[{"dataset": "group", "exampleID": 5701, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 36, "focalAPIEnd": 56, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7746/src/net/sourceforge/plantuml/command/regex/MatcherIterator.java", "rawCode": "  public String next() {\n    return matcher.group(cpt++);\n  }\n"}, {"dataset": "group", "exampleID": 5702, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(name)", "focalAPIStart": 317, "focalAPIEnd": 338, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)"], "useStart": [300], "useEnd": [339], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FenixXx/orion/tree/master/src/com/orion/parser/UrT42Parser.java", "rawCode": "  /**\n   * Helper method for BombPlanted\n   *\n   * @author Daniele Pantaleone\n   * @param matcher A <tt>Matcher</tt> object matching the log line\n   */\n  public void onBombPlanted(Matcher matcher) {\n\n    // 0:00 Bomb was planted by 3!\n    // 0:00 Bomb was planted by 11!\n\n    try {\n\n      int slot = Integer.parseInt(matcher.group(\"slot\"));\n      Client client = this.clientCtl.getBySlot(slot);\n\n      // Check to have a proper client object before the event generation\n      checkNotNull(client, \"could not retrieve client on slot %s\", slot);\n\n      this.eventBus.put(new ClientBombPlantedEvent(client));\n      this.log.trace(\"[EVENT] ClientBombPlantedEvent [ client : \" + client.getSlot() + \" ]\");\n\n    } catch (NullPointerException | InterruptedException e) {\n\n      // Logging the Exception\n      this.log.error(\"[EVENT] ClientBombPlantedEvent\", e);\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5703, "initialization": ["Matcher matcher = getStartingPattern()"], "initializationStart": [120], "initializationEnd": [140], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(matcher.find()==false)", "guardType": "IF {", "guardExpressionStart": 175, "guardExpressionEnd": 197, "guardBlockStart": 175, "guardBlockEnd": 246, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 272, "focalAPIEnd": 282, "followUpCheck": "result != null", "checkType": "IF", "followUpCheckExpressionStart": 288, "followUpCheckExpressionEnd": 306, "followUpCheckBlockStart": 288, "followUpCheckBlockEnd": 404, "use": ["result.toUpperCase()"], "useStart": [376], "useEnd": [395], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-6939/src/net/sourceforge/plantuml/command/CommandMultilinesFooter.java", "rawCode": "  public CommandExecutionResult execute(List<String> lines) {\n    StringUtils.trim(lines, false);\n    final Matcher m = getStartingPattern().matcher(lines.get(0).trim());\n    if (m.find() == false) {\n      throw new IllegalStateException();\n    }\n    final String align = m.group(1);\n    if (align != null) {\n      getSystem().setFooterAlignement(HorizontalAlignement.valueOf(align.toUpperCase()));\n    }\n    final List<String> strings = lines.subList(1, lines.size() - 1);\n    if (strings.size() > 0) {\n      getSystem().setFooter(strings);\n      return CommandExecutionResult.ok();\n    }\n    return CommandExecutionResult.error(\"Empty footer\");\n  }\n"}, {"dataset": "group", "exampleID": 5704, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [564], "initializationEnd": [590], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 598, "guardExpressionEnd": 622, "guardBlockStart": 598, "guardBlockEnd": 901, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 684, "focalAPIEnd": 702, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["equals(result)", "matcher.group(int)"], "useStart": [670, 861], "useEnd": [703, 879], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/smarr/caliper/tree/master/caliper/src/main/java/com/google/caliper/bridge/LogMessageParser.java", "rawCode": "  @Override\n  public LogMessage parse(CharSequence text) {\n    // TODO(gak): do this stuff in terms of CharSequence instead of String\n    String string = text.toString();\n    if (string.startsWith(CONTROL_PREFIX)) {\n      ImmutableList<String> parts =\n          ImmutableList.copyOf(\n              CONTROL_TYPE_SPLITTER.split(string.substring(CONTROL_PREFIX.length())));\n      Class<? extends CaliperControlLogMessage> messageType = typeMap.inverse().get(parts.get(0));\n      return gson.fromJson(parts.get(1), messageType);\n    } else {\n      Matcher gcMatcher = GC_PATTERN.matcher(string);\n      if (gcMatcher.matches()) {\n        return new GcLogMessage(\n            \"Full\".equals(gcMatcher.group(1))\n                ? GcLogMessage.Type.FULL\n                : GcLogMessage.Type.INCREMENTAL,\n            ShortDuration.of(BigDecimal.valueOf(Double.parseDouble(gcMatcher.group(2))), SECONDS));\n      }\n      Matcher jitMatcher = JIT_PATTERN.matcher(string);\n      if (jitMatcher.matches()) {\n        return new HotspotLogMessage();\n      }\n      Matcher vmOptionMatcher = VM_OPTION_PATTERN.matcher(string);\n      if (vmOptionMatcher.matches()) {\n        return new VmOptionLogMessage(vmOptionMatcher.group(2), vmOptionMatcher.group(3));\n      }\n      return new GenericLogMessage();\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5705, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [530], "initializationEnd": [573], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 579, "guardExpressionEnd": 603, "guardBlockStart": 579, "guardBlockEnd": 1055, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 645, "focalAPIEnd": 666, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Pattern.matcher(result)"], "useStart": [828], "useEnd": [884], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/epabst/sonar-plugins/tree/master/dotnet/tools/dotnet-tools-commons/src/main/java/org/sonar/dotnet/tools/commons/visualstudio/ModelFactory.java", "rawCode": "  private static List<String> getBuildConfigurations(String solutionContent) {\n    // A pattern to extract the build configurations from a visual studio solution\n    String confExtractExp =\n        \"(\\tGlobalSection\\\\(SolutionConfigurationPlatforms\\\\).*?^\\tEndGlobalSection$)\";\n    Pattern confExtractPattern =\n        Pattern.compile(confExtractExp, Pattern.MULTILINE + Pattern.DOTALL);\n    List<String> buildConfigurations = new ArrayList<String>();\n    // Extracts all the projects from the solution\n    Matcher blockMatcher = confExtractPattern.matcher(solutionContent);\n    if (blockMatcher.find()) {\n      String buildConfigurationBlock = blockMatcher.group(1);\n      String buildConfExtractExp = \" = (.*)\\\\|\";\n      Pattern buildConfExtractPattern = Pattern.compile(buildConfExtractExp);\n      Matcher buildConfMatcher = buildConfExtractPattern.matcher(buildConfigurationBlock);\n      while (buildConfMatcher.find()) {\n        String buildConfiguration = buildConfMatcher.group(1);\n        buildConfigurations.add(buildConfiguration);\n      }\n    }\n    return buildConfigurations;\n  }\n"}, {"dataset": "group", "exampleID": 5706, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [128], "initializationEnd": [147], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 153, "guardExpressionEnd": 169, "guardBlockStart": 153, "guardBlockEnd": 361, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 205, "focalAPIEnd": 215, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)"], "useStart": [188], "useEnd": [216], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/weissjeffm/webui-framework/tree/master/src/com/redhat/qe/auto/selenium/CombinedLocatorTemplate.java", "rawCode": "  protected static String increment(int count, String template) {\n    Pattern p = Pattern.compile(\"\\\\$(\\\\d+)\");\n    Matcher m = p.matcher(template);\n    while (m.find()) {\n      int num = Integer.parseInt(m.group(1));\n      int newNum = num + count;\n      template = template.replaceAll(\"\\\\$\" + num, \"\\\\$\" + newNum);\n      // System.out.println(template);\n    }\n    return template;\n  }\n"}, {"dataset": "group", "exampleID": 5707, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [60], "initializationEnd": [87], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(matcher.find()==false)", "guardType": "IF {", "guardExpressionStart": 93, "guardExpressionEnd": 115, "guardBlockStart": 93, "guardBlockEnd": 139, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 168, "focalAPIEnd": 178, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)"], "useStart": [151], "useEnd": [179], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7931/src/net/sourceforge/plantuml/graphic/Img.java", "rawCode": "  static int getVspace(String html) {\n    final Matcher m = vspacePattern.matcher(html);\n    if (m.find() == false) {\n      return 0;\n    }\n    return Integer.parseInt(m.group(1));\n  }\n"}, {"dataset": "group", "exampleID": 5708, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [474], "initializationEnd": [500], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 425, "tryExpressionEnd": 429, "tryBlockStart": 425, "tryBlockEnd": 1128, "catchExpressionStart": 1012, "catchExpressionEnd": 1032, "catchBlockStart": 1012, "catchBlockEnd": 1128, "exceptionHandlingCallStart": [1042], "exceptionHandlingCallEnd": [1119], "configuration": ["matcher.reset(String)", "matcher.end()"], "configurationStart": [593, 837], "configurationEnd": [606, 844], "guardCondition": "matcher.find() && !(!(matcher.find()))", "guardType": "LOOP {", "guardExpressionStart": 671, "guardExpressionEnd": 687, "guardBlockStart": 671, "guardBlockEnd": 914, "focalAPI": "result = matcher.group()", "focalAPIStart": 877, "focalAPIEnd": 886, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["checkTag(result,StringBuilder)"], "useStart": [868], "useEnd": [902], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/KNL-945/kernel-impl/src/main/java/org/sakaiproject/util/impl/FormattedTextImpl.java", "rawCode": "  private String processHtml(final String source, StringBuilder errorMessages) {\n    if (M_evilTags == null) init();\n\n    // normalize all variants of the \"<br>\" HTML tag to be \"<br />\\n\"\n    // TODO call a method to do this in each process routine\n    String Html = M_patternTagBr.matcher(source).replaceAll(\"<br />\");\n\n    // process text and tags\n    StringBuilder buf = new StringBuilder();\n    if (Html != null) {\n      try {\n        int start = 0;\n        Matcher m = M_patternTag.matcher(Html);\n\n        // if there are no tags, return as is\n        if (!m.find()) return Html;\n        m.reset(Html);\n\n        // if there are tags, make sure they are safe\n        while (m.find()) {\n          // append text that isn't part of a tag\n          if (m.start() > start) buf.append(Html.substring(start, m.start()));\n          start = m.end();\n\n          buf.append(checkTag(m.group(), errorMessages));\n        }\n\n        // tail\n        if (Html.length() > start) buf.append(Html.substring((start)));\n      } catch (Exception e) {\n        M_log.warn(\"FormattedText.processEscapedHtml M_patternTag.matcher(Html):\", e);\n      }\n    }\n    return String.valueOf(buf.toString());\n  }\n"}, {"dataset": "group", "exampleID": 5709, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [98], "initializationEnd": [119], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "group<=matcher.groupCount() && !(matcher.find()==false)", "guardType": "IF {", "guardExpressionStart": 125, "guardExpressionEnd": 147, "guardBlockStart": 125, "guardBlockEnd": 174, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 297, "focalAPIEnd": 307, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(result)"], "useStart": [286], "useEnd": [308], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7876/src/net/sourceforge/plantuml/StringUtils.java", "rawCode": "  public static final List<String> getSplit(Pattern pattern, String line) {\n    final Matcher m = pattern.matcher(line);\n    if (m.find() == false) {\n      return null;\n    }\n    final List<String> result = new ArrayList<String>();\n    for (int i = 1; i <= m.groupCount(); i++) {\n      result.add(m.group(i));\n    }\n    return result;\n  }\n"}, {"dataset": "group", "exampleID": 5710, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [272], "initializationEnd": [288], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.find()"], "configurationStart": [305], "configurationEnd": [313], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group()", "focalAPIStart": 333, "focalAPIEnd": 342, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["String.indexOf(result)", "format(String,result,String)"], "useStart": [360, 405], "useEnd": [378, 451], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thesmith/eventhorizon/tree/master/src/test/java/thesmith/eventhorizon/service/SocialGraphApiServiceImplTest.java", "rawCode": "  @Test\n  public void shouldReplaceLink() throws Exception {\n    String tweet = \"Panic Status Board: http://bit.ly/aTs0uZ\";\n    Pattern p =\n        Pattern.compile(\n            \"\\\\b(https?|ftp|file)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]\");\n    Matcher m = p.matcher(tweet);\n    assertTrue(m.find());\n    String url = m.group();\n    int start = tweet.indexOf(url);\n    String replacement = String.format(\"<a href='%s'>%s</a>\", url, url);\n    String beginning = tweet.substring(0, start);\n    String end = tweet.substring(start + url.length());\n    tweet = beginning + replacement + end;\n\n    System.err.println(tweet);\n    assertTrue(tweet.contains(\"<a href\"));\n  }\n"}, {"dataset": "group", "exampleID": 5711, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "group<=n", "guardType": "LOOP {", "guardExpressionStart": 349, "guardExpressionEnd": 377, "guardBlockStart": 349, "guardBlockEnd": 415, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 396, "focalAPIEnd": 406, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xiaoxiang88888888/xiaoxiang88888888/tree/master/ticket/src/main/java/com/xiaoxiang/ticket/util/StringUtil.java", "rawCode": "  /**\n   * 正则匹配\n   *\n   * @param s\n   * @param pattern\n   * @return\n   */\n  public static List<String[]> matchAll(String s, String pattern) {\n    Matcher m = Pattern.compile(pattern).matcher(s);\n    List<String[]> result = new ArrayList<String[]>();\n\n    while (m.find()) {\n      int n = m.groupCount();\n      String[] ss = new String[n + 1];\n      for (int i = 0; i <= n; i++) {\n        ss[i] = m.group(i);\n      }\n      result.add(ss);\n    }\n    return result;\n  }\n"}, {"dataset": "group", "exampleID": 5712, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [242], "initializationEnd": [258], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.find()"], "configurationStart": [332], "configurationEnd": [340], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 383, "focalAPIEnd": 393, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [414, 443, 469], "useEnd": [424, 453, 479], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CS340Group/hit/tree/master/src/common/util/QueryParser.java", "rawCode": "  /**\n   * Helper method to parse out the required fields in the query. Expects the query to look like:\n   * obj.attr = value\n   */\n  private void Parse() {\n    Pattern p = Pattern.compile(\"((\\\\w*)\\\\.)?(\\\\w*)\\\\s(.*)\\\\s(.*)\");\n    Matcher m = p.matcher(query);\n    OperatorFactory c = new OperatorFactory();\n    boolean matchFound = m.find();\n    if (matchFound) {\n      objectName = m.group(2);\n      objectAttr = m.group(3);\n      operator = m.group(4);\n      value = m.group(5);\n    } else {\n      // If match isn't found then the query is in the wrong form.\n      assert (matchFound == true);\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5713, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 82, "focalAPIEnd": 92, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["undefine(result)"], "useStart": [65], "useEnd": [93], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7936/src/net/sourceforge/plantuml/preproc/Preprocessor.java", "rawCode": "  private String manageUndef(Matcher m) throws IOException {\n    defines.undefine(m.group(1));\n    return this.readLine();\n  }\n"}, {"dataset": "group", "exampleID": 5714, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [481], "initializationEnd": [507], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 432, "tryExpressionEnd": 436, "tryBlockStart": 432, "tryBlockEnd": 1135, "catchExpressionStart": 1019, "catchExpressionEnd": 1039, "catchBlockStart": 1019, "catchBlockEnd": 1135, "exceptionHandlingCallStart": [1049], "exceptionHandlingCallEnd": [1126], "configuration": ["matcher.reset(String)", "matcher.end()"], "configurationStart": [600, 844], "configurationEnd": [613, 851], "guardCondition": "matcher.find() && !(!(matcher.find()))", "guardType": "LOOP {", "guardExpressionStart": 678, "guardExpressionEnd": 694, "guardBlockStart": 678, "guardBlockEnd": 921, "focalAPI": "result = matcher.group()", "focalAPIStart": 884, "focalAPIEnd": 893, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["checkTag(result,StringBuilder)"], "useStart": [875], "useEnd": [909], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.7/kernel-util/src/main/java/org/sakaiproject/util/FormattedText.java", "rawCode": "  private static String processHtml(final String source, StringBuilder errorMessages) {\n    if (M_evilTags == null) init();\n\n    // normalize all variants of the \"<br>\" HTML tag to be \"<br />\\n\"\n    // TODO call a method to do this in each process routine\n    String Html = M_patternTagBr.matcher(source).replaceAll(\"<br />\");\n\n    // process text and tags\n    StringBuilder buf = new StringBuilder();\n    if (Html != null) {\n      try {\n        int start = 0;\n        Matcher m = M_patternTag.matcher(Html);\n\n        // if there are no tags, return as is\n        if (!m.find()) return Html;\n        m.reset(Html);\n\n        // if there are tags, make sure they are safe\n        while (m.find()) {\n          // append text that isn't part of a tag\n          if (m.start() > start) buf.append(Html.substring(start, m.start()));\n          start = m.end();\n\n          buf.append(checkTag(m.group(), errorMessages));\n        }\n\n        // tail\n        if (Html.length() > start) buf.append(Html.substring((start)));\n      } catch (Exception e) {\n        M_log.warn(\"FormattedText.processEscapedHtml M_patternTag.matcher(Html):\", e);\n      }\n    }\n    return String.valueOf(buf.toString());\n  }\n"}, {"dataset": "group", "exampleID": 5715, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [399], "initializationEnd": [422], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find() && !(true||sValue.indexOf(sBorder,)==-group)", "guardType": "IF {", "guardExpressionStart": 186, "guardExpressionEnd": 240, "guardBlockStart": 186, "guardBlockEnd": 248, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 467, "focalAPIEnd": 477, "followUpCheck": "result.equals(\"\")", "checkType": "IF", "followUpCheckExpressionStart": 485, "followUpCheckExpressionEnd": 505, "followUpCheckBlockStart": 485, "followUpCheckBlockEnd": 1209, "use": ["matcher.appendReplacement(StringBuffer,String)", "Map.get(result)", "matcher.appendReplacement(StringBuffer,String)", "matcher.appendReplacement(StringBuffer,String)", "matcher.appendTail(StringBuffer)"], "useStart": [506, 588, 636, 794, 1220], "useEnd": [544, 606, 691, 827, 1242], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1_9_1/trunk-archive/src/util/xml/XML.java", "rawCode": "  private static void replaceNodeTokens(Text t, String sBorder, Map mReplace) {\n    // Get value and look for tokens. If there aren't any, bail now.\n    String sValue = t.getData();\n    if (mReplace == null || sValue.indexOf(sBorder) == -1) return;\n\n    StringBuffer sbBefore = new StringBuffer();\n\n    Pattern pTokens = Pattern.compile(sBorder + \"(.*?)\" + sBorder, Pattern.DOTALL);\n    Matcher m = pTokens.matcher(sValue);\n    while (m.find()) {\n      String sKey = m.group(1);\n      if (sKey.equals(\"\")) m.appendReplacement(sbBefore, sBorder);\n      else {\n        Node nMatch = (Node) mReplace.get(sKey);\n        if (nMatch == null) m.appendReplacement(sbBefore, sBorder + sKey + sBorder);\n        else {\n          // OK, found a token. Get everything before it into the buffer...\n          m.appendReplacement(sbBefore, \"\");\n          // ...create a new text node with the 'before' text...\n          Text tBefore = t.getOwnerDocument().createTextNode(sbBefore.toString());\n          t.getParentNode().insertBefore(tBefore, t);\n          sbBefore.setLength(0);\n          // ...add the new node...\n          t.getParentNode().insertBefore(t.getOwnerDocument().importNode(nMatch, true), t);\n        }\n      }\n    }\n    m.appendTail(sbBefore);\n    t.setData(sbBefore.toString());\n  }\n"}, {"dataset": "group", "exampleID": 5716, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [737], "initializationEnd": [784], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 603, "tryExpressionEnd": 607, "tryBlockStart": 603, "tryBlockEnd": 1391, "catchExpressionStart": 1311, "catchExpressionEnd": 1331, "catchBlockStart": 1311, "catchBlockEnd": 1391, "exceptionHandlingCallStart": [1339], "exceptionHandlingCallEnd": [1384], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 821, "guardExpressionEnd": 847, "guardBlockStart": 821, "guardBlockEnd": 1030, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 872, "focalAPIEnd": 895, "followUpCheck": "!result.equals(\"group/\")", "checkType": "IF", "followUpCheckExpressionStart": 948, "followUpCheckExpressionEnd": 975, "followUpCheckBlockStart": 948, "followUpCheckBlockEnd": 1022, "use": ["matcher.group(int)"], "useStart": [915], "useEnd": [938], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0-rc01/kernel-impl/src/main/java/org/sakaiproject/content/impl/serialize/impl/conversion/Type1BlobResourcesConversionHandler.java", "rawCode": "  public boolean convertSource(String id, Object source, PreparedStatement updateRecord)\n      throws SQLException {\n\n    String xml = (String) source;\n\n    SAXSerializableResourceAccess sax = new SAXSerializableResourceAccess();\n    SAXSerializableResourceAccess sax2 = new SAXSerializableResourceAccess();\n    try {\n      sax.parse(xml);\n    } catch (Exception e1) {\n      log.warn(\"Failed to parse \" + id + \"[\" + xml + \"]\", e1);\n      return false;\n    }\n\n    Type1BaseContentResourceSerializer t1b = new Type1BaseContentResourceSerializer();\n    t1b.setTimeService(new ConversionTimeService());\n    try {\n      byte[] result = t1b.serialize(sax);\n      t1b.parse(sax2, result);\n      sax.check(sax2);\n\n      Matcher contextMatcher = contextPattern.matcher(sax.getSerializableId());\n      String context = null;\n      if (contextMatcher.find()) {\n        String root = contextMatcher.group(1);\n        context = contextMatcher.group(2);\n        if (!root.equals(\"group/\")) {\n          context = \"~\" + context;\n        }\n      }\n\n      updateRecord.setString(1, context);\n      updateRecord.setLong(2, sax.getSerializableContentLength());\n      updateRecord.setBytes(3, result);\n      updateRecord.setString(4, sax.getSerializableResourceType());\n      updateRecord.setString(5, id);\n      return true;\n    } catch (Exception e) {\n      log.warn(\"Failed to process record \" + id, e);\n    }\n    return false;\n  }\n"}, {"dataset": "group", "exampleID": 5717, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [133], "initializationEnd": [156], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 196, "guardExpressionEnd": 218, "guardBlockStart": 196, "guardBlockEnd": 260, "focalAPI": "result = matcher.group()", "focalAPIStart": 237, "focalAPIEnd": 252, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(result)"], "useStart": [227], "useEnd": [253], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spring-projects/eclipse-integration-gradle/tree/master/org.springsource.ide.eclipse.gradle.core/src/org/springsource/ide/eclipse/gradle/core/launch/GradleLaunchConfigurationDelegate.java", "rawCode": "  private static List<String> parseTasks(String tasksText) {\n    List<String> tasks = new ArrayList<String>();\n    Matcher matcher = Pattern.compile(\"\\\\S+\").matcher(tasksText); // $NON-NLS-1$\n    while (matcher.find()) {\n      tasks.add(matcher.group());\n    }\n    return tasks;\n  }\n"}, {"dataset": "group", "exampleID": 5718, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [96], "initializationEnd": [115], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 277, "focalAPIEnd": 287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Top-Q/jsystem/tree/master/jsystem-core-projects/jsystemCommon/src/main/java/jsystem/extensions/analyzers/text/GetParameterValue.java", "rawCode": "  public void analyze() {\n    Pattern p = null;\n    p = Pattern.compile(regEx);\n    Matcher m = p.matcher(testText);\n    message = testText;\n    if (!m.find()) {\n      status = false;\n      title = \"GetParameterValue is not found: \" + toFind;\n      return;\n    }\n    counter = m.group(1);\n\n    title = \"Get parameter value: \" + counter;\n    status = true;\n  }\n"}, {"dataset": "group", "exampleID": 5719, "initialization": ["Matcher matcher = counterPattern(String)"], "initializationStart": [151], "initializationEnd": [178], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 208, "guardExpressionEnd": 223, "guardBlockStart": 208, "guardBlockEnd": 258, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 239, "focalAPIEnd": 251, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nourlcn/yarn-comment/tree/master/hadoop-tools/hadoop-rumen/src/main/java/org/apache/hadoop/tools/rumen/HadoopLogsAnalyzer.java", "rawCode": "  private String parseCounter(String counterString, String counterName) {\n    if (counterString == null) {\n      return null;\n    }\n\n    Matcher mat = counterPattern(counterName).matcher(counterString);\n\n    if (mat.find()) {\n      return mat.group(1);\n    }\n\n    return null;\n  }\n"}, {"dataset": "group", "exampleID": 5720, "initialization": ["Matcher matcher = getStartingPattern()"], "initializationStart": [120], "initializationEnd": [140], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(matcher.find()==false)", "guardType": "IF {", "guardExpressionStart": 175, "guardExpressionEnd": 197, "guardBlockStart": 175, "guardBlockEnd": 246, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 272, "focalAPIEnd": 282, "followUpCheck": "result != null", "checkType": "IF", "followUpCheckExpressionStart": 288, "followUpCheckExpressionEnd": 306, "followUpCheckBlockStart": 288, "followUpCheckBlockEnd": 404, "use": ["result.toUpperCase()"], "useStart": [376], "useEnd": [395], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7481/src/net/sourceforge/plantuml/command/CommandMultilinesFooter.java", "rawCode": "  public CommandExecutionResult execute(List<String> lines) {\n    StringUtils.trim(lines, false);\n    final Matcher m = getStartingPattern().matcher(lines.get(0).trim());\n    if (m.find() == false) {\n      throw new IllegalStateException();\n    }\n    final String align = m.group(1);\n    if (align != null) {\n      getSystem().setFooterAlignement(HorizontalAlignement.valueOf(align.toUpperCase()));\n    }\n    final List<String> strings = lines.subList(1, lines.size() - 1);\n    if (strings.size() > 0) {\n      getSystem().setFooter(strings);\n      return CommandExecutionResult.ok();\n    }\n    return CommandExecutionResult.error(\"Empty footer\");\n  }\n"}, {"dataset": "group", "exampleID": 5721, "initialization": ["Matcher matcher = matcher(String)"], "initializationStart": [1030], "initializationEnd": [1069], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches() && !(iChar==-group)", "guardType": "IF {", "guardExpressionStart": 856, "guardExpressionEnd": 872, "guardBlockStart": 856, "guardBlockEnd": 929, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1130, "focalAPIEnd": 1140, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)", "matcher.group(int)"], "useStart": [1113, 1388], "useEnd": [1141, 1404], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.7.2/trunk/src/om/loadtest/TNTester.java", "rawCode": "  private void sendRequestGetMedia(int iServer, Map mTokens, HttpScript.Item i, StepStats ss)\n      throws IOException {\n    if (DEBUG) System.err.print(\" \" + i.getURL());\n    ss.sPath = i.getURL();\n    long lBefore = System.currentTimeMillis();\n\n    Socket s = new Socket(HOSTS[iServer], PORTS[iServer]);\n    // Again with the dodgy charset assumptions\n    OutputStreamWriter osw = new OutputStreamWriter(s.getOutputStream());\n    String sRequest = i.getRequest();\n    sRequest = XML.replaceTokens(sRequest, \"%%\", mTokens).replaceAll(\"HTTP/1.1\", \"HTTP/1.0\");\n    osw.write(sRequest + \"\\r\\n\");\n    if (i.getData() != null) osw.write(i.getData());\n    osw.flush();\n\n    // Get input\n    InputStream is = s.getInputStream();\n    String sLine = \"\";\n    int iContentLength = -1;\n    boolean bFirst = true;\n    while (true) {\n      int iChar = is.read();\n      if (iChar == -1) throw new IOException(\"Unexpected EOF in socket input\");\n      if (iChar == 10) {\n        if (sLine.equals(\"\")) break; // End of headers\n        Matcher m = HttpScript.CONTENTLENGTH.matcher(sLine);\n        if (m.matches()) iContentLength = Integer.parseInt(m.group(1));\n        if (bFirst) {\n          bFirst = false;\n          Matcher mStatus = HttpScript.STATUSCODE.matcher(sLine);\n          if (!mStatus.matches()) throw new IOException(\"Unexpected HTTP status format: \" + sLine);\n          if (Integer.parseInt(mStatus.group(1)) != i.getExpectedResponse())\n            throw new IOException(\n                \"Unexpected response code: \"\n                    + sLine\n                    + \" (expecting \"\n                    + i.getExpectedResponse()\n                    + \")\\n\"\n                    + IO.loadString(is));\n        }\n        // System.err.println(sLine);\n        sLine = \"\";\n      } else if (iChar != 13) {\n        sLine += (char) iChar;\n      }\n    }\n\n    byte[] abData;\n    if (iContentLength != -1) {\n      abData = new byte[iContentLength];\n      for (int iRead = 0; iRead < abData.length; ) {\n        int iThisTime = is.read(abData, iRead, abData.length - iRead);\n        if (iThisTime == -1) throw new IOException(\"Didn't get all data\");\n        iRead += iThisTime;\n      }\n    } else {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      while (true) {\n        int iRead = is.read();\n        if (iRead == -1) break;\n        baos.write(iRead);\n      }\n      abData = baos.toByteArray();\n    }\n    s.close();\n\n    ss.lTime = System.currentTimeMillis() - lBefore;\n    if (DEBUG) {\n      System.err.print(\" [\" + abData.length + \" bytes]\");\n      System.err.println(\" (\" + ss.lTime + \" ms)\");\n    }\n\n    // OK now go through looking for *.gif, jpg, .css, .png\n    String sContent = new String(abData);\n    Set<String> sDone = new HashSet<String>();\n    Matcher m = MEDIALINK.matcher(sContent);\n    while (m.find()) {\n      String sURL = m.group(1);\n      if (sDone.contains(sURL)) continue;\n      sDone.add(sURL);\n\n      sURL =\n          \"http://\"\n              + HOSTS[iServer]\n              + (PORTS[iServer] != 80 ? (\":\" + PORTS[iServer]) : \"\")\n              + \"/om-tn/simple1/\"\n              + sURL;\n      sURL = sURL.replaceAll(\"simple1/../\", \"\");\n\n      loadMedia(mTokens, new URL(sURL), ss);\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5722, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [63], "initializationEnd": [86], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 92, "guardExpressionEnd": 105, "guardBlockStart": 92, "guardBlockEnd": 155, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 137, "focalAPIEnd": 147, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["valueOf(result)"], "useStart": [121], "useEnd": [148], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sages-health/sagesmobile-mReceive/tree/master/rapidjava/org.rapidsms.java/src/org/rapidsms/java/core/parser/interpreter/IntegerInterpreter.java", "rawCode": "  public Object interpretValue(String token) {\n    Matcher m = mPattern.matcher(token);\n    if (m.find()) {\n      return Integer.valueOf(m.group(0));\n    }\n    return null;\n  }\n"}, {"dataset": "group", "exampleID": 5723, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [98], "initializationEnd": [119], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "group<=matcher.groupCount() && !(matcher.find()==false)", "guardType": "IF {", "guardExpressionStart": 125, "guardExpressionEnd": 147, "guardBlockStart": 125, "guardBlockEnd": 174, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 297, "focalAPIEnd": 307, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(result)"], "useStart": [286], "useEnd": [308], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7475/src/net/sourceforge/plantuml/StringUtils.java", "rawCode": "  public static final List<String> getSplit(Pattern pattern, String line) {\n    final Matcher m = pattern.matcher(line);\n    if (m.find() == false) {\n      return null;\n    }\n    final List<String> result = new ArrayList<String>();\n    for (int i = 1; i <= m.groupCount(); i++) {\n      result.add(m.group(i));\n    }\n    return result;\n  }\n"}, {"dataset": "group", "exampleID": 5724, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 473, "focalAPIEnd": 483, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.13/trunk-archive/src/om/devservlet/DevServlet.java", "rawCode": "  private void handleQuestion(\n      String idVersion, HttpServletRequest request, HttpServletResponse response) throws Exception {\n    Matcher m = QUESTIONID_REGEXP.matcher(idVersion);\n    if (!m.matches()) {\n      sendError(\n          request,\n          response,\n          HttpServletResponse.SC_NOT_FOUND,\n          \"Not found\",\n          \"Not a valid question id-version.\",\n          null);\n    }\n    File file = new File(getServletContext().getRealPath(\"questions\"), m.group(1) + \".jar\");\n\n    // Check that the requested file exits.\n    if (!file.exists()) {\n      sendError(\n          request,\n          response,\n          HttpServletResponse.SC_NOT_FOUND,\n          \"Not found\",\n          \"The requested question is not present on this server.\",\n          null);\n    }\n\n    // Then send it.\n    byte[] abQuestion = IO.loadBytes(new FileInputStream(file));\n    response.setContentType(\"application/x-openmark\");\n    response.setContentLength(abQuestion.length);\n    OutputStream os = response.getOutputStream();\n    os.write(abQuestion);\n    os.close();\n  }\n"}, {"dataset": "group", "exampleID": 5725, "initialization": ["Matcher matcher = matcher(*)", "Matcher matcher = matcher(*)"], "initializationStart": [153, 947], "initializationEnd": [187, 981], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()"], "configurationStart": [987], "configurationEnd": [998], "guardCondition": "!(matcher.matches())", "guardType": "IF {", "guardExpressionStart": 235, "guardExpressionEnd": 251, "guardBlockStart": 235, "guardBlockEnd": 816, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1038, "focalAPIEnd": 1048, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "new AwayEventImpl(result,*,boolean,boolean,*,*,Session)"], "useStart": [1129, 1011], "useEnd": [1139, 1190], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chrizmo/SeljeIRC/tree/master/src/jerklib/parsers/AwayParser.java", "rawCode": "  public IRCEvent createEvent(EventToken token, IRCEvent event) {\n    Pattern p = Pattern.compile(\"^:\\\\S+\\\\s\\\\d{3}\\\\s+(\\\\S+)\\\\s:(.*)$\");\n    Matcher m = p.matcher(event.getRawEventData());\n    Session session = event.getSession();\n    if (m.matches()) {\n      switch (Integer.parseInt(token.command())) {\n        case 305:\n          return new AwayEventImpl(\n              session,\n              EventType.RETURNED_FROM_AWAY,\n              false,\n              true,\n              session.getNick(),\n              event.getRawEventData());\n        case 306:\n          {\n            return new AwayEventImpl(\n                session,\n                EventType.WENT_AWAY,\n                true,\n                true,\n                session.getNick(),\n                event.getRawEventData());\n          }\n      }\n    }\n\n    // :card.freenode.net 301 r0bby_ r0bby :foo\n    p = Pattern.compile(\"^:\\\\S+\\\\s+\\\\d{3}\\\\s+\\\\S+\\\\s+(\\\\S+)\\\\s+:(.*)$\");\n    m = p.matcher(event.getRawEventData());\n    m.matches();\n    return new AwayEventImpl(\n        m.group(2),\n        AwayEvent.EventType.USER_IS_AWAY,\n        true,\n        false,\n        m.group(1),\n        event.getRawEventData(),\n        session);\n  }\n"}, {"dataset": "group", "exampleID": 5726, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.reset(String)"], "configurationStart": [195], "configurationEnd": [214], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 224, "guardExpressionEnd": 246, "guardBlockStart": 224, "guardBlockEnd": 444, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 276, "focalAPIEnd": 292, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["put(String,result)", "matcher.group(int)", "matcher.group(int)"], "useStart": [259, 322, 366], "useEnd": [293, 338, 382], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/araqne/logdb/tree/master/araqne-logdb/src/main/java/org/araqne/logdb/metadata/LogMetadataProvider.java", "rawCode": "    private Row buildRow(Log log) {\n      String line = (String) log.getParams().get(\"line\");\n      Row row = new Row();\n      row.put(\"_time\", log.getDate());\n\n      if (line != null) {\n        matcher.reset(line);\n        if (matcher.matches()) {\n          row.put(\"level\", matcher.group(1));\n          row.put(\"class\", matcher.group(2));\n          row.put(\"msg\", matcher.group(3));\n        } else {\n          row.put(\"line\", line);\n        }\n      }\n\n      return row;\n    }\n"}, {"dataset": "group", "exampleID": 5727, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [58], "initializationEnd": [70], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 76, "guardExpressionEnd": 92, "guardBlockStart": 76, "guardBlockEnd": 125, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 108, "focalAPIEnd": 118, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-6939/src/net/sourceforge/plantuml/code/ArobaseStringCompressor.java", "rawCode": "  private String clean1(String s) {\n    final Matcher m = p.matcher(s);\n    if (m.matches()) {\n      return m.group(2);\n    }\n    return s;\n  }\n"}, {"dataset": "group", "exampleID": 5728, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(matcher).matches()", "guardType": "IF {", "guardExpressionStart": 500, "guardExpressionEnd": 548, "guardBlockStart": 500, "guardBlockEnd": 2193, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 565, "focalAPIEnd": 581, "followUpCheck": "line.equals(result)", "checkType": "IF", "followUpCheckExpressionStart": 771, "followUpCheckExpressionEnd": 792, "followUpCheckBlockStart": 771, "followUpCheckBlockEnd": 2185, "use": ["new Tld(result)", "HashMap<String, Tld>.put(result,Tld)"], "useStart": [601, 623], "useEnd": [613, 645], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/researchstudio-sat/ldspider4won/tree/master/src/com/ontologycentral/ldspider/tld/TldManager.java", "rawCode": "  private void readList(InputStream is) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(is));\n    String line;\n    Pattern newTldP = Pattern.compile(\"// ([a-z][a-z]+) : .*\");\n    Matcher newTldM;\n    Tld current = null;\n    String tld = \"\";\n\n    while ((line = in.readLine()) != null) {\n      if (line.trim().isEmpty()) {\n        continue;\n      }\n\n      // if we come to a new section for a new tld\n      // e.g. \"//ie : http://en.wikipedia.org/wiki/.ie\"\n      if ((newTldM = newTldP.matcher(line)).matches()) {\n        tld = newTldM.group(1);\n        current = new Tld(tld);\n        TLDs.put(tld, current);\n      } else if (current != null) {\n        // if line is stating that suffix can be one-level\n        // e.g. \"ie\"\n        if (line.equals(tld)) {\n          current.setHasOneLvlSffxes();\n        }\n        // if line is stating that any two-level suffix can be a suffix\n        // e.g. \"*.au\"\n        else if (line.equals(\"*.\" + tld)) {\n          current.setHasTwoLvlSffxes();\n        }\n        // if line is stating additional two-level suffix\n        // e.g. \"com.fr\"\n        else if (line.matches(\"[a-z0-9-]+\\\\.\" + tld)) {\n          current.addAddlTwoLvlSffx(line);\n        }\n        // if line is stating additional three-level suffix\n        // e.g. \"nsw.edu.au\"\n        else if (line.matches(\"[a-z0-9-]+\\\\.[a-z0-9-]+\\\\.\" + tld)) {\n          current.addAddlThreeLvlSffx(line);\n        }\n        // if line is stating exceptional two-level domain\n        // e.g. \"!bl.uk\"\n        else if (line.matches(\"![a-z0-9-]+\\\\.\" + tld)) {\n          current.addExcptnlTwoLvlDomain(line.substring(1, line.length()));\n        }\n        // if line is stating that for some two-levels any three-level can be a suffix\n        // e.g. \"*.sch.uk\"\n        else if (line.matches(\"\\\\*\\\\.[a-z0-9-]+\\\\.\" + tld)) {\n          current.addAddlWildcardThreeLvlSffx(line.substring(2, line.length()));\n        }\n        // if line is stating exceptional three-level domain\n        // e.g. \"!metro.tokyo.jp\"\n        else if (line.matches(\"![a-z0-9-]+\\\\.[a-z0-9-]+\\\\.\" + tld)) {\n          current.addExcptnlThreeLvlDomain(line.substring(1, line.length()));\n        }\n      }\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5729, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [402], "initializationEnd": [441], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 447, "guardExpressionEnd": 469, "guardBlockStart": 447, "guardBlockEnd": 545, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 503, "focalAPIEnd": 519, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "new FactoidSearch(result,*)"], "useStart": [521, 485], "useEnd": [537, 538], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/UWCS/choob/tree/master/src/main/plugins/Factoids2.java", "rawCode": "  private FactoidSearch getFactoidSearch(final Message mes) {\n    final String[] params1 = mods.util.getParamArray(mes, 2);\n\n    if (params1.length == 2) {\n      return new FactoidSearch(params1[1]);\n    }\n    if (params1.length <= 1) {\n      return null;\n    }\n\n    final String[] params2 = mods.util.getParamArray(mes, 1);\n\n    // If they have used quotes, split on that.\n    final Matcher mQuoted = quotedSearchPattern.matcher(params2[1]);\n    if (mQuoted.matches()) {\n      return new FactoidSearch(mQuoted.group(1), mQuoted.group(2));\n    }\n\n    // If there's a regexp search, split on that.\n    final Matcher mRegExp = regexpSearchPattern.matcher(params2[1]);\n    if (mRegExp.matches()) {\n      return new FactoidSearch(mRegExp.group(1), mRegExp.group(2));\n    }\n\n    // If they have used is/are, split on that.\n    final Matcher mIsAre = addDefinitionPattern.matcher(params2[1]);\n    if (mIsAre.matches()) {\n      return new FactoidSearch(mIsAre.group(1), mIsAre.group(2));\n    }\n\n    // Default to first word + rest split.\n    return new FactoidSearch(params1[1], params1[2]);\n  }\n"}, {"dataset": "group", "exampleID": 5730, "initialization": ["Matcher matcher = matcher(String)"], "initializationStart": [541], "initializationEnd": [577], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 730, "guardExpressionEnd": 792, "guardBlockStart": 730, "guardBlockEnd": 924, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 881, "focalAPIEnd": 913, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnmay/mdk/tree/master/io/text-parsers/src/main/java/uk/ac/ebi/mdk/io/text/brenda/PRLineParser.java", "rawCode": "  /**\n   * The contents are organised in 40 information fields as given below. Protein information is\n   * included in '#'...#', literature citations are in '<...>', commentaries in '(...)' and field-\n   * special information in '{...}'.\n   *\n   * @param line\n   * @return\n   */\n  public String parse(String line) throws IOException {\n    boolean keepParsing = true;\n    while (keepParsing) {\n      if (line.startsWith(\"PR\\t\") || line.startsWith(\"\\t\")) {\n        // if(line.contains(this.specie)) {\n        Matcher protNumberInLineMatcher = this.proteinNumPattern.matcher(line);\n        Matcher citationListMatcher = this.citationListPattern.matcher(line);\n        Matcher dbRefMatcher = this.dbRefPattern.matcher(line);\n\n        if (protNumberInLineMatcher.find() && line.startsWith(\"PR\\t\")) {\n          // protNumber.add(protNumberInLineMatcher.group(1));\n          protNumber = protNumberInLineMatcher.group(1);\n        }\n        if ((line.contains(\"<\") || line.contains(\">\")) && citationListMatcher.find()) {\n          this.citations.addAll(Arrays.asList(citationListMatcher.group(2).split(\",\")));\n        }\n        if (dbRefMatcher.find()) {\n          this.id2DbRef.put(dbRefMatcher.group(1), dbRefMatcher.group(2));\n        }\n        // } else {\n        // return this.reader.readLine();\n        // }\n        line = reader.readLine();\n        if (line.startsWith(\"PR\\t\") || line.length() < 2) return line;\n      } else {\n        return line;\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "group", "exampleID": 5731, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [117], "initializationEnd": [168], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 308, "focalAPIEnd": 318, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)", "matcher.group(int)", "matcher.group(int)"], "useStart": [291, 495, 695], "useEnd": [319, 505, 705], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/h4ck3rm1k3/josm-older/tree/master/src/org/openstreetmap/josm/gui/bbox/TileSelectionBBoxChooser.java", "rawCode": "    @Override\n    public boolean isValid() {\n      String value = getComponent().getText().trim();\n      Matcher m = Pattern.compile(\"(\\\\d+)[^\\\\d]+(\\\\d+)[^\\\\d]+(\\\\d+)\").matcher(value);\n      tileBounds = null;\n      if (!m.matches()) return false;\n      int zoom;\n      try {\n        zoom = Integer.parseInt(m.group(1));\n      } catch (NumberFormatException e) {\n        return false;\n      }\n      if (zoom < 0 || zoom > 18) return false;\n\n      int x;\n      try {\n        x = Integer.parseInt(m.group(2));\n      } catch (NumberFormatException e) {\n        return false;\n      }\n      if (x < 0 || x >= Math.pow(2, zoom - 1)) return false;\n      int y;\n      try {\n        y = Integer.parseInt(m.group(3));\n      } catch (NumberFormatException e) {\n        return false;\n      }\n      if (y < 0 || y >= Math.pow(2, zoom - 1)) return false;\n\n      tileBounds = new TileBounds(new Point(x, y), new Point(x, y), zoom);\n      return true;\n    }\n"}, {"dataset": "group", "exampleID": 5732, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [864], "initializationEnd": [905], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 927, "guardExpressionEnd": 943, "guardBlockStart": 927, "guardBlockEnd": 1022, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 977, "focalAPIEnd": 987, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)", "matcher.group(int)"], "useStart": [960, 1005], "useEnd": [988, 1015], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1_9_1/trunk-archive/src/om/graph/World.java", "rawCode": "  /**\n   * Obtains a Font object from the given string value in the format: [bold/italic] [7px] [Verdana].\n   * Leaving out any part of the string results in the defaults being used.\n   *\n   * @param sValue Input string\n   * @return Font object\n   */\n  private Font convertFont(String sValue) throws GraphFormatException {\n    // Bold/italic\n    boolean bBold = false, bItalic = false;\n    while (true) {\n      if (sValue.startsWith(\"bold\")) {\n        bBold = true;\n        sValue = sValue.substring(\"bold\".length());\n        while (sValue.startsWith(\" \")) sValue = sValue.substring(1);\n      } else if (sValue.startsWith(\"italic\")) {\n        bItalic = true;\n        sValue = sValue.substring(\"italic\".length());\n        while (sValue.startsWith(\" \")) sValue = sValue.substring(1);\n      } else break;\n    }\n\n    // Size\n    int iSize = iFontSize;\n    Matcher m = Pattern.compile(\"^([0-9]+)px(\\\\ )?(.*)$\").matcher(sValue);\n    if (m.matches()) {\n      iSize = Integer.parseInt(m.group(1));\n      sValue = m.group(3);\n    }\n\n    // Family\n    String sFamily = sFontFamily;\n    if (sValue.length() > 0) {\n      sFamily = sValue;\n    }\n\n    return new Font(sFamily, (bItalic ? Font.ITALIC : 0) | (bBold ? Font.BOLD : 0), iSize);\n  }\n"}, {"dataset": "group", "exampleID": 5733, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [499], "initializationEnd": [523], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find(start,)", "guardType": "LOOP {", "guardExpressionStart": 556, "guardExpressionEnd": 577, "guardBlockStart": 556, "guardBlockEnd": 885, "focalAPI": "result = matcher.group()", "focalAPIStart": 603, "focalAPIEnd": 612, "followUpCheck": "result.equals(\"0.0.0.0\")", "checkType": "IF", "followUpCheckExpressionStart": 649, "followUpCheckExpressionEnd": 689, "followUpCheckBlockStart": 649, "followUpCheckBlockEnd": 844, "use": ["getByName(result)", "matcher.end()"], "useStart": [805, 863], "useEnd": [831, 870], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tomp2p/TomP2P/tree/master/nat/src/main/java/net/tomp2p/natpmp/Gateway.java", "rawCode": "  static InetAddress parse(BufferedReader bufferedreader) throws IOException, UnknownHostException {\n    String line;\n    while ((line = bufferedreader.readLine()) != null) {\n      boolean gatewayLine = false;\n      if (line.indexOf(\"default\") == 0 || line.indexOf(\"0.0.0.0\") >= 0) {\n        // MacOSX\n        if (line.indexOf(\"default\") == 0) {\n          gatewayLine = true;\n        }\n        // this is the line with the gateway IP, search for the first\n        // good entry.\n        Matcher m = IP_PATTERN.matcher(line);\n        int start = 0;\n        while (m.find(start)) {\n          String tmp = m.group();\n          // first entry\n          if (start == 0 && tmp.equals(\"0.0.0.0\")) {\n            gatewayLine = true;\n          } else if (!tmp.equals(\"0.0.0.0\") && gatewayLine) {\n            return InetAddress.getByName(tmp);\n          }\n          start = m.end() + 1;\n        }\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "group", "exampleID": 5734, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [154], "initializationEnd": [166], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.find()"], "configurationStart": [172], "configurationEnd": [180], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 193, "focalAPIEnd": 203, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7177/src/net/sourceforge/plantuml/cucadiagram/dot/CucaDiagramFileMaker.java", "rawCode": "  private static String getValue(String s, String param) {\n    final Pattern p = Pattern.compile(\"(?i)\" + param + \"=\\\"([^\\\"]+)\\\"\");\n    final Matcher m = p.matcher(s);\n    m.find();\n    return m.group(1);\n  }\n"}, {"dataset": "group", "exampleID": 5735, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.groupCount()"], "configurationStart": [452], "configurationEnd": [472], "guardCondition": "group<=numGroups", "guardType": "LOOP {", "guardExpressionStart": 479, "guardExpressionEnd": 515, "guardBlockStart": 479, "guardBlockEnd": 665, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 535, "focalAPIEnd": 551, "followUpCheck": "result != null", "checkType": "IF", "followUpCheckExpressionStart": 614, "followUpCheckExpressionEnd": 628, "followUpCheckBlockStart": 614, "followUpCheckBlockEnd": 659, "use": ["StringBuilder.append(result)"], "useStart": [639], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jca02266/k9mail/tree/master/src/com/fsck/k9/helper/Regex.java", "rawCode": "  /**\n   * Convenience method to take all of the non-null matching groups in a regex Matcher and return\n   * them as a concatenated string.\n   *\n   * @param matcher The Matcher object from which grouped text will be extracted\n   * @return A String comprising all of the non-null matched groups concatenated together\n   */\n  public static final String concatGroups(Matcher matcher) {\n    StringBuilder b = new StringBuilder();\n    final int numGroups = matcher.groupCount();\n\n    for (int i = 1; i <= numGroups; i++) {\n      String s = matcher.group(i);\n\n      System.err.println(\"Group(\" + i + \") : \" + s);\n\n      if (s != null) {\n        b.append(s);\n      }\n    }\n\n    return b.toString();\n  }\n"}, {"dataset": "group", "exampleID": 5736, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [290], "initializationEnd": [320], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 326, "guardExpressionEnd": 342, "guardBlockStart": 326, "guardBlockEnd": 1327, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 366, "focalAPIEnd": 376, "followUpCheck": "result != null", "checkType": "IF", "followUpCheckExpressionStart": 488, "followUpCheckExpressionEnd": 506, "followUpCheckBlockStart": 488, "followUpCheckBlockEnd": 1237, "use": ["matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "StringBuffer.append(result)"], "useStart": [399, 432, 469, 517], "useEnd": [409, 442, 479, 537], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JetBrains/intellij-plugins/tree/master/osmorc/src/org/osmorc/maven/facet/ImporterUtil.java", "rawCode": "  /**\n   * Clean up version parameters. Other builders use more fuzzy definitions of the version syntax.\n   * This method cleans up such a version to match an OSGi version.\n   */\n  static String cleanupVersion(String version) {\n    StringBuffer result = new StringBuffer();\n    Matcher m = FUZZY_VERSION.matcher(version);\n    if (m.matches()) {\n      String major = m.group(1);\n      String minor = m.group(3);\n      String micro = m.group(5);\n      String qualifier = m.group(7);\n\n      if (major != null) {\n        result.append(major);\n        if (minor != null) {\n          result.append(\".\");\n          result.append(minor);\n          if (micro != null) {\n            result.append(\".\");\n            result.append(micro);\n            if (qualifier != null) {\n              result.append(\".\");\n              cleanupModifier(result, qualifier);\n            }\n          } else if (qualifier != null) {\n            result.append(\".0.\");\n            cleanupModifier(result, qualifier);\n          } else {\n            result.append(\".0\");\n          }\n        } else if (qualifier != null) {\n          result.append(\".0.0.\");\n          cleanupModifier(result, qualifier);\n        } else {\n          result.append(\".0.0\");\n        }\n      }\n    } else {\n      result.append(\"0.0.0.\");\n      cleanupModifier(result, version);\n    }\n    return result.toString();\n  }\n"}, {"dataset": "group", "exampleID": 5737, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [787], "initializationEnd": [822], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(matcher.matches()) && !(matcher.groupCount()<4)", "guardType": "IF {", "guardExpressionStart": 996, "guardExpressionEnd": 1019, "guardBlockStart": 996, "guardBlockEnd": 1153, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1165, "focalAPIEnd": 1175, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [1228, 1263, 1321], "useEnd": [1238, 1273, 1331], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/PerfectButter/platform_packages_apps_Settings/tree/master/src/com/android/settings/DeviceInfoSettings.java", "rawCode": "  public static String formatKernelVersion(String rawKernelVersion) {\n    // Example (see tests for more):\n    // Linux version 3.0.31-g6fb96c9 (android-build@xxx.xxx.xxx.xxx.com) \\\n    // (gcc version 4.6.x-xxx 20120106 (prerelease) (GCC) ) #1 SMP PREEMPT \\\n    // Thu Jun 28 11:02:39 PDT 2012\n\n    final String PROC_VERSION_REGEX =\n        \"Linux version (\\\\S+) \"\n            + /* group 1: \"3.0.31-g6fb96c9\" */ \"\\\\((\\\\S+?)\\\\) \"\n            + /* group 2: \"x@y.com\" (kernel builder) */ \"(?:\\\\(gcc.+? \\\\)) \"\n            + /* ignore: GCC version information */ \"(#\\\\d+) \"\n            + /* group 3: \"#1\" */ \"(?:.*?)?\"\n            + /* ignore: optional SMP, PREEMPT, and any CONFIG_FLAGS */ \"((Sun|Mon|Tue|Wed|Thu|Fri|Sat).+)\"; /* group 4: \"Thu Jun 28 11:02:39 PDT 2012\" */\n\n    Matcher m = Pattern.compile(PROC_VERSION_REGEX).matcher(rawKernelVersion);\n    if (!m.matches()) {\n      Log.e(LOG_TAG, \"Regex did not match on /proc/version: \" + rawKernelVersion);\n      return \"Unavailable\";\n    } else if (m.groupCount() < 4) {\n      Log.e(LOG_TAG, \"Regex match on /proc/version only returned \" + m.groupCount() + \" groups\");\n      return \"Unavailable\";\n    }\n    return m.group(1)\n        + \"\\n\"\n        + // 3.0.31-g6fb96c9\n        m.group(2)\n        + \" \"\n        + m.group(3)\n        + \"\\n\"\n        + // x@y.com #1\n        m.group(4); // Thu Jun 28 11:02:39 PDT 2012\n  }\n"}, {"dataset": "group", "exampleID": 5738, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [198], "initializationEnd": [214], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 220, "guardExpressionEnd": 233, "guardBlockStart": 220, "guardBlockEnd": 933, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 253, "focalAPIEnd": 263, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["splitIgnoreBlank(result)"], "useStart": [285], "useEnd": [312], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nutzam/nutz/tree/master/src/org/nutz/lang/Mirror.java", "rawCode": "  /**\n   * 获取一个字段的泛型参数数组，如果这个字段没有泛型，返回空数组\n   *\n   * @param f 字段\n   * @return 泛型参数数组\n   */\n  public static Class<?>[] getGenericTypes(Field f) {\n    String gts = f.toGenericString();\n    Matcher m = PTN.matcher(gts);\n    if (m.find()) {\n      String s = m.group(2);\n      String[] ss = Strings.splitIgnoreBlank(s);\n      if (ss.length > 0) {\n        Class<?>[] re = new Class<?>[ss.length];\n        try {\n          for (int i = 0; i < ss.length; i++) {\n            String className = ss[i];\n            if (className.length() > 0 && className.charAt(0) == '?') re[i] = Object.class;\n            else {\n              int pos = className.indexOf('<');\n              if (pos < 0) re[i] = Lang.loadClass(className);\n              else re[i] = Lang.loadClass(className.substring(0, pos));\n            }\n          }\n          return re;\n        } catch (ClassNotFoundException e) {\n          throw Lang.wrapThrow(e);\n        }\n      }\n    }\n    return new Class<?>[0];\n  }\n"}, {"dataset": "group", "exampleID": 5739, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [1050], "initializationEnd": [1071], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 752, "tryExpressionEnd": 756, "tryBlockStart": 752, "tryBlockEnd": 4258, "catchExpressionStart": 4053, "catchExpressionEnd": 4085, "catchBlockStart": 4053, "catchBlockEnd": 4160, "exceptionHandlingCallStart": [4134], "exceptionHandlingCallEnd": [4153], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 1165, "guardExpressionEnd": 1181, "guardBlockStart": 1165, "guardBlockEnd": 1498, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1200, "focalAPIEnd": 1210, "followUpCheck": "!sigcurr.equals(result)", "checkType": "IF", "followUpCheckExpressionStart": 1574, "followUpCheckExpressionEnd": 1599, "followUpCheckBlockStart": 1574, "followUpCheckBlockEnd": 3569, "use": ["matcher.group(int)", "matcher.group(int)"], "useStart": [1232, 1265], "useEnd": [1242, 1275], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seweissman/wikiduper/tree/master/src/main/wikiduper/dist/EditDistance.java", "rawCode": "  public static void main(String args[]) {\n\n    if (args.length != 1) {\n      System.out.println(\"Usage: EditDistance <filein>\\n\");\n      System.exit(-1);\n    }\n    // Pattern linepat = Pattern.compile(\"(\\\\[[-0-9, ]+\\\\])\\t\\\\((.*), \\\\d+:\\\\d+\\\\)\");\n    Pattern linepat = Pattern.compile(\"([-0-9]+)\\t([^\\t]+)\\t(.*)\");\n    // ArrayList<ArrayList<String>> clusterlist = new ArrayList<ArrayList<String>>();\n    HashMap<String, HashSet<String>> matchmap = new HashMap<String, HashSet<String>>();\n    HashMap<String, HashSet<String>> nomatchmap = new HashMap<String, HashSet<String>>();\n\n    FileInputStream fin;\n    int clusterct = 0;\n    int uniquematchct = 0;\n    int uniquefalseposct = 0;\n    int nonuniquematchct = 0;\n    int nonuniquefalseposct = 0;\n    try {\n      fin = new FileInputStream(args[0]);\n      BufferedReader bin = new BufferedReader(new InputStreamReader(fin));\n      String line;\n      ArrayList<String> cluster = new ArrayList<String>();\n      String sigcurr = null;\n      while ((line = bin.readLine()) != null) {\n        Matcher m = linepat.matcher(line);\n        String sig = \"\";\n        String sentence = \"\";\n        String article = \"\";\n        if (m.matches()) {\n          sig = m.group(1);\n          article = m.group(2);\n          sentence = m.group(3);\n          System.out.println(\n              \"sig = \" + sig + \", article = \" + article + \", sentence = \" + sentence);\n        } else {\n          System.out.println(\"Bad line: \" + line);\n          System.exit(-1);\n        }\n\n        if (sigcurr == null) {\n          sigcurr = sig;\n        }\n        if (!sigcurr.equals(sig)) {\n          clusterct++;\n          if (clusterct % 1000 == 0) System.out.println(\"clusterct = \" + clusterct);\n          for (int i = 0; i < cluster.size(); i++) {\n            String m1 = cluster.get(i);\n            for (int j = i + 1; j < cluster.size(); j++) {\n              String m2 = cluster.get(j);\n              long dl = Math.max(m1.length(), m2.length()) - Math.min(m1.length(), m2.length());\n              long d = dist(m1, m2);\n              long score =\n                  Math.round(100 * (d - dl + 1) * 1.0 / Math.max(m1.length(), m2.length()));\n\n              if (score > 25) {\n                nonuniquefalseposct++;\n                // System.out.println(m1 + \">>>>>>\" + m2 + \">>>>>> \" + score);\n                if (!nomatchmap.containsKey(m1)) {\n                  nomatchmap.put(m1, new HashSet<String>());\n                }\n\n                if (!nomatchmap.containsKey(m2)) {\n                  nomatchmap.put(m2, new HashSet<String>());\n                }\n                if (!(nomatchmap.get(m2).contains(m1) || nomatchmap.get(m1).contains(m2))) {\n                  // System.out.println(m1 + \"\\t\" + m2);\n                  uniquefalseposct++;\n                }\n\n                nomatchmap.get(m2).add(m1);\n                nomatchmap.get(m1).add(m2);\n              } else {\n                nonuniquematchct++;\n\n                if (!matchmap.containsKey(m1)) {\n                  matchmap.put(m1, new HashSet<String>());\n                }\n\n                if (!matchmap.containsKey(m2)) {\n                  matchmap.put(m2, new HashSet<String>());\n                }\n                if (!(matchmap.get(m2).contains(m1) || matchmap.get(m1).contains(m2))) {\n                  uniquematchct++;\n                }\n                matchmap.get(m2).add(m1);\n                matchmap.get(m1).add(m2);\n              }\n            }\n          }\n          // clusterlist.add(cluster);\n          // cluster = new ArrayList<String>();\n          cluster.clear();\n        }\n        sigcurr = sig;\n\n        sentence =\n            sentence\n                .replace(\"External Links\", \"\")\n                .replace(\"External links\", \"\")\n                .replace(\"References\", \"\")\n                .replace(\"Official site\", \"\")\n                .replace(\"official site\", \"\");\n        if (sentence.length() > 100) {\n          cluster.add(sentence);\n        }\n\n        // System.out.println(\"entity = \" + entity);\n      }\n      bin.close();\n      fin.close();\n\n    } catch (FileNotFoundException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    } catch (IOException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    }\n\n    System.out.println(\"Cluster count:\" + clusterct);\n    System.out.println(\"N unique input matchess: \" + uniquematchct);\n    System.out.println(\"N unique input false positives: \" + uniquefalseposct);\n    System.out.println(\"N non-unique input matchess: \" + nonuniquematchct);\n    System.out.println(\"N non-unique input false positives: \" + nonuniquefalseposct);\n    // System.exit(-1);\n    int componentct = 0;\n    HashMap<Long, Long> histogram = new HashMap<Long, Long>();\n    long matchct = 0;\n    long badct = 0;\n    while (!matchmap.isEmpty()) {\n      String[] matchentities = matchmap.keySet().toArray(new String[0]);\n      String entity = matchentities[0];\n      HashSet<String> comp = getConnectedComponent(entity, matchmap);\n      // System.out.println(\"entity = \" + entity);\n      String cluster[] = comp.toArray(new String[0]);\n      componentct++;\n      System.out.println(\"componentct = \" + componentct + \" \" + comp.size());\n\n      int clustdisplayct = 0;\n      for (String m : cluster) {\n        if (clustdisplayct > 20) break;\n        System.out.println(\"item = \" + m);\n        clustdisplayct++;\n      }\n\n      for (int i = 0; i < cluster.length; i++) {\n        String entity1 = cluster[i];\n        for (int j = i + 1; j < cluster.length; j++) {\n          matchct++;\n          String entity2 = cluster[j];\n          long dl =\n              Math.max(entity1.length(), entity2.length())\n                  - Math.min(entity1.length(), entity2.length());\n          long d = dist(entity1, entity2);\n          long score =\n              Math.round(100 * (d - dl + 1) * 1.0 / Math.max(entity1.length(), entity2.length()));\n          // System.out.println(entity1 + \", \" + entity2 + \", \" + d + \", \" + dl + \", \" + Math.ceil(\n          // 100*score));\n          if (score > 0) {\n            if (!histogram.containsKey(score)) {\n              histogram.put(score, 0l);\n            }\n            histogram.put(score, histogram.get(score) + 1);\n          }\n          // if(dl > d){\n          // System.out.println(\"Weird lines:\");\n          // System.out.println(entity1 + \", \" + entity2 + \", \" + d + \", \" + dl + \", \" + Math.ceil(\n          // 100*score));\n          // }\n\n          if (score > 5) {\n            badct++;\n          }\n        }\n      }\n      System.out.println(\"matchct = \" + matchct + \" ,'badct = \" + badct);\n    }\n    for (long i = 0; i <= 100; i++) {\n      if (histogram.containsKey(i)) {\n        System.out.println(i + \",\" + histogram.get(i));\n      } else {\n        System.out.println(i + \",\" + 0);\n      }\n    }\n    System.out.println(\"N input buckets: \" + clusterct);\n    System.out.println(\"Total pairs: \" + matchct);\n    System.out.println(\"Bad pairs: \" + badct);\n    System.out.println(\"N components: \" + componentct);\n\n    System.out.println(\"FP rate: \" + badct * 1.0 / matchct);\n    // String s1 = \"abcedfgh\";\n    // String s2 = \"bcdefg\";\n    // System.out.println(\"distance: \" + EditDistance.dist(s1, s2));\n  }\n"}, {"dataset": "group", "exampleID": 5740, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [399], "initializationEnd": [422], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find() && !(true||sValue.indexOf(sBorder,)==-group)", "guardType": "IF {", "guardExpressionStart": 186, "guardExpressionEnd": 240, "guardBlockStart": 186, "guardBlockEnd": 248, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 467, "focalAPIEnd": 477, "followUpCheck": "result.equals(\"\")", "checkType": "IF", "followUpCheckExpressionStart": 485, "followUpCheckExpressionEnd": 505, "followUpCheckBlockStart": 485, "followUpCheckBlockEnd": 1209, "use": ["matcher.appendReplacement(StringBuffer,String)", "Map.get(result)", "matcher.appendReplacement(StringBuffer,String)", "matcher.appendReplacement(StringBuffer,String)", "matcher.appendTail(StringBuffer)"], "useStart": [506, 588, 636, 794, 1220], "useEnd": [544, 606, 691, 827, 1242], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.10.2/src/util/xml/XML.java", "rawCode": "  private static void replaceNodeTokens(Text t, String sBorder, Map mReplace) {\n    // Get value and look for tokens. If there aren't any, bail now.\n    String sValue = t.getData();\n    if (mReplace == null || sValue.indexOf(sBorder) == -1) return;\n\n    StringBuffer sbBefore = new StringBuffer();\n\n    Pattern pTokens = Pattern.compile(sBorder + \"(.*?)\" + sBorder, Pattern.DOTALL);\n    Matcher m = pTokens.matcher(sValue);\n    while (m.find()) {\n      String sKey = m.group(1);\n      if (sKey.equals(\"\")) m.appendReplacement(sbBefore, sBorder);\n      else {\n        Node nMatch = (Node) mReplace.get(sKey);\n        if (nMatch == null) m.appendReplacement(sbBefore, sBorder + sKey + sBorder);\n        else {\n          // OK, found a token. Get everything before it into the buffer...\n          m.appendReplacement(sbBefore, \"\");\n          // ...create a new text node with the 'before' text...\n          Text tBefore = t.getOwnerDocument().createTextNode(sbBefore.toString());\n          t.getParentNode().insertBefore(tBefore, t);\n          sbBefore.setLength(0);\n          // ...add the new node...\n          t.getParentNode().insertBefore(t.getOwnerDocument().importNode(nMatch, true), t);\n        }\n      }\n    }\n    m.appendTail(sbBefore);\n    t.setData(sbBefore.toString());\n  }\n"}, {"dataset": "group", "exampleID": 5741, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 419, "focalAPIEnd": 435, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Matcher.appendReplacement(StringBuffer,result)"], "useStart": [374], "useEnd": [436], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.engine/tree/master/plugins/org.eclipse.birt.report.engine.emitter.postscript/src/org/eclipse/birt/report/engine/emitter/postscript/PostscriptWriter.java", "rawCode": "  /**\n   * Escape the characters \"(\", \")\", and \"\\\" in a postscript string by \"\\\".\n   *\n   * @param source\n   * @return\n   */\n  private static String escapeSpecialCharacter(String source) {\n    Pattern pattern = Pattern.compile(\"(\\\\\\\\|\\\\)|\\\\()\");\n    Matcher matcher = pattern.matcher(source);\n    StringBuffer buffer = new StringBuffer();\n    while (matcher.find()) {\n      matcher.appendReplacement(buffer, \"\\\\\\\\\\\\\" + matcher.group(1));\n    }\n    matcher.appendTail(buffer);\n    return buffer.toString();\n  }\n"}, {"dataset": "group", "exampleID": 5742, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [242], "initializationEnd": [268], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 303, "guardExpressionEnd": 316, "guardBlockStart": 303, "guardBlockEnd": 375, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 357, "focalAPIEnd": 367, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)"], "useStart": [340], "useEnd": [368], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pgroth/hbase-rdf/tree/master/src/main/java/nl/vu/datalayer/hbase/bulkload/AbstractPrefixMatchBulkLoad.java", "rawCode": "  protected int getChildJVMSize(Configuration conf) {\n    String childOptsString = conf.get(\"mapred.child.java.opts\");\n    System.out.println(\"ChildOpts: \" + childOptsString);\n    Pattern p = Pattern.compile(\"-Xmx([0-9]*)m\");\n    Matcher m = p.matcher(childOptsString);\n    int childJVMSize = 1024;\n    if (m.find()) {\n      childJVMSize = Integer.parseInt(m.group(1));\n    }\n    System.out.println(\"ChildJVM: \" + childJVMSize);\n    return childJVMSize;\n  }\n"}, {"dataset": "group", "exampleID": 5743, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [299], "initializationEnd": [331], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 339, "guardExpressionEnd": 355, "guardBlockStart": 339, "guardBlockEnd": 1554, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 478, "focalAPIEnd": 488, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [461, 530, 581, 637, 690, 743, 869, 1040], "useEnd": [489, 540, 591, 647, 700, 753, 879, 1050], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mozilla-b2g/android-sdk/tree/master/ddms/libs/ddmuilib/src/com/android/ddmuilib/location/GpxParser.java", "rawCode": "    /**\n     * Converts the string description of the time into milliseconds since epoch.\n     *\n     * @param timeString the string data.\n     * @return date in milliseconds.\n     */\n    private long computeTime(String timeString) {\n      // Time looks like: 2008-04-05T19:24:50Z\n      Matcher m = ISO8601_TIME.matcher(timeString);\n      if (m.matches()) {\n        // get the various elements and reconstruct time as a long.\n        try {\n          int year = Integer.parseInt(m.group(1));\n          int month = Integer.parseInt(m.group(2));\n          int date = Integer.parseInt(m.group(3));\n          int hourOfDay = Integer.parseInt(m.group(4));\n          int minute = Integer.parseInt(m.group(5));\n          int second = Integer.parseInt(m.group(6));\n\n          // handle the optional parameters.\n          int milliseconds = 0;\n\n          String subSecondGroup = m.group(7);\n          if (subSecondGroup != null) {\n            milliseconds = (int) (1000 * Double.parseDouble(subSecondGroup));\n          }\n\n          boolean utcTime = m.group(8) != null;\n\n          // now we convert into milliseconds since epoch.\n          Calendar c;\n          if (utcTime) {\n            c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\")); // $NON-NLS-1$\n          } else {\n            c = Calendar.getInstance();\n          }\n\n          c.set(year, month, date, hourOfDay, minute, second);\n\n          return c.getTimeInMillis() + milliseconds;\n        } catch (NumberFormatException e) {\n          // format is invalid, we'll return -1 below.\n        }\n      }\n\n      // invalid time!\n      return -1;\n    }\n"}, {"dataset": "group", "exampleID": 5744, "initialization": ["Matcher matcher = getPattern()"], "initializationStart": [129], "initializationEnd": [141], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 161, "guardExpressionEnd": 183, "guardBlockStart": 161, "guardBlockEnd": 230, "focalAPI": "result = matcher.group()", "focalAPIStart": 207, "focalAPIEnd": 222, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(result)"], "useStart": [192], "useEnd": [223], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/andygibson/datavalve/tree/master/datavalve-core/src/main/java/org/fluttercode/datavalve/params/RegexParameterParser.java", "rawCode": "  public String[] extractParameters(String line) {\n    List<String> parameters = new ArrayList<String>();\n\n    Matcher matcher = getPattern().matcher(line);\n    while (matcher.find()) {\n      parameters.add(matcher.group());\n    }\n    // if we have params, return them as an array\n    return parameters.toArray(new String[parameters.size()]);\n  }\n"}, {"dataset": "group", "exampleID": 5745, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.usePattern(Pattern)"], "configurationStart": [878], "configurationEnd": [905], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group()", "focalAPIStart": 1055, "focalAPIEnd": 1070, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/main/java/java/util/Scanner.java", "rawCode": "  /**\n   * Returns the next token if it matches the specified pattern. The token will be both prefixed and\n   * postfixed by the delimiter that is currently being used (or a string that matches the delimiter\n   * pattern). This method will block if input is being read.\n   *\n   * @param pattern the specified pattern to scan.\n   * @return the next token.\n   * @throws IllegalStateException if this {@code Scanner} has been closed.\n   * @throws NoSuchElementException if input has been exhausted.\n   * @throws InputMismatchException if the next token does not match the pattern given.\n   */\n  public String next(Pattern pattern) {\n    checkClosed();\n    checkNull(pattern);\n    matchSuccessful = false;\n    saveCurrentStatus();\n    if (!setTokenRegion()) {\n      recoverPreviousStatus();\n      // if setting match region fails\n      throw new NoSuchElementException();\n    }\n    matcher.usePattern(pattern);\n    if (!matcher.matches()) {\n      recoverPreviousStatus();\n      throw new InputMismatchException();\n    }\n    matchSuccessful = true;\n    return matcher.group();\n  }\n"}, {"dataset": "group", "exampleID": 5746, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [168], "initializationEnd": [191], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 197, "guardExpressionEnd": 210, "guardBlockStart": 197, "guardBlockEnd": 592, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 249, "focalAPIEnd": 259, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["isDefine(result)"], "useStart": [232], "useEnd": [260], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sixman9/plantuml-69/tree/master/src/net/sourceforge/plantuml/preproc/IfManager.java", "rawCode": "  protected String readLineInternal() throws IOException {\n    final String s = source.readLine();\n    if (s == null) {\n      return null;\n    }\n\n    final Matcher m = ifdefPattern.matcher(s);\n    if (m.find()) {\n      boolean ok = defines.isDefine(m.group(2));\n      if (m.group(1) != null) {\n        ok = !ok;\n      }\n      if (ok) {\n        child = new IfManagerPositif(source, defines);\n      } else {\n        child = new IfManagerNegatif(source, defines);\n      }\n      // child = new IfManager(source, defines, ok ? IfPart.IF :\n      // IfPart.SKIP);\n      return this.readLine();\n    }\n\n    // m = endifPattern.matcher(s);\n    // if (m.find()) {\n    // return null;\n    // }\n    return s;\n  }\n"}, {"dataset": "group", "exampleID": 5747, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [143], "initializationEnd": [169], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 175, "guardExpressionEnd": 188, "guardBlockStart": 175, "guardBlockEnd": 314, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 214, "focalAPIEnd": 224, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7500/trunk/src/net/sourceforge/plantuml/SkinParam.java", "rawCode": "  static String cleanForKey(String key) {\n    key = key.toLowerCase().trim();\n    key = key.replaceAll(\"_|\\\\.|\\\\s\", \"\");\n    final Matcher m = stereoPattern.matcher(key);\n    if (m.find()) {\n      final String s = m.group(1);\n      key = key.replaceAll(stereoPatternString, \"\");\n      key += \"<<\" + s + \">>\";\n    }\n    return key;\n  }\n"}, {"dataset": "group", "exampleID": 5748, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [555], "initializationEnd": [581], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.start()"], "configurationStart": [758], "configurationEnd": [779], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 638, "guardExpressionEnd": 666, "guardBlockStart": 638, "guardBlockEnd": 951, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 868, "focalAPIEnd": 890, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["htmlize(result)", "matcher.end()"], "useStart": [860, 923], "useEnd": [891, 942], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/alex73/OmegaT/tree/master/src/org/omegat/gui/tagvalidation/TagValidationFrame.java", "rawCode": "  /**\n   * Formats plain text as html with placeholders and to-remove text in color\n   *\n   * @param str the text to format\n   * @param color the color to use for placeholders\n   * @param placeholderPattern the pattern to decide what is a placeholder\n   * @param removePattern the pattern to decide what text had to be removed.\n   * @return html text\n   */\n  private String formatRemoveTagsAndPlaceholders(\n      String str, String color, Pattern placeholderPattern, Pattern removePattern) {\n    if (removePattern != null) {\n      Matcher removeMatcher = removePattern.matcher(str);\n      String htmlResult = \"\";\n      int pos = 0;\n      while (removeMatcher.find()) {\n        htmlResult +=\n            formatPlaceholders(\n                str.substring(pos, removeMatcher.start()), color, placeholderPattern);\n        htmlResult += \"<font color=\\\"red\\\"><b>\" + htmlize(removeMatcher.group(0)) + \"</b></font>\";\n        pos = removeMatcher.end();\n      }\n      htmlResult += formatPlaceholders(str.substring(pos), color, placeholderPattern);\n      return htmlResult;\n    } else {\n      return formatPlaceholders(str, color, placeholderPattern);\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5749, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 108, "focalAPIEnd": 122, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "matcher.group(int)", "new ArmInstOpRM(result,*,*)"], "useStart": [134, 161, 92], "useEnd": [148, 175, 177], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rubzo/aottracegen-plugin/tree/master/eu/whrl/aottracegen/armgen/insts/ArmInstOpRM.java", "rawCode": "  @Override\n  public ArmInst getInst(Matcher match, RegexHelper h) {\n    try {\n      return new ArmInstOpRM(match.group(1), h.readReg(match.group(2)), h.readReg(match.group(3)));\n    } catch (NotParsableException e) {\n      return null;\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5750, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [6450], "initializationEnd": [6492], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 6502, "guardExpressionEnd": 6518, "guardBlockStart": 6502, "guardBlockEnd": 8069, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 6595, "focalAPIEnd": 6605, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Attribute(*,result)", "matcher.group(int)"], "useStart": [6569, 6660], "useEnd": [6606, 6670], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/metamolecular/opsin/tree/master/opsin-core/src/main/java/uk/ac/cam/ch/wwmm/opsin/ComponentGenerator.java", "rawCode": "  /**\n   * Identifies lambdaConvention elements. The elementsValue is expected to be a comma seperated\n   * lambda values and 0 or more locants. Where a lambda value has the following form: optional\n   * locant, the word lambda and then a number which is the valency specified (with possibly some\n   * attempt to indicate this number is superscripted) If the element is followed by heteroatoms\n   * (possibly multiplied) they are multiplied and the locant/lambda assigned to them Otherwise a\n   * new lambdaConvention element is created with the valency specified by the lambda convention\n   * taking the attribute \"lambda\" In the case where heteroatoms belong to a fused ring system a new\n   * lambdaConvention element is also created. The original locants are retained in the benzo\n   * specific fused ring nomenclature: 2H-5lambda^5-phosphinino[3,2-b]pyran --> 2H 5lambda^5\n   * phosphinino[3,2-b]pyran BUT 1lambda^4,5-Benzodithiepin --> 1lambda^4 1,5-Benzodithiepin\n   *\n   * @param subOrRoot\n   * @throws ComponentGenerationException\n   */\n  private void processLambdaConvention(Element subOrRoot) throws ComponentGenerationException {\n    List<Element> lambdaConventionEls = subOrRoot.getChildElements(LAMBDACONVENTION_EL);\n    boolean fusedRingPresent = false;\n    if (lambdaConventionEls.size() > 0) {\n      if (subOrRoot.getChildElements(GROUP_EL).size() > 1) {\n        fusedRingPresent = true;\n      }\n    }\n    for (Element lambdaConventionEl : lambdaConventionEls) {\n      boolean frontLocantsExpected =\n          false; // Is the lambdaConvention el followed by benz/benzo of a fused ring system (these\n                 // have front locants which correspond to the final fused rings numbering) or by a\n                 // polycylicspiro system\n      String[] lambdaValues =\n          MATCH_COMMA.split(StringTools.removeDashIfPresent(lambdaConventionEl.getValue()));\n      Element possibleHeteroatomOrMultiplier = OpsinTools.getNextSibling(lambdaConventionEl);\n      int heteroCount = 0;\n      int multiplierValue = 1;\n      while (possibleHeteroatomOrMultiplier != null) {\n        if (possibleHeteroatomOrMultiplier.getName().equals(HETEROATOM_EL)) {\n          heteroCount += multiplierValue;\n          multiplierValue = 1;\n        } else if (possibleHeteroatomOrMultiplier.getName().equals(MULTIPLIER_EL)) {\n          multiplierValue =\n              Integer.parseInt(possibleHeteroatomOrMultiplier.getAttributeValue(VALUE_ATR));\n        } else {\n          break;\n        }\n        possibleHeteroatomOrMultiplier = OpsinTools.getNextSibling(possibleHeteroatomOrMultiplier);\n      }\n      boolean assignLambdasToHeteroAtoms = false;\n      if (lambdaValues.length\n          == heteroCount) { // heteroatom and number of locants +lambdas must match\n        if (fusedRingPresent\n            && possibleHeteroatomOrMultiplier != null\n            && possibleHeteroatomOrMultiplier.getName().equals(GROUP_EL)\n            && possibleHeteroatomOrMultiplier\n                .getAttributeValue(SUBTYPE_ATR)\n                .equals(HANTZSCHWIDMAN_SUBTYPE_VAL)) {\n          // You must not set the locants of a HW system which forms a component of a fused ring\n          // system. The locant specified corresponds to the complete fused ring system.\n        } else {\n          assignLambdasToHeteroAtoms = true;\n        }\n      } else if (possibleHeteroatomOrMultiplier != null\n          && ((heteroCount == 0\n                  && OpsinTools.getNextSibling(lambdaConventionEl)\n                      .equals(possibleHeteroatomOrMultiplier)\n                  && fusedRingPresent\n                  && possibleHeteroatomOrMultiplier.getName().equals(GROUP_EL)\n                  && (possibleHeteroatomOrMultiplier.getValue().equals(\"benzo\")\n                      || possibleHeteroatomOrMultiplier.getValue().equals(\"benz\"))\n                  && !OpsinTools.getNextSibling(possibleHeteroatomOrMultiplier)\n                      .getName()\n                      .equals(FUSION_EL)\n                  && !OpsinTools.getNextSibling(possibleHeteroatomOrMultiplier)\n                      .getName()\n                      .equals(LOCANT_EL))\n              || (possibleHeteroatomOrMultiplier.getName().equals(POLYCYCLICSPIRO_EL)\n                  && (possibleHeteroatomOrMultiplier.getAttributeValue(VALUE_ATR).equals(\"spirobi\")\n                      || possibleHeteroatomOrMultiplier\n                          .getAttributeValue(VALUE_ATR)\n                          .equals(\"spiroter\"))))) {\n        frontLocantsExpected =\n            true; // a benzo fused ring e.g. 1lambda4,3-benzothiazole or a symmetrical poly cyclic\n                  // spiro system\n      }\n      List<Element> heteroAtoms =\n          new ArrayList<\n              Element>(); // contains the heteroatoms to apply the lambda values too. Can be empty\n                          // if the values are applied to a group directly rather than to a\n                          // heteroatom\n      if (assignLambdasToHeteroAtoms) { // populate heteroAtoms, multiplied heteroatoms are\n                                        // multiplied out\n        Element multiplier = null;\n        Element heteroatomOrMultiplier = OpsinTools.getNextSibling(lambdaConventionEl);\n        while (heteroatomOrMultiplier != null) {\n          if (heteroatomOrMultiplier.getName().equals(HETEROATOM_EL)) {\n            heteroAtoms.add(heteroatomOrMultiplier);\n            if (multiplier != null) {\n              for (int i = 1; i < Integer.parseInt(multiplier.getAttributeValue(VALUE_ATR)); i++) {\n                Element newHeteroAtom = heteroatomOrMultiplier.copy();\n                OpsinTools.insertBefore(heteroatomOrMultiplier, newHeteroAtom);\n                heteroAtoms.add(newHeteroAtom);\n              }\n              multiplier.detach();\n              multiplier = null;\n            }\n          } else if (heteroatomOrMultiplier.getName().equals(MULTIPLIER_EL)) {\n            if (multiplier != null) {\n              break;\n            } else {\n              multiplier = heteroatomOrMultiplier;\n            }\n          } else {\n            break;\n          }\n          heteroatomOrMultiplier = OpsinTools.getNextSibling(heteroatomOrMultiplier);\n        }\n      }\n\n      for (int i = 0;\n          i < lambdaValues.length;\n          i++) { // assign all the lambdas to heteroatoms or to newly created lambdaConvention\n                 // elements\n        String lambdaValue = lambdaValues[i];\n        Matcher m = matchLambdaConvention.matcher(lambdaValue);\n        if (m.matches()) { // a lambda\n          Attribute valencyChange = new Attribute(LAMBDA_ATR, m.group(2));\n          Attribute locantAtr = null;\n          if (m.group(1) != null) {\n            locantAtr = new Attribute(LOCANT_ATR, m.group(1));\n          }\n          if (frontLocantsExpected) {\n            if (m.group(1) == null) {\n              throw new ComponentGenerationException(\n                  \"Locant not found for lambda convention before a benzo fused ring system\");\n            }\n            lambdaValues[i] = m.group(1);\n          }\n          if (assignLambdasToHeteroAtoms) {\n            Element heteroAtom = heteroAtoms.get(i);\n            heteroAtom.addAttribute(valencyChange);\n            if (locantAtr != null) {\n              heteroAtom.addAttribute(locantAtr);\n            }\n          } else {\n            Element newLambda = new TokenEl(LAMBDACONVENTION_EL);\n            newLambda.addAttribute(valencyChange);\n            if (locantAtr != null) {\n              newLambda.addAttribute(locantAtr);\n            }\n            OpsinTools.insertBefore(lambdaConventionEl, newLambda);\n          }\n        } else { // just a locant e.g 1,3lambda5\n          if (!assignLambdasToHeteroAtoms) {\n            if (!frontLocantsExpected) {\n              throw new ComponentGenerationException(\n                  \"Lambda convention not specified for locant: \" + lambdaValue);\n            }\n          } else {\n            Element heteroAtom = heteroAtoms.get(i);\n            heteroAtom.addAttribute(new Attribute(LOCANT_ATR, lambdaValue));\n          }\n        }\n      }\n      if (!frontLocantsExpected) {\n        lambdaConventionEl.detach();\n      } else {\n        lambdaConventionEl.setName(LOCANT_EL);\n        lambdaConventionEl.setValue(StringTools.arrayToString(lambdaValues, \",\"));\n      }\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5751, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [549], "initializationEnd": [564], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 613, "guardExpressionEnd": 629, "guardBlockStart": 613, "guardBlockEnd": 765, "focalAPI": "result = matcher.group()", "focalAPIStart": 658, "focalAPIEnd": 667, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["unEscapeHtml(result)", "matcher.appendReplacement(StringBuffer,String)", "matcher.appendTail(StringBuffer)"], "useStart": [715, 675, 770], "useEnd": [743, 758, 787], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.14/kernel-util/src/main/java/org/sakaiproject/util/Web.java", "rawCode": "  /**\n   * For converting plain-text URLs in a String to HTML &lt;a&gt; tags Any URLs in the source text\n   * that happen to be already in a &lt;a&gt; tag will be unaffected.\n   *\n   * @param text the plain text to convert\n   * @return the full source text with URLs converted to HTML.\n   */\n  public static String encodeUrlsAsHtml(String text) {\n    Pattern p =\n        Pattern.compile(\n            \"(?<!href=['\\\"]{1})(((https?|s?ftp|ftps|file|smb|afp|nfs|(x-)?man|gopher|txmt)://|mailto:)[-:;@a-zA-Z0-9_.,~%+/?=&#]+(?<![.,?:]))\");\n    Matcher m = p.matcher(text);\n    StringBuffer buf = new StringBuffer();\n    while (m.find()) {\n      String matchedUrl = m.group();\n      m.appendReplacement(buf, \"<a href=\\\"\" + Web.unEscapeHtml(matchedUrl) + \"\\\">$1</a>\");\n    }\n    m.appendTail(buf);\n    return buf.toString();\n  }\n"}, {"dataset": "group", "exampleID": 5752, "initialization": ["Matcher matcher = matcher(String)"], "initializationStart": [157], "initializationEnd": [198], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find() && matcher.group(group,)!=null", "guardType": "IF {", "guardExpressionStart": 204, "guardExpressionEnd": 217, "guardBlockStart": 204, "guardBlockEnd": 843, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 366, "focalAPIEnd": 376, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "changeSurface(result)"], "useStart": [443, 469], "useEnd": [453, 487], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xCatG/Nanidroid/tree/master/src/com/cattailsw/nanidroid/SScriptRunner.java", "rawCode": "  private boolean handle_surface() {\n    // two cases\n    // \\s0-9 and \\s[id] case\n    String left = msg.substring(charIndex, msg.length());\n    Matcher m = PatternHolders.surface_ptrn.matcher(left);\n    if (m.find()) {\n      // now, sid will be in m.group(1) or m.group(2) depending on format\n      // check for m.group(2) first?\n      String sid = null;\n      if (m.group(2) != null) {\n        sid = m.group(2);\n      } else {\n        sid = m.group(1);\n      }\n      changeSurface(sid);\n      charIndex += m.group().length();\n      return true;\n    } else {\n      Log.d(TAG, \"malformed \\\\s tag at index:\" + charIndex);\n      AnalyticsUtils.getInstance(null)\n          .trackEvent(\n              Setup.ANA_SSC,\n              \"tag_err\",\n              \"\\\\s\" + left.substring(0, 4),\n              -1); // just record 4 more chars after \\\\s\n    }\n    return false;\n  }\n"}, {"dataset": "group", "exampleID": 5753, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [1075], "initializationEnd": [1104], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 1110, "guardExpressionEnd": 1126, "guardBlockStart": 1110, "guardBlockEnd": 1474, "focalAPI": "result = matcher.group()", "focalAPIStart": 1154, "focalAPIEnd": 1163, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Pattern.matcher(result)"], "useStart": [1192], "useEnd": [1217], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/petalslink/petals-studio/tree/master/plugins/com.ebmwebsourcing.petals.common/src/com/ebmwebsourcing/petals/common/internal/provisional/utils/PetalsRefactoringUtils.java", "rawCode": "  /**\n   * Builds a list of {@link ReplaceEdit} for a refactoring wizard.\n   *\n   * @param text the original text\n   * @param regex the regular expression to replace\n   * @param newValue the new text\n   * @param leftRegex a regular expression that defines a left delimiter (can be null for none)\n   * @param rightRegex a regular expression that defines a right delimiter (can be null for none)\n   * @return a non-null list of Replace edits\n   */\n  public static List<ReplaceEdit> buildReplaceEdits(\n      String text, String regex, String leftRegex, String rightRegex, String newValue) {\n\n    StringBuilder completeRegex = new StringBuilder();\n    if (leftRegex != null) completeRegex.append(leftRegex);\n    completeRegex.append(regex);\n    if (rightRegex != null) completeRegex.append(rightRegex);\n\n    List<ReplaceEdit> edits = new ArrayList<ReplaceEdit>();\n    Pattern completePattern =\n        Pattern.compile(completeRegex.toString(), Pattern.MULTILINE | Pattern.DOTALL);\n    Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE | Pattern.DOTALL);\n    Matcher m = completePattern.matcher(text);\n    while (m.find()) {\n\n      String sequence = m.group();\n      Matcher subMatcher = pattern.matcher(sequence);\n      if (subMatcher.find()) {\n        int start = m.start() + subMatcher.start();\n        int length = subMatcher.group().length();\n\n        ReplaceEdit replaceEdit = new ReplaceEdit(start, length, newValue);\n        edits.add(replaceEdit);\n      }\n    }\n\n    return edits;\n  }\n"}, {"dataset": "group", "exampleID": 5754, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(name)", "focalAPIStart": 78, "focalAPIEnd": 101, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(String)", "matcher.group(String)", "matcher.group(String)", "matcher.group(int)", "matcher.group(String)", "matcher.group(String)"], "useStart": [175, 215, 240, 366, 407, 432], "useEnd": [198, 237, 260, 390, 429, 452], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jbosstm/transaction-profiler/tree/master/core/src/main/java/io/narayana/nta/logparsing/as8/handlers/JTSInterpositionHandler.java", "rawCode": "  @Override\n  public void handle(Matcher matcher, String line) {\n\n    switch (matcher.group(\"METHOD\")) {\n      case \"send_request\":\n        service.checkIfParent(\n            matcher.group(\"NODEID\"), Long.parseLong(matcher.group(\"REQID\")), matcher.group(\"IOR\"));\n        break;\n      case \"receive_request\":\n        service.associateThreadWithRequestId(\n            matcher.group(THREAD_ID), Long.parseLong(matcher.group(\"REQID\")), matcher.group(\"IOR\"));\n        break;\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5755, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1562, "focalAPIEnd": 1576, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/knutwalker/google-closure-compiler/tree/master/lib/rhino/src/org/mozilla/javascript/RhinoException.java", "rawCode": "  /**\n   * Get the script stack of this exception as an array of {@link ScriptStackElement}s. If\n   * optimization is enabled, this includes java stack elements whose source and method names\n   * suggest they have been generated by the Rhino script compiler.\n   *\n   * @return the script stack for this exception\n   * @since 1.7R3\n   */\n  public ScriptStackElement[] getScriptStack() {\n    List<ScriptStackElement> list = new ArrayList<ScriptStackElement>();\n    ScriptStackElement[][] interpreterStack = null;\n    if (interpreterStackInfo != null) {\n      Evaluator interpreter = Context.createInterpreter();\n      if (interpreter instanceof Interpreter)\n        interpreterStack = ((Interpreter) interpreter).getScriptStackElements(this);\n    }\n    int interpreterStackIndex = 0;\n    StackTraceElement[] stack = getStackTrace();\n    // Pattern to recover function name from java method name -\n    // see Codegen.getBodyMethodName()\n    // kudos to Marc Guillemot for coming up with this\n    Pattern pattern = Pattern.compile(\"_c_(.*)_\\\\d+\");\n    for (StackTraceElement e : stack) {\n      String fileName = e.getFileName();\n      if (e.getMethodName().startsWith(\"_c_\")\n          && e.getLineNumber() > -1\n          && fileName != null\n          && !fileName.endsWith(\".java\")) {\n        String methodName = e.getMethodName();\n        Matcher match = pattern.matcher(methodName);\n        // the method representing the main script is always \"_c_script_0\" -\n        // at least we hope so\n        methodName = !\"_c_script_0\".equals(methodName) && match.find() ? match.group(1) : null;\n        list.add(new ScriptStackElement(fileName, methodName, e.getLineNumber()));\n      } else if (\"org.mozilla.javascript.Interpreter\".equals(e.getClassName())\n          && \"interpretLoop\".equals(e.getMethodName())\n          && interpreterStack != null\n          && interpreterStack.length > interpreterStackIndex) {\n        for (ScriptStackElement elem : interpreterStack[interpreterStackIndex++]) {\n          list.add(elem);\n        }\n      }\n    }\n    return list.toArray(new ScriptStackElement[list.size()]);\n  }\n"}, {"dataset": "group", "exampleID": 5756, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [70], "initializationEnd": [94], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(matcher.find()==false)", "guardType": "IF {", "guardExpressionStart": 100, "guardExpressionEnd": 122, "guardBlockStart": 100, "guardBlockEnd": 171, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 195, "focalAPIEnd": 205, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getFile(result)", "new Img(*,result)"], "useStart": [238, 477], "useEnd": [275, 537], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-6939/src/net/sourceforge/plantuml/graphic/Img.java", "rawCode": "  static HtmlCommand getInstance(String html) {\n    final Matcher m = srcPattern.matcher(html);\n    if (m.find() == false) {\n      return new Text(\"(SYNTAX ERROR)\");\n    }\n    final String src = m.group(1);\n    try {\n      final File f = FileSystem.getInstance().getFile(src);\n      if (f.exists() == false) {\n        return new Text(\"(File not found: \" + f + \")\");\n      }\n      final int vspace = getVspace(html);\n      final ImgValign valign = getValign(html);\n      return new Img(new TileImage(ImageIO.read(f), valign, vspace), src);\n    } catch (IOException e) {\n      return new Text(\"ERROR \" + e.toString());\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5757, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [766], "initializationEnd": [802], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1017, "focalAPIEnd": 1027, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [1000, 1040, 1329, 1352], "useEnd": [1028, 1050, 1339, 1362], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SeekingFor/jfniki/tree/master/alien/src/name/fraser/neil/plaintext/diff_match_patch.java", "rawCode": "  /**\n   * Parse a textual representation of patches and return a List of Patch objects.\n   *\n   * @param textline Text representation of patches.\n   * @return List of Patch objects.\n   * @throws IllegalArgumentException If invalid input.\n   */\n  public List<Patch> patch_fromText(String textline) throws IllegalArgumentException {\n    List<Patch> patches = new LinkedList<Patch>();\n    if (textline.length() == 0) {\n      return patches;\n    }\n    List<String> textList = Arrays.asList(textline.split(\"\\n\"));\n    LinkedList<String> text = new LinkedList<String>(textList);\n    Patch patch;\n    Pattern patchHeader = Pattern.compile(\"^@@ -(\\\\d+),?(\\\\d*) \\\\+(\\\\d+),?(\\\\d*) @@$\");\n    Matcher m;\n    char sign;\n    String line;\n    while (!text.isEmpty()) {\n      m = patchHeader.matcher(text.getFirst());\n      if (!m.matches()) {\n        throw new IllegalArgumentException(\"Invalid patch string: \" + text.getFirst());\n      }\n      patch = new Patch();\n      patches.add(patch);\n      patch.start1 = Integer.parseInt(m.group(1));\n      if (m.group(2).length() == 0) {\n        patch.start1--;\n        patch.length1 = 1;\n      } else if (m.group(2).equals(\"0\")) {\n        patch.length1 = 0;\n      } else {\n        patch.start1--;\n        patch.length1 = Integer.parseInt(m.group(2));\n      }\n\n      patch.start2 = Integer.parseInt(m.group(3));\n      if (m.group(4).length() == 0) {\n        patch.start2--;\n        patch.length2 = 1;\n      } else if (m.group(4).equals(\"0\")) {\n        patch.length2 = 0;\n      } else {\n        patch.start2--;\n        patch.length2 = Integer.parseInt(m.group(4));\n      }\n      text.removeFirst();\n\n      while (!text.isEmpty()) {\n        try {\n          sign = text.getFirst().charAt(0);\n        } catch (IndexOutOfBoundsException e) {\n          // Blank line? Whatever.\n          text.removeFirst();\n          continue;\n        }\n        line = text.getFirst().substring(1);\n        line = line.replace(\"+\", \"%2B\"); // decode would change all \"+\" to \" \"\n        try {\n          line = URLDecoder.decode(line, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n          // Not likely on modern system.\n          throw new Error(\"This system does not support UTF-8.\", e);\n        } catch (IllegalArgumentException e) {\n          // Malformed URI sequence.\n          throw new IllegalArgumentException(\"Illegal escape in patch_fromText: \" + line, e);\n        }\n        if (sign == '-') {\n          // Deletion.\n          patch.diffs.add(new Diff(Operation.DELETE, line));\n        } else if (sign == '+') {\n          // Insertion.\n          patch.diffs.add(new Diff(Operation.INSERT, line));\n        } else if (sign == ' ') {\n          // Minor equality.\n          patch.diffs.add(new Diff(Operation.EQUAL, line));\n        } else if (sign == '@') {\n          // Start of next patch.\n          break;\n        } else {\n          // WTF?\n          throw new IllegalArgumentException(\"Invalid patch mode '\" + sign + \"' in: \" + line);\n        }\n        text.removeFirst();\n      }\n    }\n    return patches;\n  }\n"}, {"dataset": "group", "exampleID": 5758, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [125], "initializationEnd": [168], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.find()"], "configurationStart": [193], "configurationEnd": [201], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 277, "focalAPIEnd": 287, "followUpCheck": "i < result.length()", "checkType": "LOOP", "followUpCheckExpressionStart": 293, "followUpCheckExpressionEnd": 334, "followUpCheckBlockStart": 293, "followUpCheckBlockEnd": 446, "use": ["result.charAt(int)"], "useStart": [358], "useEnd": [374], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7284/src/net/sourceforge/plantuml/BlockUml.java", "rawCode": "  public String getFilename() {\n    if (OptionFlags.getInstance().isWord()) {\n      return null;\n    }\n    final Matcher m = patternFilename.matcher(data.get(0).trim());\n    final boolean ok = m.find();\n    if (ok == false) {\n      return null;\n    }\n    final String result = m.group(1);\n    for (int i = 0; i < result.length(); i++) {\n      final char c = result.charAt(i);\n      if (\"<>|\".indexOf(c) != -1) {\n        return null;\n      }\n    }\n    return result;\n  }\n"}, {"dataset": "group", "exampleID": 5759, "initialization": ["Matcher matcher = matcher(String)"], "initializationStart": [113], "initializationEnd": [153], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 159, "guardExpressionEnd": 175, "guardBlockStart": 159, "guardBlockEnd": 683, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 207, "focalAPIEnd": 217, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "setParameter(result,String)"], "useStart": [249, 267], "useEnd": [259, 340], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/amplafi/amplafi-flow-client/tree/master/src/main/java/org/amplafi/flow/ui/command/SetParameterCommand.java", "rawCode": "  @Override\n  public void execute(AdminTool adminTool) {\n    String options = this.getOptions();\n    Matcher m = ONE_AND_MAYBE_TWO_WORDS.matcher(options);\n    if (m.matches()) {\n      String parameterName = m.group(1);\n      String parameterValue = m.group(2);\n      adminTool.getBindingFactory().setParameter(parameterName, parameterValue);\n    } else if (NOTHING.matcher(options).find()) {\n      Map<?, ?> defaultParameters = adminTool.getBindingFactory().getDefaultParameters();\n      for (Map.Entry<?, ?> entry : defaultParameters.entrySet()) {\n        System.out.print(entry.getKey());\n        System.out.print(\" = \");\n        System.out.println(entry.getValue());\n      }\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5760, "initialization": ["Matcher matcher = matcher(String)"], "initializationStart": [73], "initializationEnd": [113], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 119, "guardExpressionEnd": 135, "guardBlockStart": 119, "guardBlockEnd": 168, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 151, "focalAPIEnd": 161, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kartiknagpal/aCal/tree/master/src/com/morphoss/acal/davacal/VCalendar.java", "rawCode": "  public static String staticGetOlsonName(String tzId) {\n    Matcher m = VCalendar.tzOlsonExtractor.matcher(tzId);\n    if (m.matches()) {\n      return m.group(1);\n    }\n    String aliasResult = checkKnownAliases(tzId);\n    if (aliasResult != null) return aliasResult;\n    Log.w(TAG, \"Could not get Olson name from \" + tzId, new Exception(\"Unrecognized Time Zone\"));\n    return tzId;\n  }\n"}, {"dataset": "group", "exampleID": 5761, "initialization": ["Matcher matcher = getStartingPattern()"], "initializationStart": [120], "initializationEnd": [140], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(matcher.find()==false)", "guardType": "IF {", "guardExpressionStart": 175, "guardExpressionEnd": 197, "guardBlockStart": 175, "guardBlockEnd": 246, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 272, "focalAPIEnd": 282, "followUpCheck": "result != null", "checkType": "IF", "followUpCheckExpressionStart": 288, "followUpCheckExpressionEnd": 306, "followUpCheckBlockStart": 288, "followUpCheckBlockEnd": 404, "use": ["result.toUpperCase()"], "useStart": [376], "useEnd": [395], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7701/src/net/sourceforge/plantuml/command/CommandMultilinesHeader.java", "rawCode": "  public CommandExecutionResult execute(List<String> lines) {\n    StringUtils.trim(lines, false);\n    final Matcher m = getStartingPattern().matcher(lines.get(0).trim());\n    if (m.find() == false) {\n      throw new IllegalStateException();\n    }\n    final String align = m.group(1);\n    if (align != null) {\n      getSystem().setHeaderAlignement(HorizontalAlignement.valueOf(align.toUpperCase()));\n    }\n    final List<String> strings = lines.subList(1, lines.size() - 1);\n    if (strings.size() > 0) {\n      getSystem().setHeader(strings);\n      return CommandExecutionResult.ok();\n    }\n    return CommandExecutionResult.error(\"Empty header\");\n  }\n"}, {"dataset": "group", "exampleID": 5762, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [355], "initializationEnd": [378], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.group(1,).equalsIgnoreCase(\"macro\",) &&  matcher.matches()", "guardType": "IF {", "guardExpressionStart": 385, "guardExpressionEnd": 401, "guardBlockStart": 385, "guardBlockEnd": 3890, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 614, "focalAPIEnd": 624, "followUpCheck": "result.equalsIgnoreCase(\"self\")", "checkType": "IF", "followUpCheckExpressionStart": 634, "followUpCheckExpressionEnd": 667, "followUpCheckBlockStart": 634, "followUpCheckBlockEnd": 1272, "use": ["matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [1293, 1327, 2106], "useEnd": [1303, 1337, 2116], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spullara/maptool/tree/master/src/net/rptools/maptool/client/functions/MacroLinkFunction.java", "rawCode": "  /**\n   * Runs the macro specified by the link.\n   *\n   * @param link the link to the macro.\n   * @param setVars should the variables be set in the macro context as well as passed in as\n   *     macro.args.\n   */\n  public void runMacroLink(String link, boolean setVars) {\n    if (link == null || link.length() == 0) {\n      return;\n    }\n    Matcher m = macroLink.matcher(link);\n\n    if (m.matches()) {\n      OutputTo outputTo;\n      String macroName = \"\";\n      String args = \"\";\n      Set<String> outputToPlayers = new HashSet<String>();\n\n      if (m.group(1).equalsIgnoreCase(\"macro\")) {\n\n        String who = m.group(3);\n        if (who.equalsIgnoreCase(\"self\")) {\n          outputTo = OutputTo.SELF;\n        } else if (who.equalsIgnoreCase(\"gm\")) {\n          outputTo = OutputTo.GM;\n        } else if (who.equalsIgnoreCase(\"none\")) {\n          outputTo = OutputTo.NONE;\n        } else if (who.equalsIgnoreCase(\"all\") || who.equalsIgnoreCase(\"say\")) {\n          outputTo = OutputTo.ALL;\n        } else if (who.equalsIgnoreCase(\"gm-self\") || who.equalsIgnoreCase(\"gmself\")) {\n          outputTo = OutputTo.SELF_AND_GM;\n        } else if (who.equalsIgnoreCase(\"list\")) {\n          outputTo = OutputTo.LIST;\n        } else {\n          outputTo = OutputTo.NONE;\n        }\n        macroName = m.group(2);\n\n        String val = m.group(5);\n        if (val != null) {\n          try {\n            Double.parseDouble(val);\n            // Do nothing as its a number\n          } catch (NumberFormatException e) {\n            try {\n              val = argsToStrPropList(val);\n            } catch (ParserException e1) {\n              MapTool.addLocalMessage(\"Error running macro link: \" + e1.getMessage());\n            }\n          }\n          args = val;\n          try {\n            JSONObject jobj = JSONObject.fromObject(args);\n            if (jobj.containsKey(\"mlOutputList\")) {\n              outputToPlayers.addAll(jobj.getJSONArray(\"mlOutputList\"));\n            }\n          } catch (Exception e) {\n            // Do nothing as we just dont populate the list.\n          }\n        }\n\n        String[] targets = m.group(4).split(\",\");\n        Zone zone = MapTool.getFrame().getCurrentZoneRenderer().getZone();\n\n        try {\n          for (String t : targets) {\n            if (t.equalsIgnoreCase(\"impersonated\")) {\n              Token token;\n              GUID guid = MapTool.getFrame().getCommandPanel().getIdentityGUID();\n              if (guid != null)\n                token = MapTool.getFrame().getCurrentZoneRenderer().getZone().getToken(guid);\n              else token = zone.resolveToken(MapTool.getFrame().getCommandPanel().getIdentity());\n              MapToolVariableResolver resolver = new MapToolVariableResolver(token);\n              String output = MapTool.getParser().runMacro(resolver, token, macroName, args);\n              doOutput(token, outputTo, output, outputToPlayers); // TODO\n            } else if (t.equalsIgnoreCase(\"selected\")) {\n              for (GUID id : MapTool.getFrame().getCurrentZoneRenderer().getSelectedTokenSet()) {\n                Token token = zone.getToken(id);\n                MapToolVariableResolver resolver = new MapToolVariableResolver(token);\n                String output = MapTool.getParser().runMacro(resolver, token, macroName, args);\n                doOutput(token, outputTo, output, outputToPlayers);\n              }\n            } else {\n              Token token = zone.resolveToken(t);\n              MapToolVariableResolver resolver = new MapToolVariableResolver(token);\n              String output = MapTool.getParser().runMacro(resolver, token, macroName, args);\n              doOutput(token, outputTo, output, outputToPlayers);\n            }\n          }\n        } catch (AbortFunctionException e) {\n          // Do nothing\n        } catch (ParserException e) {\n          MapTool.addLocalMessage(e.getMessage());\n        }\n      }\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5763, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [234], "initializationEnd": [273], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 349, "guardExpressionEnd": 365, "guardBlockStart": 349, "guardBlockEnd": 925, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 442, "focalAPIEnd": 475, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["makeEmptyNull(result)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [428, 511, 570, 636, 693, 750, 807, 882], "useEnd": [476, 538, 603, 660, 717, 774, 839, 917], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/teamgummy/frameworks_base/tree/master/telephony/java/com/android/internal/telephony/cdma/CdmaMmiCode.java", "rawCode": "  /** Check if provided string contains Mmi code in it and create corresponding Mmi if it does */\n  public static CdmaMmiCode newFromDialString(String dialString, CDMAPhone phone) {\n    Matcher m;\n    CdmaMmiCode ret = null;\n\n    m = sPatternSuppService.matcher(dialString);\n\n    // Is this formatted like a standard supplementary service code?\n    if (m.matches()) {\n      ret = new CdmaMmiCode(phone);\n      ret.poundString = makeEmptyNull(m.group(MATCH_GROUP_POUND_STRING));\n      ret.action = makeEmptyNull(m.group(MATCH_GROUP_ACTION));\n      ret.sc = makeEmptyNull(m.group(MATCH_GROUP_SERVICE_CODE));\n      ret.sia = makeEmptyNull(m.group(MATCH_GROUP_SIA));\n      ret.sib = makeEmptyNull(m.group(MATCH_GROUP_SIB));\n      ret.sic = makeEmptyNull(m.group(MATCH_GROUP_SIC));\n      ret.pwd = makeEmptyNull(m.group(MATCH_GROUP_PWD_CONFIRM));\n      ret.dialingNumber = makeEmptyNull(m.group(MATCH_GROUP_DIALING_NUMBER));\n    }\n\n    return ret;\n  }\n"}, {"dataset": "group", "exampleID": 5764, "initialization": ["Matcher matcher = match()"], "initializationStart": [744], "initializationEnd": [758], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find() && matcher.groupCount()>0", "guardType": "LOOP {", "guardExpressionStart": 801, "guardExpressionEnd": 817, "guardBlockStart": 801, "guardBlockEnd": 1334, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 984, "focalAPIEnd": 994, "followUpCheck": "result.isEmpty()", "checkType": "IF", "followUpCheckExpressionStart": 1077, "followUpCheckExpressionEnd": 1097, "followUpCheckBlockStart": 1077, "followUpCheckBlockEnd": 1137, "use": ["matcher.group()", "new TrackingId(*,result,*)"], "useStart": [1039, 1266], "useEnd": [1048, 1320], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/catrope/gerrit/tree/master/gerrit-server/src/main/java/com/google/gerrit/server/ChangeUtil.java", "rawCode": "  public static void updateTrackingIds(\n      ReviewDb db, Change change, TrackingFooters trackingFooters, List<FooterLine> footerLines)\n      throws OrmException {\n    if (trackingFooters.getTrackingFooters().isEmpty() || footerLines.isEmpty()) {\n      return;\n    }\n\n    final Set<TrackingId> want = new HashSet<TrackingId>();\n    final Set<TrackingId> have =\n        new HashSet<TrackingId>( //\n            db.trackingIds().byChange(change.getId()).toList());\n\n    for (final TrackingFooter footer : trackingFooters.getTrackingFooters()) {\n      for (final FooterLine footerLine : footerLines) {\n        if (footerLine.matches(footer.footerKey())) {\n          // supporting multiple tracking-ids on a single line\n          final Matcher m = footer.match().matcher(footerLine.getValue());\n          while (m.find()) {\n            if (m.group().isEmpty()) {\n              continue;\n            }\n\n            String idstr;\n            if (m.groupCount() > 0) {\n              idstr = m.group(1);\n            } else {\n              idstr = m.group();\n            }\n\n            if (idstr.isEmpty()) {\n              continue;\n            }\n            if (idstr.length() > TrackingId.TRACKING_ID_MAX_CHAR) {\n              continue;\n            }\n\n            want.add(new TrackingId(change.getId(), idstr, footer.system()));\n          }\n        }\n      }\n    }\n\n    // Only insert the rows we don't have, and delete rows we don't match.\n    //\n    final Set<TrackingId> toInsert = new HashSet<TrackingId>(want);\n    final Set<TrackingId> toDelete = new HashSet<TrackingId>(have);\n\n    toInsert.removeAll(have);\n    toDelete.removeAll(want);\n\n    db.trackingIds().insert(toInsert);\n    db.trackingIds().delete(toDelete);\n  }\n"}, {"dataset": "group", "exampleID": 5765, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [177], "initializationEnd": [199], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()", "matcher.groupCount()"], "configurationStart": [216, 250], "configurationEnd": [227, 264], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 296, "focalAPIEnd": 306, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(String,result)", "matcher.matches()", "matcher.groupCount()", "matcher.group(int)", "matcher.group(int)", "assertEquals(String,result)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.matches()", "matcher.groupCount()", "matcher.group(int)", "assertEquals(String,result)", "matcher.group(int)", "matcher.matches()"], "useStart": [271, 397, 431, 475, 513, 492, 549, 585, 621, 768, 802, 842, 823, 871, 1280], "useEnd": [307, 408, 445, 485, 523, 524, 559, 595, 631, 779, 816, 852, 853, 881, 1291], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robovm/robovm/tree/master/tests/libcore/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/Pattern2Test.java", "rawCode": "  public void testCapturingGroups() throws PatternSyntaxException {\n    Pattern p;\n    Matcher m;\n\n    // Test simple capturing groups\n    p = Pattern.compile(\"(a+)b\");\n    m = p.matcher(\"aaaaaaaab\");\n    assertTrue(m.matches());\n    assertEquals(1, m.groupCount());\n    assertEquals(\"aaaaaaaa\", m.group(1));\n\n    p = Pattern.compile(\"((an)+)((as)+)\");\n    m = p.matcher(\"ananas\");\n    assertTrue(m.matches());\n    assertEquals(4, m.groupCount());\n    assertEquals(\"ananas\", m.group(0));\n    assertEquals(\"anan\", m.group(1));\n    assertEquals(\"an\", m.group(2));\n    assertEquals(\"as\", m.group(3));\n    assertEquals(\"as\", m.group(4));\n\n    // Test grouping without capture (?:...)\n    p = Pattern.compile(\"(?:(?:an)+)(as)\");\n    m = p.matcher(\"ananas\");\n    assertTrue(m.matches());\n    assertEquals(1, m.groupCount());\n    assertEquals(\"as\", m.group(1));\n    try {\n      m.group(2);\n      fail(\"expected IndexOutOfBoundsException\");\n    } catch (IndexOutOfBoundsException ioobe) {\n      // expected\n    }\n\n    // Test combination of grouping and capture\n    // TODO\n\n    // Test \\<num> sequence with capturing and non-capturing groups\n    // TODO\n\n    // Test \\<num> with <num> out of range\n    p = Pattern.compile(\"((an)+)as\\\\1\");\n    m = p.matcher(\"ananasanan\");\n    assertTrue(m.matches());\n\n    try {\n      p = Pattern.compile(\"((an)+)as\\\\4\");\n      fail(\"expected PatternSyntaxException\");\n    } catch (PatternSyntaxException pse) {\n      // expected\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5766, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [49], "initializationEnd": [76], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.find()"], "configurationStart": [101], "configurationEnd": [109], "guardCondition": "!(matcher.group(group,)==null)", "guardType": "IF {", "guardExpressionStart": 211, "guardExpressionEnd": 234, "guardBlockStart": 211, "guardBlockEnd": 322, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 215, "focalAPIEnd": 225, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(result)"], "useStart": [295], "useEnd": [315], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7650/src/net/sourceforge/plantuml/FileGroup.java", "rawCode": "  private void recurse() {\n    final Matcher m = predirPath.matcher(pattern);\n    final boolean ok = m.find();\n    if (ok == false) {\n      throw new IllegalArgumentException();\n    }\n    final File parent;\n    if (m.group(1) == null) {\n      parent = new File(\".\");\n    } else {\n      parent = new File(m.group(1));\n    }\n    initWithDoubleStar(parent);\n  }\n"}, {"dataset": "group", "exampleID": 5767, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [754], "initializationEnd": [795], "hasTryCatch": 1, "exceptionType": "UnknownHostException", "exceptionHandlingCall": ["error(String,*)"], "tryExpressionStart": 560, "tryExpressionEnd": 564, "tryBlockStart": 560, "tryBlockEnd": 1833, "catchExpressionStart": 1191, "catchExpressionEnd": 1222, "catchBlockStart": 1191, "catchBlockEnd": 1333, "exceptionHandlingCallStart": [1234], "exceptionHandlingCallEnd": [1302], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 974, "focalAPIEnd": 984, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["result.lastIndexOf(char)", "result.substring(*)", "getByName(result)", "matcher.group(int)"], "useStart": [1026, 1095, 1152, 1411], "useEnd": [1047, 1118, 1179, 1421], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dimalabs/stratosphere-iterations/tree/master/nephele/nephele-clustermanager/src/main/java/eu/stratosphere/nephele/instance/cluster/ClusterManager.java", "rawCode": "  /** Reads the IP to instance type mapping from the slave file. */\n  private void loadIPToInstanceTypeMapping() {\n\n    final String configDir = GlobalConfiguration.getString(CONFIG_DIR_KEY, null);\n    if (configDir == null) {\n      LOG.error(\"Cannot find configuration directory to read IP to instance type mapping\");\n      return;\n    }\n\n    final File slaveFile = new File(configDir + File.separator + SLAVE_FILE_NAME);\n    if (!slaveFile.exists()) {\n      LOG.error(\"Cannot access slave file to read IP to instance type mapping\");\n      return;\n    }\n\n    try {\n\n      final BufferedReader input = new BufferedReader(new FileReader(slaveFile));\n\n      String line = null;\n\n      while ((line = input.readLine()) != null) {\n\n        final Matcher m = IP_TO_INSTANCE_TYPE_PATTERN.matcher(line);\n        if (!m.matches()) {\n          LOG.error(\"Entry does not match format: \" + line);\n          continue;\n        }\n        InetAddress address = null;\n        String host = m.group(1);\n        try {\n          final int pos = host.lastIndexOf('/');\n          if (pos != -1) {\n            host = host.substring(pos + 1);\n          }\n          address = InetAddress.getByName(host);\n        } catch (UnknownHostException e) {\n          LOG.error(\"Cannot resolve \" + host + \" to a hostname/IP address\", e);\n          continue;\n        }\n\n        InstanceType instanceType = null;\n        String instanceTypeName = m.group(2);\n        if (instanceTypeName != null && instanceTypeName.length() > 0) {\n\n          instanceType = getInstanceTypeByName(instanceTypeName);\n          if (instanceType != null) {\n            this.ipToInstanceTypeMapping.put(address, instanceType);\n          }\n        }\n      }\n\n      input.close();\n\n    } catch (IOException e) {\n      LOG.error(\"Cannot load IP to instance type mapping from file \" + e);\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5768, "initialization": ["Matcher matcher = matcher(String)"], "initializationStart": [490], "initializationEnd": [512], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()"], "configurationStart": [531], "configurationEnd": [542], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 605, "focalAPIEnd": 615, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher(result)", "matcher.matches()", "matcher.group(int)", "matcher.group(int)"], "useStart": [634, 678, 735, 762], "useEnd": [659, 689, 745, 772], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/boundlessgeo/geotools-2.7.x/tree/master/build/maven/javadoc/src/test/java/org/geotools/maven/taglet/SourceTest.java", "rawCode": "  /** Tests the regular expression validity using the tag for this source file. */\n  @Test\n  public void testCurrentTag() {\n    Source s = new Source();\n    Matcher m;\n    String tag, url, group, category, module;\n    tag = \"$URL$\";\n    // The url above is only converted from $URL$ if we have obtained the\n    // file using a standard access mechanism to SVN. This fails, for\n    // example, with mercurial converstion 'hg convert svnrepo hgrepo'\n    if (!tag.equals(\"$URL$\")) {\n      m = s.findURL.matcher(tag);\n      assertTrue(m.matches());\n\n      // Try to match the URL provided by SVN.\n      url = m.group(1).trim();\n      m = s.findModule.matcher(url);\n      assertTrue(m.matches());\n      group = m.group(1);\n      category = m.group(2);\n      module = m.group(3);\n      assertEquals(\"build\", group);\n      assertEquals(\"maven\", category);\n      assertEquals(\"javadoc\", module);\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5769, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [319], "initializationEnd": [331], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.find()"], "configurationStart": [337], "configurationEnd": [345], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 358, "focalAPIEnd": 368, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-6242/src/net/sourceforge/plantuml/cucadiagram/dot/CucaDiagramFileMaker.java", "rawCode": "  public static String getSvg(UGraphicSvg ug) throws IOException {\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ug.createXml(baos);\n    baos.close();\n    final String s = new String(baos.toByteArray(), \"UTF-8\");\n    final Pattern p = Pattern.compile(\"(?i)<g\\\\W.*</g>\");\n    final Matcher m = p.matcher(s);\n    m.find();\n    return m.group(0);\n  }\n"}, {"dataset": "group", "exampleID": 5770, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [83], "initializationEnd": [111], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 117, "guardExpressionEnd": 130, "guardBlockStart": 117, "guardBlockEnd": 156, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 145, "focalAPIEnd": 155, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ESGF/esgf-node-manager/tree/master/src/java/main/esg/node/filters/AccessLoggingDAO.java", "rawCode": "  private String strip(String url) {\n    String strippedUrl = url;\n    Matcher m = urlStripPattern.matcher(url);\n    if (m.find()) strippedUrl = m.group(3);\n    return strippedUrl;\n  }\n"}, {"dataset": "group", "exampleID": 5771, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [360], "initializationEnd": [392], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 398, "guardExpressionEnd": 411, "guardBlockStart": 398, "guardBlockEnd": 541, "focalAPI": "result = matcher.group()", "focalAPIStart": 451, "focalAPIEnd": 460, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getArrayType(result,IType,int)", "matcher.replaceAll(String)"], "useStart": [438, 503], "useEnd": [487, 519], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wso2/tools/tree/master/ide/eclipse/jaggery/org.eclipse.php.core/src/org/eclipse/php/internal/core/typeinference/evaluators/phpdoc/PHPDocClassVariableEvaluator.java", "rawCode": "  public static MultiTypeType getArrayType(String type, IType currentNamespace, int offset) {\n    int beginIndex = type.indexOf(\"[\") + 1; // $NON-NLS-1$\n    int endIndex = type.lastIndexOf(\"]\"); // $NON-NLS-1$\n    if (endIndex != -1) {\n      type = type.substring(beginIndex, endIndex);\n    }\n    MultiTypeType arrayType = new MultiTypeType();\n    Matcher m = ARRAY_TYPE_PATTERN.matcher(type);\n    if (m.find()) {\n      arrayType.addType(getArrayType(m.group(), currentNamespace, offset));\n      type = m.replaceAll(\"\"); // $NON-NLS-1$\n    }\n    String[] typeNames = type.split(\",\"); // $NON-NLS-1$\n    for (String name : typeNames) {\n      if (!\"\".equals(name)) { // $NON-NLS-1$\n\n        if (name.indexOf(NamespaceReference.NAMESPACE_SEPARATOR) > 0 && currentNamespace != null) {\n          // check if the first part is an\n          // alias,then get the full name\n          ModuleDeclaration moduleDeclaration =\n              SourceParserUtil.getModuleDeclaration(currentNamespace.getSourceModule());\n          String prefix = name.substring(0, name.indexOf(NamespaceReference.NAMESPACE_SEPARATOR));\n          final Map<String, UsePart> result =\n              PHPModelUtils.getAliasToNSMap(\n                  prefix, moduleDeclaration, offset, currentNamespace, true);\n          if (result.containsKey(prefix)) {\n            String fullName = result.get(prefix).getNamespace().getFullyQualifiedName();\n            name = name.replace(prefix, fullName);\n            if (name.charAt(0) != NamespaceReference.NAMESPACE_SEPARATOR) {\n              name = NamespaceReference.NAMESPACE_SEPARATOR + name;\n            }\n          }\n        }\n        arrayType.addType(getEvaluatedType(name, currentNamespace));\n      }\n    }\n    return arrayType;\n  }\n"}, {"dataset": "group", "exampleID": 5772, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 279, "focalAPIEnd": 289, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jsvm/JSVM/tree/master/WEB-INF/src/org/jsvm/util/FileUtil.java", "rawCode": "  /**\n   * Return file name, exclude file path.\n   *\n   * @param path\n   * @return\n   * @see #getFilePath(String)\n   */\n  public static String getFileName(final String path) {\n    if (path == null) return path;\n\n    Matcher m = REGX_PATH.matcher(path);\n\n    return m.matches() ? m.group(2) : path;\n  }\n"}, {"dataset": "group", "exampleID": 5773, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [307], "initializationEnd": [342], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 349, "guardExpressionEnd": 365, "guardBlockStart": 349, "guardBlockEnd": 466, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 398, "focalAPIEnd": 408, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getRepository(result)"], "useStart": [430], "useEnd": [459], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sdorra/scm-manager/tree/master/scm-core/src/main/java/sonia/scm/web/filter/RegexPermissionFilter.java", "rawCode": "  /**\n   * Method description\n   *\n   * @param request\n   * @return\n   */\n  @Override\n  protected Repository getRepository(HttpServletRequest request) {\n    Repository repository = null;\n    String uri = request.getRequestURI();\n\n    uri = uri.substring(request.getContextPath().length());\n\n    Matcher m = PATTERN_REPOSITORYNAME.matcher(uri);\n\n    if (m.matches()) {\n      String repositoryname = m.group(1);\n\n      repository = getRepository(repositoryname);\n    }\n\n    return repository;\n  }\n"}, {"dataset": "group", "exampleID": 5774, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [117], "initializationEnd": [137], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 143, "guardExpressionEnd": 168, "guardBlockStart": 143, "guardBlockEnd": 237, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 207, "focalAPIEnd": 229, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseBoolean(result)"], "useStart": [186], "useEnd": [230], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stefanotravelli/seam-2.2/tree/master/src/ioc/org/jboss/seam/ioc/microcontainer/SeamComponentRegistryPlugin.java", "rawCode": "  protected static Boolean parseCreate(String name) {\n    Boolean create = Boolean.TRUE;\n    Matcher createMatcher = CREATE.matcher(name);\n    if (createMatcher.find()) {\n      create = Boolean.parseBoolean(createMatcher.group(1));\n    }\n    return create;\n  }\n"}, {"dataset": "group", "exampleID": 5775, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [87], "initializationEnd": [110], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 135, "guardExpressionEnd": 151, "guardBlockStart": 135, "guardBlockEnd": 311, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 191, "focalAPIEnd": 201, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["encode(result)", "matcher.group(int)"], "useStart": [180, 228], "useEnd": [202, 238], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Kaljurand/Arvutaja/tree/master/app/src/ee/ioc/phon/android/arvutaja/command/Direction.java", "rawCode": "  @Override\n  public Intent getIntent() throws CommandParseException {\n    Matcher m = p.matcher(getCommand());\n    String fromTo;\n    if (m.matches()) {\n      fromTo = \"saddr=\" + Uri.encode(m.group(1)) + \"&daddr=\" + Uri.encode(m.group(2));\n    } else {\n      fromTo = \"daddr=\" + Uri.encode(getCommand());\n    }\n\n    return new Intent(Intent.ACTION_VIEW, Uri.parse(MAPS_GOOGLE_COM + fromTo));\n  }\n"}, {"dataset": "group", "exampleID": 5776, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [930], "initializationEnd": [971], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 1122, "guardExpressionEnd": 1152, "guardBlockStart": 1122, "guardBlockEnd": 2649, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1171, "focalAPIEnd": 1195, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "Map<String, Map<String, String>>.put(result,Map<String, String>)", "Map<String, String>.put(result,String)"], "useStart": [1225, 2412, 2467], "useEnd": [1249, 2457, 2514], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IQSS/dvn/tree/master/src/DVN-ingest/src/edu/harvard/iq/dvn/ingest/statdataio/impl/plugins/spss/SPSSFileReader.java", "rawCode": "  int read_ValLabels(String valLabelsCommand) {\n\n    int readStatus = 0;\n\n    Map<String, Map<String, String>> valueLabelTable =\n        new LinkedHashMap<String, Map<String, String>>();\n    Map<String, String> valueVariableMappingTable = new LinkedHashMap<String, String>();\n\n    // Value Labels are referenced by the (declared) variable names,\n    // followed by a number of value-\"label\" pairs; for every variable\n    // the entry is terminated with a \"/\".\n\n    dbgLog.fine(\"parsing \" + valLabelsCommand + \" for value labels.\");\n\n    if (valLabelsCommand == null || valLabelsCommand.equals(\"\")) {\n      return readStatus;\n    }\n\n    String varName = null;\n    String valLabelDeclaration = null;\n\n    String varValue = null;\n    String valueLabel = null;\n\n    int labelCounter = 0;\n\n    String valLabelRegex = \"\\\\s*(\\\\S+)\\\\s+([^/]+)/\";\n    Pattern valLabelPattern = Pattern.compile(valLabelRegex);\n    Matcher valLabelMatcher = valLabelPattern.matcher(valLabelsCommand);\n\n    String labelDeclarationRegex = \"\\\\s*(\\\\S+)\\\\s+(\\\"[^\\\"]*\\\")\";\n    Pattern labelDeclarationPattern = Pattern.compile(labelDeclarationRegex);\n\n    while (valLabelMatcher.find()) {\n      varName = valLabelMatcher.group(1);\n      valLabelDeclaration = valLabelMatcher.group(2);\n\n      dbgLog.fine(\"found value label declaration for \" + varName + \": \" + valLabelDeclaration);\n\n      Map<String, String> valueLabelPairs = new LinkedHashMap<String, String>();\n\n      Matcher labelDeclarationMatcher = labelDeclarationPattern.matcher(valLabelDeclaration);\n\n      int localLabelCounter = 0;\n\n      while (labelDeclarationMatcher.find()) {\n        varValue = labelDeclarationMatcher.group(1);\n        valueLabel = labelDeclarationMatcher.group(2);\n\n        dbgLog.fine(\"found label \" + valueLabel + \" for value \" + varValue);\n\n        Boolean isNumeric = false; // TODO: !\n        if (isNumeric) {\n          // Numeric variable:\n          dbgLog.fine(\"processing numeric value label\");\n          valueLabelPairs.put(doubleNumberFormatter.format(new Double(varValue)), valueLabel);\n        } else {\n          // String variable\n          dbgLog.fine(\"processing string value label\");\n          varValue = varValue.replaceFirst(\"^[\\\"']\", \"\");\n          varValue = varValue.replaceFirst(\"[\\\"']$\", \"\");\n\n          valueLabelPairs.put(varValue, valueLabel);\n        }\n\n        localLabelCounter++;\n      }\n\n      if (localLabelCounter > 0) {\n        valueLabelTable.put(varName, valueLabelPairs);\n        valueVariableMappingTable.put(varName, varName);\n        labelCounter += localLabelCounter;\n      }\n\n      // TODO:\n      // Do SPSS cards support shared value label sets -- ?\n\n    }\n\n    if (labelCounter > 0) {\n      smd.setValueLabelTable(valueLabelTable);\n      smd.setValueLabelMappingTable(valueVariableMappingTable);\n      readStatus = labelCounter;\n    }\n\n    // TODO:\n    // Better validation, error reporting.\n\n    return readStatus;\n  }\n"}, {"dataset": "group", "exampleID": 5777, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(sAgent.indexOf(\"KHTML\",)!=-group) &&  !(sAgent.indexOf(\"Opera\",)!=-group)", "guardType": "IF {", "guardExpressionStart": 385, "guardExpressionEnd": 419, "guardBlockStart": 385, "guardBlockEnd": 435, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 646, "focalAPIEnd": 661, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [670], "useEnd": [685], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/branches/DEV_v1_8/src/util/misc/UserAgent.java", "rawCode": "  /**\n   * @param request the request to analyse the user-agent header of.\n   * @return A string identifying the browser that made the request, of the form gecko-1-8 or\n   *     ie-5[space]ie-5-5, or empty string if unknown\n   */\n  public static String getBrowserString(HttpServletRequest request) {\n    String sAgent = request.getHeader(\"user-agent\");\n    // Filter troublemakers\n    if (sAgent.indexOf(\"KHTML\") != -1) return \"khtml\";\n    if (sAgent.indexOf(\"Opera\") != -1) return \"opera\";\n\n    // Check version of our two supported browsers\n    Matcher mGecko = GECKOVERSION.matcher(sAgent);\n    if (mGecko.matches()) {\n      return \"gecko-\" + mGecko.group(1) + \"-\" + mGecko.group(2);\n    }\n    Matcher mIE = IEVERSION.matcher(sAgent);\n    if (mIE.matches()) {\n      return \"winie-\" + mIE.group(1); // Major verison only\n    }\n\n    return \"\";\n  }\n"}, {"dataset": "group", "exampleID": 5778, "initialization": ["Matcher matcher = matcher(*)", "Matcher matcher = matcher(*)"], "initializationStart": [153, 947], "initializationEnd": [187, 981], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()"], "configurationStart": [987], "configurationEnd": [998], "guardCondition": "!(matcher.matches())", "guardType": "IF {", "guardExpressionStart": 235, "guardExpressionEnd": 251, "guardBlockStart": 235, "guardBlockEnd": 816, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1038, "focalAPIEnd": 1048, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "new AwayEventImpl(result,*,boolean,boolean,*,*,Session)"], "useStart": [1129, 1011], "useEnd": [1139, 1190], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/EnderWiggin/Haven-and-Hearth-client-modified-by-Ender/tree/master/src/jerklib/parsers/AwayParser.java", "rawCode": "  public IRCEvent createEvent(EventToken token, IRCEvent event) {\n    Pattern p = Pattern.compile(\"^:\\\\S+\\\\s\\\\d{3}\\\\s+(\\\\S+)\\\\s:(.*)$\");\n    Matcher m = p.matcher(event.getRawEventData());\n    Session session = event.getSession();\n    if (m.matches()) {\n      switch (Integer.parseInt(token.command())) {\n        case 305:\n          return new AwayEventImpl(\n              session,\n              EventType.RETURNED_FROM_AWAY,\n              false,\n              true,\n              session.getNick(),\n              event.getRawEventData());\n        case 306:\n          {\n            return new AwayEventImpl(\n                session,\n                EventType.WENT_AWAY,\n                true,\n                true,\n                session.getNick(),\n                event.getRawEventData());\n          }\n      }\n    }\n\n    // :card.freenode.net 301 r0bby_ r0bby :foo\n    p = Pattern.compile(\"^:\\\\S+\\\\s+\\\\d{3}\\\\s+\\\\S+\\\\s+(\\\\S+)\\\\s+:(.*)$\");\n    m = p.matcher(event.getRawEventData());\n    m.matches();\n    return new AwayEventImpl(\n        m.group(2),\n        AwayEvent.EventType.USER_IS_AWAY,\n        true,\n        false,\n        m.group(1),\n        event.getRawEventData(),\n        session);\n  }\n"}, {"dataset": "group", "exampleID": 5779, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [194], "initializationEnd": [252], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 260, "guardExpressionEnd": 295, "guardBlockStart": 260, "guardBlockEnd": 368, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 329, "focalAPIEnd": 358, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addDataSourceName(result)"], "useStart": [306], "useEnd": [359], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Union-Investment/Crud2Go/tree/master/eai-portal-xsd-crudportlet/src/main/java/de/unioninvestment/eai/portal/portlet/crud/config/visitor/DatasourceNameCollectingVisitor.java", "rawCode": "  private void visitScriptConfig(ScriptConfig config) {\n    GroovyScript script = config.getValue();\n    if (script != null && script.getSource() != null) {\n      Matcher datasourceNameFinder = DATASOURCE_NAME_FINDER_PATTERN.matcher(script.getSource());\n      while (datasourceNameFinder.find()) {\n        this.addDataSourceName(datasourceNameFinder.group(1));\n      }\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5780, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [921], "initializationEnd": [959], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 966, "guardExpressionEnd": 979, "guardBlockStart": 966, "guardBlockEnd": 1195, "focalAPI": "result = matcher.group()", "focalAPIStart": 1003, "focalAPIEnd": 1012, "followUpCheck": "result.indexOf(\"aaa<!--bbb\") == -1", "checkType": "IF", "followUpCheckExpressionStart": 1020, "followUpCheckExpressionEnd": 1058, "followUpCheckBlockStart": 1020, "followUpCheckBlockEnd": 1123, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/icefaces/tree/master/test/HtmlUnitTest/src/org/icefaces/htmlunit/ICE_3182Test.java", "rawCode": "  /**\n   * Post some cdata terminating characters into the input text field and verify that they show up\n   * in the echoing text field, and i suppose in the input text field itself.\n   *\n   * @throws Exception test exception\n   */\n  public void doXMLCommentFull() throws Exception {\n\n    // check to see if the pre-rendered input fields have the correct values\n\n    String val = getHtmlInputValue(page, \"form1:inOne\");\n    Assert.assertEquals(\"]]>\", val);\n\n    val = getHtmlInputValue(page, \"form1:inTwo\");\n    Assert.assertEquals(\"]]>\", val);\n\n    setInputTextValue(page, \"form1:in1\", \"aaa<!--bbb\");\n\n    // This is a simple event to toggle the path of a ui:include tag on the page\n    HtmlPage page2 = clickElement(page, \"form1:childAdder\", webClient);\n\n    // make sure new bit has arrived\n    HtmlTextInput hti = (HtmlTextInput) page2.getElementById(\"form1:autogen\");\n    Assert.assertNotNull(hti);\n\n    Matcher m = output_pattern.matcher(page2.asText());\n\n    if (m.find()) {\n      String value = m.group();\n      if (value.indexOf(\"aaa<!--bbb\") == -1) {\n        Assert.fail(\"Failed to find expected output\");\n      }\n    } else {\n      Assert.fail(\"Failed to find expected output\");\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5781, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [978], "initializationEnd": [1024], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 1038, "guardExpressionEnd": 1054, "guardBlockStart": 1038, "guardBlockEnd": 1368, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1088, "focalAPIEnd": 1098, "followUpCheck": "result.equals(name) && (true)", "checkType": "IF", "followUpCheckExpressionStart": 1158, "followUpCheckExpressionEnd": 1265, "followUpCheckBlockStart": 1158, "followUpCheckBlockEnd": 1354, "use": ["matcher.group(int)"], "useStart": [1132], "useEnd": [1142], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wso2/tools/tree/master/ide/eclipse/jaggery/org.eclipse.php.debug.core/src/org/eclipse/php/internal/debug/core/phpIni/INIFileModifier.java", "rawCode": "  /**\n   * Adds new entry to the INI file. If <code>replace</code> is <code>true</code> the old entry will\n   * be replaced, otherwise - add a new one.\n   *\n   * @param sectionName Section name\n   * @param name Entry name\n   * @param value Value name\n   * @param replace Whether to replace the old entry or add a new one\n   * @param replacePattern Pattern to check against existing entry value, before replacing it. If\n   *     <code>replacePattern</code> is <code>null</code> - every entry that matches the given name\n   *     will be replaced\n   */\n  public void addEntry(\n      String sectionName, String name, String value, boolean replace, String replacePattern) {\n    if (sectionName == null || name == null || value == null) {\n      throw new NullPointerException();\n    }\n    for (INIFileSection section : sections) {\n      if (section.name.equals(sectionName)) {\n        if (replace) {\n          for (int i = 0; i < section.lines.size(); ++i) {\n            Matcher m = NAME_VAL_PATTERN.matcher(section.lines.get(i));\n            if (m.matches()) {\n              String oldName = m.group(1);\n              String oldValue = m.group(2);\n              if (oldName.equals(name)\n                  && (replacePattern == null || oldValue.matches(replacePattern))) {\n                section.lines.set(i, name + '=' + quoteString(value));\n              }\n            }\n          }\n        } else {\n          section.lines.add(name + '=' + quoteString(value));\n        }\n        break;\n      }\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5782, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [1642], "initializationEnd": [1666], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()"], "configurationStart": [1678], "configurationEnd": [1689], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1742, "focalAPIEnd": 1752, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["appendPath(String,result)", "matcher.matches()", "matcher.group(int)", "appendPath(String,result)", "matcher.matches()", "matcher.group(int)", "parseInt(result)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [1711, 2045, 3059, 3028, 3367, 3947, 3930, 3975, 4205, 4233], "useEnd": [1753, 2079, 3069, 3070, 3401, 3957, 3958, 3985, 4215, 4243], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/istlab/Alitheia-Core/tree/master/alitheia/core/src/main/java/eu/sqooss/impl/service/tds/diff/UnifiedDiffParser.java", "rawCode": "  /** Parse a unified diff and return true on success or false and set the error message. */\n  public boolean parseDiff() {\n    // Don't re-parse the parsed diff\n    if (parsed) return true;\n\n    Pattern chunkStart = Pattern.compile(diffChunkStart);\n    Pattern propChunk = Pattern.compile(propChunkStart);\n    Pattern fileTarget = Pattern.compile(chunkFileTarget);\n    Pattern fileSource = Pattern.compile(chunkFileSource);\n    Pattern idx = Pattern.compile(index);\n    Pattern equals = Pattern.compile(eqs);\n\n    Matcher m = null;\n\n    BufferedReader r = new BufferedReader(new StringReader(theDiff));\n    String line;\n\n    boolean diffStart = false, chnkStart = false;\n    StringBuffer curChunkText = null;\n    String curPath = null;\n    DiffChunkImpl curChunk = null;\n    List<DiffChunk> curChunkList = null;\n    try {\n      while ((line = r.readLine()) != null) {\n        /*\n         * Skip SVN introduced lines like\n         * Index: specs/src/eu/sqooss/impl/service/dsl/SpRevision.java\n         * ===========================================================\n         */\n        if (idx.matcher(line).matches() || equals.matcher(line).matches()) {\n          continue;\n        }\n\n        /* Match lines like\n         * --- specs/src/eu/sqooss/impl/service/dsl/SpRevision.java\n         *\n         *\n         * and record file name. Match either of those 2 lines\n         * signifies start of parsing chunks\n         */\n        if (fileSource.matcher(line).matches()) {\n          // New group found\n          if (diffStart == true && curChunkList.size() != 0) {\n            diffChunks.put(curPath, curChunkList);\n          }\n\n          m = fileSource.matcher(line);\n          m.matches();\n          curPath = FileUtils.appendPath(basePath, m.group(1));\n          changedPaths.add(curPath);\n          curChunkList = new ArrayList<DiffChunk>();\n          diffStart = true;\n          continue;\n        }\n        /* those lines are not really interesting\n         * +++ specs/src/eu/sqooss/impl/service/dsl/SpRevision.java\n         */\n        if (fileTarget.matcher(line).matches()) {\n          continue;\n        }\n\n        /*\n         * Match a chunk describing a property change\n         * (this is SVN specific code)\n         * Property changes on: ProjectFile.java\n         */\n        if (propChunk.matcher(line).matches()) {\n          /* Match */\n          if (chnkStart == true) {\n            curChunk.setChunk(curChunkText.toString());\n            curChunkList.add(curChunk);\n          }\n\n          chnkStart = true;\n          curChunk = new DiffChunkImpl();\n          curChunk.setDiffOp(DiffOp.UNDEF);\n          curChunkText = new StringBuffer();\n\n          /* If the property change is the only thing\n           * appearing in the diff, we need to start\n           * parsing and init some variables first.\n           */\n          if (!diffStart) {\n            curChunkList = new ArrayList<DiffChunk>();\n            diffStart = true;\n            m = propChunk.matcher(line);\n            m.matches();\n            curPath = FileUtils.appendPath(basePath, m.group(1));\n            changedPaths.add(curPath);\n          }\n        }\n\n        if (!diffStart) {\n          error = \"Not a chunk header: \" + line;\n          return false;\n        }\n\n        /* Match chunk start lines like\n         * @@ -111,10 +111,10 @@ or\n         * @@ -1 +1 @@\n         */\n        if (chunkStart.matcher(line).matches()) {\n\n          if (chnkStart == true) {\n            curChunk.setChunk(curChunkText.toString());\n            curChunkList.add(curChunk);\n          }\n\n          chnkStart = true;\n          curChunk = new DiffChunkImpl();\n          m = chunkStart.matcher(line);\n          // We already know that it matches, just trigger the group extraction\n          m.matches();\n\n          // Unified diffs do not support this\n          curChunk.setDiffOp(DiffOp.UNDEF);\n          curChunk.setPath(curPath);\n          curChunk.setSourceStartLine(Integer.parseInt(m.group(1)));\n          if (m.group(2) != null) {\n            curChunk.setSourceLenght(Integer.parseInt(m.group(2).substring(1)));\n          } else {\n            curChunk.setSourceLenght(0);\n          }\n          curChunk.setTargetStartLine(Integer.parseInt(m.group(3)));\n          if (m.group(4) != null) {\n            curChunk.setTargetLength(Integer.parseInt(m.group(4).substring(1)));\n          } else {\n            curChunk.setTargetLength(0);\n          }\n          curChunkText = new StringBuffer();\n          continue;\n        }\n\n        curChunkText.append(line).append(\"\\n\");\n      }\n    } catch (IOException e) {\n      error = \"Error reading diff file\";\n      return false;\n    }\n    // Clean up\n    if (curChunk != null) {\n      curChunk.setChunk(curChunkText.toString());\n      curChunkList.add(curChunk);\n      diffChunks.put(curPath, curChunkList);\n    } else {\n      // This means that the actual diff was empty\n      List<DiffChunk> l = Collections.emptyList();\n      diffChunks.put(curPath, l);\n    }\n\n    // Don't hold up space now that the diff is parsed\n    theDiff = null;\n    parsed = true;\n    return true;\n  }\n"}, {"dataset": "group", "exampleID": 5783, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [1687], "initializationEnd": [1715], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.start()"], "configurationStart": [1803], "configurationEnd": [1813], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 1762, "guardExpressionEnd": 1779, "guardBlockStart": 1762, "guardBlockEnd": 1917, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1862, "focalAPIEnd": 1873, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.appendReplacement(StringBuffer,String)", "matcher.appendTail(StringBuffer)"], "useStart": [1837, 1926], "useEnd": [1874, 1943], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/g-pechorin/degen/tree/master/jsyntaxpane/src/main/java/jsyntaxpane/actions/ActionUtils.java", "rawCode": "  /**\n   * Expand the string template and replaces the selection with the expansion of the template. The\n   * template String may contain any of the following special tags.\n   * <li>{@code #{selection}} replaced with the selection, if any. If there is no selection, then\n   *     the {@code #{selection}} tag will be removed.\n   * <li>{@code #{p:any text}} will be replaced by {@code any text} and then set selection to {@code\n   *     any text}\n   *\n   *     <p>This method properly handles indentation as follows: The indentation of the whole block\n   *     will match the indentation of the caret line, or the line with the beginning of the\n   *     selection, if the selection is in whole line, i.e.e one or more lines of selected text.\n   *     {@see selectLines()}\n   *\n   * @param target JEditorCOmponent to be affected\n   * @param templateLines template split as a String array of lines.\n   * @see insertLinesTemplate\n   */\n  public static void insertLinesTemplate(JTextComponent target, String[] templateLines) {\n    // get some stuff we'll need:\n    String thisIndent = getIndent(getLineAt(target, target.getSelectionStart()));\n    String[] selLines = getSelectedLines(target);\n    int selStart = -1, selEnd = -1;\n    StringBuffer sb = new StringBuffer();\n    for (String tLine : templateLines) {\n      int selNdx = tLine.indexOf(\"#{selection}\");\n      if (selNdx >= 0) {\n        // for each of the selected lines:\n        for (String selLine : selLines) {\n          sb.append(tLine.subSequence(0, selNdx));\n          sb.append(selLine);\n          sb.append('\\n');\n        }\n      } else {\n        sb.append(thisIndent);\n        // now check for any ptags\n        Matcher pm = PTAGS_PATTERN.matcher(tLine);\n        int lineStart = sb.length();\n        while (pm.find()) {\n          selStart = pm.start() + lineStart;\n          pm.appendReplacement(sb, pm.group(1));\n          selEnd = sb.length();\n        }\n        pm.appendTail(sb);\n        sb.append('\\n');\n      }\n    }\n    int ofst = target.getSelectionStart();\n    target.replaceSelection(sb.toString());\n    if (selStart >= 0) {\n      // target.setCaretPosition(selStart);\n      target.select(ofst + selStart, ofst + selEnd);\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5784, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [1121], "initializationEnd": [1152], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "conditional", "guardType": "IF {", "guardExpressionStart": 348, "guardExpressionEnd": 397, "guardBlockStart": 348, "guardBlockEnd": 617, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 1216, "focalAPIEnd": 1226, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)", "matcher.group(int)"], "useStart": [1199, 1265], "useEnd": [1227, 1275], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sgothel/jogl-demos/tree/master/src/demos/hdr/RGBE.java", "rawCode": "  public static Header readHeader(DataInputStream in) throws IOException {\n    int valid = 0;\n    String programType = null;\n    float gamma = 1.0f;\n    float exposure = 1.0f;\n    int width = 0;\n    int height = 0;\n\n    String buf = in.readLine();\n    if (buf == null) {\n      throw new IOException(\"Unexpected EOF reading magic token\");\n    }\n    if (buf.charAt(0) == '#' && buf.charAt(1) == '?') {\n      valid |= VALID_PROGRAMTYPE;\n      programType = buf.substring(2);\n      buf = in.readLine();\n      if (buf == null) {\n        throw new IOException(\"Unexpected EOF reading line after magic token\");\n      }\n    }\n\n    boolean foundFormat = false;\n    boolean done = false;\n    while (!done) {\n      if (buf.equals(\"FORMAT=32-bit_rle_rgbe\")) {\n        foundFormat = true;\n      } else if (buf.startsWith(gammaString)) {\n        valid |= VALID_GAMMA;\n        gamma = Float.parseFloat(buf.substring(gammaString.length()));\n      } else if (buf.startsWith(exposureString)) {\n        valid |= VALID_EXPOSURE;\n        exposure = Float.parseFloat(buf.substring(exposureString.length()));\n      } else {\n        Matcher m = widthHeightPattern.matcher(buf);\n        if (m.matches()) {\n          width = Integer.parseInt(m.group(2));\n          height = Integer.parseInt(m.group(1));\n          done = true;\n        }\n      }\n\n      if (!done) {\n        buf = in.readLine();\n        if (buf == null) {\n          throw new IOException(\"Unexpected EOF reading header\");\n        }\n      }\n    }\n\n    if (!foundFormat) {\n      throw new IOException(\"No FORMAT specifier found\");\n    }\n\n    return new Header(valid, programType, gamma, exposure, width, height);\n  }\n"}, {"dataset": "group", "exampleID": 5785, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group()", "focalAPIStart": 202, "focalAPIEnd": 211, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)"], "useStart": [231], "useEnd": [256], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ppolabs/jlinda/tree/master/jlinda-core/src/test/java/org/jlinda/core/coregistration/legacy/CoregistrationTest.java", "rawCode": "  private int extractNumber(String line) {\n    String numbers = new String();\n\n    Pattern p = Pattern.compile(\"\\\\d+\");\n    Matcher m = p.matcher(line);\n    while (m.find()) {\n      numbers = numbers + m.group();\n    }\n\n    return Integer.parseInt(numbers);\n  }\n"}, {"dataset": "group", "exampleID": 5786, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [146], "initializationEnd": [164], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 238, "focalAPIEnd": 250, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new WhileBlock(RowWrapper,result)"], "useStart": [314], "useEnd": [344], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seasarorg/fisshplate/tree/master/fisshplate/src/main/java/org/seasar/fisshplate/core/parser/WhileParser.java", "rawCode": "  public boolean process(CellWrapper cell, FPParser parser) throws FPParseException {\n    String value = cell.getStringValue();\n    Matcher mat = pat.matcher(value);\n    if (!mat.find()) {\n      return false;\n    }\n    String condition = mat.group(1);\n    RowWrapper row = cell.getRow();\n    AbstractBlock block = new WhileBlock(row, condition);\n    parser.addBlockElement(block);\n    return true;\n  }\n"}, {"dataset": "group", "exampleID": 5787, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [551], "initializationEnd": [595], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "IF {", "guardExpressionStart": 602, "guardExpressionEnd": 625, "guardBlockStart": 602, "guardBlockEnd": 701, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 648, "focalAPIEnd": 668, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setType(result)"], "useStart": [676], "useEnd": [694], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Y3PP3R/AP2DX/tree/master/java/AP2DX/src/AP2DX/usarsim/specialized/UOdometrySensorMessage.java", "rawCode": "  /**\n   * @see AP2DX.usarsim.specialized.SensorMessage#parseMessage() Parses all the fields in the\n   *     message and sets the values of the fields with the same name to the values.\n   * @throws IllegalAccessException\n   * @throws IllegalArgumentException\n   * @see AP2DX.Message#parseMessage()\n   */\n  @Override\n  public void parseMessage() throws IllegalArgumentException, IllegalAccessException {\n    String typePatternStr = \"\\\\{Type ([a-zA-Z0-9,._\\\\-]+)\\\\}\";\n    Pattern typePattern = Pattern.compile(typePatternStr);\n    Matcher typeMatcher = typePattern.matcher(this.getMessageString());\n\n    if (typeMatcher.find()) {\n      String type = typeMatcher.group(1);\n      this.setType(type);\n    }\n\n    String namePatternStr = \"\\\\{Name ([a-zA-Z0-9,._\\\\-]+)\\\\}\";\n    Pattern namePattern = Pattern.compile(namePatternStr);\n    Matcher nameMatcher = namePattern.matcher(this.getMessageString());\n\n    if (nameMatcher.find()) {\n      String name = nameMatcher.group(1);\n      this.setName(name);\n    }\n\n    String posPatternStr = \"\\\\{Pose ([0-9.,\\\\-_]+)\\\\}\";\n    Pattern posPattern = Pattern.compile(posPatternStr);\n    Matcher posMatcher = posPattern.matcher(this.getMessageString());\n\n    double[] data = null;\n    if (posMatcher.find()) {\n      String[] loc = posMatcher.group(1).split(\",\");\n      data = new double[loc.length];\n\n      for (int i = 0; i < data.length; i++) {\n        data[i] = Double.parseDouble(loc[i]);\n      }\n    }\n    this.setPose(data);\n  }\n"}, {"dataset": "group", "exampleID": 5788, "initialization": ["Matcher matcher = getStartingPattern()"], "initializationStart": [132], "initializationEnd": [152], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(matcher.find()==false) && matcher.group(group,)!=null", "guardType": "IF {", "guardExpressionStart": 187, "guardExpressionEnd": 214, "guardBlockStart": 187, "guardBlockEnd": 263, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 272, "focalAPIEnd": 287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["push(result)"], "useStart": [305], "useEnd": [334], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7940/src/net/sourceforge/plantuml/command/CommandSkinParamMultilines.java", "rawCode": "  public CommandExecutionResult execute(List<String> lines) {\n    final Context context = new Context();\n    final Matcher mStart = getStartingPattern().matcher(lines.get(0).trim());\n    if (mStart.find() == false) {\n      throw new IllegalStateException();\n    }\n    if (mStart.group(1) != null) {\n      context.push(mStart.group(1));\n    }\n\n    lines = new ArrayList<String>(lines.subList(1, lines.size() - 1));\n    StringUtils.trim(lines, true);\n\n    for (String s : lines) {\n      assert s.length() > 0;\n      if (s.equals(\"}\")) {\n        context.pop();\n        continue;\n      }\n      final Matcher m = p1.matcher(s);\n      if (m.find() == false) {\n        throw new IllegalStateException();\n      }\n      if (m.group(2) != null) {\n        context.push(m.group(1));\n      } else if (m.group(3) != null) {\n        final String key = context.getFullParam() + m.group(1);\n        getSystem().setParam(key, m.group(3));\n      } else {\n        throw new IllegalStateException();\n      }\n    }\n\n    return CommandExecutionResult.ok();\n  }\n"}, {"dataset": "group", "exampleID": 5789, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 339, "focalAPIEnd": 355, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "put(result,*)"], "useStart": [357, 327], "useEnd": [373, 374], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rejeep/apes/tree/master/src/apes/models/ApesConfiguration.java", "rawCode": "  /**\n   * When parsing the file and a match is found, this method is called. If the regex has been\n   * changed, it is most likely that this method should be overridden in the subclass.\n   *\n   * @param line The line that matches.\n   * @param matcher The matcher.\n   */\n  public void match(String line, Matcher matcher) {\n    options.put(matcher.group(1), matcher.group(3));\n  }\n"}, {"dataset": "group", "exampleID": 5790, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group()", "focalAPIStart": 183, "focalAPIEnd": 192, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/KLyko/Zitationsgraph/tree/master/src/de/uni/leipzig/asv/zitationsgraph/extraction/HeadExtraction.java", "rawCode": "  private void showMatch(Matcher m) {\n    System.out.print(\"### Start index: \" + m.start());\n    System.out.print(\", End index: \" + m.end() + \" \");\n    System.out.print(\", Match: \" + m.group() + \"\\n\");\n  }\n"}, {"dataset": "group", "exampleID": 5791, "initialization": ["Matcher matcher = RegexCache.getPatternForRegex(String)"], "initializationStart": [308], "initializationEnd": [352], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.find()"], "configurationStart": [386], "configurationEnd": [394], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group()", "focalAPIStart": 450, "focalAPIEnd": 459, "followUpCheck": "result.length() < nationalNumber.length()", "checkType": "IF", "followUpCheckExpressionStart": 628, "followUpCheckExpressionEnd": 680, "followUpCheckBlockStart": 628, "followUpCheckBlockEnd": 705, "use": ["result.replaceAll(String,String)"], "useStart": [780], "useEnd": [832], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/google-libphonenumber-mirror/tree/master/tags/libphonenumber-6.3.1/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java", "rawCode": "  private String getFormattingTemplate(String numberPattern, String numberFormat) {\n    // Creates a phone number consisting only of the digit 9 that matches the\n    // numberPattern by applying the pattern to the longestPhoneNumber string.\n    String longestPhoneNumber = \"999999999999999\";\n    Matcher m = regexCache.getPatternForRegex(numberPattern).matcher(longestPhoneNumber);\n    m.find(); // this will always succeed\n    String aPhoneNumber = m.group();\n    // No formatting template can be created if the number of digits entered so far is longer than\n    // the maximum the current formatting rule can accommodate.\n    if (aPhoneNumber.length() < nationalNumber.length()) {\n      return \"\";\n    }\n    // Formats the number according to numberFormat\n    String template = aPhoneNumber.replaceAll(numberPattern, numberFormat);\n    // Replaces each digit with character DIGIT_PLACEHOLDER\n    template = template.replaceAll(\"9\", DIGIT_PLACEHOLDER);\n    return template;\n  }\n"}, {"dataset": "group", "exampleID": 5792, "initialization": ["Matcher matcher = getMatcherAgainstContent(String)"], "initializationStart": [417], "initializationEnd": [462], "hasTryCatch": 1, "exceptionType": "URISyntaxException", "exceptionHandlingCall": ["processException(Logger,*)"], "tryExpressionStart": 503, "tryExpressionEnd": 507, "tryBlockStart": 503, "tryBlockEnd": 683, "catchExpressionStart": 589, "catchExpressionEnd": 624, "catchBlockStart": 589, "catchBlockEnd": 683, "exceptionHandlingCallStart": [636], "exceptionHandlingCallEnd": [672], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 470, "guardExpressionEnd": 492, "guardBlockStart": 470, "guardBlockEnd": 691, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 539, "focalAPIEnd": 555, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["result.replace(String,String)"], "useStart": [539], "useEnd": [575], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AbinashBishoyi/FreeRapid-Plugins/tree/master/src/dailymotion/cz/vity/freerapid/plugins/services/dailymotion/DailymotionRunner.java", "rawCode": "  private LinkedList<URI> getURIList(final String action) throws Exception {\n    final LinkedList<URI> uriList = new LinkedList<URI>();\n    int page = 1;\n    do {\n      if (!makeRedirectedRequest(\n          getDailyMotionMethodBuilder(action, page++, \"url\").toGetMethod())) {\n        checkProblems();\n        throw new ServiceConnectionProblemException();\n      }\n      checkProblems();\n      final Matcher matcher = getMatcherAgainstContent(\"\\\"url\\\":\\\"(.+?)\\\"\");\n      while (matcher.find()) {\n        try {\n          uriList.add(new URI(matcher.group(1).replace(\"\\\\/\", \"/\")));\n        } catch (final URISyntaxException e) {\n          LogUtils.processException(logger, e);\n        }\n      }\n    } while (getContentAsString().contains(\"\\\"has_more\\\":true\"));\n    return uriList;\n  }\n"}, {"dataset": "group", "exampleID": 5793, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [734], "initializationEnd": [749], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()"], "configurationStart": [769], "configurationEnd": [780], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 868, "focalAPIEnd": 879, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseLong(result)", "matcher.group(int)"], "useStart": [853, 929], "useEnd": [880, 940], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/0xdata/h2o/tree/master/src/main/java/water/util/LinuxProcFileReader.java", "rawCode": "  private void parseProcessProcFile(String s) {\n    if (s == null) return;\n\n    try {\n      BufferedReader reader = new BufferedReader(new StringReader(s));\n      String line = reader.readLine();\n\n      Pattern p =\n          Pattern.compile(\n              \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\"\n                  + \"\\\\s+\"\n                  + \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\"\n                  + \"\\\\s+\"\n                  + \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\"\n                  + \"\\\\s+\"\n                  + \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\"\n                  + \"\\\\s+\"\n                  + \"(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\\\\s+(\\\\S+)\"\n                  + \".*\");\n      Matcher m = p.matcher(line);\n      boolean b = m.matches();\n      if (!b) {\n        return;\n      }\n\n      long processUserTicks = Long.parseLong(m.group(14));\n      long processSystemTicks = Long.parseLong(m.group(15));\n      _processTotalTicks = processUserTicks + processSystemTicks;\n      _processRss = Long.parseLong(m.group(24));\n    } catch (Exception ignore) {\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5794, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [101], "initializationEnd": [135], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 141, "guardExpressionEnd": 157, "guardBlockStart": 141, "guardBlockEnd": 545, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 177, "focalAPIEnd": 187, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(result)"], "useStart": [238], "useEnd": [257], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Cyberspice/platform_tools_base/tree/master/sdk-common/src/main/java/com/android/ide/common/resources/configuration/NetworkCodeQualifier.java", "rawCode": "  @Override\n  public boolean checkAndSet(String value, FolderConfiguration config) {\n    Matcher m = sNetworkCodePattern.matcher(value);\n    if (m.matches()) {\n      String v = m.group(1);\n\n      int code = -1;\n      try {\n        code = Integer.parseInt(v);\n      } catch (NumberFormatException e) {\n        // looks like the string we extracted wasn't a valid number.\n        return false;\n      }\n\n      NetworkCodeQualifier qualifier = new NetworkCodeQualifier(code);\n      config.setNetworkCodeQualifier(qualifier);\n      return true;\n    }\n\n    return false;\n  }\n"}, {"dataset": "group", "exampleID": 5795, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [129], "initializationEnd": [143], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()&&matcher.groupCount()>0", "guardType": "IF {", "guardExpressionStart": 149, "guardExpressionEnd": 187, "guardBlockStart": 149, "guardBlockEnd": 228, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 195, "focalAPIEnd": 205, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cpieloth/GPGPU-on-Hadoop/tree/master/k-means/src/hadoop/KMeansHadoop.java", "rawCode": "  private static String getJobID(String url) {\n    final Pattern p = Pattern.compile(\".*jobid=job_(\\\\d+_\\\\d+)\");\n    Matcher m = p.matcher(url);\n    if (m.matches() && m.groupCount() > 0) return m.group(1);\n    else return null;\n  }\n"}, {"dataset": "group", "exampleID": 5796, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [418], "initializationEnd": [434], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 440, "guardExpressionEnd": 456, "guardBlockStart": 440, "guardBlockEnd": 1001, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 479, "focalAPIEnd": 489, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SharkHunter/Channel/tree/master/src/com/sharkhunter/channel/ChannelCfg.java", "rawCode": "  private void fetchFromGit(String list, String raw, String path) throws Exception {\n    URL u = new URL(list);\n    Pattern re = Pattern.compile(chReg);\n    URLConnection connection = u.openConnection();\n    connection.setRequestProperty(\"User-Agent\", ChannelUtil.defAgentString);\n    connection.setDoInput(true);\n    connection.setDoOutput(true);\n\n    String page = ChannelUtil.fetchPage(connection);\n    Matcher m = re.matcher(page);\n    while (m.find()) {\n      String name = m.group(1);\n      URL u1 = new URL(raw + name);\n      InputStream in = u1.openStream();\n      String fName = path + File.separator + name;\n      int count;\n      final int BUFFER = 2048;\n      byte data[] = new byte[BUFFER];\n      FileOutputStream fos1 = new FileOutputStream(fName);\n      BufferedOutputStream dest = new BufferedOutputStream(fos1, BUFFER);\n      while ((count = in.read(data, 0, BUFFER)) != -1) {\n        dest.write(data, 0, count);\n      }\n      dest.flush();\n      dest.close();\n      in.close();\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5797, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [426], "initializationEnd": [451], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.find()"], "configurationStart": [507], "configurationEnd": [526], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 562, "focalAPIEnd": 583, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Text(result)"], "useStart": [606], "useEnd": [627], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kijiproject/kiji-mapreduce/tree/master/kiji-mapreduce/src/test/java/org/kiji/mapreduce/IntegrationTestKijiTableInputFormat.java", "rawCode": "    @Override\n    public void map(EntityId entityId, KijiRowData row, Context context)\n        throws IOException, InterruptedException {\n      final String name = row.getMostRecentValue(\"info\", \"name\").toString();\n      final String email = row.getMostRecentValue(\"info\", \"email\").toString();\n\n      // Build email domain regex.\n      final Pattern emailRegex = Pattern.compile(\".+@(.+)\");\n      final Matcher emailMatcher = emailRegex.matcher(email);\n\n      // Extract domain from email.\n      assertTrue(emailMatcher.find());\n      final String emailDomain = emailMatcher.group(1);\n\n      context.write(new Text(emailDomain), new Text(name));\n    }\n"}, {"dataset": "group", "exampleID": 5798, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [572], "initializationEnd": [604], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.matches()", "guardType": "IF {", "guardExpressionStart": 616, "guardExpressionEnd": 632, "guardBlockStart": 616, "guardBlockEnd": 845, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 661, "focalAPIEnd": 671, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new TagInfo(*,*,result,*)"], "useStart": [712], "useEnd": [763], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thebohemian/android-buglabsdemo-build/tree/master/tools/droiddoc/src/Comment.java", "rawCode": "  private void parseBriefTags() {\n    int N = mInlineTagsList.size();\n\n    // look for \"@more\" tag, which means that we might go past the first sentence.\n    int more = -1;\n    for (int i = 0; i < N; i++) {\n      if (mInlineTagsList.get(i).name().equals(\"@more\")) {\n        more = i;\n      }\n    }\n    if (more >= 0) {\n      for (int i = 0; i < more; i++) {\n        mBriefTagsList.add(mInlineTagsList.get(i));\n      }\n    } else {\n      for (int i = 0; i < N; i++) {\n        TagInfo t = mInlineTagsList.get(i);\n        if (t.name().equals(\"Text\")) {\n          Matcher m = FIRST_SENTENCE.matcher(t.text());\n          if (m.matches()) {\n            String text = m.group(1);\n            TagInfo firstSentenceTag = new TagInfo(t.name(), t.kind(), text, t.position());\n            mBriefTagsList.add(firstSentenceTag);\n            break;\n          }\n        }\n        mBriefTagsList.add(t);\n      }\n    }\n  }\n"}, {"dataset": "group", "exampleID": 5799, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [154], "initializationEnd": [184], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "matcher.find()", "guardType": "LOOP {", "guardExpressionStart": 207, "guardExpressionEnd": 223, "guardBlockStart": 207, "guardBlockEnd": 461, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 256, "focalAPIEnd": 266, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["valueOf(result)", "matcher.appendReplacement(StringBuffer,String)", "matcher.group()", "matcher.appendTail(StringBuffer)"], "useStart": [240, 321, 436, 466], "useEnd": [267, 401, 445, 482], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/isr-uci-edu/ArchStudio5/tree/master/org.archstudio.utils.system/src/org/archstudio/sysutils/SystemUtils.java", "rawCode": "  public static final String message(String message, Object... variables) {\n    StringBuffer sb = new StringBuffer(2 * message.length());\n    Matcher m = Pattern.compile(\"\\\\$([0-9]+)\").matcher(message);\n    while (m.find()) {\n      int v = Integer.valueOf(m.group(1));\n      if (v >= 0 && v < variables.length) {\n        m.appendReplacement(sb, variables[v] == null ? \"null\" : variables[v].toString());\n      } else {\n        sb.append(m.group());\n      }\n    }\n    m.appendTail(sb);\n    return sb.toString();\n  }\n"}, {"dataset": "group", "exampleID": 5800, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.group(group)", "focalAPIStart": 494, "focalAPIEnd": 510, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fyhertz/spydroid-ipcamera/tree/master/src/net/majorkernelpanic/streaming/rtsp/RtspServer.java", "rawCode": "    /** Parse the method, uri & headers of a RTSP request */\n    public static Request parseRequest(BufferedReader input)\n        throws IOException, IllegalStateException, SocketException {\n      Request request = new Request();\n      String line;\n      Matcher matcher;\n\n      // Parsing request method & uri\n      if ((line = input.readLine()) == null) throw new SocketException(\"Client disconnected\");\n      matcher = regexMethod.matcher(line);\n      matcher.find();\n      request.method = matcher.group(1);\n      request.uri = matcher.group(2);\n\n      // Parsing headers of the request\n      while ((line = input.readLine()) != null && line.length() > 3) {\n        matcher = rexegHeader.matcher(line);\n        matcher.find();\n        request.headers.put(matcher.group(1).toLowerCase(Locale.US), matcher.group(2));\n      }\n      if (line == null) throw new SocketException(\"Client disconnected\");\n\n      // It's not an error, it's just easier to follow what's happening in logcat with the request\n      // in red\n      Log.e(TAG, request.method + \" \" + request.uri);\n\n      return request;\n    }\n"}]