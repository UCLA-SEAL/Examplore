[{"dataset": "split", "exampleID": 8701, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null", "guardType": "IF {", "guardExpressionStart": 154, "guardExpressionEnd": 172, "guardBlockStart": 154, "guardBlockEnd": 1123, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 198, "focalAPIEnd": 216, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 225, "followUpCheckExpressionEnd": 250, "followUpCheckBlockStart": 225, "followUpCheckBlockEnd": 1117, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/calebrob6/json-server/tree/master/src/server/ParameterFilter.java", "rawCode": "  @SuppressWarnings(\"unchecked\")\n  private void parseQuery(String query, Map<String, Object> parameters)\n      throws UnsupportedEncodingException {\n\n    if (query != null) {\n      String pairs[] = query.split(\"[&]\");\n\n      for (String pair : pairs) {\n        String param[] = pair.split(\"[=]\");\n\n        String key = null;\n        String value = null;\n        if (param.length > 0) {\n          key = URLDecoder.decode(param[0], System.getProperty(\"file.encoding\"));\n        }\n\n        if (param.length > 1) {\n          value = URLDecoder.decode(param[1], System.getProperty(\"file.encoding\"));\n        }\n\n        if (parameters.containsKey(key)) {\n          Object obj = parameters.get(key);\n          if (obj instanceof List<?>) {\n            List<String> values = (List<String>) obj;\n            values.add(value);\n          } else if (obj instanceof String) {\n            List<String> values = new ArrayList<String>();\n            values.add((String) obj);\n            values.add(value);\n            parameters.put(key, values);\n          }\n        } else {\n          parameters.put(key, value);\n        }\n      }\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8702, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["getStackTrace()", "d(String,String)"], "tryExpressionStart": 313, "tryExpressionEnd": 317, "tryBlockStart": 313, "tryBlockEnd": 1822, "catchExpressionStart": 1496, "catchExpressionEnd": 1528, "catchBlockStart": 1496, "catchBlockEnd": 1606, "exceptionHandlingCallStart": [1581, 1536], "exceptionHandlingCallEnd": [1598, 1599], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(string)!=null", "guardType": "LOOP {", "guardExpressionStart": 403, "guardExpressionEnd": 440, "guardBlockStart": 403, "guardBlockEnd": 1489, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 467, "focalAPIEnd": 481, "followUpCheck": "\"true\".equals(strArray[3])", "checkType": "IF", "followUpCheckExpressionStart": 798, "followUpCheckExpressionEnd": 825, "followUpCheckBlockStart": 798, "followUpCheckBlockEnd": 1115, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1664, "finallyExpressionEnd": 1672, "finallyBlockStart": 1664, "finallyBlockEnd": 1822, "cleanUpCallStart": [1722], "cleanUpCallEnd": [1732], "url": "https://github.com/dalvik/WebCam/tree/master/src/com/iped/ipcam/utils/FileUtil.java", "rawCode": "  public static List<Device> fetchDeviceFromFile(Context context) {\n    List<Device> deviceList = new ArrayList<Device>();\n    File file = new File(context.getFilesDir().getPath() + File.separator + Constants.DEVICELIST);\n    if (!file.exists()) {\n      return deviceList;\n    }\n    BufferedReader br = null;\n    try {\n      br = new BufferedReader(new FileReader(file));\n      String str = null;\n      while ((str = br.readLine()) != null) {\n        String[] info = str.split(\"&\");\n        int l = info.length;\n        /// System.out.println(\"device info str=\" + str + \" length=\" + l);\n        if (l < 8) {\n          continue;\n        }\n        Device device = new Device();\n        device.setDeviceName(info[0]);\n        device.setDeviceID(info[1]);\n        device.setUnDefine1(info[2]);\n        if (\"true\".equals(info[3])) {\n          device.setDeviceNetType(true);\n          device.setDeviceEthIp(info[4]);\n          device.setDeviceEthGateWay(info[5]);\n        } else {\n          device.setDeviceNetType(false);\n          device.setDeviceEthIp(info[4]);\n          device.setDeviceEthGateWay(info[5]);\n        }\n        device.setDeviceRemoteCmdPort(Integer.parseInt(info[6]));\n        device.setDeviceRemoteVideoPort(Integer.parseInt(info[7]));\n        device.setDeviceRemoteAudioPort(Integer.parseInt(info[8]));\n        device.setUnDefine2(info[9].equals(\"null\") ? null : info[9]);\n        if (!checkDeviceId(deviceList, device)) {\n          deviceList.add(device);\n        }\n      }\n    } catch (FileNotFoundException e) {\n      Log.d(TAG, \"FileUtil fetchDeviceFromFile \" + e.getStackTrace());\n    } catch (IOException e) {\n      e.printStackTrace();\n    } finally {\n      if (br != null) {\n        try {\n          br.close();\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n    }\n    return deviceList;\n  }\n"}, {"dataset": "split", "exampleID": 8703, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 85, "focalAPIEnd": 104, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vanzin/jEdit/tree/master/org/gjt/sp/jedit/search/HyperSearchFileNode.java", "rawCode": "  public String toString() {\n    if (showFullPath) return path;\n    String[] paths = path.split(fileSep);\n    return paths[paths.length - 1];\n  } // }}}\n"}, {"dataset": "split", "exampleID": 8704, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 142, "focalAPIEnd": 157, "followUpCheck": "i < strArray.length", "checkType": "LOOP", "followUpCheckExpressionStart": 163, "followUpCheckExpressionEnd": 203, "followUpCheckBlockStart": 163, "followUpCheckBlockEnd": 251, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/shevek/spring-rich-client/tree/master/spring-richclient-sandbox/src/main/java/org/springframework/richclient/settings/j2seprefs/PreferencesSettingsFactory.java", "rawCode": "  private Preferences getForId(Preferences root, String id) {\n    Assert.notNull(root);\n    Preferences result = root;\n    String[] idParts = id.split(\"\\\\.\");\n    for (int i = 0; i < idParts.length; i++) {\n      result = result.node(idParts[i]);\n    }\n    return result;\n  }\n"}, {"dataset": "split", "exampleID": 8705, "initialization": ["String string = HttpURLConnection.getResponseMessage()"], "initializationStart": [180], "initializationEnd": [204], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null||string.isEmpty())", "guardType": "IF {", "guardExpressionStart": 266, "guardExpressionEnd": 301, "guardBlockStart": 266, "guardBlockEnd": 314, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 385, "focalAPIEnd": 400, "followUpCheck": "strArray.length < 2", "checkType": "IF", "followUpCheckExpressionStart": 406, "followUpCheckExpressionEnd": 424, "followUpCheckBlockStart": 406, "followUpCheckBlockEnd": 437, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DelegationTokenFetcher.java", "rawCode": "  private static IOException getExceptionFromResponse(HttpURLConnection con) {\n    IOException e = null;\n    String resp;\n    if (con == null) return null;\n\n    try {\n      resp = con.getResponseMessage();\n    } catch (IOException ie) {\n      return null;\n    }\n    if (resp == null || resp.isEmpty()) return null;\n\n    String exceptionClass = \"\", exceptionMsg = \"\";\n    String[] rs = resp.split(\";\");\n    if (rs.length < 2) return null;\n    exceptionClass = rs[0];\n    exceptionMsg = rs[1];\n    LOG.info(\n        \"Error response from HTTP request=\"\n            + resp\n            + \";ec=\"\n            + exceptionClass\n            + \";em=\"\n            + exceptionMsg);\n\n    if (exceptionClass == null || exceptionClass.isEmpty()) return null;\n\n    // recreate exception objects\n    try {\n      Class<? extends Exception> ec = Class.forName(exceptionClass).asSubclass(Exception.class);\n      // we are interested in constructor with String arguments\n      java.lang.reflect.Constructor<? extends Exception> constructor =\n          (java.lang.reflect.Constructor<? extends Exception>)\n              ec.getConstructor(new Class[] {String.class});\n\n      // create an instance\n      e = (IOException) constructor.newInstance(exceptionMsg);\n\n    } catch (Exception ee) {\n      LOG.warn(\"failed to create object of this class\", ee);\n    }\n    if (e == null) return null;\n\n    e.setStackTrace(new StackTraceElement[0]); // local stack is not relevant\n    LOG.info(\"Exception from HTTP response=\" + e.getLocalizedMessage());\n    return e;\n  }\n"}, {"dataset": "split", "exampleID": 8706, "initialization": ["String string = String.substring(int,int)"], "initializationStart": [1374], "initializationEnd": [1449], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.length()>0", "guardType": "IF {", "guardExpressionStart": 1488, "guardExpressionEnd": 1514, "guardBlockStart": 1488, "guardBlockEnd": 2352, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1555, "focalAPIEnd": 1582, "followUpCheck": "i < strArray.length", "checkType": "LOOP", "followUpCheckExpressionStart": 1658, "followUpCheckExpressionEnd": 1711, "followUpCheckBlockStart": 1658, "followUpCheckBlockEnd": 2291, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/prsebastian/gwt-issue-8215/tree/master/build_tools/doctool/src/com/google/doctool/LinkResolver.java", "rawCode": "  public static SourcePosition resolveLink(Tag tag, ExtraClassResolver classResolver) {\n    String linkText = tag.text();\n    String className;\n    String methodSig;\n    int pos = linkText.indexOf('#');\n    if (pos >= 0) {\n      className = linkText.substring(0, pos);\n      methodSig = linkText.substring(pos + 1);\n    } else {\n      className = linkText;\n      methodSig = null;\n    }\n\n    ClassDoc containingClass = null;\n    Doc holder = tag.holder();\n    if (holder instanceof ClassDoc) {\n      containingClass = (ClassDoc) holder;\n    } else if (holder instanceof MemberDoc) {\n      containingClass = ((MemberDoc) holder).containingClass();\n    }\n\n    ClassDoc targetClass = null;\n    if (className.length() == 0) {\n      targetClass = containingClass;\n    } else if (holder instanceof PackageDoc) {\n      targetClass = ((PackageDoc) holder).findClass(className);\n    } else {\n      targetClass = containingClass.findClass(className);\n    }\n\n    if (targetClass == null) {\n      if (classResolver != null) {\n        targetClass = classResolver.findClass(className);\n      }\n      if (targetClass == null) {\n        System.err.println(\n            tag.position().toString() + \": unable to resolve class \" + className + \" for \" + tag);\n        System.exit(1);\n      }\n    }\n\n    if (methodSig == null) {\n      return targetClass.position();\n    }\n\n    String paramSig = methodSig.substring(methodSig.indexOf('(') + 1, methodSig.lastIndexOf(')'));\n    String[] resolvedParamTypes;\n    if (paramSig.length() > 0) {\n      String[] unresolvedParamTypes = paramSig.split(\"\\\\s*,\\\\s*\");\n      resolvedParamTypes = new String[unresolvedParamTypes.length];\n      for (int i = 0; i < unresolvedParamTypes.length; ++i) {\n        ClassDoc paramType = containingClass.findClass(unresolvedParamTypes[i]);\n        if (paramType == null && classResolver != null) {\n          paramType = classResolver.findClass(unresolvedParamTypes[i]);\n        }\n        if (paramType == null) {\n          System.err.println(\n              tag.position().toString()\n                  + \": unable to resolve class \"\n                  + unresolvedParamTypes[i]\n                  + \" for \"\n                  + tag);\n          System.exit(1);\n        }\n        resolvedParamTypes[i] = paramType.qualifiedTypeName();\n      }\n    } else {\n      resolvedParamTypes = new String[0];\n    }\n\n    String possibleOverloads = \"\";\n\n    MethodDoc[] methods = targetClass.methods();\n    outer:\n    for (int i = 0; i < methods.length; ++i) {\n      MethodDoc methodDoc = methods[i];\n      if (methodSig.startsWith(methodDoc.name())) {\n        possibleOverloads += \"\\n\" + methodDoc.flatSignature();\n        Parameter[] tryParams = methodDoc.parameters();\n        if (resolvedParamTypes.length != tryParams.length) {\n          // param count mismatch\n          continue outer;\n        }\n        for (int j = 0; j < tryParams.length; ++j) {\n          if (!tryParams[j].type().qualifiedTypeName().equals(resolvedParamTypes[j])) {\n            // param type mismatch\n            continue outer;\n          }\n        }\n        return methodDoc.position();\n      }\n    }\n\n    System.err.println(tag.position().toString() + \": unable to resolve method for \" + tag);\n    if (possibleOverloads.length() > 0) {\n      System.err.println(\"Possible overloads: \" + possibleOverloads);\n    }\n    System.exit(1);\n    return null;\n  }\n"}, {"dataset": "split", "exampleID": 8707, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 73, "focalAPIEnd": 111, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.12/kernel-util/src/main/java/org/sakaiproject/content/util/ZipContentUtil.java", "rawCode": "  private String extractName(String collectionName) {\n    String[] tmp = collectionName.split(Entity.SEPARATOR);\n    return tmp[tmp.length - 1];\n  }\n"}, {"dataset": "split", "exampleID": 8708, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 71, "focalAPIEnd": 92, "followUpCheck": "!HEADER_LINEINDICATOR.equals(strArray[0])", "checkType": "IF", "followUpCheckExpressionStart": 98, "followUpCheckExpressionEnd": 142, "followUpCheckBlockStart": 98, "followUpCheckBlockEnd": 170, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vogtp/android-clockcard/tree/master/src/ch/almana/android/stechkarte/model/io/DatabaseCsvIo.java", "rawCode": "  private boolean parseHeaderLine(String line) {\n    String[] values = line.split(SEPARATOR);\n    if (!HEADER_LINEINDICATOR.equals(values[0])) {\n      return false;\n    }\n    columnNames = new String[values.length];\n    columnNames[0] = \"INDICATOR\";\n    for (int i = 1; i < values.length; i++) {\n      columnNames[i] = values[i];\n    }\n    return true;\n  }\n"}, {"dataset": "split", "exampleID": 8709, "initialization": ["String string = new String(byte[])"], "initializationStart": [354], "initializationEnd": [371], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 480, "focalAPIEnd": 503, "followUpCheck": "strArray.length < 2", "checkType": "IF", "followUpCheckExpressionStart": 510, "followUpCheckExpressionEnd": 531, "followUpCheckBlockStart": 510, "followUpCheckBlockEnd": 630, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wangyif2/4d19/tree/master/Lab4/src/zookeeper/contrib/bookkeeper/src/java/org/apache/bookkeeper/client/LedgerMetadata.java", "rawCode": "  /**\n   * Parses a given byte array and transforms into a LedgerConfig object\n   *\n   * @param array byte array to parse\n   * @return LedgerConfig\n   * @throws IOException if the given byte[] cannot be parsed\n   */\n  static LedgerMetadata parseConfig(byte[] bytes) throws IOException {\n\n    LedgerMetadata lc = new LedgerMetadata();\n    String config = new String(bytes);\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Parsing Config: \" + config);\n    }\n\n    String lines[] = config.split(lSplitter);\n\n    if (lines.length < 2) {\n      throw new IOException(\"Quorum size or ensemble size absent from config: \" + config);\n    }\n\n    try {\n      lc.quorumSize = new Integer(lines[0]);\n      lc.ensembleSize = new Integer(lines[1]);\n\n      for (int i = 2; i < lines.length; i++) {\n        String parts[] = lines[i].split(tSplitter);\n\n        if (parts[1].equals(closed)) {\n          lc.close = new Long(parts[0]);\n          break;\n        }\n\n        ArrayList<InetSocketAddress> addrs = new ArrayList<InetSocketAddress>();\n        for (int j = 1; j < parts.length; j++) {\n          addrs.add(StringUtils.parseAddr(parts[j]));\n        }\n        lc.addEnsemble(new Long(parts[0]), addrs);\n      }\n    } catch (NumberFormatException e) {\n      throw new IOException(e);\n    }\n    return lc;\n  }\n"}, {"dataset": "split", "exampleID": 8710, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.contains(\".\",) && !(StringUtils.isEmpty(string,))", "guardType": "IF {", "guardExpressionStart": 214, "guardExpressionEnd": 252, "guardBlockStart": 214, "guardBlockEnd": 312, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 385, "focalAPIEnd": 410, "followUpCheck": "strArray != null && strArray.length > 0", "checkType": "IF", "followUpCheckExpressionStart": 479, "followUpCheckExpressionEnd": 517, "followUpCheckBlockStart": 479, "followUpCheckBlockEnd": 2142, "use": ["new NoSuchFieldException(string)", "new NoSuchFieldException(string)"], "useStart": [845, 2097], "useEnd": [883, 2135], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/crux-framework/tree/master/tags/5.0.4/Crux/src/core/org/cruxframework/crux/core/utils/JClassUtils.java", "rawCode": "  public static JType buildSetValueExpression(\n      SourcePrinter out,\n      JClassType dtoType,\n      String propertyPath,\n      String objectVariable,\n      String value)\n      throws NoSuchFieldException {\n    if (StringUtils.isEmpty(propertyPath)) {\n      throw new NoSuchFieldException(propertyPath);\n    }\n    String[] props;\n    if (propertyPath.contains(\".\")) {\n      props = propertyPath.split(\"\\\\.\");\n    } else {\n      props = new String[] {propertyPath};\n    }\n\n    if (props != null && props.length > 0) {\n      StringBuilder getExpression = new StringBuilder();\n      getExpression.append(objectVariable);\n      JType baseType = dtoType;\n      JClassType baseClassType = baseType.isClassOrInterface();\n      for (int i = 0; i < props.length - 1; i++) {\n        if (baseClassType == null && i < props.length - 1) {\n          throw new NoSuchFieldException(propertyPath);\n        }\n        String prop = props[i];\n        JClassType propertyType = getTypeForProperty(prop, baseClassType).isClassOrInterface();\n\n        String getterMethod = getGetterMethod(prop, baseClassType);\n        String setterMethod = getSetterMethod(prop, baseClassType, propertyType);\n\n        out.println(\"if (\" + getExpression.toString() + \".\" + getterMethod + \"()==null){\");\n        out.println(\n            getExpression\n                + \".\"\n                + setterMethod\n                + \"((\"\n                + propertyType.getParameterizedQualifiedSourceName()\n                + \")\"\n                + GWT.class.getCanonicalName()\n                + \".create(\"\n                + propertyType.getQualifiedSourceName()\n                + \".class));\");\n        out.println(\"}\");\n        getExpression.append(\".\" + getterMethod + \"()\");\n\n        baseClassType = propertyType;\n      }\n      String prop = props[props.length - 1];\n      JType propertyType = getTypeForProperty(prop, baseClassType);\n      String setterMethod = getSetterMethod(prop, baseClassType, propertyType);\n      out.println(getExpression + \".\" + setterMethod + \"(\" + value + \");\");\n\n      return propertyType;\n    } else {\n      throw new NoSuchFieldException(propertyPath);\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8711, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 99, "focalAPIEnd": 117, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 146, "followUpCheckExpressionEnd": 173, "followUpCheckBlockStart": 146, "followUpCheckBlockEnd": 597, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/milanaleksic/baobab/tree/master/baobab-core/src/main/java/net/milanaleksic/baobab/converters/typed/IntegerConverter.java", "rawCode": "  public Integer getValueFromString(String input) {\n    checkNotNull(input);\n    String[] values = input.split(\"\\\\|\");\n    int ofTheJedi = 0;\n    for (String value : values) {\n      Matcher matcher = magicConstantsValue.matcher(value);\n      if (matcher.matches()) {\n        Integer matchedMagicConstantValue = magicConstants.get(matcher.group(1));\n        if (matchedMagicConstantValue == null)\n          throw new TransformerException(\"Magic constant does not exist - \" + matcher.group(1));\n        ofTheJedi |= matchedMagicConstantValue;\n      } else ofTheJedi |= Integer.parseInt(value);\n    }\n    return ofTheJedi;\n  }\n"}, {"dataset": "split", "exampleID": 8712, "initialization": ["String string = String.replace(String,String)"], "initializationStart": [4242], "initializationEnd": [4262], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.replace(String,String)"], "configurationStart": [4242], "configurationEnd": [4262], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 4281, "focalAPIEnd": 4294, "followUpCheck": "strArray[3].equals(\"0\") || strArray[3].equals(\"00\") || strArray[3].equals(\"000\")|| strArray[3].equals(\"255\")", "checkType": "IF", "followUpCheckExpressionStart": 4377, "followUpCheckExpressionEnd": 4463, "followUpCheckBlockStart": 4377, "followUpCheckBlockEnd": 4491, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lvelezsantos/packet_tracer_java/tree/master/packet_tracert_java/src/Autom/Automata.java", "rawCode": "  /** @param args the command line arguments */\n  public static boolean evalip(String ip) {\n\n    Automaton atmt255 = new Automaton();\n    State estd1 = new State(),\n        estd2 = new State(),\n        estd3 = new State(),\n        estd4 = new State(),\n        estd5 = new State(),\n        estd6 = new State(),\n        estd7 = new State();\n\n    estd1.addTransition(new Transition('0', estd2));\n    estd1.addTransition(new Transition('1', estd2));\n\n    estd1.addTransition(new Transition('2', estd3));\n\n    estd1.addTransition(new Transition('3', estd5));\n    estd1.addTransition(new Transition('4', estd5));\n    estd1.addTransition(new Transition('5', estd5));\n    estd1.addTransition(new Transition('6', estd5));\n    estd1.addTransition(new Transition('7', estd5));\n    estd1.addTransition(new Transition('8', estd5));\n    estd1.addTransition(new Transition('9', estd5));\n\n    estd2.setAccept(true);\n    estd2.addTransition(new Transition('0', estd5));\n    estd2.addTransition(new Transition('1', estd5));\n    estd2.addTransition(new Transition('2', estd5));\n    estd2.addTransition(new Transition('3', estd5));\n    estd2.addTransition(new Transition('4', estd5));\n    estd2.addTransition(new Transition('5', estd5));\n    estd2.addTransition(new Transition('6', estd5));\n    estd2.addTransition(new Transition('7', estd5));\n    estd2.addTransition(new Transition('8', estd5));\n    estd2.addTransition(new Transition('9', estd5));\n\n    estd3.setAccept(true);\n    estd3.addTransition(new Transition('5', estd4));\n\n    estd3.addTransition(new Transition('0', estd5));\n    estd3.addTransition(new Transition('1', estd5));\n    estd3.addTransition(new Transition('2', estd5));\n    estd3.addTransition(new Transition('3', estd5));\n    estd3.addTransition(new Transition('4', estd5));\n\n    estd3.addTransition(new Transition('6', estd6));\n    estd3.addTransition(new Transition('7', estd6));\n    estd3.addTransition(new Transition('8', estd6));\n    estd3.addTransition(new Transition('9', estd6));\n\n    estd4.setAccept(true);\n    estd4.addTransition(new Transition('0', estd6));\n    estd4.addTransition(new Transition('1', estd6));\n    estd4.addTransition(new Transition('2', estd6));\n    estd4.addTransition(new Transition('3', estd6));\n    estd4.addTransition(new Transition('4', estd6));\n    estd4.addTransition(new Transition('5', estd6));\n\n    estd4.addTransition(new Transition('6', estd7));\n    estd4.addTransition(new Transition('7', estd7));\n    estd4.addTransition(new Transition('8', estd7));\n    estd4.addTransition(new Transition('9', estd7));\n\n    estd5.setAccept(true);\n    estd5.addTransition(new Transition('0', estd6));\n    estd5.addTransition(new Transition('1', estd6));\n    estd5.addTransition(new Transition('2', estd6));\n    estd5.addTransition(new Transition('3', estd6));\n    estd5.addTransition(new Transition('4', estd6));\n    estd5.addTransition(new Transition('5', estd6));\n    estd5.addTransition(new Transition('6', estd6));\n    estd5.addTransition(new Transition('7', estd6));\n    estd5.addTransition(new Transition('8', estd6));\n    estd5.addTransition(new Transition('9', estd6));\n\n    estd6.setAccept(true);\n    estd6.addTransition(new Transition('0', estd7));\n    estd6.addTransition(new Transition('1', estd7));\n    estd6.addTransition(new Transition('2', estd7));\n    estd6.addTransition(new Transition('3', estd7));\n    estd6.addTransition(new Transition('4', estd7));\n    estd6.addTransition(new Transition('5', estd7));\n    estd6.addTransition(new Transition('6', estd7));\n    estd6.addTransition(new Transition('7', estd7));\n    estd6.addTransition(new Transition('8', estd7));\n    estd6.addTransition(new Transition('9', estd7));\n\n    estd7.addTransition(new Transition('0', estd7));\n    estd7.addTransition(new Transition('1', estd7));\n    estd7.addTransition(new Transition('2', estd7));\n    estd7.addTransition(new Transition('3', estd7));\n    estd7.addTransition(new Transition('4', estd7));\n    estd7.addTransition(new Transition('5', estd7));\n    estd7.addTransition(new Transition('6', estd7));\n    estd7.addTransition(new Transition('7', estd7));\n    estd7.addTransition(new Transition('8', estd7));\n    estd7.addTransition(new Transition('9', estd7));\n\n    atmt255.setInitialState(estd1);\n    ip = ip.replace(\".\", \"_\");\n    String[] a = ip.split(\"_\");\n    System.out.println(\">>\" + ip + \" ..... \");\n    System.out.println(a[0]);\n    if (a[3].equals(\"0\") || a[3].equals(\"00\") || a[3].equals(\"000\") || a[3].equals(\"255\")) {\n      return false;\n    }\n    for (int i = 0; i < 4; i++) {\n      // System.out.println(a[i]+\"Soy yo\");\n      if (!atmt255.run(a[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n"}, {"dataset": "split", "exampleID": 8713, "initialization": ["String string = HttpServletRequest.getHeader(String)"], "initializationStart": [529], "initializationEnd": [565], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null", "guardType": "IF {", "guardExpressionStart": 571, "guardExpressionEnd": 596, "guardBlockStart": 571, "guardBlockEnd": 789, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 688, "focalAPIEnd": 711, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 719, "followUpCheckExpressionEnd": 744, "followUpCheckBlockStart": 719, "followUpCheckBlockEnd": 783, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rfkrocktk/red5-server/tree/master/src/org/red5/server/net/servlet/ServletUtils.java", "rawCode": "  /**\n   * Return all remote addresses that were involved in the passed request.\n   *\n   * @param request request\n   * @return remote addresses\n   */\n  public static List<String> getRemoteAddresses(HttpServletRequest request) {\n    List<String> addresses = new ArrayList<String>();\n    addresses.add(request.getRemoteHost());\n    if (!request.getRemoteAddr().equals(request.getRemoteHost())) {\n      // Store both remote host and remote address\n      addresses.add(request.getRemoteAddr());\n    }\n    final String forwardedFor = request.getHeader(\"X-Forwarded-For\");\n    if (forwardedFor != null) {\n      // Also store address this request was forwarded for.\n      final String[] parts = forwardedFor.split(\",\");\n      for (String part : parts) {\n        addresses.add(part);\n      }\n    }\n    final String httpVia = request.getHeader(\"Via\");\n    if (httpVia != null) {\n      // Also store address this request was forwarded for.\n      final String[] parts = httpVia.split(\",\");\n      for (String part : parts) {\n        addresses.add(part);\n      }\n    }\n    return Collections.unmodifiableList(addresses);\n  }\n"}, {"dataset": "split", "exampleID": 8714, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.lastIndexOf(String)", "string.substring(int,int)", "string.length()", "string.length()", "string.lastIndexOf(String,int)", "string.substring(int,int)"], "configurationStart": [527, 596, 660, 682, 723, 804], "configurationEnd": [549, 628, 674, 696, 753, 827], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 874, "focalAPIEnd": 890, "followUpCheck": "strArray.length > 0", "checkType": "IF", "followUpCheckExpressionStart": 900, "followUpCheckExpressionEnd": 926, "followUpCheckBlockStart": 900, "followUpCheckBlockEnd": 1080, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/KLyko/Zitationsgraph/tree/master/src/de/uni/leipzig/asv/zitationsgraph/extraction/ReferenceExtraction.java", "rawCode": "  /**\n   * clean a match title String The assumption are naive. The first assumption is , if a \"?\" was\n   * found it is also the end of a title The second assumption use the keyword \"vol.\", which doesn't\n   * belongs to a title The third assumption use the word length by splitting the title by \",\" All\n   * words, which occur between \",\" should have a word length more than 4\n   *\n   * @param title\n   * @return cleaned title\n   */\n  private String cleanTitle(String title) {\n    String cleanTitle = title;\n    int sepIndex = title.lastIndexOf(\"?\");\n    if (sepIndex != -1) {\n      cleanTitle = title.substring(0, sepIndex + 1);\n    } else {\n      int end = (title.length() > 4) ? title.length() - 4 : 0;\n      sepIndex = title.lastIndexOf(\"vol.\", end);\n      if (sepIndex != -1) {\n        cleanTitle = title.substring(0, end);\n      } else {\n        String[] titleParts = title.split(\",\");\n        if (titleParts.length > 0) {\n          String[] words = titleParts[0].split(\"\\\\s+\");\n          if (words.length > 4) {\n            cleanTitle = titleParts[0];\n          }\n        }\n      }\n    }\n\n    return cleanTitle;\n  }\n"}, {"dataset": "split", "exampleID": 8715, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null)", "guardType": "IF {", "guardExpressionStart": 50, "guardExpressionEnd": 76, "guardBlockStart": 50, "guardBlockEnd": 119, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 190, "focalAPIEnd": 214, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 220, "followUpCheckExpressionEnd": 247, "followUpCheckBlockStart": 220, "followUpCheckBlockEnd": 362, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ysc/APDPlat/tree/master/APDPlat_Core/src/main/java/org/apdplat/platform/action/ActionSupport.java", "rawCode": "  public OrderCriteria buildOrderCriteria() {\n    if (orderCriteria == null) {\n      return defaultOrderCriteria;\n    }\n    OrderCriteria result = new OrderCriteria();\n    String[] orders = orderCriteria.split(\",\");\n    for (String order : orders) {\n      String[] orderInfo = order.split(\":\");\n      result.addOrder(new Order(orderInfo[0], orderInfo[1]));\n    }\n\n    return result;\n  }\n"}, {"dataset": "split", "exampleID": 8716, "initialization": ["String string = getResponse(HttpExchange)"], "initializationStart": [179], "initializationEnd": [204], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 237, "focalAPIEnd": 258, "followUpCheck": "strArray.length > 0", "checkType": "IF", "followUpCheckExpressionStart": 266, "followUpCheckExpressionEnd": 295, "followUpCheckBlockStart": 266, "followUpCheckBlockEnd": 1370, "use": ["getParameter(strArray,String,String)", "getParameter(strArray,String)"], "useStart": [433, 952], "useEnd": [486, 986], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mariodavid/Fallstudie1213/tree/master/fallstudie/src/main/java/http/HTTPServer.java", "rawCode": "    public void handle(HttpExchange t) throws IOException {\n      System.out.println(\"\\n-> Receiving request from: \" + t.getRequestHeaders().get(\"Host\"));\n      String response = HTTPServer.getResponse(t);\n      String[] responseParts = response.split(\"[&]\");\n      if (responseParts.length > 0) {\n        // first check whether or not a format is given (default is XML\n        // as defined by W3C)\n        String formatParameter = HTTPServer.getParameter(responseParts, format, \"XML\");\n        Formatter formatter = registeredFormatter.get(formatParameter.toLowerCase());\n        if (formatter == null) {\n          t.getResponseHeaders().add(\"Content-type\", \"text/plain\");\n          final String answer = \"Bad Request: format \" + formatParameter + \" not supported\";\n          System.out.println(answer);\n          HTTPServer.sendString(t, answer);\n          return;\n        }\n        // now look for a query parameter\n        String queryParameter = getParameter(responseParts, query);\n        if (queryParameter != null) {\n          this.sparqlExecution.execute(queryParameter, formatter, t);\n        } else {\n          t.getResponseHeaders().add(\"Content-type\", \"text/plain\");\n          final String answer = \"Bad Request: query parameter missing\";\n          System.out.println(answer);\n          HTTPServer.sendString(t, answer);\n          return;\n        }\n      }\n      HTTPServer.htmlForm.sendHTMLForm(t);\n    }\n"}, {"dataset": "split", "exampleID": 8717, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.contains(regex,)", "guardType": "IF {", "guardExpressionStart": 52, "guardExpressionEnd": 79, "guardBlockStart": 52, "guardBlockEnd": 401, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 110, "focalAPIEnd": 129, "followUpCheck": "i < strArray.length", "checkType": "LOOP", "followUpCheckExpressionStart": 138, "followUpCheckExpressionEnd": 185, "followUpCheckBlockStart": 138, "followUpCheckBlockEnd": 272, "use": ["join(strArray,String)", "string.toLowerCase()"], "useStart": [287, 371], "useEnd": [320, 393], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/geNAZt/RegionShop/tree/master/src/main/java/net/cubespace/RegionShop/Util/ItemName.java", "rawCode": "  public static String nicer(String itemName) {\n    if (itemName.contains(\"_\")) {\n      String[] itemPieces = itemName.split(\"_\");\n\n      for (Integer i = 0; i < itemPieces.length; i++) {\n        itemPieces[i] = StringUtils.capitalize(itemPieces[i].toLowerCase());\n      }\n\n      return StringUtils.join(itemPieces, \" \");\n    } else {\n      return StringUtils.capitalize(itemName.toLowerCase());\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8718, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.contains(regex,)", "guardType": "IF {", "guardExpressionStart": 78, "guardExpressionEnd": 104, "guardBlockStart": 78, "guardBlockEnd": 810, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 121, "focalAPIEnd": 139, "followUpCheck": "strArray == null || strArray.length != length", "checkType": "IF", "followUpCheckExpressionStart": 815, "followUpCheckExpressionEnd": 859, "followUpCheckBlockStart": 815, "followUpCheckBlockEnd": 948, "use": ["string.split(String)", "string.substring(int)"], "useStart": [195, 302], "useEnd": [213, 322], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brl/netifera/tree/master/platform/com.netifera.platform.core/com.netifera.platform.util/src/com/netifera/platform/util/addresses/AbstractMACAddress.java", "rawCode": "  private byte[] parseString(String address) {\n    String[] parts = null;\n    if (address.contains(\":\")) {\n      parts = address.split(\":\");\n    } else if (address.contains(\"-\")) {\n      parts = address.split(\"-\");\n    } else if (address.contains(\".\") && address.startsWith(\"0x\")) {\n      String[] p = address.substring(2).split(\"\\\\.\");\n      if (p.length != length / 2) {\n        throw new AddressFormatException(\"Invalid MAC address format:\" + address);\n      }\n      parts = new String[length];\n      for (int i = 0; i < length / 2; i++) {\n        int len = p[i].length();\n        if (len > 2) {\n          parts[2 * i] = p[i].substring(0, len - 2);\n          parts[(2 * i) + 1] = p[i].substring(2);\n        } else {\n          parts[2 * i] = \"00\";\n          parts[(2 * i) + 1] = p[i];\n        }\n      }\n    }\n    if (parts == null || parts.length != length) {\n      throw new AddressFormatException(\"Invalid MAC address format:\" + address);\n    }\n    byte[] bytes = new byte[length];\n    for (int i = 0; i < length; i++) {\n      bytes[i] = (byte) Integer.parseInt(parts[i], 16);\n    }\n    return bytes;\n  }\n"}, {"dataset": "split", "exampleID": 8719, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 108, "focalAPIEnd": 136, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 143, "followUpCheckExpressionEnd": 190, "followUpCheckBlockStart": 143, "followUpCheckBlockEnd": 494, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/binwiederhier/syncany/tree/master/syncany-lib/src/main/java/org/syncany/chunk/CipherTransformer.java", "rawCode": "  private void initCipherSpecs(String cipherSpecListStr) throws Exception {\n    String[] cipherSpecIdStrs = cipherSpecListStr.split(\",\");\n\n    for (String cipherSpecIdStr : cipherSpecIdStrs) {\n      int cipherSpecId = Integer.parseInt(cipherSpecIdStr);\n      CipherSpec cipherSpec = CipherSpecs.getCipherSpec(cipherSpecId);\n\n      if (cipherSpec == null) {\n        throw new Exception(\"Cannot find cipher suite with ID '\" + cipherSpecId + \"'\");\n      }\n\n      cipherSpecs.add(cipherSpec);\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8720, "initialization": ["String string = String.trim()"], "initializationStart": [335], "initializationEnd": [345], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.trim()"], "configurationStart": [335], "configurationEnd": [345], "guardCondition": "(string)!=null", "guardType": "LOOP {", "guardExpressionStart": 230, "guardExpressionEnd": 267, "guardBlockStart": 230, "guardBlockEnd": 1184, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 371, "focalAPIEnd": 386, "followUpCheck": "strArray.length < 7", "checkType": "IF", "followUpCheckExpressionStart": 396, "followUpCheckExpressionEnd": 416, "followUpCheckBlockStart": 396, "followUpCheckBlockEnd": 454, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SharkHunter/Channel/tree/master/src/com/sharkhunter/channel/Channels.java", "rawCode": "  public static boolean readCookieFile(String file, HashMap<String, ArrayList<ChannelAuth>> map) {\n    boolean skipped = false;\n    try {\n      BufferedReader in = new BufferedReader(new FileReader(file));\n      String str;\n      while ((str = in.readLine()) != null) {\n        if (ChannelUtil.ignoreLine(str)) continue;\n        str = str.trim();\n        String[] line = str.split(\"\\t\");\n        if (line.length < 7) // bad line skip it\n        continue;\n        String url = line[0];\n        String ttd0 = line[4];\n        String key = line[5];\n        String val = line[6];\n        long ttd = 0;\n        try {\n          ttd = Long.parseLong(ttd0);\n        } catch (NumberFormatException e1) {\n        }\n        if (ttd < System.currentTimeMillis()) { // ignore old cookies\n          skipped = true;\n          continue;\n        }\n        ChannelAuth a = new ChannelAuth();\n        a.authStr = key + \"=\" + val;\n        a.method = ChannelLogin.COOKIE;\n        a.ttd = ttd;\n        a.proxy = null;\n        ArrayList<ChannelAuth> old = map.get(url);\n        if (old == null) {\n          old = new ArrayList<ChannelAuth>();\n        }\n        old.add(a);\n        map.put(url, old);\n      }\n    } catch (Exception e) {\n    }\n    return skipped;\n  }\n"}, {"dataset": "split", "exampleID": 8721, "initialization": ["String string = loadFromFile(File)"], "initializationStart": [75], "initializationEnd": [108], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null)", "guardType": "IF {", "guardExpressionStart": 114, "guardExpressionEnd": 135, "guardBlockStart": 114, "guardBlockEnd": 162, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 174, "focalAPIEnd": 194, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sehgalanuj/contiki-interop/tree/master/tools/cooja/java/se/sics/cooja/contikimote/ContikiMoteType.java", "rawCode": "  public static String[] loadMapFile(File mapFile) {\n    String contents = StringUtils.loadFromFile(mapFile);\n    if (contents == null) {\n      return null;\n    }\n    return contents.split(\"\\n\");\n  }\n"}, {"dataset": "split", "exampleID": 8722, "initialization": ["String string = get(*)"], "initializationStart": [120], "initializationEnd": [160], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 240, "focalAPIEnd": 259, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 267, "followUpCheckExpressionEnd": 303, "followUpCheckBlockStart": 267, "followUpCheckBlockEnd": 484, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/willnorris/java-openid/tree/master/src/main/java/edu/internet2/middleware/openid/extensions/ax/impl/FetchRequestUnmarshaller.java", "rawCode": "  /** {@inheritDoc} */\n  public void unmarshall(FetchRequest request, ParameterMap parameters) {\n\n    String required = parameters.get(Parameter.required.QNAME);\n    if (!DatatypeHelper.isEmpty(required)) {\n      String[] requiredAliases = required.split(\",\");\n      for (String alias : requiredAliases) {\n        String typeURI = unmarshallAttribute(request, parameters, alias);\n        if (typeURI != null) {\n          request.getRequiredAttributes().add(typeURI);\n        }\n      }\n    }\n\n    String optional = parameters.get(Parameter.if_available.QNAME);\n    if (!DatatypeHelper.isEmpty(optional)) {\n      String[] optionalAliases = optional.split(\",\");\n      for (String alias : optionalAliases) {\n        String typeURI = unmarshallAttribute(request, parameters, alias);\n        if (typeURI != null) {\n          request.getOptionalAttributes().add(typeURI);\n        }\n      }\n    }\n\n    String updateURL = parameters.get(Parameter.update_url.QNAME);\n    if (!DatatypeHelper.isEmpty(updateURL)) {\n      request.setUpdateURL(updateURL);\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8723, "initialization": ["String string = URI.getQuery()"], "initializationStart": [259], "initializationEnd": [273], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(null==string)", "guardType": "IF {", "guardExpressionStart": 279, "guardExpressionEnd": 297, "guardBlockStart": 279, "guardBlockEnd": 310, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 334, "focalAPIEnd": 350, "followUpCheck": "strArray.length > 0", "checkType": "IF", "followUpCheckExpressionStart": 356, "followUpCheckExpressionEnd": 378, "followUpCheckBlockStart": 356, "followUpCheckBlockEnd": 655, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/good-life/PushTalk/tree/master/client-android/src/org/pushtalk/android/Global.java", "rawCode": "  public static String getCurrentChatting(String url) {\n    if (StringUtils.isEmpty(url)) return url;\n    URI uri;\n    try {\n      uri = new URI(url);\n    } catch (URISyntaxException e) {\n      e.printStackTrace();\n      return null;\n    }\n    String query = uri.getQuery();\n    if (null == query) return null;\n\n    String[] params = query.split(\"&\");\n    if (params.length > 0) {\n      for (String param : params) {\n        if (param.contains(Constants.KEY_CHATTING)) {\n          String[] s = param.split(\"=\");\n          if (s.length > 1) {\n            return s[1];\n          }\n        }\n      }\n    } else {\n      Logger.d(TAG, \"No query param.\");\n    }\n\n    return null;\n  }\n"}, {"dataset": "split", "exampleID": 8724, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["log(*,String,*)"], "tryExpressionStart": 424, "tryExpressionEnd": 428, "tryBlockStart": 424, "tryBlockEnd": 3405, "catchExpressionStart": 3137, "catchExpressionEnd": 3159, "catchBlockStart": 3137, "catchBlockEnd": 3268, "exceptionHandlingCallStart": [3167], "exceptionHandlingCallEnd": [3247], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(string)!=null && string.startsWith(\"r \",)", "guardType": "LOOP {", "guardExpressionStart": 556, "guardExpressionEnd": 594, "guardBlockStart": 556, "guardBlockEnd": 3111, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 821, "focalAPIEnd": 836, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kjbbb/ernie/tree/master/src/SanitizedBridgesWriter.java", "rawCode": "  /**\n   * Sanitizes a network status and writes it to disk. Processes every r line separately and looks\n   * up whether the descriptor mapping contains a bridge with given identity hash and descriptor\n   * publication time.\n   */\n  public void sanitizeAndStoreNetworkStatus(byte[] data, String publicationTime) {\n\n    /* Parse the given network status line by line. */\n    StringBuilder scrubbed = new StringBuilder();\n    try {\n      BufferedReader br = new BufferedReader(new StringReader(new String(data, \"US-ASCII\")));\n      String line = null;\n      while ((line = br.readLine()) != null) {\n\n        /* r lines contain sensitive information that needs to be removed\n         * or replaced. */\n        if (line.startsWith(\"r \")) {\n\n          /* Parse the relevant parts of this r line. */\n          String[] parts = line.split(\" \");\n          String bridgeIdentity = parts[2];\n          String descPublicationTime = parts[4] + \" \" + parts[5];\n          String orPort = parts[7];\n          String dirPort = parts[8];\n\n          /* Look up the descriptor in the descriptor mapping, or add a\n           * new mapping entry if there is none. */\n          String hashedBridgeIdentityHex =\n              Hex.encodeHexString(DigestUtils.sha(Base64.decodeBase64(bridgeIdentity + \"==\")))\n                  .toLowerCase();\n          String mappingKey = hashedBridgeIdentityHex + \",\" + descPublicationTime;\n          DescriptorMapping mapping = null;\n          if (this.bridgeDescriptorMappings.containsKey(mappingKey)) {\n            mapping = this.bridgeDescriptorMappings.get(mappingKey);\n          } else {\n            mapping =\n                new DescriptorMapping(hashedBridgeIdentityHex.toLowerCase(), descPublicationTime);\n            this.bridgeDescriptorMappings.put(mappingKey, mapping);\n          }\n\n          /* Write scrubbed r line to buffer. */\n          String hashedBridgeIdentityBase64 =\n              Base64.encodeBase64String(DigestUtils.sha(Base64.decodeBase64(bridgeIdentity + \"==\")))\n                  .substring(0, 27);\n          String sdi =\n              Base64.encodeBase64String(\n                      Hex.decodeHex(mapping.serverDescriptorIdentifier.toCharArray()))\n                  .substring(0, 27);\n          scrubbed.append(\n              \"r Unnamed \"\n                  + hashedBridgeIdentityBase64\n                  + \" \"\n                  + sdi\n                  + \" \"\n                  + descPublicationTime\n                  + \" 127.0.0.1 \"\n                  + orPort\n                  + \" \"\n                  + dirPort\n                  + \"\\n\");\n\n          /* Nothing special about s lines; just copy them. */\n        } else if (line.startsWith(\"s \")) {\n          scrubbed.append(line + \"\\n\");\n\n          /* There should be nothing else but r and s lines in the network\n           * status. If there is, we should probably learn before writing\n           * anything to the sanitized descriptors. */\n        } else {\n          this.logger.fine(\n              \"Unknown line '\" + line + \"' in bridge \" + \"network status. Not writing to disk!\");\n          return;\n        }\n      }\n      br.close();\n\n    } catch (IOException e) {\n      this.logger.log(Level.WARNING, \"Could not parse bridge network \" + \"status.\", e);\n      return;\n    } catch (DecoderException e) {\n      this.logger.log(Level.WARNING, \"Could not parse bridge network \" + \"status.\", e);\n      return;\n    }\n\n    /* Write the sanitized network status to disk. */\n    try {\n\n      /* Determine file name. */\n      String syear = publicationTime.substring(0, 4);\n      String smonth = publicationTime.substring(5, 7);\n      String sday = publicationTime.substring(8, 10);\n      String stime =\n          publicationTime.substring(11, 13)\n              + publicationTime.substring(14, 16)\n              + publicationTime.substring(17, 19);\n      File statusFile =\n          new File(\n              this.sanitizedBridgesDir\n                  + \"/\"\n                  + syear\n                  + \"/\"\n                  + smonth\n                  + \"/statuses/\"\n                  + sday\n                  + \"/\"\n                  + syear\n                  + smonth\n                  + sday\n                  + \"-\"\n                  + stime\n                  + \"-\"\n                  + \"4A0CCD2DDC7995083D73F5D667100C8A5831F16D\");\n\n      /* Create all parent directories to write this network status. */\n      statusFile.getParentFile().mkdirs();\n\n      /* Write sanitized network status to disk. */\n      BufferedWriter bw = new BufferedWriter(new FileWriter(statusFile));\n      bw.write(scrubbed.toString());\n      bw.close();\n\n    } catch (IOException e) {\n      this.logger.log(\n          Level.WARNING, \"Could not write sanitized bridge \" + \"network status to disk.\", e);\n      return;\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8725, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["new UnknownHostException(String)"], "tryExpressionStart": 89, "tryExpressionEnd": 93, "tryBlockStart": 89, "tryBlockEnd": 545, "catchExpressionStart": 455, "catchExpressionEnd": 488, "catchBlockStart": 455, "catchBlockEnd": 545, "exceptionHandlingCallStart": [188], "exceptionHandlingCallEnd": [224], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 118, "focalAPIEnd": 141, "followUpCheck": "strArray.length != 4", "checkType": "IF", "followUpCheckExpressionStart": 149, "followUpCheckExpressionEnd": 171, "followUpCheckBlockStart": 149, "followUpCheckBlockEnd": 233, "use": ["new UnknownHostException(string)", "new UnknownHostException(string)"], "useStart": [188, 502], "useEnd": [224, 538], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arjunroy/cinder_base/tree/master/wifi/java/android/net/wifi/WifiStateTracker.java", "rawCode": "  private static int stringToIpAddr(String addrString) throws UnknownHostException {\n    try {\n      String[] parts = addrString.split(\"\\\\.\");\n      if (parts.length != 4) {\n        throw new UnknownHostException(addrString);\n      }\n\n      int a = Integer.parseInt(parts[0]);\n      int b = Integer.parseInt(parts[1]) << 8;\n      int c = Integer.parseInt(parts[2]) << 16;\n      int d = Integer.parseInt(parts[3]) << 24;\n\n      return a | b | c | d;\n    } catch (NumberFormatException ex) {\n      throw new UnknownHostException(addrString);\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8726, "initialization": ["String string = URI.getHost()"], "initializationStart": [1532], "initializationEnd": [1550], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1619, "focalAPIEnd": 1636, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/extension/app-schema/app-schema-resolver/src/main/java/org/geotools/xml/AppSchemaResolver.java", "rawCode": "  /**\n   * Return the Simple HTTP Resource Path for an absolute http/https URL.\n   *\n   * <p>The Simple HTTP Resource Path maps an HTTP or HTTPS URL to a path on the classpath or\n   * relative to some other root. To form the Simple HTTP Resource Path from an http/https URL:\n   *\n   * <ol>\n   *   <li>Protocol, port, fragment, and query are ignored.\n   *   <li>Take the host name, split it into its components, reverse their order, prepend a forward\n   *       slash to each, and concatenate them.\n   *   <li>Append the path component of the URL.\n   * </ol>\n   *\n   * For example <code>http://schemas.example.org/exampleml/exml.xsd</code> becomes <code>\n   * /org/example/schemas/exampleml/exml.xsd</code> .\n   *\n   * <p>The Simple HTTP Resource Path always starts with a forward slash (if not null). Does not\n   * include query components in the path.\n   *\n   * @param location not null\n   * @param keepQuery indicates whether or not the query components should be included in the path.\n   *     If this is set to true then the query portion is converted to an MD5 message digest and\n   *     that string is used to identify the file in the cache.\n   * @return the Simple HTTP Resource Path as a string, or null if the URI is not an absolute\n   *     HTTP/HTTPS URL.\n   */\n  public static String getSimpleHttpResourcePath(URI location, boolean keepQuery) {\n    String scheme = location.getScheme();\n    if (scheme == null || !(scheme.equals(\"http\") || scheme.equals(\"https\"))) {\n      return null;\n    } else {\n      String host = location.getHost();\n      String path = location.getPath();\n      String[] hostParts = host.split(\"\\\\.\");\n      StringBuilder builder = new StringBuilder();\n      for (int i = hostParts.length - 1; i >= 0; i--) {\n        builder.append(\"/\");\n        builder.append(hostParts[i]);\n      }\n      builder.append(path);\n      String query = location.getQuery();\n      if (keepQuery && query != null) {\n        builder.append(\".\");\n        builder.append(stringToMD5String(query));\n        builder.append(\".xsd\");\n      }\n      return builder.toString();\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8727, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 435, "focalAPIEnd": 451, "followUpCheck": "i < strArray.length", "checkType": "LOOP", "followUpCheckExpressionStart": 458, "followUpCheckExpressionEnd": 494, "followUpCheckBlockStart": 458, "followUpCheckBlockEnd": 703, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Netstatum/Laboratorio-2-EDA/tree/master/src/Grafica/src/Interno/serializar.java", "rawCode": "  /**\n   * Lee los síntomas desde el string valor en donde están separados por comas y las agrega al nodo\n   * dado\n   *\n   * @param valor String que contiene a los síntomas separados por comas: vómitos,mareos,etc\n   * @param nodo Nodo al cual se va a agregar los síntomas\n   */\n  private void crear_sintomas(String valor, Nodo nodo) {\n    int i;\n\n    // los valores de los síntomas están separados por una coma\n    String[] valores = valor.split(\",\");\n\n    for (i = 0; i < valores.length; i++) {\n      if (valores[i] != null) {\n        // encontramos un síntoma valido, le sacamos los\n        // espacios a ambos lados y lo agregamos a nodo\n        nodo.AgregarSintoma(valores[i].trim());\n      }\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8728, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 805, "focalAPIEnd": 822, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(String,string)"], "useStart": [2020], "useEnd": [2049], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/htmlunit-fork/tree/master/htmlunit/src/test/java/com/gargoylesoftware/htmlunit/javascript/regexp/mozilla/MozillaTestGenerator.java", "rawCode": "  /**\n   * Outputs java test case for the specified JavaScript source.\n   *\n   * @param author the author name\n   * @param htmlunitRoot HtmlUnit root path\n   * @param mozillaRoot Mozilla root path\n   * @param jsPath relative JavaScript source path, e.g. \"/js/src/tests/js1_2/regexp/everything.js\"\n   * @param initialScript whether another initial script is needed or not\n   * @throws IOException if a reading error occurs\n   */\n  public static void printMozillaTest(\n      final String author,\n      final String htmlunitRoot,\n      final String mozillaRoot,\n      final String jsPath,\n      final boolean initialScript)\n      throws IOException {\n    for (final Object o : FileUtils.readLines(new File(htmlunitRoot, \"LICENSE.txt\"))) {\n      System.out.println(o);\n    }\n    final String[] jsPathTokens = jsPath.split(\"/\");\n    System.out.println(\n        \"package com.gargoylesoftware.htmlunit.javascript.regexp.mozilla.\" + jsPathTokens[4] + \";\");\n    System.out.println();\n    System.out.println(\"import org.junit.Test;\");\n    System.out.println(\"import org.junit.runner.RunWith;\");\n    System.out.println();\n    System.out.println(\"import com.gargoylesoftware.htmlunit.BrowserRunner;\");\n    System.out.println(\"import com.gargoylesoftware.htmlunit.WebDriverTestCase;\");\n    System.out.println(\"import com.gargoylesoftware.htmlunit.BrowserRunner.Alerts;\");\n    System.out.println();\n    System.out.println(\"/**\");\n    System.out.println(\" * Tests originally in '\" + jsPath + \"'.\");\n    System.out.println(\" *\");\n    System.out.println(\" * @version $Revision$\");\n    System.out.println(\" * @author \" + author);\n    System.out.println(\" */\");\n    System.out.println(\"@RunWith(BrowserRunner.class)\");\n    String className = jsPathTokens[jsPathTokens.length - 1];\n    className =\n        Character.toUpperCase(className.charAt(0)) + className.substring(1, className.length() - 3);\n    System.out.println(\"public class \" + className + \"Test extends WebDriverTestCase {\");\n    final List<String> lines = FileUtils.readLines(new File(mozillaRoot, jsPath));\n    int testNumber = 1;\n    for (int i = 0; i < lines.size(); i++) {\n      final String line = lines.get(i);\n      if (line.startsWith(\"new TestCase\")) {\n        if (line.endsWith(\";\")) {\n          System.out.println(\"ERROR...... test case ends with ; in \" + (i + 1));\n          continue;\n        }\n        int x = i + 1;\n        String next = lines.get(x++).trim();\n        while (!next.endsWith(\";\")) {\n          next = lines.get(x++).trim();\n        }\n        final String expected = getExpected(next);\n        final String script;\n        if (next.startsWith(\"String(\")) {\n          final int p0 = next.indexOf(\"String(\", 1) + \"String(\".length();\n          script = next.substring(p0, next.length() - 3);\n        } else if (next.startsWith(\"\\\"\")) {\n          script = next.substring(expected.length() + 3, next.length() - 2).trim();\n        } else {\n          script = next.substring(next.indexOf(',') + 1, next.length() - 2).trim();\n        }\n        System.out.println();\n        System.out.println(\" /**\");\n        System.out.println(\" * Tests \" + script + \".\");\n        System.out.println(\" * @throws Exception if the test fails\");\n        System.out.println(\" */\");\n        System.out.println(\" @Test\");\n        System.out.println(\" @Alerts(\\\"\" + expected + \"\\\")\");\n        System.out.println(\" public void test\" + testNumber++ + \"() throws Exception {\");\n        if (initialScript) {\n          System.out.print(\" test(initialScript, \");\n        } else {\n          System.out.print(\" test(\");\n        }\n        System.out.println(\"\\\"\" + script.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\") + \"\\\");\");\n        System.out.println(\" }\");\n      }\n    }\n    System.out.println();\n    if (initialScript) {\n      System.out.println(\" private void test(final String script) throws Exception {\");\n      System.out.println(\" test(null, script);\");\n      System.out.println(\" }\");\n      System.out.println(\"\");\n      System.out.println(\n          \" private void test(final String initialScript, final String script) throws Exception {\");\n      System.out.println(\" String html = \\\"<html><head><title>foo</title><script>\\\\n\\\";\");\n      System.out.println(\" if (initialScript != null) {\");\n      System.out.println(\" html += initialScript + \\\";\\\\n\\\";\");\n      System.out.println(\" }\");\n      System.out.println(\" html += \\\" alert(\\\" + script + \\\");\\\\n\\\"\");\n      System.out.println(\" + \\\"</script></head><body>\\\\n\\\"\");\n      System.out.println(\" + \\\"</body></html>\\\";\");\n      System.out.println(\" loadPageWithAlerts2(html);\");\n      System.out.println(\" }\");\n    } else {\n      System.out.println(\" private void test(final String script) throws Exception {\");\n      System.out.println(\" final String html = \\\"<html><head><title>foo</title><script>\\\\n\\\"\");\n      System.out.println(\" + \\\" alert(\\\" + script + \\\");\\\\n\\\"\");\n      System.out.println(\" + \\\"</script></head><body>\\\\n\\\"\");\n      System.out.println(\" + \\\"</body></html>\\\";\");\n      System.out.println(\" loadPageWithAlerts2(html);\");\n      System.out.println(\" }\");\n    }\n    System.out.println(\"}\");\n  }\n"}, {"dataset": "split", "exampleID": 8729, "initialization": ["String string = String.substring(int)"], "initializationStart": [131], "initializationEnd": [183], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 209, "focalAPIEnd": 224, "followUpCheck": "strArray.length < 2", "checkType": "IF", "followUpCheckExpressionStart": 230, "followUpCheckExpressionEnd": 254, "followUpCheckBlockStart": 230, "followUpCheckBlockEnd": 267, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codehaus/jetty-project/tree/master/jetty-reverse-http/reverse-http-gateway/src/main/java/org/mortbay/jetty/rhttp/gateway/StandardTargetIdRetriever.java", "rawCode": "  public String retrieveTargetId(HttpServletRequest httpRequest) {\n    String uri = httpRequest.getRequestURI();\n    String path = uri.substring(httpRequest.getServletPath().length());\n    String[] segments = path.split(\"/\");\n    if (segments.length < 2) return null;\n    return segments[1];\n  }\n"}, {"dataset": "split", "exampleID": 8730, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 240, "focalAPIEnd": 261, "followUpCheck": "strArray != null", "checkType": "IF", "followUpCheckExpressionStart": 472, "followUpCheckExpressionEnd": 500, "followUpCheckBlockStart": 472, "followUpCheckBlockEnd": 1303, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/europeana/contrib/tree/master/repox/branches/repox_rhine/src/main/java/pt/utl/ist/repox/web/action/mapMetadata/MapMetadataActionBean.java", "rawCode": "  public Resolution submitMappings()\n      throws NoSuchFieldException, IllegalAccessException, DocumentException, IOException,\n          TransformerException, NoSuchAlgorithmException {\n    String[] mappedTagsArray = (mappedTags != null ? mappedTags.split(\",\") : null);\n    loadSessionVariables();\n\n    dcMappings = new TreeMap<String, Set<String>>();\n    for (Tag currentDcTag : dcTags) {\n      dcMappings.put(currentDcTag.getXpath(), new TreeSet<String>());\n    }\n\n    if (mappedTagsArray != null) {\n      for (String currentMappedTagItem : mappedTagsArray) {\n        String[] mappedTag = currentMappedTagItem.split(\"-\");\n        int mappedDcPos = Integer.parseInt(mappedTag[0]);\n        int mappedParsedTagPos = Integer.parseInt(mappedTag[1]);\n\n        Set<String> currentParsedTagsSet = dcMappings.get(dcTags.get(mappedDcPos).getXpath());\n        if (currentParsedTagsSet == null) {\n          currentParsedTagsSet = new TreeSet<String>();\n        }\n        currentParsedTagsSet.add(parsedTags.get(mappedParsedTagPos).getXpath());\n        dcMappings.put(dcTags.get(mappedDcPos).getXpath(), currentParsedTagsSet);\n      }\n    } else {\n      getContext().getMessages().add(new LocalizableError(\"error.mapMetadata.noMappings\"));\n      return new ForwardResolution(\"/jsp/mapMetadata/mapping.jsp\");\n    }\n\n    SAXReader reader = new SAXReader();\n    Document document = reader.read(getTempFile());\n    OutputFormat format = OutputFormat.createPrettyPrint();\n    OutputStream outputStream = new ByteArrayOutputStream();\n    XMLWriter writer = new XMLWriter(outputStream, format);\n    writer.write(document);\n\n    sampleXml = outputStream.toString();\n\n    setTransformations(document);\n\n    saveSessionVariables();\n\n    return new ForwardResolution(\"/jsp/mapMetadata/mappingResult.jsp\");\n  }\n"}, {"dataset": "split", "exampleID": 8731, "initialization": ["String string = PathPrefix.getPrefix()"], "initializationStart": [449], "initializationEnd": [467], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(\"\".equals(string,))", "guardType": "IF {", "guardExpressionStart": 629, "guardExpressionEnd": 655, "guardBlockStart": 629, "guardBlockEnd": 728, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 806, "focalAPIEnd": 827, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 901, "followUpCheckExpressionEnd": 926, "followUpCheckBlockStart": 901, "followUpCheckBlockEnd": 1210, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lexspoon/scalagwt-gwt/tree/master/dev/core/src/com/google/gwt/dev/resource/impl/PathPrefixSet.java", "rawCode": "  /**\n   * @param prefix the prefix to add\n   * @return <code>true</code> if the prefix was not already in the set; otherwise, it merged with\n   *     one having the same prefix, which has the effect of expanding the filter (the merge works\n   *     as <code>union(includes - skips) - union(excludes)</code>)\n   */\n  public boolean add(PathPrefix prefix) {\n    prefix.setPriority(prefixes.size());\n    prefixes.add(prefix);\n\n    String pathPrefix = prefix.getPrefix();\n\n    /*\n     * An empty prefix means we have no prefix requirement, but we do attach the\n     * prefix to the root so that we can apply the filter.\n     */\n    if (\"\".equals(pathPrefix)) {\n      rootTrieNode.extendPathPrefix(prefix);\n      return false;\n    }\n\n    // TODO(bruce): consider not using split for speed\n    String[] parts = pathPrefix.split(\"/\");\n    TrieNode parentNode = rootTrieNode;\n    boolean didAdd = false;\n    for (String part : parts) {\n      TrieNode childNode = parentNode.findChild(part);\n      if (childNode != null) {\n        // Follow existing branch.\n        parentNode = childNode;\n      } else {\n        // Add a new branch.\n        parentNode = parentNode.addChild(part);\n        didAdd = true;\n      }\n    }\n    assert (parentNode != null);\n    parentNode.extendPathPrefix(prefix);\n    return didAdd;\n  }\n"}, {"dataset": "split", "exampleID": 8732, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 331, "focalAPIEnd": 347, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 409, "followUpCheckExpressionEnd": 430, "followUpCheckBlockStart": 409, "followUpCheckBlockEnd": 478, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fhdragon/dragon/tree/master/dragon-commons/src/main/java/org/apache/dragon/commons/util/StringUtil.java", "rawCode": "  /**\n   * 根据regex分隔str字符串，并转化为int值，若非字符串则默认为defaultVal. 若str、regex为null，则抛出NullPointerException\n   *\n   * @param str\n   * @param regex\n   * @param defaultVal\n   * @return\n   * @throws NullPointerException if str or regex is null\n   */\n  public static int[] splitInt(String str, String regex, int defaultVal) {\n    String[] strs = str.split(regex);\n    int[] result = new int[strs.length];\n    int i = 0;\n    for (String s : strs) {\n      result[i++] = num(s, defaultVal);\n    }\n    return result;\n  }\n"}, {"dataset": "split", "exampleID": 8733, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(null==string)", "guardType": "IF {", "guardExpressionStart": 108, "guardExpressionEnd": 122, "guardBlockStart": 108, "guardBlockEnd": 169, "focalAPI": "strArray = string.split(regex,limit)", "focalAPIStart": 197, "focalAPIEnd": 212, "followUpCheck": "strArray.length == limit", "checkType": "IF", "followUpCheckExpressionStart": 296, "followUpCheckExpressionEnd": 317, "followUpCheckBlockStart": 296, "followUpCheckBlockEnd": 550, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vega113/WaveInCloud/tree/master/src/org/waveprotocol/wave/model/version/HashedVersionSerializer.java", "rawCode": "        @Override\n        public HashedVersion fromString(String s, HashedVersion defaultValue) {\n          if (null == s) {\n            return defaultValue;\n          }\n\n          String[] pair = s.split(\":\", 2);\n          long v = Long.parseLong(pair[0]);\n          byte[] h = EMPTY;\n          if (pair.length == 2) {\n            try {\n              h = CharBase64.decode(pair[1]);\n            } catch (Base64DecoderException e) {\n              throw new IllegalArgumentException(\"Invalid base64 hash: '\" + pair[1] + \"'\");\n            }\n          }\n          return HashedVersion.of(v, h);\n        }\n"}, {"dataset": "split", "exampleID": 8734, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 354, "focalAPIEnd": 372, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["createArrayToList(strArray)"], "useStart": [336], "useEnd": [373], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/remain/topick/tree/master/client/Topick/src/com/kosenventure/sansan/others/OCRTask.java", "rawCode": "  @Override\n  protected void onPostExecute(String result) {\n    super.onPostExecute(result);\n\n    // ダイアログを消す\n    mProgressDialog.dismiss();\n    // 結果がnullなら解析失敗\n    if (result == null)\n      Toast.makeText(mContext, getStr(R.string.toast_pick_up_failure_msg), Toast.LENGTH_SHORT)\n          .show();\n    // resultに\\nで区切られて格納されているため\n    createArrayToList(result.split(\"\\n\"));\n    showSelectKanaDialog();\n  }\n"}, {"dataset": "split", "exampleID": 8735, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 893, "focalAPIEnd": 912, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/OpenIotOrg/openiot/tree/master/modules/x-gsn/src/main/java/org/openiot/gsn/wrappers/StsPiezometerWrapper.java", "rawCode": "  private boolean readStatus() {\n    String filename;\n    if (file_handling) filename = datadirectory;\n    else filename = svnurl;\n    filename = filename.replace('/', '_');\n    filename = filename.replace(':', '_');\n    filename = filename.replace('\\\\', '_');\n    statusFile = new File(directory + File.separator + filename + \"_status.txt\");\n    String contents = null;\n    if (statusFile.exists()) {\n      try {\n        BufferedReader input = new BufferedReader(new FileReader(statusFile));\n        try {\n          String line = null; // not declared within while loop\n          while ((line = input.readLine()) != null) {\n            contents = line;\n          }\n        } finally {\n          input.close();\n        }\n      } catch (IOException ex) {\n        ex.printStackTrace();\n      }\n      logger.warn(\"Content of the last line of the status file: \" + contents);\n      String[] list = contents.split(\";\");\n      logger.warn(\"number of split elements: \" + list.length + \" 0:\" + list[0] + \" 1:\" + list[1]);\n      this.lastEnteredStreamelement = new Long(list[0]);\n      this.lastModified = new Long(list[1]);\n    } else {\n      try {\n        statusFile.createNewFile();\n      } catch (IOException e) {\n        logger.error(\"the status file can not be created \" + statusFile.getAbsolutePath());\n        return false;\n      }\n    }\n\n    return true;\n  }\n"}, {"dataset": "split", "exampleID": 8736, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 118, "focalAPIEnd": 139, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 145, "followUpCheckExpressionEnd": 167, "followUpCheckBlockStart": 145, "followUpCheckBlockEnd": 436, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openrocket/openrocket/tree/master/swing/src/net/sf/openrocket/startup/jij/ManifestClasspathProvider.java", "rawCode": "  private void parseManifestLine(List<URL> urls, String manifest) throws MalformedURLException {\n    String[] array = manifest.split(\"\\\\s\");\n    for (String s : array) {\n      if (s.length() > 0) {\n        if (getClass().getClassLoader().getResource(s) != null) {\n          urls.add(new URL(\"classpath:\" + s));\n        } else {\n          System.err.println(\"Library \" + s + \" not found on classpath, ignoring.\");\n        }\n      }\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8737, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 99, "focalAPIEnd": 120, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gvtools/gvtools-legacy/tree/master/extensions/extWMS/src/com/iver/cit/gvsig/fmap/layers/DefaultDimension.java", "rawCode": "  public int valueCount() {\n    if (compiled) {\n      if (type == MULTIPLE_VALUE) {\n        return expression.split(\",\").length;\n      } else if (type == INTERVAL) {\n        int count;\n        double min = Double.parseDouble((String) minValue);\n        double max = Double.parseDouble((String) maxValue);\n        double step = Double.parseDouble(period);\n        double distance = max - min;\n        count = (int) (distance / step);\n        return count;\n      } else {\n        return 1;\n      }\n    }\n    return -1;\n  }\n"}, {"dataset": "split", "exampleID": 8738, "initialization": ["String string = Properties.getProperty(String)"], "initializationStart": [1428], "initializationEnd": [1463], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null", "guardType": "IF {", "guardExpressionStart": 1473, "guardExpressionEnd": 1491, "guardBlockStart": 1473, "guardBlockEnd": 1547, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1512, "focalAPIEnd": 1536, "followUpCheck": "!CollectionUtil.isEmpty(strArray)", "checkType": "IF", "followUpCheckExpressionStart": 1557, "followUpCheckExpressionEnd": 1592, "followUpCheckBlockStart": 1557, "followUpCheckBlockEnd": 1739, "use": ["_load(boolean,ClassLoader,boolean,strArray)"], "useStart": [1629], "useEnd": [1666], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fbierhaus/hackathon/tree/master/common/src/com/vzw/util/config/AbstractProperties.java", "rawCode": "  /**\n   * Recursive method call\n   *\n   * @param cl\n   * @param searchRealPath\n   * @param fileNames\n   * @throws Exception\n   */\n  private Properties _load(\n      boolean buildFileInfos, ClassLoader cl, boolean searchRealPath, String... fileNames)\n      throws Exception {\n\n    Properties propRet = new Properties();\n    InputStream fis = null;\n\n    for (String fn : fileNames) {\n      URL url = cl.getResource(fn);\n\n      File f = null;\n\n      if (url != null) {\n        f = new File(url.getFile());\n      } else if (searchRealPath) {\n        f = new File(fn);\n        if (!(f.exists() && f.isFile())) {\n          f = null;\n        }\n      }\n\n      if (f != null) {\n        // we found a file\n        Properties propCur = new Properties();\n\n        try {\n          fis = new FileInputStream(f);\n          propCur.load(fis);\n        } finally {\n          CleanupUtil.release(fis);\n          fis = null;\n        }\n\n        if (buildFileInfos) {\n          if (fileInfos == null) {\n            fileInfos = new ArrayList<FileInfo>();\n          }\n          FileInfo fi = new FileInfo(f);\n          fi.setLastModified(f.lastModified());\n          fileInfos.add(fi);\n        }\n\n        //\n        // check imports\n        //\n        boolean srp;\n        String srpStr = propCur.getProperty(\"import.search_real_path\");\n        srp = StringUtils.equalsIgnoreCase(srpStr, \"true\");\n\n        String[] files = null;\n        String flStr = propCur.getProperty(\"import.files\");\n        if (flStr != null) {\n          files = flStr.split(\"\\\\s*,\\\\s*\");\n        }\n\n        if (!CollectionUtil.isEmpty(files)) {\n          Properties propImport = _load(buildFileInfos, cl, srp, files);\n          // once done,\n          propRet.putAll(propImport);\n        }\n\n        propRet.putAll(propCur);\n\n        //\n        // now check sub dir\n        //\n        checkIncludeHome(propRet, f);\n        // once done, the include_home_subdir will be removed\n      }\n    }\n\n    return propRet;\n  }\n"}, {"dataset": "split", "exampleID": 8739, "initialization": ["String string = Element.getAttribute(String)"], "initializationStart": [329], "initializationEnd": [360], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 388, "focalAPIEnd": 408, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hackystat/hackystat-sensor-eclipse/tree/master/plugin/src/org/hackystat/sensor/eclipse/VersionCheck.java", "rawCode": "  /**\n   * Gets the version from the element.\n   *\n   * @param element Element node in the XML file.\n   * @return Version if the feature node has a valid version number.\n   */\n  private static Version getVersion(Element element) {\n    Version identifier = null;\n\n    if (element.hasAttribute(\"version\")) {\n      String version = element.getAttribute(\"version\");\n      String[] versions = version.split(\"\\\\.\");\n      String newVersion = versions[0] + \".\" + versions[1];\n      identifier = new Version(newVersion);\n    }\n\n    return identifier;\n  }\n"}, {"dataset": "split", "exampleID": 8740, "initialization": ["String string = holeEinzelFeld(String)", "String string = holeEinzelFeld(String)"], "initializationStart": [599, 1170], "initializationEnd": [679, 1260], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1337, "focalAPIEnd": 1353, "followUpCheck": "i < strArray.length", "checkType": "LOOP", "followUpCheckExpressionStart": 1371, "followUpCheckExpressionEnd": 1409, "followUpCheckBlockStart": 1371, "followUpCheckBlockEnd": 1534, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bomm/thera-pi-2/tree/master/Reha301/src/reha301Panels/Reha301Auswerten.java", "rawCode": "  /** ***************************************** */\n  private Vector<Object> doSetPatientFuerNachricht(String patid) {\n    // dta301mod.show_X_PatData();\n    Vector<Object> vecobj = new Vector<Object>();\n    patBetroffen = String.valueOf(patid);\n    String ktraeger = tab.getValueAt(tab.getSelectedRow(), 7).toString();\n    // String kkasse = tab.getValueAt(tab.getSelectedRow(), 8).toString();\n    String id = tab.getValueAt(tab.getSelectedRow(), 11).toString();\n    // String diag1 = SqlInfo.holeEinzelFeld(\"select diagschluessel from dta301 where id ='\"+id+\"'\n    // LIMIT 1\");\n    String diag1 = SqlInfo.holeEinzelFeld(\"select esol from dta301 where id ='\" + id + \"' LIMIT 1\");\n    /*String[] diag2 = diag1.split(\"\\\\+\");\n    if(diag2[2].split(\":\")[0].startsWith(\"M\") || diag2[2].split(\":\")[0].startsWith(\"S\") ||\n    diag2[2].split(\":\")[0].startsWith(\"Q\") || diag2[2].split(\":\")[0].startsWith(\"T\") ){\n    diaggruppe = \"04\";\n    }\n    */\n    String diaggruppe = null;\n    // Die muß ersetzt werden durch Abteilung 2300;\n    if (diag1.indexOf(\"CTA+ABT+2300\") >= 0) {\n      diaggruppe = \"04\";\n    }\n    rVTraeger = testeDTAIni(ktraeger, diaggruppe);\n\n    diag1 =\n        SqlInfo.holeEinzelFeld(\"select diagschluessel from dta301 where id ='\" + id + \"' LIMIT 1\");\n\n    String[] diag2 = null;\n    String diagnose = \"\";\n    String[] diags = diag1.split(\"@\");\n    try {\n      for (int i = 0; i < diags.length; i++) {\n        diag2 = diags[i].split(\"\\\\+\");\n        diagnose = diagnose + (i > 0 ? \"\\n\" : \"\") + diag2[2].split(\":\")[0];\n      }\n    } catch (Exception ex) {\n      ex.printStackTrace();\n    }\n    String fallart =\n        SqlInfo.holeEinzelFeld(\"select leistung from dta301 where id ='\" + id + \"' LIMIT 1\");\n    String eilfall =\n        SqlInfo.holeEinzelFeld(\"select eilfall from dta301 where id ='\" + id + \"' LIMIT 1\");\n    String preisgruppe =\n        SqlInfo.holeEinzelFeld(\n            \"select preisgruppe from kass_adr where ik_kostent ='\" + ktraeger + \"' LIMIT 1\");\n    //// System.out.println();\n    if (((Integer) rVTraeger[0]) >= 0) {\n      // RV-Träger\n      /*\n      //System.out.println(\"Patient=\"+patBetroffen);\n      //System.out.println(\"Kostenträger=\"+ktraeger);\n      //System.out.println(\"Diagnose=\"+diagnose);\n      //System.out.println(\"Fallart=\"+fallart);\n      //System.out.println(\"Eilfall=\"+eilfall);\n      //System.out.println(\"Preisgruppe=\"+preisgruppe);\n      //System.out.println(\"Diagnosegruppe=\"+diaggruppe);\n      for(int i = 0; i < rVTraeger.length;i++){\n      //System.out.println(rVTraeger[i]);\n      }\n      */\n      isRVTraeger = true;\n      vecobj.add(rVTraeger);\n      vecobj.add(patBetroffen);\n      vecobj.add(ktraeger);\n      vecobj.add(diagnose);\n      vecobj.add(fallart);\n      vecobj.add(eilfall);\n      vecobj.add(preisgruppe);\n      vecobj.add(diaggruppe);\n\n    } else {\n      // KrankenKasse\n      isRVTraeger = false;\n    }\n\n    // Verordnung überpüfen\n    // Verordnung anlegen\n    //\n    return vecobj;\n  }\n"}, {"dataset": "split", "exampleID": 8741, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(isValueBlank(string,))", "guardType": "IF {", "guardExpressionStart": 204, "guardExpressionEnd": 229, "guardBlockStart": 204, "guardBlockEnd": 256, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 560, "focalAPIEnd": 577, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/primefaces-dcs/tree/master/src/main/java/org/primefaces/component/imagecropper/ImageCropperRenderer.java", "rawCode": "  @Override\n  public Object getConvertedValue(\n      FacesContext context, UIComponent component, Object submittedValue)\n      throws ConverterException {\n    String coords = (String) submittedValue;\n    if (isValueBlank(coords)) {\n      return null;\n    }\n\n    ImageCropper cropper = (ImageCropper) component;\n\n    // remove query string\n    String imagePath = cropper.getImage();\n    int queryStringIndex = imagePath.indexOf(\"?\");\n    if (queryStringIndex != -1) {\n      imagePath = imagePath.substring(0, queryStringIndex);\n    }\n\n    String[] cropCoords = coords.split(\"_\");\n    String format = getFormat(imagePath);\n\n    int x = Integer.parseInt(cropCoords[0]);\n    int y = Integer.parseInt(cropCoords[1]);\n    int w = Integer.parseInt(cropCoords[2]);\n    int h = Integer.parseInt(cropCoords[3]);\n\n    try {\n      BufferedImage outputImage = getSourceImage(context, imagePath);\n      BufferedImage cropped = outputImage.getSubimage(x, y, w, h);\n\n      ByteArrayOutputStream croppedOutImage = new ByteArrayOutputStream();\n      ImageIO.write(cropped, format, croppedOutImage);\n\n      return new CroppedImage(cropper.getImage(), croppedOutImage.toByteArray(), x, y, w, h);\n\n    } catch (IOException e) {\n      throw new ConverterException(e);\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8742, "initialization": ["String string = Properties.getProperty(String)"], "initializationStart": [635], "initializationEnd": [662], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string.equals(\"null\",))", "guardType": "IF {", "guardExpressionStart": 672, "guardExpressionEnd": 700, "guardBlockStart": 672, "guardBlockEnd": 1177, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 775, "focalAPIEnd": 794, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chartsy/chartsy/tree/master/Chartsy/Main/src/org/chartsy/main/managers/CacheManager.java", "rawCode": "  public Dataset fetchVisibleDatasetFromCache(String fileName, int period, int end)\n      throws IOException {\n    String folder = FileUtils.cacheDatasetsFolder();\n    File file = FileUtils.hashedCacheFile(folder, fileName);\n\n    Properties properties = new Properties();\n    FileInputStream fileInputStream = new FileInputStream(file);\n    properties.load(fileInputStream);\n\n    List<DataItem> items = new ArrayList<DataItem>();\n    int size = properties.size();\n    for (int i = 0; i < period; i++) {\n      int j = end - period + i;\n      if (j < size && j >= 0) {\n        String key = Integer.toString(j);\n        String property = properties.getProperty(key);\n        if (property.equals(\"null\")) {\n          items.add(null);\n        } else {\n          String[] values = property.split(\",\");\n          DataItem item =\n              new DataItem(\n                  Long.parseLong(values[0]),\n                  Double.parseDouble(values[1]),\n                  Double.parseDouble(values[2]),\n                  Double.parseDouble(values[3]),\n                  Double.parseDouble(values[4]),\n                  Double.parseDouble(values[5]));\n          items.add(item);\n        }\n      }\n    }\n\n    fileInputStream.close();\n    Dataset dataset = new Dataset(items);\n    return dataset;\n  }\n"}, {"dataset": "split", "exampleID": 8743, "initialization": ["String string = BufferedReader.readLine()", "String string = String.trim()"], "initializationStart": [672, 783], "initializationEnd": [684, 794], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["string.trim()"], "configurationStart": [783], "configurationEnd": [794], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 933, "focalAPIEnd": 950, "followUpCheck": "strArray.length < 4", "checkType": "IF", "followUpCheckExpressionStart": 958, "followUpCheckExpressionEnd": 980, "followUpCheckBlockStart": 958, "followUpCheckBlockEnd": 1176, "use": ["println(string)", "println(string)"], "useStart": [1064, 1350], "useEnd": [1088, 1374], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/helioliu/vooga/tree/master/src/levelEditor_delta/GraphicsBank.java", "rawCode": "  /**\n   * Load tileset from file. This will combine the tilesets if one has already been loaded. The most\n   * recently loaded tileset file becomes the \"loadedFrom\" tileset.\n   */\n  public void loadTileset(File from) throws FileNotFoundException, IOException {\n    BufferedReader r;\n    String line;\n    String tokens[];\n    int id;\n    int lineCount;\n    File tileFile;\n\n    if (tiles.size() > 0) {\n      isUnsaved = true;\n    } else {\n      isUnsaved = false;\n    }\n\n    System.out.println(from);\n    baseDirectory = from.getParentFile();\n    this.loadedFrom = from;\n\n    lineCount = 0;\n    r = new BufferedReader(new FileReader(from));\n    while (true) {\n      line = r.readLine();\n      lineCount++;\n\n      // stop when no more lines\n      if (line == null) break;\n      line = line.trim();\n      if (line.length() == 0 || line.charAt(0) == COMMENT) {\n        continue; // skip comments and empty lines.\n      }\n\n      tokens = line.split(DELIM);\n      if (tokens.length < 4) {\n        System.err.println(\"Could not parse line \" + lineCount + \". :\");\n        System.err.println(line);\n        System.err.println(\"(There are not enough tokens)\");\n        continue;\n      }\n      try {\n        id = Integer.parseInt(tokens[ID].trim());\n      } catch (Exception e) {\n        System.err.println(\"Could not parse line \" + lineCount + \". :\");\n        System.err.println(line);\n        System.err.println(\"(The tile id is not a valid number)\");\n        continue;\n      }\n\n      // get file for image\n      tokens[PATH] = tokens[PATH].trim();\n      tokens[NAME] = tokens[NAME].trim();\n      tokens[TYPE] = tokens[TYPE].trim();\n\n      tileFile = new File(baseDirectory, tokens[PATH]);\n      // System.out.println(\"load tile image: \"+tileFile);\n      if (!tileFile.exists()) {\n        tileFile = new File(tokens[PATH]);\n        if (tileFile.exists()) {\n          System.err.println(\n              \"WARNING: file \" + tokens[PATH] + \" not within the tilemaps working directory\");\n        } else {\n          r.close();\n          throw new FileNotFoundException(\n              \"File \"\n                  + tokens[PATH]\n                  + \" referenced on line \"\n                  + lineCount\n                  + \" of \"\n                  + from\n                  + \" could not be found\");\n        }\n      }\n\n      // System.out.println(\"New tile: \"+id+\", name = \"+tokens[NAME]);\n\n      Tile t = null;\n\n      if (tokens.length > EXTRA) {\n        t =\n            new Tile(\n                id,\n                tileFile.toString(),\n                tokens[NAME].trim(),\n                tokens[TYPE].trim(),\n                tokens[EXTRA].trim());\n      } else {\n        t = new Tile(id, tileFile.toString(), tokens[NAME], tokens[TYPE]);\n      }\n      tiles.add(t);\n    }\n  } // end loadTileset\n"}, {"dataset": "split", "exampleID": 8744, "initialization": ["String string = Text.toString()"], "initializationStart": [242], "initializationEnd": [256], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 284, "focalAPIEnd": 301, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 399, "followUpCheckExpressionEnd": 424, "followUpCheckBlockStart": 399, "followUpCheckBlockEnd": 517, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seweissman/wikiduper/tree/master/src/main/wikiduper/clir/minhash/SampleSentenceTranslations.java", "rawCode": "    @Override\n    public void reduce(\n        Text key,\n        Iterator<IntWritable> values,\n        OutputCollector<IntWritable, ArrayListWritable<Text>> output,\n        Reporter reporter)\n        throws IOException {\n      String keyStr = key.toString();\n      String keySplit[] = keyStr.split(\",\");\n      Text outWord;\n      ArrayListWritable<Text> outsig = new ArrayListWritable<Text>();\n      for (String w : keySplit) {\n        outWord = new Text();\n        outWord.set(w);\n        outsig.add(outWord);\n      }\n      IntWritable idxOut = new IntWritable();\n      idxOut.set(ct);\n      ct++;\n\n      output.collect(idxOut, outsig);\n    }\n"}, {"dataset": "split", "exampleID": 8745, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 496, "focalAPIEnd": 518, "followUpCheck": "strArray.length > 1", "checkType": "IF", "followUpCheckExpressionStart": 524, "followUpCheckExpressionEnd": 546, "followUpCheckBlockStart": 524, "followUpCheckBlockEnd": 669, "use": ["new DisjunctiveConditions(strArray)", "parseFromConjuncts(string)"], "useStart": [629, 681], "useEnd": [662, 710], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ICMediaLab/HelloGame/tree/master/src/conditiontree/Condition.java", "rawCode": "  /**\n   * Returns a new conditional evaluate-able node.\n   *\n   * @param condition The string to be parsed when creating the branch.\n   * @throws IllegalArgumentException If a condition is malformed.\n   * @throws NoSuchFieldException If a specified condition parameter does not exist.\n   */\n  public static Condition getCondition(String condition)\n      throws IllegalArgumentException, NoSuchFieldException {\n    // split disjuncts (or statements) denoted by | characters\n    String[] juncts = condition.split(\"\\\\|\");\n    if (juncts.length > 1) {\n      // if multiple disjuncts exist, create a container for them.\n      return new DisjunctiveConditions(juncts);\n    }\n    return parseFromConjuncts(condition);\n  }\n"}, {"dataset": "split", "exampleID": 8746, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 257, "focalAPIEnd": 279, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dryade/chouette/tree/master/chouette-exchange-gtfs/src/main/java/fr/certu/chouette/exchange/gtfs/exporter/producer/GtfsTripProducer.java", "rawCode": "  private GtfsTrip produce(\n      VehicleJourney vj, String timetableId, List<GtfsStopTime> times, boolean multipleTimetable) {\n\n    GtfsTrip trip = new GtfsTrip();\n\n    String tripId = toGtfsId(vj.getObjectId());\n    if (multipleTimetable) tripId += \"_\" + timetableId.split(\":\")[2];\n\n    trip.setTripId(tripId);\n\n    // route = un aller-retour !\n    Route route = vj.getRoute();\n    if (\"R\".equals(route.getWayBack()) && route.getWayBackRouteId() != null) {\n      logger.info(\"trip \" + vj.getObjectId() + \" as wayback of route \" + route.getWayBackRouteId());\n      trip.setRouteId(toGtfsId(route.getWayBackRouteId()));\n      trip.setDirectionId(GtfsTrip.INBOUND);\n    } else {\n      logger.info(\"trip \" + vj.getObjectId() + \" as direct of route \" + route.getWayBackRouteId());\n\n      trip.setRouteId(toGtfsId(route.getObjectId()));\n      trip.setDirectionId(GtfsTrip.OUTBOUND);\n    }\n\n    trip.setServiceId(toGtfsId(timetableId));\n\n    // trip.setTripHeadsign(...);\n    String name = vj.getPublishedJourneyName();\n    if (name == null && vj.getNumber() != null) name = \"\" + vj.getNumber();\n    else name = \"\";\n    if (name.trim().length() == 0 && vj.getComment() != null) name = vj.getComment();\n    if (name.trim().length() != 0) trip.setTripShortName(name);\n    // trip.setShapeId(...);\n\n    // add StopTimes\n    for (GtfsStopTime time : times) {\n      GtfsStopTime copy = time.copy();\n      copy.setTripId(tripId);\n      trip.addStopTime(copy);\n    }\n\n    return trip;\n  }\n"}, {"dataset": "split", "exampleID": 8747, "initialization": ["String string = getString(*,*)"], "initializationStart": [102], "initializationEnd": [186], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 367, "focalAPIEnd": 391, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 455, "followUpCheckExpressionEnd": 490, "followUpCheckBlockStart": 455, "followUpCheckBlockEnd": 555, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/adamz667/packages_apps_ROMControl/tree/master/src/com/aokp/romcontrol/fragments/StatusBarToggles.java", "rawCode": "  public static ArrayList<String> getTogglesStringArray(Context c) {\n    String clusterfuck =\n        Settings.System.getString(c.getContentResolver(), Settings.System.STATUSBAR_TOGGLES);\n\n    if (clusterfuck == null) {\n      Log.e(TAG, \"clusterfuck was null\");\n      // return null;\n      clusterfuck = \"WIFI|BT|GPS|ROTATE\";\n    }\n\n    String[] togglesStringArray = clusterfuck.split(\"\\\\|\");\n    ArrayList<String> iloveyou = new ArrayList<String>();\n    for (String s : togglesStringArray) {\n      Log.e(TAG, \"adding: \" + s);\n      iloveyou.add(s);\n    }\n\n    return iloveyou;\n  }\n"}, {"dataset": "split", "exampleID": 8748, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null", "guardType": "IF {", "guardExpressionStart": 97, "guardExpressionEnd": 111, "guardBlockStart": 97, "guardBlockEnd": 590, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 137, "focalAPIEnd": 149, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 157, "followUpCheckExpressionEnd": 187, "followUpCheckBlockStart": 157, "followUpCheckBlockEnd": 584, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sgattani/Group-Project/tree/master/FacebookSDK/src/com/facebook/android/Util.java", "rawCode": "  @Deprecated\n  public static Bundle decodeUrl(String s) {\n    Bundle params = new Bundle();\n    if (s != null) {\n      String array[] = s.split(\"&\");\n      for (String parameter : array) {\n        String v[] = parameter.split(\"=\");\n\n        try {\n          if (v.length == 2) {\n            params.putString(URLDecoder.decode(v[0], UTF8), URLDecoder.decode(v[1], UTF8));\n          } else if (v.length == 1) {\n            params.putString(URLDecoder.decode(v[0], UTF8), \"\");\n          }\n        } catch (UnsupportedEncodingException e) {\n          // shouldn't happen\n        }\n      }\n    }\n    return params;\n  }\n"}, {"dataset": "split", "exampleID": 8749, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 233, "focalAPIEnd": 245, "followUpCheck": "strArray.length == 0 || strArray.length > 3", "checkType": "IF", "followUpCheckExpressionStart": 251, "followUpCheckExpressionEnd": 285, "followUpCheckBlockStart": 251, "followUpCheckBlockEnd": 296, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/noe/sgf.importer/tree/master/src/sgfimporter/game/Clock.java", "rawCode": "  /**\n   * Parses a time string. The expected format is <tt>[[H:]MM:]SS</tt>.\n   *\n   * @return The time in milliseconds or -1, if the time string is not valid.\n   */\n  public static long parseTimeString(String s) {\n    String a[] = s.split(\":\");\n    if (a.length == 0 || a.length > 3) return -1;\n    int hours = 0;\n    int minutes = 0;\n    int seconds = 0;\n    try {\n      if (a.length == 3) {\n        hours = Integer.parseInt(a[0]);\n        minutes = Integer.parseInt(a[1]);\n        seconds = Integer.parseInt(a[2]);\n      } else if (a.length == 2) {\n        minutes = Integer.parseInt(a[0]);\n        seconds = Integer.parseInt(a[1]);\n      } else {\n        assert a.length == 1;\n        seconds = Integer.parseInt(a[0]);\n      }\n    } catch (NumberFormatException e) {\n      return -1;\n    }\n    if (minutes < 0 || minutes > 60 || seconds < 0 || seconds > 60) return -1;\n    return 1000L * (seconds + minutes * 60L + hours * 3600L);\n  }\n"}, {"dataset": "split", "exampleID": 8750, "initialization": ["String string = Event.getResource()"], "initializationStart": [381], "initializationEnd": [400], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 618, "focalAPIEnd": 640, "followUpCheck": "strArray.length >= 4", "checkType": "IF", "followUpCheckExpressionStart": 646, "followUpCheckExpressionEnd": 668, "followUpCheckBlockStart": 646, "followUpCheckBlockEnd": 1634, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0-rc02/kernel-impl/src/main/java/org/sakaiproject/content/impl/DropboxNotification.java", "rawCode": "  /**\n   * Get the list of User objects who are eligible to receive the notification email.\n   *\n   * @param event The event that matched criteria to cause the notification.\n   * @return the list of User objects who are eligible to receive the notification email.\n   */\n  protected List getRecipients(Event event) {\n    List recipients = new ArrayList();\n\n    String resourceRef = event.getResource();\n    Reference ref = EntityManager.newReference(resourceRef);\n\n    ResourceProperties props = ref.getProperties();\n    String modifiedBy = props.getProperty(ResourceProperties.PROP_MODIFIED_BY);\n\n    String parts[] = resourceRef.split(\"/\");\n    if (parts.length >= 4) {\n      String dropboxOwnerId = parts[4];\n      if (modifiedBy != null && modifiedBy.equals(dropboxOwnerId)) {\n        // notify instructor(s)\n        StringBuilder buf = new StringBuilder();\n        buf.append(\"/content/group-user/\");\n        buf.append(parts[3]);\n        buf.append(\"/\");\n        String siteDropbox = buf.toString();\n\n        recipients.addAll(\n            SecurityService.unlockUsers(ContentHostingService.AUTH_DROPBOX_MAINTAIN, siteDropbox));\n      } else {\n        // notify student\n        try {\n          User user = UserDirectoryService.getUser(dropboxOwnerId);\n          recipients.add(user);\n        } catch (UserNotDefinedException e0) {\n          try {\n            User user = UserDirectoryService.getUserByEid(dropboxOwnerId);\n            recipients.add(user);\n          } catch (UserNotDefinedException e1) {\n            logger.warn(\"UserNotDefinedException trying to get user: \" + dropboxOwnerId);\n          }\n        }\n      }\n    }\n\n    return recipients;\n  }\n"}, {"dataset": "split", "exampleID": 8751, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 443, "focalAPIEnd": 470, "followUpCheck": "strArray.length < 2", "checkType": "IF", "followUpCheckExpressionStart": 476, "followUpCheckExpressionEnd": 502, "followUpCheckBlockStart": 476, "followUpCheckBlockEnd": 553, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CSLD/CSLD/tree/master/src/main/java/cz/larpovadatabaze/dao/CsldUserDAO.java", "rawCode": "  /**\n   * Used when autoCompletable field is used.\n   *\n   * @param autoCompletable Expected format is {Name, Email} Email is unique identifier of person as\n   *     well as user.\n   * @return It should return only single user or no user if none belongs to given data.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public List<CsldUser> getByAutoCompletable(String autoCompletable)\n      throws WrongParameterException {\n    String[] personData = autoCompletable.split(\", \");\n    if (personData.length < 2) {\n      throw new WrongParameterException();\n    }\n    String email = personData[1];\n    Criteria uniqueUser =\n        getBuilder()\n            .build()\n            .getExecutableCriteria(sessionFactory.getCurrentSession())\n            .add(Restrictions.eq(\"person.email\", email));\n\n    return uniqueUser.list();\n  }\n"}, {"dataset": "split", "exampleID": 8752, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "AddressException", "exceptionHandlingCall": ["getMessage()", "error(String,*)"], "tryExpressionStart": 1248, "tryExpressionEnd": 1252, "tryBlockStart": 1248, "tryBlockEnd": 1966, "catchExpressionStart": 1783, "catchExpressionEnd": 1810, "catchBlockStart": 1783, "catchBlockEnd": 1966, "exceptionHandlingCallStart": [1939, 1894], "exceptionHandlingCallEnd": [1953, 1957], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.split(regex,).length>0", "guardType": "IF {", "guardExpressionStart": 1376, "guardExpressionEnd": 1405, "guardBlockStart": 1376, "guardBlockEnd": 1774, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1380, "focalAPIEnd": 1393, "followUpCheck": "i < strArray.length", "checkType": "LOOP", "followUpCheckExpressionStart": 1529, "followUpCheckExpressionEnd": 1573, "followUpCheckBlockStart": 1529, "followUpCheckBlockEnd": 1651, "use": ["new InternetAddress(string)"], "useStart": [1740], "useEnd": [1763], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IKANOW/Infinit.e/tree/master/core/infinit.e.data_model/src/com/ikanow/infinit/e/data_model/utils/SendMail.java", "rawCode": "  /**\n   * Sends mail messages\n   *\n   * @return\n   */\n  public boolean send(String mimeType) {\n    boolean sendMail = true;\n\n    PropertiesManager propManager = new PropertiesManager();\n    TextEncryption textEncryptor = new TextEncryption();\n    if (null == from) {\n      from = propManager.getProperty(\"log.files.mail.from\");\n    }\n\n    String host = propManager.getProperty(\"mail.server\");\n    String username = null;\n    String password = null;\n    try {\n      username = textEncryptor.decrypt(propManager.getProperty(\"mail.username\"));\n    } catch (Exception e) {\n      username = propManager.getProperty(\"mail.username\");\n    }\n    try {\n      password = textEncryptor.decrypt(propManager.getProperty(\"mail.password\"));\n    } catch (Exception e) {\n      password = propManager.getProperty(\"mail.password\");\n    }\n\n    Properties props = new Properties();\n    props.put(\"mail.smtps.auth\", \"true\");\n    Session session = Session.getDefaultInstance(props);\n\n    MimeMessage msg = new MimeMessage(session);\n    Transport t = null;\n\n    try {\n      t = session.getTransport(\"smtps\");\n\n      InternetAddress fromAddress = null;\n      // CV: 7/6/11 - Changed to array to support multiple recipients\n      InternetAddress[] toAddress = null;\n\n      try {\n        fromAddress = new InternetAddress(from);\n\n        // CV: 7/6/11 - Split on ; to get multiple to addresses\n        if (to.split(\";\").length > 0) {\n          String[] toAddresses = to.split(\";\");\n          toAddress = new InternetAddress[toAddresses.length];\n          for (int i = 0; i < toAddresses.length; i++) {\n            toAddress[i] = new InternetAddress(toAddresses[i]);\n          }\n        } else {\n          toAddress = new InternetAddress[1];\n          toAddress[0] = new InternetAddress(to);\n        }\n      } catch (AddressException e) {\n        sendMail = false;\n        // If an exception occurs log the error\n        logger.error(\"Address Exception Message: \" + e.getMessage(), e);\n      }\n\n      try {\n        msg.setFrom(fromAddress);\n        msg.setRecipients(RecipientType.TO, toAddress);\n        msg.setSubject(subject);\n        msg.setContent(text, mimeType);\n\n        t.connect(host, username, password);\n        t.sendMessage(msg, msg.getAllRecipients());\n\n      } catch (MessagingException e) {\n        sendMail = false;\n        // If an exception occurs log the error\n        logger.error(\"Messaging Exception Message: \" + e.getMessage(), e);\n\n      } finally {\n        try {\n          t.close();\n        } catch (MessagingException e) {\n          logger.error(\"Messaging Exception Message: \" + e.getMessage(), e);\n        }\n      }\n\n    } catch (NoSuchProviderException e) {\n      sendMail = false;\n      logger.error(\"Provider Exception Message: \" + e.getMessage(), e);\n    }\n\n    return sendMail;\n  }\n"}, {"dataset": "split", "exampleID": 8753, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string.contains(BuilderHelper.getTempLabel(),))", "guardType": "IF {", "guardExpressionStart": 686, "guardExpressionEnd": 742, "guardBlockStart": 686, "guardBlockEnd": 1475, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1085, "focalAPIEnd": 1108, "followUpCheck": "i < strArray.length", "checkType": "LOOP", "followUpCheckExpressionStart": 1116, "followUpCheckExpressionEnd": 1155, "followUpCheckBlockStart": 1116, "followUpCheckBlockEnd": 1469, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JonKjaersgaard/alt-ussr/tree/master/src/ussr/builder/saveLoadXML/PreSimulationXMLSerializer.java", "rawCode": "  protected void createNewModule(\n      String moduleName,\n      String moduleType,\n      VectorDescription modulePosition,\n      RotationDescription moduleRotation,\n      LinkedList<Color> listColorsComponents,\n      LinkedList<Color> listColorsConnectors,\n      String labelsModule,\n      String[] labelsConnectors) {\n    ModulePosition modulePos;\n    /* if (moduleType.contains(\"ATRON\")||moduleType.equalsIgnoreCase(\"default\")){\n    modulePos= new ModulePosition(moduleName,\"ATRON\",modulePosition,moduleRotation);\n    } else {*/\n    modulePos = new ModulePosition(moduleName, moduleType, modulePosition, moduleRotation);\n    // }\n\n    world.getModulePositions().add(modulePos);\n\n    if (labelsModule.contains(BuilderHelper.getTempLabel())) {\n      // do nothing\n    } else {\n      // Store labels in module properties, plus extract @-prefixed labels and define as properties\n      HashMap<String, String> properties = new HashMap<String, String>();\n      properties.put(BuilderHelper.getLabelsKey(), labelsModule);\n      modulePos.setProperties(properties);\n      String[] labels = labelsModule.split(\",\");\n      for (int i = 0; i < labels.length; i++) {\n        if (labels[i].startsWith(\"@\") && labels[i].indexOf('=') > 1) {\n          String key = labels[i].split(\"=\")[0].substring(1);\n          String value = labels[i].split(\"=\")[1];\n          properties.put(key, value);\n          System.out.println(\"Setting property \" + key + \" to \" + value);\n        }\n      }\n    }\n\n    PhysicsLogger.log(\n        \"Warning: colors not transferred\"); // newModule.setColorList(listColorsComponents);\n  }\n"}, {"dataset": "split", "exampleID": 8754, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 495, "focalAPIEnd": 512, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nelsonsilva/vaadin/tree/master/build/buildhelpers/com/vaadin/buildhelpers/CompileDefaultTheme.java", "rawCode": "  private static String updateUrls(\n      String folder, String themeName, boolean inheritedFile, String strLine) {\n    // Define image url prefix\n    String urlPrefix = \"\";\n    if (inheritedFile) {\n      urlPrefix = \"../\" + themeName + \"/\";\n    }\n\n    if (strLine.indexOf(\"url(/\") > 0) {\n      // Do nothing for urls beginning with /\n    } else if (strLine.indexOf(\"url(../\") >= 0) {\n      // eliminate a path segment in the folder name for every\n      // \"../\"\n      String[] folderSegments = folder.split(\"/\");\n      int segmentCount = folderSegments.length;\n      while (segmentCount > 0 && strLine.indexOf(\"url(../\") >= 0) {\n        segmentCount--;\n        strLine = strLine.replaceAll(\"url\\\\(../\", (\"url\\\\(\"));\n      }\n      // add remaining path segments to urlPrefix\n      StringBuilder sb = new StringBuilder(urlPrefix);\n      for (int i = 0; i < segmentCount; i++) {\n        sb.append(folderSegments[i]);\n        sb.append(\"/\");\n      }\n      strLine = strLine.replaceAll(\"url\\\\(\", (\"url\\\\(\" + sb.toString()));\n\n    } else {\n      strLine = strLine.replaceAll(\"url\\\\(\", (\"url\\\\(\" + urlPrefix + folder + \"/\"));\n    }\n    return strLine;\n  }\n"}, {"dataset": "split", "exampleID": 8755, "initialization": ["String string = BufferedReader.readLine()", "String string = BufferedReader.readLine()"], "initializationStart": [395, 545], "initializationEnd": [412, 562], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null && string.length()>0", "guardType": "LOOP {", "guardExpressionStart": 473, "guardExpressionEnd": 493, "guardBlockStart": 473, "guardBlockEnd": 1564, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 645, "focalAPIEnd": 662, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ARUP-NGS/Pipeline/tree/master/src/main/java/buffer/BEDFile.java", "rawCode": "  /**\n   * Construct/initialize a map which allows us to easily look up which sites are in the intervals\n   * described by this BED file. If arg is true, strip chr from all contig labels\n   *\n   * @throws IOException\n   */\n  public void buildIntervalsMap(boolean stripChr) throws IOException {\n    BufferedReader reader = new BufferedReader(new FileReader(getAbsolutePath()));\n    String line = reader.readLine();\n    intervals = new HashMap<String, List<Interval>>();\n    while (line != null) {\n      if (line.startsWith(\"#\")) {\n        line = reader.readLine();\n        continue;\n      }\n      if (line.length() > 0) {\n        String[] toks = line.split(\"\\\\s\");\n        String contig = toks[0];\n        if (stripChr) contig = contig.replace(\"chr\", \"\");\n        toks[1] = toks[1].trim();\n        toks[2] = toks[2].trim();\n        try {\n          Integer begin = Integer.parseInt(toks[1]) + 1;\n          Integer end = Integer.parseInt(toks[2]) + 1;\n          Interval interval = new Interval(begin, end);\n\n          List<Interval> contigIntervals = intervals.get(contig);\n          if (contigIntervals == null) {\n            contigIntervals = new ArrayList<Interval>(1024);\n            intervals.put(contig, contigIntervals);\n            // System.out.println(\"BED file adding contig: \" + contig);\n          }\n          contigIntervals.add(interval);\n        } catch (Exception ex) {\n          Logger.getLogger(Pipeline.primaryLoggerName)\n              .warning(\"Skipping invalid line in bed file: \" + line);\n        }\n      }\n      line = reader.readLine();\n    }\n\n    reader.close();\n    sortAllContigs();\n  }\n"}, {"dataset": "split", "exampleID": 8756, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 50, "focalAPIEnd": 63, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jianwang2010/Test/tree/master/public/java/src/org/broadinstitute/sting/gatk/walkers/varianteval/evaluators/GenotypeConcordance.java", "rawCode": "  public int parseAC(String s) {\n    String[] g = s.split(\"AC\");\n    return Integer.parseInt(g[1]);\n  }\n"}, {"dataset": "split", "exampleID": 8757, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 128, "focalAPIEnd": 146, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Data2Semantics/d2s-tools/tree/master/RDFmodel/src/main/java/org/data2semantics/RDFmodel/RDFGraph.java", "rawCode": "      @Override\n      public List<Integer> next() {\n        String line = _line;\n        cache_line();\n        String[] parts = line.split(\"\\\\s+\");\n        assert parts.length == 3 : \"Not a triple!\";\n        int subj_id = Integer.parseInt(parts[0]);\n        int pred_id = Integer.parseInt(parts[1]);\n        int obj_id = Integer.parseInt(parts[2]);\n        return Arrays.asList(subj_id, pred_id, obj_id);\n      }\n"}, {"dataset": "split", "exampleID": 8758, "initialization": ["String string = Bundle.getString(String)"], "initializationStart": [309], "initializationEnd": [351], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null", "guardType": "IF {", "guardExpressionStart": 359, "guardExpressionEnd": 389, "guardBlockStart": 359, "guardBlockEnd": 504, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 419, "focalAPIEnd": 447, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["asList(strArray)"], "useStart": [472], "useEnd": [494], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/OpenKit/openkit-android/tree/master/Vendor/facebook/src/com/facebook/widget/PickerFragment.java", "rawCode": "  private void setPickerFragmentSettingsFromBundle(Bundle inState) {\n    // We do this in a separate non-overridable method so it is safe to call from the constructor.\n    if (inState != null) {\n      showPictures = inState.getBoolean(SHOW_PICTURES_BUNDLE_KEY, showPictures);\n      String extraFieldsString = inState.getString(EXTRA_FIELDS_BUNDLE_KEY);\n      if (extraFieldsString != null) {\n        String[] strings = extraFieldsString.split(\",\");\n        setExtraFields(Arrays.asList(strings));\n      }\n      showTitleBar = inState.getBoolean(SHOW_TITLE_BAR_BUNDLE_KEY, showTitleBar);\n      String titleTextString = inState.getString(TITLE_TEXT_BUNDLE_KEY);\n      if (titleTextString != null) {\n        titleText = titleTextString;\n        if (titleTextView != null) {\n          titleTextView.setText(titleText);\n        }\n      }\n      String doneButtonTextString = inState.getString(DONE_BUTTON_TEXT_BUNDLE_KEY);\n      if (doneButtonTextString != null) {\n        doneButtonText = doneButtonTextString;\n        if (doneButton != null) {\n          doneButton.setText(doneButtonText);\n        }\n      }\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8759, "initialization": ["String string = String.substring(int)", "String string = String.substring(int)"], "initializationStart": [1019, 1151], "initializationEnd": [1052, 1171], "hasTryCatch": 1, "exceptionType": "PathNotFoundException", "exceptionHandlingCall": ["getMessage()", "Log.debug(String)"], "tryExpressionStart": 371, "tryExpressionEnd": 375, "tryBlockStart": 371, "tryBlockEnd": 4018, "catchExpressionStart": 1994, "catchExpressionEnd": 2029, "catchBlockStart": 1994, "catchBlockEnd": 3320, "exceptionHandlingCallStart": [2092, 2067], "exceptionHandlingCallEnd": [2109, 2116], "configuration": ["string.substring(int)"], "configurationStart": [1151], "configurationEnd": [1171], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1212, "focalAPIEnd": 1230, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 1334, "followUpCheckExpressionEnd": 1368, "followUpCheckBlockStart": 1334, "followUpCheckBlockEnd": 1434, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta11/kernel-impl-experimental/content/jcr/sakai-content-jcr-impl/src/main/java/org/sakaiproject/content/impl/BaseJCRStorage.java", "rawCode": "  /**\n   * Create a new node. Nodes are of the form nt:folder/nt:folder/nt:folder/nt:file nt:folders have\n   * properties nt:files have properties nt:files have a nt:resource subnode\n   *\n   * @param id\n   * @param collection\n   * @return\n   * @throws TypeException\n   */\n  private Node createNode(String id, String type) throws TypeException {\n    Node node = null;\n    try {\n      String absPath = m_user.convertId2Storage(id);\n      Session s = jcrService.getSession();\n      Node n = getNodeFromSession(s, absPath);\n      // the node might already exist\n      if (n != null) {\n        return n;\n      }\n\n      String vpath = getParentPath(absPath);\n      while (n == null && !\"/\".equals(vpath)) {\n        n = getNodeFromSession(s, vpath);\n        if (n == null) {\n          vpath = getParentPath(vpath);\n        } else {\n          log.debug(\"Got Path \" + vpath + \" as \" + n);\n        }\n      }\n      if (n == null) {\n        n = s.getRootNode();\n      }\n      log.debug(\"VPath is \" + vpath);\n      String relPath = absPath.substring(vpath.length());\n      // Node rootNode = s.getRootNode();\n      if (relPath.startsWith(\"/\")) {\n        relPath = relPath.substring(1);\n      }\n\n      String[] pathElements = relPath.split(\"/\");\n      log.debug(\"RelPath is \" + relPath + \" split into \" + pathElements.length + \" elements \");\n      for (String pathel : pathElements) {\n        log.debug(\" Path Element is [\" + pathel + \"]\");\n      }\n\n      Node currentNode = n;\n      for (int i = 0; i < pathElements.length; i++) {\n        try {\n          log.debug(\"Getting \" + pathElements[i] + \" under \" + currentNode);\n          currentNode = currentNode.getNode(pathElements[i]);\n          if (!currentNode.isNodeType(JCRConstants.NT_FOLDER)\n              && !currentNode.isNodeType(JCRConstants.NT_BASE)) {\n            throw new TypeException(\n                \"Cant create collection or a folder inside a node that is not a folder \"\n                    + currentNode.getPath());\n          }\n\n        } catch (PathNotFoundException pnfe) {\n          if (log.isDebugEnabled()) log.debug(\"Not Found \" + pnfe.getMessage() + \" \");\n          if (i < pathElements.length - 1 || JCRConstants.NT_FOLDER.equals(type)) {\n            if (log.isDebugEnabled())\n              log.debug(\n                  \"Adding Node \"\n                      + pathElements[i]\n                      + \" as \"\n                      + type\n                      + \" to \"\n                      + currentNode.getPath());\n            Node newNode = currentNode.addNode(pathElements[i], JCRConstants.NT_FOLDER);\n            populateFolder(newNode);\n            currentNode.save();\n            currentNode = newNode;\n            if (log.isDebugEnabled()) log.debug(\"Adding Node Complete\");\n          } else {\n            if (log.isDebugEnabled())\n              log.debug(\n                  \"Adding Node \"\n                      + pathElements[i]\n                      + \" as \"\n                      + type\n                      + \" to \"\n                      + currentNode.getPath());\n            Node newNode = currentNode.addNode(pathElements[i], JCRConstants.NT_FILE);\n            populateFile(newNode);\n            currentNode.save();\n            currentNode = newNode;\n            if (log.isDebugEnabled()) log.debug(\"Adding Node Complete\");\n          }\n        }\n        if (currentNode.isCheckedOut()) {\n          currentNode.save();\n        }\n      }\n      node = currentNode;\n      if (node == null) {\n        log.error(\"Failed to create Node \" + absPath + \" got \" + node);\n        throw new Error(\"Failed to create node \" + absPath + \" got \" + node);\n      } else if (!absPath.equals(node.getPath())) {\n\n        log.error(\"Failed to create Node \" + absPath + \" got\" + node.getPath());\n        throw new Error(\"Failed to create node \" + absPath + \" got \" + node.getPath());\n      }\n\n    } catch (RepositoryException rex) {\n      log.warn(\"Unspecified Repository Failiure \", rex);\n      log.error(\"Unspecified Repository Failiure \" + rex.getMessage());\n    }\n    return node;\n  }\n"}, {"dataset": "split", "exampleID": 8760, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 191, "focalAPIEnd": 211, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sakai-mirror/edu-services/tree/master/gradebook-service/impl/src/java/org/sakaiproject/tool/gradebook/facades/sakai2impl/GradebookConditionsProvider.java", "rawCode": "  public Map<String, String> getData(String type, String context) {\n    Map<String, String> rv = new HashMap<String, String>();\n    if (\"grades\".equals(type)) {\n      String[] contextParts = context.split(\"\\\\|\");\n      String gradebookId = contextParts[0];\n      String assignmentName = contextParts[1];\n      String studentId = contextParts[2];\n      Long assignmentId = null;\n      for (Object assignment : gbs.getAssignments(gradebookId)) {\n        if (((Assignment) assignment).getName().equals(assignmentName)) {\n          assignmentId = ((Assignment) assignment).getId();\n          break;\n        }\n      }\n      if (assignmentId != null) {\n        String score = gbs.getAssignmentScoreString(gradebookId, assignmentId, studentId);\n        if (score == null) {\n          score = \"\";\n        }\n        rv.put(\"score\", score);\n      }\n    }\n\n    return rv;\n  }\n"}, {"dataset": "split", "exampleID": 8761, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 122, "focalAPIEnd": 140, "followUpCheck": "strArray[0].trim().length() > 0", "checkType": "IF", "followUpCheckExpressionStart": 146, "followUpCheckExpressionEnd": 183, "followUpCheckBlockStart": 146, "followUpCheckBlockEnd": 356, "use": ["println(string)"], "useStart": [1378], "useEnd": [1402], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/deriggi/wilderness-sar/tree/master/src/main/java/raster/AsciiParser2.java", "rawCode": "  @Deprecated\n  private void handleLine(String line, double xmin, double ymin, int lineNumber) {\n    String[] lineParts = line.split(\"\\\\s+\");\n    if (lineParts[0].trim().length() > 0) {\n      log.log(\n          Level.FINE,\n          \"{0} first:{1} last: {2}\",\n          new Object[] {lineParts.length, lineParts[0], lineParts[lineParts.length - 1]});\n    }\n\n    int colNumber = 0;\n    log.log(Level.FINE, \"col width: {0}\", lineParts.length);\n    final String INF = \"Inf\";\n    for (String s : lineParts) {\n\n      // make column count and line count global\n      // increment line number only after column count reached\n\n      if (s.trim().length() > 0) {\n        double rowOffset = (numRows - (lineNumber - STANDARD_HEADER_SIZE)) * cellSize;\n        double y = ymin + rowOffset - cellSize;\n\n        double colOffset = (colNumber) * cellSize;\n        double x = xmin + colOffset;\n\n        if (!s.equalsIgnoreCase(INF)) {\n          try {\n            double val = Double.parseDouble(s);\n            if (val != nullValue) {\n              // this.action.handleNonNullData(y, x, val);\n              log.log(\n                  Level.FINE,\n                  \"row: {0} col: {1} x: {2} y:{3}\",\n                  new Object[] {lineNumber - STANDARD_HEADER_SIZE, colNumber, x, y});\n            }\n          } catch (NumberFormatException nfe) {\n            nfe.printStackTrace();\n            System.out.println(line);\n          }\n        }\n        colNumber++;\n      }\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8762, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 52, "focalAPIEnd": 72, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/helianbobo/FlipDroid/tree/master/app/src/com/goal98/flipdroid2/model/FakeArticleSource.java", "rawCode": "  private boolean loadArticle() {\n    strLibArray = strLib.split(\"\\\\s+\");\n\n    for (int i = 0; i < 20; i++) {\n      list.add(generateFakeArticle());\n    }\n\n    lastModified = new Date();\n    return true;\n  }\n"}, {"dataset": "split", "exampleID": 8763, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "error(*,*)"], "tryExpressionStart": 315, "tryExpressionEnd": 319, "tryBlockStart": 315, "tryBlockEnd": 2144, "catchExpressionStart": 2078, "catchExpressionEnd": 2098, "catchBlockStart": 2078, "catchBlockEnd": 2144, "exceptionHandlingCallStart": [2119, 2106], "exceptionHandlingCallEnd": [2133, 2137], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1920, "focalAPIEnd": 1934, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["exec(strArray)"], "useStart": [1894], "useEnd": [1935], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rob42/freeboard-server/tree/master/src/main/java/nz/co/fortytwo/freeboard/server/util/Util.java", "rawCode": "  /**\n   * Attempt to set the system time using the GPS time\n   *\n   * @param sen\n   */\n  @SuppressWarnings(\"deprecation\")\n  public static void checkTime(RMCSentence sen) {\n    if (timeSet) {\n      return;\n    }\n    try {\n      sen.getPosition();\n    } catch (DataNotAvailableException e) {\n      return;\n    }\n    try {\n      net.sf.marineapi.nmea.util.Date dayNow = sen.getDate();\n      // if we need to set the time, we will be WAAYYY out\n      // we only try once, so we dont get lots of native processes spawning if we fail\n      props = getConfig(null);\n      if (props.getProperty(Constants.DEMO).equals(\"false\")) {\n        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n          // includes: Windows 2000, Windows 95, Windows 98, Windows NT, Windows Vista, Windows XP\n          // a Win system will already have the time set.\n          return;\n        }\n      }\n      timeSet = true;\n      Date date = new Date();\n      net.sf.marineapi.nmea.util.Date gpsDate;\n\n      // so we need to set the date and time\n      net.sf.marineapi.nmea.util.Time gpsTime = sen.getTime();\n      gpsDate = sen.getDate();\n      String hh = pad(2, String.valueOf(gpsTime.getHour()));\n      String mm = pad(2, String.valueOf(gpsTime.getMinutes()));\n      String ss = pad(2, String.valueOf((int) gpsTime.getSeconds()));\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Setting current date to \" + dayNow + \" \" + gpsTime);\n      }\n      String cmd =\n          \"sudo date --utc \"\n              + pad(2, String.valueOf(gpsDate.getMonth()))\n              + pad(2, String.valueOf(gpsDate.getDay()))\n              + hh\n              + mm\n              + gpsDate.getYear()\n              + \".\"\n              + ss;\n      System.out.println(\"Setting date \" + cmd);\n      // only set the system time if we are not running demo\n      if (props.getProperty(Constants.DEMO).equals(\"false\")) {\n        Runtime.getRuntime().exec(cmd.split(\" \")); // MMddhhmm[[yy]yy]\n      }\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Executed date setting command:\" + cmd);\n      }\n    } catch (Exception e) {\n      logger.error(e.getMessage(), e);\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8764, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 82, "focalAPIEnd": 99, "followUpCheck": "strArray.length > 1 && !strArray[1].trim().isEmpty()", "checkType": "IF", "followUpCheckExpressionStart": 105, "followUpCheckExpressionEnd": 148, "followUpCheckBlockStart": 105, "followUpCheckBlockEnd": 194, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/obiba/magma/tree/master/magma-datasource-csv/src/main/java/org/obiba/magma/datasource/csv/converter/VariableConverter.java", "rawCode": "  @Nullable\n  private Locale getAttributeLocale(String header) {\n    String[] h = header.split(\":\");\n    if (h.length > 1 && !h[1].trim().isEmpty()) {\n      return new Locale(h[1].trim());\n    }\n    return null;\n  }\n"}, {"dataset": "split", "exampleID": 8765, "initialization": ["String string = BufferedReader.readLine()"], "initializationStart": [348], "initializationEnd": [361], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(string)!=null", "guardType": "LOOP {", "guardExpressionStart": 329, "guardExpressionEnd": 371, "guardBlockStart": 329, "guardBlockEnd": 1530, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 422, "focalAPIEnd": 441, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pcoriente/LaAnita/tree/master/LaAnita/src/java/pedidos/LeerTextuales/LeerTextuales.java", "rawCode": "  public ArrayList<Imss> leerArchivoImss(File archivoTexto) throws IOException {\n    ArrayList<Imss> lstIms = new ArrayList<Imss>();\n    BufferedReader in = new BufferedReader(new FileReader(archivoTexto));\n    String registro;\n    String anio;\n    String mes;\n    String dia;\n    String fecha;\n    registro = in.readLine();\n    while ((registro = in.readLine()) != null) {\n      String[] pedidoArray;\n      pedidoArray = registro.split(\",\");\n      Imss ims = new Imss();\n      ims.setOrdenCompra(pedidoArray[0]);\n      anio = pedidoArray[1].substring(6);\n      mes = pedidoArray[1].substring(3, 5);\n      dia = pedidoArray[1].substring(0, 2);\n      fecha = anio + \"-\" + mes + \"-\" + dia;\n      ims.setFechaElaboracion(Date.valueOf(fecha));\n      ims.setFechaEmbarque(Date.valueOf(fecha));\n      anio = pedidoArray[2].substring(6);\n      mes = pedidoArray[2].substring(3, 5);\n      dia = pedidoArray[2].substring(0, 2);\n      fecha = anio + \"-\" + mes + \"-\" + dia;\n      ims.setFechaCancelacion(Date.valueOf(fecha));\n      ims.setCodigoTienda(Integer.parseInt(pedidoArray[3]));\n      ims.setDescripcion(pedidoArray[12]);\n      ims.setSku(pedidoArray[10]);\n      ims.setUpc(pedidoArray[11]);\n      ims.setCantidad(\n          (Float.parseFloat(pedidoArray[14].substring(0, 2)))\n              * (Float.parseFloat(pedidoArray[16])));\n      ims.setEmpaque(Float.parseFloat(pedidoArray[14].substring(0, 2)));\n      ims.setCosto(Float.parseFloat(pedidoArray[17]));\n      ims.setNumeroProveedor(pedidoArray[5]);\n      lstIms.add(ims);\n    }\n    return lstIms;\n  }\n"}, {"dataset": "split", "exampleID": 8766, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 150, "focalAPIEnd": 169, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/EJEHardenberg/GreenUp/tree/master/android/src/com/xenon/greenup/HomeSectionFragment.java", "rawCode": "  public long getChronoTime(String timeForm) {\n    // The chronometer doesn't actually have a 'getTime' function. So here's one\n    String[] pieces = timeForm.split(\":\");\n\n    long t = 0;\n    for (int i = pieces.length - 1; i >= 0; i--) {\n      try {\n        long temp = Long.parseLong(pieces[i]);\n        t += temp * (temp == 0 ? 0 : Math.pow(60, pieces.length - i - 1));\n      } catch (Exception e) {\n        // What did we get\n        Log.i(\"stupidChrono:\", pieces[i]);\n      }\n    }\n    return t;\n  }\n"}, {"dataset": "split", "exampleID": 8767, "initialization": ["String string = ContentResource.getContentType()"], "initializationStart": [212], "initializationEnd": [250], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 344, "focalAPIEnd": 363, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/KNL-1158/kernel-impl/src/main/java/org/sakaiproject/content/impl/BaseExtensionResourceFilter.java", "rawCode": "  public boolean allowSelect(ContentResource resource) {\n    // on a new resource, it seems that getContentType is more reliable than accessing that value\n    // through properties.\n    String mimeType =\n        resource\n            .getContentType(); // .getProperties().getProperty(ResourceProperties.PROP_CONTENT_TYPE);\n    String[] parts = mimeType.split(\"/\");\n    String primaryType = parts[0];\n\n    if (!getMimeTypes().isEmpty()\n        && !getMimeTypes().contains(primaryType)\n        && !getMimeTypes().contains(mimeType)) {\n      return false;\n    }\n\n    String filePath = resource.getUrl();\n\n    if (getAcceptedExtensions() != null) {\n      // check extension\n      for (Iterator i = getAcceptedExtensions().iterator(); i.hasNext(); ) {\n        if (filePath.endsWith(\".\" + i.next().toString().toLowerCase())) {\n          return true;\n        }\n      }\n\n      return false;\n    } else {\n      return true;\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8768, "initialization": ["String string = Map<String, String>.remove(String)"], "initializationStart": [86], "initializationEnd": [111], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null)", "guardType": "IF {", "guardExpressionStart": 118, "guardExpressionEnd": 140, "guardBlockStart": 118, "guardBlockEnd": 231, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 197, "focalAPIEnd": 224, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/webx/citrus/tree/master/common/logconfig/src/main/java/com/alibaba/citrus/logconfig/LogConfiguratorListener.java", "rawCode": "  private String[] getLogSystems(Map<String, String> params) {\n    String logSystem = params.remove(LOG_SYSTEM);\n\n    if (logSystem == null) {\n      return new String[0];\n    } else {\n      return logSystem.split(\"(,|\\\\s)+\");\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8769, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 87, "focalAPIEnd": 109, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["newArrayList(strArray)"], "useStart": [136], "useEnd": [165], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/illyfrancis/bogo/tree/master/api/src/main/java/com/bbh/openbbh/api/dao/Country.java", "rawCode": "  public static List<Model> findByCodes(String codesString) {\n    String[] codeArray = codesString.split(\",\");\n    List<String> codes = Lists.newArrayList(codeArray);\n    return newArrayList(country.find(\"{code: { $in : # }}\", codes).as(Model.class));\n  }\n"}, {"dataset": "split", "exampleID": 8770, "initialization": ["String string = String.substring(int)", "String string = String.substring(int)"], "initializationStart": [1019, 1151], "initializationEnd": [1052, 1171], "hasTryCatch": 1, "exceptionType": "PathNotFoundException", "exceptionHandlingCall": ["getMessage()", "Log.debug(String)"], "tryExpressionStart": 371, "tryExpressionEnd": 375, "tryBlockStart": 371, "tryBlockEnd": 4018, "catchExpressionStart": 1994, "catchExpressionEnd": 2029, "catchBlockStart": 1994, "catchBlockEnd": 3320, "exceptionHandlingCallStart": [2092, 2067], "exceptionHandlingCallEnd": [2109, 2116], "configuration": ["string.substring(int)"], "configurationStart": [1151], "configurationEnd": [1171], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1212, "focalAPIEnd": 1230, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 1334, "followUpCheckExpressionEnd": 1368, "followUpCheckBlockStart": 1334, "followUpCheckBlockEnd": 1434, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/KNL-276/kernel-impl-experimental/content/jcr/sakai-content-jcr-impl/src/main/java/org/sakaiproject/content/impl/BaseJCRStorage.java", "rawCode": "  /**\n   * Create a new node. Nodes are of the form nt:folder/nt:folder/nt:folder/nt:file nt:folders have\n   * properties nt:files have properties nt:files have a nt:resource subnode\n   *\n   * @param id\n   * @param collection\n   * @return\n   * @throws TypeException\n   */\n  private Node createNode(String id, String type) throws TypeException {\n    Node node = null;\n    try {\n      String absPath = m_user.convertId2Storage(id);\n      Session s = jcrService.getSession();\n      Node n = getNodeFromSession(s, absPath);\n      // the node might already exist\n      if (n != null) {\n        return n;\n      }\n\n      String vpath = getParentPath(absPath);\n      while (n == null && !\"/\".equals(vpath)) {\n        n = getNodeFromSession(s, vpath);\n        if (n == null) {\n          vpath = getParentPath(vpath);\n        } else {\n          log.debug(\"Got Path \" + vpath + \" as \" + n);\n        }\n      }\n      if (n == null) {\n        n = s.getRootNode();\n      }\n      log.debug(\"VPath is \" + vpath);\n      String relPath = absPath.substring(vpath.length());\n      // Node rootNode = s.getRootNode();\n      if (relPath.startsWith(\"/\")) {\n        relPath = relPath.substring(1);\n      }\n\n      String[] pathElements = relPath.split(\"/\");\n      log.debug(\"RelPath is \" + relPath + \" split into \" + pathElements.length + \" elements \");\n      for (String pathel : pathElements) {\n        log.debug(\" Path Element is [\" + pathel + \"]\");\n      }\n\n      Node currentNode = n;\n      for (int i = 0; i < pathElements.length; i++) {\n        try {\n          log.debug(\"Getting \" + pathElements[i] + \" under \" + currentNode);\n          currentNode = currentNode.getNode(pathElements[i]);\n          if (!currentNode.isNodeType(JCRConstants.NT_FOLDER)\n              && !currentNode.isNodeType(JCRConstants.NT_BASE)) {\n            throw new TypeException(\n                \"Cant create collection or a folder inside a node that is not a folder \"\n                    + currentNode.getPath());\n          }\n\n        } catch (PathNotFoundException pnfe) {\n          if (log.isDebugEnabled()) log.debug(\"Not Found \" + pnfe.getMessage() + \" \");\n          if (i < pathElements.length - 1 || JCRConstants.NT_FOLDER.equals(type)) {\n            if (log.isDebugEnabled())\n              log.debug(\n                  \"Adding Node \"\n                      + pathElements[i]\n                      + \" as \"\n                      + type\n                      + \" to \"\n                      + currentNode.getPath());\n            Node newNode = currentNode.addNode(pathElements[i], JCRConstants.NT_FOLDER);\n            populateFolder(newNode);\n            currentNode.save();\n            currentNode = newNode;\n            if (log.isDebugEnabled()) log.debug(\"Adding Node Complete\");\n          } else {\n            if (log.isDebugEnabled())\n              log.debug(\n                  \"Adding Node \"\n                      + pathElements[i]\n                      + \" as \"\n                      + type\n                      + \" to \"\n                      + currentNode.getPath());\n            Node newNode = currentNode.addNode(pathElements[i], JCRConstants.NT_FILE);\n            populateFile(newNode);\n            currentNode.save();\n            currentNode = newNode;\n            if (log.isDebugEnabled()) log.debug(\"Adding Node Complete\");\n          }\n        }\n        if (currentNode.isCheckedOut()) {\n          currentNode.save();\n        }\n      }\n      node = currentNode;\n      if (node == null) {\n        log.error(\"Failed to create Node \" + absPath + \" got \" + node);\n        throw new Error(\"Failed to create node \" + absPath + \" got \" + node);\n      } else if (!absPath.equals(node.getPath())) {\n\n        log.error(\"Failed to create Node \" + absPath + \" got\" + node.getPath());\n        throw new Error(\"Failed to create node \" + absPath + \" got \" + node.getPath());\n      }\n\n    } catch (RepositoryException rex) {\n      log.warn(\"Unspecified Repository Failiure \", rex);\n      log.error(\"Unspecified Repository Failiure \" + rex.getMessage());\n    }\n    return node;\n  }\n"}, {"dataset": "split", "exampleID": 8771, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 2340, "focalAPIEnd": 2356, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["lineWidth(strArray,Font)", "Graphics2D.drawString(string,int,int)"], "useStart": [2330, 3604], "useEnd": [2363, 3649], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mdb92nc/STAR-Vote/tree/master/preptool/model/layout/manager/RenderingUtils.java", "rawCode": "  /**\n   * Renders a ToggleButton and returns it as a BufferedImage. ToggleButton does not wrap unless\n   * indicated to do so with \\n. Also if two names are used the second name appears at an offset.\n   * And since this is a ToggleButton a box and possible check mark in the box are added\n   *\n   * @param text is the text of the ToggleButton\n   * @param text2 is the second text of the toggle button added on a second line and indented\n   * @param party is the party of the candidate in the toggle button, right aligned on first line of\n   *     button\n   * @param fontsize the size of the font\n   * @param wrappingWidth is not used\n   * @param bold whether the button is bold\n   * @param selected is whether or not the toggleButton should have a check mark in its box\n   * @return the rendered ToggleButton\n   */\n  public static BufferedImage renderToggleButton(\n      String text,\n      String text2,\n      String party,\n      int fontsize,\n      int wrappingWidth,\n      boolean bold,\n      boolean selected,\n      boolean focused) {\n\n    /* This is the standard font we use, so we can size the button with respect to the text */\n    Font font = new Font(FONT_NAME, (bold) ? Font.BOLD : Font.PLAIN, fontsize);\n\n    /* box character */\n    String box = \"\\u25a1\";\n\n    /* check mark character */\n    String filledSelection = \"\\u2713\";\n\n    /* This is the image that we will draw the button on to */\n    BufferedImage wrappedImage = new BufferedImage(1000, 1000, BufferedImage.TYPE_INT_ARGB);\n\n    /* Get the graphics off our image and set is font and aliasing information */\n    Graphics2D graphs = wrappedImage.createGraphics();\n    graphs.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    graphs.setFont(font);\n\n    /* Find the baseline for the text that will be drawn on the button */\n    int baseline = graphs.getFontMetrics().getAscent();\n\n    /* This is how much whitespace there will be between the text and the edge of the button */\n    int padding = 10;\n\n    /* This is the location of the top side of the bounding box for the text */\n    int heightPos = padding + baseline;\n\n    /* The positioning of the check box on every button, right justified */\n    int boxPos = wrappingWidth - 30;\n\n    /* The length of the party to be displayed for this button */\n    int partyLength = lineWidth(party.split(\" \"), font);\n\n    /* The position of the party text, right justified next to the checkbox */\n    int partyPos = boxPos - 10 - partyLength;\n\n    /* Set and draw the background color if the button is focused */\n    if (focused) {\n      graphs.setColor(Color.ORANGE);\n      graphs.fillRect(0, 0, wrappedImage.getWidth(), wrappedImage.getHeight());\n    }\n\n    /* Set the font color to black for drawing text */\n    graphs.setColor(Color.BLACK);\n\n    /* Draw the text for the button */\n    graphs.drawString(text, padding, heightPos);\n\n    /* Draw the checkbox on the button */\n    graphs.drawString(box, boxPos, heightPos);\n\n    /* If the button is selected, fill the checkbox with a green check */\n    if (selected) {\n\n      /* Set the check's font */\n      Font checkFont =\n          new Font(FONT_NAME, Font.PLAIN, (int) (fontsize - 4 + ((fontsize - 4) * 1.1)));\n      graphs.setFont(checkFont);\n\n      /* Set the color of the check to green */\n      graphs.setColor(new Color(0, 165, 80));\n\n      /* Draw the box and reset the font and draw colors */\n      graphs.drawString(filledSelection, boxPos, heightPos);\n      graphs.setFont(font);\n      graphs.setColor(Color.BLACK);\n    }\n\n    /* If there is a party, draw it on */\n    if (!party.equals(\"\")) graphs.drawString(party, partyPos, heightPos);\n\n    /* If there is secondary text, i.e. this is a presidential race, draw it */\n    if (!text2.equals(\"\")) {\n      /* Update the height to account for the second name */\n      heightPos += lineHeight(text, font);\n\n      /* Tab over the second candidate's name */\n      graphs.drawString(\" \" + text2, padding, heightPos);\n    }\n\n    /* Ensure the font color is black, and then set a thicker stroke to border the button */\n    graphs.setColor(Color.BLACK);\n    graphs.setStroke(new BasicStroke(padding / 2));\n\n    /* start this rectangle off the top of our visible area so we don't see the top border */\n    graphs.drawRect(0, -padding, wrappingWidth - 1, heightPos + 2 * padding - 1);\n\n    /* Wrap the image to the correct size */\n    wrappedImage = wrappedImage.getSubimage(0, 0, wrappingWidth, heightPos + padding);\n\n    /* I think this copies to avoid aliasing or something. TODO Figure this out */\n    return copy(wrappedImage);\n  }\n"}, {"dataset": "split", "exampleID": 8772, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1010, "focalAPIEnd": 1029, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 1035, "followUpCheckExpressionEnd": 1062, "followUpCheckBlockStart": 1035, "followUpCheckBlockEnd": 1534, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Bhasmithal/Modular-PircBot/tree/master/modular-pircbot-modules/src/main/java/org/pircbotx/util/PropertiesUtils.java", "rawCode": "  /**\n   * Builds a list containing integers and ranges of integers, read from a property having the\n   * following format: \"<tt>{exp}, {exp}, {exp}, ...</tt> \".\n   *\n   * <p>An expression (<tt>{exp}</tt>) can be:\n   *\n   * <ul>\n   *   <li>A single integer. This value will be added to the returned list.\n   *   <li>A range, having the following format: \"<tt>{min}-{max}</tt>\". All values between the\n   *       <tt>{min}</tt> and <tt>{max}</tt> values are inserted in the list.\n   * </ul>\n   *\n   * <p>For example, if the property is equal to \"<tt>3, 10-14, 91</tt>\", the returned list will\n   * contain 7 elements: <tt>[3, 10, 11, 12, 13, 14, 91]</tt>.\n   *\n   * @param property the property to read as a list of integer expressions\n   * @return a list of integers as described above\n   * @throws NumberFormatException if integers cannot be read from the property\n   */\n  public static List<Integer> getIntList(String property) {\n    List<Integer> integers = new ArrayList<Integer>();\n\n    String[] values = property.split(\",\");\n    for (String value : values) {\n      if (value.contains(\"-\")) {\n        String[] boundaries = value.split(\"-\");\n        int i1 = Integer.parseInt(boundaries[0]);\n        int i2 = Integer.parseInt(boundaries[1]);\n\n        // Now add all values between boundaries, including\n        int min = Math.min(i1, i2);\n        int max = Math.max(i1, i2);\n        for (int i = min; i <= max; i++) {\n          integers.add(i);\n        }\n      } else {\n        integers.add(Integer.parseInt(value));\n      }\n    }\n    return integers;\n  }\n"}, {"dataset": "split", "exampleID": 8773, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 30, "tryExpressionEnd": 34, "tryBlockStart": 30, "tryBlockEnd": 973, "catchExpressionStart": 880, "catchExpressionEnd": 900, "catchBlockStart": 880, "catchBlockEnd": 938, "exceptionHandlingCallStart": [910], "exceptionHandlingCallEnd": [929], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(string)!=null", "guardType": "LOOP {", "guardExpressionStart": 207, "guardExpressionEnd": 247, "guardBlockStart": 207, "guardBlockEnd": 871, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 288, "focalAPIEnd": 305, "followUpCheck": "strArray.length != 5", "checkType": "IF", "followUpCheckExpressionStart": 317, "followUpCheckExpressionEnd": 350, "followUpCheckBlockStart": 317, "followUpCheckBlockEnd": 484, "use": ["new IOException(string)"], "useStart": [448], "useEnd": [471], "hasFinally": 1, "cleanUpCall": ["close()"], "finallyExpressionStart": 939, "finallyExpressionEnd": 947, "finallyBlockStart": 939, "finallyBlockEnd": 973, "cleanUpCallStart": [957], "cleanUpCallEnd": [964], "url": "https://github.com/wangyif2/4d19/tree/master/Lab4/src/zookeeper/src/java/systest/org/apache/zookeeper/test/system/GenerateLoad.java", "rawCode": "    public void run() {\n      try {\n        System.out.println(\"Connected to \" + s);\n        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));\n        String result;\n        while ((result = is.readLine()) != null) {\n          String timePercentCount[] = result.split(\" \");\n          if (timePercentCount.length != 5) {\n            System.err.println(\"Got \" + result + \" from \" + s + \" exitng.\");\n            throw new IOException(result);\n          }\n          long time = Long.parseLong(timePercentCount[0]);\n          // int percent = Integer.parseInt(timePercentCount[1]);\n          int count = Integer.parseInt(timePercentCount[2]);\n          int errs = Integer.parseInt(timePercentCount[3]);\n          if (errs > 0) {\n            System.out.println(s + \" Got an error! \" + errs);\n          }\n          add(time, count, s);\n        }\n      } catch (Exception e) {\n        e.printStackTrace();\n      } finally {\n        close();\n      }\n    }\n"}, {"dataset": "split", "exampleID": 8774, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 74, "focalAPIEnd": 95, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 101, "followUpCheckExpressionEnd": 132, "followUpCheckBlockStart": 101, "followUpCheckBlockEnd": 474, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/commoncrawl/commoncrawl-crawler/tree/master/src/org/commoncrawl/service/pagerank/slave/PageRankSlaveServer.java", "rawCode": "  private void parseSlavesList(String slavesList) {\n    String slaves[] = slavesList.split(\",\");\n    for (String slaveName : slaves) {\n      String nameParts[] = slaveName.split(\":\");\n      _slaveAddresses.add(new InetSocketAddress(nameParts[0], Integer.parseInt(nameParts[1])));\n      LOG.info(\n          \"Slave At Index:\"\n              + (_slaveAddresses.size() - 1)\n              + \" is:\"\n              + _slaveAddresses.get(_slaveAddresses.size() - 1).toString());\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8775, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 356, "tryExpressionEnd": 360, "tryBlockStart": 356, "tryBlockEnd": 1744, "catchExpressionStart": 1551, "catchExpressionEnd": 1573, "catchBlockStart": 1551, "catchBlockEnd": 1607, "exceptionHandlingCallStart": [1581], "exceptionHandlingCallEnd": [1600], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 602, "focalAPIEnd": 634, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1608, "finallyExpressionEnd": 1616, "finallyBlockStart": 1608, "finallyBlockEnd": 1744, "cleanUpCallStart": [1529], "cleanUpCallEnd": [1543], "url": "https://github.com/wjcquking/fuzzyJoin/tree/master/WordCount/src/org/macau/local/sample/SpatialBlackBoxWR2.java", "rawCode": "  /**\n   * @param fileName\n   * @return statistic of the data Using the Account as the weight\n   */\n  public static Map<Integer, List<FlickrData>> getTextualListData(String fileName) {\n\n    File file = new File(fileName);\n\n    BufferedReader reader = null;\n\n    Map<Integer, List<FlickrData>> textualWeight = new HashMap<Integer, List<FlickrData>>();\n\n    try {\n      reader = new BufferedReader(new FileReader(file));\n      String tempString = null;\n      int line = 1;\n\n      // Read One line one time until the null\n      while ((tempString = reader.readLine()) != null) {\n\n        String textual = tempString.toString().split(\":\")[5];\n\n        System.out.println(line);\n        if (!textual.equals(\"null\")) {\n\n          String[] textualList = textual.split(\";\");\n\n          FlickrData fd = FlickrSimilarityUtil.getFlickrDataFromString(tempString);\n          // get the prefix values\n          int prefixLength =\n              SimilarityUtil.getPrefixLength(\n                  textualList.length, FlickrSimilarityUtil.TEXTUAL_THRESHOLD);\n\n          for (int i = 0; i < prefixLength; i++) {\n\n            Integer tokenID = Integer.parseInt(textualList[i]);\n\n            if (textualWeight.containsKey(tokenID)) {\n\n              textualWeight.get(tokenID).add(fd);\n\n            } else {\n\n              List<FlickrData> recordList = new ArrayList<FlickrData>();\n              recordList.add(fd);\n              textualWeight.put(new Integer(tokenID), recordList);\n            }\n          }\n        }\n\n        line++;\n      }\n\n      reader.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    } finally {\n      if (reader != null) {\n        try {\n          reader.close();\n        } catch (IOException e1) {\n        }\n      }\n    }\n    return textualWeight;\n  }\n"}, {"dataset": "split", "exampleID": 8776, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 111, "focalAPIEnd": 126, "followUpCheck": "strArray.length > 1", "checkType": "IF", "followUpCheckExpressionStart": 134, "followUpCheckExpressionEnd": 152, "followUpCheckBlockStart": 134, "followUpCheckBlockEnd": 404, "use": ["new LabelAndValue(string)"], "useStart": [372], "useEnd": [395], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/akjava/akjava_gwtlib/tree/master/src/com/akjava/lib/common/functions/LabelAndValueDto.java", "rawCode": "    @Override\n    public LabelAndValue apply(String text) {\n      LabelAndValue lv = null;\n      String[] vs = text.split(\":\");\n      if (vs.length > 1) {\n        if (vs.length > 2) {\n          lv = new LabelAndValue(vs[0], vs[1], ValuesUtils.toBoolean(vs[2], false));\n        } else {\n          lv = new LabelAndValue(vs[0], vs[1]);\n        }\n      } else {\n        lv = new LabelAndValue(text);\n      }\n\n      return lv;\n    }\n"}, {"dataset": "split", "exampleID": 8777, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 260, "focalAPIEnd": 275, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 330, "followUpCheckExpressionEnd": 353, "followUpCheckBlockStart": 330, "followUpCheckBlockEnd": 380, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apps4av/avare/tree/master/app/src/main/java/com/ds/avare/utils/FolderPreference.java", "rawCode": "  /** @param path */\n  private void init(String path) {\n    if (path.length() == 0) {\n      path = \"/\";\n    }\n    if (path.equals(\"/\")) {\n      mFirstLevel = true;\n    } else {\n      mFirstLevel = false;\n    }\n    mPath = new File(path);\n    String tokens[] = path.split(\"/\");\n    mStr = new ArrayList<String>(tokens.length);\n    for (String s : tokens) {\n      mStr.add(s);\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8778, "initialization": ["String string = HttpClient.getSetCookieHeader()"], "initializationStart": [2464], "initializationEnd": [2495], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 2581, "focalAPIEnd": 2598, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 2638, "followUpCheckExpressionEnd": 2661, "followUpCheckBlockStart": 2638, "followUpCheckBlockEnd": 2864, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jbossas/console/tree/master/gui/src/main/java/org/jboss/as/console/server/proxy/XmlHttpProxy.java", "rawCode": "  /**\n   * This method will go out and make the call and it will apply an XSLT Transformation with the set\n   * of parameters provided.\n   *\n   * @param urlString - The URL which you are looking up\n   * @param out - The OutputStream to which the resulting document is written\n   * @param xslInputStream - An input Stream to an XSL style sheet that is provided to the XSLT\n   *     processor. If set to null there will be no transformation\n   * @param paramsMap - A Map of parameters that are feed to the XSLT Processor. These params may be\n   *     used when generating content. This may be set to null if no parameters are necessary.\n   * @param method - the HTTP method used.\n   * @param postData - A String of the bodyContent to be posted. A doPost will be used if this is\n   *     parameter is not null.\n   * @param postContentType - The request contentType used when posting data. Will not be set if\n   *     this parameter is null.\n   * @param userName - userName used for basic authorization\n   * @param password - password used for basic authorization\n   */\n  public void doProcess(\n      String urlString,\n      OutputStream out,\n      InputStream xslInputStream,\n      Map paramsMap,\n      Map headers,\n      String method,\n      byte[] postData,\n      String postContentType,\n      String userName,\n      String password)\n      throws IOException, MalformedURLException {\n\n    if (paramsMap == null) {\n      paramsMap = new HashMap();\n    }\n\n    String format = (String) paramsMap.get(\"format\");\n    if (format == null) {\n      format = \"xml\";\n    }\n\n    InputStream in = null;\n    BufferedOutputStream os = null;\n\n    HttpClient httpclient = null;\n\n    CookieCallback callback =\n        new CookieCallback() {\n\n          public Map<String, Cookie> getCookies() {\n            return accessCookies();\n          }\n        };\n\n    if (userName != null && password != null) {\n      httpclient =\n          new HttpClient(\n              proxyHost, proxyPort, urlString, headers, method, userName, password, callback);\n    } else {\n      httpclient = new HttpClient(proxyHost, proxyPort, urlString, headers, method, callback);\n    }\n\n    // post data determines whether we are going to do a get or a post\n    if (postData == null) {\n      in = httpclient.getInputStream();\n    } else {\n      in = httpclient.doPost(postData, postContentType, authHeader);\n    }\n\n    // Set-Cookie header\n    if (httpclient.getSetCookieHeader() != null) {\n      String cookie = httpclient.getSetCookieHeader();\n      System.out.println(\"'Set-Cookie' header: \" + cookie);\n      String[] values = cookie.split(\";\");\n\n      Cookie c = new Cookie();\n      for (String v : values) {\n        String[] tuple = v.split(\"=\");\n        if (\"Path\".equals(tuple[0].trim())) c.path = tuple[1];\n        else {\n          c.name = tuple[0].trim();\n          c.value = tuple[1];\n        }\n      }\n\n      List<String> toBeRemoved = new ArrayList<String>();\n      Iterator it = cookies.keySet().iterator();\n      while (it.hasNext()) {\n        Cookie exists = cookies.get(it.next());\n        if (exists.name.equals(c.name)) {\n          String msg =\n              exists.value.equals(c.value)\n                  ? \"Replace with same value: \" + exists.value\n                  : \"Replace with different value: \" + exists.value + \"->\" + c.value;\n\n          System.out.println(\"Cookie '\" + exists.name + \"' exists: \" + msg);\n          // avoid doubles\n          toBeRemoved.add(exists.name);\n        }\n      }\n\n      // clean up\n      for (String s : toBeRemoved) {\n        cookies.remove(s);\n      }\n\n      cookies.put(c.name, c);\n    }\n\n    int responseCode = httpclient.getResponseCode();\n    if (responseCode != 200) {\n      if (401 == responseCode || 403 == responseCode) {\n        // authentication required\n        throw new AuthenticationException(responseCode, httpclient.getHeader(\"WWW-Authenticate\"));\n      } else if (307 == responseCode) {\n        // redirect\n        throw new RedirectException(httpclient.getHeader(\"Location\"));\n      } else if (503 == responseCode) {\n        // service unavailable\n        throw new ServiceUnavailableException(httpclient.getHeader(\"Retry-After\"));\n      } else {\n        throw new IOException(\"Failed to open input stream, status: \" + responseCode);\n      }\n    }\n\n    // read the encoding from the incoming document and default to UTF-8\n    // if an encoding is not provided\n    String ce = httpclient.getContentEncoding();\n    if (ce == null) {\n      String ct = httpclient.getContentType();\n      if (ct != null) {\n        int idx = ct.lastIndexOf(\"charset=\");\n        if (idx >= 0) {\n          ce = ct.substring(idx + 8);\n        } else {\n          ce = \"UTF-8\";\n        }\n      } else {\n        ce = \"UTF-8\";\n      }\n    }\n    // get the content type\n    this.contentType = httpclient.getContentType();\n    this.status = httpclient.getResponseCode();\n\n    // write out the content type\n    // http://www.ietf.org/rfc/rfc4627.txt\n\n    try {\n\n      // response stream\n\n      byte[] buffer = new byte[1024];\n      int read = 0;\n      if (xslInputStream == null) {\n        while (true) {\n          read = in.read(buffer);\n          if (read <= 0) break;\n          out.write(buffer, 0, read);\n        }\n      } else {\n        transform(in, xslInputStream, paramsMap, out, ce);\n      }\n    } catch (Exception e) {\n      getLogger().severe(\"XmlHttpProxy transformation error: \" + e);\n    } finally {\n      try {\n        if (in != null) {\n          in.close();\n        }\n        if (out != null) {\n          out.flush();\n          out.close();\n        }\n      } catch (Exception e) {\n        // do nothing\n      }\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8779, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 204, "focalAPIEnd": 230, "followUpCheck": "strArray[0].equals(\"deploy-pu\")", "checkType": "IF", "followUpCheckExpressionStart": 236, "followUpCheckExpressionEnd": 276, "followUpCheckBlockStart": 236, "followUpCheckBlockEnd": 1242, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CloudifySource/Cloudify-iTests/tree/master/src/main/java/org/cloudifysource/quality/iTests/test/cli/cloudify/cloud/ec2/examples/Ec2XAP9xApplicationTest.java", "rawCode": "  private void validateInstance(String lookuplocators, String deploypuCommand) throws Exception {\n    String gridname;\n    String partitions, backups, maxPerVM, maxPerMachine;\n    String[] deployCmdArr = deploypuCommand.split(\" \");\n    if (deployCmdArr[0].equals(\"deploy-pu\")) {\n      gridname = deployCmdArr[1];\n      partitions = deployCmdArr[4];\n      backups = deployCmdArr[5];\n      maxPerVM = deployCmdArr[6];\n      maxPerMachine = deployCmdArr[7];\n    } else if (deployCmdArr[0].equals(\"deploy-grid\")) {\n      gridname = deployCmdArr[1];\n      partitions = deployCmdArr[3];\n      backups = deployCmdArr[4];\n      maxPerVM = deployCmdArr[5];\n      maxPerMachine = deployCmdArr[6];\n    } else if (deployCmdArr[0].equals(\"deploy-pu-basic\")) {\n      File file = new File(PUURL);\n      gridname = file.getName();\n      partitions = \"1\";\n      backups = \"0\";\n      maxPerVM = \"1\";\n      maxPerMachine = \"1\";\n    } else if (deployCmdArr[0].equals(\"deploy-grid-basic\")) {\n      gridname = deployCmdArr[1];\n      partitions = \"1\";\n      backups = \"1\";\n      maxPerVM = \"0\";\n      maxPerMachine = \"0\";\n    } else {\n      throw new Exception(\n          \"Unknown command. Please recheck the command or add it to validateInstance function.\");\n    }\n    InvokeServiceCommandResponse response;\n    InvocationResult result;\n    String appName = \"default\";\n    String numOfInstances =\n        String.valueOf(Integer.valueOf(partitions) * (1 + Integer.valueOf(backups)));\n\n    response =\n        customCommand(\n            \"get-datagrid-instances \" + gridname + \" \" + lookuplocators + \" \" + numOfInstances,\n            SG_VALIDATOR,\n            appName);\n    result = getCustomCommandResult(response);\n    Assert.assertEquals(result.getInvocationStatus(), CloudifyConstants.InvocationStatus.SUCCESS);\n    Assert.assertEquals(result.getResult(), numOfInstances);\n\n    response =\n        customCommand(\n            \"get-datagrid-deploymentstatus \"\n                + gridname\n                + \" \"\n                + lookuplocators\n                + \" \"\n                + numOfInstances,\n            SG_VALIDATOR,\n            appName);\n    result = getCustomCommandResult(response);\n    Assert.assertEquals(result.getInvocationStatus(), CloudifyConstants.InvocationStatus.SUCCESS);\n    Assert.assertEquals(result.getResult(), String.valueOf(DeploymentStatus.INTACT));\n\n    response =\n        customCommand(\n            \"get-datagrid-partitions \" + gridname + \" \" + lookuplocators + \" \" + numOfInstances,\n            SG_VALIDATOR,\n            appName);\n    result = getCustomCommandResult(response);\n    Assert.assertEquals(result.getInvocationStatus(), CloudifyConstants.InvocationStatus.SUCCESS);\n    Assert.assertEquals(result.getResult(), partitions);\n\n    response =\n        customCommand(\n            \"get-datagrid-backups \" + gridname + \" \" + lookuplocators + \" \" + numOfInstances,\n            SG_VALIDATOR,\n            appName);\n    result = getCustomCommandResult(response);\n    Assert.assertEquals(result.getInvocationStatus(), CloudifyConstants.InvocationStatus.SUCCESS);\n    Assert.assertEquals(result.getResult(), backups);\n\n    response =\n        customCommand(\n            \"get-datagrid-maxinstancespermachine \"\n                + gridname\n                + \" \"\n                + lookuplocators\n                + \" \"\n                + numOfInstances,\n            SG_VALIDATOR,\n            appName);\n    result = getCustomCommandResult(response);\n    Assert.assertEquals(result.getInvocationStatus(), CloudifyConstants.InvocationStatus.SUCCESS);\n    Assert.assertEquals(result.getResult(), maxPerMachine);\n\n    response =\n        customCommand(\n            \"get-datagrid-maxinstancespervm \"\n                + gridname\n                + \" \"\n                + lookuplocators\n                + \" \"\n                + numOfInstances,\n            SG_VALIDATOR,\n            appName);\n    result = getCustomCommandResult(response);\n    Assert.assertEquals(result.getInvocationStatus(), CloudifyConstants.InvocationStatus.SUCCESS);\n    Assert.assertEquals(result.getResult(), maxPerVM);\n  }\n"}, {"dataset": "split", "exampleID": 8780, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 380, "tryExpressionEnd": 384, "tryBlockStart": 380, "tryBlockEnd": 1195, "catchExpressionStart": 1039, "catchExpressionEnd": 1059, "catchBlockStart": 1039, "catchBlockEnd": 1093, "exceptionHandlingCallStart": [1067], "exceptionHandlingCallEnd": [1086], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(string)!=null", "guardType": "LOOP {", "guardExpressionStart": 566, "guardExpressionEnd": 613, "guardBlockStart": 566, "guardBlockEnd": 1032, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1003, "focalAPIEnd": 1022, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["processMDSequence(strArray)"], "useStart": [985], "useEnd": [1023], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1094, "finallyExpressionEnd": 1102, "finallyBlockStart": 1094, "finallyBlockEnd": 1195, "cleanUpCallStart": [1165], "cleanUpCallEnd": [1180], "url": "https://github.com/hdc1112/misc-program/tree/master/java/Eclipse-workspace/spmf/src/ca/pfv/spmf/algorithms/sequentialpatterns/fournier2008_seqdim/multidimensionalsequentialpatterns/MDSequenceDatabase.java", "rawCode": "  /**\n   * Load a MD-Sequence database from a file\n   *\n   * @param path the path of the file\n   * @throws IOException exception if error reading the file\n   */\n  public void loadFile(String path) throws IOException {\n    // It read the file line by line\n    // Each line is a md-sequence except lines starting with #.\n\n    String thisLine;\n    BufferedReader myInput = null;\n    try {\n      FileInputStream fin = new FileInputStream(new File(path));\n      myInput = new BufferedReader(new InputStreamReader(fin));\n      // for each line until the end of file\n      while ((thisLine = myInput.readLine()) != null) {\n        // if the line is a comment, is empty or is a\n        // kind of metadata\n        if (thisLine.isEmpty() == true\n            || thisLine.charAt(0) == '#'\n            || thisLine.charAt(0) == '%'\n            || thisLine.charAt(0) == '@') {\n          continue;\n        }\n\n        // split the MDsequence into tokens\n        // and process this MDsequence\n        processMDSequence(thisLine.split(\" \"));\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      // close the file\n      if (myInput != null) {\n        myInput.close();\n      }\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8781, "initialization": ["String string = get(*)"], "initializationStart": [78], "initializationEnd": [110], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null", "guardType": "IF {", "guardExpressionStart": 165, "guardExpressionEnd": 185, "guardBlockStart": 165, "guardBlockEnd": 908, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 248, "focalAPIEnd": 266, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["asList(strArray)"], "useStart": [234], "useEnd": [267], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mwoodbri/MRIdb/tree/master/app/jobs/ClipboardExporter.java", "rawCode": "  public static List<File> getExports(Session session) {\n    String exports = session.get(Application.EXPORTS);\n    List<File> archives = new ArrayList<File>();\n    if (exports != null) {\n      List<String> exportList = new ArrayList(Arrays.asList(exports.split(\",\")));\n      for (Iterator<String> i = exportList.iterator(); i.hasNext(); ) {\n        String export = i.next();\n        File tmpDir = new File(Properties.getDownloads(), export.split(\":\")[0]);\n        if (tmpDir.exists()) {\n          archives.add(\n              new File(\n                  new File(Properties.getExports(), export.split(\":\")[1].split(\"-\")[0]),\n                  export.split(\":\")[1]));\n        } else {\n          i.remove();\n        }\n      }\n      if (exportList.isEmpty()) {\n        session.remove(Application.EXPORTS);\n      } else {\n        session.put(Application.EXPORTS, StringUtils.join(exportList, \",\"));\n      }\n    }\n    return archives;\n  }\n"}, {"dataset": "split", "exampleID": 8782, "initialization": ["String string = get(String,Scriptable)"], "initializationStart": [224], "initializationEnd": [257], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null", "guardType": "IF {", "guardExpressionStart": 478, "guardExpressionEnd": 502, "guardBlockStart": 478, "guardBlockEnd": 759, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 539, "focalAPIEnd": 565, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 614, "followUpCheckExpressionEnd": 650, "followUpCheckBlockStart": 614, "followUpCheckBlockEnd": 753, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/suvajitgupta/Tasks/tree/master/persevere/WEB-INF/src/org/persvr/datasource/HttpJsonSource.java", "rawCode": "  private void handleRemoteSchema(Scriptable xhr, String url) {\n    url = getId() + '/' + url;\n    String tableUrl = url.substring(0, url.lastIndexOf('/'));\n\n    String contentType =\n        (String)\n            ((Function) xhr.get(\"getResponseHeader\", xhr))\n                .call(\n                    PersevereContextFactory.getContext(),\n                    global,\n                    xhr,\n                    new Object[] {\"Content-Type\"});\n    String schemaUrl = null;\n    if (contentType != null) {\n      String[] contentTypeParts = contentType.split(\";\\\\s*\");\n      contentType = contentTypeParts[0];\n      for (String part : contentTypeParts) {\n        if (part.startsWith(\"schema\")) {\n          schemaUrl = part.split(\"=\")[1];\n        }\n      }\n    }\n    if (schemaUrl != null) {\n      if (DataSourceManager.getSource(tableUrl) == null && loadingSources.get(tableUrl) == null) {\n        loadingSources.put(tableUrl, true);\n        Persistable schemaForData =\n            (Persistable) Identification.idForRelativeString(url, schemaUrl).getTarget();\n        // use a transaction to make the class not really run\n        PersistableClass classForData = new PersistableClass();\n        classForData.persist = false;\n        for (Map.Entry<String, Object> entry : schemaForData.entrySet(0)) {\n          classForData.put(entry.getKey(), classForData, entry.getValue());\n        }\n        try {\n          Map config = new HashMap();\n          config.put(\"name\", tableUrl);\n          config.put(\"sourceClass\", getClass().getName());\n          config.put(\"hidden\", true);\n          DataSourceManager.initSource(config, null, classForData, \"\");\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8783, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 328, "focalAPIEnd": 345, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 351, "followUpCheckExpressionEnd": 382, "followUpCheckBlockStart": 351, "followUpCheckBlockEnd": 669, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.8/kernel-impl/src/main/java/org/sakaiproject/memory/impl/CacheInitializer.java", "rawCode": "  /**\n   * Set the configuration that needs to be set on the cache.\n   *\n   * @param config The unsplit configuration. Eg: \"timeToLiveSeconds=400,timeToIdleSeconds=100\"\n   * @return This object.\n   */\n  public CacheInitializer configure(String config) {\n    configMap = new HashMap<String, String>();\n    String[] configParts = config.split(\",\");\n    for (String part : configParts) {\n      String[] splitParts = part.split(\"=\", 2);\n      if (splitParts.length == 2) {\n        String key = splitParts[0];\n        String value = splitParts[1];\n        configMap.put(key, value);\n      } else {\n        M_log.warn(\"Couldn't parse cache config of: \" + part);\n      }\n    }\n    return this;\n  }\n"}, {"dataset": "split", "exampleID": 8784, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 393, "focalAPIEnd": 409, "followUpCheck": "i < strArray.length", "checkType": "LOOP", "followUpCheckExpressionStart": 461, "followUpCheckExpressionEnd": 499, "followUpCheckBlockStart": 461, "followUpCheckBlockEnd": 692, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/scudderfish/MSLoggerBase/tree/master/MSLogger/src_chart/uk/org/smithfamily/mslogger/chart/chart/AbstractChart.java", "rawCode": "  /**\n   * Draw a multiple lines string.\n   *\n   * @param canvas the canvas to paint to\n   * @param text the text to be painted\n   * @param x the x value of the area to draw to\n   * @param y the y value of the area to draw to\n   * @param paint the paint to be used for drawing\n   */\n  protected void drawString(Canvas canvas, String text, float x, float y, Paint paint) {\n    String[] lines = text.split(\"\\n\");\n    Rect rect = new Rect();\n    int yOff = 0;\n    for (int i = 0; i < lines.length; ++i) {\n      canvas.drawText(lines[i], x, y + yOff, paint);\n      paint.getTextBounds(lines[i], 0, lines[i].length(), rect);\n      yOff = yOff + rect.height() + 5; // space between lines is 5\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8785, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 87, "focalAPIEnd": 101, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tickleman/RealShop/tree/master/src/fr/crafter/tickleman/RealPlugin/RealBlock.java", "rawCode": "  public static Block fromStrId(RealPlugin plugin, String str) {\n    String[] coords = str.split(\";\");\n    return plugin\n        .getServer()\n        .getWorld(coords[0])\n        .getBlockAt(\n            Integer.parseInt(coords[1]), Integer.parseInt(coords[2]), Integer.parseInt(coords[3]));\n  }\n"}, {"dataset": "split", "exampleID": 8786, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 115, "focalAPIEnd": 143, "followUpCheck": "strArray[0].split(\":\")[0].equals(\"Track2\")", "checkType": "IF", "followUpCheckExpressionStart": 151, "followUpCheckExpressionEnd": 195, "followUpCheckBlockStart": 151, "followUpCheckBlockEnd": 364, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Synature-Jitthapong/myrepo_core_libs/tree/master/src/com/j1tth4/util/CreditCardParser.java", "rawCode": "  public boolean parser(String content) {\n    if (content != null && !content.equals(\"\")) {\n      String[] track = content.split(END_SENTINEL1);\n      if (track[0].split(\":\")[0].equals(\"Track2\")) {\n        parserDebit(track[0]);\n        return true;\n      } else {\n        String track1 = track[0].trim();\n        parserCredit(track1);\n        return true;\n      }\n    }\n    return false;\n  }\n"}, {"dataset": "split", "exampleID": 8787, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 119, "focalAPIEnd": 142, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cwhelan/cloudbreak/tree/master/src/main/java/edu/ohsu/sonmezsysbio/cloudbreak/io/BaseAlignmentReader.java", "rawCode": "  protected String stripChromosomeName(String chromName) {\n    if (isStripChromosomeNameAtWhitespace()) {\n      return chromName.split(\"\\\\s+\")[0];\n    } else {\n      return chromName;\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8788, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 117, "focalAPIEnd": 139, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 145, "followUpCheckExpressionEnd": 174, "followUpCheckBlockStart": 145, "followUpCheckBlockEnd": 224, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/acionescu/open-groups-vaadin/tree/master/src/ro/zg/opengroups/vo/EntityState.java", "rawCode": "  public void setCurrentActionsPath(String actionsPath) {\n    currentActionTabsQueue.clear();\n    String[] actions = actionsPath.split(\"/\");\n    for (String action : actions) {\n      currentActionTabsQueue.add(action);\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8789, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 151, "focalAPIEnd": 168, "followUpCheck": "strArray", "checkType": "LOOP {", "followUpCheckExpressionStart": 437, "followUpCheckExpressionEnd": 463, "followUpCheckBlockStart": 437, "followUpCheckBlockEnd": 591, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sakai-mirror/sdata/tree/master/tool/sakai-sdata-impl/src/main/java/org/sakaiproject/sdata/services/mcp/MyCoursesAndProjectsBean.java", "rawCode": "  @SuppressWarnings(\"unchecked\")\n  private boolean containstool(Site site, String tool) {\n\n    boolean containstool = false;\n\n    String[] toolcheck = tool.split(\"[|]\");\n\n    List<SitePage> pages = (List<SitePage>) site.getOrderedPages();\n\n    for (SitePage page : pages) {\n      List<ToolConfiguration> lst = (List<ToolConfiguration>) page.getTools();\n      for (ToolConfiguration conf : lst) {\n        Tool t = conf.getTool();\n        for (String s : toolcheck) {\n          if (t != null && t.getId() != null && t.getId().equals(s)) {\n            containstool = true;\n          }\n        }\n      }\n    }\n\n    return containstool;\n  }\n"}, {"dataset": "split", "exampleID": 8790, "initialization": ["String string = isReference()"], "initializationStart": [163], "initializationEnd": [176], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 246, "focalAPIEnd": 263, "followUpCheck": "strArray.length == 1", "checkType": "IF", "followUpCheckExpressionStart": 270, "followUpCheckExpressionEnd": 292, "followUpCheckBlockStart": 270, "followUpCheckBlockEnd": 323, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/synyx/minos/tree/master/modules/core/src/main/java/org/synyx/minos/core/module/config/PropertyAttribute.java", "rawCode": "  /**\n   * Returns the attribute in camel case form.\n   *\n   * @return the attribute in camel case form\n   */\n  public String asCamelCase() {\n\n    String source = isReference() ? name.substring(0, name.indexOf(REF)) : name;\n\n    String[] parts = source.split(\"-\");\n\n    if (parts.length == 1) {\n      return parts[0];\n    }\n\n    StringBuilder builder = new StringBuilder(parts[0]);\n\n    for (int i = 1; i < parts.length; i++) {\n      builder.append(StringUtils.capitalize(parts[i]));\n    }\n\n    return builder.toString();\n  }\n"}, {"dataset": "split", "exampleID": 8791, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IllegalArgumentException", "exceptionHandlingCall": ["getMessage()", "format(String,int,String,*)", "warn(*)"], "tryExpressionStart": 460, "tryExpressionEnd": 464, "tryBlockStart": 460, "tryBlockEnd": 1610, "catchExpressionStart": 1246, "catchExpressionEnd": 1281, "catchBlockStart": 1246, "catchBlockEnd": 1437, "exceptionHandlingCallStart": [1410, 1321, 1293], "exceptionHandlingCallEnd": [1424, 1425, 1426], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(string)!=null", "guardType": "LOOP {", "guardExpressionStart": 306, "guardExpressionEnd": 371, "guardBlockStart": 306, "guardBlockEnd": 1618, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 494, "focalAPIEnd": 510, "followUpCheck": "strArray.length < 4", "checkType": "IF", "followUpCheckExpressionStart": 522, "followUpCheckExpressionEnd": 544, "followUpCheckBlockStart": 522, "followUpCheckBlockEnd": 608, "use": ["format(String,int,string,*)"], "useStart": [1321], "useEnd": [1425], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/utgenome/utgb/tree/master/utgb-core/src/main/java/org/utgenome/format/keyword/KeywordDB.java", "rawCode": "  public void importFromTAB(String ref, Reader tabFileReader) throws UTGBException {\n\n    int entryCount = 0;\n    int lineCount = 1;\n    try {\n      initDB();\n      db.update(\"pragma synchronous = off\");\n      db.setAutoCommit(false);\n\n      BufferedReader input = new BufferedReader(tabFileReader);\n      for (String line; (line = input.readLine()) != null; lineCount++) {\n        // skip the comment line\n        if (line.startsWith(\"#\")) continue;\n\n        try {\n          String[] column = line.split(\"\\t\");\n          if (column.length < 4) {\n            throw new IllegalArgumentException();\n          }\n          // chr, start, end, text ....\n          String chr = column[0];\n          int start = Integer.parseInt(column[1]);\n          int end = Integer.parseInt(column[2]);\n          StringBuilder buf = new StringBuilder();\n          for (int i = 3; i < column.length; ++i) {\n            if (i != 3) buf.append(\" \");\n            buf.append(column[i]);\n          }\n          GenomeKeywordEntry entry = new GenomeKeywordEntry(ref, chr, buf.toString(), start, end);\n\n          if (entryCount > 0 && (entryCount % 10000 == 0))\n            _logger.info(\"num entries: \" + entryCount);\n          entryCount++;\n\n          add(entry);\n        } catch (IllegalArgumentException e) {\n          _logger.warn(\n              String.format(\n                  \"line %d has invalid format: %s (%s)\", lineCount, line, e.getMessage()));\n        } catch (DBException e) {\n          _logger.error(String.format(\"line %d: insertion error %s\", lineCount, e.getMessage()));\n          e.printStackTrace(System.err);\n        }\n      }\n\n      db.update(\"commit\");\n    } catch (DBException e) {\n      _logger.error(\"error at line \" + lineCount);\n      throw new UTGBException(UTGBErrorCode.DatabaseError, e);\n    } catch (IOException e) {\n      throw new UTGBException(UTGBErrorCode.IO_ERROR, e);\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8792, "initialization": ["String string = BufferedReader.readLine()"], "initializationStart": [316], "initializationEnd": [329], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 143, "tryExpressionEnd": 147, "tryBlockStart": 143, "tryBlockEnd": 854, "catchExpressionStart": 800, "catchExpressionEnd": 820, "catchBlockStart": 800, "catchBlockEnd": 854, "exceptionHandlingCallStart": [828], "exceptionHandlingCallEnd": [847], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null", "guardType": "LOOP {", "guardExpressionStart": 337, "guardExpressionEnd": 380, "guardBlockStart": 337, "guardBlockEnd": 715, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 432, "focalAPIEnd": 447, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olanto/MYCAT/tree/master/prog/TMXsupport/src/org/olanto/mycat/tmx/multiun/extract/extractZHCorrection.java", "rawCode": "  static void Process(String fileName) {\n\n    System.out.println(\"------------- entry dictionary: \" + fileName);\n    int totdictEntry = 0;\n    try {\n      InputStreamReader isrso = new InputStreamReader(new FileInputStream(fileName), \"UTF-8\");\n      BufferedReader so = new BufferedReader(isrso);\n      String wso = so.readLine();\n      while (wso != null && totdictEntry < limit) {\n        totdictEntry++;\n        String[] entry = wso.split(\"\\t\");\n        entry[6] = stringManip.addSpace(entry[6]);\n        outmflf.append(\n            entry[0] + \"\\t\" + entry[1] + \"\\t\" + entry[2] + \"\\t\" + entry[3] + \"\\t\" + entry[4] + \"\\t\"\n                + entry[5] + \"\\t\" + entry[6] + \"\\n\");\n\n        wso = so.readLine();\n      }\n      so.close();\n      System.out.println(\" read entries: \" + totdictEntry);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8793, "initialization": ["String string = getProperty(String)"], "initializationStart": [264], "initializationEnd": [314], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new TestopiaException(*)"], "tryExpressionStart": 118, "tryExpressionEnd": 122, "tryBlockStart": 118, "tryBlockEnd": 1780, "catchExpressionStart": 600, "catchExpressionEnd": 620, "catchBlockStart": 600, "catchBlockEnd": 677, "exceptionHandlingCallStart": [640], "exceptionHandlingCallEnd": [664], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string!=null", "guardType": "IF {", "guardExpressionStart": 345, "guardExpressionEnd": 370, "guardBlockStart": 345, "guardBlockEnd": 695, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 427, "focalAPIEnd": 450, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RedHatQE/tcms-testng/tree/master/src/com/redhat/qe/auto/tcms/TCMSTestNGListener.java", "rawCode": "  public void onStart(ITestContext context) {\n    // create new test run\n    String testname = context.getName();\n    try {\n      loginTestopia();\n      retrieveContext();\n\n      // if set, onStart determine env id that needs to be set\n      String sEnvironment = System.getProperty(\"testopia.testrun.environment\");\n      int iEnvID = -1;\n      if (sEnvironment != null) {\n        if (env == null) {\n          String[] saEnv = sEnvironment.split(\":\");\n          try {\n            env = new Environment(session, product.getId(), saEnv[0], saEnv[1]);\n            iEnvID = env.getValueId();\n          } catch (Exception e) {\n            throw new TestopiaException(e);\n          }\n        }\n      }\n\n      testrun =\n          new TestRun(\n              session,\n              testplan.getId(),\n              iEnvID,\n              build.getId(),\n              session.getUserid(),\n              testname,\n              product.getId(),\n              product.getVersionIDByName(version));\n      testrun.create();\n\n      // if set, onStart globally set environment for test run\n      if (iEnvID != -1) {\n        testrun.applyEnvironmentValue();\n      }\n\n      // if set, onStart set tags on test run\n      String sTags = System.getProperty(\"testopia.testrun.tags\");\n      if (sTags != null) {\n        Object result = testrun.setTags(sTags);\n        if (result != null) {\n          System.out.println(\"Setting tag result: \" + result.toString());\n        } else {\n          System.out.println(\"Setting tag result: null\");\n        }\n      }\n\n    } catch (Exception e) {\n      // log.severe(\"Could not create new test run in testopia! Aborting!\");\n      TestopiaException te = new TestopiaException(\"Could not create new test run in testopia.\");\n      te.initCause(e);\n      throw te;\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8794, "initialization": ["String string = FileConfiguration.getString(String)"], "initializationStart": [745], "initializationEnd": [785], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getLogger()", "log(*,String,*)"], "tryExpressionStart": 395, "tryExpressionEnd": 399, "tryBlockStart": 395, "tryBlockEnd": 2376, "catchExpressionStart": 2258, "catchExpressionEnd": 2279, "catchBlockStart": 2258, "catchBlockEnd": 2376, "exceptionHandlingCallStart": [2291, 2291], "exceptionHandlingCallEnd": [2309, 2365], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "string.contains(regex,)", "guardType": "IF {", "guardExpressionStart": 866, "guardExpressionEnd": 892, "guardBlockStart": 866, "guardBlockEnd": 1050, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 928, "focalAPIEnd": 946, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CodingBadgers/bFundamentals/tree/master/bNpcStore/src/uk/codingbadgers/bnpcstore/bNpcStore.java", "rawCode": "  private void loadItemConfig(FileConfiguration itemConfig, GuiInventory inventory) {\n\n    if (this.m_itemNames.isEmpty()) {\n      return;\n    }\n\n    List<String> items = m_itemNames.get(inventory);\n\n    if (!items.isEmpty()) {\n      int itemIndex = 0;\n      String item = items.get(itemIndex);\n      while (inventory.getItem(item) == null) {\n\n        String nodePath = \"item.\" + item;\n\n        try {\n          String name = itemConfig.getString(nodePath + \".name\");\n          int row = itemConfig.getInt(nodePath + \".row\");\n          int column = itemConfig.getInt(nodePath + \".column\");\n          List<String> details = itemConfig.getStringList(nodePath + \".details\");\n          details = parseColorCodes(details);\n\n          String rawIcon = itemConfig.getString(nodePath + \".icon\");\n          String iconName = rawIcon;\n          Byte dataValue = -1;\n\n          if (rawIcon.contains(\":\")) {\n            String[] iconParts = rawIcon.split(\":\");\n            iconName = iconParts[0];\n            dataValue = Byte.parseByte(iconParts[1]);\n          }\n\n          ItemStack itemStack = null;\n          if (dataValue != -1) {\n            itemStack = new ItemStack(Material.valueOf(iconName), 1, dataValue);\n          } else {\n            itemStack = new ItemStack(Material.valueOf(iconName));\n          }\n\n          GuiCallback onClickCallback = null;\n          if (itemConfig.contains(nodePath + \".onclick\")) {\n\n            // BuySellCallback\n            if (itemConfig.contains(nodePath + \".onclick.buysell\")) {\n              double buyPrice = itemConfig.getDouble(nodePath + \".onclick.buysell.buyprice\", 100.0);\n              double sellPrice =\n                  itemConfig.getDouble(nodePath + \".onclick.buysell.sellprice\", 100.0);\n\n              details.add(\" \");\n              details.add(\"Buy for £\" + buyPrice + \" each.\");\n              details.add(\"Sell for £\" + sellPrice + \" each.\");\n\n              onClickCallback =\n                  new GuiBuySellCallback(inventory, name, itemStack, buyPrice, sellPrice);\n            }\n          }\n\n          String[] detailsArray = new String[details.size()];\n          details.toArray(detailsArray);\n          inventory.addMenuItem(name, itemStack, detailsArray, (row * 9) + column, onClickCallback);\n\n        } catch (Exception ex) {\n          Bukkit.getLogger().log(Level.WARNING, \"Failed to load item - \" + item, ex);\n        }\n\n        itemIndex++;\n        if (itemIndex >= items.size()) {\n          break;\n        }\n        item = items.get(itemIndex);\n      }\n    }\n  }\n"}, {"dataset": "split", "exampleID": 8795, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 114, "focalAPIEnd": 135, "followUpCheck": "i < strArray.length", "checkType": "LOOP", "followUpCheckExpressionStart": 143, "followUpCheckExpressionEnd": 182, "followUpCheckBlockStart": 143, "followUpCheckBlockEnd": 269, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gilsondev/jsf2-api/tree/master/jsf-tools/src/main/java/com/sun/faces/generate/AbstractGenerator.java", "rawCode": "    public void writeBlockComment(String str) throws IOException {\n\n      fwrite(\"/*\\n\");\n      String[] tokens = str.split(\"\\r|\\n|\\t\");\n      for (int i = 0; i < tokens.length; i++) {\n        fwrite(\" * \");\n        write(tokens[i].trim());\n        write('\\n');\n      }\n      fwrite(\" */\\n\");\n    } // END writeBlockComment\n"}, {"dataset": "split", "exampleID": 8796, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(string)!=null", "guardType": "LOOP {", "guardExpressionStart": 684, "guardExpressionEnd": 742, "guardBlockStart": 684, "guardBlockEnd": 1367, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 772, "focalAPIEnd": 790, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string.split(String)"], "useStart": [3043], "useEnd": [3061], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fozziethebeat/S-Space/tree/master/src/main/java/edu/ucla/sspace/matrix/MatrixIO.java", "rawCode": "  /**\n   * Reads in a matrix in the {@link Format#MATLAB_SPARSE} format and writes it to the output file\n   * in {@link Format#SVDLIBC_SPARSE_BINARY} format.\n   */\n  private static void matlabToSvdlibcSparseBinary(File input, File output, boolean transpose)\n      throws IOException {\n    MATRIX_IO_LOGGER.info(\n        \"Converting from Matlab double values to \"\n            + \"SVDLIBC float values; possible loss of \"\n            + \"precision\");\n    BufferedReader br = new BufferedReader(new FileReader(input));\n    Map<Integer, Integer> colToNonZero = new HashMap<Integer, Integer>();\n\n    // read through once to get matrix dimensions\n    int rows = 0, cols = 0, nonZero = 0;\n    for (String line = null; (line = br.readLine()) != null; ) {\n      String[] rowColVal = line.split(\"\\\\s+\");\n      int row, col;\n      if (transpose) {\n        row = Integer.parseInt(rowColVal[1]);\n        col = Integer.parseInt(rowColVal[0]);\n      } else {\n        row = Integer.parseInt(rowColVal[0]);\n        col = Integer.parseInt(rowColVal[1]);\n      }\n      if (row > rows) rows = row;\n      if (col > cols) cols = col;\n      ++nonZero;\n\n      // NOTE: subtract by 1 here because Matlab arrays start at 1, while\n      // SVDLIBC arrays start at 0.\n      Integer colCount = colToNonZero.get(col - 1);\n      colToNonZero.put(col - 1, (colCount == null) ? 1 : colCount + 1);\n    }\n    br.close();\n\n    // Print out the header information\n    DataOutputStream dos =\n        new DataOutputStream(new BufferedOutputStream(new FileOutputStream(output)));\n    dos.writeInt(rows);\n    dos.writeInt(cols);\n    dos.writeInt(nonZero);\n\n    // Process the entire array in chunks in case the matlab array is too\n    // big to fit into memory.\n\n    // REMINDER: this should probably be chosen based on the number of rows\n    // and their expected density\n    int chunkSize = 1000;\n\n    // This keeps track of the last columns printed. We need this outside\n    // the loop to ensure that blank columns at the end of a chunk are still\n    // printed by the next non-zero chunk\n    int lastCol = -1;\n\n    // lower bound inclusive, upper bound exclusive\n    for (int lowerBound = 0, upperBound = chunkSize;\n        lowerBound < rows;\n        lowerBound = upperBound, upperBound += chunkSize) {\n      // Once the dimensions and number of non-zero values are known,\n      // reprocess the matrix, storing the rows and values for each column\n      // that are inside the bounds\n      br = new BufferedReader(new FileReader(input));\n\n      // for each column, keep track of which in the next index into the\n      // rows array that should be used to store the row index. Also keep\n      // track of the value associated for that row\n      int[] colIndices = new int[cols];\n\n      // columns are kept in sorted order\n      SortedMap<Integer, int[]> colToRowIndex = new TreeMap<Integer, int[]>();\n      SortedMap<Integer, float[]> colToRowValues = new TreeMap<Integer, float[]>();\n\n      for (String line = null; (line = br.readLine()) != null; ) {\n        String[] rowColVal = line.split(\"\\\\s+\");\n        int row, col;\n        if (transpose) {\n          row = Integer.parseInt(rowColVal[1]) - 1;\n          col = Integer.parseInt(rowColVal[0]) - 1;\n        } else {\n          row = Integer.parseInt(rowColVal[0]) - 1;\n          col = Integer.parseInt(rowColVal[1]) - 1;\n        }\n        // NOTE: SVDLIBC uses floats instead of doubles, which can cause\n        // a loss of precision\n        float val = Double.valueOf(rowColVal[2]).floatValue();\n\n        // check that the current column is within the current chunk\n        if (col < lowerBound || col >= upperBound) continue;\n\n        // get the arrays used to store the non-zero row indices for\n        // this column and the parallel array that stores the\n        // row-index's value\n        int[] rowIndices = colToRowIndex.get(col);\n        float[] rowValues = colToRowValues.get(col);\n        if (rowIndices == null) {\n          rowIndices = new int[colToNonZero.get(col)];\n          rowValues = new float[colToNonZero.get(col)];\n          colToRowIndex.put(col, rowIndices);\n          colToRowValues.put(col, rowValues);\n        }\n\n        // determine what is the current index in the non-zero row array\n        // that can be used to store this row.\n        int curColIndex = colIndices[col];\n        rowIndices[curColIndex] = row;\n        rowValues[curColIndex] = val;\n        colIndices[col] += 1;\n      }\n      br.close();\n\n      // loop through the stored column and row values, printing out for\n      // each column, the number of non zero rows, followed by each row\n      // index and the value. This is the SVDLIBC sparse text format.\n      for (Map.Entry<Integer, int[]> e : colToRowIndex.entrySet()) {\n        int col = e.getKey().intValue();\n        int[] nonZeroRows = e.getValue();\n        float[] values = colToRowValues.get(col);\n\n        if (col != lastCol) {\n          // print any missing columns in case not all the columns\n          // have data\n          for (int i = lastCol + 1; i < col; ++i) dos.writeInt(0);\n\n          // print the new header\n          int colCount = colToNonZero.get(col);\n          lastCol = col;\n          dos.writeInt(colCount);\n        }\n\n        for (int i = 0; i < nonZeroRows.length; ++i) {\n          dos.writeInt(nonZeroRows[i]);\n          dos.writeFloat(values[i]);\n        }\n      }\n    }\n    dos.close();\n  }\n"}, {"dataset": "split", "exampleID": 8797, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 124, "focalAPIEnd": 139, "followUpCheck": "strArray.equals(\"B11\")", "checkType": "IF", "followUpCheckExpressionStart": 188, "followUpCheckExpressionEnd": 216, "followUpCheckBlockStart": 188, "followUpCheckBlockEnd": 591, "use": ["string.split(String)"], "useStart": [164], "useEnd": [179], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bomm/thera-pi/tree/master/Reha301/src/reha301Panels/Reha301Einlesen.java", "rawCode": "  private String regleArtDerLeistung(String wert) {\n    String ret = \"Art der Leistung - unbekannt\";\n    String codeliste = wert.split(\":\")[1];\n    String inhalt = wert.split(\":\")[0];\n    if (codeliste.equals(\"B11\")) {\n      if (inhalt.equals(\"1\")) {\n        return \"Art der Leistung: stationär\";\n      }\n      if (inhalt.equals(\"2\")) {\n        return \"Art der Leistung: ganztägig ambulant\";\n      }\n      if (inhalt.equals(\"3\")) {\n        // Wenn ambulant dann muß es NACHSORGE sein\n        dbHmap.put(\"a12\", \"NACHSORGE\");\n        return \"Art der Leistung: ambulant (nur RV)\";\n      }\n    }\n    if (codeliste.equals(\"B09\")) {\n      if (inhalt.equals(\"01\")) {\n        return \"Indikationsgruppe - 01 = Krankheiten des Herzens und des Kreislaufs\";\n      }\n      if (inhalt.equals(\"02\")) {\n        return \"Indikationsgruppe - 02 = Krankheiten der Gefäße\";\n      }\n      if (inhalt.equals(\"03\")) {\n        return \"Indikationsgruppe - 03 = Entzündliche rheumatische Erkrankungen\";\n      }\n      if (inhalt.equals(\"04\")) {\n        return \"Indikationsgruppe - 04 = Degenerative rheumatische Krankheiten (orthop.)\";\n      }\n      if (inhalt.equals(\"09\")) {\n        return \"Indikationsgruppe - 09 = Neurologische Erkrankungen\";\n      }\n    }\n    return ret;\n  }\n"}, {"dataset": "split", "exampleID": 8798, "initialization": ["String string = getKey(String)"], "initializationStart": [256], "initializationEnd": [272], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(string==null)", "guardType": "IF {", "guardExpressionStart": 278, "guardExpressionEnd": 294, "guardBlockStart": 278, "guardBlockEnd": 323, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 398, "focalAPIEnd": 414, "followUpCheck": "strArray.length == 3 && \"filename\".equals(strArray[2])", "checkType": "IF", "followUpCheckExpressionStart": 482, "followUpCheckExpressionEnd": 541, "followUpCheckBlockStart": 482, "followUpCheckBlockEnd": 948, "use": ["string.replaceAll(String,String)", "string.replaceAll(String,String)"], "useStart": [631, 705], "useEnd": [670, 744], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benkonrath/gwt-glom/tree/master/src/main/java/org/glom/web/server/OnlineGlomProperties.java", "rawCode": "  /**\n   * Get the credentials for a specific file, ignoring the global username and password.\n   *\n   * @param filename\n   * @return\n   */\n  public Credentials getCredentials(final String filename) {\n    Credentials result = null;\n\n    final String key = getKey(filename);\n    if (key == null) {\n      return result;\n    }\n\n    // Split the line at the . separators,\n    final String[] keyArray = key.split(\"\\\\.\");\n\n    // Check that the third item is \"filename\", as expected:\n    if (keyArray.length == 3 && \"filename\".equals(keyArray[2])) {\n      // Get the username and password for this file:\n      final String usernameKey = key.replaceAll(keyArray[2], \"username\");\n      final String passwordKey = key.replaceAll(keyArray[2], \"password\");\n      final String username = getPropertyNonNull(usernameKey).trim();\n      final String password = getPropertyNonNull(passwordKey);\n      result = new Credentials(null, username, password, null);\n    }\n\n    return result;\n  }\n"}, {"dataset": "split", "exampleID": 8799, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex,limit)", "focalAPIStart": 240, "focalAPIEnd": 260, "followUpCheck": "tabDifference(strArray[startLine]) < 0", "checkType": "IF", "followUpCheckExpressionStart": 1050, "followUpCheckExpressionEnd": 1092, "followUpCheckBlockStart": 1050, "followUpCheckBlockEnd": 1138, "use": ["string.trim()"], "useStart": [1556], "useEnd": [1567], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mok4ry/htmleditor/tree/master/src/main/java/edu/rit/se/antipattern/htmleditor/models/Indent.java", "rawCode": "  /**\n   * Indents the given text over the given range\n   *\n   * @param text\n   * @param startChar\n   * @param endChar\n   * @return newText\n   */\n  private String indentText(String text, int startChar, int endChar) {\n    String[] newText = text.split(\"\\n\", -1);\n    // Calculate the line numbers to indent\n    int startLine = 0;\n    int endLine = 0;\n    // Get Start Line\n    int i = startChar;\n    if (i == text.length()) i--;\n    while (i > 0) {\n      if (text.charAt(i) == '\\n') startLine++;\n      i--;\n    }\n    // Get End Line\n    i = endChar;\n    if (i == text.length()) i--;\n    while (i > startChar) {\n      if (text.charAt(i) == '\\n') endLine++;\n      i--;\n    }\n    endLine += startLine;\n\n    // Get the number of tabs from the previous line\n    int numTabs = 0;\n    if (startLine > 0) {\n      numTabs = countTabs(newText[startLine - 1]);\n      numTabs += tabDifference(newText[startLine - 1]);\n    }\n\n    // Add the tabs to the apropriate line\n    while (startLine <= endLine) {\n      newText[startLine] = newText[startLine].trim();\n      if (tabDifference(newText[startLine]) < 0) numTabs += tabDifference(newText[startLine]);\n\n      if (numTabs < 0) numTabs = 0;\n\n      for (i = 0; i < numTabs; i++) {\n        newText[startLine] = tab + newText[startLine];\n      }\n\n      if (tabDifference(newText[startLine]) > 0) numTabs += tabDifference(newText[startLine]);\n\n      startLine++;\n    }\n\n    // Recompile the text appropriately\n    text = \"\";\n    for (i = 0; i < newText.length; i++) {\n      text = text + newText[i] + \"\\n\";\n    }\n\n    return text.trim();\n  }\n"}, {"dataset": "split", "exampleID": 8800, "initialization": ["String string = PositionKind.getOutput(OutputKind)"], "initializationStart": [691], "initializationEnd": [720], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "strArray = string.split(regex)", "focalAPIStart": 1014, "focalAPIEnd": 1035, "followUpCheck": "strArray.length == 1", "checkType": "IF", "followUpCheckExpressionStart": 1270, "followUpCheckExpressionEnd": 1292, "followUpCheckBlockStart": 1270, "followUpCheckBlockEnd": 1353, "use": ["string.replaceFirst(String,String)", "printInfo(String,OutputKind,ErrorKind,MultilineKind,MultilinePolicy,PositionKind,XDiagsSource,XDiagsCompact,CaretKind,SourceLineKind,IndentKind,IndentKind,IndentKind,IndentKind,string)"], "useStart": [1386, 1697], "useEnd": [1561, 2045], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-langtools/tree/master/test/tools/javac/Diagnostics/6769027/T6769027.java", "rawCode": "  void checkOutput(\n      String msg,\n      OutputKind outputKind,\n      ErrorKind errorKind,\n      MultilineKind multiKind,\n      MultilinePolicy multiPolicy,\n      PositionKind posKind,\n      XDiagsSource xdiagsSource,\n      XDiagsCompact xdiagsCompact,\n      CaretKind caretKind,\n      SourceLineKind sourceLineKind,\n      IndentKind summaryIndent,\n      IndentKind detailsIndent,\n      IndentKind sourceIndent,\n      IndentKind subdiagsIndent) {\n    boolean shouldPrintSource =\n        posKind == PositionKind.POS\n            && xdiagsSource != XDiagsSource.NO_SOURCE\n            && (xdiagsSource == XDiagsSource.SOURCE || outputKind == OutputKind.BASIC);\n    String errorLine =\n        posKind.getOutput(outputKind)\n            + errorKind.getOutput(outputKind, summaryIndent, detailsIndent);\n    if (xdiagsCompact != XDiagsCompact.COMPACT)\n      errorLine +=\n          multiKind.getOutput(\n              outputKind, errorKind, multiPolicy, summaryIndent, detailsIndent, subdiagsIndent);\n    String[] lines = errorLine.split(\"\\n\");\n    if (xdiagsCompact == XDiagsCompact.COMPACT) {\n      errorLine = lines[0];\n      lines = new String[] {errorLine};\n    }\n    if (shouldPrintSource) {\n      if (sourceLineKind.isAfterSummary()) {\n        String sep = \"\\n\";\n        if (lines.length == 1) {\n          errorLine += \"\\n\";\n          sep = \"\";\n        }\n        errorLine =\n            errorLine.replaceFirst(\n                \"\\n\",\n                Matcher.quoteReplacement(\n                    xdiagsSource.getOutput(caretKind, sourceIndent, outputKind) + sep));\n      } else errorLine += xdiagsSource.getOutput(caretKind, sourceIndent, outputKind);\n    }\n\n    if (!msg.equals(errorLine)) {\n      printInfo(\n          msg,\n          outputKind,\n          errorKind,\n          multiKind,\n          multiPolicy,\n          posKind,\n          xdiagsSource,\n          xdiagsCompact,\n          caretKind,\n          sourceLineKind,\n          summaryIndent,\n          detailsIndent,\n          sourceIndent,\n          subdiagsIndent,\n          errorLine);\n      nerrors++;\n    }\n  }\n"}]