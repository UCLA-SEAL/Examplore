[{"dataset": "inputStreamRead", "exampleID": 2601, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "new StreamParsingException(*,*)"], "tryExpressionStart": 65, "tryExpressionEnd": 69, "tryBlockStart": 65, "tryBlockEnd": 370, "catchExpressionStart": 286, "catchExpressionEnd": 306, "catchBlockStart": 286, "catchBlockEnd": 370, "exceptionHandlingCallStart": [347, 320], "exceptionHandlingCallEnd": [359, 363], "configuration": ["inputStream.mark(int)"], "configurationStart": [78], "configurationEnd": [100], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 118, "focalAPIEnd": 138, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 147, "followUpCheckExpressionEnd": 161, "followUpCheckBlockStart": 147, "followUpCheckBlockEnd": 192, "use": ["inputStream.reset()", "readDERCrossCertificatePair(inputStream)"], "useStart": [200, 236], "useEnd": [221, 278], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bcgit/bc-java/tree/master/prov/src/main/java/org/bouncycastle/jce/provider/X509CertPairParser.java", "rawCode": "  public Object engineRead() throws StreamParsingException {\n    try {\n\n      currentStream.mark(10);\n      int tag = currentStream.read();\n\n      if (tag == -1) {\n        return null;\n      }\n\n      currentStream.reset();\n      return readDERCrossCertificatePair(currentStream);\n    } catch (Exception e) {\n      throw new StreamParsingException(e.toString(), e);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2602, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 243, "focalAPIEnd": 258, "followUpCheck": "bytes != -1", "checkType": "LOOP {", "followUpCheckExpressionStart": 264, "followUpCheckExpressionEnd": 281, "followUpCheckBlockStart": 264, "followUpCheckBlockEnd": 351, "use": ["OutputStream.write(byte[],int,bytes)", "inputStream.read(byte[])"], "useStart": [290, 329], "useEnd": [315, 344], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sk89q/commandhelper/tree/master/src/main/java/com/laytonsmith/PureUtilities/Common/StreamUtils.java", "rawCode": "  /**\n   * Copies from one stream to another\n   *\n   * @param out\n   * @param in\n   * @throws IOException\n   */\n  public static void Copy(InputStream in, OutputStream out) throws IOException {\n    byte[] buffer = new byte[1024];\n    int len = in.read(buffer);\n    while (len != -1) {\n      out.write(buffer, 0, len);\n      len = in.read(buffer);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2603, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "inputStream.available()>0", "guardType": "IF {", "guardExpressionStart": 174, "guardExpressionEnd": 197, "guardBlockStart": 174, "guardBlockEnd": 215, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 205, "focalAPIEnd": 214, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cloudera/flume/tree/master/flume-core/src/main/java/com/cloudera/flume/handlers/console/JLineStdinSource.java", "rawCode": "    @Override\n    public int read() throws IOException {\n      // have set this to poll..\n      while (true) {\n        // there is data buffered, read and return it.\n        if (in.available() > 0) return in.read();\n\n        // no data left\n        if (!opened.get()) {\n          // we are closed, return EOF\n          return ConsoleOperations.CTRL_D;\n        }\n        try {\n          // still open, wait a little and try again.\n          Clock.sleep(50);\n        } catch (InterruptedException e) {\n          // interrupted? return end of file.\n          return ConsoleOperations.CTRL_D;\n        }\n      }\n    }\n"}, {"dataset": "inputStreamRead", "exampleID": 2604, "initialization": ["InputStream inputStream = HttpURLConnection.getInputStream()"], "initializationStart": [930], "initializationEnd": [957], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 425, "tryExpressionEnd": 429, "tryBlockStart": 425, "tryBlockEnd": 2238, "catchExpressionStart": 1248, "catchExpressionEnd": 1270, "catchBlockStart": 1248, "catchBlockEnd": 2097, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(true||offset+len>b.length)", "guardType": "IF {", "guardExpressionStart": 272, "guardExpressionEnd": 285, "guardBlockStart": 272, "guardBlockEnd": 309, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 1004, "focalAPIEnd": 1040, "followUpCheck": "bytes < 0", "checkType": "IF", "followUpCheckExpressionStart": 1050, "followUpCheckExpressionEnd": 1064, "followUpCheckBlockStart": 1050, "followUpCheckBlockEnd": 1173, "use": ["inputStream.close()"], "useStart": [2140], "useEnd": [2150], "hasFinally": 1, "cleanUpCall": ["InputStream.close()"], "finallyExpressionStart": 2098, "finallyExpressionEnd": 2106, "finallyBlockStart": 2098, "finallyBlockEnd": 2238, "cleanUpCallStart": [2140], "cleanUpCallEnd": [2150], "url": "https://github.com/iansealy/picard-detct/tree/master/src/java/net/sf/samtools/seekablestream/SeekableHTTPStream.java", "rawCode": "  public int read(byte[] buffer, int offset, int len) throws IOException {\n\n    if (offset < 0 || len < 0 || (offset + len) > buffer.length) {\n      throw new IndexOutOfBoundsException(\n          \"Offset=\" + offset + \",len=\" + len + \",buflen=\" + buffer.length);\n    }\n    if (len == 0) {\n      return 0;\n    }\n\n    HttpURLConnection connection = null;\n    InputStream is = null;\n    String byteRange = \"\";\n    int n = 0;\n    try {\n      connection =\n          proxy == null\n              ? (HttpURLConnection) url.openConnection()\n              : (HttpURLConnection) url.openConnection(proxy);\n\n      long endRange = position + len - 1;\n      // IF we know the total content length, limit the end range to that.\n      if (contentLength > 0) {\n        endRange = Math.min(endRange, contentLength);\n      }\n      byteRange = \"bytes=\" + position + \"-\" + endRange;\n      connection.setRequestProperty(\"Range\", byteRange);\n\n      is = connection.getInputStream();\n\n      while (n < len) {\n        int count = is.read(buffer, offset + n, len - n);\n        if (count < 0) {\n          if (n == 0) {\n            return -1;\n          } else {\n            break;\n          }\n        }\n        n += count;\n      }\n\n      position += n;\n\n      return n;\n\n    } catch (IOException e) {\n      // THis is a bit of a hack, but its not clear how else to handle this. If a byte range is\n      // specified\n      // that goes past the end of the file the response code will be 416. The MAC os translates\n      // this to\n      // an IOException with the 416 code in the message. Windows translates the error to an\n      // EOFException.\n      //\n      // The BAM file iterator uses the return value to detect end of file (specifically looks for n\n      // == 0).\n      if (e.getMessage().contains(\"416\") || (e instanceof EOFException)) {\n        if (n == 0) {\n          return -1;\n        } else {\n          position += n;\n          // As we are at EOF, the contentLength and position are by definition =\n          contentLength = position;\n          return n;\n        }\n      } else {\n        throw e;\n      }\n\n    } finally {\n      if (is != null) {\n        is.close();\n      }\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2605, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "off<len", "guardType": "LOOP {", "guardExpressionStart": 112, "guardExpressionEnd": 127, "guardBlockStart": 112, "guardBlockEnd": 283, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 144, "focalAPIEnd": 168, "followUpCheck": "bytes <= 0", "checkType": "IF", "followUpCheckExpressionStart": 176, "followUpCheckExpressionEnd": 187, "followUpCheckBlockStart": 176, "followUpCheckBlockEnd": 263, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/tigervnc/tree/master/trunk/java/com/jcraft/jsch/ProxySOCKS5.java", "rawCode": "  private void fill(InputStream in, byte[] buf, int len) throws JSchException, IOException {\n    int s = 0;\n    while (s < len) {\n      int i = in.read(buf, s, len - s);\n      if (i <= 0) {\n        throw new JSchException(\"ProxySOCKS5: stream is closed\");\n      }\n      s += i;\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2606, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "off<size&&off>=0", "guardType": "LOOP {", "guardExpressionStart": 201, "guardExpressionEnd": 235, "guardBlockStart": 201, "guardBlockEnd": 280, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 244, "focalAPIEnd": 279, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fiji/imagej1/tree/master/ij/plugin/PGM_Reader.java", "rawCode": "  public ImageProcessor open16bitRawImage(InputStream is, int width, int height)\n      throws IOException {\n    int size = width * height * 2;\n    byte[] bytes = new byte[size];\n    int count = 0;\n    while (count < size && count >= 0) count = is.read(bytes, count, size - count);\n    short[] pixels = new short[size / 2];\n    for (int i = 0, j = 0; i < size / 2; i++, j += 2)\n      pixels[i] = (short) (((bytes[j] & 0xff) << 8) | (bytes[j + 1] & 0xff)); // big endian\n    return new ShortProcessor(width, height, pixels, null);\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2607, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 194, "focalAPIEnd": 224, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 234, "followUpCheckExpressionEnd": 250, "followUpCheckBlockStart": 234, "followUpCheckBlockEnd": 257, "use": ["OutputStream.write(byte[],int,bytes)"], "useStart": [266], "useEnd": [291], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kerpie/truTest/tree/master/src/lazylist/Utils.java", "rawCode": "  public static void CopyStream(InputStream is, OutputStream os) {\n    final int buffer_size = 1024;\n    try {\n      byte[] bytes = new byte[buffer_size];\n      for (; ; ) {\n        int count = is.read(bytes, 0, buffer_size);\n        if (count == -1) break;\n        os.write(bytes, 0, count);\n      }\n    } catch (Exception ex) {\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2608, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 68, "focalAPIEnd": 77, "followUpCheck": "bytes < 0", "checkType": "IF", "followUpCheckExpressionStart": 86, "followUpCheckExpressionEnd": 96, "followUpCheckBlockStart": 86, "followUpCheckBlockEnd": 125, "use": ["inputStream.read()", "inputStream.read()", "inputStream.read()", "inputStream.read()"], "useStart": [265, 334, 354, 374], "useEnd": [274, 343, 363, 383], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rtyley/test-bc-java-cvsimport/tree/master/crypto/src/org/bouncycastle/bcpg/BCPGInputStream.java", "rawCode": "    private int loadDataLength() throws IOException {\n      int l = in.read();\n\n      if (l < 0) {\n        return -1;\n      }\n\n      partial = false;\n      if (l < 192) {\n        dataLength = l;\n      } else if (l <= 223) {\n        dataLength = ((l - 192) << 8) + (in.read()) + 192;\n      } else if (l == 255) {\n        dataLength = (in.read() << 24) | (in.read() << 16) | (in.read() << 8) | in.read();\n      } else {\n        partial = true;\n        dataLength = 1 << (l & 0x1f);\n      }\n\n      return dataLength;\n    }\n"}, {"dataset": "inputStreamRead", "exampleID": 2609, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(inputStream==null)", "guardType": "IF {", "guardExpressionStart": 219, "guardExpressionEnd": 234, "guardBlockStart": 219, "guardBlockEnd": 479, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 306, "focalAPIEnd": 315, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 323, "followUpCheckExpressionEnd": 339, "followUpCheckBlockStart": 323, "followUpCheckBlockEnd": 412, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robovm/robovm/tree/master/rt/libcore/luni/src/main/java/org/apache/harmony/security/asn1/BerInputStream.java", "rawCode": "  /** Reads the next encoded byte from the encoded input stream. */\n  protected int read() throws IOException {\n    if (offset == buffer.length) {\n      throw new ASN1Exception(\"Unexpected end of encoding\");\n    }\n\n    if (in == null) {\n      return buffer[offset++] & 0xFF;\n    } else {\n      int octet = in.read();\n      if (octet == -1) {\n        throw new ASN1Exception(\"Unexpected end of encoding\");\n      }\n\n      buffer[offset++] = (byte) octet;\n\n      return octet;\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2610, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 53, "focalAPIEnd": 71, "followUpCheck": "bytes != -1", "checkType": "IF", "followUpCheckExpressionStart": 77, "followUpCheckExpressionEnd": 89, "followUpCheckBlockStart": 77, "followUpCheckBlockEnd": 101, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tmobile/themes-platform-packages-apps-Email/tree/master/src/org/apache/james/mime4j/util/PositionInputStream.java", "rawCode": "  public int read() throws IOException {\n    int b = inputStream.read();\n    if (b != -1) position++;\n    return b;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2611, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 555, "focalAPIEnd": 608, "followUpCheck": "bytes < 1", "checkType": "IF", "followUpCheckExpressionStart": 618, "followUpCheckExpressionEnd": 628, "followUpCheckBlockStart": 618, "followUpCheckBlockEnd": 636, "use": ["OutputStream.write(byte[],int,bytes)"], "useStart": [763], "useEnd": [788], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pdinc-oss/jgit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/util/TemporaryBuffer.java", "rawCode": "  /**\n   * Copy all bytes remaining on the input stream into this buffer.\n   *\n   * @param in the stream to read from, until EOF is reached.\n   * @throws IOException an error occurred reading from the input stream, or while writing to a\n   *     local temporary file.\n   */\n  public void copy(final InputStream in) throws IOException {\n    if (blocks != null) {\n      for (; ; ) {\n        Block s = last();\n        if (s.isFull()) {\n          if (reachedInCoreLimit()) break;\n          s = new Block();\n          blocks.add(s);\n        }\n\n        int n = in.read(s.buffer, s.count, s.buffer.length - s.count);\n        if (n < 1) return;\n        s.count += n;\n      }\n    }\n\n    final byte[] tmp = new byte[Block.SZ];\n    int n;\n    while ((n = in.read(tmp)) > 0) overflow.write(tmp, 0, n);\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2612, "initialization": ["InputStream inputStream = DownloadResource.getInputStream()"], "initializationStart": [1381], "initializationEnd": [1407], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 1456, "focalAPIEnd": 1468, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.close()"], "useStart": [1569], "useEnd": [1579], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/exoplatform/aio-portal/tree/master/webui/eXo/src/main/java/org/exoplatform/web/command/handler/DownloadHandler.java", "rawCode": "  @SuppressWarnings(\"unused\")\n  public void execute(WebAppController controller, HttpServletRequest req, HttpServletResponse res)\n      throws Exception {\n    res.setHeader(\"Cache-Control\", \"private max-age=600, s-maxage=120\");\n    ExoContainer container = ExoContainerContext.getCurrentContainer();\n    DownloadService dservice =\n        (DownloadService) container.getComponentInstanceOfType(DownloadService.class);\n    DownloadResource dresource = dservice.getDownloadResource(resourceId);\n    if (dresource == null) {\n      res.setContentType(\"text/plain\");\n      res.getWriter()\n          .write(\n              \"NO DOWNDLOAD RESOURCE CONTENT OR YOU DO NOT HAVE THE RIGHT TO ACCESS THE CONTENT\");\n      return;\n    }\n    String userAgent = req.getHeader(\"User-Agent\");\n    if (dresource.getDownloadName() != null) {\n      if (userAgent != null && userAgent.contains(\"MSIE\")) {\n        res.setHeader(\n            \"Content-Disposition\",\n            \"attachment;filename=\\\"\"\n                + URLEncoder.encode(dresource.getDownloadName(), \"UTF-8\")\n                + \"\\\"\");\n      } else {\n        res.setHeader(\n            \"Content-Disposition\",\n            \"attachment; filename*=utf-8''\"\n                + URLEncoder.encode(dresource.getDownloadName(), \"UTF-8\")\n                + \"\");\n      }\n    }\n    res.setContentType(dresource.getResourceMimeType());\n    InputStream is = dresource.getInputStream();\n    byte[] buf = new byte[is.available()];\n    is.read(buf);\n    res.setContentType(dresource.getResourceMimeType());\n    res.getOutputStream().write(buf);\n    is.close();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2613, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["setException(*)"], "tryExpressionStart": 698, "tryExpressionEnd": 702, "tryBlockStart": 698, "tryBlockEnd": 837, "catchExpressionStart": 759, "catchExpressionEnd": 781, "catchBlockStart": 759, "catchBlockEnd": 837, "exceptionHandlingCallStart": [793], "exceptionHandlingCallEnd": [808], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 722, "focalAPIEnd": 747, "followUpCheck": "bytes <= off", "checkType": "IF", "followUpCheckExpressionStart": 846, "followUpCheckExpressionEnd": 861, "followUpCheckBlockStart": 846, "followUpCheckBlockEnd": 951, "use": ["max(bytes,int)", "arraycopy(byte[],int,byte[],int,bytes)"], "useStart": [2409, 2470], "useEnd": [2427, 2529], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jFastCGI/jfastcgi/tree/master/server/src/main/java/com/fastcgi/FCGIInputStream.java", "rawCode": "  /**\n   * Reads into an array of bytes. This method will block until some input is available.\n   *\n   * @param b the buffer into which the data is read\n   * @param off the start offset of the data\n   * @param len the maximum number of bytes read\n   * @return the actual number of bytes read, -1 is returned when the end of the stream is reached.\n   * @throws IOException If an I/O error has occurred.\n   */\n  public void fill() throws IOException {\n    byte[] headerBuf = new byte[FCGIConstants.BUFFER_HEADER_LENGTH];\n    int headerLen = 0;\n    int status = 0;\n    int count = 0;\n    while (true) {\n      /*\n       * If buffer is empty, do a read\n       */\n      if (rdNext == buffStop) {\n        try {\n          count = in.read(buff, 0, buffLen);\n        } catch (IOException e) {\n          setException(e);\n          return;\n        }\n        if (count <= 0) {\n          setFCGIError(FCGIConstants.ERROR_PROTOCOL_ERROR);\n          return;\n        }\n        rdNext = 0;\n        buffStop = count; // 1 more than we read\n      }\n      /*\n       * Now buf is not empty: If the current record contains more content\n       * bytes, deliver all that are present in buff to callers buffer\n       * unless he asked for less than we have, in which case give him\n       * less\n       */\n      if (contentLen > 0) {\n        count = Math.min(contentLen, buffStop - rdNext);\n        contentLen -= count;\n        if (!skip) {\n          stop = rdNext + count;\n          return;\n        } else {\n          rdNext += count;\n          if (contentLen > 0) {\n            continue;\n          } else {\n            skip = false;\n          }\n        }\n      }\n      /*\n       * Content has been consumed by client. If record was padded, skip\n       * over padding\n       */\n      if (paddingLen > 0) {\n        count = Math.min(paddingLen, buffStop - rdNext);\n        paddingLen -= count;\n        rdNext += count;\n        if (paddingLen > 0) {\n          continue; // more padding to read\n        }\n      }\n      /*\n       * All done with current record, including the padding. If we are in\n       * a recursive call from Process Header, deliver EOF\n       */\n      if (eorStop) {\n        stop = rdNext;\n        isClosed = true;\n        return;\n      }\n      /*\n       * Fill header with bytes from input buffer - get the whole header.\n       */\n      count = Math.min(headerBuf.length - headerLen, buffStop - rdNext);\n      count = Math.max(count, 0); // jr: why could it be negative ??\n      System.arraycopy(buff, rdNext, headerBuf, headerLen, count);\n      headerLen += count;\n      rdNext += count;\n      if (headerLen < headerBuf.length) {\n        continue;\n      }\n      headerLen = 0;\n      /*\n       * Interperet the header. eorStop prevents ProcessHeader from\n       * reading past the end of record when using stream to read content\n       */\n      eorStop = true;\n      stop = rdNext;\n      status = 0;\n      status = new FCGIMessage(this).processHeader(headerBuf);\n      eorStop = false;\n      isClosed = false;\n      switch (status) {\n        case FCGIConstants.HEADER_STREAM_RECORD:\n          if (contentLen == 0) {\n            stop = rdNext;\n            isClosed = true;\n            return;\n          }\n          break;\n        case FCGIConstants.HEADER_SKIP:\n          skip = true;\n          break;\n        case FCGIConstants.HEADER_BEGIN_RECORD:\n          /*\n           * If this header marked the beginning of a new request, return\n           * role info to caller\n           */\n          return;\n        case FCGIConstants.HEADER_MANAGEMENT_RECORD:\n          break;\n        default:\n          /*\n           * ASSERT\n           */\n          setFCGIError(status);\n          return;\n      }\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2614, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 112, "focalAPIEnd": 121, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.read()"], "useStart": [138], "useEnd": [147], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.quercus/src/main/java/com/caucho/java/JikesErrorParser.java", "rawCode": "  private int skipToNewline(InputStream is, int ch) throws IOException {\n    for (; ch >= 0 && ch != '\\n'; ch = is.read()) {}\n\n    return is.read();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2615, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "len>0", "guardType": "LOOP {", "guardExpressionStart": 124, "guardExpressionEnd": 140, "guardBlockStart": 124, "guardBlockEnd": 278, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 165, "focalAPIEnd": 187, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 195, "followUpCheckExpressionEnd": 215, "followUpCheckBlockStart": 195, "followUpCheckBlockEnd": 222, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Unidata/thredds/tree/master/cdm/src/main/java/ucar/nc2/stream/NcStream.java", "rawCode": "  public static int readFully(InputStream is, byte[] b) throws IOException {\n    int done = 0;\n    int want = b.length;\n    while (want > 0) {\n      int bytesRead = is.read(b, done, want);\n      if (bytesRead == -1) break;\n      done += bytesRead;\n      want -= bytesRead;\n    }\n    return done;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2616, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 498, "focalAPIEnd": 507, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/libcore/java/net/URLConnectionTest.java", "rawCode": "  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {\n    String body = \"ABCDEFGH\";\n    MockResponse response = new MockResponse();\n    transferKind.setBody(response, body, 4);\n    server.enqueue(response);\n    server.play();\n    URLConnection connection = server.getUrl(\"/\").openConnection();\n    InputStream in = connection.getInputStream();\n    for (int i = 0; i < body.length(); i++) {\n      assertTrue(in.available() >= 0);\n      assertEquals(body.charAt(i), in.read());\n    }\n    assertEquals(0, in.available());\n    assertEquals(-1, in.read());\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2617, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 65, "focalAPIEnd": 80, "followUpCheck": "bytes == 127", "checkType": "IF", "followUpCheckExpressionStart": 86, "followUpCheckExpressionEnd": 99, "followUpCheckBlockStart": 86, "followUpCheckBlockEnd": 131, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/matthoffman/blast-shell/tree/master/core/src/main/java/blast/shell/jline/BackspaceWrappingInputStream.java", "rawCode": "  @Override\n  public int read() throws IOException {\n    int c = delegate.read();\n    if (c == 127) return '\\b';\n    else return c;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2618, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["fillInStackTrace()"], "tryExpressionStart": 484, "tryExpressionEnd": 488, "tryBlockStart": 484, "tryBlockEnd": 787, "catchExpressionStart": 672, "catchExpressionEnd": 694, "catchBlockStart": 672, "catchBlockEnd": 787, "exceptionHandlingCallStart": [760], "exceptionHandlingCallEnd": [780], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 508, "focalAPIEnd": 518, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(byte[],int,bytes)"], "useStart": [792], "useEnd": [815], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.3.1/kernel-storage-util/src/main/java/org/sakaiproject/util/Blob.java", "rawCode": "  /**\n   * Reads bytes from an InputStream into the Blob.\n   *\n   * @param len The number of bytes to attempt to read.\n   * @param in The InputStream to read from.\n   * @return The number of bytes read and appended to the blob or -1 if the end of the stream was\n   *     reached.\n   * @exception java.io.IOException If there is a problem reading.\n   */\n  public synchronized int read(int len, InputStream in) throws IOException {\n\n    byte b[] = new byte[len];\n    int bytesRead;\n    try {\n      bytesRead = in.read(b);\n    } catch (EOFException e) {\n      // We'll just return a -1 just as if\n      // we had gotten a -1 in response from the read\n      return -1;\n\n    } catch (IOException e) {\n      // Throw this one to the caller\n      throw (IOException) e.fillInStackTrace();\n    }\n    append(b, 0, bytesRead);\n    return bytesRead;\n  } // end read();\n"}, {"dataset": "inputStreamRead", "exampleID": 2619, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": [], "tryExpressionStart": 430, "tryExpressionEnd": 434, "tryBlockStart": 430, "tryBlockEnd": 3577, "catchExpressionStart": 1985, "catchExpressionEnd": 2016, "catchBlockStart": 1985, "catchBlockEnd": 2058, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 482, "focalAPIEnd": 491, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 749, "followUpCheckExpressionEnd": 770, "followUpCheckBlockStart": 749, "followUpCheckBlockEnd": 875, "use": ["inputStream.read()", "inputStream.read()", "inputStream.read()", "inputStream.read(byte[],int,int)", "MySQLPacket.setInputStream(inputStream)"], "useStart": [516, 550, 684, 2872, 3329], "useEnd": [525, 559, 693, 2925, 3349], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/shutterstock/tungsten-replicator/tree/master/commons/src/java/com/continuent/tungsten/commons/mysql/MySQLPacket.java", "rawCode": "  /**\n   * Reads a MySQL packet from the input stream.\n   *\n   * @param in the data input stream from where we read the MySQL packet\n   * @param timeoutMillis Number of milliseconds we will pause while waiting for data from the the\n   *     network during a packet.\n   * @return a MySQLPacket object or null if the MySQL packet cannot be read\n   */\n  public static MySQLPacket readPacket(InputStream in, long timeoutMillis) {\n    try {\n      int mask = 0xff;\n      int packetLen1 = in.read();\n      int packetLen2 = in.read();\n      int packetLen3 = in.read();\n      int packetLen = (packetLen1 & mask) | (packetLen2 & mask) << 8 | (packetLen3 & mask) << 16;\n      int packetNumber = in.read();\n      // This is ok, no more packet on the line\n      if (packetLen1 == -1) {\n        logger.debug(\"Reached end of input stream while reading packet\");\n        return null;\n      }\n      // This is bad, client went away\n      if (packetLen2 == -1 || packetLen3 == -1 || packetNumber == -1) {\n        throw new EOFException(\"Reached end of input stream.\");\n      }\n\n      // read the body of the packet\n      byte[] packetData = new byte[packetLen + HEADER_LENGTH];\n      // copy header\n      packetData[0] = (byte) packetLen1;\n      packetData[1] = (byte) packetLen2;\n      packetData[2] = (byte) packetLen3;\n      packetData[3] = (byte) packetNumber;\n\n      // read() returns the number of actual bytes read, which might be\n      // less that the desired length this loop ensures that the whole\n      // packet is read\n      int n = 0;\n      while (n < packetLen) {\n        // Issue 281. Wait until at least one byte is available to avoid\n        // a possible out of data condition when reading from the\n        // network.\n        if (in.available() == 0) {\n          long readStartTime = System.currentTimeMillis();\n          long delay = -1;\n\n          // Sleep for up to timeout.\n          while (in.available() == 0) {\n            try {\n              Thread.sleep(10);\n            } catch (InterruptedException e) {\n              return null;\n            }\n            delay = System.currentTimeMillis() - readStartTime;\n            if (delay > timeoutMillis) {\n              break;\n            }\n          }\n\n          // Note the delay if longer than 10% of the timeout. This\n          // is helpful for diagnosing failures.\n          if (delay > (timeoutMillis / 10)) {\n            logger.info(\n                \"Paused to allow packet data to appear on the network: delay=\"\n                    + (delay / 1000.0)\n                    + \" timeout=\"\n                    + (timeoutMillis / 1000.0)\n                    + \" packetNumber=\"\n                    + packetNumber\n                    + \" packetlen=\"\n                    + packetLen\n                    + \" bytesRead=\"\n                    + n);\n          }\n        }\n\n        // Now read data.\n        int count = in.read(packetData, HEADER_LENGTH + n, packetLen - n);\n\n        if (count < 0) {\n          throw new EOFException(\n              \"Reached end of input stream: packetNumber=\"\n                  + packetNumber\n                  + \" packetlen=\"\n                  + packetLen\n                  + \" bytesRead=\"\n                  + n);\n        }\n\n        n += count;\n      }\n      MySQLPacket p = new MySQLPacket(packetLen, packetData, (byte) packetNumber);\n      p.setInputStream(in);\n      return p;\n    } catch (SocketTimeoutException e) {\n      logger.warn(\"Socket timeout expired, closing connection\");\n    } catch (IOException e) {\n      logger.error(\"I/O error while reading from client socket\", e);\n    }\n\n    return null;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2620, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["inputStream.skip(int)"], "configurationStart": [143], "configurationEnd": [152], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 164, "focalAPIEnd": 172, "followUpCheck": "bytes != -1", "checkType": "IF", "followUpCheckExpressionStart": 180, "followUpCheckExpressionEnd": 192, "followUpCheckBlockStart": 180, "followUpCheckBlockEnd": 218, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/libcore/java/io/OldAndroidPushbackInputStreamTest.java", "rawCode": "  public static String skipRead(InputStream a) throws IOException {\n    int r;\n    StringBuilder builder = new StringBuilder();\n    do {\n      a.skip(1);\n      r = a.read();\n      if (r != -1) builder.append((char) r);\n    } while (r != -1);\n    return builder.toString();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2621, "initialization": ["InputStream inputStream = URL.openStream()"], "initializationStart": [156], "initializationEnd": [172], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 291, "focalAPIEnd": 300, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 312, "followUpCheckExpressionEnd": 324, "followUpCheckBlockStart": 312, "followUpCheckBlockEnd": 377, "use": ["ByteArrayOutputStream.write(bytes)", "inputStream.close()"], "useStart": [388, 439], "useEnd": [401, 449], "hasFinally": 1, "cleanUpCall": ["InputStream.close()"], "finallyExpressionStart": 421, "finallyExpressionEnd": 429, "finallyBlockStart": 421, "finallyBlockEnd": 458, "cleanUpCallStart": [439], "cleanUpCallEnd": [449], "url": "https://github.com/ether/pad/tree/master/infrastructure/rhino1_7R1/src/org/mozilla/javascript/SecureCaller.java", "rawCode": "  private static byte[] loadBytecodePrivileged() {\n    URL url = SecureCaller.class.getResource(\"SecureCallerImpl.clazz\");\n    try {\n      InputStream in = url.openStream();\n      try {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        for (; ; ) {\n          int r = in.read();\n          if (r == -1) {\n            return bout.toByteArray();\n          }\n          bout.write(r);\n        }\n      } finally {\n        in.close();\n      }\n    } catch (IOException e) {\n      throw new UndeclaredThrowableException(e);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2622, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 192, "focalAPIEnd": 201, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/plugins/image/ext/src/sanselan-0.97-incubator/src/main/java/org/apache/sanselan/common/BinaryFileFunctions.java", "rawCode": "  public final byte[] readBytes(InputStream is, int count) throws ImageReadException, IOException {\n    byte result[] = new byte[count];\n    for (int i = 0; i < count; i++) {\n      int data = is.read();\n      result[i] = (byte) data;\n    }\n    return result;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2623, "initialization": ["InputStream inputStream = Socket.getInputStream()"], "initializationStart": [393], "initializationEnd": [411], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 76, "tryExpressionEnd": 80, "tryBlockStart": 76, "tryBlockEnd": 910, "catchExpressionStart": 665, "catchExpressionEnd": 687, "catchBlockStart": 665, "catchBlockEnd": 737, "exceptionHandlingCallStart": [695], "exceptionHandlingCallEnd": [730], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 542, "focalAPIEnd": 559, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["Socket.close()"], "finallyExpressionStart": 738, "finallyExpressionEnd": 746, "finallyBlockStart": 738, "finallyBlockEnd": 910, "cleanUpCallStart": [795], "cleanUpCallEnd": [804], "url": "https://github.com/elka-projekt/cs-voltdb/tree/master/third_party/java/src/org/apache/zookeeper_voltpatches/ServerAdminClient.java", "rawCode": "  public static void dump(String host, int port) {\n    Socket s = null;\n    try {\n      byte[] reqBytes = new byte[4];\n      ByteBuffer req = ByteBuffer.wrap(reqBytes);\n      req.putInt(ByteBuffer.wrap(\"dump\".getBytes()).getInt());\n      s = new Socket();\n      s.setSoLinger(false, 10);\n      s.setSoTimeout(20000);\n      s.connect(new InetSocketAddress(host, port));\n\n      InputStream is = s.getInputStream();\n      OutputStream os = s.getOutputStream();\n\n      os.write(reqBytes);\n\n      byte[] resBytes = new byte[1024];\n\n      int rc = is.read(resBytes);\n      String retv = new String(resBytes);\n      System.out.println(\"rc=\" + rc + \" retv=\" + retv);\n    } catch (IOException e) {\n      LOG.warn(\"Unexpected exception\", e);\n    } finally {\n      if (s != null) {\n        try {\n          s.close();\n        } catch (IOException e) {\n          LOG.warn(\"Unexpected exception\", e);\n        }\n      }\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2624, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 533, "focalAPIEnd": 542, "followUpCheck": "bytes < 0 || true", "checkType": "IF", "followUpCheckExpressionStart": 1329, "followUpCheckExpressionEnd": 1350, "followUpCheckBlockStart": 1329, "followUpCheckBlockEnd": 1357, "use": ["inputStream.read()"], "useStart": [1274], "useEnd": [1283], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thomasbecker/jetty-7/tree/master/jetty-util/src/main/java/org/eclipse/jetty/util/UrlEncoded.java", "rawCode": "  /**\n   * Decoded parameters to Map.\n   *\n   * @param in InputSteam to read\n   * @param map MultiMap to add parameters to\n   * @param maxLength maximum length of content to read 0r -1 for no limit\n   */\n  public static void decode88591To(InputStream in, MultiMap map, int maxLength) throws IOException {\n    synchronized (map) {\n      StringBuffer buffer = new StringBuffer();\n      String key = null;\n      String value = null;\n\n      int b;\n\n      // TODO cache of parameter names ???\n      int totalLength = 0;\n      while ((b = in.read()) >= 0) {\n        switch ((char) b) {\n          case '&':\n            value = buffer.length() == 0 ? \"\" : buffer.toString();\n            buffer.setLength(0);\n            if (key != null) {\n              map.add(key, value);\n            } else if (value != null && value.length() > 0) {\n              map.add(value, \"\");\n            }\n            key = null;\n            value = null;\n            break;\n\n          case '=':\n            if (key != null) {\n              buffer.append((char) b);\n              break;\n            }\n            key = buffer.toString();\n            buffer.setLength(0);\n            break;\n\n          case '+':\n            buffer.append(' ');\n            break;\n\n          case '%':\n            int dh = in.read();\n            int dl = in.read();\n            if (dh < 0 || dl < 0) break;\n            buffer.append(\n                (char)\n                    ((TypeUtil.convertHexDigit((byte) dh) << 4)\n                        + TypeUtil.convertHexDigit((byte) dl)));\n            break;\n          default:\n            buffer.append((char) b);\n            break;\n        }\n        if (maxLength >= 0 && (++totalLength > maxLength))\n          throw new IllegalStateException(\"Form too large\");\n      }\n\n      if (key != null) {\n        value = buffer.length() == 0 ? \"\" : buffer.toString();\n        buffer.setLength(0);\n        map.add(key, value);\n      } else if (buffer.length() > 0) {\n        map.add(buffer.toString(), \"\");\n      }\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2625, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 186, "focalAPIEnd": 195, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spring-projects/spring-integration/tree/master/spring-integration-ip/src/test/java/org/springframework/integration/ip/tcp/TcpReceivingChannelAdapterTests.java", "rawCode": "  /**\n   * @param is\n   * @param buff\n   */\n  private void readFully(InputStream is, byte[] buff) throws IOException {\n    for (int i = 0; i < buff.length; i++) {\n      buff[i] = (byte) is.read();\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2626, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["toString()", "println(*)"], "tryExpressionStart": 127, "tryExpressionEnd": 131, "tryBlockStart": 127, "tryBlockEnd": 1485, "catchExpressionStart": 1396, "catchExpressionEnd": 1418, "catchBlockStart": 1396, "catchBlockEnd": 1485, "exceptionHandlingCallStart": [1445, 1426], "exceptionHandlingCallEnd": [1457, 1458], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "inputStream.available()>0", "guardType": "IF {", "guardExpressionStart": 932, "guardExpressionEnd": 955, "guardBlockStart": 932, "guardBlockEnd": 1084, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 976, "focalAPIEnd": 985, "followUpCheck": "bytes != '.'", "checkType": "IF", "followUpCheckExpressionStart": 997, "followUpCheckExpressionEnd": 1010, "followUpCheckBlockStart": 997, "followUpCheckBlockEnd": 1024, "use": ["inputStream.read()"], "useStart": [1155], "useEnd": [1164], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/concurrency/new-kroc-repo-test-2-do-not-clone/tree/master/tvm/srv1/programs/SRV.java", "rawCode": "  public boolean upload(byte[] bytecode) {\n    if (out == null) return false;\n    if (bytecode.length < 20) return false;\n\n    try {\n      System.err.println(\"Sending kill command.\");\n      sendCommand(CMD_KILL);\n      sendCommand(CMD_KILL);\n      sendCommand(CMD_KILL);\n      sendCommand(CMD_KILL);\n\n      waitForResponse(\"Send 'U' to begin\", 2000);\n\n      System.err.println(\"Sending upload command.\");\n      sendCommand(CMD_UPLOAD);\n\n      System.err.println(\"Waiting...\");\n      if (!waitForResponse(\"Waiting for header\", 3000)) return false;\n\n      System.err.println(\"Sending header...\");\n      for (int i = 0; i < 20; ++i) out.write(bytecode[i]);\n\n      System.err.println(\"Waiting...\");\n      if (!waitForResponse(\"Waiting for bytecode\", 3000)) return false;\n\n      System.err.println(\"Uploading bytecode...\");\n\n      int ack = 0;\n\n      for (int i = 20; i < bytecode.length; ++i) {\n        out.write(bytecode[i]);\n\n        if (in.available() > 0) {\n          int c = in.read();\n          if (c != '.') return false;\n          System.err.print(\".\");\n          ack++;\n        }\n      }\n\n      while (ack < (bytecode.length - 20)) {\n        int c = in.read();\n        if (c != '.') return false;\n        System.err.print(\".\");\n        ack++;\n      }\n\n      if (in.read() != '\\n') return false;\n\n      System.err.println(\"\");\n      System.err.println(\"Complete!\");\n\n      return true;\n    } catch (IOException e) {\n      System.out.println(e.toString());\n      return false;\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2627, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 559, "focalAPIEnd": 585, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/deruelle/mobicents/tree/master/servers/sip-servlets/sip-servlets-impl/src/main/java/org/mobicents/servlet/sip/annotations/SipApplicationAnnotationUtils.java", "rawCode": "  /**\n   * Determine if this stream contains SipApplication annotations\n   *\n   * <p>TODO: HACK: FIXME: This method reads raw class file trying to determine if it uses the\n   * SIpApplication annotation. This seems to be reliable and a lot faster than using a classloader,\n   * but can be reviewed in the future especially when JBoss AS 5.0 is available with the new\n   * deployer.\n   */\n  public static boolean findSipApplicationAnnotation(InputStream stream) {\n    try {\n      byte[] rawClassBytes;\n      rawClassBytes = new byte[stream.available()];\n      stream.read(rawClassBytes);\n      boolean one = contains(rawClassBytes, SIP_APPLICATION_BYTES);\n      boolean two = contains(rawClassBytes, ANNOTATION_BYTES);\n      if (one && two) return true;\n    } catch (Exception e) {\n    }\n    return false;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2628, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 93, "focalAPIEnd": 102, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.read()", "inputStream.read()", "inputStream.read()"], "useStart": [128, 163, 196], "useEnd": [137, 172, 205], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/poidasmith/xlloop/tree/master/org.boris.xlloop/java/src/org/boris/xlloop/codec/BinaryCodec.java", "rawCode": "  private static long readDoubleWord(InputStream is) throws IOException {\n    return ((long) is.read() << 24)\n        | ((long) is.read() << 16)\n        | ((long) is.read() << 8)\n        | (long) is.read();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2629, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 713, "focalAPIEnd": 722, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 732, "followUpCheckExpressionEnd": 744, "followUpCheckBlockStart": 732, "followUpCheckBlockEnd": 814, "use": ["BufferedOutputStream.write(bytes)"], "useStart": [791], "useEnd": [803], "hasFinally": 1, "cleanUpCall": ["BufferedOutputStream.close()"], "finallyExpressionStart": 916, "finallyExpressionEnd": 924, "finallyBlockStart": 916, "finallyBlockEnd": 950, "cleanUpCallStart": [932], "cleanUpCallEnd": [943], "url": "https://github.com/guyrixon/XSAMS-views-webapp/tree/master/src/main/java/eu/vamdc/xsams/views/DataCache.java", "rawCode": "  /**\n   * Reads data from a stream and writes them to a file.\n   *\n   * @param in The data to be read.\n   * @param f The file to receive the data.\n   * @return The number of bytes read.\n   * @throws FileNotFoundException If the given file does not exist.\n   * @throws IOException If the stream cannot be read.\n   * @throws IOException If the the file cannot be written.\n   * @throws DownloadException if the stream gave no bytes.\n   */\n  private void readFromStream(InputStream in, File f)\n      throws FileNotFoundException, IOException, DownloadException {\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(f));\n    try {\n      long n;\n      for (n = 0; true; n++) {\n        int c = in.read();\n        if (c == -1) {\n          break;\n        } else {\n          out.write(c);\n        }\n      }\n      if (n == 0L) {\n        throw new DownloadException(\"No data were read\");\n      }\n    } finally {\n      out.close();\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2630, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 598, "tryExpressionEnd": 602, "tryBlockStart": 598, "tryBlockEnd": 1690, "catchExpressionStart": 1617, "catchExpressionEnd": 1644, "catchBlockStart": 1617, "catchBlockEnd": 1684, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(inputStream==null)", "guardType": "IF {", "guardExpressionStart": 434, "guardExpressionEnd": 458, "guardBlockStart": 434, "guardBlockEnd": 516, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 618, "focalAPIEnd": 642, "followUpCheck": "bytes >= b.length", "checkType": "LOOP {", "followUpCheckExpressionStart": 650, "followUpCheckExpressionEnd": 676, "followUpCheckBlockStart": 650, "followUpCheckBlockEnd": 1160, "use": ["inputStream.read(byte[])", "arraycopy(byte[],int,byte[],*,bytes)", "inputStream.close()"], "useStart": [1127, 1460, 1588], "useEnd": [1151, 1515, 1607], "hasFinally": 1, "cleanUpCall": ["InputStream.close()"], "finallyExpressionStart": 1558, "finallyExpressionEnd": 1566, "finallyBlockStart": 1558, "finallyBlockEnd": 1690, "cleanUpCallStart": [1588], "cleanUpCallEnd": [1607], "url": "https://github.com/amorfis/hibernate/tree/master/hibernate-core/src/main/java/org/hibernate/bytecode/spi/ByteCodeHelper.java", "rawCode": "  /**\n   * Reads class byte array info from the given input stream.\n   *\n   * <p>The stream is closed within this method!\n   *\n   * @param inputStream The stream containing the class binary; null will lead to an {@link\n   *     IOException}\n   * @return The read bytes\n   * @throws IOException Indicates a problem accessing the given stream.\n   */\n  public static byte[] readByteCode(InputStream inputStream) throws IOException {\n    if (inputStream == null) {\n      throw new IOException(\"null input stream\");\n    }\n\n    byte[] buffer = new byte[409600];\n    byte[] classBytes = new byte[0];\n\n    try {\n      int r = inputStream.read(buffer);\n      while (r >= buffer.length) {\n        byte[] temp = new byte[classBytes.length + buffer.length];\n        // copy any previously read bytes into the temp array\n        System.arraycopy(classBytes, 0, temp, 0, classBytes.length);\n        // copy the just read bytes into the temp array (after the previously read)\n        System.arraycopy(buffer, 0, temp, classBytes.length, buffer.length);\n        classBytes = temp;\n        // read the next set of bytes into buffer\n        r = inputStream.read(buffer);\n      }\n      if (r != -1) {\n        byte[] temp = new byte[classBytes.length + r];\n        // copy any previously read bytes into the temp array\n        System.arraycopy(classBytes, 0, temp, 0, classBytes.length);\n        // copy the just read bytes into the temp array (after the previously read)\n        System.arraycopy(buffer, 0, temp, classBytes.length, r);\n        classBytes = temp;\n      }\n    } finally {\n      try {\n        inputStream.close();\n      } catch (IOException ignore) {\n        // intentionally empty\n      }\n    }\n\n    return classBytes;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2631, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 84, "focalAPIEnd": 93, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.skip(int)", "inputStream.skip(int)", "inputStream.skip(int)", "scanAnnotation(inputStream)", "readShort(inputStream)", "skipElementValue(inputStream)"], "useStart": [268, 320, 372, 424, 494, 559], "useEnd": [278, 330, 382, 442, 507, 579], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.quercus/src/main/java/com/caucho/bytecode/ByteCodeClassScanner.java", "rawCode": "  private void skipElementValue(InputStream is) throws IOException {\n    int code = is.read();\n\n    switch (code) {\n      case 'B':\n      case 'C':\n      case 'D':\n      case 'F':\n      case 'I':\n      case 'J':\n      case 'S':\n      case 'Z':\n      case 's':\n        is.skip(2);\n        return;\n      case 'e':\n        is.skip(4);\n        return;\n      case 'c':\n        is.skip(2);\n        return;\n      case '@':\n        scanAnnotation(is);\n        return;\n      case '[':\n        int len = readShort(is);\n        for (int i = 0; i < len; i++) {\n          skipElementValue(is);\n        }\n        return;\n      default:\n        throw new IllegalStateException(\"unknown code: \" + (char) code);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2632, "initialization": ["InputStream inputStream = HttpServletRequest.getInputStream()"], "initializationStart": [1259], "initializationEnd": [1283], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "error(*,*)", "JSONObject.put(String,boolean)"], "tryExpressionStart": 321, "tryExpressionEnd": 325, "tryBlockStart": 321, "tryBlockEnd": 4377, "catchExpressionStart": 4099, "catchExpressionEnd": 4119, "catchBlockStart": 4099, "catchBlockEnd": 4377, "exceptionHandlingCallStart": [4140, 4127, 4180], "exceptionHandlingCallEnd": [4154, 4158, 4206], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "off<i", "guardType": "LOOP {", "guardExpressionStart": 1291, "guardExpressionEnd": 1304, "guardBlockStart": 1291, "guardBlockEnd": 1373, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 1323, "focalAPIEnd": 1348, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rongjihuang/bc-framework/tree/master/bc-docs/src/main/java/cn/bc/docs/web/Html5FileUploadServlet.java", "rawCode": "  public void doPost4Html5(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    String source = \"\"; // 用户原始的本地文件路径信息\n    String subdir = request.getParameter(\"subdir\"); // 子路径\n    if (subdir == null) subdir = \"\";\n    JSONObject json = new JSONObject(); // 返回的信息\n\n    try {\n      // 获取当前用户信息\n      SystemContext context = (SystemContext) request.getSession().getAttribute(Context.KEY);\n      if (context == null) {\n        json.put(\"success\", false);\n        json.put(\"msg\", \"用户未登录或登录超时！\");\n        writeReturnJson(response, json);\n        return;\n      }\n\n      // 获取上传文件名\n      source = URLDecoder.decode(getHtml5FileName(request), \"UTF-8\");\n\n      // 获取扩展名\n      String extension = getExtension(source);\n\n      // 检查文件类型\n      if (!StringUtils.isEmpty(extensions)\n          && (\",\" + extensions.toLowerCase() + \",\").indexOf(\",\" + extension.toLowerCase() + \",\")\n              == -1) {\n        json.put(\"success\", false);\n        json.put(\"msg\", \"不允许上传此类型的文件\");\n        writeReturnJson(response, json);\n        return;\n      }\n\n      // 获取上传文件流\n      int i = request.getContentLength();\n      logger.debug(\"contentLength={}\", i);\n      byte buffer[] = new byte[i];\n      int j = 0;\n      InputStream in = request.getInputStream();\n      while (j < i) {\n        int k = in.read(buffer, j, i - j);\n        j += k;\n      }\n\n      // 检查文件是否为空\n      int size = buffer.length;\n      if (size == 0) {\n        json.put(\"success\", false);\n        json.put(\"msg\", \"传文件不能为空\");\n        writeReturnJson(response, json);\n        return;\n      }\n\n      // 检查文件大小是否超限\n      if (maxSize > 0 && size > maxSize) {\n        json.put(\"success\", false);\n        json.put(\"msg\", \"上传文件的大小超出限制\");\n        writeReturnJson(response, json);\n        return;\n      }\n\n      // 文件存储的相对路径（年月），避免超出目录内文件数的限制\n      Calendar now = Calendar.getInstance();\n      String datedir = new SimpleDateFormat(\"yyyyMM\").format(now.getTime());\n\n      // 要保存的物理文件\n      String realpath; // 绝对路径名\n      String fileName =\n          new SimpleDateFormat(\"yyyyMMddHHmmssSSSS\").format(now.getTime())\n              + \".\"\n              + extension; // 不含路径的文件名\n      realpath =\n          Attach.DATA_REAL_PATH\n              + (subdir.length() > 0 ? \"/\" + subdir : \"\")\n              + \"/\"\n              + datedir\n              + \"/\"\n              + fileName;\n\n      // 构建文件要保存到的目录\n      File file = new File(realpath);\n      if (!file.getParentFile().exists()) {\n        if (logger.isWarnEnabled()) {\n          logger.warn(\"mkdir={}\", file.getParentFile().getAbsolutePath());\n        }\n        file.getParentFile().mkdirs();\n      }\n\n      // 根目录下的子路径名\n      String path = (subdir.length() > 0 ? subdir + \"/\" : \"\") + datedir + \"/\" + fileName;\n\n      // 创建文件上传日志\n      String ptype = request.getParameter(\"ptype\");\n      String puid = request.getParameter(\"puid\");\n      if (ptype != null && puid != null) {\n        AttachHistory history = new AttachHistory();\n        history.setPtype(ptype);\n        history.setPuid(puid);\n        history.setType(AttachHistory.TYPE_UPLOAD);\n        history.setAuthor(context.getUserHistory());\n        history.setFileDate(now);\n        history.setPath(path);\n        history.setAppPath(false);\n        history.setFormat(extension);\n        history.setSubject(source);\n        String[] c = WebUtils.getClient(request);\n        history.setClientIp(c[0]);\n        history.setClientInfo(c[2]);\n        this.getAttachService().saveHistory(history);\n      } else {\n        logger.warn(\"没有指定ptype、puid参数，不保存文件上传记录\");\n      }\n\n      // 保存到文件\n      OutputStream out = new BufferedOutputStream(new FileOutputStream(realpath));\n      out.write(buffer);\n      out.close();\n\n      // 返回成功信息\n      json.put(\"success\", true);\n      json.put(\"msg\", \"上传成功\");\n      json.put(\"rootdir\", Attach.DATA_REAL_PATH); // 根目录名\n      json.put(\"subdir\", subdir); // 子目录名\n      json.put(\"to\", datedir + \"/\" + fileName); // 子目录下的子路径名\n      json.put(\"file\", path);\n      json.put(\"source\", source); // 用户原始的本地文件路径信息\n      json.put(\"size\", size); // 文件大小\n      writeReturnJson(response, json);\n    } catch (Exception e) {\n      logger.error(e.getMessage(), e);\n      try {\n        json.put(\"success\", false);\n        json.put(\"msg\", e.getMessage());\n      } catch (JSONException e1) {\n        logger.error(e.getMessage(), e);\n      }\n      writeReturnJson(response, json);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2633, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 81, "focalAPIEnd": 95, "followUpCheck": "bytes != CR", "checkType": "IF", "followUpCheckExpressionStart": 103, "followUpCheckExpressionEnd": 116, "followUpCheckBlockStart": 103, "followUpCheckBlockEnd": 192, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/funambol-mirror/funambol-client-sdk/tree/master/v911/common/src/main/java-me/com/funambol/platform/HttpConnectionAdapter.java", "rawCode": "    private void readCR(InputStream aStream) throws IOException {\n      int cr = aStream.read();\n      if (cr != CR) {\n        throw new IOException(\"Expected CR char in InputStream\");\n      }\n    }\n"}, {"dataset": "inputStreamRead", "exampleID": 2634, "initialization": ["InputStream inputStream = Class<?>.getResourceAsStream(String)"], "initializationStart": [858], "initializationEnd": [889], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(true||path.length()==off) && inputStream!=null", "guardType": "IF {", "guardExpressionStart": 637, "guardExpressionEnd": 653, "guardBlockStart": 637, "guardBlockEnd": 761, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 1050, "focalAPIEnd": 1079, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.close()"], "useStart": [1156], "useEnd": [1166], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dalezak/FrontlineSMS/tree/master/src/main/java/net/frontlinesms/FrontlineUtils.java", "rawCode": "  /**\n   * Creates an image from the specified resource. To speed up loading the same images use a cache\n   * (a simple hashtable). And flush the resources being used by an image when you won't use it\n   * henceforward\n   *\n   * @param path is relative or the classpath, or an URL\n   * @param clazz TODO\n   * @return the loaded image or null\n   */\n  public static Image getImage(String path, Class<?> clazz) {\n    if ((path == null) || (path.length() == 0)) {\n      return null;\n    }\n    Image image = null; // (Image) imagepool.get(path);\n    try {\n      URL url = clazz.getResource(path); // ClassLoader.getSystemResource(path)\n      if (url != null) { // contributed by Stefan Matthias Aust\n        image = Toolkit.getDefaultToolkit().getImage(url);\n      }\n    } catch (Throwable e) {\n    }\n    if (image == null) {\n      try {\n        InputStream is = clazz.getResourceAsStream(path);\n        // InputStream is = ClassLoader.getSystemResourceAsStream(path);\n        if (is != null) {\n          byte[] data = new byte[is.available()];\n          is.read(data, 0, data.length);\n          image = Toolkit.getDefaultToolkit().createImage(data);\n          is.close();\n        } else { // contributed by Wolf Paulus\n          image = Toolkit.getDefaultToolkit().getImage(new URL(path));\n        }\n      } catch (Throwable e) {\n      }\n    }\n    return image;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2635, "initialization": ["InputStream inputStream = URL.openStream()"], "initializationStart": [359], "initializationEnd": [375], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 619, "focalAPIEnd": 660, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/liucong/jms4cxf2/tree/master/integration/jca/src/test/java/org/apache/cxf/jca/core/classloader/PlugInClassLoaderTest.java", "rawCode": "  @Test\n  public void testLoadResourceWithPluginClassLoader() throws Exception {\n    Class resultClass = plugInClassLoader.loadClass(\"org.apache.cxf.jca.dummy.Dummy\");\n    URL url = resultClass.getResource(\"dummy.txt\");\n    LOG.info(\"URL: \" + url);\n    assertTrue(\"bad url: \" + url, url.toString().startsWith(\"classloader:\"));\n\n    InputStream configStream = url.openStream();\n    assertNotNull(\"stream must not be null. \", configStream);\n    assertTrue(\n        \"unexpected stream class: \" + configStream.getClass(),\n        configStream instanceof java.io.ByteArrayInputStream);\n\n    byte[] bytes = new byte[10];\n    configStream.read(bytes, 0, bytes.length);\n\n    String result = IOUtils.newStringFromBytes(bytes);\n    LOG.fine(\"dummy.txt contents: \" + result);\n    assertEquals(\"unexpected dummy.txt contents.\", \"blah,blah.\", result);\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2636, "initialization": ["InputStream inputStream = new BufferedInputStream(*)"], "initializationStart": [739], "initializationEnd": [780], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new RuntimeException(String,*)"], "tryExpressionStart": 635, "tryExpressionEnd": 639, "tryBlockStart": 635, "tryBlockEnd": 1292, "catchExpressionStart": 1176, "catchExpressionEnd": 1198, "catchBlockStart": 1176, "catchBlockEnd": 1292, "exceptionHandlingCallStart": [1212], "exceptionHandlingCallEnd": [1285], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 1047, "focalAPIEnd": 1056, "followUpCheck": "bytes < 0", "checkType": "IF", "followUpCheckExpressionStart": 1081, "followUpCheckExpressionEnd": 1091, "followUpCheckBlockStart": 1081, "followUpCheckBlockEnd": 1120, "use": ["ByteArrayOutputStream.write(bytes)", "inputStream.close()"], "useStart": [1129, 1158], "useEnd": [1142, 1168], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/H2-Mirror/tree/master/h2/src/tools/org/h2/build/BuildBase.java", "rawCode": "  /**\n   * Download a file if it does not yet exist. If no checksum is used (that is, if the parameter is\n   * null), the checksum is printed. For security, checksums should always be used.\n   *\n   * @param target the target file name\n   * @param fileURL the source url of the file\n   * @param sha1Checksum the SHA-1 checksum or null\n   */\n  protected void download(String target, String fileURL, String sha1Checksum) {\n    File targetFile = new File(target);\n    if (targetFile.exists()) {\n      return;\n    }\n    mkdirs(targetFile.getAbsoluteFile().getParentFile());\n    ByteArrayOutputStream buff = new ByteArrayOutputStream();\n    try {\n      println(\"Downloading \" + fileURL);\n      URL url = new URL(fileURL);\n      InputStream in = new BufferedInputStream(url.openStream());\n      long last = System.currentTimeMillis();\n      int len = 0;\n      while (true) {\n        long now = System.currentTimeMillis();\n        if (now > last + 1000) {\n          println(\"Downloaded \" + len + \" bytes\");\n          last = now;\n        }\n        int x = in.read();\n        len++;\n        if (x < 0) {\n          break;\n        }\n        buff.write(x);\n      }\n      in.close();\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error downloading \" + fileURL + \" to \" + target, e);\n    }\n    byte[] data = buff.toByteArray();\n    String got = getSHA1(data);\n    if (sha1Checksum == null) {\n      println(\"SHA1 checksum: \" + got);\n    } else {\n      if (!got.equals(sha1Checksum)) {\n        throw new RuntimeException(\n            \"SHA1 checksum mismatch; got: \"\n                + got\n                + \" expected: \"\n                + sha1Checksum\n                + \" for file \"\n                + target);\n      }\n    }\n    writeFile(targetFile, data);\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2637, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["fillInStackTrace()"], "tryExpressionStart": 484, "tryExpressionEnd": 488, "tryBlockStart": 484, "tryBlockEnd": 787, "catchExpressionStart": 672, "catchExpressionEnd": 694, "catchBlockStart": 672, "catchBlockEnd": 787, "exceptionHandlingCallStart": [760], "exceptionHandlingCallEnd": [780], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 508, "focalAPIEnd": 518, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(byte[],int,bytes)"], "useStart": [792], "useEnd": [815], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/SAK-18559/kernel-util/src/main/java/org/sakaiproject/util/Blob.java", "rawCode": "  /**\n   * Reads bytes from an InputStream into the Blob.\n   *\n   * @param len The number of bytes to attempt to read.\n   * @param in The InputStream to read from.\n   * @return The number of bytes read and appended to the blob or -1 if the end of the stream was\n   *     reached.\n   * @exception java.io.IOException If there is a problem reading.\n   */\n  public synchronized int read(int len, InputStream in) throws IOException {\n\n    byte b[] = new byte[len];\n    int bytesRead;\n    try {\n      bytesRead = in.read(b);\n    } catch (EOFException e) {\n      // We'll just return a -1 just as if\n      // we had gotten a -1 in response from the read\n      return -1;\n\n    } catch (IOException e) {\n      // Throw this one to the caller\n      throw (IOException) e.fillInStackTrace();\n    }\n    append(b, 0, bytesRead);\n    return bytesRead;\n  } // end read();\n"}, {"dataset": "inputStreamRead", "exampleID": 2638, "initialization": ["int len = max(*,int)"], "initializationStart": [614], "initializationEnd": [664], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["inputStream.available()"], "configurationStart": [623], "configurationEnd": [641], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 1050, "focalAPIEnd": 1104, "followUpCheck": "bytes > 0", "checkType": "IF", "followUpCheckExpressionStart": 1115, "followUpCheckExpressionEnd": 1134, "followUpCheckBlockStart": 1115, "followUpCheckBlockEnd": 1227, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/panchenko/org.eclipse.dltk.core/tree/master/core/plugins/org.eclipse.dltk.core/compiler/org/eclipse/dltk/compiler/util/Util.java", "rawCode": "  /**\n   * Returns the given input stream's contents as a byte array. If a length is specified (ie. if\n   * length != -1), only length bytes are returned. Otherwise all bytes in the stream are returned.\n   * Note this doesn't close the stream.\n   *\n   * @throws IOException if a problem occured reading the stream.\n   */\n  public static byte[] getInputStreamAsByteArray(InputStream stream, int length)\n      throws IOException {\n    byte[] contents;\n    if (length == -1) {\n      contents = new byte[0];\n      int contentsLength = 0;\n      int amountRead = -1;\n      do {\n        int amountRequested =\n            Math.max(stream.available(), DEFAULT_READING_SIZE); // read at least 8K\n\n        // resize contents if needed\n        if (contentsLength + amountRequested > contents.length) {\n          System.arraycopy(\n              contents,\n              0,\n              contents = new byte[contentsLength + amountRequested],\n              0,\n              contentsLength);\n        }\n\n        // read as many bytes as possible\n        amountRead = stream.read(contents, contentsLength, amountRequested);\n\n        if (amountRead > 0) {\n          // remember length of contents\n          contentsLength += amountRead;\n        }\n      } while (amountRead != -1);\n\n      // resize contents if necessary\n      if (contentsLength < contents.length) {\n        System.arraycopy(contents, 0, contents = new byte[contentsLength], 0, contentsLength);\n      }\n    } else {\n      contents = new byte[length];\n      int len = 0;\n      int readSize = 0;\n      while ((readSize != -1) && (len != length)) {\n        // See PR 1FMS89U\n        // We record first the read size. In this case len is the actual\n        // read size.\n        len += readSize;\n        readSize = stream.read(contents, len, length - len);\n      }\n    }\n\n    return contents;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2639, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 693, "focalAPIEnd": 708, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 721, "followUpCheckExpressionEnd": 741, "followUpCheckBlockStart": 721, "followUpCheckBlockEnd": 1019, "use": ["increasePosition(bytes)", "ByteArrayOutputStream.write(byte[],int,bytes)", "inputStream.read(byte[],int,int)", "increasePosition(bytes)"], "useStart": [899, 975, 1435, 1530], "useEnd": [926, 1006, 1488, 1557], "hasFinally": 1, "cleanUpCall": ["ByteArrayOutputStream.toByteArray()"], "finallyExpressionStart": 1038, "finallyExpressionEnd": 1046, "finallyBlockStart": 1038, "finallyBlockEnd": 1089, "cleanUpCallStart": [1063], "cleanUpCallEnd": [1080], "url": "https://github.com/jubianchi/gdpjam2/tree/master/pulpcore-0.11.5/src/src/pulpcore/net/Download.java", "rawCode": "  /** @return true if the data length should be double-checked with a head request. */\n  private boolean downloadData(InputStream in) throws IOException {\n\n    if (size == -1) {\n\n      ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n      if (startPosition > 0) {\n        if (data == null || startPosition > data.length) {\n          // Permanent Error - don't automatically retry\n          setState(ERROR);\n          setErrorMessage(\"Bad Content-Range\");\n          return false;\n        }\n        out.write(data, 0, startPosition);\n      }\n\n      data = null;\n      byte[] buffer = new byte[BUFFER_SIZE];\n\n      try {\n        while (state == DOWNLOADING) {\n          int bytesRead = in.read(buffer);\n\n          if (bytesRead == -1) {\n            // Either the download is finished, or there was a connection error\n            return true;\n          } else if (bytesRead > 0) {\n            increasePosition(bytesRead);\n            markRestartPosition();\n            out.write(buffer, 0, bytesRead);\n          }\n        }\n      } finally {\n        data = out.toByteArray();\n      }\n    } else {\n      if (data == null) {\n        data = new byte[size];\n      } else if (data.length < size) {\n        byte[] newData = new byte[size];\n        System.arraycopy(data, 0, newData, 0, data.length);\n        data = newData;\n      }\n\n      while (state == DOWNLOADING) {\n        int pos = getCurrentPosition();\n\n        int bytesRead = in.read(data, pos, Math.min(BUFFER_SIZE, size - pos));\n\n        if (bytesRead > 0) {\n          increasePosition(bytesRead);\n          markRestartPosition();\n        }\n\n        if (getCurrentPosition() >= size) {\n          setState(SUCCESS);\n        } else if (bytesRead == -1) {\n          throw new IOException(\"Closed Prematurely\");\n        }\n      }\n    }\n    return false;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2640, "initialization": ["InputStream inputStream = ZipFile.getInputStream(ZipEntry)"], "initializationStart": [336], "initializationEnd": [361], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getName()", "new RuntimeException(String,*)"], "tryExpressionStart": 85, "tryExpressionEnd": 89, "tryBlockStart": 85, "tryBlockEnd": 698, "catchExpressionStart": 574, "catchExpressionEnd": 594, "catchBlockStart": 574, "catchBlockEnd": 698, "exceptionHandlingCallStart": [669, 608], "exceptionHandlingCallEnd": [687, 691], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 420, "focalAPIEnd": 435, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.close()"], "useStart": [445], "useEnd": [456], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mDiyo/InfiCraft/tree/master/inficraft/tweaks/deepfreeze/DFClassOverride.java", "rawCode": "  public static byte[] overrideBytes(String name, byte[] bytes, File location) {\n    try {\n      ZipFile zip = new ZipFile(location);\n      ZipEntry entry = zip.getEntry(name.replace('.', '/') + \".class\");\n      if (entry == null) System.out.println(name + \" not found in \" + location.getName());\n      else {\n        InputStream zin = zip.getInputStream(entry);\n        bytes = new byte[(int) entry.getSize()];\n        zin.read(bytes);\n        zin.close();\n        // System.out.println(name + \" was overriden from \" + location.getName());\n      }\n      zip.close();\n    } catch (Exception e) {\n      throw new RuntimeException(\"Error overriding \" + name + \" from \" + location.getName(), e);\n    }\n    return bytes;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2641, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 484, "focalAPIEnd": 501, "followUpCheck": "bytes <= 0", "checkType": "IF", "followUpCheckExpressionStart": 509, "followUpCheckExpressionEnd": 524, "followUpCheckBlockStart": 509, "followUpCheckBlockEnd": 531, "use": ["OutputStream.write(byte[],int,bytes)", "inputStream.close()"], "useStart": [538, 578], "useEnd": [566, 588], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.5.0/src/util/misc/IO.java", "rawCode": "  /**\n   * Copies from an input stream (until EOF) to output stream.\n   *\n   * @param is Input stream (will be closed at end)\n   * @param os Output stream\n   * @param bCloseOutput If true, will close output stream at end\n   * @throws IOException If there's any I/O error in process\n   */\n  public static void copy(InputStream is, OutputStream os, boolean bCloseOutput)\n      throws IOException {\n    byte[] abBuffer = new byte[COPYBUFFER_LENGTH];\n    while (true) {\n      int iRead = is.read(abBuffer);\n      if (iRead <= 0) break;\n      os.write(abBuffer, 0, iRead);\n    }\n    is.close(); // Was at EOF anyway\n    if (bCloseOutput) os.close();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2642, "initialization": ["InputStream inputStream = Socket.getInputStream()"], "initializationStart": [208], "initializationEnd": [231], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 2685, "focalAPIEnd": 2702, "followUpCheck": "i < bytes", "checkType": "LOOP", "followUpCheckExpressionStart": 2809, "followUpCheckExpressionEnd": 2836, "followUpCheckBlockStart": 2809, "followUpCheckBlockEnd": 3085, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/weishengshui/posserver/tree/master/main/src/test/java/com/chinarewards/qqgbpvn/main/ProtocolOnMinaTest.java", "rawCode": "  public void testSendFirmwareUpdateRequestViaJavaSocket_Free() throws Exception {\n\n    Socket socket = new Socket(\"192.168.1.42\", 1234);\n\n    OutputStream os = socket.getOutputStream();\n    InputStream is = socket.getInputStream();\n\n    byte[] msg =\n        new byte[] {\n          // SEQ\n          0,\n          0,\n          0,\n          24,\n          // ACK\n          0x20,\n          0,\n          0,\n          0x04,\n          // flags\n          0,\n          0,\n          // checksum (auto-calculated)\n          0,\n          0,\n          // message length\n          0,\n          0,\n          0,\n          0x20,\n          // command ID\n          0,\n          0,\n          0,\n          13,\n          // POS ID\n          'R',\n          'E',\n          'W',\n          'A',\n          'R',\n          'D',\n          'S',\n          '-',\n          '0',\n          '0',\n          '0',\n          '1'\n        };\n\n    msg =\n        new byte[] {\n          // SEQ\n          0,\n          0,\n          0,\n          24,\n          // ACK\n          0x20,\n          0,\n          0,\n          0x04,\n          // flags\n          0,\n          0,\n          // checksum (auto-calculated)\n          0,\n          0,\n          // message length\n          0,\n          0,\n          0,\n          0x20,\n          // command ID\n          0,\n          0,\n          0,\n          5,\n          // POS ID\n          'R',\n          'E',\n          'W',\n          'A',\n          'R',\n          'D',\n          'S',\n          '-',\n          '0',\n          '0',\n          '0',\n          '1'\n        };\n\n    // calculate checksum\n    int checksum = Tools.checkSum(msg, msg.length);\n    Tools.putUnsignedShort(msg, checksum, 10);\n\n    System.out.println(\"Packet size: \" + msg.length);\n\n    int loop = 5;\n\n    long runForSeconds = 1;\n    // write response\n    log.info(\"Send request to server\");\n    for (int j = 0; j < loop; j++) {\n      msg[3] = (byte) 0x0a;\n      msg[3] += (byte) j;\n\n      // uncomment the following to enable individual CORRECT checksum\n      // to be sent\n\n      boolean doSaneChecksum = true;\n\n      if (j == 3) {\n        doSaneChecksum = false;\n      }\n\n      if (doSaneChecksum) {\n        msg[10] = 0;\n        msg[11] = 0;\n        int checksum2 = Tools.checkSum(msg, msg.length);\n        Tools.putUnsignedShort(msg, checksum2, 10);\n      }\n\n      os.write(msg);\n      // os.flush();\n      // Thread.sleep(1);\n\n      msg[31] += 1;\n    }\n\n    // os.flush();\n    // Thread.sleep(1000);\n    // os.write(msg);\n    // os.flush();\n\n    // session.write(\"Client First Message\");\n    Thread.sleep(runForSeconds * 1000);\n    // read\n    log.info(\"Read response\");\n    byte[] response = new byte[30 * loop];\n    int n = is.read(response);\n    System.out.println(\"Number of bytes read: \" + n + \"\\n\");\n    CodecUtil.debugRaw(log, response);\n\n    for (int i = 0; i < n; i++) {\n      String s = Integer.toHexString((byte) response[i]);\n      if (s.length() < 2) s = \"0\" + s;\n      if (s.length() > 2) s = s.substring(s.length() - 2);\n      System.out.print(s + \" \");\n      if ((i + 1) % 8 == 0) System.out.println(\"\");\n    }\n\n    os.close();\n    socket.close();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2643, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 3751, "focalAPIEnd": 3764, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fanhongtao/JDK/tree/master/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java", "rawCode": "  /**\n   * This method uses the passed-in XMLInputSource to make fCurrentEntity usable for reading.\n   *\n   * @param name name of the entity (XML is it's the document entity)\n   * @param xmlInputSource the input source, with sufficient information to begin scanning\n   *     characters.\n   * @param literal True if this entity is started within a literal value.\n   * @param isExternal whether this entity should be treated as an internal or external entity.\n   * @throws IOException if anything can't be read XNIException If any parser-specific goes wrong.\n   * @return the encoding of the new entity or null if a character stream was employed\n   */\n  public String setupCurrentEntity(\n      String name, XMLInputSource xmlInputSource, boolean literal, boolean isExternal)\n      throws IOException, XNIException {\n    // get information\n\n    final String publicId = xmlInputSource.getPublicId();\n    String literalSystemId = xmlInputSource.getSystemId();\n    String baseSystemId = xmlInputSource.getBaseSystemId();\n    String encoding = xmlInputSource.getEncoding();\n    final boolean encodingExternallySpecified = (encoding != null);\n    Boolean isBigEndian = null;\n\n    // create reader\n    InputStream stream = null;\n    Reader reader = xmlInputSource.getCharacterStream();\n\n    // First chance checking strict URI\n    String expandedSystemId = expandSystemId(literalSystemId, baseSystemId, fStrictURI);\n    if (baseSystemId == null) {\n      baseSystemId = expandedSystemId;\n    }\n    if (reader == null) {\n      stream = xmlInputSource.getByteStream();\n      if (stream == null) {\n        URL location = new URL(expandedSystemId);\n        URLConnection connect = location.openConnection();\n        if (!(connect instanceof HttpURLConnection)) {\n          stream = connect.getInputStream();\n        } else {\n          boolean followRedirects = true;\n\n          // setup URLConnection if we have an HTTPInputSource\n          if (xmlInputSource instanceof HTTPInputSource) {\n            final HttpURLConnection urlConnection = (HttpURLConnection) connect;\n            final HTTPInputSource httpInputSource = (HTTPInputSource) xmlInputSource;\n\n            // set request properties\n            Iterator propIter = httpInputSource.getHTTPRequestProperties();\n            while (propIter.hasNext()) {\n              Map.Entry entry = (Map.Entry) propIter.next();\n              urlConnection.setRequestProperty((String) entry.getKey(), (String) entry.getValue());\n            }\n\n            // set preference for redirection\n            followRedirects = httpInputSource.getFollowHTTPRedirects();\n            if (!followRedirects) {\n              setInstanceFollowRedirects(urlConnection, followRedirects);\n            }\n          }\n\n          stream = connect.getInputStream();\n\n          // REVISIT: If the URLConnection has external encoding\n          // information, we should be reading it here. It's located\n          // in the charset parameter of Content-Type. -- mrglavas\n\n          if (followRedirects) {\n            String redirect = connect.getURL().toString();\n            // E43: Check if the URL was redirected, and then\n            // update literal and expanded system IDs if needed.\n            if (!redirect.equals(expandedSystemId)) {\n              literalSystemId = redirect;\n              expandedSystemId = redirect;\n            }\n          }\n        }\n      }\n\n      // wrap this stream in RewindableInputStream\n      stream = new RewindableInputStream(stream);\n\n      // perform auto-detect of encoding if necessary\n      if (encoding == null) {\n        // read first four bytes and determine encoding\n        final byte[] b4 = new byte[4];\n        int count = 0;\n        for (; count < 4; count++) {\n          b4[count] = (byte) stream.read();\n        }\n        if (count == 4) {\n          Object[] encodingDesc = getEncodingName(b4, count);\n          encoding = (String) (encodingDesc[0]);\n          isBigEndian = (Boolean) (encodingDesc[1]);\n\n          stream.reset();\n          // Special case UTF-8 files with BOM created by Microsoft\n          // tools. It's more efficient to consume the BOM than make\n          // the reader perform extra checks. -Ac\n          if (count > 2 && encoding.equals(\"UTF-8\")) {\n            int b0 = b4[0] & 0xFF;\n            int b1 = b4[1] & 0xFF;\n            int b2 = b4[2] & 0xFF;\n            if (b0 == 0xEF && b1 == 0xBB && b2 == 0xBF) {\n              // ignore first three bytes...\n              stream.skip(3);\n            }\n          }\n          reader = createReader(stream, encoding, isBigEndian);\n        } else {\n          reader = createReader(stream, encoding, isBigEndian);\n        }\n      }\n\n      // use specified encoding\n      else {\n        encoding = encoding.toUpperCase(Locale.ENGLISH);\n\n        // If encoding is UTF-8, consume BOM if one is present.\n        if (encoding.equals(\"UTF-8\")) {\n          final int[] b3 = new int[3];\n          int count = 0;\n          for (; count < 3; ++count) {\n            b3[count] = stream.read();\n            if (b3[count] == -1) break;\n          }\n          if (count == 3) {\n            if (b3[0] != 0xEF || b3[1] != 0xBB || b3[2] != 0xBF) {\n              // First three bytes are not BOM, so reset.\n              stream.reset();\n            }\n          } else {\n            stream.reset();\n          }\n        }\n        // If encoding is UTF-16, we still need to read the first four bytes\n        // in order to discover the byte order.\n        else if (encoding.equals(\"UTF-16\")) {\n          final int[] b4 = new int[4];\n          int count = 0;\n          for (; count < 4; ++count) {\n            b4[count] = stream.read();\n            if (b4[count] == -1) break;\n          }\n          stream.reset();\n\n          String utf16Encoding = \"UTF-16\";\n          if (count >= 2) {\n            final int b0 = b4[0];\n            final int b1 = b4[1];\n            if (b0 == 0xFE && b1 == 0xFF) {\n              // UTF-16, big-endian\n              utf16Encoding = \"UTF-16BE\";\n              isBigEndian = Boolean.TRUE;\n            } else if (b0 == 0xFF && b1 == 0xFE) {\n              // UTF-16, little-endian\n              utf16Encoding = \"UTF-16LE\";\n              isBigEndian = Boolean.FALSE;\n            } else if (count == 4) {\n              final int b2 = b4[2];\n              final int b3 = b4[3];\n              if (b0 == 0x00 && b1 == 0x3C && b2 == 0x00 && b3 == 0x3F) {\n                // UTF-16, big-endian, no BOM\n                utf16Encoding = \"UTF-16BE\";\n                isBigEndian = Boolean.TRUE;\n              }\n              if (b0 == 0x3C && b1 == 0x00 && b2 == 0x3F && b3 == 0x00) {\n                // UTF-16, little-endian, no BOM\n                utf16Encoding = \"UTF-16LE\";\n                isBigEndian = Boolean.FALSE;\n              }\n            }\n          }\n          reader = createReader(stream, utf16Encoding, isBigEndian);\n        }\n        // If encoding is UCS-4, we still need to read the first four bytes\n        // in order to discover the byte order.\n        else if (encoding.equals(\"ISO-10646-UCS-4\")) {\n          final int[] b4 = new int[4];\n          int count = 0;\n          for (; count < 4; ++count) {\n            b4[count] = stream.read();\n            if (b4[count] == -1) break;\n          }\n          stream.reset();\n\n          // Ignore unusual octet order for now.\n          if (count == 4) {\n            // UCS-4, big endian (1234)\n            if (b4[0] == 0x00 && b4[1] == 0x00 && b4[2] == 0x00 && b4[3] == 0x3C) {\n              isBigEndian = Boolean.TRUE;\n            }\n            // UCS-4, little endian (1234)\n            else if (b4[0] == 0x3C && b4[1] == 0x00 && b4[2] == 0x00 && b4[3] == 0x00) {\n              isBigEndian = Boolean.FALSE;\n            }\n          }\n        }\n        // If encoding is UCS-2, we still need to read the first four bytes\n        // in order to discover the byte order.\n        else if (encoding.equals(\"ISO-10646-UCS-2\")) {\n          final int[] b4 = new int[4];\n          int count = 0;\n          for (; count < 4; ++count) {\n            b4[count] = stream.read();\n            if (b4[count] == -1) break;\n          }\n          stream.reset();\n\n          if (count == 4) {\n            // UCS-2, big endian\n            if (b4[0] == 0x00 && b4[1] == 0x3C && b4[2] == 0x00 && b4[3] == 0x3F) {\n              isBigEndian = Boolean.TRUE;\n            }\n            // UCS-2, little endian\n            else if (b4[0] == 0x3C && b4[1] == 0x00 && b4[2] == 0x3F && b4[3] == 0x00) {\n              isBigEndian = Boolean.FALSE;\n            }\n          }\n        }\n\n        reader = createReader(stream, encoding, isBigEndian);\n      }\n\n      // read one character at a time so we don't jump too far\n      // ahead, converting characters from the byte stream in\n      // the wrong encoding\n      if (DEBUG_ENCODINGS) {\n        System.out.println(\"$$$ no longer wrapping reader in OneCharReader\");\n      }\n      // reader = new OneCharReader(reader);\n    }\n\n    // We've seen a new Reader.\n    // Push it on the stack so we can close it later.\n    // fOwnReaders.add(reader);\n\n    // push entity on stack\n    if (fCurrentEntity != null) {\n      fEntityStack.push(fCurrentEntity);\n    }\n\n    // create entity\n    /* if encoding is specified externally, 'encoding' information present\n     * in the prolog of the XML document is not considered. Hence, prolog can\n     * be read in Chunks of data instead of byte by byte.\n     */\n    fCurrentEntity =\n        new com.sun.xml.internal.stream.Entity.ScannedEntity(\n            name,\n            new XMLResourceIdentifierImpl(\n                publicId, literalSystemId, baseSystemId, expandedSystemId),\n            stream,\n            reader,\n            encoding,\n            literal,\n            encodingExternallySpecified,\n            isExternal);\n    fCurrentEntity.setEncodingExternallySpecified(encodingExternallySpecified);\n    fEntityScanner.setCurrentEntity(fCurrentEntity);\n    fResourceIdentifier.setValues(publicId, literalSystemId, baseSystemId, expandedSystemId);\n    return encoding;\n  } // setupCurrentEntity(String, XMLInputSource, boolean, boolean): String\n"}, {"dataset": "inputStreamRead", "exampleID": 2644, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 81, "focalAPIEnd": 95, "followUpCheck": "bytes != LF", "checkType": "IF", "followUpCheckExpressionStart": 103, "followUpCheckExpressionEnd": 116, "followUpCheckBlockStart": 103, "followUpCheckBlockEnd": 192, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/funambol-mirror/funambol-client-sdk/tree/master/us8871/common/src/main/java-me/com/funambol/platform/HttpConnectionAdapter.java", "rawCode": "    private void readLF(InputStream aStream) throws IOException {\n      int lf = aStream.read();\n      if (lf != LF) {\n        throw new IOException(\"Expected LF char in InputStream\");\n      }\n    }\n"}, {"dataset": "inputStreamRead", "exampleID": 2645, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 903, "focalAPIEnd": 921, "followUpCheck": "bytes == 0 || bytes < -1", "checkType": "IF", "followUpCheckExpressionStart": 927, "followUpCheckExpressionEnd": 966, "followUpCheckBlockStart": 927, "followUpCheckBlockEnd": 1166, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aismail/AndroAR/tree/master/AndroARComm/src/com/google/protobuf/CodedInputStream.java", "rawCode": "  /**\n   * Called with {@code this.buffer} is empty to read more bytes from the input. If {@code\n   * mustSucceed} is true, refillBuffer() gurantees that either there will be at least one byte in\n   * the buffer when it returns or it will throw an exception. If {@code mustSucceed} is false,\n   * refillBuffer() returns false if no more bytes were available.\n   */\n  private boolean refillBuffer(final boolean mustSucceed) throws IOException {\n    if (bufferPos < bufferSize) {\n      throw new IllegalStateException(\"refillBuffer() called when buffer wasn't empty.\");\n    }\n\n    if (totalBytesRetired + bufferSize == currentLimit) {\n      // Oops, we hit a limit.\n      if (mustSucceed) {\n        throw InvalidProtocolBufferException.truncatedMessage();\n      } else {\n        return false;\n      }\n    }\n\n    totalBytesRetired += bufferSize;\n\n    bufferPos = 0;\n    bufferSize = (input == null) ? -1 : input.read(buffer);\n    if (bufferSize == 0 || bufferSize < -1) {\n      throw new IllegalStateException(\n          \"InputStream#read(byte[]) returned invalid result: \"\n              + bufferSize\n              + \"\\nThe InputStream implementation is buggy.\");\n    }\n    if (bufferSize == -1) {\n      bufferSize = 0;\n      if (mustSucceed) {\n        throw InvalidProtocolBufferException.truncatedMessage();\n      } else {\n        return false;\n      }\n    } else {\n      recomputeBufferSizeAfterLimit();\n      final int totalBytesRead = totalBytesRetired + bufferSize + bufferSizeAfterLimit;\n      if (totalBytesRead > sizeLimit || totalBytesRead < 0) {\n        throw InvalidProtocolBufferException.sizeLimitExceeded();\n      }\n      return true;\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2646, "initialization": ["InputStream inputStream = new FileInputStream(File)"], "initializationStart": [1606], "initializationEnd": [1631], "hasTryCatch": 1, "exceptionType": "UnmarshallerException", "exceptionHandlingCall": ["getCause()", "printStackTrace()", "fail(String)"], "tryExpressionStart": 1201, "tryExpressionEnd": 1205, "tryBlockStart": 1201, "tryBlockEnd": 2164, "catchExpressionStart": 1978, "catchExpressionEnd": 2010, "catchBlockStart": 1978, "catchBlockEnd": 2109, "exceptionHandlingCallStart": [2018, 2018, 2056], "exceptionHandlingCallEnd": [2030, 2048, 2102], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 1641, "focalAPIEnd": 1667, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.close()", "inputStream.close()"], "useStart": [1677, 1757], "useEnd": [1695, 1775], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/esoeproject/esoeproject/tree/master/esoecore/tests/functional/com/qut/middleware/esoe/pdp/AuthorizationProcessorTest.java", "rawCode": "  private void setupPolicyCache() {\n    this.database = new HashMap<String, List<Policy>>();\n\n    String path = \"tests\" + File.separator + \"testdata\" + File.separator;\n\n    // map of policy sets and associated test SPEP ID's\n    String filenames[] =\n        new String[] {\n          path + \"PolicySetSimple.xml\", // };\n          path + \"PolicySetComplexity1.xml\", // };\n          path + \"PolicySetComplexity2.xml\", // };\n          path + \"PolicySetComplexity3.xml\",\n          path + \"PolicySetAction1.xml\",\n          path + \"PolicySetAction2.xml\",\n          path + \"PolicySetAction3.xml\",\n          path + \"PolicySetSimple2.xml\"\n        };\n    // path + \"NewFile.xml\" };\n\n    Map<String, String> config = new HashMap<String, String>();\n    config.put(filenames[0], \"urn:test:spep:id:s\");\n    config.put(filenames[1], \"urn:test:spep:id:1\");\n    config.put(filenames[2], \"urn:test:spep:id:2\");\n    config.put(filenames[3], \"urn:test:spep:id:3\");\n    config.put(filenames[4], \"urn:test:spep:id:4\");\n    config.put(filenames[5], \"urn:test:spep:id:5\");\n    config.put(filenames[6], \"urn:test:spep:id:6\");\n    config.put(filenames[7], \"urn:test:spep:id:s2\");\n    // config.put(filenames[8], \"access\");\n\n    try {\n      this.policySetUnmarshaller =\n          new UnmarshallerImpl<PolicySet>(\n              PolicySet.class.getPackage().getName(), new String[] {SchemaConstants.lxacml});\n\n      for (String s : filenames) {\n        // Get the size of the file\n        File file = new File(s);\n        long length = file.length();\n        byte[] byteArray = new byte[(int) length];\n\n        InputStream fileStream = new FileInputStream(file);\n        fileStream.read(byteArray);\n        fileStream.close();\n\n        // Close the input stream and return bytes\n        fileStream.close();\n\n        PolicySet policySet = policySetUnmarshaller.unMarshallUnSigned(byteArray);\n\n        assertNotNull(policySet);\n\n        this.database.put(config.get(s), policySet.getPolicies());\n      }\n    } catch (UnmarshallerException e) {\n      e.getCause().printStackTrace();\n      fail(\"Caught exception loading policy cache.\");\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    // assertNotNull(\"call to cache.getCache() returned null\", cache.getCache());\n\n    // //System.out.println(\"Cache size is: \" + this.cache.getCache().size());\n\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2647, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 66, "focalAPIEnd": 79, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nielssj/JN-DBusJolie/tree/master/jolie-src/extensions/http/src/jolie/net/http/HttpScanner.java", "rawCode": "  public final void readChar() throws IOException {\n    currInt = stream.read();\n    ch = (char) currInt;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2648, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 83, "focalAPIEnd": 106, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/certator/tuxguitar_mod/tree/master/TuxGuitar-gtp/src/org/herac/tuxguitar/io/gtp/GTPInputStream.java", "rawCode": "  protected int readInt() throws IOException {\n    byte[] bytes = new byte[4];\n    this.stream.read(bytes);\n    return ((bytes[3] & 0xff) << 24)\n        | ((bytes[2] & 0xff) << 16)\n        | ((bytes[1] & 0xff) << 8)\n        | (bytes[0] & 0xff);\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2649, "initialization": ["InputStream inputStream = new DeflaterInputStream(*)"], "initializationStart": [161], "initializationEnd": [216], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 222, "tryExpressionEnd": 226, "tryBlockStart": 222, "tryBlockEnd": 328, "catchExpressionStart": 618, "catchExpressionEnd": 647, "catchBlockStart": 618, "catchBlockEnd": 654, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 234, "focalAPIEnd": 256, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.read(byte[],int,int)", "inputStream.read(byte[],int,int)", "inputStream.close()", "inputStream.read(byte[],int,int)"], "useStart": [345, 448, 547, 575], "useEnd": [364, 470, 557, 596], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codefireX/platform_libcore/tree/master/luni/src/test/java/libcore/java/util/zip/DeflaterInputStreamTest.java", "rawCode": "  public void testReadExceptions() throws IOException {\n    byte[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    byte[] buffer = new byte[8];\n    InputStream in = new DeflaterInputStream(new ByteArrayInputStream(data));\n    try {\n      in.read(buffer, 0, 10);\n      fail();\n    } catch (IndexOutOfBoundsException expected) {\n    }\n    try {\n      in.read(null, 0, 5);\n      fail();\n    } catch (NullPointerException expected) {\n    }\n    try {\n      in.read(buffer, -1, 5);\n      fail();\n    } catch (IndexOutOfBoundsException expected) {\n    }\n    in.close();\n    try {\n      in.read(buffer, 0, 5);\n      fail();\n    } catch (IOException expected) {\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2650, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 159, "focalAPIEnd": 172, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/tests/api/org/xml/sax/support/BrokenInputStream.java", "rawCode": "  @Override\n  public int read() throws IOException {\n    if (offset == 0) {\n      throw new IOException(\"Injected exception\");\n    }\n\n    offset--;\n    return stream.read();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2651, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 903, "focalAPIEnd": 921, "followUpCheck": "bytes == 0 || bytes < -1", "checkType": "IF", "followUpCheckExpressionStart": 927, "followUpCheckExpressionEnd": 966, "followUpCheckBlockStart": 927, "followUpCheckBlockEnd": 1166, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jhartman/Google-Protocol-Buffers/tree/master/java/src/main/java/com/google/protobuf/CodedInputStream.java", "rawCode": "  /**\n   * Called with {@code this.buffer} is empty to read more bytes from the input. If {@code\n   * mustSucceed} is true, refillBuffer() gurantees that either there will be at least one byte in\n   * the buffer when it returns or it will throw an exception. If {@code mustSucceed} is false,\n   * refillBuffer() returns false if no more bytes were available.\n   */\n  private boolean refillBuffer(final boolean mustSucceed) throws IOException {\n    if (bufferPos < bufferSize) {\n      throw new IllegalStateException(\"refillBuffer() called when buffer wasn't empty.\");\n    }\n\n    if (totalBytesRetired + bufferSize == currentLimit) {\n      // Oops, we hit a limit.\n      if (mustSucceed) {\n        throw InvalidProtocolBufferException.truncatedMessage();\n      } else {\n        return false;\n      }\n    }\n\n    totalBytesRetired += bufferSize;\n\n    bufferPos = 0;\n    bufferSize = (input == null) ? -1 : input.read(buffer);\n    if (bufferSize == 0 || bufferSize < -1) {\n      throw new IllegalStateException(\n          \"InputStream#read(byte[]) returned invalid result: \"\n              + bufferSize\n              + \"\\nThe InputStream implementation is buggy.\");\n    }\n    if (bufferSize == -1) {\n      bufferSize = 0;\n      if (mustSucceed) {\n        throw InvalidProtocolBufferException.truncatedMessage();\n      } else {\n        return false;\n      }\n    } else {\n      recomputeBufferSizeAfterLimit();\n      final int totalBytesRead = totalBytesRetired + bufferSize + bufferSizeAfterLimit;\n      if (totalBytesRead > sizeLimit || totalBytesRead < 0) {\n        throw InvalidProtocolBufferException.sizeLimitExceeded();\n      }\n      return true;\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2652, "initialization": ["InputStream inputStream = JarFile.getInputStream(JarEntry)"], "initializationStart": [1049], "initializationEnd": [1081], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 1184, "tryExpressionEnd": 1188, "tryBlockStart": 1184, "tryBlockEnd": 1698, "catchExpressionStart": 1609, "catchExpressionEnd": 1637, "catchBlockStart": 1609, "catchBlockEnd": 1676, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 1362, "focalAPIEnd": 1380, "followUpCheck": "bytes <= 0", "checkType": "IF", "followUpCheckExpressionStart": 1394, "followUpCheckExpressionEnd": 1405, "followUpCheckBlockStart": 1394, "followUpCheckBlockEnd": 1442, "use": ["BufferedOutputStream.write(byte[],int,bytes)", "inputStream.close()", "inputStream.close()"], "useStart": [1455, 2033, 2145], "useEnd": [1481, 2046, 2158], "hasFinally": 1, "cleanUpCall": ["BufferedOutputStream.close()"], "finallyExpressionStart": 1505, "finallyExpressionEnd": 1513, "finallyBlockStart": 1505, "finallyBlockEnd": 1698, "cleanUpCallStart": [1579], "cleanUpCallEnd": [1593], "url": "https://github.com/apache/tomee/tree/master/tomee/tomee-loader/src/main/java/org/apache/tomee/loader/OpenEJBListener.java", "rawCode": "  public static void extract(final File src, final File dest) throws IOException {\n    if (dest.exists()) {\n      return;\n    }\n\n    LOGGER.log(\n        Level.INFO,\n        \"Extracting openejb webapp from {0} to {1}\",\n        new Object[] {src.getAbsolutePath(), dest.getAbsolutePath()});\n\n    if (!dest.mkdirs()) {\n      throw new IOException(\"Failed to create: \" + dest);\n    }\n\n    JarFile jarFile = null;\n    InputStream input = null;\n    try {\n      jarFile = new JarFile(src);\n      final Enumeration jarEntries = jarFile.entries();\n      while (jarEntries.hasMoreElements()) {\n        final JarEntry jarEntry = (JarEntry) jarEntries.nextElement();\n        final String name = jarEntry.getName();\n        final int last = name.lastIndexOf('/');\n        if (last >= 0) {\n          final File parent = new File(dest, name.substring(0, last));\n          if (!parent.mkdirs()) {\n            throw new IOException(\"Failed to create: \" + parent);\n          }\n        }\n        if (name.endsWith(\"/\")) {\n          continue;\n        }\n        input = jarFile.getInputStream(jarEntry);\n\n        final File file = new File(dest, name);\n        BufferedOutputStream output = null;\n        try {\n          output = new BufferedOutputStream(new FileOutputStream(file));\n          final byte[] buffer = new byte[2048];\n          while (true) {\n            final int n = input.read(buffer);\n            if (n <= 0) {\n              break;\n            }\n            output.write(buffer, 0, n);\n          }\n        } finally {\n          if (output != null) {\n            try {\n              output.close();\n            } catch (final IOException e) {\n              // Ignore\n            }\n          }\n        }\n\n        final long lastModified = jarEntry.getTime();\n        if (lastModified != -1 && lastModified != 0 && file != null) {\n          if (!file.setLastModified(lastModified)) {\n            LOGGER.log(\n                Level.WARNING, \"Failed to set last modified time on: {0}\", file.getAbsolutePath());\n          }\n        }\n\n        input.close();\n        input = null;\n      }\n    } finally {\n      if (input != null) {\n        try {\n          input.close();\n        } catch (final Throwable t) {\n          // no-op\n        }\n      }\n      if (jarFile != null) {\n        try {\n          jarFile.close();\n        } catch (final Throwable t) {\n          // no-op\n        }\n      }\n    }\n\n    LOGGER.info(\"Extracted openejb webapp\");\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2653, "initialization": ["InputStream inputStream = Activity.getResources()"], "initializationStart": [147], "initializationEnd": [170], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new Exception(String)"], "tryExpressionStart": 97, "tryExpressionEnd": 101, "tryBlockStart": 97, "tryBlockEnd": 428, "catchExpressionStart": 335, "catchExpressionEnd": 357, "catchBlockStart": 335, "catchBlockEnd": 428, "exceptionHandlingCallStart": [371], "exceptionHandlingCallEnd": [421], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 258, "focalAPIEnd": 273, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.close()"], "useStart": [281], "useEnd": [293], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/babayka74/vwml/tree/master/projects/puzzleR1/app/android/src/com/win/game/puzzleR1/configurator/PuzzleR1Configurator.java", "rawCode": "  public void loadResources(Activity activity) throws Exception {\n    String strJSON = null;\n    try {\n      InputStream file = null;\n      file = activity.getResources().getAssets().open(\"config.json\");\n      byte[] data = new byte[file.available()];\n      file.read(data);\n      file.close();\n      strJSON = new String(data);\n    } catch (IOException e) {\n      throw new Exception(\"Could not open file 'config.json'\");\n    }\n    try {\n      JSONObject configJSON = new JSONObject(strJSON);\n      // Parse imgIDs array\n      JSONArray jsaImgIDs = (JSONArray) configJSON.get(CFG_KEY_IMG_IDS);\n      imgIDsList = new ArrayList<String>();\n      int len = jsaImgIDs.length();\n      for (int i = 0; i < len; i++) {\n        String id = jsaImgIDs.getString(i);\n        imgIDsList.add(id);\n        Log.d(\"CONFIG\", \"imgIDs[\" + String.valueOf(i) + \"] = \" + id);\n      }\n      // Parse placesIDs array\n      JSONArray jsaPlacesIDs = (JSONArray) configJSON.get(CFG_KEY_PLACES_IDS);\n      placesIDsList = new ArrayList<String>();\n      len = jsaPlacesIDs.length();\n      for (int i = 0; i < len; i++) {\n        String id = jsaPlacesIDs.getString(i);\n        placesIDsList.add(id);\n        Log.d(\"CONFIG\", \"placesIDs[\" + String.valueOf(i) + \"] = \" + id);\n      }\n      // Parse relations\n      relationsMap = new HashMap<String, String>();\n      JSONArray jsaRelations = (JSONArray) configJSON.get(CFG_KEY_RELATIONS);\n      len = jsaRelations.length();\n      for (int i = 0; i < len; i++) {\n        JSONArray jsaPair = jsaRelations.getJSONArray(i);\n        String iId = jsaPair.getString(0);\n        String pId = jsaPair.getString(1);\n        relationsMap.put(iId, pId);\n      }\n      Log.d(\"CONFIG\", \"Place for 'i1' -> \" + relationsMap.get(\"i1\"));\n      Log.d(\"CONFIG\", \"Parsing finished\");\n      mConfig = new HashMap<String, Object>();\n      mConfig.put(CFG_KEY_IMG_IDS, imgIDsList);\n      mConfig.put(CFG_KEY_PLACES_IDS, placesIDsList);\n      mConfig.put(CFG_KEY_RELATIONS, relationsMap);\n\n    } catch (JSONException e) {\n      throw new Exception(\"The configuration has invalid format\");\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2654, "initialization": ["InputStream inputStream = Context.getAssets()"], "initializationStart": [154], "initializationEnd": [173], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 57, "tryExpressionEnd": 61, "tryBlockStart": 57, "tryBlockEnd": 475, "catchExpressionStart": 409, "catchExpressionEnd": 431, "catchBlockStart": 409, "catchBlockEnd": 475, "exceptionHandlingCallStart": [445], "exceptionHandlingCallEnd": [468], "configuration": ["inputStream.available()"], "configurationStart": [207], "configurationEnd": [230], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 276, "focalAPIEnd": 300, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.close()"], "useStart": [308], "useEnd": [327], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/crosswalk-project/crosswalk/tree/master/test/android/core/javatests/src/org/xwalk/core/xwview/test/XWalkViewTestBase.java", "rawCode": "  protected String getFileContent(String fileName) {\n    try {\n      Context context = getInstrumentation().getContext();\n      InputStream inputStream = context.getAssets().open(fileName);\n      int size = inputStream.available();\n      byte buffer[] = new byte[size];\n      inputStream.read(buffer);\n      inputStream.close();\n\n      String fileContent = new String(buffer);\n      return fileContent;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2655, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 200, "focalAPIEnd": 225, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 386, "followUpCheckExpressionEnd": 398, "followUpCheckBlockStart": 386, "followUpCheckBlockEnd": 465, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/branches/Xappia20090527/src/core/net/sf/appia/protocols/tcpcomplete/TcpReader.java", "rawCode": "  private int receive_n(byte[] b, int length) throws IOException {\n    // if (bench != null) bench.startBench(\"receive_n\");\n    int n = 0, i = 0, x = 0;\n    while (n != length && i != -1) {\n      i = is.read(b, n, length - n);\n      n += i;\n      x++;\n    }\n    // if (bench != null) bench.stopBench(\"receive_n\");\n    // if (bench != null) bench.indepBench(\"iterations_on read\",x);\n    if (i == -1) throw new IOException(\"Received EOF in the socket input stream.\");\n\n    return n;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2656, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(*)"], "tryExpressionStart": 315, "tryExpressionEnd": 319, "tryBlockStart": 315, "tryBlockEnd": 2122, "catchExpressionStart": 2062, "catchExpressionEnd": 2084, "catchBlockStart": 2062, "catchBlockEnd": 2122, "exceptionHandlingCallStart": [2092], "exceptionHandlingCallEnd": [2115], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 1209, "focalAPIEnd": 1223, "followUpCheck": "bytes != lbuf[k]", "checkType": "IF", "followUpCheckExpressionStart": 1263, "followUpCheckExpressionEnd": 1280, "followUpCheckBlockStart": 1263, "followUpCheckBlockEnd": 1376, "use": ["inputStream.read()"], "useStart": [1689], "useEnd": [1703], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arekinath/jop/tree/master/java/tools/src/com/jopdesign/tools/JavaDown.java", "rawCode": "  public static boolean downLoad(String fname) {\n    FileReader fileIn = null;\n    try {\n      fileIn = new FileReader(fname);\n    } catch (FileNotFoundException e1) {\n      sysoutStream.println(\"Error opening \" + fname);\n      System.exit(-1);\n    }\n\n    // read .jop file word for word and write bytes to JOP\n    try {\n      StreamTokenizer in = new StreamTokenizer(fileIn);\n      in.slashSlashComments(true);\n      in.whitespaceChars(',', ',');\n      int cnt = 0;\n      int lbuf[] = new int[CNTMOD];\n      for (; in.nextToken() != StreamTokenizer.TT_EOF; ++cnt) {\n        // in.nval contains the next 32 bit word to be sent\n        int l = (int) in.nval;\n        lbuf[cnt % CNTMOD] = l;\n\n        // Java code length at index 1 position in .jop\n        if (cnt == 1) {\n          sysoutStream.println(l + \" words of Java bytecode (\" + (l / 256) + \" KB)\");\n        }\n        for (int i = 0; i < 4; i++) {\n          byte b = (byte) (l >> ((3 - i) * 8));\n          outputStream.write(b);\n        }\n\n        if (!usb) {\n          if (cnt % CNTMOD == CNTMOD - 1) {\n            for (int k = 0; k < CNTMOD; k++) {\n              int r = 0;\n              for (int i = 0; i < 4; i++) {\n                r = (r << 8) | (iStream.read() & 0xff);\n              }\n              if (r != lbuf[k]) {\n                sysoutStream.println(\"received word differs from sent word\");\n              }\n            }\n          }\n        }\n\n        if ((cnt & 0x3f) == 0) {\n          sysoutStream.print(prog_char[(cnt >> 6) & 0x07] + \"\\r\");\n        }\n      }\n\n      if (!usb) {\n        for (int k = 0; k < cnt % CNTMOD; k++) {\n          int r = 0;\n          for (int i = 0; i < 4; i++) {\n            r = (r << 8) | (iStream.read() & 0xff);\n          }\n          if (r != lbuf[k]) {\n            sysoutStream.println(\"received word differs from sent word\");\n          }\n        }\n      }\n\n      sysoutStream.println(cnt + \" words external RAM (\" + (cnt / 256) + \" KB)\");\n      sysoutStream.println(\"download complete\");\n      sysoutStream.println(\"\");\n      sysoutStream.println(\"\");\n\n    } catch (IOException e) {\n      sysoutStream.println(e);\n    }\n    return true;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2657, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 185, "focalAPIEnd": 200, "followUpCheck": "bytes == 0x23 || bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 208, "followUpCheckExpressionEnd": 233, "followUpCheckBlockStart": 208, "followUpCheckBlockEnd": 258, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/validator/htmlparser/tree/master/test-src/nu/validator/htmlparser/test/UntilHashInputStream.java", "rawCode": "  /** @see java.io.InputStream#close() */\n  @Override\n  public void close() throws IOException {\n    super.close();\n    if (closed) {\n      return;\n    }\n    for (; ; ) {\n      int b = delegate.read();\n      if (b == 0x23 || b == -1) {\n        break;\n      }\n    }\n    closed = true;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2658, "initialization": ["byte[] b = ThreadLocal<byte[]>.get()"], "initializationStart": [146], "initializationEnd": [165], "hasTryCatch": 1, "exceptionType": "IOExceptionWrapper", "exceptionHandlingCall": ["getOriginalException()"], "tryExpressionStart": 118, "tryExpressionEnd": 122, "tryBlockStart": 118, "tryBlockEnd": 731, "catchExpressionStart": 451, "catchExpressionEnd": 483, "catchBlockStart": 451, "catchBlockEnd": 531, "exceptionHandlingCallStart": [497], "exceptionHandlingCallEnd": [524], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 290, "focalAPIEnd": 306, "followUpCheck": "bytes > 0", "checkType": "IF", "followUpCheckExpressionStart": 316, "followUpCheckExpressionEnd": 331, "followUpCheckBlockStart": 316, "followUpCheckBlockEnd": 383, "use": ["OutputStream.write(byte[],int,bytes)"], "useStart": [344], "useEnd": [372], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jenkinsci/svnkit/tree/master/svnkit/src/main/java/org/tmatesoft/svn/core/internal/io/fs/FSRepositoryUtil.java", "rawCode": "  public static void copy(InputStream src, OutputStream dst, ISVNCanceller canceller)\n      throws SVNException {\n    try {\n      byte[] buffer = ourCopyBuffer.get();\n      while (true) {\n        if (canceller != null) {\n          canceller.checkCancelled();\n        }\n        int length = src.read(buffer);\n        if (length > 0) {\n          dst.write(buffer, 0, length);\n        }\n        if (length < 0) {\n          break;\n        }\n      }\n    } catch (IOExceptionWrapper ioew) {\n      throw ioew.getOriginalException();\n    } catch (IOException ioe) {\n      SVNErrorMessage err =\n          SVNErrorMessage.create(SVNErrorCode.IO_ERROR, ioe.getLocalizedMessage());\n      SVNErrorManager.error(err, ioe, SVNLogType.FSFS);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2659, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 209, "focalAPIEnd": 218, "followUpCheck": "bytes != LONG_SIZE", "checkType": "IF", "followUpCheckExpressionStart": 226, "followUpCheckExpressionEnd": 245, "followUpCheckBlockStart": 226, "followUpCheckBlockEnd": 495, "use": ["inputStream.read(byte[],int,int)"], "useStart": [356], "useEnd": [383], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aadamowski/fi.java.net/tree/master/code/fastinfoset/src/main/java/com/sun/xml/fastinfoset/algorithm/LongEncodingAlgorithm.java", "rawCode": "  public final long[] decodeFromInputStreamToIntArray(InputStream s) throws IOException {\n    final List longList = new ArrayList();\n    final byte[] b = new byte[LONG_SIZE];\n\n    while (true) {\n      int n = s.read(b);\n      if (n != LONG_SIZE) {\n        if (n == -1) {\n          break;\n        }\n\n        while (n != LONG_SIZE) {\n          final int m = s.read(b, n, LONG_SIZE - n);\n          if (m == -1) {\n            throw new EOFException();\n          }\n          n += m;\n        }\n      }\n\n      final long l =\n          (((long) b[0] << 56)\n              + ((long) (b[1] & 0xFF) << 48)\n              + ((long) (b[2] & 0xFF) << 40)\n              + ((long) (b[3] & 0xFF) << 32)\n              + ((long) (b[4] & 0xFF) << 24)\n              + ((b[5] & 0xFF) << 16)\n              + ((b[6] & 0xFF) << 8)\n              + ((b[7] & 0xFF) << 0));\n\n      longList.add(Long.valueOf(l));\n    }\n\n    return generateArrayFromList(longList);\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2660, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "remaining>off", "guardType": "LOOP {", "guardExpressionStart": 521, "guardExpressionEnd": 542, "guardBlockStart": 521, "guardBlockEnd": 743, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 557, "focalAPIEnd": 621, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 631, "followUpCheckExpressionEnd": 643, "followUpCheckBlockStart": 631, "followUpCheckBlockEnd": 672, "use": ["OutputStream.write(byte[],int,bytes)"], "useStart": [681], "useEnd": [710], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/onedanshow/Screen-Courter/tree/master/lib/src/org/apache/http/entity/InputStreamEntity.java", "rawCode": "  public void writeTo(final OutputStream outstream) throws IOException {\n    if (outstream == null) {\n      throw new IllegalArgumentException(\"Output stream may not be null\");\n    }\n    InputStream instream = this.content;\n    byte[] buffer = new byte[BUFFER_SIZE];\n    int l;\n    if (this.length < 0) {\n      // consume until EOF\n      while ((l = instream.read(buffer)) != -1) {\n        outstream.write(buffer, 0, l);\n      }\n    } else {\n      // consume no more than length\n      long remaining = this.length;\n      while (remaining > 0) {\n        l = instream.read(buffer, 0, (int) Math.min(BUFFER_SIZE, remaining));\n        if (l == -1) {\n          break;\n        }\n        outstream.write(buffer, 0, l);\n        remaining -= l;\n      }\n    }\n    this.consumed = true;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2661, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 184, "focalAPIEnd": 193, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 217, "followUpCheckExpressionEnd": 229, "followUpCheckBlockStart": 217, "followUpCheckBlockEnd": 337, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RobKohr/bitcoinj/tree/master/src/com/google/bitcoin/core/BitcoinSerializer.java", "rawCode": "  public void seekPastMagicBytes(InputStream in) throws IOException {\n    int magicCursor = 3; // Which byte of the magic we're looking for currently.\n    while (true) {\n      int b = in.read(); // Read a byte.\n      if (b == -1) {\n        // There's no more data to read.\n        throw new IOException(\"Socket is disconnected\");\n      }\n      // We're looking for a run of bytes that is the same as the packet magic but we want to ignore\n      // partial\n      // magics that aren't complete. So we keep track of where we're up to with magicCursor.\n      int expectedByte = 0xFF & (int) (params.packetMagic >>> (magicCursor * 8));\n      if (b == expectedByte) {\n        magicCursor--;\n        if (magicCursor < 0) {\n          // We found the magic sequence.\n          return;\n        } else {\n          // We still have further to go to find the next message.\n        }\n      } else {\n        magicCursor = 3;\n      }\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2662, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 229, "focalAPIEnd": 244, "followUpCheck": "bytes >= 0", "checkType": "IF", "followUpCheckExpressionStart": 252, "followUpCheckExpressionEnd": 271, "followUpCheckBlockStart": 252, "followUpCheckBlockEnd": 437, "use": ["OutputStream.write(byte[],int,bytes)"], "useStart": [313], "useEnd": [344], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lexspoon/scalagwt-gwt/tree/master/dev/core/src/com/google/gwt/dev/shell/GWTShellServlet.java", "rawCode": "  private void streamOut(InputStream in, OutputStream out, int bufferSize) throws IOException {\n    assert (bufferSize >= 0);\n\n    byte[] buffer = new byte[bufferSize];\n    int bytesRead = 0;\n    while (true) {\n      bytesRead = in.read(buffer);\n      if (bytesRead >= 0) {\n        // Copy the bytes out.\n        out.write(buffer, 0, bytesRead);\n      } else {\n        // End of input stream.\n        out.flush();\n        return;\n      }\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2663, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 31, "tryExpressionEnd": 35, "tryBlockStart": 31, "tryBlockEnd": 250, "catchExpressionStart": 185, "catchExpressionEnd": 211, "catchBlockStart": 185, "catchBlockEnd": 250, "exceptionHandlingCallStart": [222], "exceptionHandlingCallEnd": [241], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 54, "focalAPIEnd": 63, "followUpCheck": "bytes != -1", "checkType": "LOOP {", "followUpCheckExpressionStart": 97, "followUpCheckExpressionEnd": 112, "followUpCheckBlockStart": 97, "followUpCheckBlockEnd": 175, "use": ["OutputStream.write(bytes)", "inputStream.read()", "OutputStream.write(bytes)"], "useStart": [74, 130, 152], "useEnd": [86, 139, 164], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/tomee/tree/master/itests/openejb-itests-client/src/main/java/org/apache/openejb/test/TestRunner.java", "rawCode": "    public void run() {\n\n      try {\n\n        int i = is.read();\n\n        out.write(i);\n\n        while (i != -1) {\n\n          i = is.read();\n\n          out.write(i);\n        }\n\n      } catch (final Exception e) {\n\n        e.printStackTrace();\n      }\n    }\n"}, {"dataset": "inputStreamRead", "exampleID": 2664, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 343, "focalAPIEnd": 390, "followUpCheck": "bytes < 0", "checkType": "IF", "followUpCheckExpressionStart": 398, "followUpCheckExpressionEnd": 408, "followUpCheckBlockStart": 398, "followUpCheckBlockEnd": 433, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/blackberry/BB10-WebWorks-Community-Samples/tree/master/Ant-Cordova-Build-Script/tools/rhino1_7R3/src/org/mozilla/javascript/Kit.java", "rawCode": "  public static byte[] readStream(InputStream is, int initialBufferCapacity) throws IOException {\n    if (initialBufferCapacity <= 0) {\n      throw new IllegalArgumentException(\"Bad initialBufferCapacity: \" + initialBufferCapacity);\n    }\n    byte[] buffer = new byte[initialBufferCapacity];\n    int cursor = 0;\n    for (; ; ) {\n      int n = is.read(buffer, cursor, buffer.length - cursor);\n      if (n < 0) {\n        break;\n      }\n      cursor += n;\n      if (cursor == buffer.length) {\n        byte[] tmp = new byte[buffer.length * 2];\n        System.arraycopy(buffer, 0, tmp, 0, cursor);\n        buffer = tmp;\n      }\n    }\n    if (cursor != buffer.length) {\n      byte[] tmp = new byte[cursor];\n      System.arraycopy(buffer, 0, tmp, 0, cursor);\n      buffer = tmp;\n    }\n    return buffer;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2665, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["inputStream.mark(int)"], "configurationStart": [290], "configurationEnd": [305], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 356, "focalAPIEnd": 370, "followUpCheck": "bytes < 0", "checkType": "IF", "followUpCheckExpressionStart": 376, "followUpCheckExpressionEnd": 386, "followUpCheckBlockStart": 376, "followUpCheckBlockEnd": 399, "use": ["inputStream.reset()", "guessContentTypeFromBuffer(byte[],bytes)"], "useStart": [404, 427], "useEnd": [414, 463], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nmacs/lm3s-uclinux/tree/master/lib/classpath/vm/reference/java/net/VMURLConnection.java", "rawCode": "  /**\n   * This is called from URLConnection to guess the mime type of a stream. This method may return\n   * null to indicate that it could not guess a type.\n   */\n  static String guessContentTypeFromStream(InputStream is) throws IOException {\n    if (!is.markSupported()) return null;\n    is.mark(LENGTH);\n    byte[] bytes = new byte[LENGTH];\n    int r = is.read(bytes);\n    if (r < 0) return null;\n    is.reset();\n    return guessContentTypeFromBuffer(bytes, r);\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2666, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(inputStream==null)", "guardType": "IF {", "guardExpressionStart": 219, "guardExpressionEnd": 234, "guardBlockStart": 219, "guardBlockEnd": 479, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 306, "focalAPIEnd": 315, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 323, "followUpCheckExpressionEnd": 339, "followUpCheckBlockStart": 323, "followUpCheckBlockEnd": 412, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/main/java/org/apache/harmony/security/asn1/BerInputStream.java", "rawCode": "  /** Reads the next encoded byte from the encoded input stream. */\n  protected int read() throws IOException {\n    if (offset == buffer.length) {\n      throw new ASN1Exception(\"Unexpected end of encoding\");\n    }\n\n    if (in == null) {\n      return buffer[offset++] & 0xFF;\n    } else {\n      int octet = in.read();\n      if (octet == -1) {\n        throw new ASN1Exception(\"Unexpected end of encoding\");\n      }\n\n      buffer[offset++] = (byte) octet;\n\n      return octet;\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2667, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "new StreamParsingException(*,*)"], "tryExpressionStart": 65, "tryExpressionEnd": 69, "tryBlockStart": 65, "tryBlockEnd": 753, "catchExpressionStart": 669, "catchExpressionEnd": 689, "catchBlockStart": 669, "catchBlockEnd": 753, "exceptionHandlingCallStart": [730, 703], "exceptionHandlingCallEnd": [742, 746], "configuration": ["inputStream.mark(int)"], "configurationStart": [302], "configurationEnd": [324], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 342, "focalAPIEnd": 362, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 371, "followUpCheckExpressionEnd": 385, "followUpCheckBlockStart": 371, "followUpCheckBlockEnd": 416, "use": ["inputStream.reset()", "readPEMCertificate(inputStream)", "inputStream.reset()", "readDERCertificate(inputStream)"], "useStart": [486, 524, 582, 620], "useEnd": [507, 557, 603, 653], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sake/bouncycastle-java/tree/master/src/org/bouncycastle/jce/provider/X509AttrCertParser.java", "rawCode": "  public Object engineRead() throws StreamParsingException {\n    try {\n      if (sData != null) {\n        if (sDataObjectCount != sData.size()) {\n          return getCertificate();\n        } else {\n          sData = null;\n          sDataObjectCount = 0;\n          return null;\n        }\n      }\n\n      currentStream.mark(10);\n      int tag = currentStream.read();\n\n      if (tag == -1) {\n        return null;\n      }\n\n      if (tag != 0x30) // assume ascii PEM encoded.\n      {\n        currentStream.reset();\n        return readPEMCertificate(currentStream);\n      } else {\n        currentStream.reset();\n        return readDERCertificate(currentStream);\n      }\n    } catch (Exception e) {\n      throw new StreamParsingException(e.toString(), e);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2668, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 394, "focalAPIEnd": 403, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 411, "followUpCheckExpressionEnd": 423, "followUpCheckBlockStart": 411, "followUpCheckBlockEnd": 512, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fywb251/bsl_impc_android/tree/master/cube-android/src/com/squareup/okhttp/internal/Util.java", "rawCode": "  /**\n   * Returns the ASCII characters up to but not including the next \"\\r\\n\", or \"\\n\".\n   *\n   * @throws java.io.EOFException if the stream is exhausted before the next newline character.\n   */\n  public static String readAsciiLine(InputStream in) throws IOException {\n    // TODO: support UTF-8 here instead\n    StringBuilder result = new StringBuilder(80);\n    while (true) {\n      int c = in.read();\n      if (c == -1) {\n        throw new EOFException();\n      } else if (c == '\\n') {\n        break;\n      }\n\n      result.append((char) c);\n    }\n    int length = result.length();\n    if (length > 0 && result.charAt(length - 1) == '\\r') {\n      result.setLength(length - 1);\n    }\n    return result.toString();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2669, "initialization": ["InputStream inputStream = Socket.getInputStream()"], "initializationStart": [703], "initializationEnd": [721], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 839, "focalAPIEnd": 848, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 856, "followUpCheckExpressionEnd": 872, "followUpCheckBlockStart": 856, "followUpCheckBlockEnd": 929, "use": ["loadString(inputStream)", "inputStream.read(byte[],int,int)", "inputStream.read()"], "useStart": [1675, 2010, 2286], "useEnd": [1692, 2055, 2295], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.7.2/trunk/src/om/loadtest/TNTester.java", "rawCode": "  private void sendRequestGetMedia(int iServer, Map mTokens, HttpScript.Item i, StepStats ss)\n      throws IOException {\n    if (DEBUG) System.err.print(\" \" + i.getURL());\n    ss.sPath = i.getURL();\n    long lBefore = System.currentTimeMillis();\n\n    Socket s = new Socket(HOSTS[iServer], PORTS[iServer]);\n    // Again with the dodgy charset assumptions\n    OutputStreamWriter osw = new OutputStreamWriter(s.getOutputStream());\n    String sRequest = i.getRequest();\n    sRequest = XML.replaceTokens(sRequest, \"%%\", mTokens).replaceAll(\"HTTP/1.1\", \"HTTP/1.0\");\n    osw.write(sRequest + \"\\r\\n\");\n    if (i.getData() != null) osw.write(i.getData());\n    osw.flush();\n\n    // Get input\n    InputStream is = s.getInputStream();\n    String sLine = \"\";\n    int iContentLength = -1;\n    boolean bFirst = true;\n    while (true) {\n      int iChar = is.read();\n      if (iChar == -1) throw new IOException(\"Unexpected EOF in socket input\");\n      if (iChar == 10) {\n        if (sLine.equals(\"\")) break; // End of headers\n        Matcher m = HttpScript.CONTENTLENGTH.matcher(sLine);\n        if (m.matches()) iContentLength = Integer.parseInt(m.group(1));\n        if (bFirst) {\n          bFirst = false;\n          Matcher mStatus = HttpScript.STATUSCODE.matcher(sLine);\n          if (!mStatus.matches()) throw new IOException(\"Unexpected HTTP status format: \" + sLine);\n          if (Integer.parseInt(mStatus.group(1)) != i.getExpectedResponse())\n            throw new IOException(\n                \"Unexpected response code: \"\n                    + sLine\n                    + \" (expecting \"\n                    + i.getExpectedResponse()\n                    + \")\\n\"\n                    + IO.loadString(is));\n        }\n        // System.err.println(sLine);\n        sLine = \"\";\n      } else if (iChar != 13) {\n        sLine += (char) iChar;\n      }\n    }\n\n    byte[] abData;\n    if (iContentLength != -1) {\n      abData = new byte[iContentLength];\n      for (int iRead = 0; iRead < abData.length; ) {\n        int iThisTime = is.read(abData, iRead, abData.length - iRead);\n        if (iThisTime == -1) throw new IOException(\"Didn't get all data\");\n        iRead += iThisTime;\n      }\n    } else {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      while (true) {\n        int iRead = is.read();\n        if (iRead == -1) break;\n        baos.write(iRead);\n      }\n      abData = baos.toByteArray();\n    }\n    s.close();\n\n    ss.lTime = System.currentTimeMillis() - lBefore;\n    if (DEBUG) {\n      System.err.print(\" [\" + abData.length + \" bytes]\");\n      System.err.println(\" (\" + ss.lTime + \" ms)\");\n    }\n\n    // OK now go through looking for *.gif, jpg, .css, .png\n    String sContent = new String(abData);\n    Set<String> sDone = new HashSet<String>();\n    Matcher m = MEDIALINK.matcher(sContent);\n    while (m.find()) {\n      String sURL = m.group(1);\n      if (sDone.contains(sURL)) continue;\n      sDone.add(sURL);\n\n      sURL =\n          \"http://\"\n              + HOSTS[iServer]\n              + (PORTS[iServer] != 80 ? (\":\" + PORTS[iServer]) : \"\")\n              + \"/om-tn/simple1/\"\n              + sURL;\n      sURL = sURL.replaceAll(\"simple1/../\", \"\");\n\n      loadMedia(mTokens, new URL(sURL), ss);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2670, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 127, "focalAPIEnd": 136, "followUpCheck": "bytes < 0", "checkType": "IF", "followUpCheckExpressionStart": 144, "followUpCheckExpressionEnd": 154, "followUpCheckBlockStart": 144, "followUpCheckBlockEnd": 180, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thomasbecker/jetty-spdy/tree/master/jetty-websocket/src/test/java/org/eclipse/jetty/websocket/WebSocketMessageD08Test.java", "rawCode": "  private void skipTo(String string, InputStream in) throws IOException {\n    int state = 0;\n\n    while (true) {\n      int b = in.read();\n      if (b < 0) throw new EOFException();\n\n      if (b == string.charAt(state)) {\n        state++;\n        if (state == string.length()) break;\n      } else state = 0;\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2671, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 152, "focalAPIEnd": 167, "followUpCheck": "bytes < 0", "checkType": "IF", "followUpCheckExpressionStart": 176, "followUpCheckExpressionEnd": 191, "followUpCheckBlockStart": 176, "followUpCheckBlockEnd": 275, "use": ["OutputStream.write(byte[],int,bytes)"], "useStart": [238], "useEnd": [266], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/webx/citrus/tree/master/common/util/src/main/java/com/alibaba/citrus/util/io/InputStreamOutputEngine.java", "rawCode": "  public void execute() throws IOException {\n    if (out == null) {\n      throw new IOException(\"Not yet initialized\");\n    } else {\n      int amount = in.read(buffer);\n\n      if (amount < 0) {\n        out.close();\n      } else {\n        out.write(buffer, 0, amount);\n      }\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2672, "initialization": ["int off = ByteBuffer.limit()"], "initializationStart": [780], "initializationEnd": [798], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 999, "focalAPIEnd": 1045, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 1055, "followUpCheckExpressionEnd": 1069, "followUpCheckBlockStart": 1055, "followUpCheckBlockEnd": 1233, "use": ["inputStream.close()"], "useStart": [1108], "useEnd": [1127], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jasvir/google-caja/tree/master/third_party/java/htmlparser/src/nu/validator/htmlparser/io/HtmlInputStreamReader.java", "rawCode": "  @Override\n  public int read(char[] charArray) throws IOException {\n    lineColPos = 0;\n    assert !sniffing;\n    assert charArray.length >= 2;\n    if (needToNotifyTokenizer) {\n      if (driver != null) {\n        driver.notifyAboutMetaBoundary();\n      }\n      needToNotifyTokenizer = false;\n    }\n    CharBuffer charBuffer = CharBuffer.wrap(charArray);\n    charBuffer.limit(charArray.length);\n    charBuffer.position(0);\n    if (flushing) {\n      decoder.flush(charBuffer);\n      // return -1 if zero\n      int cPos = charBuffer.position();\n      return cPos == 0 ? -1 : cPos;\n    }\n    if (hasPendingReplacementCharacter) {\n      charBuffer.put('\\uFFFD');\n      hasPendingReplacementCharacter = false;\n    }\n    for (; ; ) {\n      if (shouldReadBytes) {\n        int oldLimit = byteBuffer.limit();\n        int readLen;\n        if (charsetBoundaryPassed) {\n          readLen = byteArray.length - oldLimit;\n        } else {\n          readLen = SNIFFING_LIMIT - oldLimit;\n        }\n        int num = inputStream.read(byteArray, oldLimit, readLen);\n        if (num == -1) {\n          eofSeen = true;\n          inputStream.close();\n        } else {\n          byteBuffer.position(0);\n          byteBuffer.limit(oldLimit + num);\n        }\n        shouldReadBytes = false;\n      }\n      boolean finalDecode = false;\n      for (; ; ) {\n        int oldBytePos = byteBuffer.position();\n        CoderResult cr = decoder.decode(byteBuffer, charBuffer, finalDecode);\n        bytesRead += byteBuffer.position() - oldBytePos;\n        if (cr == CoderResult.OVERFLOW) {\n          // Decoder will remember surrogates\n          return charBuffer.position();\n        } else if (cr == CoderResult.UNDERFLOW) {\n          int remaining = byteBuffer.remaining();\n          if (!charsetBoundaryPassed) {\n            if (bytesRead + remaining >= SNIFFING_LIMIT) {\n              needToNotifyTokenizer = true;\n              charsetBoundaryPassed = true;\n            }\n          }\n\n          // XXX what happens if the entire byte buffer consists of\n          // a pathologically long malformed sequence?\n\n          // If the buffer was not fully consumed, there may be an\n          // incomplete byte sequence that needs to seed the next\n          // buffer.\n          if (remaining > 0) {\n            System.arraycopy(byteArray, byteBuffer.position(), byteArray, 0, remaining);\n          }\n          byteBuffer.position(0);\n          byteBuffer.limit(remaining);\n          if (flushing) {\n            // The final decode was successful. Not sure if this\n            // ever happens.\n            // Let's get out in any case.\n            int cPos = charBuffer.position();\n            return cPos == 0 ? -1 : cPos;\n          } else if (eofSeen) {\n            // If there's something left, it isn't something that\n            // would be\n            // consumed in the middle of the stream. Rerun the loop\n            // once\n            // in the final mode.\n            shouldReadBytes = false;\n            finalDecode = true;\n            flushing = true;\n            continue;\n          } else {\n            // The usual stuff. Want more bytes next time.\n            shouldReadBytes = true;\n            // return -1 if zero\n            int cPos = charBuffer.position();\n            return cPos == 0 ? -1 : cPos;\n          }\n        } else {\n          // The result is in error. No need to test.\n          StringBuilder sb = new StringBuilder();\n          for (int i = 0; i < cr.length(); i++) {\n            if (i > 0) {\n              sb.append(\", \");\n            }\n            sb.append('\\u201C');\n            sb.append(Integer.toHexString(byteBuffer.get() & 0xFF));\n            bytesRead++;\n            sb.append('\\u201D');\n          }\n          if (charBuffer.hasRemaining()) {\n            charBuffer.put('\\uFFFD');\n          } else {\n            hasPendingReplacementCharacter = true;\n          }\n          calculateLineAndCol(charBuffer);\n          if (cr.isMalformed()) {\n            err(\"Malformed byte sequence: \" + sb + \".\");\n          } else if (cr.isUnmappable()) {\n            err(\"Unmappable byte sequence: \" + sb + \".\");\n          } else {\n            throw new RuntimeException(\n                \"CoderResult was none of overflow, underflow, malformed or unmappable.\");\n          }\n          if (finalDecode) {\n            // These were the last bytes of input. Return without\n            // relooping.\n            // return -1 if zero\n            int cPos = charBuffer.position();\n            return cPos == 0 ? -1 : cPos;\n          }\n        }\n      }\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2673, "initialization": ["InputStream inputStream = VersionedVFS.getInputStream(VFSPath,String)"], "initializationStart": [430], "initializationEnd": [463], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new ConflictException(*)"], "tryExpressionStart": 525, "tryExpressionEnd": 529, "tryBlockStart": 525, "tryBlockEnd": 734, "catchExpressionStart": 661, "catchExpressionEnd": 689, "catchBlockStart": 661, "catchBlockEnd": 734, "exceptionHandlingCallStart": [703], "exceptionHandlingCallEnd": [727], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 543, "focalAPIEnd": 556, "followUpCheck": "bytes != -1", "checkType": "LOOP {", "followUpCheckExpressionStart": 565, "followUpCheckExpressionEnd": 582, "followUpCheckBlockStart": 565, "followUpCheckBlockEnd": 654, "use": ["OutputStream.write(byte[],int,bytes)", "inputStream.read(byte[])"], "useStart": [593, 632], "useEnd": [616, 645], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gogoego-gerrit/iucn-sis/tree/master/com.solertium.vfs/src/com/solertium/vfs/VFSRevisionUtils.java", "rawCode": "  /**\n   * Reverts to the version of the file as specified.\n   *\n   * @param vfs\n   * @param uri\n   * @param revision\n   * @throws NotFoundException\n   * @throws ConflictException\n   */\n  public static void revertToVersion(\n      final VersionedVFS vfs, final VFSPath uri, final String revision)\n      throws NotFoundException, ConflictException {\n    final OutputStream out = vfs.getOutputStream(uri);\n    final InputStream in = vfs.getInputStream(uri, revision);\n\n    int len;\n    final byte[] temp = new byte[65536];\n\n    try {\n      len = in.read(temp);\n\n      while (len != -1) {\n        out.write(temp, 0, len);\n        len = in.read(temp);\n      }\n    } catch (final IOException e) {\n      throw new ConflictException(e);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2674, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 227, "focalAPIEnd": 245, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 253, "followUpCheckExpressionEnd": 265, "followUpCheckBlockStart": 253, "followUpCheckBlockEnd": 449, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xone-team/p0001/tree/master/xone-action/src/main/java/com/xone/action/utils/Base64InputStream.java", "rawCode": "  /**\n   * Reads from the underlying stream, decodes the data and puts the decoded bytes into the buffer.\n   */\n  private void acquire() throws IOException {\n    char[] four = new char[4];\n    int i = 0;\n    do {\n      int b = inputStream.read();\n      if (b == -1) {\n        if (i != 0) {\n          throw new IOException(\"Bad base64 stream\");\n        } else {\n          buffer = new int[0];\n          eof = true;\n          return;\n        }\n      }\n      char c = (char) b;\n      if (Shared.chars.indexOf(c) != -1 || c == Shared.pad) {\n        four[i++] = c;\n      } else if (c != '\\r' && c != '\\n') {\n        throw new IOException(\"Bad base64 stream\");\n      }\n    } while (i < 4);\n    boolean padded = false;\n    for (i = 0; i < 4; i++) {\n      if (four[i] != Shared.pad) {\n        if (padded) {\n          throw new IOException(\"Bad base64 stream\");\n        }\n      } else {\n        if (!padded) {\n          padded = true;\n        }\n      }\n    }\n    int l;\n    if (four[3] == Shared.pad) {\n      if (inputStream.read() != -1) {\n        throw new IOException(\"Bad base64 stream\");\n      }\n      eof = true;\n      if (four[2] == Shared.pad) {\n        l = 1;\n      } else {\n        l = 2;\n      }\n    } else {\n      l = 3;\n    }\n    int aux = 0;\n    for (i = 0; i < 4; i++) {\n      if (four[i] != Shared.pad) {\n        aux = aux | (Shared.chars.indexOf(four[i]) << (6 * (3 - i)));\n      }\n    }\n    buffer = new int[l];\n    for (i = 0; i < l; i++) {\n      buffer[i] = (aux >>> (8 * (2 - i))) & 0xFF;\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2675, "initialization": ["InputStream inputStream = HttpURLConnection.getInputStream()"], "initializationStart": [1072], "initializationEnd": [1099], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 1014, "tryExpressionEnd": 1018, "tryBlockStart": 1014, "tryBlockEnd": 1474, "catchExpressionStart": 1328, "catchExpressionEnd": 1348, "catchBlockStart": 1328, "catchBlockEnd": 1474, "exceptionHandlingCallStart": [1358], "exceptionHandlingCallEnd": [1377], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "inputStream.available()>0", "guardType": "LOOP {", "guardExpressionStart": 1185, "guardExpressionEnd": 1214, "guardBlockStart": 1185, "guardBlockEnd": 1296, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 1240, "focalAPIEnd": 1252, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.close()"], "useStart": [1305], "useEnd": [1318], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nettapper/GameCenter/tree/master/GameCenterClient/src/client/ClientControl.java", "rawCode": "  /**\n   * Connects to server and sends the json string 'outputData'\n   *\n   * @param path The path connecting to\n   * @param gsonClientPack The json formated string to be sent to the server\n   * @return String The data from the server\n   */\n  public static String connect(String path, String gsonClientPack) {\n\n    System.out.println(\"Client attempting a connection to : \" + ADDRESS + path); // Debugging\n\n    HttpURLConnection connection;\n    URL link;\n    InputStream input;\n    String data = \"\";\n    DataOutputStream output;\n\n    try {\n      link = new URL(ADDRESS + path);\n      connection = (HttpURLConnection) link.openConnection();\n      connection.setAllowUserInteraction(true);\n      connection.setRequestMethod(\"POST\");\n      connection.setDoOutput(true);\n      connection.setDoInput(true);\n      connection.setInstanceFollowRedirects(false);\n\n      output = new DataOutputStream(connection.getOutputStream());\n      output.writeBytes(gsonClientPack);\n      output.flush();\n      output.close();\n\n      try { // Try to read the data from server\n        input = connection.getInputStream();\n        while (input.available() <= 0) ; // no data from server, waiting...\n        while (input.available() > 0) {\n          int number = input.read();\n          data += (char) number;\n        }\n        input.close();\n      } catch (Exception e) {\n        e.printStackTrace();\n        data = gsonClientPack; // in the case of an exception, return the original pack\n      }\n\n      connection.disconnect();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    // DEBUGGING //\n\n    System.out.println(\"Client succesfully connected to : \" + ADDRESS + path); // Debugging\n    System.out.println(\"Data To Server: \" + gsonClientPack);\n    System.out.println(\"Data From Server: \" + data);\n    System.out.println(\"---------------------------------------\");\n\n    // END //\n\n    return data;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2676, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new FilesystemAccessException(String,*)"], "tryExpressionStart": 159, "tryExpressionEnd": 163, "tryBlockStart": 159, "tryBlockEnd": 784, "catchExpressionStart": 677, "catchExpressionEnd": 701, "catchBlockStart": 677, "catchBlockEnd": 784, "exceptionHandlingCallStart": [715], "exceptionHandlingCallEnd": [777], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 251, "focalAPIEnd": 270, "followUpCheck": "bytes < 0", "checkType": "IF", "followUpCheckExpressionStart": 280, "followUpCheckExpressionEnd": 292, "followUpCheckBlockStart": 280, "followUpCheckBlockEnd": 299, "use": ["arraycopy(byte[],int,byte[],int,bytes)"], "useStart": [569], "useEnd": [612], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dkfellows/taverna-server/tree/master/server-webapp/src/main/java/org/taverna/server/master/TavernaServerSupport.java", "rawCode": "  public void copyStreamToFile(InputStream stream, File file) throws FilesystemAccessException {\n    String name = file.getFullName();\n    long total = 0;\n    try {\n      byte[] buffer = new byte[TRANSFER_SIZE];\n      while (true) {\n        int len = stream.read(buffer);\n        if (len < 0) break;\n        total += len;\n        log.debug(\n            \"read \" + len + \" bytes from source stream (total: \" + total + \") bound for \" + name);\n        if (len == buffer.length) file.appendContents(buffer);\n        else {\n          byte[] newBuf = new byte[len];\n          System.arraycopy(buffer, 0, newBuf, 0, len);\n          file.appendContents(newBuf);\n        }\n      }\n    } catch (IOException exn) {\n      throw new FilesystemAccessException(\"failed to transfer bytes\", exn);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2677, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 458, "focalAPIEnd": 470, "followUpCheck": "bytes > 0", "checkType": "LOOP {", "followUpCheckExpressionStart": 493, "followUpCheckExpressionEnd": 509, "followUpCheckBlockStart": 493, "followUpCheckBlockEnd": 1077, "use": ["arraycopy(byte[],int,byte[],int,bytes)", "inputStream.read(byte[])"], "useStart": [636, 1058], "useEnd": [674, 1070], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/funambol-mirror/funambol-client-sdk/tree/master/us9098/common/src/main/java/com/funambol/util/Base64.java", "rawCode": "  /**\n   * encode the input stream and write the base64 encoded output into the output stream\n   *\n   * @throws IOException if the input/output streams cannot be read/written\n   */\n  public static void encode(InputStream is, OutputStream os, int breakLen, String breakStr)\n      throws IOException {\n\n    // The BUF SIZE must be a multiple of 3 to avoid b64 intermeditate padding\n    int BUF_SIZE = 16380;\n    byte buf[] = new byte[BUF_SIZE];\n    int size = is.read(buf);\n    int col = 0;\n    while (size > 0) {\n      // Encode this chunk\n      byte encoded[];\n      if (size != BUF_SIZE) {\n        byte tmp[] = new byte[size];\n        System.arraycopy(buf, 0, tmp, 0, size);\n        encoded = encode(tmp);\n      } else {\n        encoded = encode(buf);\n      }\n      // Now print it to the OS, breaking if required\n      for (int i = 0; i < encoded.length; ++i) {\n        os.write((char) encoded[i]);\n        col++;\n        if (col == breakLen - breakStr.length()) {\n          os.write(breakStr.getBytes());\n          col = 0;\n        }\n      }\n      size = is.read(buf);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2678, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 30, "tryExpressionEnd": 34, "tryBlockStart": 30, "tryBlockEnd": 687, "catchExpressionStart": 623, "catchExpressionEnd": 647, "catchBlockStart": 623, "catchBlockEnd": 687, "exceptionHandlingCallStart": [657], "exceptionHandlingCallEnd": [678], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 109, "focalAPIEnd": 127, "followUpCheck": "bytes < off", "checkType": "IF", "followUpCheckExpressionStart": 400, "followUpCheckExpressionEnd": 410, "followUpCheckBlockStart": 400, "followUpCheckBlockEnd": 443, "use": ["new String(byte[],int,bytes,String)"], "useStart": [465], "useEnd": [493], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/com/sun/jdi/DoubleAgentTest.java", "rawCode": "    public void run() {\n      try {\n        byte b[] = new byte[100];\n        for (; ; ) {\n          int n = in.read(b, 0, 100);\n          // The first thing that will get read is\n          // Listening for transport dt_socket at address: xxxxx\n          // which shows the debuggee is ready to accept connections.\n          synchronized (locker) {\n            locker.notify();\n          }\n          if (n < 0) {\n            break;\n          }\n          String s = new String(b, 0, n, \"UTF-8\");\n          System.out.print(s);\n          synchronized (outputText) {\n            outputText += s;\n          }\n        }\n      } catch (IOException ioe) {\n        ioe.printStackTrace();\n      }\n    }\n"}, {"dataset": "inputStreamRead", "exampleID": 2679, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 93, "focalAPIEnd": 105, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/PatrickDeelen/molgenis-genotype-reader/tree/master/src/main/java/org/molgenis/genotype/tabix/TabixIndex.java", "rawCode": "  private int readInt(InputStream in) throws IOException {\n    byte[] buf = new byte[4];\n    in.read(buf);\n\n    return ByteBuffer.wrap(buf).order(ByteOrder.LITTLE_ENDIAN).getInt();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2680, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 162, "focalAPIEnd": 171, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 179, "followUpCheckExpressionEnd": 191, "followUpCheckBlockStart": 179, "followUpCheckBlockEnd": 216, "use": ["inputStream.mark(int)", "inputStream.read()", "inputStream.reset()"], "useStart": [356, 396, 463], "useEnd": [366, 405, 473], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-mapreduce-project/src/contrib/index/src/java/org/apache/hadoop/contrib/index/example/LineDocRecordReader.java", "rawCode": "  private static long readData(InputStream in, OutputStream out, char delimiter)\n      throws IOException {\n    long bytes = 0;\n    while (true) {\n\n      int b = in.read();\n      if (b == -1) {\n        break;\n      }\n      bytes += 1;\n\n      byte c = (byte) b;\n      if (c == EOL || c == delimiter) {\n        break;\n      }\n\n      if (c == '\\r') {\n        in.mark(1);\n        byte nextC = (byte) in.read();\n        if (nextC != EOL || c == delimiter) {\n          in.reset();\n        } else {\n          bytes += 1;\n        }\n        break;\n      }\n\n      if (out != null) {\n        out.write(c);\n      }\n    }\n    return bytes;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2681, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 67, "focalAPIEnd": 85, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 93, "followUpCheckExpressionEnd": 110, "followUpCheckBlockStart": 93, "followUpCheckBlockEnd": 179, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cloudsmith/org.eclipse.emf/tree/master/plugins/org.eclipse.emf.gwt.ecore/src/org/eclipse/emf/ecore/resource/impl/BinaryResourceImpl.java", "rawCode": "    public byte readByte() throws IOException {\n      int result = inputStream.read();\n      if (result == -1) {\n        throw new IOException(\"Unexpected end of stream\");\n      }\n      return (byte) result;\n    }\n"}, {"dataset": "inputStreamRead", "exampleID": 2682, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 897, "focalAPIEnd": 916, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 923, "followUpCheckExpressionEnd": 939, "followUpCheckBlockStart": 923, "followUpCheckBlockEnd": 1097, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mhl/libbio-formats-java/tree/master/components/forks/poi/src/loci/poi/util/LittleEndian.java", "rawCode": "  /**\n   * Read the appropriate number of bytes from the stream and return them to the caller.\n   *\n   * <p>However, for the purposes of the POI project, this risk is deemed negligible. It is,\n   * however, so noted.\n   *\n   * @param stream the InputStream we're reading from\n   * @param size the number of bytes to read; in 99.99% of cases, this will be SHORT_SIZE, INT_SIZE,\n   *     or LONG_SIZE -- but it doesn't have to be.\n   * @return the byte array containing the required number of bytes. The array will contain all\n   *     zero's on end of stream\n   * @exception IOException will be propagated back to the caller\n   * @exception BufferUnderrunException if the stream cannot provide enough bytes\n   */\n  public static byte[] readFromStream(final InputStream stream, final int size)\n      throws IOException, BufferUnderrunException {\n    byte[] buffer = new byte[size];\n\n    int count = stream.read(buffer);\n\n    if (count == -1) {\n\n      // return a zero-filled buffer\n      Arrays.fill(buffer, (byte) 0);\n    } else if (count != size) {\n      throw new BufferUnderrunException();\n    }\n    return buffer;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2683, "initialization": ["InputStream inputStream = new BufferedInputStream(InputStream,int)"], "initializationStart": [238], "initializationEnd": [277], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["inputStream.mark(int)"], "configurationStart": [283], "configurationEnd": [300], "guardCondition": "!(inputStream==null)", "guardType": "IF {", "guardExpressionStart": 114, "guardExpressionEnd": 135, "guardBlockStart": 114, "guardBlockEnd": 191, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 314, "focalAPIEnd": 329, "followUpCheck": "bytes == -1", "checkType": "IF", "followUpCheckExpressionStart": 335, "followUpCheckExpressionEnd": 347, "followUpCheckBlockStart": 335, "followUpCheckBlockEnd": 373, "use": ["inputStream.reset()", "inputStream.read()", "new Base64InputStream(inputStream)", "inputStream.read()", "inputStream.reset()", "new X509Certificate(inputStream)"], "useStart": [679, 816, 1127, 1276, 1617, 1648], "useEnd": [695, 831, 1158, 1291, 1633, 1677], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/redstar3894/android-gcc/tree/master/libjava/classpath/gnu/java/security/provider/X509CertificateFactory.java", "rawCode": "  private X509Certificate generateCert(InputStream inStream)\n      throws IOException, CertificateException {\n    if (inStream == null) throw new CertificateException(\"missing input stream\");\n    if (!inStream.markSupported()) inStream = new BufferedInputStream(inStream, 8192);\n    inStream.mark(20);\n    int i = inStream.read();\n    if (i == -1) throw new EOFException();\n    // If the input is in binary DER format, the first byte MUST be\n    // 0x30, which stands for the ASN.1 [UNIVERSAL 16], which is the\n    // UNIVERSAL SEQUENCE, with the CONSTRUCTED bit (0x20) set.\n    //\n    // So if we do not see 0x30 here we will assume it is in Base-64.\n    if (i != 0x30) {\n      inStream.reset();\n      CPStringBuilder line = new CPStringBuilder(80);\n      do {\n        line.setLength(0);\n        do {\n          i = inStream.read();\n          if (i == -1) throw new EOFException();\n          if (i != '\\n' && i != '\\r') line.append((char) i);\n        } while (i != '\\n' && i != '\\r');\n      } while (!line.toString().equals(BEGIN_CERTIFICATE));\n      X509Certificate ret =\n          new X509Certificate(new BufferedInputStream(new Base64InputStream(inStream), 8192));\n      line.setLength(0);\n      line.append('-'); // Base64InputStream will eat this.\n      do {\n        i = inStream.read();\n        if (i == -1) throw new EOFException();\n        if (i != '\\n' && i != '\\r') line.append((char) i);\n      } while (i != '\\n' && i != '\\r');\n      // XXX ???\n      if (!line.toString().equals(END_CERTIFICATE))\n        throw new CertificateException(\"no end-of-certificate marker\");\n      return ret;\n    } else {\n      inStream.reset();\n      return new X509Certificate(inStream);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2684, "initialization": ["InputStream inputStream = Socket.getInputStream()"], "initializationStart": [1345], "initializationEnd": [1368], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 1798, "focalAPIEnd": 1813, "followUpCheck": "bytes >= 4", "checkType": "IF", "followUpCheckExpressionStart": 1915, "followUpCheckExpressionEnd": 1928, "followUpCheckBlockStart": 1915, "followUpCheckBlockEnd": 2221, "use": ["assertEquals(String,*,bytes)", "inputStream.read(byte[])", "assertEquals(String,int,bytes)"], "useStart": [1821, 2545, 2568], "useEnd": [1860, 2560, 2594], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thomasbecker/jetty-spdy/tree/master/jetty-websocket/src/test/java/org/eclipse/jetty/websocket/WebSocketMessageRFC6455Test.java", "rawCode": "  @Test\n  public void testCloseOut() throws Exception {\n    int[][] tests = {\n      {-1, 0, -1},\n      {-1, 0, -1},\n      {0, 2, 1000},\n      {0, 2 + 4, 1000},\n      {1000, 2, 1000},\n      {1000, 2 + 4, 1000},\n      {1005, 0, -1},\n      {1005, 0, -1},\n      {1006, 0, -1},\n      {1006, 0, -1},\n      {9000, 2, 9000},\n      {9000, 2 + 4, 9000}\n    };\n\n    String[] mesg = {\n      null, \"Not Sent\", null, \"mesg\", null, \"mesg\", null, \"mesg\", null, \"mesg\", null, \"mesg\"\n    };\n\n    for (int t = 0; t < tests.length; t++) {\n      String tst = \"\" + t;\n      Socket socket = new Socket(\"localhost\", __connector.getLocalPort());\n      OutputStream output = socket.getOutputStream();\n      output.write(\n          (\"GET /chat HTTP/1.1\\r\\n\"\n                  + \"Host: server.example.com\\r\\n\"\n                  + \"Upgrade: websocket\\r\\n\"\n                  + \"Connection: Upgrade\\r\\n\"\n                  + \"Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\\r\\n\"\n                  + \"Sec-WebSocket-Origin: http://example.com\\r\\n\"\n                  + \"Sec-WebSocket-Protocol: chat\\r\\n\"\n                  + \"Sec-WebSocket-Version: \"\n                  + WebSocketConnectionRFC6455.VERSION\n                  + \"\\r\\n\"\n                  + \"\\r\\n\")\n              .getBytes(\"ISO-8859-1\"));\n      output.flush();\n\n      socket.setSoTimeout(100000);\n      InputStream input = socket.getInputStream();\n\n      lookFor(\"HTTP/1.1 101 Switching Protocols\\r\\n\", input);\n      skipTo(\"Sec-WebSocket-Accept: \", input);\n      lookFor(\"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\", input);\n      skipTo(\"\\r\\n\\r\\n\", input);\n\n      assertTrue(__serverWebSocket.awaitConnected(1000));\n      assertNotNull(__serverWebSocket.connection);\n\n      __serverWebSocket.getConnection().close(tests[t][0], mesg[t]);\n\n      byte[] buf = new byte[128];\n      int len = input.read(buf);\n      assertEquals(tst, 2 + tests[t][1], len);\n      assertEquals(tst, (byte) 0x88, buf[0]);\n\n      if (len >= 4) {\n        int code = (0xff & buf[2]) * 0x100 + (0xff & buf[3]);\n        assertEquals(tst, tests[t][2], code);\n\n        if (len > 4) {\n          String m = new String(buf, 4, len - 4, \"UTF-8\");\n          assertEquals(tst, mesg[t], m);\n        }\n      } else assertEquals(tst, tests[t][2], -1);\n\n      try {\n        output.write(0x88);\n        output.write(0x80);\n        output.write(0x00);\n        output.write(0x00);\n        output.write(0x00);\n        output.write(0x00);\n        output.flush();\n      } catch (IOException e) {\n        System.err.println(\"socket \" + socket);\n        throw e;\n      }\n\n      len = input.read(buf);\n      assertEquals(tst, -1, len);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2685, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 52, "focalAPIEnd": 61, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/GDI-Vlaanderen/geonetwork/tree/master/web/src/main/java/org/fao/geonet/kernel/mef/IVisitor.java", "rawCode": "  public int read() throws IOException {\n    return is.read();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2686, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 305, "focalAPIEnd": 324, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getAudioInputStream(inputStream)"], "useStart": [445], "useEnd": [484], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jeid64/despotify/tree/master/java/tags/0.4.1/src/main/java/se/despotify/client/player/ChannelPlayer.java", "rawCode": "  private boolean open(InputStream stream) {\n    /* Audio streams and formats. */\n    AudioInputStream sourceStream;\n    AudioFormat sourceFormat;\n    AudioFormat targetFormat;\n\n    /* Spotify specific ogg header. */\n    byte[] header = new byte[167];\n\n    try {\n      /* Read and decode header. */\n      stream.read(header);\n\n      this.spotifyOggHeader = new SpotifyOggHeader(header);\n\n      /* Get audio source stream */\n      sourceStream = AudioSystem.getAudioInputStream(stream);\n\n      /* Get source format and set target format. */\n      sourceFormat = sourceStream.getFormat();\n      targetFormat =\n          new AudioFormat(\n              sourceFormat.getSampleRate(), 16, sourceFormat.getChannels(), true, false);\n\n      this.audioFormat = targetFormat;\n\n      /* Get target audio stream */\n      this.audioStream = AudioSystem.getAudioInputStream(targetFormat, sourceStream);\n\n      /* Get line info for target format. */\n      DataLine.Info info = new DataLine.Info(SourceDataLine.class, targetFormat);\n\n      /* Get line for obtained line info. */\n      this.audioLine = (SourceDataLine) AudioSystem.getLine(info);\n\n      /* Finally open line for playback. */\n      this.audioLine.open();\n    } catch (UnsupportedAudioFileException e) {\n      return false;\n    } catch (IOException e) {\n      return false;\n    } catch (LineUnavailableException e) {\n      return false;\n    }\n\n    /* Set player status. */\n    this.active = true;\n\n    /* Start thread which writes data to the line. */\n    new Thread(this).start();\n\n    /* Success. */\n    return true;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2687, "initialization": ["InputStream inputStream = openInputStream(*)"], "initializationStart": [134], "initializationEnd": [193], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["setResult(int)", "finish()", "printStackTrace()"], "tryExpressionStart": 39, "tryExpressionEnd": 43, "tryBlockStart": 39, "tryBlockEnd": 707, "catchExpressionStart": 562, "catchExpressionEnd": 582, "catchBlockStart": 562, "catchBlockEnd": 707, "exceptionHandlingCallStart": [630, 661, 679], "exceptionHandlingCallEnd": [651, 669, 698], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 318, "focalAPIEnd": 333, "followUpCheck": "bytes >= 0", "checkType": "LOOP {", "followUpCheckExpressionStart": 343, "followUpCheckExpressionEnd": 357, "followUpCheckBlockStart": 343, "followUpCheckBlockEnd": 436, "use": ["ByteArrayOutputStream.write(byte[],int,bytes)", "inputStream.read(byte[])", "inputStream.close()"], "useStart": [370, 410, 445], "useEnd": [394, 425, 455], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/michaelcadilhac/pdfannot/tree/master/platform/android/src/com/artifex/mupdfdemo/PrintDialogActivity.java", "rawCode": "    public String getContent() {\n      try {\n        ContentResolver contentResolver = getContentResolver();\n        InputStream is = contentResolver.openInputStream(cloudPrintIntent.getData());\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        byte[] buffer = new byte[4096];\n        int n = is.read(buffer);\n        while (n >= 0) {\n          baos.write(buffer, 0, n);\n          n = is.read(buffer);\n        }\n        is.close();\n        baos.flush();\n\n        return Base64.encodeToString(baos.toByteArray(), Base64.DEFAULT);\n      } catch (Throwable e) {\n        resultCode = RESULT_CANCELED;\n        setResult(resultCode);\n        finish();\n        e.printStackTrace();\n      }\n      return \"\";\n    }\n"}, {"dataset": "inputStreamRead", "exampleID": 2688, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 169, "focalAPIEnd": 187, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mbastian/gephi-maven/tree/master/modules/ImportAPI/src/main/java/org/gephi/io/importer/api/ImportUtils.java", "rawCode": "  private static void ignoreBytes(InputStream inputStream, int numberOfBytes) throws IOException {\n    for (int counter = 0; counter < numberOfBytes; counter++) {\n      inputStream.read();\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2689, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 344, "focalAPIEnd": 361, "followUpCheck": "bytes <= 0", "checkType": "IF", "followUpCheckExpressionStart": 369, "followUpCheckExpressionEnd": 384, "followUpCheckBlockStart": 369, "followUpCheckBlockEnd": 391, "use": ["inputStream.close()"], "useStart": [402], "useEnd": [412], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.6.0/src/util/misc/IO.java", "rawCode": "  /**\n   * Reads all data to EOF from an input stream, discarding it.\n   *\n   * @param is Input stream (will be closed at end)\n   * @throws IOException If there's any I/O error in process\n   */\n  public static void eat(InputStream is) throws IOException {\n    byte[] abBuffer = new byte[COPYBUFFER_LENGTH];\n    while (true) {\n      int iRead = is.read(abBuffer);\n      if (iRead <= 0) break;\n    }\n    is.close(); // Was at EOF anyway\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2690, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 45, "tryExpressionEnd": 49, "tryBlockStart": 45, "tryBlockEnd": 264, "catchExpressionStart": 199, "catchExpressionEnd": 225, "catchBlockStart": 199, "catchBlockEnd": 264, "exceptionHandlingCallStart": [236], "exceptionHandlingCallEnd": [255], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 68, "focalAPIEnd": 77, "followUpCheck": "bytes != -1", "checkType": "LOOP {", "followUpCheckExpressionStart": 111, "followUpCheckExpressionEnd": 126, "followUpCheckBlockStart": 111, "followUpCheckBlockEnd": 189, "use": ["OutputStream.write(bytes)", "inputStream.read()", "OutputStream.write(bytes)"], "useStart": [88, 144, 166], "useEnd": [100, 153, 178], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/tomee/tree/master/server/openejb-server/src/main/java/org/apache/openejb/server/Start.java", "rawCode": "    @Override\n    public void run() {\n\n      try {\n\n        int i = is.read();\n\n        out.write(i);\n\n        while (i != -1) {\n\n          i = is.read();\n\n          out.write(i);\n        }\n\n      } catch (final Exception e) {\n\n        e.printStackTrace();\n      }\n    }\n"}, {"dataset": "inputStreamRead", "exampleID": 2691, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IndexOutOfBoundsException", "exceptionHandlingCall": ["fail(String)"], "tryExpressionStart": 149, "tryExpressionEnd": 153, "tryBlockStart": 149, "tryBlockEnd": 318, "catchExpressionStart": 257, "catchExpressionEnd": 293, "catchBlockStart": 257, "catchBlockEnd": 318, "exceptionHandlingCallStart": [922], "exceptionHandlingCallEnd": [975], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 173, "focalAPIEnd": 190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.read(byte[],int,int)", "inputStream.read(byte[],int,int)", "inputStream.read(byte[],int,int)", "assertEquals(String,bytes,int)", "inputStream.read(byte[],int,int)", "assertEquals(String,bytes,int)"], "useStart": [379, 652, 854, 987, 1083, 1201], "useEnd": [396, 668, 870, 1024, 1099, 1238], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wsot/platform_libcore/tree/master/luni/src/test/java/libcore/java/io/OldInputStreamTest.java", "rawCode": "  public void test_read$BII_Exception() throws IOException {\n    byte[] b = new byte[10];\n    int bytesRead = 0;\n\n    // Test 1: Invalid offset.\n    try {\n      bytesRead = is.read(b, -1, 5);\n      fail(\"Test 1: IndexOutOfBoundsException expected.\");\n    } catch (IndexOutOfBoundsException e) {\n      // expected\n    }\n\n    // Test 2: Invalid length.\n    try {\n      bytesRead = is.read(b, 5, -1);\n      fail(\"Test 2: IndexOutOfBoundsException expected.\");\n    } catch (IndexOutOfBoundsException e) {\n      // expected\n    }\n\n    // Test 3: Invalid offset and length combination (sum is larger\n    // than the length of b).\n    try {\n      bytesRead = is.read(b, 6, 5);\n      fail(\"Test 3: IndexOutOfBoundsException expected.\");\n    } catch (IndexOutOfBoundsException e) {\n      // expected\n    }\n\n    // Test 4: Border case.\n    try {\n      bytesRead = is.read(b, 6, 4);\n    } catch (IndexOutOfBoundsException e) {\n      fail(\"Test 4: Unexpected IndexOutOfBoundsException.\");\n    }\n    assertEquals(\"Test 4:\", bytesRead, 4);\n\n    // Test 5: Border case.\n    try {\n      bytesRead = is.read(b, 6, 0);\n    } catch (Exception e) {\n      fail(\"Test 5: Unexpected Exception \" + e.getMessage());\n    }\n    assertEquals(\"Test 5:\", bytesRead, 0);\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2692, "initialization": ["int len = readInt(InputStream)"], "initializationStart": [105], "initializationEnd": [120], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 161, "focalAPIEnd": 188, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hudson3-plugins/perforce-plugin/tree/master/src/main/java/hudson/plugins/perforce/PerforceSCMHelper.java", "rawCode": "  private static String readPythonString(InputStream stream) throws IOException {\n    int length = (int) readInt(stream);\n    byte[] buf = new byte[length];\n    stream.read(buf, 0, length);\n    String result = new String(buf);\n    return result;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2693, "initialization": ["InputStream inputStream = new FileInputStream(File)"], "initializationStart": [311], "initializationEnd": [340], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 435, "focalAPIEnd": 448, "followUpCheck": "bytes != -1", "checkType": "LOOP {", "followUpCheckExpressionStart": 455, "followUpCheckExpressionEnd": 474, "followUpCheckBlockStart": 455, "followUpCheckBlockEnd": 575, "use": ["OutputStream.write(byte[],int,bytes)", "IProgressMonitor.worked(bytes)", "inputStream.read(byte[])", "inputStream.close()"], "useStart": [483, 517, 555, 581], "useEnd": [508, 538, 568, 591], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SjB/Dart/tree/master/editor/tools/plugins/com.google.dart.tools.update.core/src/com/google/dart/tools/update/core/internal/UpdateUtils.java", "rawCode": "  /** Copy a file from one place to another, providing progress along the way. */\n  public static void copyFile(File fromFile, File toFile, IProgressMonitor monitor)\n      throws IOException {\n\n    // System.out.println(\"copying \" + fromFile.getName());\n\n    byte[] data = new byte[4096];\n\n    InputStream in = new FileInputStream(fromFile);\n\n    toFile.delete();\n\n    OutputStream out = new FileOutputStream(toFile);\n\n    int count = in.read(data);\n\n    while (count != -1) {\n      out.write(data, 0, count);\n\n      monitor.worked(count);\n\n      count = in.read(data);\n    }\n\n    in.close();\n    out.close();\n\n    toFile.setLastModified(fromFile.lastModified());\n\n    monitor.done();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2694, "initialization": ["InputStream inputStream = ZipFile.getInputStream(ZipEntry)"], "initializationStart": [420], "initializationEnd": [448], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 500, "focalAPIEnd": 515, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.close()"], "useStart": [521], "useEnd": [535], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/vjet.all/tree/master/core/org.eclipse.vjet.core.jstojava/src/org/eclipse/vjet/dsf/jstojava/loader/OnDemandAllTypeLoader.java", "rawCode": "  protected SourceType createType(String groupName, ZipFile jarFile, ZipEntry elem)\n      throws IOException {\n\n    String typeName = elem.getName();\n    if (!typeName.endsWith(JS)) {\n      return null;\n    }\n    int end = typeName.lastIndexOf(JS); // remove .js\n\n    typeName = typeName.substring(0, end);\n    typeName = typeName.replace(\"\\\\\", \".\");\n    typeName = typeName.replace(\"/\", \".\");\n\n    InputStream stream = jarFile.getInputStream(elem);\n    byte[] bs = new byte[stream.available()];\n    stream.read(bs);\n    stream.close();\n\n    String source = new String(bs);\n\n    File f = null;\n    f = new File(jarFile.getName() + \"!\" + elem.getName());\n\n    SourceType srcType = new SourceType(groupName, typeName, source, f);\n\n    return srcType;\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2695, "initialization": ["InputStream inputStream = Resource.getInputStream()"], "initializationStart": [3799], "initializationEnd": [3817], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b,off,len)", "focalAPIStart": 3958, "focalAPIEnd": 3991, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["close(inputStream)"], "useStart": [4080], "useEnd": [4099], "hasFinally": 1, "cleanUpCall": ["close(InputStream)"], "finallyExpressionStart": 4064, "finallyExpressionEnd": 4072, "finallyBlockStart": 4064, "finallyBlockEnd": 4106, "cleanUpCallStart": [4080], "cleanUpCallEnd": [4099], "url": "https://github.com/and146/SPLAT-ARI/tree/master/ant/src/main/org/apache/tools/ant/taskdefs/Tar.java", "rawCode": "  /**\n   * tar a resource\n   *\n   * @param r the resource to tar\n   * @param tOut the output stream\n   * @param vPath the path name of the file to tar\n   * @param tarFileSet the fileset that the file came from, may be null.\n   * @throws IOException on error\n   * @since Ant 1.7\n   */\n  protected void tarResource(Resource r, TarOutputStream tOut, String vPath, TarFileSet tarFileSet)\n      throws IOException {\n\n    if (!r.isExists()) {\n      return;\n    }\n\n    if (tarFileSet != null) {\n      String fullpath = tarFileSet.getFullpath(this.getProject());\n      if (fullpath.length() > 0) {\n        vPath = fullpath;\n      } else {\n        // don't add \"\" to the archive\n        if (vPath.length() <= 0) {\n          return;\n        }\n\n        String prefix = tarFileSet.getPrefix(this.getProject());\n        // '/' is appended for compatibility with the zip task.\n        if (prefix.length() > 0 && !prefix.endsWith(\"/\")) {\n          prefix = prefix + \"/\";\n        }\n        vPath = prefix + vPath;\n      }\n\n      if (vPath.startsWith(\"/\") && !tarFileSet.getPreserveLeadingSlashes()) {\n        int l = vPath.length();\n        if (l <= 1) {\n          // we would end up adding \"\" to the archive\n          return;\n        }\n        vPath = vPath.substring(1, l);\n      }\n    }\n\n    if (r.isDirectory() && !vPath.endsWith(\"/\")) {\n      vPath += \"/\";\n    }\n\n    if (vPath.length() >= TarConstants.NAMELEN) {\n      if (longFileMode.isOmitMode()) {\n        log(\"Omitting: \" + vPath, Project.MSG_INFO);\n        return;\n      } else if (longFileMode.isWarnMode()) {\n        log(\n            \"Entry: \" + vPath + \" longer than \" + TarConstants.NAMELEN + \" characters.\",\n            Project.MSG_WARN);\n        if (!longWarningGiven) {\n          log(\n              \"Resulting tar file can only be processed \"\n                  + \"successfully by GNU compatible tar commands\",\n              Project.MSG_WARN);\n          longWarningGiven = true;\n        }\n      } else if (longFileMode.isFailMode()) {\n        throw new BuildException(\n            \"Entry: \" + vPath + \" longer than \" + TarConstants.NAMELEN + \"characters.\",\n            getLocation());\n      }\n    }\n\n    TarEntry te = new TarEntry(vPath);\n    te.setModTime(r.getLastModified());\n    // preserve permissions\n    if (r instanceof ArchiveResource) {\n      ArchiveResource ar = (ArchiveResource) r;\n      te.setMode(ar.getMode());\n      if (r instanceof TarResource) {\n        TarResource tr = (TarResource) r;\n        te.setUserName(tr.getUserName());\n        te.setUserId(tr.getUid());\n        te.setGroupName(tr.getGroup());\n        te.setGroupId(tr.getGid());\n      }\n    }\n\n    if (!r.isDirectory()) {\n      if (r.size() > TarConstants.MAXSIZE) {\n        throw new BuildException(\n            \"Resource: \" + r + \" larger than \" + TarConstants.MAXSIZE + \" bytes.\");\n      }\n      te.setSize(r.getSize());\n      // override permissions if set explicitly\n      if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {\n        te.setMode(tarFileSet.getMode());\n      }\n    } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {\n      // override permissions if set explicitly\n      te.setMode(tarFileSet.getDirMode(this.getProject()));\n    }\n\n    if (tarFileSet != null) {\n      // only override permissions if set explicitly\n      if (tarFileSet.hasUserNameBeenSet()) {\n        te.setUserName(tarFileSet.getUserName());\n      }\n      if (tarFileSet.hasGroupBeenSet()) {\n        te.setGroupName(tarFileSet.getGroup());\n      }\n      if (tarFileSet.hasUserIdBeenSet()) {\n        te.setUserId(tarFileSet.getUid());\n      }\n      if (tarFileSet.hasGroupIdBeenSet()) {\n        te.setGroupId(tarFileSet.getGid());\n      }\n    }\n\n    InputStream in = null;\n    try {\n      tOut.putNextEntry(te);\n\n      if (!r.isDirectory()) {\n        in = r.getInputStream();\n\n        byte[] buffer = new byte[8 * 1024];\n        int count = 0;\n        do {\n          tOut.write(buffer, 0, count);\n          count = in.read(buffer, 0, buffer.length);\n        } while (count != -1);\n      }\n\n      tOut.closeEntry();\n    } finally {\n      FileUtils.close(in);\n    }\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2696, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 81, "focalAPIEnd": 95, "followUpCheck": "bytes != LF", "checkType": "IF", "followUpCheckExpressionStart": 103, "followUpCheckExpressionEnd": 116, "followUpCheckBlockStart": 103, "followUpCheckBlockEnd": 192, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/funambol-mirror/funambol-client-sdk/tree/master/v911/common/src/main/java-me/com/funambol/platform/HttpConnectionAdapter.java", "rawCode": "    private void readLF(InputStream aStream) throws IOException {\n      int lf = aStream.read();\n      if (lf != LF) {\n        throw new IOException(\"Expected LF char in InputStream\");\n      }\n    }\n"}, {"dataset": "inputStreamRead", "exampleID": 2697, "initialization": ["InputStream inputStream = getResources()"], "initializationStart": [371], "initializationEnd": [385], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 333, "tryExpressionEnd": 337, "tryBlockStart": 333, "tryBlockEnd": 663, "catchExpressionStart": 607, "catchExpressionEnd": 629, "catchBlockStart": 607, "catchBlockEnd": 663, "exceptionHandlingCallStart": [637], "exceptionHandlingCallEnd": [656], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 485, "focalAPIEnd": 517, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.close()"], "useStart": [525], "useEnd": [544], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ouya/ouya-sdk-examples/tree/master/Unity/GameAnalytics/Assets/Plugins/Android/src/OuyaUnityApplication.java", "rawCode": "  protected void onCreate(Bundle savedInstanceState) {\n    // make activity accessible to Unity\n    IOuyaActivity.SetActivity(this);\n\n    // make bundle accessible to Unity\n    IOuyaActivity.SetSavedInstanceState(savedInstanceState);\n\n    super.onCreate(savedInstanceState);\n\n    // load the raw resource for the application key\n    try {\n      InputStream inputStream = getResources().openRawResource(R.raw.key);\n      byte[] applicationKey = new byte[inputStream.available()];\n      inputStream.read(applicationKey);\n      inputStream.close();\n      IOuyaActivity.SetApplicationKey(applicationKey);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n\n    // Create the UnityPlayer\n    IOuyaActivity.SetUnityPlayer(new UnityPlayer(this));\n    int glesMode = IOuyaActivity.GetUnityPlayer().getSettings().getInt(\"gles_mode\", 1);\n    boolean trueColor8888 = false;\n    IOuyaActivity.GetUnityPlayer().init(glesMode, trueColor8888);\n    setContentView(R.layout.main);\n\n    // Add the Unity view\n    FrameLayout layout = (FrameLayout) findViewById(R.id.unityLayout);\n    LayoutParams lp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);\n    layout.addView(IOuyaActivity.GetUnityPlayer().getView(), 0, lp);\n    IOuyaActivity.SetLayout(layout);\n\n    // Set the focus\n    RelativeLayout mainLayout = (RelativeLayout) findViewById(R.id.mainLayout);\n    mainLayout.setFocusableInTouchMode(true);\n\n    Context context = getBaseContext();\n\n    // Init the controller\n    OuyaController.init(context);\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2698, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 148, "focalAPIEnd": 157, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["inputStream.read()", "inputStream.close()"], "useStart": [172, 223], "useEnd": [181, 233], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/liucong/jms4cxf2/tree/master/common/common/src/main/java/org/apache/cxf/helpers/IOUtils.java", "rawCode": "  public static String readStringFromStream(InputStream in) throws IOException {\n\n    StringBuilder sb = new StringBuilder(1024);\n\n    for (int i = in.read(); i != -1; i = in.read()) {\n      sb.append((char) i);\n    }\n\n    in.close();\n\n    return sb.toString();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2699, "initialization": ["InputStream inputStream = new FileInputStream(String)"], "initializationStart": [96], "initializationEnd": [125], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read(b)", "focalAPIStart": 269, "focalAPIEnd": 285, "followUpCheck": "bytes > 0", "checkType": "IF", "followUpCheckExpressionStart": 293, "followUpCheckExpressionEnd": 309, "followUpCheckBlockStart": 293, "followUpCheckBlockEnd": 364, "use": ["MessageDigest.update(byte[],int,bytes)", "inputStream.close()"], "useStart": [320, 398], "useEnd": [355, 409], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RomRaider/assembla.flat/tree/master/trunk/src/com/romraider/util/MD5Checksum.java", "rawCode": "  public static byte[] createChecksum(String filename) throws Exception {\n    InputStream fis = new FileInputStream(filename);\n\n    byte[] buffer = new byte[1024];\n    MessageDigest complete = MessageDigest.getInstance(\"MD5\");\n    int numRead;\n    do {\n      numRead = fis.read(buffer);\n      if (numRead > 0) {\n        complete.update(buffer, 0, numRead);\n      }\n    } while (numRead != -1);\n    fis.close();\n    return complete.digest();\n  }\n"}, {"dataset": "inputStreamRead", "exampleID": 2700, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "bytes = inputStream.read()", "focalAPIStart": 228, "focalAPIEnd": 243, "followUpCheck": "bytes < 0", "checkType": "IF", "followUpCheckExpressionStart": 254, "followUpCheckExpressionEnd": 268, "followUpCheckBlockStart": 254, "followUpCheckBlockEnd": 341, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ALRubinger/shrinkwrap/tree/master/impl-base/src/main/java/org/jboss/shrinkwrap/impl/base/io/tar/bzip/BZip2CompressorInputStream.java", "rawCode": "  private int bsR(final int n) throws IOException {\n    int bsLiveShadow = this.bsLive;\n    int bsBuffShadow = this.bsBuff;\n\n    if (bsLiveShadow < n) {\n      final InputStream inShadow = this.in;\n      do {\n        int thech = inShadow.read();\n\n        if (thech < 0) {\n          throw new IOException(\"unexpected end of stream\");\n        }\n\n        bsBuffShadow = (bsBuffShadow << 8) | thech;\n        bsLiveShadow += 8;\n      } while (bsLiveShadow < n);\n\n      this.bsBuff = bsBuffShadow;\n    }\n\n    this.bsLive = bsLiveShadow - n;\n    return (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n  }\n"}]