[{"dataset": "byteBufferGet", "exampleID": 801, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.remaining()"], "configurationStart": [78], "configurationEnd": [94], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 327, "focalAPIEnd": 337, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)", "ByteBuffer.put(byteBuffer)"], "useStart": [320, 387], "useEnd": [338, 399], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.java_websocket/src/main/java/org/java_websocket/SSLSocketChannel2.java", "rawCode": "  private int transfereTo(ByteBuffer from, ByteBuffer to) {\n    int fremain = from.remaining();\n    int toremain = to.remaining();\n    if (fremain > toremain) {\n      // FIXME there should be a more efficient transfer method\n      int limit = Math.min(fremain, toremain);\n      for (int i = 0; i < limit; i++) {\n        to.put(from.get());\n      }\n      return limit;\n    } else {\n      to.put(from);\n      return fremain;\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 802, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/kernel-1.3.x-release/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 803, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.remaining()"], "configurationStart": [96], "configurationEnd": [111], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 159, "guardExpressionEnd": 185, "guardBlockStart": 159, "guardBlockEnd": 406, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 218, "focalAPIEnd": 227, "followUpCheck": "value == (byte)'\\n'", "checkType": "IF", "followUpCheckExpressionStart": 256, "followUpCheckExpressionEnd": 302, "followUpCheckBlockStart": 256, "followUpCheckBlockEnd": 400, "use": ["ByteBuffer.put(value)", "byteBuffer.position()", "byteBuffer.position()", "byteBuffer.position(int)"], "useStart": [235, 324, 475, 462], "useEnd": [248, 339, 489, 508], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/btwmodsbiz/server-mods/tree/master/src/org/java_websocket/drafts/Draft.java", "rawCode": "  public static ByteBuffer readLine(ByteBuffer buf) {\n    ByteBuffer sbuf = ByteBuffer.allocate(buf.remaining());\n    byte prev = '0';\n    byte cur = '0';\n    while (buf.hasRemaining()) {\n      prev = cur;\n      cur = buf.get();\n      sbuf.put(cur);\n      if (prev == (byte) '\\r' && cur == (byte) '\\n') {\n        sbuf.limit(sbuf.position() - 2);\n        sbuf.position(0);\n        return sbuf;\n      }\n    }\n    // ensure that there wont be any bytes skipped\n    buf.position(buf.position() - sbuf.position());\n    return null;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 804, "initialization": ["ByteBuffer byteBuffer = loadImage(*,boolean,boolean,*)"], "initializationStart": [690], "initializationEnd": [768], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<byteBuffer.limit()", "guardType": "LOOP {", "guardExpressionStart": 774, "guardExpressionEnd": 814, "guardBlockStart": 774, "guardBlockEnd": 1065, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 834, "focalAPIEnd": 844, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.get(byte[])", "byteBuffer.get(byte[])", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.put(byte,byte)", "byteBuffer.put(int,byte)", "byteBuffer.put(byte,byte)"], "useStart": [865, 899, 934, 957, 984, 1013, 1037], "useEnd": [879, 913, 948, 976, 1005, 1029, 1058], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ribab/Zed/tree/master/slick/src/org/newdawn/slick/opengl/CursorLoader.java", "rawCode": "  /**\n   * Get a cursor based on a image reference on the classpath\n   *\n   * @param ref The reference to the image to be loaded\n   * @param x The x-coordinate of the cursor hotspot (left -> right)\n   * @param y The y-coordinate of the cursor hotspot (bottom -> top)\n   * @return The create cursor\n   * @throws IOException Indicates a failure to load the image\n   * @throws LWJGLException Indicates a failure to create the hardware cursor\n   */\n  public Cursor getCursor(String ref, int x, int y) throws IOException, LWJGLException {\n    LoadableImageData imageData = null;\n\n    imageData = ImageDataFactory.getImageDataFor(ref);\n    imageData.configureEdging(false);\n\n    ByteBuffer buf = imageData.loadImage(ResourceLoader.getResourceAsStream(ref), true, true, null);\n    for (int i = 0; i < buf.limit(); i += 4) {\n      byte red = buf.get(i);\n      byte green = buf.get(i + 1);\n      byte blue = buf.get(i + 2);\n      byte alpha = buf.get(i + 3);\n\n      buf.put(i + 2, red);\n      buf.put(i + 1, green);\n      buf.put(i, blue);\n      buf.put(i + 3, alpha);\n    }\n\n    try {\n      int yspot = imageData.getHeight() - y - 1;\n      if (yspot < 0) {\n        yspot = 0;\n      }\n\n      return new Cursor(\n          imageData.getTexWidth(), imageData.getTexHeight(), x, yspot, 1, buf.asIntBuffer(), null);\n    } catch (Throwable e) {\n      Log.info(\"Chances are you cursor is too small for this platform\");\n      throw new LWJGLException(e);\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 805, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<schema.size()", "guardType": "LOOP {", "guardExpressionStart": 189, "guardExpressionEnd": 228, "guardBlockStart": 189, "guardBlockEnd": 1785, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 356, "focalAPIEnd": 368, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["value.asByte()", "byteBuffer.get(int)", "value.asByte()", "byteBuffer.get(int)", "value.asByte()", "byteBuffer.get(int)", "value.asInt2()", "byteBuffer.get(int)", "value.asInt4()", "byteBuffer.get(int)", "value.asInt8()", "byteBuffer.get(int)", "value.asFloat4()", "byteBuffer.get(int)", "value.asFloat8()", "byteBuffer.get(int)", "value.asByteArray()", "byteBuffer.get(int)", "value.asInt4()", "byteBuffer.get(int)", "value.asInt8()", "byteBuffer.get(int)", "value.asByteArray()", "byteBuffer.get(int)", "value.asByteArray()", "byteBuffer.get(int)", "value.asByteArray()"], "useStart": [356, 438, 438, 521, 521, 609, 609, 695, 695, 782, 782, 872, 872, 965, 965, 1060, 1060, 1218, 1218, 1331, 1331, 1422, 1422, 1584, 1584, 1701, 1701], "useEnd": [377, 450, 459, 533, 542, 621, 630, 707, 716, 794, 803, 884, 895, 977, 988, 1072, 1086, 1230, 1239, 1343, 1352, 1434, 1448, 1596, 1610, 1713, 1727], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/incubator-tajo/tree/master/tajo-storage/src/main/java/org/apache/tajo/storage/RowStoreUtil.java", "rawCode": "    public static byte[] toBytes(Schema schema, Tuple tuple) {\n      int size = StorageUtil.getRowByteSize(schema);\n      ByteBuffer bb = ByteBuffer.allocate(size);\n      Column col;\n      for (int i = 0; i < schema.size(); i++) {\n        col = schema.getColumn(i);\n        switch (col.getDataType().getType()) {\n          case BOOLEAN:\n            bb.put(tuple.get(i).asByte());\n            break;\n          case BIT:\n            bb.put(tuple.get(i).asByte());\n            break;\n          case CHAR:\n            bb.put(tuple.get(i).asByte());\n            break;\n          case INT2:\n            bb.putShort(tuple.get(i).asInt2());\n            break;\n          case INT4:\n            bb.putInt(tuple.get(i).asInt4());\n            break;\n          case INT8:\n            bb.putLong(tuple.get(i).asInt8());\n            break;\n          case FLOAT4:\n            bb.putFloat(tuple.get(i).asFloat4());\n            break;\n          case FLOAT8:\n            bb.putDouble(tuple.get(i).asFloat8());\n            break;\n          case TEXT:\n            byte[] _string = tuple.get(i).asByteArray();\n            bb.putInt(_string.length);\n            bb.put(_string);\n            break;\n          case DATE:\n            bb.putInt(tuple.get(i).asInt4());\n            break;\n          case TIME:\n          case TIMESTAMP:\n            bb.putLong(tuple.get(i).asInt8());\n            break;\n          case BLOB:\n            byte[] bytes = tuple.get(i).asByteArray();\n            bb.putInt(bytes.length);\n            bb.put(bytes);\n            break;\n          case INET4:\n            byte[] ipBytes = tuple.get(i).asByteArray();\n            bb.put(ipBytes);\n            break;\n          case INET6:\n            bb.put(tuple.get(i).asByteArray());\n            break;\n          default:\n        }\n      }\n\n      bb.flip();\n      byte[] buf = new byte[bb.limit()];\n      bb.get(buf);\n      return buf;\n    }\n"}, {"dataset": "byteBufferGet", "exampleID": 806, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0-rc01/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 807, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<to", "guardType": "LOOP {", "guardExpressionStart": 244, "guardExpressionEnd": 275, "guardBlockStart": 244, "guardBlockEnd": 303, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 293, "focalAPIEnd": 301, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thinkaurelius/titan/tree/master/titan-core/src/main/java/com/thinkaurelius/titan/diskstorage/util/WriteByteBuffer.java", "rawCode": "  @Override\n  public StaticBuffer getStaticBufferFlipBytes(int from, int to) {\n    ByteBuffer b = buffer.duplicate();\n    b.flip();\n    Preconditions.checkArgument(from >= 0 && from <= to);\n    Preconditions.checkArgument(to <= b.limit());\n    for (int i = from; i < to; i++) b.put(i, (byte) ~b.get(i));\n    return new StaticByteBuffer(b);\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 808, "initialization": ["ByteBuffer byteBuffer = createByteBuffer(*)"], "initializationStart": [4700], "initializationEnd": [4744], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte[])"], "configurationStart": [4750], "configurationEnd": [4770], "guardCondition": "index<texWidth*perPixel", "guardType": "LOOP {", "guardExpressionStart": 4974, "guardExpressionEnd": 5019, "guardBlockStart": 4974, "guardBlockEnd": 5197, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 5057, "focalAPIEnd": 5071, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.flip()"], "useStart": [5030, 5149, 5082, 5426, 5335, 5576, 5481, 5679], "useEnd": [5072, 5187, 5188, 5468, 5469, 5647, 5648, 5693], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guodman/5games5nights2009/tree/master/Slick/src/org/newdawn/slick/opengl/TGAImageData.java", "rawCode": "  /**\n   * @see org.newdawn.slick.opengl.LoadableImageData#loadImage(java.io.InputStream, boolean,\n   *     boolean, int[])\n   */\n  public ByteBuffer loadImage(\n      InputStream fis, boolean flipped, boolean forceAlpha, int[] transparent) throws IOException {\n    if (transparent != null) {\n      forceAlpha = true;\n    }\n    byte red = 0;\n    byte green = 0;\n    byte blue = 0;\n    byte alpha = 0;\n\n    BufferedInputStream bis = new BufferedInputStream(fis, 100000);\n    DataInputStream dis = new DataInputStream(bis);\n\n    // Read in the Header\n    short idLength = (short) dis.read();\n    short colorMapType = (short) dis.read();\n    short imageType = (short) dis.read();\n    short cMapStart = flipEndian(dis.readShort());\n    short cMapLength = flipEndian(dis.readShort());\n    short cMapDepth = (short) dis.read();\n    short xOffset = flipEndian(dis.readShort());\n    short yOffset = flipEndian(dis.readShort());\n\n    width = flipEndian(dis.readShort());\n    height = flipEndian(dis.readShort());\n    pixelDepth = (short) dis.read();\n    if (pixelDepth == 32) {\n      forceAlpha = false;\n    }\n\n    texWidth = get2Fold(width);\n    texHeight = get2Fold(height);\n\n    short imageDescriptor = (short) dis.read();\n    if ((imageDescriptor & 0x0020) == 0) {\n      flipped = !flipped;\n    }\n\n    // Skip image ID\n    if (idLength > 0) {\n      bis.skip(idLength);\n    }\n\n    byte[] rawData = null;\n    if ((pixelDepth == 32) || (forceAlpha)) {\n      pixelDepth = 32;\n      rawData = new byte[texWidth * texHeight * 4];\n    } else if (pixelDepth == 24) {\n      rawData = new byte[texWidth * texHeight * 3];\n    } else {\n      throw new RuntimeException(\"Only 24 and 32 bit TGAs are supported\");\n    }\n\n    if (pixelDepth == 24) {\n      if (flipped) {\n        for (int i = height - 1; i >= 0; i--) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n\n            int ofs = ((j + (i * texWidth)) * 3);\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n          }\n        }\n      } else {\n        for (int i = 0; i < height; i++) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n\n            int ofs = ((j + (i * texWidth)) * 3);\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n          }\n        }\n      }\n    } else if (pixelDepth == 32) {\n      if (flipped) {\n        for (int i = height - 1; i >= 0; i--) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n            if (forceAlpha) {\n              alpha = (byte) 255;\n            } else {\n              alpha = dis.readByte();\n            }\n\n            int ofs = ((j + (i * texWidth)) * 4);\n\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n            rawData[ofs + 3] = alpha;\n\n            if (alpha == 0) {\n              rawData[ofs + 2] = (byte) 0;\n              rawData[ofs + 1] = (byte) 0;\n              rawData[ofs] = (byte) 0;\n            }\n          }\n        }\n      } else {\n        for (int i = 0; i < height; i++) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n            if (forceAlpha) {\n              alpha = (byte) 255;\n            } else {\n              alpha = dis.readByte();\n            }\n\n            int ofs = ((j + (i * texWidth)) * 4);\n\n            if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) {\n              rawData[ofs] = red;\n              rawData[ofs + 1] = green;\n              rawData[ofs + 2] = blue;\n              rawData[ofs + 3] = alpha;\n            } else {\n              rawData[ofs] = red;\n              rawData[ofs + 1] = green;\n              rawData[ofs + 2] = blue;\n              rawData[ofs + 3] = alpha;\n            }\n\n            if (alpha == 0) {\n              rawData[ofs + 2] = 0;\n              rawData[ofs + 1] = 0;\n              rawData[ofs] = 0;\n            }\n          }\n        }\n      }\n    }\n    fis.close();\n\n    if (transparent != null) {\n      for (int i = 0; i < rawData.length; i += 4) {\n        boolean match = true;\n        for (int c = 0; c < 3; c++) {\n          if (rawData[i + c] != transparent[c]) {\n            match = false;\n          }\n        }\n\n        if (match) {\n          rawData[i + 3] = 0;\n        }\n      }\n    }\n\n    // Get a pointer to the image memory\n    ByteBuffer scratch = BufferUtils.createByteBuffer(rawData.length);\n    scratch.put(rawData);\n\n    int perPixel = pixelDepth / 8;\n    if (height < texHeight - 1) {\n      int topOffset = (texHeight - 1) * (texWidth * perPixel);\n      int bottomOffset = (height - 1) * (texWidth * perPixel);\n      for (int x = 0; x < texWidth * perPixel; x++) {\n        scratch.put(topOffset + x, scratch.get(x));\n        scratch.put(\n            bottomOffset + (texWidth * perPixel) + x, scratch.get((texWidth * perPixel) + x));\n      }\n    }\n    if (width < texWidth - 1) {\n      for (int y = 0; y < texHeight; y++) {\n        for (int i = 0; i < perPixel; i++) {\n          scratch.put(\n              ((y + 1) * (texWidth * perPixel)) - perPixel + i,\n              scratch.get(y * (texWidth * perPixel) + i));\n          scratch.put(\n              (y * (texWidth * perPixel)) + (width * perPixel) + i,\n              scratch.get((y * (texWidth * perPixel)) + ((width - 1) * perPixel) + i));\n        }\n      }\n    }\n\n    scratch.flip();\n\n    return scratch;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 809, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(byteBuffer.remaining()<=buffer.remaining())", "guardType": "IF {", "guardExpressionStart": 118, "guardExpressionEnd": 167, "guardBlockStart": 118, "guardBlockEnd": 253, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 443, "focalAPIEnd": 459, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)", "process(byteBuffer)", "ByteBuffer.put(byteBuffer)"], "useStart": [432, 675, 773], "useEnd": [460, 694, 795], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lowasser/guava-experimental/tree/master/guava/src/com/google/common/hash/AbstractStreamingHashFunction.java", "rawCode": "    private final Hasher putBytes(ByteBuffer readBuffer) {\n      // If we have room for all of it, this is easy\n      if (readBuffer.remaining() <= buffer.remaining()) {\n        buffer.put(readBuffer);\n        munchIfFull();\n        return this;\n      }\n\n      // First add just enough to fill buffer size, and munch that\n      int bytesToCopy = bufferSize - buffer.position();\n      for (int i = 0; i < bytesToCopy; i++) {\n        buffer.put(readBuffer.get());\n      }\n      munch(); // buffer becomes empty here, since chunkSize divides bufferSize\n\n      // Now process directly from the rest of the input buffer\n      while (readBuffer.remaining() >= chunkSize) {\n        process(readBuffer);\n      }\n\n      // Finally stick the remainder back in our usual buffer\n      buffer.put(readBuffer);\n      return this;\n    }\n"}, {"dataset": "byteBufferGet", "exampleID": 810, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 1655, "focalAPIEnd": 1667, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Logger.debug(value)"], "useStart": [1618], "useEnd": [1668], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/osi/mulgara/tree/master/src/jar/store-stringpool/java/org/mulgara/store/stringpool/xa/SPDateTimeUnitTest.java", "rawCode": "  /** Tests that valid xsd:dateTime values are accepted and processed correctly. */\n  public void testValid() {\n    // Create a new factory\n    SPDateTimeFactory factory = new SPDateTimeFactory();\n\n    // Create a dateTime object by lexical string\n    SPDateTimeImpl dateTime =\n        (SPDateTimeImpl) factory.newSPTypedLiteral(XSD.DATE_TIME_URI, VALID_XSD_DATETIME);\n\n    // Test that the lexical form of the date is correct\n    assertEquals(VALID_XSD_DATETIME, dateTime.getLexicalForm());\n\n    // Retrieve the byte data of the dateTime object\n    ByteBuffer dtBytes = dateTime.getData();\n\n    // Retrieve the long value from the buffer\n    long dtLong = dtBytes.getLong();\n\n    // Create a date object from the dateTime's long\n    Date dtDate = new Date(dtLong);\n\n    // Format the resulting day\n    format.format(dtDate);\n\n    // Test the correct value is stored\n    assertEquals(VALID_XSD_DATETIME, getDateString(dateTime));\n\n    // Byte buffer to hold our date information\n    ByteBuffer buffer = ByteBuffer.wrap(new byte[Constants.SIZEOF_LONG + Constants.SIZEOF_INT]);\n\n    // If the previous step passed then we know the long value is what we want,\n    // so store it in our buffer\n    buffer.putLong(dtLong);\n    buffer.put((byte) 0x02); // The value of the \"local\" flag\n    buffer.put((byte) 0);\n\n    // Reset the buffer for reading\n    buffer.flip();\n\n    if (log.isDebugEnabled()) {\n\n      log.debug(\n          \"Creating dateTime from byte buffer storing value: \" + format.format(new Date(dtLong)));\n\n      log.debug(\"Original dateTime long vs. stored long: \" + dtLong + \" vs. \" + buffer.getLong());\n      log.debug(\"Stored timezone code: \" + buffer.get());\n      log.debug(\"Stored decimal places: \" + buffer.get());\n\n      // Reset the buffer\n      buffer.flip();\n    }\n\n    // Create a dateTime object by byte buffer\n    dateTime = (SPDateTimeImpl) factory.newSPTypedLiteral(0, buffer);\n\n    // Test that the lexical form of the date is correct\n    assertEquals(VALID_XSD_DATETIME, dateTime.getLexicalForm());\n\n    // Test the correct value is stored\n    assertEquals(VALID_XSD_DATETIME, getDateString(dateTime));\n\n    // Create a dateTime object by lexical string\n    dateTime = (SPDateTimeImpl) factory.newSPTypedLiteral(XSD.DATE_TIME_URI, VALID_XSD_DATETIME2);\n\n    // Test that the lexical form of the date is correct\n    assertEquals(VALID_XSD_DATETIME2, dateTime.getLexicalForm());\n\n    // Test the correct value is stored\n    assertEquals(VALID_XSD_DATETIME2, getDateString(dateTime));\n\n    // Create a dateTime object by lexical string\n    dateTime = (SPDateTimeImpl) factory.newSPTypedLiteral(XSD.DATE_TIME_URI, VALID_XSD_DATETIME3);\n\n    // Test that the lexical form of the date is correct\n    assertEquals(VALID_XSD_DATETIME3, dateTime.getLexicalForm());\n\n    // Test the correct value is stored\n    assertEquals(VALID_XSD_DATETIME3, getDateString(dateTime));\n\n    // Create a dateTime object by lexical string\n    dateTime = (SPDateTimeImpl) factory.newSPTypedLiteral(XSD.DATE_TIME_URI, VALID_XSD_DATETIME4);\n\n    // Test that the lexical form of the date is correct\n    assertEquals(VALID_XSD_DATETIME4, dateTime.getLexicalForm());\n\n    // Test the correct value is stored\n    assertEquals(VALID_XSD_DATETIME4, getDateString(dateTime));\n\n    // Create a dateTime object by lexical string\n    dateTime = (SPDateTimeImpl) factory.newSPTypedLiteral(XSD.DATE_TIME_URI, VALID_XSD_DATETIME5);\n\n    // Test that the lexical form of the date is correct\n    assertEquals(VALID_XSD_DATETIME5, dateTime.getLexicalForm());\n\n    // Test the correct value is stored\n    assertEquals(VALID_XSD_DATETIME5, getDateString(dateTime));\n\n    // Create a dateTime object by lexical string\n    dateTime = (SPDateTimeImpl) factory.newSPTypedLiteral(XSD.DATE_TIME_URI, VALID_XSD_DATETIME6);\n\n    // Test that the lexical form of the date is correct\n    assertEquals(VALID_XSD_DATETIME6, dateTime.getLexicalForm());\n\n    // Test the correct value is stored\n    assertEquals(VALID_JAVA_DATETIME6, getDateString(dateTime));\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 811, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": [], "tryExpressionStart": 403, "tryExpressionEnd": 407, "tryBlockStart": 403, "tryBlockEnd": 1073, "catchExpressionStart": 1040, "catchExpressionEnd": 1066, "catchBlockStart": 1040, "catchBlockEnd": 1073, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<200", "guardType": "LOOP {", "guardExpressionStart": 473, "guardExpressionEnd": 502, "guardBlockStart": 473, "guardBlockEnd": 545, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 896, "focalAPIEnd": 909, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bobmcwhirter/jboss-messaging/tree/master/tests/src/org/jboss/messaging/tests/unit/core/journal/impl/AlignedJournalImplTest.java", "rawCode": "  public void testBasicAlignment() throws Exception {\n\n    FakeSequentialFileFactory factory = new FakeSequentialFileFactory(200, true);\n\n    SequentialFile file = factory.createSequentialFile(\"test1\", 1);\n\n    file.open();\n\n    try {\n      ByteBuffer buffer = ByteBuffer.allocateDirect(57);\n      file.write(buffer, true);\n      fail(\"Exception expected\");\n    } catch (Exception ignored) {\n    }\n\n    try {\n      ByteBuffer buffer = ByteBuffer.allocateDirect(200);\n      for (int i = 0; i < 200; i++) {\n        buffer.put(i, (byte) 1);\n      }\n\n      file.write(buffer, true);\n\n      buffer = ByteBuffer.allocate(400);\n      for (int i = 0; i < 400; i++) {\n        buffer.put(i, (byte) 2);\n      }\n\n      file.write(buffer, true);\n\n      buffer = ByteBuffer.allocate(600);\n\n      file.position(0);\n\n      file.read(buffer);\n\n      for (int i = 0; i < 200; i++) {\n        assertEquals((byte) 1, buffer.get(i));\n      }\n\n      for (int i = 201; i < 600; i++) {\n        assertEquals(\"Position \" + i, (byte) 2, buffer.get(i));\n      }\n\n    } catch (Exception ignored) {\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 812, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 697, "focalAPIEnd": 706, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [686], "useEnd": [707], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bryanjimenez/empanada/tree/master/hadoop/hadoop-1.2.1/src/test/org/apache/hadoop/fs/slive/DataVerifier.java", "rawCode": "  /**\n   * Verifies a buffer of a given size using the given start hash offset\n   *\n   * @param buf the buffer to verify\n   * @param size the number of bytes to be used in that buffer\n   * @param startOffset the start hash offset\n   * @param hasher the hasher to use for calculating expected values\n   * @return ResumeBytes a set of data about the next offset and chunks analyzed\n   */\n  private VerifyInfo verifyBuffer(ByteBuffer buf, int size, long startOffset, DataHasher hasher) {\n    ByteBuffer cmpBuf = ByteBuffer.wrap(new byte[BYTES_PER_LONG]);\n    long hashOffset = startOffset;\n    long chunksSame = 0;\n    long chunksDifferent = 0;\n    for (long i = 0; i < size; ++i) {\n      cmpBuf.put(buf.get());\n      if (!cmpBuf.hasRemaining()) {\n        cmpBuf.rewind();\n        long receivedData = cmpBuf.getLong();\n        cmpBuf.rewind();\n        long expected = hasher.generate(hashOffset);\n        hashOffset += BYTES_PER_LONG;\n        if (receivedData == expected) {\n          ++chunksSame;\n        } else {\n          ++chunksDifferent;\n        }\n      }\n    }\n    // any left over??\n    if (cmpBuf.hasRemaining() && cmpBuf.position() != 0) {\n      // partial capture\n      // zero fill and compare with zero filled\n      int curSize = cmpBuf.position();\n      while (cmpBuf.hasRemaining()) {\n        cmpBuf.put((byte) 0);\n      }\n      long expected = hasher.generate(hashOffset);\n      ByteBuffer tempBuf = ByteBuffer.wrap(new byte[BYTES_PER_LONG]);\n      tempBuf.putLong(expected);\n      tempBuf.position(curSize);\n      while (tempBuf.hasRemaining()) {\n        tempBuf.put((byte) 0);\n      }\n      cmpBuf.rewind();\n      tempBuf.rewind();\n      if (cmpBuf.equals(tempBuf)) {\n        ++chunksSame;\n      } else {\n        ++chunksDifferent;\n      }\n    }\n    return new VerifyInfo(chunksSame, chunksDifferent);\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 813, "initialization": ["ByteBuffer byteBuffer = allocateDirect(int)"], "initializationStart": [514], "initializationEnd": [544], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.flip()"], "configurationStart": [616], "configurationEnd": [625], "guardCondition": "!(sc.read(byteBuffer,)!=1)", "guardType": "IF {", "guardExpressionStart": 552, "guardExpressionEnd": 573, "guardBlockStart": 552, "guardBlockEnd": 609, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 642, "focalAPIEnd": 650, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.clear()", "byteBuffer.put(byte[])", "byteBuffer.flip()"], "useStart": [723, 741, 766], "useEnd": [733, 758, 775], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/java/nio/channels/ServerSocketChannel/Basic.java", "rawCode": "    void go() throws Exception {\n      log.println(\"Server: Listening \" + (block ? \"(blocking)\" : \"(non-blocking)\"));\n      if (!block) ssc.configureBlocking(false);\n      log.println(\" \" + ssc);\n      // log.println(\" \" + ssc.options());\n      SocketChannel sc = null;\n      for (; ; ) {\n        sc = ssc.accept();\n        if (sc != null) {\n          break;\n        }\n        log.println(\"Server: Sleeping...\");\n        Thread.sleep(50);\n      }\n      log.println(\"Server: Accepted \" + sc);\n      ByteBuffer bb = ByteBuffer.allocateDirect(100);\n      if (sc.read(bb) != 1) throw new Exception(\"Read failed\");\n      bb.flip();\n      byte b = bb.get();\n      log.println(\"Server: Read \" + b + \", writing \" + (b + 1));\n      bb.clear();\n      bb.put((byte) 43);\n      bb.flip();\n      if (sc.write(bb) != 1) throw new Exception(\"Write failed\");\n      sc.close();\n      ssc.close();\n      log.println(\"Server: Finished\");\n    }\n"}, {"dataset": "byteBufferGet", "exampleID": 814, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 102, "focalAPIEnd": 117, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/linpawslitap/mds_scaling/tree/master/hadoop/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/util/TestDataChecksum.java", "rawCode": "  private static void uncorruptBufferOffset(ByteBuffer buf, int offset) {\n    buf.put(offset, (byte) (buf.get(offset) - 1));\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 815, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.3.1/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 816, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta11/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 817, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 2042, "focalAPIEnd": 2050, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/marymiller/floodlight/tree/master/src/main/java/net/floodlightcontroller/packet/TCP.java", "rawCode": "  /**\n   * Serializes the packet. Will compute and set the following fields if they are set to specific\n   * values at the time serialize is called: -checksum : 0 -length : 0\n   */\n  public byte[] serialize() {\n    int length;\n    if (dataOffset == 0) dataOffset = 5; // default header length\n    length = dataOffset << 2;\n    byte[] payloadData = null;\n    if (payload != null) {\n      payload.setParent(this);\n      payloadData = payload.serialize();\n      length += payloadData.length;\n    }\n\n    byte[] data = new byte[length];\n    ByteBuffer bb = ByteBuffer.wrap(data);\n\n    bb.putShort(this.sourcePort);\n    bb.putShort(this.destinationPort);\n    bb.putInt(this.sequence);\n    bb.putInt(this.acknowledge);\n    bb.putShort((short) (this.flags | (dataOffset << 12)));\n    bb.putShort(this.windowSize);\n    bb.putShort(this.checksum);\n    bb.putShort(this.urgentPointer);\n    if (dataOffset > 5) {\n      int padding;\n      bb.put(options);\n      padding = (dataOffset << 2) - 20 - options.length;\n      for (int i = 0; i < padding; i++) bb.put((byte) 0);\n    }\n    if (payloadData != null) bb.put(payloadData);\n\n    if (this.parent != null && this.parent instanceof IPv4)\n      ((IPv4) this.parent).setProtocol(IPv4.PROTOCOL_TCP);\n\n    // compute checksum if needed\n    if (this.checksum == 0) {\n      bb.rewind();\n      int accumulation = 0;\n\n      // compute pseudo header mac\n      if (this.parent != null && this.parent instanceof IPv4) {\n        IPv4 ipv4 = (IPv4) this.parent;\n        accumulation +=\n            ((ipv4.getSourceAddress() >> 16) & 0xffff) + (ipv4.getSourceAddress() & 0xffff);\n        accumulation +=\n            ((ipv4.getDestinationAddress() >> 16) & 0xffff)\n                + (ipv4.getDestinationAddress() & 0xffff);\n        accumulation += ipv4.getProtocol() & 0xff;\n        accumulation += length & 0xffff;\n      }\n\n      for (int i = 0; i < length / 2; ++i) {\n        accumulation += 0xffff & bb.getShort();\n      }\n      // pad to an even number of shorts\n      if (length % 2 > 0) {\n        accumulation += (bb.get() & 0xff) << 8;\n      }\n\n      accumulation = ((accumulation >> 16) & 0xffff) + (accumulation & 0xffff);\n      this.checksum = (short) (~accumulation & 0xffff);\n      bb.putShort(16, this.checksum);\n    }\n    return data;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 818, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.clear()", "byteBuffer.put(byte[])", "byteBuffer.clear()", "byteBuffer.position()", "byteBuffer.put(byte[])"], "configurationStart": [78, 99, 270, 349, 392], "configurationEnd": [89, 116, 281, 363, 409], "guardCondition": "index<byteBuffer.capacity() && !(byteBuffer.isReadOnly())", "guardType": "IF {", "guardExpressionStart": 34, "guardExpressionEnd": 55, "guardBlockStart": 34, "guardBlockEnd": 264, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 430, "focalAPIEnd": 440, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(value,*)", "assertSame(ByteBuffer,byteBuffer)", "byteBuffer.put(byte[])"], "useStart": [417, 459, 503], "useEnd": [451, 479, 520], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rwl/j2objc/tree/master/jre_emul/apache_harmony/classlib/modules/nio/src/test/java/common/org/apache/harmony/nio/tests/java/nio/ByteBufferTest.java", "rawCode": "  public void testPutbyte() {\n    if (buf.isReadOnly()) {\n      try {\n        buf.clear();\n        buf.put((byte) 0);\n        fail(\"Should throw Exception\"); // $NON-NLS-1$\n      } catch (ReadOnlyBufferException e) {\n        // expected\n      }\n      return;\n    }\n\n    buf.clear();\n    for (int i = 0; i < buf.capacity(); i++) {\n      assertEquals(buf.position(), i);\n      ByteBuffer ret = buf.put((byte) i);\n      assertEquals(buf.get(i), (byte) i);\n      assertSame(ret, buf);\n    }\n    try {\n      buf.put((byte) 0);\n      fail(\"Should throw Exception\"); // $NON-NLS-1$\n    } catch (BufferOverflowException e) {\n      // expected\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 819, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.position(int)"], "configurationStart": [456], "configurationEnd": [525], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 644, "focalAPIEnd": 656, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)", "byteBuffer.position(int)"], "useStart": [634, 998], "useEnd": [657, 1079], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Progga1/YangLib/tree/master/src_lib/yang/graphics/textures/TextureData.java", "rawCode": "  public void copyRect(\n      int left,\n      int top,\n      int width,\n      int height,\n      ByteBuffer source,\n      int sourceChannels,\n      int sourceLeft,\n      int sourceTop,\n      int sourceBufferWidth,\n      int downScale) {\n\n    if (downScale == 1 && sourceChannels == mChannels) {\n      // Fast version for matching formats\n      for (int i = 0; i < height; i++) {\n        mData.position(((top + i) * mWidth + left) * sourceChannels);\n        source.position((sourceTop + i) * sourceBufferWidth * sourceChannels);\n        for (int j = 0; j < width; j++) {\n          for (int c = 0; c < sourceChannels; c++) {\n            mData.put(source.get());\n          }\n        }\n      }\n    } else {\n      // Copy converted\n      tempArray4b[0] = 0;\n      tempArray4b[1] = 0;\n      tempArray4b[2] = 0;\n      tempArray4b[3] = 0;\n      width /= downScale;\n      height /= downScale;\n\n      for (int i = 0; i < height; i++) {\n        mData.position(((top + i) * mWidth + left) * mChannels);\n        source.position((sourceTop + i * downScale) * sourceBufferWidth * sourceChannels);\n        for (int j = 0; j < width; j++) {\n          for (int d = 0; d < downScale; d++)\n            for (int c = 0; c < sourceChannels; c++) {\n              tempArray4b[c] = source.get();\n            }\n          for (int c = 0; c < mChannels; c++) {\n            mData.put(tempArray4b[c]);\n          }\n        }\n      }\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 820, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 203, "focalAPIEnd": 221, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(int,byte)"], "useStart": [259], "useEnd": [286], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zerovm/impala-port/tree/master/thirdparty/hbase-0.94.6-cdh4.3.0/src/main/java/org/apache/hadoop/hbase/util/ByteBloomFilter.java", "rawCode": "  /**\n   * Set the bit at the specified index to 1.\n   *\n   * @param pos index of bit\n   */\n  void set(long pos) {\n    int bytePos = (int) (pos / 8);\n    int bitPos = (int) (pos % 8);\n    byte curByte = bloom.get(bytePos);\n    curByte |= bitvals[bitPos];\n    bloom.put(bytePos, curByte);\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 821, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.14/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 822, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.clear()", "byteBuffer.rewind()"], "configurationStart": [201, 482], "configurationEnd": [219, 501], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 516, "focalAPIEnd": 532, "followUpCheck": "value == 123", "checkType": "IF", "followUpCheckExpressionStart": 550, "followUpCheckExpressionEnd": 563, "followUpCheckBlockStart": 550, "followUpCheckBlockEnd": 747, "use": ["Stack<Byte>.push(value)", "ByteBuffer.put(value)", "ByteBuffer.put(value)", "ByteBuffer.put(value)"], "useStart": [572, 597, 681, 721], "useEnd": [589, 616, 700, 740], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/allankin/gproject/tree/master/TXL/source/server/txl-socket/test/TestNIOSocket.java", "rawCode": "  /**\n   * 处理读取服务端发来的信息 的事件\n   *\n   * @param key\n   * @throws IOException\n   */\n  public int read(SelectionKey key) throws IOException {\n    SocketChannel channel = (SocketChannel) key.channel();\n\n    readBuffer.clear();\n    int count = channel.read(readBuffer);\n\n    if (count == -1) {\n      try {\n        channel.close();\n        System.out.println(\"read error：count = -1， close\");\n      } catch (IOException e1) {\n        e1.printStackTrace();\n      }\n      return -1;\n    }\n    readBuffer.rewind();\n    byte b = readBuffer.get();\n\n    // {开始\n    if (b == 123) {\n      jsonStack.push(b);\n      singleBuffer.put(b);\n    } else if (b == 125) { // }结束\n      jsonStack.pop();\n      singleBuffer.put(b);\n    } else {\n      singleBuffer.put(b);\n    }\n\n    if (jsonStack.isEmpty()) {\n      singleBuffer.rewind();\n      String msg = new String(singleBuffer.array(), \"utf-8\");\n      singleBuffer.clear();\n      System.out.println(\"read msg:\" + msg);\n    }\n    return 1;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 823, "initialization": ["ByteBuffer byteBuffer = wrap(byte[])"], "initializationStart": [223], "initializationEnd": [251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.order(ByteOrder)", "byteBuffer.asShortBuffer()"], "configurationStart": [257, 402], "configurationEnd": [291, 421], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 477, "focalAPIEnd": 492, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [541], "useEnd": [560], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FoxyCorndog/WorkspaceOld/tree/master/LWJGL/src/org/lwjgl/util/WaveData.java", "rawCode": "  private static ByteBuffer convertAudioBytes(byte[] audio_bytes, boolean two_bytes_data) {\n    ByteBuffer dest = ByteBuffer.allocateDirect(audio_bytes.length);\n    dest.order(ByteOrder.nativeOrder());\n    ByteBuffer src = ByteBuffer.wrap(audio_bytes);\n    src.order(ByteOrder.LITTLE_ENDIAN);\n    if (two_bytes_data) {\n      ShortBuffer dest_short = dest.asShortBuffer();\n      ShortBuffer src_short = src.asShortBuffer();\n      while (src_short.hasRemaining()) dest_short.put(src_short.get());\n    } else {\n      while (src.hasRemaining()) dest.put(src.get());\n    }\n    dest.rewind();\n    return dest;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 824, "initialization": ["ByteBuffer byteBuffer = createDynamicCompositeKey(String,*,int,boolean)", "ByteBuffer byteBuffer = createDynamicCompositeKey(String,*,int,boolean)", "ByteBuffer byteBuffer = createDynamicCompositeKey(String,*,int,boolean)"], "initializationStart": [60, 158, 252], "initializationEnd": [115, 209, 306], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 343, "focalAPIEnd": 352, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["DynamicCompositeType.validate(byteBuffer)", "byteBuffer.putShort(char)", "byteBuffer.putShort(short)", "byteBuffer.put(byte[])", "byteBuffer.put(byte[])", "byteBuffer.putShort(char)", "byteBuffer.putShort(short)", "byteBuffer.rewind()", "DynamicCompositeType.validate(byteBuffer)", "DynamicCompositeType.validate(byteBuffer)"], "useStart": [409, 578, 620, 664, 708, 731, 773, 803, 833, 1100], "useEnd": [433, 614, 658, 702, 725, 767, 797, 815, 857, 1124], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/godares79/CS848-Project/tree/master/apache-cassandra-1.1.6-src/test/unit/org/apache/cassandra/db/marshal/DynamicCompositeTypeTest.java", "rawCode": "  @Test\n  public void testValidate() {\n    ByteBuffer key = createDynamicCompositeKey(\"test1\", uuids[1], 42, false);\n    comparator.validate(key);\n\n    key = createDynamicCompositeKey(\"test1\", null, -1, false);\n    comparator.validate(key);\n\n    key = createDynamicCompositeKey(\"test1\", uuids[2], -1, true);\n    comparator.validate(key);\n\n    key.get(); // make sure we're not aligned anymore\n    try {\n      comparator.validate(key);\n      fail(\"Should not validate\");\n    } catch (MarshalException e) {\n    }\n\n    key = ByteBuffer.allocate(5 + \"test1\".length() + 5 + 14);\n    key.putShort((short) (0x8000 | 'b'));\n    key.putShort((short) \"test1\".length());\n    key.put(ByteBufferUtil.bytes(\"test1\"));\n    key.put((byte) 0);\n    key.putShort((short) (0x8000 | 't'));\n    key.putShort((short) 14);\n    key.rewind();\n    try {\n      comparator.validate(key);\n      fail(\"Should not validate\");\n    } catch (MarshalException e) {\n      assert e.toString().contains(\"TimeUUID should be 16 or 0 bytes\");\n    }\n\n    key = createDynamicCompositeKey(\"test1\", UUID.randomUUID(), 42, false);\n    try {\n      comparator.validate(key);\n      fail(\"Should not validate\");\n    } catch (MarshalException e) {\n      assert e.toString().contains(\"Invalid version for TimeUUID type\");\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 825, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 2072, "focalAPIEnd": 2083, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/linkedin/databus/tree/master/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestDbusEvent.java", "rawCode": "  @Test\n  public void testGetStringFromBuffer() throws Exception {\n    final String verificationStr1 =\n        \"{\\\"message\\\":null,\\\"error\\\":\\\"java.lang.NullPointerException\\\"}\";\n    final String verificationStr2 =\n        \"{\\\"message\\\":\\\"Error in _bufferOffset\\\",\\\"error\\\":\\\"java.lang.RuntimeException\\\"}\\n\";\n\n    // {\"message\":null,\"error\":\"java.lang.NullPointerException\"} plus 16 junk bytes at start (-1)\n    // and 7 at end (-128)\n    final byte[] jsonEncodedException1 = {\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 16 junk bytes\n      0x7b, 0x22, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c,\n          0x2c,\n      0x22, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x3a, 0x22, 0x6a, 0x61, 0x76, 0x61, 0x2e, 0x6c,\n          0x61,\n      0x6e, 0x67, 0x2e, 0x4e, 0x75, 0x6c, 0x6c, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x45,\n          0x78,\n      0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x7d, -128, -128, -128, -128, -128, -128,\n          -128 // 7 junk bytes\n    };\n    // {\"message\":\"Error in _bufferOffset\",\"error\":\"java.lang.RuntimeException\"} (73 + newline + 16\n    // (-2) + 6 (-127))\n    final byte[] jsonEncodedException2 = {\n      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, // 16 junk bytes\n      0x7b, 0x22, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x3a, 0x22, 0x45, 0x72, 0x72,\n          0x6f,\n      0x72, 0x20, 0x69, 0x6e, 0x20, 0x5f, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x4f, 0x66, 0x66,\n          0x73,\n      0x65, 0x74, 0x22, 0x2c, 0x22, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x3a, 0x22, 0x6a, 0x61,\n          0x76,\n      0x61, 0x2e, 0x6c, 0x61, 0x6e, 0x67, 0x2e, 0x52, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x45,\n          0x78,\n      0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x7d, 0x0a, -127, -127, -127, -127, -127,\n          -127 // 6 junk bytes\n    };\n\n    ByteBuffer bb1 = ByteBuffer.wrap(jsonEncodedException1, 16, 57);\n    assertEquals(\n        \"failed to find \\\"version 123\\\" at expected ByteBuffer offset (wrap())\",\n        123 /* 0x7b */,\n        bb1.get(16));\n\n    ByteBuffer bb2 = ByteBuffer.allocate(128);\n    bb2.position(3); // anywhere but offset zero\n    bb2.put(jsonEncodedException2, 16, 74);\n    ByteBuffer bb2ro = bb2.asReadOnlyBuffer();\n    assertEquals(\n        \"failed to find \\\"version 123\\\" at expected ByteBuffer offset (put())\",\n        123 /* 0x7b */,\n        bb2ro.get(3));\n\n    // sanity checks to make sure we test both code paths\n    assertTrue(\"wrapped byte-array ByteBuffer should have a backing array\", bb1.hasArray());\n    assertFalse(\"read-only ByteBuffer shouldn't have a backing array\", bb2ro.hasArray());\n\n    String jsonEncodedExceptionString1 = DbusEventFactory.getStringFromBuffer(bb1, 16);\n    String jsonEncodedExceptionString2 = DbusEventFactory.getStringFromBuffer(bb2ro, 3);\n\n    assertEquals(\n        \"JSON string from wrapped byte-array ByteBuffer doesn't match expected\",\n        verificationStr1,\n        jsonEncodedExceptionString1);\n    assertEquals(\n        \"JSON string from bulk-put, read-only ByteBuffer doesn't match expected\",\n        verificationStr2,\n        jsonEncodedExceptionString2);\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 826, "initialization": ["ByteBuffer byteBuffer = wrap(*)"], "initializationStart": [87], "initializationEnd": [110], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 122, "guardExpressionEnd": 174, "guardBlockStart": 122, "guardBlockEnd": 212, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 190, "focalAPIEnd": 204, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)", "byteBuffer.hasRemaining()"], "useStart": [183, 225], "useEnd": [205, 248], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ybrs/hazelcastforked/tree/master/hazelcast/src/main/java/com/hazelcast/impl/ascii/memcache/SetCommand.java", "rawCode": "  public boolean writeTo(ByteBuffer bb) {\n    if (response == null) {\n      response = ByteBuffer.wrap(STORED);\n    }\n    while (bb.hasRemaining() && response.hasRemaining()) {\n      bb.put(response.get());\n    }\n    return !response.hasRemaining();\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 827, "initialization": ["ByteBuffer byteBuffer = wrap(byte[])"], "initializationStart": [421], "initializationEnd": [449], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.order(ByteOrder)", "byteBuffer.asShortBuffer()"], "configurationStart": [455, 600], "configurationEnd": [489, 619], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 675, "focalAPIEnd": 690, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [739], "useEnd": [758], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dlangdon/ToTameTheVoid-java/tree/master/lib/slick/src/org/newdawn/slick/openal/WaveData.java", "rawCode": "  /**\n   * Convert the audio bytes into the stream\n   *\n   * @param audio_bytes The audio byts\n   * @param two_bytes_data True if we using double byte data\n   * @return The byte bufer of data\n   */\n  private static ByteBuffer convertAudioBytes(byte[] audio_bytes, boolean two_bytes_data) {\n    ByteBuffer dest = ByteBuffer.allocateDirect(audio_bytes.length);\n    dest.order(ByteOrder.nativeOrder());\n    ByteBuffer src = ByteBuffer.wrap(audio_bytes);\n    src.order(ByteOrder.LITTLE_ENDIAN);\n    if (two_bytes_data) {\n      ShortBuffer dest_short = dest.asShortBuffer();\n      ShortBuffer src_short = src.asShortBuffer();\n      while (src_short.hasRemaining()) dest_short.put(src_short.get());\n    } else {\n      while (src.hasRemaining()) dest.put(src.get());\n    }\n    dest.rewind();\n    return dest;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 828, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 54, "guardExpressionEnd": 85, "guardBlockStart": 54, "guardBlockEnd": 1825, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 104, "focalAPIEnd": 118, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["readVarInt(byteBuffer)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.array()", "readVarInt(byteBuffer)", "readVarLong(byteBuffer)", "readVarLong(byteBuffer)", "readVarLong(byteBuffer)", "ByteBuffer.put(byteBuffer)", "byteBuffer.array()"], "useStart": [178, 306, 288, 405, 490, 562, 657, 714, 1102, 1160, 1516, 1788], "useEnd": [208, 325, 332, 424, 514, 578, 687, 745, 1133, 1191, 1539, 1804], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/H2-Mirror/tree/master/h2/src/main/org/h2/mvstore/StreamStore.java", "rawCode": "    private ByteArrayInputStream nextBuffer() {\n      while (idBuffer.hasRemaining()) {\n        switch (idBuffer.get()) {\n          case 0:\n            {\n              int len = DataUtils.readVarInt(idBuffer);\n              if (skip >= len) {\n                skip -= len;\n                idBuffer.position(idBuffer.position() + len);\n                continue;\n              }\n              int p = (int) (idBuffer.position() + skip);\n              int l = (int) (len - skip);\n              idBuffer.position(p + l);\n              return new ByteArrayInputStream(idBuffer.array(), p, l);\n            }\n          case 1:\n            {\n              int len = DataUtils.readVarInt(idBuffer);\n              long key = DataUtils.readVarLong(idBuffer);\n              if (skip >= len) {\n                skip -= len;\n                continue;\n              }\n              byte[] data = store.getBlock(key);\n              int s = (int) skip;\n              skip = 0;\n              return new ByteArrayInputStream(data, s, data.length - s);\n            }\n          case 2:\n            {\n              long len = DataUtils.readVarLong(idBuffer);\n              long key = DataUtils.readVarLong(idBuffer);\n              if (skip >= len) {\n                skip -= len;\n                continue;\n              }\n              byte[] k = store.getBlock(key);\n              ByteBuffer newBuffer =\n                  ByteBuffer.allocate(k.length + idBuffer.limit() - idBuffer.position());\n              newBuffer.put(k);\n              newBuffer.put(idBuffer);\n              newBuffer.flip();\n              idBuffer = newBuffer;\n              return nextBuffer();\n            }\n          default:\n            throw DataUtils.newIllegalArgumentException(\n                \"Unsupported id {0}\", Arrays.toString(idBuffer.array()));\n        }\n      }\n      return null;\n    }\n"}, {"dataset": "byteBufferGet", "exampleID": 829, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.15/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 830, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 2969, "focalAPIEnd": 2977, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/floodlight/floodlight/tree/master/src/main/java/net/floodlightcontroller/packet/TCP.java", "rawCode": "  /**\n   * Serializes the packet. Will compute and set the following fields if they are set to specific\n   * values at the time serialize is called: -checksum : 0 -length : 0\n   */\n  public byte[] serialize() {\n    int length;\n    if (dataOffset == 0) dataOffset = 5; // default header length\n    length = dataOffset << 2;\n    byte[] payloadData = null;\n    if (payload != null) {\n      payload.setParent(this);\n\n      payloadData = payload.serialize();\n      length += payloadData.length;\n    }\n\n    byte[] data = new byte[length];\n    ByteBuffer bb = ByteBuffer.wrap(data);\n\n    bb.putShort((short) this.sourcePort.getPort()); // TCP ports are defined to be 16 bits\n    bb.putShort((short) this.destinationPort.getPort());\n    bb.putInt(this.sequence);\n    bb.putInt(this.acknowledge);\n    bb.putShort((short) (this.flags | (dataOffset << 12)));\n    bb.putShort(this.windowSize);\n    bb.putShort(this.checksum);\n    bb.putShort(this.urgentPointer);\n    if (dataOffset > 5) {\n      int padding;\n      bb.put(options);\n      padding = (dataOffset << 2) - 20 - options.length;\n      for (int i = 0; i < padding; i++) bb.put((byte) 0);\n    }\n    if (payloadData != null) bb.put(payloadData);\n\n    if (this.parent != null && this.parent instanceof IPv4)\n      ((IPv4) this.parent).setProtocol(IpProtocol.TCP);\n\n    // compute checksum if needed\n    if (this.checksum == 0) {\n\n      if (this.parent != null && this.parent instanceof IPv4) {\n        // Checksum calculation based on the JSocket Wrench code\n        // https://github.com/ehrmann/jswrench\n        // The original code can be found at\n        // https://github.com/ehrmann/jswrench/blob/master/src/com/act365/net/SocketUtils.java\n        IPv4 ipv4 = (IPv4) this.parent;\n\n        int bufferlength = length + 12;\n        boolean odd = length % 2 == 1;\n        byte[] source = ipv4.getSourceAddress().getBytes();\n        byte[] destination = ipv4.getDestinationAddress().getBytes();\n\n        if (odd) {\n          ++bufferlength;\n        }\n\n        byte[] buffer = new byte[bufferlength];\n\n        buffer[0] = source[0];\n        buffer[1] = source[1];\n        buffer[2] = source[2];\n        buffer[3] = source[3];\n\n        buffer[4] = destination[0];\n        buffer[5] = destination[1];\n        buffer[6] = destination[2];\n        buffer[7] = destination[3];\n\n        buffer[8] = (byte) 0;\n        buffer[9] = (byte) ipv4.getProtocol().getIpProtocolNumber();\n\n        shortToBytes((short) length, buffer, 10);\n\n        int i = 11;\n\n        while (++i < length + 12) {\n          buffer[i] = data[i + 0 - 12];\n        }\n\n        if (odd) {\n          buffer[i] = (byte) 0;\n        }\n\n        this.checksum = checksum(buffer, buffer.length, 0);\n      } else {\n        bb.rewind();\n        int accumulation = 0;\n        for (int i = 0; i < length / 2; ++i) {\n          accumulation += 0xffff & bb.getShort();\n        }\n        // pad to an even number of shorts\n        if (length % 2 > 0) {\n          accumulation += (bb.get() & 0xff) << 8;\n        }\n\n        accumulation = ((accumulation >> 16) & 0xffff) + (accumulation & 0xffff);\n        this.checksum = (short) (~accumulation & 0xffff);\n      }\n\n      bb.putShort(16, this.checksum);\n    }\n\n    return data;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 831, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "byteBuffer.remaining()>0", "guardType": "LOOP {", "guardExpressionStart": 387, "guardExpressionEnd": 417, "guardBlockStart": 387, "guardBlockEnd": 2256, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 641, "focalAPIEnd": 653, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.get()", "byteBuffer.getShort()", "byteBuffer.remaining()", "byteBuffer.remaining()", "byteBuffer.position()", "byteBuffer.limit(int)", "ByteBuffer.put(byteBuffer)", "byteBuffer.position()", "byteBuffer.limit(int)", "ByteBuffer.put(byteBuffer)"], "useStart": [1093, 1323, 1526, 1789, 1852, 1839, 1932, 2049, 2036, 2222], "useEnd": [1105, 1340, 1544, 1807, 1869, 1892, 1951, 2066, 2075, 2241], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kuykendall-benjamin/School-Project-KNKG/tree/master/JMonkeyEngine/source/com/jme3/network/base/MessageProtocol.java", "rawCode": "  /**\n   * Adds the specified buffer, extracting the contained messages and making them available to\n   * getMessage(). The left over data is buffered to be combined with future data. &\n   *\n   * @return The total number of queued messages after this call.\n   */\n  public int addBuffer(ByteBuffer buffer) {\n    // push the data from the buffer into as\n    // many messages as we can\n    while (buffer.remaining() > 0) {\n\n      if (current == null) {\n\n        // If we have a left over carry then we need to\n        // do manual processing to get the short value\n        if (carry != null) {\n          byte high = carry;\n          byte low = buffer.get();\n\n          size = (high & 0xff) << 8 | (low & 0xff);\n          carry = null;\n        } else if (buffer.remaining() < 2) {\n          // It's possible that the supplied buffer only has one\n          // byte in it... and in that case we will get an underflow\n          // when attempting to read the short below.\n\n          // It has to be 1 or we'd never get here... but one\n          // isn't enough so we stash it away.\n          carry = buffer.get();\n          break;\n        } else {\n          // We are not currently reading an object so\n          // grab the size.\n          // Note: this is somewhat limiting... int would\n          // be better.\n          size = buffer.getShort();\n        }\n\n        // Allocate the buffer into which we'll feed the\n        // data as we get it\n        current = ByteBuffer.allocate(size);\n      }\n\n      if (current.remaining() <= buffer.remaining()) {\n        // We have at least one complete object so\n        // copy what we can into current, create a message,\n        // and then continue pulling from buffer.\n\n        // Artificially set the limit so we don't overflow\n        int extra = buffer.remaining() - current.remaining();\n        buffer.limit(buffer.position() + current.remaining());\n\n        // Now copy the data\n        current.put(buffer);\n        current.flip();\n\n        // Now set the limit back to a good value\n        buffer.limit(buffer.position() + extra);\n\n        createMessage(current);\n\n        current = null;\n      } else {\n\n        // Not yet a complete object so just copy what we have\n        current.put(buffer);\n      }\n    }\n\n    return messages.size();\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 832, "initialization": ["ByteBuffer byteBuffer = wrap(byte[])"], "initializationStart": [498], "initializationEnd": [526], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.order(ByteOrder)", "byteBuffer.asShortBuffer()"], "configurationStart": [532, 674], "configurationEnd": [563, 693], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 749, "focalAPIEnd": 764, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [952], "useEnd": [963], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fisherevans/LRK/tree/master/src/org/newdawn/slick/openal/AiffData.java", "rawCode": "  /**\n   * Convert the audio bytes into the stream\n   *\n   * @param format The audio format being decoded\n   * @param audio_bytes The audio byts\n   * @param two_bytes_data True if we using double byte data\n   * @return The byte bufer of data\n   */\n  private static ByteBuffer convertAudioBytes(\n      AudioFormat format, byte[] audio_bytes, boolean two_bytes_data) {\n    ByteBuffer dest = ByteBuffer.allocateDirect(audio_bytes.length);\n    dest.order(ByteOrder.nativeOrder());\n    ByteBuffer src = ByteBuffer.wrap(audio_bytes);\n    src.order(ByteOrder.BIG_ENDIAN);\n    if (two_bytes_data) {\n      ShortBuffer dest_short = dest.asShortBuffer();\n      ShortBuffer src_short = src.asShortBuffer();\n      while (src_short.hasRemaining()) dest_short.put(src_short.get());\n    } else {\n      while (src.hasRemaining()) {\n        byte b = src.get();\n        if (format.getEncoding() == Encoding.PCM_SIGNED) {\n          b = (byte) (b + 127);\n        }\n        dest.put(b);\n      }\n    }\n    dest.rewind();\n    return dest;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 833, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta01/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 834, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.6/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 835, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0-rc11/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 836, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 723, "focalAPIEnd": 742, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)", "byteBuffer.getInt()"], "useStart": [715, 806], "useEnd": [743, 828], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/disy/jSCSI/tree/master/bundles/commons/src/main/java/org/jscsi/parser/AdditionalHeaderSegment.java", "rawCode": "  /**\n   * This method serializes the informations of this AHS object to the byte representation defined\n   * by the iSCSI Standard.\n   *\n   * @param dst The destination array to write in.\n   * @param offset The start offset in <code>dst</code>.\n   * @return The length of used integers of the serialized form of this AHS object.\n   * @throws InternetSCSIException If any violation of the iSCSI-Standard emerge.\n   */\n  final int serialize(final ByteBuffer dst, final int offset) throws InternetSCSIException {\n\n    dst.position(offset);\n    if (dst.remaining() < length) {\n      throw new IllegalArgumentException(\"Destination array is too small.\");\n    }\n\n    dst.putShort(length);\n    dst.put(type.value());\n    dst.put(specificField.get());\n\n    while (specificField.hasRemaining()) {\n      dst.putInt(specificField.getInt());\n    }\n\n    return length + FIX_SIZE_OVERHEAD;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 837, "initialization": ["ByteBuffer byteBuffer = createByteBuffer(*)"], "initializationStart": [4700], "initializationEnd": [4744], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte[])"], "configurationStart": [4750], "configurationEnd": [4770], "guardCondition": "index<texWidth*perPixel", "guardType": "LOOP {", "guardExpressionStart": 4974, "guardExpressionEnd": 5019, "guardBlockStart": 4974, "guardBlockEnd": 5197, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 5057, "focalAPIEnd": 5071, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.flip()"], "useStart": [5030, 5149, 5082, 5426, 5335, 5576, 5481, 5679], "useEnd": [5072, 5187, 5188, 5468, 5469, 5647, 5648, 5693], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ProjetX/ProjetX/tree/master/slick/src/org/newdawn/slick/opengl/TGAImageData.java", "rawCode": "  /**\n   * @see org.newdawn.slick.opengl.LoadableImageData#loadImage(java.io.InputStream, boolean,\n   *     boolean, int[])\n   */\n  public ByteBuffer loadImage(\n      InputStream fis, boolean flipped, boolean forceAlpha, int[] transparent) throws IOException {\n    if (transparent != null) {\n      forceAlpha = true;\n    }\n    byte red = 0;\n    byte green = 0;\n    byte blue = 0;\n    byte alpha = 0;\n\n    BufferedInputStream bis = new BufferedInputStream(fis, 100000);\n    DataInputStream dis = new DataInputStream(bis);\n\n    // Read in the Header\n    short idLength = (short) dis.read();\n    short colorMapType = (short) dis.read();\n    short imageType = (short) dis.read();\n    short cMapStart = flipEndian(dis.readShort());\n    short cMapLength = flipEndian(dis.readShort());\n    short cMapDepth = (short) dis.read();\n    short xOffset = flipEndian(dis.readShort());\n    short yOffset = flipEndian(dis.readShort());\n\n    width = flipEndian(dis.readShort());\n    height = flipEndian(dis.readShort());\n    pixelDepth = (short) dis.read();\n    if (pixelDepth == 32) {\n      forceAlpha = false;\n    }\n\n    texWidth = get2Fold(width);\n    texHeight = get2Fold(height);\n\n    short imageDescriptor = (short) dis.read();\n    if ((imageDescriptor & 0x0020) == 0) {\n      flipped = !flipped;\n    }\n\n    // Skip image ID\n    if (idLength > 0) {\n      bis.skip(idLength);\n    }\n\n    byte[] rawData = null;\n    if ((pixelDepth == 32) || (forceAlpha)) {\n      pixelDepth = 32;\n      rawData = new byte[texWidth * texHeight * 4];\n    } else if (pixelDepth == 24) {\n      rawData = new byte[texWidth * texHeight * 3];\n    } else {\n      throw new RuntimeException(\"Only 24 and 32 bit TGAs are supported\");\n    }\n\n    if (pixelDepth == 24) {\n      if (flipped) {\n        for (int i = height - 1; i >= 0; i--) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n\n            int ofs = ((j + (i * texWidth)) * 3);\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n          }\n        }\n      } else {\n        for (int i = 0; i < height; i++) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n\n            int ofs = ((j + (i * texWidth)) * 3);\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n          }\n        }\n      }\n    } else if (pixelDepth == 32) {\n      if (flipped) {\n        for (int i = height - 1; i >= 0; i--) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n            if (forceAlpha) {\n              alpha = (byte) 255;\n            } else {\n              alpha = dis.readByte();\n            }\n\n            int ofs = ((j + (i * texWidth)) * 4);\n\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n            rawData[ofs + 3] = alpha;\n\n            if (alpha == 0) {\n              rawData[ofs + 2] = (byte) 0;\n              rawData[ofs + 1] = (byte) 0;\n              rawData[ofs] = (byte) 0;\n            }\n          }\n        }\n      } else {\n        for (int i = 0; i < height; i++) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n            if (forceAlpha) {\n              alpha = (byte) 255;\n            } else {\n              alpha = dis.readByte();\n            }\n\n            int ofs = ((j + (i * texWidth)) * 4);\n\n            if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) {\n              rawData[ofs] = red;\n              rawData[ofs + 1] = green;\n              rawData[ofs + 2] = blue;\n              rawData[ofs + 3] = alpha;\n            } else {\n              rawData[ofs] = red;\n              rawData[ofs + 1] = green;\n              rawData[ofs + 2] = blue;\n              rawData[ofs + 3] = alpha;\n            }\n\n            if (alpha == 0) {\n              rawData[ofs + 2] = 0;\n              rawData[ofs + 1] = 0;\n              rawData[ofs] = 0;\n            }\n          }\n        }\n      }\n    }\n    fis.close();\n\n    if (transparent != null) {\n      for (int i = 0; i < rawData.length; i += 4) {\n        boolean match = true;\n        for (int c = 0; c < 3; c++) {\n          if (rawData[i + c] != transparent[c]) {\n            match = false;\n          }\n        }\n\n        if (match) {\n          rawData[i + 3] = 0;\n        }\n      }\n    }\n\n    // Get a pointer to the image memory\n    ByteBuffer scratch = BufferUtils.createByteBuffer(rawData.length);\n    scratch.put(rawData);\n\n    int perPixel = pixelDepth / 8;\n    if (height < texHeight - 1) {\n      int topOffset = (texHeight - 1) * (texWidth * perPixel);\n      int bottomOffset = (height - 1) * (texWidth * perPixel);\n      for (int x = 0; x < texWidth * perPixel; x++) {\n        scratch.put(topOffset + x, scratch.get(x));\n        scratch.put(\n            bottomOffset + (texWidth * perPixel) + x, scratch.get((texWidth * perPixel) + x));\n      }\n    }\n    if (width < texWidth - 1) {\n      for (int y = 0; y < texHeight; y++) {\n        for (int i = 0; i < perPixel; i++) {\n          scratch.put(\n              ((y + 1) * (texWidth * perPixel)) - perPixel + i,\n              scratch.get(y * (texWidth * perPixel) + i));\n          scratch.put(\n              (y * (texWidth * perPixel)) + (width * perPixel) + i,\n              scratch.get((y * (texWidth * perPixel)) + ((width - 1) * perPixel) + i));\n        }\n      }\n    }\n\n    scratch.flip();\n\n    return scratch;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 838, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.flip()"], "configurationStart": [265], "configurationEnd": [282], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 321, "focalAPIEnd": 337, "followUpCheck": "value == 0x1f", "checkType": "IF", "followUpCheckExpressionStart": 345, "followUpCheckExpressionEnd": 359, "followUpCheckBlockStart": 345, "followUpCheckBlockEnd": 606, "use": ["byteBuffer.getShort()", "byteBuffer.getShort()", "byteBuffer.clear()", "byteBuffer.put(byte)"], "useStart": [384, 430, 614, 685], "useEnd": [405, 451, 632, 702], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/araqne/core/tree/master/araqne-core/src/main/java/org/araqne/test/TelnetStateMachine.java", "rawCode": "  private void handleSubNegotiation(byte b) {\n    if (negoState == State.Option && isInterpreatAsControl(b)) {\n      negoState = State.Command;\n      return;\n    }\n\n    // subnegotiation end (SE)\n    if (negoState == State.Command && b == TelnetCommand.SE) {\n      negoBuffer.flip();\n\n      // window size\n      byte c = negoBuffer.get();\n      if (c == 0x1f) {\n        short width = negoBuffer.getShort();\n        short height = negoBuffer.getShort();\n\n        context.setWindowSize(width, height);\n        logger.trace(\"araqne-core: changed negotiate about window size: [{}, {}]\", width, height);\n      }\n\n      negoBuffer.clear();\n      state = State.Data;\n      return;\n    }\n\n    negoBuffer.put(b);\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 839, "initialization": ["ByteBuffer byteBuffer = wrap(byte[])"], "initializationStart": [498], "initializationEnd": [526], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.order(ByteOrder)", "byteBuffer.asShortBuffer()"], "configurationStart": [532, 674], "configurationEnd": [563, 693], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 749, "focalAPIEnd": 764, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [952], "useEnd": [963], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/perclasson/stresstetris/tree/master/slick/src/org/newdawn/slick/openal/AiffData.java", "rawCode": "  /**\n   * Convert the audio bytes into the stream\n   *\n   * @param format The audio format being decoded\n   * @param audio_bytes The audio byts\n   * @param two_bytes_data True if we using double byte data\n   * @return The byte bufer of data\n   */\n  private static ByteBuffer convertAudioBytes(\n      AudioFormat format, byte[] audio_bytes, boolean two_bytes_data) {\n    ByteBuffer dest = ByteBuffer.allocateDirect(audio_bytes.length);\n    dest.order(ByteOrder.nativeOrder());\n    ByteBuffer src = ByteBuffer.wrap(audio_bytes);\n    src.order(ByteOrder.BIG_ENDIAN);\n    if (two_bytes_data) {\n      ShortBuffer dest_short = dest.asShortBuffer();\n      ShortBuffer src_short = src.asShortBuffer();\n      while (src_short.hasRemaining()) dest_short.put(src_short.get());\n    } else {\n      while (src.hasRemaining()) {\n        byte b = src.get();\n        if (format.getEncoding() == Encoding.PCM_SIGNED) {\n          b = (byte) (b + 127);\n        }\n        dest.put(b);\n      }\n    }\n    dest.rewind();\n    return dest;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 840, "initialization": ["ByteBuffer byteBuffer = wrap(byte[])"], "initializationStart": [223], "initializationEnd": [251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.order(ByteOrder)", "byteBuffer.asShortBuffer()"], "configurationStart": [257, 402], "configurationEnd": [291, 421], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 477, "focalAPIEnd": 492, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [541], "useEnd": [560], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FoxyCorndog/WorkspaceOld/tree/master/gafggfds/LWJGL/lwjgl-2.8.5/src/java/org/lwjgl/util/WaveData.java", "rawCode": "  private static ByteBuffer convertAudioBytes(byte[] audio_bytes, boolean two_bytes_data) {\n    ByteBuffer dest = ByteBuffer.allocateDirect(audio_bytes.length);\n    dest.order(ByteOrder.nativeOrder());\n    ByteBuffer src = ByteBuffer.wrap(audio_bytes);\n    src.order(ByteOrder.LITTLE_ENDIAN);\n    if (two_bytes_data) {\n      ShortBuffer dest_short = dest.asShortBuffer();\n      ShortBuffer src_short = src.asShortBuffer();\n      while (src_short.hasRemaining()) dest_short.put(src_short.get());\n    } else {\n      while (src.hasRemaining()) dest.put(src.get());\n    }\n    dest.rewind();\n    return dest;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 841, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/KNL-1011/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 842, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 1644, "focalAPIEnd": 1652, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srcvirus/floodlight/tree/master/src/main/java/net/floodlightcontroller/packet/UDP.java", "rawCode": "  /**\n   * Serializes the packet. Will compute and set the following fields if they are set to specific\n   * values at the time serialize is called: -checksum : 0 -length : 0\n   */\n  public byte[] serialize() {\n    byte[] payloadData = null;\n    if (payload != null) {\n      payload.setParent(this);\n      payloadData = payload.serialize();\n    }\n\n    this.length = (short) (8 + ((payloadData == null) ? 0 : payloadData.length));\n\n    byte[] data = new byte[this.length];\n    ByteBuffer bb = ByteBuffer.wrap(data);\n\n    bb.putShort(this.sourcePort);\n    bb.putShort(this.destinationPort);\n    bb.putShort(this.length);\n    bb.putShort(this.checksum);\n    if (payloadData != null) bb.put(payloadData);\n\n    if (this.parent != null && this.parent instanceof IPv4)\n      ((IPv4) this.parent).setProtocol(IPv4.PROTOCOL_UDP);\n\n    // compute checksum if needed\n    if (this.checksum == 0) {\n      bb.rewind();\n      int accumulation = 0;\n\n      // compute pseudo header mac\n      if (this.parent != null && this.parent instanceof IPv4) {\n        IPv4 ipv4 = (IPv4) this.parent;\n        accumulation +=\n            ((ipv4.getSourceAddress() >> 16) & 0xffff) + (ipv4.getSourceAddress() & 0xffff);\n        accumulation +=\n            ((ipv4.getDestinationAddress() >> 16) & 0xffff)\n                + (ipv4.getDestinationAddress() & 0xffff);\n        accumulation += ipv4.getProtocol() & 0xff;\n        accumulation += this.length & 0xffff;\n      }\n\n      for (int i = 0; i < this.length / 2; ++i) {\n        accumulation += 0xffff & bb.getShort();\n      }\n      // pad to an even number of shorts\n      if (this.length % 2 > 0) {\n        accumulation += (bb.get() & 0xff) << 8;\n      }\n\n      accumulation = ((accumulation >> 16) & 0xffff) + (accumulation & 0xffff);\n      this.checksum = (short) (~accumulation & 0xffff);\n      bb.putShort(6, this.checksum);\n    }\n    return data;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 843, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.duplicate()", "byteBuffer.position(int)"], "configurationStart": [133, 191], "configurationEnd": [148, 210], "guardCondition": "index!=SizeOfBitmap", "guardType": "LOOP {", "guardExpressionStart": 299, "guardExpressionEnd": 341, "guardBlockStart": 299, "guardBlockEnd": 548, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 369, "focalAPIEnd": 379, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.position(int)"], "useStart": [573], "useEnd": [599], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kragen/waterken-server/tree/master/waterken/k2v/src/org/k2v/trie/Trie.java", "rawCode": "  static ByteBuffer listMap(final ByteBuffer map, final int arity) {\n    if (SizeOfBitmap >= arity) {\n      final ByteBuffer heads = map.duplicate();\n      heads.rewind().limit(arity);\n      map.position(arity);\n      return heads;\n    }\n    final ByteBuffer heads = ByteBuffer.allocate(arity);\n    for (int i = 0; i != SizeOfBitmap; i += 1) {\n      final byte flags = map.get(i);\n      for (int j = 0, mask = 0x80; 0 != mask; j += 1, mask >>= 1) {\n        if (0 != (flags & mask)) {\n          heads.put((byte) (i * 8 + j));\n        }\n      }\n    }\n    heads.rewind();\n    map.position(SizeOfBitmap);\n    return heads;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 844, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 100, "focalAPIEnd": 115, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/util/TestDataChecksum.java", "rawCode": "  private static void corruptBufferOffset(ByteBuffer buf, int offset) {\n    buf.put(offset, (byte) (buf.get(offset) + 1));\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 845, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/SAK-18559/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 846, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 158, "focalAPIEnd": 176, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.get(int)", "getOmaHeader(byte,value,byte)", "byteBuffer.remaining()", "byteBuffer.remaining()", "byteBuffer.remaining()", "byteBuffer.position()", "byteBuffer.position(int)", "getNextHeaderPosition(byteBuffer,int)", "byteBuffer.slice()", "byteBuffer.position(int)", "byteBuffer.limit()", "byteBuffer.position(int)"], "useStart": [201, 245, 418, 485, 769, 1009, 988, 1061, 1133, 1249, 1327, 1306], "useEnd": [219, 304, 441, 508, 792, 1031, 1036, 1106, 1152, 1281, 1346, 1347], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mirror/jpcsp/tree/master/src/jpcsp/media/OMAFormat.java", "rawCode": "  public static ByteBuffer convertStreamToOMA(ByteBuffer audioStream) {\n    if (!isHeader(audioStream, 0)) {\n      return null;\n    }\n\n    byte headerCode1 = audioStream.get(2);\n    byte headerCode2 = audioStream.get(3);\n    ByteBuffer header = getOmaHeader(OMA_CODECID_ATRAC3P, headerCode1, headerCode2);\n\n    int frameSize = ((headerCode1 & 0x03) << 8) | (headerCode2 & 0xFF) * 8 + 0x10;\n    int numCompleteFrames = audioStream.remaining() / (frameSize + 8);\n    int lastFrameSize = audioStream.remaining() - (numCompleteFrames * (frameSize + 8));\n\n    int omaStreamSize = header.remaining() + numCompleteFrames * frameSize + lastFrameSize;\n    // Allocate an OMA stream size large enough (better too large than too short)\n    omaStreamSize = Math.max(omaStreamSize, audioStream.remaining());\n    ByteBuffer oma = ByteBuffer.allocate(omaStreamSize).order(ByteOrder.LITTLE_ENDIAN);\n\n    oma.put(header);\n    while (audioStream.remaining() > 8) {\n      // Skip 8 bytes frame header\n      audioStream.position(audioStream.position() + 8);\n      int nextHeader = getNextHeaderPosition(audioStream, frameSize);\n      ByteBuffer frame = audioStream.slice();\n      if (nextHeader >= 0) {\n        frame.limit(nextHeader - audioStream.position());\n        audioStream.position(nextHeader);\n      } else {\n        audioStream.position(audioStream.limit());\n      }\n      oma.put(frame);\n    }\n    oma.limit(oma.position());\n    oma.rewind();\n\n    return oma;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 847, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 848, "initialization": ["ByteBuffer byteBuffer = allocateDirect(int)"], "initializationStart": [83], "initializationEnd": [112], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.isDirect()", "byteBuffer.hasArray()", "byteBuffer.arrayOffset()"], "configurationStart": [129, 215, 250], "configurationEnd": [141, 227, 265], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 415, "focalAPIEnd": 423, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(int,value)", "byteBuffer.get(int)", "assertEquals(int,value)", "byteBuffer.put(int,byte)"], "useStart": [399, 464, 448, 571], "useEnd": [424, 472, 473, 589], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codefireX/platform_libcore/tree/master/luni/src/test/java/libcore/java/nio/BufferTest.java", "rawCode": "  public void testDirectByteBufferHasArray() throws Exception {\n    ByteBuffer b = ByteBuffer.allocateDirect(10);\n    assertTrue(b.isDirect());\n    // Check the buffer has an array of the right size.\n    assertTrue(b.hasArray());\n    assertEquals(0, b.arrayOffset());\n    byte[] array = b.array();\n    assertEquals(10, array.length);\n    // Check that writes to the array show up in the buffer.\n    assertEquals(0, b.get(0));\n    array[0] = 1;\n    assertEquals(1, b.get(0));\n    // Check that writes to the buffer show up in the array.\n    assertEquals(1, array[0]);\n    b.put(0, (byte) 0);\n    assertEquals(0, array[0]);\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 849, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 1280, "focalAPIEnd": 1298, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.get(int)", "byteBuffer.get(int)", "byteBuffer.get(int)", "byteBuffer.get(String)", "byteBuffer.get(String)"], "useStart": [1301, 1437, 1467, 1846, 1901], "useEnd": [1319, 1455, 1485, 1869, 1924], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jonnywang/mylocal/tree/master/java/LogTcpServer/src/com/bi/core/ClientHandler.java", "rawCode": "  private Boolean formatBiRequestData(HashMap<String, String> requestData) {\n    Charset charset = Charset.forName(\"UTF-8\");\n    ByteBuffer biLogData = ByteBuffer.allocate(2048);\n    // timestamp\n    biLogData.putInt(LogUtil.getTimestamp());\n    // timestamp\n    if (null != requestData.get(\"time\")) {\n      biLogData.putInt(Integer.parseInt(requestData.get(\"time\").toString()));\n    } else {\n      biLogData.putInt(0);\n    }\n    // event\n    if (null != requestData.get(\"event\")) {\n      biLogData.putInt(Integer.parseInt(requestData.get(\"event\").toString()));\n    } else {\n      biLogData.putInt(-1);\n    }\n    // uid\n    String uid;\n    if (null != requestData.get(\"uid\")) {\n      if (requestData.get(\"uid\").toString().length() < 50) {\n        uid =\n            String.format(\n                \"%0\" + (50 - requestData.get(\"uid\").toString().length()) + \"d%s\",\n                0,\n                requestData.get(\"uid\"));\n      } else {\n        uid = requestData.get(\"uid\").substring(0, 50);\n      }\n    } else {\n      uid = String.format(\"%050d\", 0);\n    }\n    biLogData.put(uid.getBytes(charset));\n\n    // p1->p16\n    short datalen = 0;\n    String[] params = {\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\", \"p8\", \"p9\", \"p10\"};\n\n    for (String p : params) {\n      datalen += null != requestData.get(p) ? requestData.get(p).length() : 0;\n    }\n    biLogData.putShort(datalen);\n\n    for (String p : params) {\n      biLogData.putShort(null != requestData.get(p) ? (short) (requestData.get(p).length()) : 0);\n    }\n\n    for (String p : params) {\n      if (null != requestData.get(p)) {\n        biLogData.put(requestData.get(p).toString().getBytes(charset));\n      }\n    }\n\n    // write to bi\n    biLogData.flip();\n    byte[] logContent = new byte[biLogData.limit()];\n    biLogData.get(logContent);\n    biLogData.clear();\n\n    Logger.bi(\n        null != requestData.get(\"time\")\n            ? Integer.parseInt(requestData.get(\"time\"))\n            : LogUtil.getTimestamp(),\n        logContent);\n\n    return true;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 850, "initialization": ["ByteBuffer byteBuffer = ProtocolDataUnit.getDataSegment()"], "initializationStart": [734], "initializationEnd": [767], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 777, "guardExpressionEnd": 836, "guardBlockStart": 777, "guardBlockEnd": 889, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 860, "focalAPIEnd": 877, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [849], "useEnd": [878], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/disy/jSCSI/tree/master/bundles/initiator/src/main/java/org/jscsi/initiator/connection/state/ReadResponseState.java", "rawCode": "  /** {@inheritDoc} */\n  public final void execute() throws InternetSCSIException {\n\n    ProtocolDataUnit protocolDataUnit;\n\n    do {\n      protocolDataUnit = connection.receive();\n      boolean dataWasRead = false;\n      if (protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser) {\n        final DataInParser parser =\n            (DataInParser) protocolDataUnit.getBasicHeaderSegment().getParser();\n\n        if (LOGGER.isDebugEnabled()) {\n          LOGGER.debug(\n              \"Remaining, DataSegmentLength: \"\n                  + buffer.remaining()\n                  + \", \"\n                  + protocolDataUnit.getBasicHeaderSegment().getDataSegmentLength());\n        }\n\n        final ByteBuffer dataSegment = protocolDataUnit.getDataSegment();\n        while (buffer.hasRemaining() && dataSegment.hasRemaining()) {\n          buffer.put(dataSegment.get());\n        }\n        dataWasRead = true;\n        // last message with the status flag set\n        if (parser.isStatusFlag() && parser.getStatus() == SCSIStatus.GOOD) {\n          // return false;\n          return;\n        } else if (connection.getSettingAsInt(OperationalTextKey.ERROR_RECOVERY_LEVEL) > 0\n            && parser.isAcknowledgeFlag()) {\n          // TODO: Test this case\n          // send a DataAck\n          connection.nextState(new SNACKRequestState(connection, this, parser.getTargetTaskTag()));\n          // return true;\n          return;\n        } else if (protocolDataUnit.getBasicHeaderSegment().getParser()\n                instanceof SCSIResponseParser\n            && !dataWasRead) {\n          readHandleImmediateData(protocolDataUnit);\n        }\n      }\n    } while (!protocolDataUnit.getBasicHeaderSegment().isFinalFlag());\n\n    if (connection.getSettingAsBoolean(OperationalTextKey.IMMEDIATE_DATA)) {\n      return;\n    } else {\n      protocolDataUnit = connection.receive();\n      if (protocolDataUnit.getBasicHeaderSegment().getParser() instanceof SCSIResponseParser) {\n        readHandleImmediateData(protocolDataUnit);\n      }\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 851, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.position(int)"], "configurationStart": [86], "configurationEnd": [99], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 105, "focalAPIEnd": 112, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.get(byte[])", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.get(byte[],int,int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getChar()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getDouble()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getFloat()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getInt()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getLong()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getShort()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.put(byte[])", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.put(byte[])", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.put(byte[],int,int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putChar(char)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putDouble(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putFloat(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putInt(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putLong(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putShort(short)", "byteBuffer.position()"], "useStart": [134, 184, 203, 235, 255, 274, 312, 332, 351, 384, 404, 423, 458, 478, 497, 531, 551, 570, 602, 622, 641, 674, 694, 713, 747, 779, 798, 835, 855, 874, 906, 926, 945, 983, 1003, 1022, 1058, 1078, 1097, 1133, 1153, 1172, 1207, 1227, 1246, 1279, 1299, 1318, 1352, 1372, 1391, 1434], "useEnd": [146, 197, 213, 247, 268, 290, 324, 345, 362, 396, 417, 436, 470, 491, 509, 543, 564, 580, 614, 635, 652, 686, 707, 725, 759, 792, 813, 847, 868, 884, 918, 939, 961, 995, 1016, 1036, 1070, 1091, 1111, 1145, 1166, 1185, 1219, 1240, 1257, 1291, 1312, 1330, 1364, 1385, 1412, 1446], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/libcore/java/nio/BufferTest.java", "rawCode": "  private void testRelativePositions(ByteBuffer b) throws Exception {\n    // gets\n    b.position(0);\n    b.get();\n    assertEquals(1, b.position());\n\n    byte[] buf = new byte[5];\n    b.position(0);\n    b.get(buf);\n    assertEquals(5, b.position());\n\n    b.position(0);\n    b.get(buf, 1, 3);\n    assertEquals(3, b.position());\n\n    b.position(0);\n    b.getChar();\n    assertEquals(2, b.position());\n\n    b.position(0);\n    b.getDouble();\n    assertEquals(8, b.position());\n\n    b.position(0);\n    b.getFloat();\n    assertEquals(4, b.position());\n\n    b.position(0);\n    b.getInt();\n    assertEquals(4, b.position());\n\n    b.position(0);\n    b.getLong();\n    assertEquals(8, b.position());\n\n    b.position(0);\n    b.getShort();\n    assertEquals(2, b.position());\n\n    // puts\n    b.position(0);\n    b.put((byte) 0);\n    assertEquals(1, b.position());\n\n    b.position(0);\n    b.put(buf);\n    assertEquals(5, b.position());\n\n    b.position(0);\n    b.put(buf, 1, 3);\n    assertEquals(3, b.position());\n\n    b.position(0);\n    b.putChar('x');\n    assertEquals(2, b.position());\n\n    b.position(0);\n    b.putDouble(0);\n    assertEquals(8, b.position());\n\n    b.position(0);\n    b.putFloat(0);\n    assertEquals(4, b.position());\n\n    b.position(0);\n    b.putInt(0);\n    assertEquals(4, b.position());\n\n    b.position(0);\n    b.putLong(0);\n    assertEquals(8, b.position());\n\n    b.position(0);\n    b.putShort((short) 0);\n    assertEquals(2, b.position());\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 852, "initialization": ["ByteBuffer byteBuffer = createByteBuffer(*)"], "initializationStart": [4700], "initializationEnd": [4744], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte[])"], "configurationStart": [4750], "configurationEnd": [4770], "guardCondition": "index<texWidth*perPixel", "guardType": "LOOP {", "guardExpressionStart": 4974, "guardExpressionEnd": 5019, "guardBlockStart": 4974, "guardBlockEnd": 5197, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 5057, "focalAPIEnd": 5071, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.flip()"], "useStart": [5030, 5149, 5082, 5426, 5335, 5576, 5481, 5679], "useEnd": [5072, 5187, 5188, 5468, 5469, 5647, 5648, 5693], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/solar-1992/CE301---Individual-Project/tree/master/slick/src/org/newdawn/slick/opengl/TGAImageData.java", "rawCode": "  /**\n   * @see org.newdawn.slick.opengl.LoadableImageData#loadImage(java.io.InputStream, boolean,\n   *     boolean, int[])\n   */\n  public ByteBuffer loadImage(\n      InputStream fis, boolean flipped, boolean forceAlpha, int[] transparent) throws IOException {\n    if (transparent != null) {\n      forceAlpha = true;\n    }\n    byte red = 0;\n    byte green = 0;\n    byte blue = 0;\n    byte alpha = 0;\n\n    BufferedInputStream bis = new BufferedInputStream(fis, 100000);\n    DataInputStream dis = new DataInputStream(bis);\n\n    // Read in the Header\n    short idLength = (short) dis.read();\n    short colorMapType = (short) dis.read();\n    short imageType = (short) dis.read();\n    short cMapStart = flipEndian(dis.readShort());\n    short cMapLength = flipEndian(dis.readShort());\n    short cMapDepth = (short) dis.read();\n    short xOffset = flipEndian(dis.readShort());\n    short yOffset = flipEndian(dis.readShort());\n\n    width = flipEndian(dis.readShort());\n    height = flipEndian(dis.readShort());\n    pixelDepth = (short) dis.read();\n    if (pixelDepth == 32) {\n      forceAlpha = false;\n    }\n\n    texWidth = get2Fold(width);\n    texHeight = get2Fold(height);\n\n    short imageDescriptor = (short) dis.read();\n    if ((imageDescriptor & 0x0020) == 0) {\n      flipped = !flipped;\n    }\n\n    // Skip image ID\n    if (idLength > 0) {\n      bis.skip(idLength);\n    }\n\n    byte[] rawData = null;\n    if ((pixelDepth == 32) || (forceAlpha)) {\n      pixelDepth = 32;\n      rawData = new byte[texWidth * texHeight * 4];\n    } else if (pixelDepth == 24) {\n      rawData = new byte[texWidth * texHeight * 3];\n    } else {\n      throw new RuntimeException(\"Only 24 and 32 bit TGAs are supported\");\n    }\n\n    if (pixelDepth == 24) {\n      if (flipped) {\n        for (int i = height - 1; i >= 0; i--) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n\n            int ofs = ((j + (i * texWidth)) * 3);\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n          }\n        }\n      } else {\n        for (int i = 0; i < height; i++) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n\n            int ofs = ((j + (i * texWidth)) * 3);\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n          }\n        }\n      }\n    } else if (pixelDepth == 32) {\n      if (flipped) {\n        for (int i = height - 1; i >= 0; i--) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n            if (forceAlpha) {\n              alpha = (byte) 255;\n            } else {\n              alpha = dis.readByte();\n            }\n\n            int ofs = ((j + (i * texWidth)) * 4);\n\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n            rawData[ofs + 3] = alpha;\n\n            if (alpha == 0) {\n              rawData[ofs + 2] = (byte) 0;\n              rawData[ofs + 1] = (byte) 0;\n              rawData[ofs] = (byte) 0;\n            }\n          }\n        }\n      } else {\n        for (int i = 0; i < height; i++) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n            if (forceAlpha) {\n              alpha = (byte) 255;\n            } else {\n              alpha = dis.readByte();\n            }\n\n            int ofs = ((j + (i * texWidth)) * 4);\n\n            if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) {\n              rawData[ofs] = red;\n              rawData[ofs + 1] = green;\n              rawData[ofs + 2] = blue;\n              rawData[ofs + 3] = alpha;\n            } else {\n              rawData[ofs] = red;\n              rawData[ofs + 1] = green;\n              rawData[ofs + 2] = blue;\n              rawData[ofs + 3] = alpha;\n            }\n\n            if (alpha == 0) {\n              rawData[ofs + 2] = 0;\n              rawData[ofs + 1] = 0;\n              rawData[ofs] = 0;\n            }\n          }\n        }\n      }\n    }\n    fis.close();\n\n    if (transparent != null) {\n      for (int i = 0; i < rawData.length; i += 4) {\n        boolean match = true;\n        for (int c = 0; c < 3; c++) {\n          if (rawData[i + c] != transparent[c]) {\n            match = false;\n          }\n        }\n\n        if (match) {\n          rawData[i + 3] = 0;\n        }\n      }\n    }\n\n    // Get a pointer to the image memory\n    ByteBuffer scratch = BufferUtils.createByteBuffer(rawData.length);\n    scratch.put(rawData);\n\n    int perPixel = pixelDepth / 8;\n    if (height < texHeight - 1) {\n      int topOffset = (texHeight - 1) * (texWidth * perPixel);\n      int bottomOffset = (height - 1) * (texWidth * perPixel);\n      for (int x = 0; x < texWidth * perPixel; x++) {\n        scratch.put(topOffset + x, scratch.get(x));\n        scratch.put(\n            bottomOffset + (texWidth * perPixel) + x, scratch.get((texWidth * perPixel) + x));\n      }\n    }\n    if (width < texWidth - 1) {\n      for (int y = 0; y < texHeight; y++) {\n        for (int i = 0; i < perPixel; i++) {\n          scratch.put(\n              ((y + 1) * (texWidth * perPixel)) - perPixel + i,\n              scratch.get(y * (texWidth * perPixel) + i));\n          scratch.put(\n              (y * (texWidth * perPixel)) + (width * perPixel) + i,\n              scratch.get((y * (texWidth * perPixel)) + ((width - 1) * perPixel) + i));\n        }\n      }\n    }\n\n    scratch.flip();\n\n    return scratch;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 853, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 54, "focalAPIEnd": 71, "followUpCheck": "value == START_OF_FRAME", "checkType": "IF", "followUpCheckExpressionStart": 78, "followUpCheckExpressionEnd": 128, "followUpCheckBlockStart": 78, "followUpCheckBlockEnd": 1275, "use": ["ByteBuffer.put(value)"], "useStart": [1214], "useEnd": [1235], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/royb3/Energy_Vampires/tree/master/Mobile/EnergyVampire/src/net/tootallnate/websocket/WebSocket.java", "rawCode": "  private void recieveFrame() {\n    byte newestByte = this.buffer.get();\n\n    if (newestByte == START_OF_FRAME && !readingState) { // Beginning of Frame\n      this.currentFrame = null;\n      readingState = true;\n\n    } else if (newestByte == END_OF_FRAME && readingState) { // End of Frame\n      readingState = false;\n      String textFrame = null;\n      // currentFrame will be null if END_OF_FRAME was send directly after\n      // START_OF_FRAME, thus we will send 'null' as the sent message.\n      if (this.currentFrame != null) {\n        try {\n          textFrame = new String(this.currentFrame.array(), UTF8_CHARSET);\n        } catch (UnsupportedEncodingException ex) {\n          // TODO: Fire an 'onError' handler here\n          ex.printStackTrace();\n          textFrame = \"\";\n        }\n      }\n      this.wsl.onMessage(this, textFrame);\n\n    } else { // Regular frame data, add to current frame buffer\n      ByteBuffer frame =\n          ByteBuffer.allocate(\n              (this.currentFrame != null ? this.currentFrame.capacity() : 0)\n                  + this.buffer.capacity());\n      if (this.currentFrame != null) {\n        this.currentFrame.rewind();\n        frame.put(this.currentFrame);\n      }\n      frame.put(newestByte);\n      this.currentFrame = frame;\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 854, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 54, "guardExpressionEnd": 85, "guardBlockStart": 54, "guardBlockEnd": 1759, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 104, "focalAPIEnd": 118, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["readVarInt(byteBuffer)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.array()", "readVarInt(byteBuffer)", "readVarLong(byteBuffer)", "readVarInt(byteBuffer)", "readVarLong(byteBuffer)", "ByteBuffer.put(byteBuffer)"], "useStart": [178, 306, 288, 405, 490, 562, 657, 714, 1102, 1159, 1515], "useEnd": [208, 325, 332, 424, 514, 578, 687, 745, 1132, 1190, 1538], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yudis/h2database/tree/master/h2/src/tools/org/h2/dev/store/btree/StreamStore.java", "rawCode": "    private ByteArrayInputStream nextBuffer() {\n      while (idBuffer.hasRemaining()) {\n        switch (idBuffer.get()) {\n          case 0:\n            {\n              int len = DataUtils.readVarInt(idBuffer);\n              if (skip >= len) {\n                skip -= len;\n                idBuffer.position(idBuffer.position() + len);\n                continue;\n              }\n              int p = (int) (idBuffer.position() + skip);\n              int l = (int) (len - skip);\n              idBuffer.position(p + l);\n              return new ByteArrayInputStream(idBuffer.array(), p, l);\n            }\n          case 1:\n            {\n              int len = DataUtils.readVarInt(idBuffer);\n              long key = DataUtils.readVarLong(idBuffer);\n              if (skip >= len) {\n                skip -= len;\n                continue;\n              }\n              byte[] data = store.getBlock(key);\n              int s = (int) skip;\n              skip = 0;\n              return new ByteArrayInputStream(data, s, data.length - s);\n            }\n          case 2:\n            {\n              long len = DataUtils.readVarInt(idBuffer);\n              long key = DataUtils.readVarLong(idBuffer);\n              if (skip >= len) {\n                skip -= len;\n                continue;\n              }\n              byte[] k = store.getBlock(key);\n              ByteBuffer newBuffer =\n                  ByteBuffer.allocate(k.length + idBuffer.limit() - idBuffer.position());\n              newBuffer.put(k);\n              newBuffer.put(idBuffer);\n              newBuffer.flip();\n              idBuffer = newBuffer;\n              return nextBuffer();\n            }\n          default:\n            throw new IllegalArgumentException(\"Unsupported id\");\n        }\n      }\n      return null;\n    }\n"}, {"dataset": "byteBufferGet", "exampleID": 855, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<n", "guardType": "LOOP {", "guardExpressionStart": 1280, "guardExpressionEnd": 1325, "guardBlockStart": 1280, "guardBlockEnd": 1420, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 1348, "focalAPIEnd": 1360, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [3543], "useEnd": [3559], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Cyberspice/platform_tools_base/tree/master/lint/libs/lint-checks/src/main/java/com/android/tools/lint/checks/TypoLookup.java", "rawCode": "  /** See the {@link #readData()} for documentation on the data format. */\n  private static void writeDatabase(File file, List<String> lines) throws IOException {\n    /*\n     * 1. A file header, which is the exact contents of {@link FILE_HEADER} encoded\n     * as ASCII characters. The purpose of the header is to identify what the file\n     * is for, for anyone attempting to open the file.\n     * 2. A file version number. If the binary file does not match the reader's expected\n     * version, it can ignore it (and regenerate the cache from XML).\n     */\n\n    // Drop comments etc\n    List<String> words = new ArrayList<String>(lines.size());\n    for (String line : lines) {\n      if (!line.isEmpty() && Character.isLetter(line.charAt(0))) {\n        int end = line.indexOf(WORD_SEPARATOR);\n        if (end == -1) {\n          end = line.trim().length();\n        }\n        String typo = line.substring(0, end).trim();\n        String replacements = line.substring(end + WORD_SEPARATOR.length()).trim();\n        if (replacements.isEmpty()) {\n          // We don't support empty replacements\n          continue;\n        }\n        String combined = typo + (char) 0 + replacements;\n\n        words.add(combined);\n      }\n    }\n\n    byte[][] wordArrays = new byte[words.size()][];\n    for (int i = 0, n = words.size(); i < n; i++) {\n      String word = words.get(i);\n      wordArrays[i] = word.getBytes(Charsets.UTF_8);\n    }\n    // Sort words, using our own comparator to ensure that it matches the\n    // binary search in getTypos()\n    Comparator<byte[]> comparator =\n        new Comparator<byte[]>() {\n          @Override\n          public int compare(byte[] o1, byte[] o2) {\n            return TypoLookup.compare(o1, 0, (byte) 0, o2, 0, o2.length);\n          }\n        };\n    Arrays.sort(wordArrays, comparator);\n\n    int entryCount = wordArrays.length;\n    int capacity = entryCount * BYTES_PER_ENTRY;\n    ByteBuffer buffer = ByteBuffer.allocate(capacity);\n    buffer.order(ByteOrder.BIG_ENDIAN);\n    // 1. A file header, which is the exact contents of {@link FILE_HEADER} encoded\n    // as ASCII characters. The purpose of the header is to identify what the file\n    // is for, for anyone attempting to open the file.\n    buffer.put(FILE_HEADER.getBytes(Charsets.US_ASCII));\n\n    // 2. A file version number. If the binary file does not match the reader's expected\n    // version, it can ignore it (and regenerate the cache from XML).\n    buffer.put((byte) BINARY_FORMAT_VERSION);\n\n    // 3. The number of words [1 int]\n    buffer.putInt(entryCount);\n\n    // 4. Word offset table (one integer per word, pointing to the byte offset in the\n    // file (relative to the beginning of the file) where each word begins.\n    // The words are always sorted alphabetically.\n    int wordOffsetTable = buffer.position();\n\n    // Reserve enough room for the offset table here: we will backfill it with pointers\n    // as we're writing out the data structures below\n    for (int i = 0, n = entryCount; i < n; i++) {\n      buffer.putInt(0);\n    }\n\n    int nextEntry = buffer.position();\n    int nextOffset = wordOffsetTable;\n\n    // 7. Word entry table. Each word entry consists of the word, followed by the byte 0\n    // as a terminator, followed by a comma separated list of suggestions (which\n    // may be empty), or a final 0.\n    for (int i = 0; i < entryCount; i++) {\n      byte[] word = wordArrays[i];\n      buffer.position(nextOffset);\n      buffer.putInt(nextEntry);\n      nextOffset = buffer.position();\n      buffer.position(nextEntry);\n\n      buffer.put(word); // already embeds 0 to separate typo from words\n      buffer.put((byte) 0);\n\n      nextEntry = buffer.position();\n    }\n\n    int size = buffer.position();\n    assert size <= buffer.limit();\n    buffer.mark();\n\n    if (WRITE_STATS) {\n      System.out.println(\"Wrote \" + words.size() + \" word entries\");\n      System.out.print(\"Actual binary size: \" + size + \" bytes\");\n      System.out.println(String.format(\" (%.1fM)\", size / (1024 * 1024.f)));\n\n      System.out.println(\"Allocated size: \" + (entryCount * BYTES_PER_ENTRY) + \" bytes\");\n      System.out.println(\"Required bytes per entry: \" + (size / entryCount) + \" bytes\");\n    }\n\n    // Now dump this out as a file\n    // There's probably an API to do this more efficiently; TODO: Look into this.\n    byte[] b = new byte[size];\n    buffer.rewind();\n    buffer.get(b);\n    FileOutputStream output = Files.newOutputStreamSupplier(file).getOutput();\n    output.write(b);\n    output.close();\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 856, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 103, "guardExpressionEnd": 132, "guardBlockStart": 103, "guardBlockEnd": 1447, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 159, "focalAPIEnd": 171, "followUpCheck": "value == START_OF_FRAME", "checkType": "IF", "followUpCheckExpressionStart": 179, "followUpCheckExpressionEnd": 212, "followUpCheckBlockStart": 179, "followUpCheckBlockEnd": 1441, "use": ["byteBuffer.mark()", "ByteBuffer.put(value)"], "useStart": [923, 1368], "useEnd": [936, 1396], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/GrantSparks/mtgox-java/tree/master/src/main/java/org/java_websocket/drafts/Draft_75.java", "rawCode": "  protected List<Framedata> translateRegularFrame(ByteBuffer buffer) throws InvalidDataException {\n    while (buffer.hasRemaining()) {\n      byte newestByte = buffer.get();\n      if (newestByte == START_OF_FRAME) { // Beginning of Frame\n        if (readingState) return null;\n        readingState = true;\n      } else if (newestByte == END_OF_FRAME) { // End of Frame\n        if (!readingState) return null;\n        // currentFrame will be null if END_OF_FRAME was send directly after\n        // START_OF_FRAME, thus we will send 'null' as the sent message.\n        if (this.currentFrame != null) {\n          currentFrame.flip();\n          FramedataImpl1 curframe = new FramedataImpl1();\n          curframe.setPayload(currentFrame);\n          curframe.setFin(true);\n          curframe.setOptcode(inframe ? Opcode.CONTINUOUS : Opcode.TEXT);\n          readyframes.add(curframe);\n          this.currentFrame = null;\n          buffer.mark();\n        }\n        readingState = false;\n        inframe = false;\n      } else if (readingState) { // Regular frame data, add to current frame buffer //TODO This code\n                                 // is very expensive and slow\n        if (currentFrame == null) {\n          currentFrame = createBuffer();\n        } else if (!currentFrame.hasRemaining()) {\n          currentFrame = increaseBuffer(currentFrame);\n        }\n        currentFrame.put(newestByte);\n      } else {\n        return null;\n      }\n    }\n    if (readingState) {\n      FramedataImpl1 curframe = new FramedataImpl1();\n      currentFrame.flip();\n      curframe.setPayload(currentFrame);\n      curframe.setFin(false);\n      curframe.setOptcode(inframe ? Opcode.CONTINUOUS : Opcode.TEXT);\n      inframe = true;\n      readyframes.add(curframe);\n    }\n\n    List<Framedata> frames = readyframes;\n    readyframes = new LinkedList<Framedata>();\n    this.currentFrame = null;\n    return frames;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 857, "initialization": ["ByteBuffer byteBuffer = createByteBuffer(*)"], "initializationStart": [4700], "initializationEnd": [4744], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte[])"], "configurationStart": [4750], "configurationEnd": [4770], "guardCondition": "index<texWidth*perPixel", "guardType": "LOOP {", "guardExpressionStart": 4974, "guardExpressionEnd": 5019, "guardBlockStart": 4974, "guardBlockEnd": 5197, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 5057, "focalAPIEnd": 5071, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.flip()"], "useStart": [5030, 5149, 5082, 5426, 5335, 5576, 5481, 5679], "useEnd": [5072, 5187, 5188, 5468, 5469, 5647, 5648, 5693], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nam0r/Devint/tree/master/Slick/Slick/src/org/newdawn/slick/opengl/TGAImageData.java", "rawCode": "  /**\n   * @see org.newdawn.slick.opengl.LoadableImageData#loadImage(java.io.InputStream, boolean,\n   *     boolean, int[])\n   */\n  public ByteBuffer loadImage(\n      InputStream fis, boolean flipped, boolean forceAlpha, int[] transparent) throws IOException {\n    if (transparent != null) {\n      forceAlpha = true;\n    }\n    byte red = 0;\n    byte green = 0;\n    byte blue = 0;\n    byte alpha = 0;\n\n    BufferedInputStream bis = new BufferedInputStream(fis, 100000);\n    DataInputStream dis = new DataInputStream(bis);\n\n    // Read in the Header\n    short idLength = (short) dis.read();\n    short colorMapType = (short) dis.read();\n    short imageType = (short) dis.read();\n    short cMapStart = flipEndian(dis.readShort());\n    short cMapLength = flipEndian(dis.readShort());\n    short cMapDepth = (short) dis.read();\n    short xOffset = flipEndian(dis.readShort());\n    short yOffset = flipEndian(dis.readShort());\n\n    width = flipEndian(dis.readShort());\n    height = flipEndian(dis.readShort());\n    pixelDepth = (short) dis.read();\n    if (pixelDepth == 32) {\n      forceAlpha = false;\n    }\n\n    texWidth = get2Fold(width);\n    texHeight = get2Fold(height);\n\n    short imageDescriptor = (short) dis.read();\n    if ((imageDescriptor & 0x0020) == 0) {\n      flipped = !flipped;\n    }\n\n    // Skip image ID\n    if (idLength > 0) {\n      bis.skip(idLength);\n    }\n\n    byte[] rawData = null;\n    if ((pixelDepth == 32) || (forceAlpha)) {\n      pixelDepth = 32;\n      rawData = new byte[texWidth * texHeight * 4];\n    } else if (pixelDepth == 24) {\n      rawData = new byte[texWidth * texHeight * 3];\n    } else {\n      throw new RuntimeException(\"Only 24 and 32 bit TGAs are supported\");\n    }\n\n    if (pixelDepth == 24) {\n      if (flipped) {\n        for (int i = height - 1; i >= 0; i--) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n\n            int ofs = ((j + (i * texWidth)) * 3);\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n          }\n        }\n      } else {\n        for (int i = 0; i < height; i++) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n\n            int ofs = ((j + (i * texWidth)) * 3);\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n          }\n        }\n      }\n    } else if (pixelDepth == 32) {\n      if (flipped) {\n        for (int i = height - 1; i >= 0; i--) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n            if (forceAlpha) {\n              alpha = (byte) 255;\n            } else {\n              alpha = dis.readByte();\n            }\n\n            int ofs = ((j + (i * texWidth)) * 4);\n\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n            rawData[ofs + 3] = alpha;\n\n            if (alpha == 0) {\n              rawData[ofs + 2] = (byte) 0;\n              rawData[ofs + 1] = (byte) 0;\n              rawData[ofs] = (byte) 0;\n            }\n          }\n        }\n      } else {\n        for (int i = 0; i < height; i++) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n            if (forceAlpha) {\n              alpha = (byte) 255;\n            } else {\n              alpha = dis.readByte();\n            }\n\n            int ofs = ((j + (i * texWidth)) * 4);\n\n            if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) {\n              rawData[ofs] = red;\n              rawData[ofs + 1] = green;\n              rawData[ofs + 2] = blue;\n              rawData[ofs + 3] = alpha;\n            } else {\n              rawData[ofs] = red;\n              rawData[ofs + 1] = green;\n              rawData[ofs + 2] = blue;\n              rawData[ofs + 3] = alpha;\n            }\n\n            if (alpha == 0) {\n              rawData[ofs + 2] = 0;\n              rawData[ofs + 1] = 0;\n              rawData[ofs] = 0;\n            }\n          }\n        }\n      }\n    }\n    fis.close();\n\n    if (transparent != null) {\n      for (int i = 0; i < rawData.length; i += 4) {\n        boolean match = true;\n        for (int c = 0; c < 3; c++) {\n          if (rawData[i + c] != transparent[c]) {\n            match = false;\n          }\n        }\n\n        if (match) {\n          rawData[i + 3] = 0;\n        }\n      }\n    }\n\n    // Get a pointer to the image memory\n    ByteBuffer scratch = BufferUtils.createByteBuffer(rawData.length);\n    scratch.put(rawData);\n\n    int perPixel = pixelDepth / 8;\n    if (height < texHeight - 1) {\n      int topOffset = (texHeight - 1) * (texWidth * perPixel);\n      int bottomOffset = (height - 1) * (texWidth * perPixel);\n      for (int x = 0; x < texWidth * perPixel; x++) {\n        scratch.put(topOffset + x, scratch.get(x));\n        scratch.put(\n            bottomOffset + (texWidth * perPixel) + x, scratch.get((texWidth * perPixel) + x));\n      }\n    }\n    if (width < texWidth - 1) {\n      for (int y = 0; y < texHeight; y++) {\n        for (int i = 0; i < perPixel; i++) {\n          scratch.put(\n              ((y + 1) * (texWidth * perPixel)) - perPixel + i,\n              scratch.get(y * (texWidth * perPixel) + i));\n          scratch.put(\n              (y * (texWidth * perPixel)) + (width * perPixel) + i,\n              scratch.get((y * (texWidth * perPixel)) + ((width - 1) * perPixel) + i));\n        }\n      }\n    }\n\n    scratch.flip();\n\n    return scratch;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 858, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0-rc10/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 859, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.14/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 860, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.3.0-b01/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 861, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 526, "focalAPIEnd": 535, "followUpCheck": "i < value", "checkType": "LOOP", "followUpCheckExpressionStart": 592, "followUpCheckExpressionEnd": 623, "followUpCheckBlockStart": 592, "followUpCheckBlockEnd": 657, "use": ["byteBuffer.get(byte[])"], "useStart": [569], "useEnd": [583], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kaupppa/Javnce/tree/master/core/src/main/java/org/javnce/util/RunLengthEncoder.java", "rawCode": "  /**\n   * Convert Run-length encoded data.\n   *\n   * @param buffer the RLE coded buffer\n   * @param width the width\n   * @param height the height\n   * @return the byte buffer\n   */\n  static ByteBuffer decode(ByteBuffer src, int width, int height, int bytesPerPixel) {\n\n    byte[] pixel = new byte[bytesPerPixel];\n\n    ByteBuffer dst = ByteBuffer.allocate(width * height * bytesPerPixel);\n\n    int rleSize = bytesPerPixel + 1;\n\n    while ((rleSize) <= src.remaining() && bytesPerPixel <= dst.remaining()) {\n\n      int count = src.get() & 0xff;\n      count += 1;\n\n      src.get(pixel);\n\n      for (int i = 0; i < count; i++) {\n        dst.put(pixel);\n      }\n    }\n\n    dst.clear();\n    return dst;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 862, "initialization": ["ByteBuffer byteBuffer = allocate(int)", "ByteBuffer byteBuffer = ObjectDataType.write(ByteBuffer,Object)"], "initializationStart": [389, 452], "initializationEnd": [414, 469], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte[])", "byteBuffer.flip()"], "configurationStart": [475, 501], "configurationEnd": [495, 512], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 591, "focalAPIEnd": 601, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(int,value)", "byteBuffer.remaining()"], "useStart": [573, 624], "useEnd": [602, 640], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/agueganno/h2geometry/tree/master/h2/src/test/org/h2/test/store/TestObjectDataType.java", "rawCode": "  private void test(Object last, Object x) {\n    ObjectDataType ot = new ObjectDataType();\n\n    // switch to the last type before every operation,\n    // to test switching types\n    ot.getMemory(last);\n    assertTrue(ot.getMemory(x) >= 0);\n\n    ot.getMemory(last);\n    assertTrue(ot.getMemory(x) >= 0);\n\n    ot.getMemory(last);\n    assertEquals(0, ot.compare(x, x));\n    ByteBuffer buff = ByteBuffer.allocate(1024);\n\n    ot.getMemory(last);\n    buff = ot.write(buff, x);\n    buff.put((byte) 123);\n    buff.flip();\n\n    ot.getMemory(last);\n    Object y = ot.read(buff);\n    assertEquals(123, buff.get());\n    assertEquals(0, buff.remaining());\n    assertEquals(x.getClass().getName(), y.getClass().getName());\n\n    ot.getMemory(last);\n    assertEquals(0, ot.compare(x, y));\n    if (x.getClass().isArray()) {\n      if (x instanceof byte[]) {\n        assertTrue(Arrays.equals((byte[]) x, (byte[]) y));\n      } else if (x instanceof boolean[]) {\n        assertTrue(Arrays.equals((boolean[]) x, (boolean[]) y));\n      } else if (x instanceof short[]) {\n        assertTrue(Arrays.equals((short[]) x, (short[]) y));\n      } else if (x instanceof float[]) {\n        assertTrue(Arrays.equals((float[]) x, (float[]) y));\n      } else if (x instanceof double[]) {\n        assertTrue(Arrays.equals((double[]) x, (double[]) y));\n      } else if (x instanceof char[]) {\n        assertTrue(Arrays.equals((char[]) x, (char[]) y));\n      } else if (x instanceof int[]) {\n        assertTrue(Arrays.equals((int[]) x, (int[]) y));\n      } else if (x instanceof long[]) {\n        assertTrue(Arrays.equals((long[]) x, (long[]) y));\n      } else {\n        assertTrue(Arrays.equals((Object[]) x, (Object[]) y));\n      }\n    } else {\n      assertEquals(x.hashCode(), y.hashCode());\n      assertTrue(x.equals(y));\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 863, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.9/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 864, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/trunk/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 865, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "byteBuffer.remaining()>0", "guardType": "LOOP {", "guardExpressionStart": 106, "guardExpressionEnd": 167, "guardBlockStart": 106, "guardBlockEnd": 212, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 192, "focalAPIEnd": 204, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [176], "useEnd": [205], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CSEMike/OneSwarm/tree/master/az_src/src/org/gudy/azureus2/core3/util/SHA1.java", "rawCode": "  private void completeFinalBuffer(ByteBuffer buffer) {\n    if (finalBuffer.position() == 0) return;\n\n    while (buffer.remaining() > 0 && finalBuffer.remaining() > 0) {\n      finalBuffer.put(buffer.get());\n    }\n\n    if (finalBuffer.remaining() == 0) {\n      transform(finalBuffer.array(), 0);\n      finalBuffer.rewind();\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 866, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.getInt()"], "configurationStart": [777], "configurationEnd": [792], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 730, "guardExpressionEnd": 759, "guardBlockStart": 730, "guardBlockEnd": 3039, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 807, "focalAPIEnd": 819, "followUpCheck": "value == EnumProtocol.TYPE_INT", "checkType": "IF", "followUpCheckExpressionStart": 827, "followUpCheckExpressionEnd": 861, "followUpCheckBlockStart": 827, "followUpCheckBlockEnd": 3033, "use": ["byteBuffer.getInt()", "byteBuffer.getInt()", "byteBuffer.getInt()", "byteBuffer.getInt()", "byteBuffer.getInt()", "byteBuffer.get(byte[])", "byteBuffer.get(byte[])", "byteBuffer.get(byte[])", "byteBuffer.get(byte[])"], "useStart": [930, 1016, 1112, 1208, 1310, 1467, 1732, 2049, 2332], "useEnd": [945, 1031, 1127, 1223, 1325, 1482, 1747, 2064, 2347], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnnyeven/godwar-server/tree/master/GodwarLogicServer/src/com/xgame/server/logic/GameServerHolderThread.java", "rawCode": "  private void requestLogicServerRoom(ByteBuffer buffer) {\n    int length = Integer.MIN_VALUE;\n    int type = Integer.MIN_VALUE;\n\n    int roomType = Integer.MIN_VALUE;\n    int roomId = Integer.MIN_VALUE;\n    String roomTitle = null;\n    int peopleCount = Integer.MIN_VALUE;\n    String ownerGuid = null;\n    List<String> playerList = new ArrayList<String>();\n    Map<String, String> heroList = new HashMap<String, String>();\n    Map<String, Integer> groupList = new HashMap<String, Integer>();\n    Map<String, Integer> positionList = new HashMap<String, Integer>();\n    String playerGuid = null;\n    int playerGroup = Integer.MIN_VALUE;\n    int playerPosition = Integer.MIN_VALUE;\n    String heroCardId = null;\n    byte[] dst;\n    while (buffer.hasRemaining()) {\n      length = buffer.getInt();\n      type = buffer.get();\n      if (type == EnumProtocol.TYPE_INT) {\n        if (roomType == Integer.MIN_VALUE) {\n          roomType = buffer.getInt();\n        } else if (roomId == Integer.MIN_VALUE) {\n          roomId = buffer.getInt();\n        } else if (peopleCount == Integer.MIN_VALUE) {\n          peopleCount = buffer.getInt();\n        } else if (playerGroup == Integer.MIN_VALUE) {\n          playerGroup = buffer.getInt();\n        } else if (playerPosition == Integer.MIN_VALUE) {\n          playerPosition = buffer.getInt();\n        }\n      } else if (type == EnumProtocol.TYPE_STRING) {\n        if (roomTitle == null) {\n          dst = new byte[length];\n          buffer.get(dst);\n          try {\n            roomTitle = new String(dst, \"UTF-8\");\n          } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n          }\n        } else if (ownerGuid == null) {\n          dst = new byte[length];\n          buffer.get(dst);\n          try {\n            ownerGuid = new String(dst, \"UTF-8\");\n          } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n          }\n        } else if (heroList.size() < peopleCount) {\n          if (playerGuid == null) {\n            dst = new byte[length];\n            buffer.get(dst);\n            try {\n              playerGuid = new String(dst, \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n              e.printStackTrace();\n            }\n          } else if (heroCardId == null) {\n            dst = new byte[length];\n            buffer.get(dst);\n            try {\n              heroCardId = new String(dst, \"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n              e.printStackTrace();\n            }\n          }\n        }\n\n        if (playerGuid != null\n            && playerGroup != Integer.MIN_VALUE\n            && playerPosition != Integer.MIN_VALUE\n            && heroCardId != null) {\n          heroList.put(playerGuid, heroCardId);\n          groupList.put(playerGuid, playerGroup);\n          positionList.put(playerGuid, playerPosition);\n\n          playerGuid = null;\n          playerGroup = Integer.MIN_VALUE;\n          playerPosition = Integer.MIN_VALUE;\n          heroCardId = null;\n        }\n      }\n    }\n\n    if (roomType == 0) {\n      BattleRoom room = BattleHall.getInstance().addRoom(roomId);\n      if (room != null) {\n        room.setTitle(roomTitle);\n        room.setPeopleCount(peopleCount);\n        room.initialize();\n        Iterator<Entry<String, String>> it = heroList.entrySet().iterator();\n        Entry<String, String> en;\n        String guid;\n        while (it.hasNext()) {\n          en = it.next();\n          guid = en.getKey();\n          room.addHeroCardId(guid, en.getValue());\n          room.addPlayerGuid(guid, groupList.get(guid));\n          room.addPlayerPosition(guid, positionList.get(guid));\n        }\n\n        log.info(\"[RequestRoom] 房间创建成功，等待客户端连接, room id = \" + roomId);\n        // TODO 通知GameServer创建房间成功\n        DatagramPacket p = DatagramPacketPool.getInstance().getObject();\n        p.setSocketAddress(LogicServer.gameServerAdd);\n\n        ByteBuffer bf = BufferPool.getInstance().getBuffer();\n\n        bf.putShort(EnumProtocol.BASE_REQUEST_LOGIC_SERVER_ROOM_CONFIRM);\n\n        bf.putInt(4);\n        bf.put((byte) EnumProtocol.TYPE_INT);\n        bf.putInt(roomType);\n\n        bf.putInt(4);\n        bf.put((byte) EnumProtocol.TYPE_INT);\n        bf.putInt(roomId);\n\n        bf.flip();\n\n        byte[] dest = new byte[bf.remaining()];\n        bf.get(dest, 0, dest.length);\n\n        p.setData(dest);\n\n        GameServerConnector.getInstance().send(p);\n      } else {\n        log.error(\"[RequestRoom] 创建房间失败, room id = \" + roomId);\n        // TODO 通知GameServer创建房间失败\n      }\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 867, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.clear()", "byteBuffer.mark()", "byteBuffer.put(byte[])", "byteBuffer.reset()", "byteBuffer.clear()", "byteBuffer.flip()"], "configurationStart": [66, 86, 137, 220, 368, 394], "configurationEnd": [79, 98, 170, 233, 381, 406], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 424, "focalAPIEnd": 435, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.order(ByteOrder)"], "useStart": [412], "useEnd": [490], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robo-code/robocode/tree/master/robocode.core/src/main/java/net/sf/robocode/robotpaint/Graphics2DSerialized.java", "rawCode": "  public void processTo(Graphics2D g, Object graphicsCalls) {\n    calls.clear();\n\n    calls.mark(); // Mark for rollback\n    try {\n      calls.put((byte[]) graphicsCalls);\n    } catch (BufferOverflowException e) {\n      calls.reset(); // Rollback buffer\n      if (reallocBuffer()) {\n        processTo(g, graphicsCalls);\n        return; // must exit here\n      }\n      calls.clear();\n    }\n\n    calls.flip();\n    calls.order(calls.get() == 1 ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\n\n    while (calls.remaining() > 0) {\n      try {\n        processQueuedCall(g);\n      } catch (Exception e) {\n        e.printStackTrace();\n        // FOR-DEBUG } catch (Error e) {\n        // FOR-DEBUG calls.position(lastPos - 4);\n      }\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 868, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.remaining()"], "configurationStart": [96], "configurationEnd": [111], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 159, "guardExpressionEnd": 185, "guardBlockStart": 159, "guardBlockEnd": 406, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 218, "focalAPIEnd": 227, "followUpCheck": "value == (byte)'\\n'", "checkType": "IF", "followUpCheckExpressionStart": 256, "followUpCheckExpressionEnd": 302, "followUpCheckBlockStart": 256, "followUpCheckBlockEnd": 400, "use": ["ByteBuffer.put(value)", "byteBuffer.position()", "byteBuffer.position()", "byteBuffer.position(int)"], "useStart": [235, 324, 475, 462], "useEnd": [248, 339, 489, 508], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.java_websocket/src/main/java/org/java_websocket/drafts/Draft.java", "rawCode": "  public static ByteBuffer readLine(ByteBuffer buf) {\n    ByteBuffer sbuf = ByteBuffer.allocate(buf.remaining());\n    byte prev = '0';\n    byte cur = '0';\n    while (buf.hasRemaining()) {\n      prev = cur;\n      cur = buf.get();\n      sbuf.put(cur);\n      if (prev == (byte) '\\r' && cur == (byte) '\\n') {\n        sbuf.limit(sbuf.position() - 2);\n        sbuf.position(0);\n        return sbuf;\n      }\n    }\n    // ensure that there wont be any bytes skipped\n    buf.position(buf.position() - sbuf.position());\n    return null;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 869, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.rewind()"], "configurationStart": [344], "configurationEnd": [365], "guardCondition": "index<bytesRead", "guardType": "LOOP {", "guardExpressionStart": 545, "guardExpressionEnd": 580, "guardBlockStart": 545, "guardBlockEnd": 774, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 627, "focalAPIEnd": 646, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [616], "useEnd": [647], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/royb3/Energy_Vampires/tree/master/Mobile/EnergyVampire/src/net/tootallnate/websocket/WebSocket.java", "rawCode": "  /**\n   * Should be called when a Selector has a key that is writable for this WebSocket's SocketChannel\n   * connection.\n   *\n   * @throws IOException When socket related I/O errors occur.\n   * @throws NoSuchAlgorithmException\n   */\n  void handleRead() throws IOException, NoSuchAlgorithmException {\n\n    int bytesRead = -1;\n\n    try {\n      socketBuffer.rewind();\n      bytesRead = this.socketChannel.read(this.socketBuffer);\n    } catch (Exception ex) {\n    }\n\n    if (bytesRead == -1) {\n      close();\n    } else if (bytesRead > 0) {\n      for (int i = 0; i < bytesRead; i++) {\n        buffer.rewind();\n        buffer.put(socketBuffer.get(i));\n\n        this.buffer.rewind();\n\n        if (!this.handshakeComplete) recieveHandshake();\n        else recieveFrame();\n      }\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 870, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<decryptDataLen", "guardType": "LOOP {", "guardExpressionStart": 414, "guardExpressionEnd": 454, "guardBlockStart": 414, "guardBlockEnd": 650, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 477, "focalAPIEnd": 497, "followUpCheck": "value != 0 && value != -1 && value != 1", "checkType": "IF", "followUpCheckExpressionStart": 505, "followUpCheckExpressionEnd": 567, "followUpCheckBlockStart": 505, "followUpCheckBlockEnd": 644, "use": ["byteBuffer.put(byte)", "byteBuffer.position(int)", "byteBuffer.get(byte[],int,int)"], "useStart": [578, 708, 752], "useEnd": [608, 746, 803], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/polyvi/xface-android/tree/master/framework/src/com/polyvi/xface/util/XCryptor.java", "rawCode": "  /**\n   * 由于android平台的doFinal方法解密出的二进制数组 会多出-1和0和1的无效数字，平台自身错误，在java平台上不会遇到这种情况。 需要处理掉-1和0和1\n   *\n   * <p>TODO:以后android的doFinal方法解决此问题后该函数可以删除\n   *\n   * @param decryptBuffer [in] 需要处理的二进制缓存\n   * @param decryptDataLen [in] 需要处理的二进制数组长度\n   * @return 去掉-1、0、1的二进制数组\n   */\n  private byte[] handleDoFinalBytes(ByteBuffer decryptBuffer, int decryptDataLen) {\n    byte decryptData = 0;\n    int handledArrayLen = 0;\n    for (int i = 0; i < decryptDataLen; i++) {\n      decryptData = decryptBuffer.get(i);\n      if (decryptData != 0 && decryptData != -1 && decryptData != 1) {\n        decryptBuffer.put(decryptData);\n        handledArrayLen++;\n      }\n    }\n    byte[] handledArray = new byte[handledArrayLen];\n    decryptBuffer.position(decryptDataLen);\n    decryptBuffer.get(handledArray, 0, handledArrayLen);\n    return handledArray;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 871, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 582, "focalAPIEnd": 612, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(int,byte)"], "useStart": [657], "useEnd": [697], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FoxyCorndog/WorkspaceOld/tree/master/gafggfds/LWJGL/lwjgl-2.8.5/src/java/org/lwjgl/opengl/LinuxDisplay.java", "rawCode": "  private static ByteBuffer convertIconMask(ByteBuffer icon, int width, int height) {\n    ByteBuffer icon_mask = BufferUtils.createByteBuffer((icon.capacity() / 4) / 8);\n    int x;\n    int y;\n    byte a;\n\n    int depth = 4;\n\n    for (y = 0; y < height; y++) {\n      for (x = 0; x < width; x++) {\n        a = icon.get((x * 4) + (y * width * 4) + 3);\n\n        int mask_index = x + y * width;\n        int mask_byte_index = mask_index / 8;\n        int mask_bit_index = mask_index % 8;\n        byte bit = (((int) a) & 0xff) >= 127 ? (byte) 1 : (byte) 0;\n        byte new_byte = (byte) ((icon_mask.get(mask_byte_index) | (bit << mask_bit_index)) & 0xff);\n        icon_mask.put(mask_byte_index, new_byte);\n      }\n    }\n    return icon_mask;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 872, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 873, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.16/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 874, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.remaining()"], "configurationStart": [114], "configurationEnd": [139], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 194, "focalAPIEnd": 213, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [269], "useEnd": [289], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CSEMike/OneSwarm/tree/master/az_src/src/com/aelitis/azureus/core/networkmanager/impl/TransportHelperFilterStreamXOR.java", "rawCode": "  protected void cryptoIn(ByteBuffer source_buffer, ByteBuffer target_buffer) throws IOException {\n\n    int rem = source_buffer.remaining();\n\n    for (int i = 0; i < rem; i++) {\n\n      byte b = source_buffer.get();\n\n      b = (byte) (b ^ mask[read_position++]);\n\n      target_buffer.put(b);\n\n      if (read_position == mask.length) {\n\n        read_position = 0;\n      }\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 875, "initialization": ["ByteBuffer byteBuffer = PacketPayload.toByteBuffer()"], "initializationStart": [298], "initializationEnd": [320], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "byteBuffer.remaining()>0", "guardType": "LOOP {", "guardExpressionStart": 382, "guardExpressionEnd": 419, "guardBlockStart": 382, "guardBlockEnd": 878, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 437, "focalAPIEnd": 456, "followUpCheck": "value >= 32 && value <= 126", "checkType": "IF", "followUpCheckExpressionStart": 464, "followUpCheckExpressionEnd": 488, "followUpCheckBlockStart": 464, "followUpCheckBlockEnd": 872, "use": ["ByteBuffer.put(value)"], "useStart": [543], "useEnd": [560], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brl/netifera/tree/master/platform/com.netifera.platform.net.wifi/com.netifera.platform.net.wifi.tools/src/com/netifera/platform/net/wifi/tools/TestWifiSniffer.java", "rawCode": "  private void processFrame(WiFiFrame frame) {\n    // System.out.println(\"wifi --> \" + frame.print());\n    PacketPayload payload = (PacketPayload) frame.findHeader(PacketPayload.class);\n\n    boolean asciiFound = false;\n    if (payload == null) {\n      return;\n    }\n\n    ByteBuffer payloadBuffer = payload.toByteBuffer();\n    ByteBuffer lineBuffer = ByteBuffer.allocate(1024);\n\n    while (payloadBuffer.remaining() > 0) {\n      byte b = payloadBuffer.get();\n      if (b >= 32 && b <= 126) {\n        if (lineBuffer.remaining() > 0) {\n          lineBuffer.put(b);\n        }\n      } else {\n        if (lineBuffer.position() >= MIN_LENGTH) {\n          if (!asciiFound) {\n            outputBuffer.append(frame.print() + \"\\n\");\n          }\n          lineBuffer.flip();\n          printBuffer(lineBuffer);\n          asciiFound = true;\n        }\n        lineBuffer.clear();\n      }\n    }\n\n    if (asciiFound) {\n      outputBuffer.append(\"\\n\");\n      // ctx.extra(\"wifi-ascii\", outputBuffer.toString());\n      resetBuffer();\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 876, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 2042, "focalAPIEnd": 2050, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srcvirus/floodlight/tree/master/src/main/java/net/floodlightcontroller/packet/TCP.java", "rawCode": "  /**\n   * Serializes the packet. Will compute and set the following fields if they are set to specific\n   * values at the time serialize is called: -checksum : 0 -length : 0\n   */\n  public byte[] serialize() {\n    int length;\n    if (dataOffset == 0) dataOffset = 5; // default header length\n    length = dataOffset << 2;\n    byte[] payloadData = null;\n    if (payload != null) {\n      payload.setParent(this);\n      payloadData = payload.serialize();\n      length += payloadData.length;\n    }\n\n    byte[] data = new byte[length];\n    ByteBuffer bb = ByteBuffer.wrap(data);\n\n    bb.putShort(this.sourcePort);\n    bb.putShort(this.destinationPort);\n    bb.putInt(this.sequence);\n    bb.putInt(this.acknowledge);\n    bb.putShort((short) (this.flags | (dataOffset << 12)));\n    bb.putShort(this.windowSize);\n    bb.putShort(this.checksum);\n    bb.putShort(this.urgentPointer);\n    if (dataOffset > 5) {\n      int padding;\n      bb.put(options);\n      padding = (dataOffset << 2) - 20 - options.length;\n      for (int i = 0; i < padding; i++) bb.put((byte) 0);\n    }\n    if (payloadData != null) bb.put(payloadData);\n\n    if (this.parent != null && this.parent instanceof IPv4)\n      ((IPv4) this.parent).setProtocol(IPv4.PROTOCOL_TCP);\n\n    // compute checksum if needed\n    if (this.checksum == 0) {\n      bb.rewind();\n      int accumulation = 0;\n\n      // compute pseudo header mac\n      if (this.parent != null && this.parent instanceof IPv4) {\n        IPv4 ipv4 = (IPv4) this.parent;\n        accumulation +=\n            ((ipv4.getSourceAddress() >> 16) & 0xffff) + (ipv4.getSourceAddress() & 0xffff);\n        accumulation +=\n            ((ipv4.getDestinationAddress() >> 16) & 0xffff)\n                + (ipv4.getDestinationAddress() & 0xffff);\n        accumulation += ipv4.getProtocol() & 0xff;\n        accumulation += length & 0xffff;\n      }\n\n      for (int i = 0; i < length / 2; ++i) {\n        accumulation += 0xffff & bb.getShort();\n      }\n      // pad to an even number of shorts\n      if (length % 2 > 0) {\n        accumulation += (bb.get() & 0xff) << 8;\n      }\n\n      accumulation = ((accumulation >> 16) & 0xffff) + (accumulation & 0xffff);\n      this.checksum = (short) (~accumulation & 0xffff);\n      bb.putShort(16, this.checksum);\n    }\n    return data;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 877, "initialization": ["ByteBuffer byteBuffer = wrap(byte[])", "ByteBuffer byteBuffer = allocateDirect(int)"], "initializationStart": [133, 279], "initializationEnd": [155, 307], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.position()", "byteBuffer.put(byte[])", "byteBuffer.position(int)", "byteBuffer.remaining()", "byteBuffer.position()", "byteBuffer.mark()"], "configurationStart": [255, 313, 331, 405, 441, 489], "configurationEnd": [267, 325, 344, 418, 453, 497], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 503, "focalAPIEnd": 510, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["copyBinary(byteBuffer)", "byteBuffer.position()", "byteBuffer.reset()", "byteBuffer.position()"], "useStart": [524, 626, 645, 676], "useEnd": [549, 638, 654, 688], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tripadvisor/ta-thrift/tree/master/lib/java/test/org/apache/thrift/TestTBaseHelper.java", "rawCode": "  public void testCopyBinaryWithByteBuffer() throws Exception {\n    byte[] bytes = new byte[] {0, 1, 2, 3, 4, 5};\n    ByteBuffer b = ByteBuffer.wrap(bytes);\n    ByteBuffer bCopy = TBaseHelper.copyBinary(b);\n    assertEquals(b, bCopy);\n    assertEquals(0, b.position());\n\n    b = ByteBuffer.allocateDirect(6);\n    b.put(bytes);\n    b.position(0);\n    bCopy = TBaseHelper.copyBinary(b);\n    assertEquals(6, b.remaining());\n    assertEquals(0, b.position());\n    assertEquals(b, bCopy);\n\n    b.mark();\n    b.get();\n    bCopy = TBaseHelper.copyBinary(b);\n    assertEquals(ByteBuffer.wrap(bytes, 1, 5), bCopy);\n    assertEquals(1, b.position());\n    b.reset();\n    assertEquals(0, b.position());\n\n    assertNull(TBaseHelper.copyBinary((ByteBuffer) null));\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 878, "initialization": ["ByteBuffer byteBuffer = createByteBuffer(*)"], "initializationStart": [4700], "initializationEnd": [4744], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte[])"], "configurationStart": [4750], "configurationEnd": [4770], "guardCondition": "index<texWidth*perPixel", "guardType": "LOOP {", "guardExpressionStart": 4974, "guardExpressionEnd": 5019, "guardBlockStart": 4974, "guardBlockEnd": 5197, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 5057, "focalAPIEnd": 5071, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.flip()"], "useStart": [5030, 5149, 5082, 5426, 5335, 5576, 5481, 5679], "useEnd": [5072, 5187, 5188, 5468, 5469, 5647, 5648, 5693], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/marcelleguine/war-game-of-thrones/tree/master/projeto/War Game of Thrones/lib/slick/src/org/newdawn/slick/opengl/TGAImageData.java", "rawCode": "  /**\n   * @see org.newdawn.slick.opengl.LoadableImageData#loadImage(java.io.InputStream, boolean,\n   *     boolean, int[])\n   */\n  public ByteBuffer loadImage(\n      InputStream fis, boolean flipped, boolean forceAlpha, int[] transparent) throws IOException {\n    if (transparent != null) {\n      forceAlpha = true;\n    }\n    byte red = 0;\n    byte green = 0;\n    byte blue = 0;\n    byte alpha = 0;\n\n    BufferedInputStream bis = new BufferedInputStream(fis, 100000);\n    DataInputStream dis = new DataInputStream(bis);\n\n    // Read in the Header\n    short idLength = (short) dis.read();\n    short colorMapType = (short) dis.read();\n    short imageType = (short) dis.read();\n    short cMapStart = flipEndian(dis.readShort());\n    short cMapLength = flipEndian(dis.readShort());\n    short cMapDepth = (short) dis.read();\n    short xOffset = flipEndian(dis.readShort());\n    short yOffset = flipEndian(dis.readShort());\n\n    width = flipEndian(dis.readShort());\n    height = flipEndian(dis.readShort());\n    pixelDepth = (short) dis.read();\n    if (pixelDepth == 32) {\n      forceAlpha = false;\n    }\n\n    texWidth = get2Fold(width);\n    texHeight = get2Fold(height);\n\n    short imageDescriptor = (short) dis.read();\n    if ((imageDescriptor & 0x0020) == 0) {\n      flipped = !flipped;\n    }\n\n    // Skip image ID\n    if (idLength > 0) {\n      bis.skip(idLength);\n    }\n\n    byte[] rawData = null;\n    if ((pixelDepth == 32) || (forceAlpha)) {\n      pixelDepth = 32;\n      rawData = new byte[texWidth * texHeight * 4];\n    } else if (pixelDepth == 24) {\n      rawData = new byte[texWidth * texHeight * 3];\n    } else {\n      throw new RuntimeException(\"Only 24 and 32 bit TGAs are supported\");\n    }\n\n    if (pixelDepth == 24) {\n      if (flipped) {\n        for (int i = height - 1; i >= 0; i--) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n\n            int ofs = ((j + (i * texWidth)) * 3);\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n          }\n        }\n      } else {\n        for (int i = 0; i < height; i++) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n\n            int ofs = ((j + (i * texWidth)) * 3);\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n          }\n        }\n      }\n    } else if (pixelDepth == 32) {\n      if (flipped) {\n        for (int i = height - 1; i >= 0; i--) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n            if (forceAlpha) {\n              alpha = (byte) 255;\n            } else {\n              alpha = dis.readByte();\n            }\n\n            int ofs = ((j + (i * texWidth)) * 4);\n\n            rawData[ofs] = red;\n            rawData[ofs + 1] = green;\n            rawData[ofs + 2] = blue;\n            rawData[ofs + 3] = alpha;\n\n            if (alpha == 0) {\n              rawData[ofs + 2] = (byte) 0;\n              rawData[ofs + 1] = (byte) 0;\n              rawData[ofs] = (byte) 0;\n            }\n          }\n        }\n      } else {\n        for (int i = 0; i < height; i++) {\n          for (int j = 0; j < width; j++) {\n            blue = dis.readByte();\n            green = dis.readByte();\n            red = dis.readByte();\n            if (forceAlpha) {\n              alpha = (byte) 255;\n            } else {\n              alpha = dis.readByte();\n            }\n\n            int ofs = ((j + (i * texWidth)) * 4);\n\n            if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) {\n              rawData[ofs] = red;\n              rawData[ofs + 1] = green;\n              rawData[ofs + 2] = blue;\n              rawData[ofs + 3] = alpha;\n            } else {\n              rawData[ofs] = red;\n              rawData[ofs + 1] = green;\n              rawData[ofs + 2] = blue;\n              rawData[ofs + 3] = alpha;\n            }\n\n            if (alpha == 0) {\n              rawData[ofs + 2] = 0;\n              rawData[ofs + 1] = 0;\n              rawData[ofs] = 0;\n            }\n          }\n        }\n      }\n    }\n    fis.close();\n\n    if (transparent != null) {\n      for (int i = 0; i < rawData.length; i += 4) {\n        boolean match = true;\n        for (int c = 0; c < 3; c++) {\n          if (rawData[i + c] != transparent[c]) {\n            match = false;\n          }\n        }\n\n        if (match) {\n          rawData[i + 3] = 0;\n        }\n      }\n    }\n\n    // Get a pointer to the image memory\n    ByteBuffer scratch = BufferUtils.createByteBuffer(rawData.length);\n    scratch.put(rawData);\n\n    int perPixel = pixelDepth / 8;\n    if (height < texHeight - 1) {\n      int topOffset = (texHeight - 1) * (texWidth * perPixel);\n      int bottomOffset = (height - 1) * (texWidth * perPixel);\n      for (int x = 0; x < texWidth * perPixel; x++) {\n        scratch.put(topOffset + x, scratch.get(x));\n        scratch.put(\n            bottomOffset + (texWidth * perPixel) + x, scratch.get((texWidth * perPixel) + x));\n      }\n    }\n    if (width < texWidth - 1) {\n      for (int y = 0; y < texHeight; y++) {\n        for (int i = 0; i < perPixel; i++) {\n          scratch.put(\n              ((y + 1) * (texWidth * perPixel)) - perPixel + i,\n              scratch.get(y * (texWidth * perPixel) + i));\n          scratch.put(\n              (y * (texWidth * perPixel)) + (width * perPixel) + i,\n              scratch.get((y * (texWidth * perPixel)) + ((width - 1) * perPixel) + i));\n        }\n      }\n    }\n\n    scratch.flip();\n\n    return scratch;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 879, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [69], "initializationEnd": [91], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte[])", "byteBuffer.flip()"], "configurationStart": [97, 116], "configurationEnd": [110, 126], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 139, "focalAPIEnd": 148, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Juliens/red5/tree/master/src/test/java/org/red5/io/mp4/impl/MP4ReaderTest.java", "rawCode": "  public static byte bytesToByte(byte[] data) {\n    ByteBuffer buf = ByteBuffer.allocate(1);\n    buf.put(data);\n    buf.flip();\n    return buf.get();\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 880, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 1374, "focalAPIEnd": 1396, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["StreamSinkConduit.resumeWrites()"], "finallyExpressionStart": 3326, "finallyExpressionEnd": 3334, "finallyBlockStart": 3326, "finallyBlockEnd": 3655, "cleanUpCallStart": [3481], "cleanUpCallEnd": [3500], "url": "https://github.com/undertow-io/undertow/tree/master/core/src/main/java/io/undertow/conduits/DeflatingStreamSinkConduit.java", "rawCode": "  @Override\n  public boolean flush() throws IOException {\n    if (currentBuffer == null) {\n      if (anyAreSet(state, NEXT_SHUTDOWN)) {\n        return next.flush();\n      } else {\n        return true;\n      }\n    }\n    try {\n      boolean nextCreated = false;\n      try {\n        if (anyAreSet(state, SHUTDOWN)) {\n          if (anyAreSet(state, NEXT_SHUTDOWN)) {\n            return next.flush();\n          } else {\n            if (!performFlushIfRequired()) {\n              return false;\n            }\n            // if the deflater has not been fully flushed we need to flush it\n            if (!deflater.finished()) {\n              deflateData(false);\n              // if could not fully flush\n              if (!deflater.finished()) {\n                return false;\n              }\n            }\n            final ByteBuffer buffer = currentBuffer.getBuffer();\n            if (allAreClear(state, WRITTEN_TRAILER)) {\n              state |= WRITTEN_TRAILER;\n              byte[] data = getTrailer();\n              if (data != null) {\n                Connectors.updateResponseBytesSent(exchange, data.length);\n                if (additionalBuffer != null) {\n                  byte[] newData = new byte[additionalBuffer.remaining() + data.length];\n                  int pos = 0;\n                  while (additionalBuffer.hasRemaining()) {\n                    newData[pos++] = additionalBuffer.get();\n                  }\n                  for (byte aData : data) {\n                    newData[pos++] = aData;\n                  }\n                  this.additionalBuffer = ByteBuffer.wrap(newData);\n                } else if (anyAreSet(state, FLUSHING_BUFFER)\n                    && buffer.capacity() - buffer.remaining() >= data.length) {\n                  buffer.compact();\n                  buffer.put(data);\n                  buffer.flip();\n                } else if (data.length <= buffer.remaining()\n                    && !anyAreSet(state, FLUSHING_BUFFER)) {\n                  buffer.put(data);\n                } else {\n                  additionalBuffer = ByteBuffer.wrap(data);\n                }\n              }\n            }\n\n            // ok the deflater is flushed, now we need to flush the buffer\n            if (!anyAreSet(state, FLUSHING_BUFFER)) {\n              buffer.flip();\n              state |= FLUSHING_BUFFER;\n              if (next == null) {\n                nextCreated = true;\n                this.next = createNextChannel();\n              }\n            }\n            if (performFlushIfRequired()) {\n              state |= NEXT_SHUTDOWN;\n              freeBuffer();\n              next.terminateWrites();\n              return next.flush();\n            } else {\n              return false;\n            }\n          }\n        } else {\n          if (allAreClear(state, FLUSHING_BUFFER)) {\n            if (next == null) {\n              nextCreated = true;\n              this.next = createNextChannel();\n            }\n            deflateData(true);\n            if (allAreClear(state, FLUSHING_BUFFER)) {\n              // deflateData can cause this to be change\n              currentBuffer.getBuffer().flip();\n              this.state |= FLUSHING_BUFFER;\n            }\n          }\n          if (!performFlushIfRequired()) {\n            return false;\n          }\n          return next.flush();\n        }\n      } finally {\n        if (nextCreated) {\n          if (anyAreSet(state, WRITES_RESUMED) && !anyAreSet(state, NEXT_SHUTDOWN)) {\n            try {\n              next.resumeWrites();\n            } catch (Throwable e) {\n              UndertowLogger.REQUEST_LOGGER.debug(\"Failed to resume\", e);\n            }\n          }\n        }\n      }\n    } catch (IOException | RuntimeException | Error e) {\n      freeBuffer();\n      throw e;\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 881, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 1739, "focalAPIEnd": 1747, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.putFloat(value)"], "useStart": [1712], "useEnd": [1748], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chototsu/MikuMikuStudio/tree/master/engine/src/mmd/projectkyoto/jme3/mmd/GeometryOptimizer.java", "rawCode": "  public void optimize() {\n    calcInterleavedSize();\n    interleavedBuffer = BufferUtil.createByteBuffer(interleavedSize);\n    // interleavedBuffer = ByteBuffer.allocateDirect(interleavedSize);\n    // interleavedBuffer.order(ByteOrder.nativeOrder());\n    VertexBuffer allData = new VertexBuffer(VertexBuffer.Type.InterleavedData);\n    // ByteBuffer dataBuf = BufferUtils.createByteBuffer(stride * getVertexCount());\n    allData.setupData(\n        VertexBuffer.Usage.Static, 1, VertexBuffer.Format.UnsignedByte, interleavedBuffer);\n    int offset = 0;\n    for (Mesh mesh : meshSet) {\n      int stride = 0;\n      for (VertexBuffer vb : mesh.getBufferList()) {\n        if (vb.getBufferType().equals(VertexBuffer.Type.Index)\n            || vb.getBufferType().equals(VertexBuffer.Type.InterleavedData)) {\n          continue;\n        }\n        vb.getData().clear();\n        vb.setOffset(offset + stride);\n        stride += vb.getComponentsLength();\n      }\n      for (VertexBuffer vb : mesh.getBufferList()) {\n        if (vb.getBufferType().equals(VertexBuffer.Type.Index)\n            || vb.getBufferType().equals(VertexBuffer.Type.InterleavedData)) {\n          continue;\n        }\n        vb.setStride(stride);\n      }\n      for (int i = 0; i < mesh.getVertexCount(); i++)\n        for (VertexBuffer vb : mesh.getBufferList()) {\n          if (vb.getBufferType().equals(VertexBuffer.Type.Index)\n              || vb.getBufferType().equals(VertexBuffer.Type.InterleavedData)) {\n            continue;\n          }\n          switch (vb.getFormat()) {\n            case Float:\n              FloatBuffer fb = (FloatBuffer) vb.getData();\n              for (int comp = 0; comp < vb.getNumComponents(); comp++) {\n                interleavedBuffer.putFloat(fb.get());\n              }\n              break;\n            case Byte:\n            case UnsignedByte:\n              ByteBuffer bb = (ByteBuffer) vb.getData();\n              for (int comp = 0; comp < vb.getNumComponents(); comp++) {\n                interleavedBuffer.put(bb.get());\n              }\n              break;\n            case Half:\n            case Short:\n            case UnsignedShort:\n              ShortBuffer sb = (ShortBuffer) vb.getData();\n              for (int comp = 0; comp < vb.getNumComponents(); comp++) {\n                interleavedBuffer.putShort(sb.get());\n              }\n              break;\n            case Int:\n            case UnsignedInt:\n              IntBuffer ib = (IntBuffer) vb.getData();\n              for (int comp = 0; comp < vb.getNumComponents(); comp++) {\n                interleavedBuffer.putInt(ib.get());\n              }\n              break;\n            case Double:\n              DoubleBuffer db = (DoubleBuffer) vb.getData();\n              for (int comp = 0; comp < vb.getNumComponents(); comp++) {\n                interleavedBuffer.putDouble(db.get());\n              }\n              break;\n          }\n        }\n      // mesh.setBuffer(allData);\n      offset = interleavedBuffer.position();\n      for (VertexBuffer vb : mesh.getBufferList()) {\n        if (vb.getBufferType().equals(VertexBuffer.Type.Index)\n            || vb.getBufferType().equals(VertexBuffer.Type.InterleavedData)) {\n          continue;\n        }\n        // System.out.println(\n        // \"type = \"+vb.getBufferType()\n        // + \"stride = \"+vb.getStride()\n        // + \"offset \"+vb.getOffset()\n        // );\n        vb.updateData(null);\n      }\n      // System.out.println(\"done\");\n      // optimize2();\n      // VertexBuffer allData2 = mesh.getBuffer(VertexBuffer.Type.InterleavedData);\n      // ByteBuffer bb = (ByteBuffer)allData2.getData();\n      // for(int i=0;i<allData.getData().capacity();i++) {\n      // System.out.printf(\"%d %x %x \", i, bb.get(i), interleavedBuffer.get(i));\n      // System.out.println();\n      // }\n      mesh.setBuffer(allData);\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 882, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.position()", "byteBuffer.position(int)"], "configurationStart": [298, 327], "configurationEnd": [319, 354], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 405, "guardExpressionEnd": 461, "guardBlockStart": 405, "guardBlockEnd": 507, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 481, "focalAPIEnd": 497, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)", "byteBuffer.position(int)"], "useStart": [472, 763], "useEnd": [498, 787], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/disy/jSCSI/tree/master/bundles/commons/src/main/java/org/jscsi/parser/datasegment/AbstractDataSegment.java", "rawCode": "    /** {@inheritDoc} */\n    public final IDataSegmentChunk next(final int chunkSize) {\n\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n\n      if (chunkSize < 0 && chunkSize > maxChunkSize) {\n        throw new IllegalArgumentException();\n      }\n\n      final int pos = dataBuffer.position();\n      dataBuffer.position(cursor);\n\n      data.position(0).limit(chunkSize);\n\n      while (data.hasRemaining() && dataBuffer.hasRemaining()) {\n        data.put(dataBuffer.get());\n      }\n\n      final int dataSegmentLength = data.position();\n      final int totalLength = dataSegmentLength + calcPadding(dataSegmentLength);\n\n      // set limit to the next nearest bound (with padding)\n      data.limit(totalLength);\n      data.rewind();\n      dataBuffer.position(pos);\n\n      // cursor += chunkSize;\n      cursor += totalLength;\n\n      return new DataSegmentChunk(dataSegmentLength, totalLength);\n    }\n"}, {"dataset": "byteBufferGet", "exampleID": 883, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta12/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 884, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/SAK-16693/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 885, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<buf.capacity()", "guardType": "LOOP {", "guardExpressionStart": 424, "guardExpressionEnd": 464, "guardBlockStart": 424, "guardBlockEnd": 647, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 601, "focalAPIEnd": 611, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/nio/src/test/java/org/apache/harmony/nio/tests/java/nio/ByteBufferTest.java", "rawCode": "  @TestTargetNew(\n    level = TestLevel.PARTIAL_COMPLETE,\n    notes = \"\",\n    method = \"put\",\n    args = {byte[].class}\n  )\n  public void testPutbyteArray() {\n    byte array[] = new byte[1];\n    if (buf.isReadOnly()) {\n      try {\n        buf.put(array);\n        fail(\"Should throw Exception\"); // $NON-NLS-1$\n      } catch (ReadOnlyBufferException e) {\n        // expected\n      }\n      return;\n    }\n\n    buf.clear();\n    for (int i = 0; i < buf.capacity(); i++) {\n      assertEquals(i, buf.position());\n      array[0] = (byte) i;\n      ByteBuffer ret = buf.put(array);\n      assertEquals((byte) i, buf.get(i));\n      assertSame(ret, buf);\n    }\n    try {\n      buf.put(array);\n      fail(\"Should throw Exception\"); // $NON-NLS-1$\n    } catch (BufferOverflowException e) {\n      // expected\n    }\n    try {\n      buf.put((byte[]) null);\n      fail(\"Should throw Exception\"); // $NON-NLS-1$\n    } catch (NullPointerException e) {\n      // expected\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 886, "initialization": ["ByteBuffer byteBuffer = createByteBuffer(*)"], "initializationStart": [618], "initializationEnd": [679], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<texWidth*perPixel", "guardType": "LOOP {", "guardExpressionStart": 899, "guardExpressionEnd": 944, "guardBlockStart": 899, "guardBlockEnd": 1122, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 982, "focalAPIEnd": 996, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.get(int)", "byteBuffer.get(byte[])", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.position(int)"], "useStart": [955, 1074, 1007, 1351, 1260, 1501, 1406, 1951, 2010, 2073, 2556, 2615], "useEnd": [997, 1112, 1113, 1393, 1394, 1572, 1573, 1973, 2036, 2099, 2584, 2634], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fisherevans/LRK/tree/master/src/org/newdawn/slick/opengl/PNGImageData.java", "rawCode": "  /**\n   * @see org.newdawn.slick.opengl.LoadableImageData#loadImage(java.io.InputStream, boolean,\n   *     boolean, int[])\n   */\n  public ByteBuffer loadImage(\n      InputStream fis, boolean flipped, boolean forceAlpha, int[] transparent) throws IOException {\n    if (transparent != null) {\n      forceAlpha = true;\n    }\n\n    init(fis);\n\n    if (!isRGB()) {\n      throw new IOException(\"Only RGB formatted images are supported by the PNGLoader\");\n    }\n\n    texWidth = get2Fold(width);\n    texHeight = get2Fold(height);\n\n    int perPixel = hasAlpha() ? 4 : 3;\n\n    // Get a pointer to the image memory\n    scratch = BufferUtils.createByteBuffer(texWidth * texHeight * perPixel);\n    decode(scratch, texWidth * perPixel, flipped);\n\n    if (height < texHeight - 1) {\n      int topOffset = (texHeight - 1) * (texWidth * perPixel);\n      int bottomOffset = (height - 1) * (texWidth * perPixel);\n      for (int x = 0; x < texWidth * perPixel; x++) {\n        scratch.put(topOffset + x, scratch.get(x));\n        scratch.put(\n            bottomOffset + (texWidth * perPixel) + x, scratch.get((texWidth * perPixel) + x));\n      }\n    }\n    if (width < texWidth - 1) {\n      for (int y = 0; y < texHeight; y++) {\n        for (int i = 0; i < perPixel; i++) {\n          scratch.put(\n              ((y + 1) * (texWidth * perPixel)) - perPixel + i,\n              scratch.get(y * (texWidth * perPixel) + i));\n          scratch.put(\n              (y * (texWidth * perPixel)) + (width * perPixel) + i,\n              scratch.get((y * (texWidth * perPixel)) + ((width - 1) * perPixel) + i));\n        }\n      }\n    }\n\n    if (!hasAlpha() && forceAlpha) {\n      ByteBuffer temp = BufferUtils.createByteBuffer(texWidth * texHeight * 4);\n      for (int x = 0; x < texWidth; x++) {\n        for (int y = 0; y < texHeight; y++) {\n          int srcOffset = (y * 3) + (x * texHeight * 3);\n          int dstOffset = (y * 4) + (x * texHeight * 4);\n\n          temp.put(dstOffset, scratch.get(srcOffset));\n          temp.put(dstOffset + 1, scratch.get(srcOffset + 1));\n          temp.put(dstOffset + 2, scratch.get(srcOffset + 2));\n          temp.put(dstOffset + 3, (byte) 255);\n        }\n      }\n\n      colorType = COLOR_TRUEALPHA;\n      bitDepth = 32;\n      scratch = temp;\n    }\n\n    if (transparent != null) {\n      for (int i = 0; i < texWidth * texHeight * 4; i += 4) {\n        boolean match = true;\n        for (int c = 0; c < 3; c++) {\n          if (toInt(scratch.get(i + c)) != transparent[c]) {\n            match = false;\n          }\n        }\n\n        if (match) {\n          scratch.put(i + 3, (byte) 0);\n        }\n      }\n    }\n\n    scratch.position(0);\n\n    return scratch;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 887, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 185, "focalAPIEnd": 198, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hashio/websocket-client/tree/master/src/main/java/jp/a840/websocket/handler/MaskFrameStreamHandler.java", "rawCode": "  @Override\n  public void nextUpstreamHandler(\n      WebSocket ws, ByteBuffer buffer, Frame frame, StreamHandlerChain chain)\n      throws WebSocketException {\n    buffer.put(1, (byte) (buffer.get(1) | 0x80)); // force set mask bit;\n    int maskkeyOffset = 2;\n    if (buffer.get(buffer.position() + 1) == (byte) 0xFE) {\n      maskkeyOffset = 4;\n    } else if (buffer.get(buffer.position() + 1) == 0xFF) {\n      maskkeyOffset = 10;\n    }\n\n    // avoid copy buffer\n    // buffer already reserved mask key field in FrameRfc6455\n    ByteBuffer buf = ByteBuffer.wrap(buffer.array());\n    int limit = buffer.limit();\n    buffer.limit(buffer.position() + maskkeyOffset);\n    buf.put(buffer);\n    buffer.limit(limit);\n    buf.putInt(random.nextInt());\n\n    byte[] maskkey = new byte[4];\n    buf.position(maskkeyOffset);\n    buf.get(maskkey, 0, 4);\n    int m = 0;\n    while (buf.hasRemaining()) {\n      int position = buf.position();\n      buf.put((byte) (buf.get(position) ^ maskkey[m++ % 4]));\n    }\n    buf.flip();\n    chain.nextUpstreamHandler(ws, buf, frame);\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 888, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 54, "guardExpressionEnd": 85, "guardBlockStart": 54, "guardBlockEnd": 1824, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 104, "focalAPIEnd": 118, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["readVarInt(byteBuffer)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.array()", "readVarInt(byteBuffer)", "readVarLong(byteBuffer)", "readVarInt(byteBuffer)", "readVarLong(byteBuffer)", "ByteBuffer.put(byteBuffer)", "byteBuffer.array()"], "useStart": [178, 306, 288, 405, 490, 562, 657, 714, 1102, 1159, 1515, 1787], "useEnd": [208, 325, 332, 424, 514, 578, 687, 745, 1132, 1190, 1538, 1803], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chris-martin/h2/tree/master/h2/src/main/org/h2/mvstore/StreamStore.java", "rawCode": "    private ByteArrayInputStream nextBuffer() {\n      while (idBuffer.hasRemaining()) {\n        switch (idBuffer.get()) {\n          case 0:\n            {\n              int len = DataUtils.readVarInt(idBuffer);\n              if (skip >= len) {\n                skip -= len;\n                idBuffer.position(idBuffer.position() + len);\n                continue;\n              }\n              int p = (int) (idBuffer.position() + skip);\n              int l = (int) (len - skip);\n              idBuffer.position(p + l);\n              return new ByteArrayInputStream(idBuffer.array(), p, l);\n            }\n          case 1:\n            {\n              int len = DataUtils.readVarInt(idBuffer);\n              long key = DataUtils.readVarLong(idBuffer);\n              if (skip >= len) {\n                skip -= len;\n                continue;\n              }\n              byte[] data = store.getBlock(key);\n              int s = (int) skip;\n              skip = 0;\n              return new ByteArrayInputStream(data, s, data.length - s);\n            }\n          case 2:\n            {\n              long len = DataUtils.readVarInt(idBuffer);\n              long key = DataUtils.readVarLong(idBuffer);\n              if (skip >= len) {\n                skip -= len;\n                continue;\n              }\n              byte[] k = store.getBlock(key);\n              ByteBuffer newBuffer =\n                  ByteBuffer.allocate(k.length + idBuffer.limit() - idBuffer.position());\n              newBuffer.put(k);\n              newBuffer.put(idBuffer);\n              newBuffer.flip();\n              idBuffer = newBuffer;\n              return nextBuffer();\n            }\n          default:\n            throw DataUtils.newIllegalArgumentException(\n                \"Unsupported id {0}\", Arrays.toString(idBuffer.array()));\n        }\n      }\n      return null;\n    }\n"}, {"dataset": "byteBufferGet", "exampleID": 889, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 1401, "focalAPIEnd": 1415, "followUpCheck": "value > 3", "checkType": "IF", "followUpCheckExpressionStart": 1697, "followUpCheckExpressionEnd": 1712, "followUpCheckBlockStart": 1697, "followUpCheckBlockEnd": 2061, "use": ["createByteBuffer(value)", "glGetShaderInfoLog(int,*,byteBuffer,ByteBuffer)", "ByteBuffer.get(byte[],int,value)"], "useStart": [1768, 1816, 1941], "useEnd": [1804, 1883, 1972], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chototsu/MikuMikuStudio/tree/master/engine/src/jogl2/com/jme3/renderer/jogl/JoglRenderer.java", "rawCode": "  public void updateShaderSourceData(ShaderSource source, String language) {\n    if (glslVer != -1) {\n      GL gl = GLContext.getCurrentGL();\n      int id = source.getId();\n      if (id == -1) {\n        // create id\n        id = gl.getGL2().glCreateShader(convertShaderType(source.getType()));\n        if (id <= 0) {\n          throw new RendererException(\"Invalid ID received when trying to create shader.\");\n        }\n\n        source.setId(id);\n      }\n\n      // upload shader source\n      // merge the defines and source code\n      byte[] versionData = new byte[] {}; // \"#version 140\\n\".getBytes();\n      // versionData = \"#define INSTANCING 1\\n\".getBytes();\n      byte[] definesCodeData = source.getDefines().getBytes();\n      byte[] sourceCodeData = source.getSource().getBytes();\n      ByteBuffer codeBuf =\n          BufferUtils.createByteBuffer(\n              versionData.length + definesCodeData.length + sourceCodeData.length);\n      codeBuf.put(versionData);\n      codeBuf.put(definesCodeData);\n      codeBuf.put(sourceCodeData);\n      codeBuf.flip();\n\n      final byte[] array = new byte[codeBuf.limit()];\n      codeBuf.get(array);\n      gl.getGL2()\n          .glShaderSourceARB(id, 1, new String[] {new String(array)}, new int[] {array.length}, 0);\n      gl.getGL2().glCompileShader(id);\n\n      gl.getGL2().glGetShaderiv(id, GL2ES2.GL_COMPILE_STATUS, intBuf1);\n\n      boolean compiledOK = intBuf1.get(0) == GL.GL_TRUE;\n      String infoLog = null;\n\n      if (VALIDATE_SHADER || !compiledOK) {\n        // even if compile succeeded, check\n        // log for warnings\n        gl.getGL2().glGetShaderiv(id, GL2ES2.GL_INFO_LOG_LENGTH, intBuf1);\n        int length = intBuf1.get(0);\n        if (length > 3) {\n          // get infos\n          ByteBuffer logBuf = BufferUtils.createByteBuffer(length);\n          gl.getGL2().glGetShaderInfoLog(id, logBuf.limit(), intBuf1, logBuf);\n          byte[] logBytes = new byte[length];\n          logBuf.get(logBytes, 0, length);\n          // convert to string, etc\n          infoLog = new String(logBytes);\n        }\n      }\n\n      if (compiledOK) {\n        if (infoLog != null) {\n          logger.log(\n              Level.INFO, \"{0} compile success\\n{1}\", new Object[] {source.getName(), infoLog});\n        } else {\n          logger.log(Level.FINE, \"{0} compile success\", source.getName());\n        }\n      } else {\n        if (infoLog != null) {\n          logger.log(\n              Level.WARNING, \"{0} compile error: {1}\", new Object[] {source.getName(), infoLog});\n        } else {\n          logger.log(Level.WARNING, \"{0} compile error: ?\", source.getName());\n        }\n        logger.log(Level.WARNING, \"{0}{1}\", new Object[] {source.getDefines(), source.getSource()});\n      }\n\n      source.clearUpdateNeeded();\n      // only usable if compiled\n      source.setUsable(compiledOK);\n      if (!compiledOK) {\n        // make sure to dispose id cause all program's\n        // shaders will be cleared later.\n        gl.getGL2().glDeleteShader(id);\n      } else {\n        // register for cleanup since the ID is usable\n        objManager.registerForCleanup(source);\n      }\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 890, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/SAK-8908/kernel-test/content/src/main/java/org/sakaiproject/content/test/ContentIntegrationTest.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 891, "initialization": ["ByteBuffer byteBuffer = wrap(byte[])"], "initializationStart": [498], "initializationEnd": [526], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.order(ByteOrder)", "byteBuffer.asShortBuffer()"], "configurationStart": [532, 674], "configurationEnd": [563, 693], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 749, "focalAPIEnd": 764, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [952], "useEnd": [963], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dlangdon/ToTameTheVoid-java/tree/master/lib/slick/src/org/newdawn/slick/openal/AiffData.java", "rawCode": "  /**\n   * Convert the audio bytes into the stream\n   *\n   * @param format The audio format being decoded\n   * @param audio_bytes The audio byts\n   * @param two_bytes_data True if we using double byte data\n   * @return The byte bufer of data\n   */\n  private static ByteBuffer convertAudioBytes(\n      AudioFormat format, byte[] audio_bytes, boolean two_bytes_data) {\n    ByteBuffer dest = ByteBuffer.allocateDirect(audio_bytes.length);\n    dest.order(ByteOrder.nativeOrder());\n    ByteBuffer src = ByteBuffer.wrap(audio_bytes);\n    src.order(ByteOrder.BIG_ENDIAN);\n    if (two_bytes_data) {\n      ShortBuffer dest_short = dest.asShortBuffer();\n      ShortBuffer src_short = src.asShortBuffer();\n      while (src_short.hasRemaining()) dest_short.put(src_short.get());\n    } else {\n      while (src.hasRemaining()) {\n        byte b = src.get();\n        if (format.getEncoding() == Encoding.PCM_SIGNED) {\n          b = (byte) (b + 127);\n        }\n        dest.put(b);\n      }\n    }\n    dest.rewind();\n    return dest;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 892, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 564, "focalAPIEnd": 580, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(byte,value)"], "useStart": [538], "useEnd": [581], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kragen/waterken-server/tree/master/waterken/k2v/src/org/k2v/trie/Trie.java", "rawCode": "      public ByteBuffer readNext() throws IOException {\n        if (closed) {\n          throw new IOException();\n        }\n        while (true) {\n          if (stack.isEmpty()) {\n            throw new NoSuchElementException();\n          }\n          final Node node = stack.get(stack.size() - 1);\n          if (!node.branches.hasRemaining()) {\n            stack.remove(stack.size() - 1);\n            continue;\n          }\n          rwkey.limit(node.depth);\n          rokey.limit(rwkey.limit());\n          if (node.depth > 0) {\n            rwkey.put(node.depth - 1, node.heads.get());\n          }\n          long ref = node.branches.getLong();\n          while (true) {\n            type = type(ref);\n            at = data(ref);\n            if (!isARun(type)) {\n              break;\n            }\n            final int length = lengthOfRun(type);\n            final int size = sizeOfRun(length);\n            final ByteBuffer run = read(size, at);\n            ref = value(run, RunBranch);\n            if (rwkey.limit() + length > rwkey.capacity()) {\n              rwkey = ByteBuffer.allocate(2 * (rwkey.limit() + length)).put(rwkey);\n              rokey = rwkey.asReadOnlyBuffer();\n            }\n            rwkey.limit(rwkey.limit() + length);\n            rokey.limit(rwkey.limit());\n            run.rewind().limit(length);\n            rwkey.put(run);\n          }\n          if (isAMap(type)) {\n            if (rwkey.limit() == rwkey.capacity()) {\n              rwkey = ByteBuffer.allocate(2 * (rwkey.limit() + 1)).put(rwkey);\n              rokey = rwkey.asReadOnlyBuffer();\n            }\n            final int arity = arityOfMap(type);\n            final int size = sizeOfMap(arity);\n            final ByteBuffer map = read(size, at);\n            stack.add(\n                new Node(\n                    rwkey.limit() + 1,\n                    listMap(map, arity),\n                    (ByteBuffer) ByteBuffer.allocate(map.remaining()).put(map).rewind()));\n          } else if (TypeOfLeaf == type) {\n            final ByteBuffer leaf = read(SizeOfLeaf, at);\n            final long child = value(leaf, LeafChild);\n            type = type(child);\n            at = data(child);\n            final int depth = rwkey.limit();\n            stack.add(\n                new Node(\n                    depth,\n                    0 == depth ? null : ByteBuffer.allocate(1).put(0, rwkey.get(depth - 1)),\n                    ByteBuffer.allocate(8).putLong(0, value(leaf, LeafBranch))));\n            rokey.rewind();\n            return rokey;\n          } else {\n            rokey.rewind();\n            return rokey;\n          }\n        }\n      }\n"}, {"dataset": "byteBufferGet", "exampleID": 893, "initialization": ["ByteBuffer byteBuffer = allocateDirect(*)"], "initializationStart": [436], "initializationEnd": [481], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.clear()", "byteBuffer.position(int)"], "configurationStart": [493, 903], "configurationEnd": [517, 931], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 999, "focalAPIEnd": 1021, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.get()", "byteBuffer.get()", "byteBuffer.position(int)", "byteBuffer.put(byte)", "byteBuffer.put(byte)", "byteBuffer.put(byte)", "new PngEncoder(byteBuffer,boolean,*,int,int,int)"], "useStart": [1040, 1081, 1113, 1155, 1188, 1221, 1287], "useEnd": [1062, 1103, 1145, 1178, 1211, 1244, 1368], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/maesse/CubeTech/tree/master/src/cubetech/client/ClientRender.java", "rawCode": "  private void takeScreenshot() {\n    screenshot = false;\n\n    // Are we taking pictures of a demo?\n    boolean video = (Ref.client.demo.isPlaying() && Ref.cvars.Find(\"cl_demorecord\").isTrue());\n\n    int width = (int) Ref.glRef.GetResolution().x;\n    int height = (int) Ref.glRef.GetResolution().y;\n\n    // Copy backbuffer\n    if (screenshotBuffer == null || screenshotBuffer.capacity() < 3 * width * height) {\n      screenshotBuffer = ByteBuffer.allocateDirect(3 * width * height);\n    }\n    screenshotBuffer.clear();\n    GL11.glReadPixels(0, 0, width, height, GL12.GL_BGR, GL11.GL_UNSIGNED_BYTE, screenshotBuffer);\n\n    byte[] encData = null;\n    if (video) {\n      // Bmp for speed\n      BMPWriter enc = new BMPWriter(screenshotBuffer, width, height);\n      encData = enc.encodeImage();\n      writeVideoFrame(encData);\n    } else {\n      // Encode as png\n      // Change format from bgr to rgb\n      screenshotBuffer.position(0);\n      for (int i = 0; i < width * height; i++) {\n        byte b = screenshotBuffer.get();\n        byte g = screenshotBuffer.get();\n        byte r = screenshotBuffer.get();\n        screenshotBuffer.position(i * 3);\n        screenshotBuffer.put(r);\n        screenshotBuffer.put(g);\n        screenshotBuffer.put(b);\n      }\n      PngEncoder enc =\n          new PngEncoder(screenshotBuffer, false, PngEncoder.FILTER_NONE, 3, width, height);\n      encData = enc.pngEncode();\n      writeScreenshot(encData);\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 894, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "index<byteBuffer.limit()", "guardType": "LOOP {", "guardExpressionStart": 774, "guardExpressionEnd": 814, "guardBlockStart": 774, "guardBlockEnd": 1065, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 834, "focalAPIEnd": 844, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.get(byte[])", "byteBuffer.get(byte[])", "byteBuffer.get(byte[])", "byteBuffer.put(byte,byte)", "byteBuffer.put(byte,byte)", "byteBuffer.put(int,byte)", "byteBuffer.put(byte,byte)", "byteBuffer.asIntBuffer()"], "useStart": [865, 899, 934, 957, 984, 1013, 1037, 1276], "useEnd": [879, 913, 948, 976, 1005, 1029, 1058, 1293], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ariejan/slick2d/tree/master/src/org/newdawn/slick/opengl/CursorLoader.java", "rawCode": "  /**\n   * Get a cursor based on a image reference on the classpath\n   *\n   * @param ref The reference to the image to be loaded\n   * @param x The x-coordinate of the cursor hotspot (left -> right)\n   * @param y The y-coordinate of the cursor hotspot (bottom -> top)\n   * @return The create cursor\n   * @throws IOException Indicates a failure to load the image\n   * @throws LWJGLException Indicates a failure to create the hardware cursor\n   */\n  public Cursor getCursor(String ref, int x, int y) throws IOException, LWJGLException {\n    LoadableImageData imageData = null;\n\n    imageData = ImageDataFactory.getImageDataFor(ref);\n    imageData.configureEdging(false);\n\n    ByteBuffer buf = imageData.loadImage(ResourceLoader.getResourceAsStream(ref), true, true, null);\n    for (int i = 0; i < buf.limit(); i += 4) {\n      byte red = buf.get(i);\n      byte green = buf.get(i + 1);\n      byte blue = buf.get(i + 2);\n      byte alpha = buf.get(i + 3);\n\n      buf.put(i + 2, red);\n      buf.put(i + 1, green);\n      buf.put(i, blue);\n      buf.put(i + 3, alpha);\n    }\n\n    try {\n      int yspot = imageData.getHeight() - y - 1;\n      if (yspot < 0) {\n        yspot = 0;\n      }\n\n      return new Cursor(\n          imageData.getTexWidth(), imageData.getTexHeight(), x, yspot, 1, buf.asIntBuffer(), null);\n    } catch (Throwable e) {\n      Log.info(\"Chances are you cursor is too small for this platform\");\n      throw new LWJGLException(e);\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 895, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.size()"], "configurationStart": [7048], "configurationEnd": [7062], "guardCondition": "index<n", "guardType": "LOOP {", "guardExpressionStart": 7018, "guardExpressionEnd": 7095, "guardBlockStart": 7018, "guardBlockEnd": 8549, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 7117, "focalAPIEnd": 7141, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Map<String, ApiClass>.get(value)"], "useStart": [7169], "useEnd": [7186], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sophiedankel/Android-lint/tree/master/libs/lint-checks/src/main/java/com/android/tools/lint/checks/ApiLookup.java", "rawCode": "  /** See the {@link #readData()} for documentation on the data format. */\n  private static void writeDatabase(File file, Api info) throws IOException {\n    /*\n     * 1. A file header, which is the exact contents of {@link FILE_HEADER} encoded\n     * as ASCII characters. The purpose of the header is to identify what the file\n     * is for, for anyone attempting to open the file.\n     * 2. A file version number. If the binary file does not match the reader's expected\n     * version, it can ignore it (and regenerate the cache from XML).\n     */\n    Map<String, ApiClass> classMap = info.getClasses();\n    // Write the class table\n\n    List<String> classes = new ArrayList<String>(classMap.size());\n    Map<ApiClass, List<String>> memberMap = Maps.newHashMapWithExpectedSize(classMap.size());\n    int memberCount = 0;\n    Set<String> javaPackageSet = Sets.newHashSetWithExpectedSize(70);\n    for (Map.Entry<String, ApiClass> entry : classMap.entrySet()) {\n      String className = entry.getKey();\n      ApiClass apiClass = entry.getValue();\n\n      if (className.startsWith(\"java/\") // $NON-NLS-1$\n          || className.startsWith(\"javax/\")) { // $NON-NLS-1$\n        String pkg = apiClass.getPackage();\n        javaPackageSet.add(pkg);\n      }\n\n      if (!isRelevantOwner(className)) {\n        System.out.println(\"Warning: The isRelevantOwner method does not pass \" + className);\n      }\n\n      Set<String> allMethods = apiClass.getAllMethods(info);\n      Set<String> allFields = apiClass.getAllFields(info);\n\n      // Strip out all members that have been supported since version 1.\n      // This makes the database *much* leaner (down from about 4M to about\n      // 1.7M), and this just fills the table with entries that ultimately\n      // don't help the API checker since it just needs to know if something\n      // requires a version *higher* than the minimum. If in the future the\n      // database needs to answer queries about whether a method is public\n      // or not, then we'd need to put this data back in.\n      List<String> members = new ArrayList<String>(allMethods.size() + allFields.size());\n      for (String member : allMethods) {\n\n        Integer since = apiClass.getMethod(member, info);\n        if (since == null) {\n          assert false : className + ':' + member;\n          since = 1;\n        }\n        if (since != 1) {\n          members.add(member);\n        }\n      }\n\n      // Strip out all members that have been supported since version 1.\n      // This makes the database *much* leaner (down from about 4M to about\n      // 1.7M), and this just fills the table with entries that ultimately\n      // don't help the API checker since it just needs to know if something\n      // requires a version *higher* than the minimum. If in the future the\n      // database needs to answer queries about whether a method is public\n      // or not, then we'd need to put this data back in.\n      for (String member : allFields) {\n        Integer since = apiClass.getField(member, info);\n        if (since == null) {\n          assert false : className + ':' + member;\n          since = 1;\n        }\n        if (since != 1) {\n          members.add(member);\n        }\n      }\n\n      // Only include classes that have one or more members requiring version 2 or higher:\n      if (!members.isEmpty()) {\n        classes.add(className);\n        memberMap.put(apiClass, members);\n        memberCount += members.size();\n      }\n    }\n    Collections.sort(classes);\n\n    List<String> javaPackages = Lists.newArrayList(javaPackageSet);\n    Collections.sort(javaPackages);\n    int javaPackageCount = javaPackages.size();\n\n    int entryCount = classMap.size() + memberCount;\n    int capacity = entryCount * BYTES_PER_ENTRY;\n    ByteBuffer buffer = ByteBuffer.allocate(capacity);\n    buffer.order(ByteOrder.BIG_ENDIAN);\n    // 1. A file header, which is the exact contents of {@link FILE_HEADER} encoded\n    // as ASCII characters. The purpose of the header is to identify what the file\n    // is for, for anyone attempting to open the file.\n\n    buffer.put(FILE_HEADER.getBytes(Charsets.US_ASCII));\n\n    // 2. A file version number. If the binary file does not match the reader's expected\n    // version, it can ignore it (and regenerate the cache from XML).\n    buffer.put((byte) BINARY_FORMAT_VERSION);\n\n    // 3. The number of classes [1 int]\n    buffer.putInt(classes.size());\n\n    // 4. The number of members (across all classes) [1 int].\n    buffer.putInt(memberCount);\n\n    // 5. The number of Java packages [1 int].\n    buffer.putInt(javaPackageCount);\n\n    // 6. The Java package table. There are javaPackage.size() entries, where each entry\n    // consists of a string length, as a byte, followed by the bytes in the package.\n    // There is no terminating 0.\n    for (String pkg : javaPackages) {\n      byte[] bytes = pkg.getBytes(Charsets.UTF_8);\n      assert bytes.length < 255 : pkg;\n      buffer.put((byte) bytes.length);\n      buffer.put(bytes);\n    }\n\n    // 7. Class offset table (one integer per class, pointing to the byte offset in the\n    // file (relative to the beginning of the file) where each class begins.\n    // The classes are always sorted alphabetically by fully qualified name.\n    int classOffsetTable = buffer.position();\n\n    // Reserve enough room for the offset table here: we will backfill it with pointers\n    // as we're writing out the data structures below\n    for (int i = 0, n = classes.size(); i < n; i++) {\n      buffer.putInt(0);\n    }\n\n    // 8. Member offset table (one integer per member, pointing to the byte offset in the\n    // file (relative to the beginning of the file) where each member entry begins.\n    // The members are always sorted alphabetically.\n    int methodOffsetTable = buffer.position();\n    for (int i = 0, n = memberCount; i < n; i++) {\n      buffer.putInt(0);\n    }\n\n    int nextEntry = buffer.position();\n    int nextOffset = classOffsetTable;\n\n    // 9. Class entry table. Each class entry consists of the fully qualified class name,\n    // in JVM format (using / instead of . in package names and $ for inner classes),\n    // followed by the byte 0 as a terminator, followed by the API version as a byte.\n    for (String clz : classes) {\n      buffer.position(nextOffset);\n      buffer.putInt(nextEntry);\n      nextOffset = buffer.position();\n      buffer.position(nextEntry);\n      buffer.put(clz.getBytes(Charsets.UTF_8));\n      buffer.put((byte) 0);\n\n      ApiClass apiClass = classMap.get(clz);\n      assert apiClass != null : clz;\n      int since = apiClass.getSince();\n      assert since == UnsignedBytes.toInt((byte) since) : since; // make sure it fits\n      buffer.put((byte) since);\n\n      nextEntry = buffer.position();\n    }\n\n    // 10. Member entry table. Each member entry consists of the class number (as a short),\n    // followed by the JVM method/field signature, encoded as UTF-8, followed by a 0 byte\n    // signature terminator, followed by the API level as a byte.\n    assert nextOffset == methodOffsetTable;\n\n    for (int classNumber = 0, n = classes.size(); classNumber < n; classNumber++) {\n      String clz = classes.get(classNumber);\n      ApiClass apiClass = classMap.get(clz);\n      assert apiClass != null : clz;\n      List<String> members = memberMap.get(apiClass);\n      Collections.sort(members);\n\n      for (String member : members) {\n        buffer.position(nextOffset);\n        buffer.putInt(nextEntry);\n        nextOffset = buffer.position();\n        buffer.position(nextEntry);\n\n        Integer since;\n        if (member.indexOf('(') != -1) {\n          since = apiClass.getMethod(member, info);\n        } else {\n          since = apiClass.getField(member, info);\n        }\n        if (since == null) {\n          assert false : clz + ':' + member;\n          since = 1;\n        }\n\n        assert classNumber == (short) classNumber;\n        buffer.putShort((short) classNumber);\n        byte[] signature = member.getBytes(Charsets.UTF_8);\n        for (int i = 0; i < signature.length; i++) {\n          // Make sure all signatures are really just simple ASCII\n          byte b = signature[i];\n          assert b == (b & 0x7f) : member;\n          buffer.put(b);\n          // Skip types on methods\n          if (b == (byte) ')') {\n            break;\n          }\n        }\n        buffer.put((byte) 0);\n        int api = since;\n        assert api == UnsignedBytes.toInt((byte) api);\n        // assert api >= 1 && api < 0xFF; // max that fits in a byte\n        buffer.put((byte) api);\n        nextEntry = buffer.position();\n      }\n    }\n\n    int size = buffer.position();\n    assert size <= buffer.limit();\n    buffer.mark();\n\n    if (WRITE_STATS) {\n      System.out.println(\n          \"Wrote \" + classes.size() + \" classes and \" + memberCount + \" member entries\");\n      System.out.print(\"Actual binary size: \" + size + \" bytes\");\n      System.out.println(String.format(\" (%.1fM)\", size / (1024 * 1024.f)));\n\n      System.out.println(\"Allocated size: \" + (entryCount * BYTES_PER_ENTRY) + \" bytes\");\n      System.out.println(\"Required bytes per entry: \" + (size / entryCount) + \" bytes\");\n    }\n\n    // Now dump this out as a file\n    // There's probably an API to do this more efficiently; TODO: Look into this.\n    byte[] b = new byte[size];\n    buffer.rewind();\n    buffer.get(b);\n    if (file.exists()) {\n      file.delete();\n    }\n    FileOutputStream output = Files.newOutputStreamSupplier(file).getOutput();\n    output.write(b);\n    output.close();\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 896, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.position()", "byteBuffer.get(byte[],int,int)"], "configurationStart": [535, 935], "configurationEnd": [552, 998], "guardCondition": "byteBuffer.hasRemaining()", "guardType": "IF {", "guardExpressionStart": 196, "guardExpressionEnd": 222, "guardBlockStart": 196, "guardBlockEnd": 1190, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 1142, "focalAPIEnd": 1154, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.hasRemaining()", "byteBuffer.clear()", "byteBuffer.array()", "byteBuffer.position(int)", "byteBuffer.flip()"], "useStart": [1205, 1234, 1287, 1511, 1543], "useEnd": [1226, 1248, 1301, 1535, 1556], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Nodeclipse/nodeclipse-1/tree/master/chromedevtools/plugins/org.chromium.sdk/src/org/chromium/sdk/internal/transport/LineReader.java", "rawCode": "  /** Method has similar semantics to {@link BufferedReader#readLine()} method. */\n  public String readLine(Charset charset) throws IOException {\n    lineBuffer.clear();\n\n    while (true) {\n      if (buffer.hasRemaining()) {\n        boolean lineEndFound = false;\n        int pos;\n        findingLineEnd:\n        for (pos = buffer.position(); pos < buffer.limit(); pos++) {\n          if (buffer.get(pos) == LF_BYTE) {\n            lineEndFound = true;\n            break findingLineEnd;\n          }\n        }\n        int chunkLen = pos - buffer.position();\n        if (chunkLen > 0) {\n          if (lineBuffer.remaining() < chunkLen) {\n            int newSize = Math.max(lineBuffer.capacity() * 2, lineBuffer.position() + chunkLen);\n            ByteBuffer newLineBuffer = ByteBuffer.allocate(newSize);\n            lineBuffer.flip();\n            newLineBuffer.put(lineBuffer);\n            lineBuffer = newLineBuffer;\n          }\n          buffer.get(lineBuffer.array(), lineBuffer.position(), chunkLen);\n          lineBuffer.position(lineBuffer.position() + chunkLen);\n        }\n        if (lineEndFound) {\n          // Shift position.\n          buffer.get();\n          break;\n        }\n      }\n      assert !buffer.hasRemaining();\n      buffer.clear();\n      int readRes = inputStream.read(buffer.array());\n      if (readRes <= 0) {\n        if (lineBuffer.position() == 0) {\n          return null;\n        } else {\n          throw new IOException(\"End of stream while expecting line end\");\n        }\n      }\n      buffer.position(readRes);\n      buffer.flip();\n    }\n    if (lineBuffer.position() > 0 && lineBuffer.get(lineBuffer.position() - 1) == CR_BYTE) {\n      lineBuffer.position(lineBuffer.position() - 1);\n    }\n    return new String(lineBuffer.array(), 0, lineBuffer.position(), charset);\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 897, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "byteBuffer.remaining()>0", "guardType": "LOOP {", "guardExpressionStart": 179, "guardExpressionEnd": 212, "guardBlockStart": 179, "guardBlockEnd": 1556, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 235, "focalAPIEnd": 250, "followUpCheck": "value > 0 && value <= DATA_MAX", "checkType": "IF", "followUpCheckExpressionStart": 276, "followUpCheckExpressionEnd": 315, "followUpCheckBlockStart": 276, "followUpCheckBlockEnd": 435, "use": ["get(byteBuffer,boolean)", "byteBuffer.position()", "dump(byteBuffer,*,int)", "byteBuffer.get()", "get(byteBuffer,boolean)"], "useStart": [400, 674, 658, 784, 1028], "useEnd": [434, 694, 703, 799, 1062], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wordrak/kryo/tree/master/src/main/java/com/esotericsoftware/kryo/compress/Delta.java", "rawCode": "  /** @param oldData Can be null if the delta does not contain copy commands. */\n  public void decompress(ByteBuffer oldData, ByteBuffer deltaData, ByteBuffer outputBuffer) {\n    while (deltaData.remaining() > 0) {\n      int command = deltaData.get();\n      int length;\n      if (command > 0 && command <= DATA_MAX) {\n        length = command;\n        command = COMMAND_APPEND;\n      } else length = IntSerializer.get(deltaData, true);\n      switch (command) {\n        case COMMAND_APPEND:\n          if (debug)\n            System.out.println(\n                \"decompress APPEND \"\n                    + length\n                    + \": \"\n                    + dump(deltaData, deltaData.position(), length));\n          // Append new data.\n          while (length-- > 0) outputBuffer.put(deltaData.get());\n          break;\n        case COMMAND_COPY:\n          // Copy old data.\n          if (oldData == null)\n            throw new SerializationException(\"Delta copy command received without previous data.\");\n          int offset = IntSerializer.get(deltaData, true);\n          if (debug)\n            System.out.println(\n                \"decompress COPY at \"\n                    + offset\n                    + \", length \"\n                    + length\n                    + \": \"\n                    + dump(oldData, offset, length));\n          oldData.position(offset);\n          while (length-- > 0) outputBuffer.put(oldData.get());\n          break;\n        default:\n          throw new SerializationException(\"Invalid delta command: \" + command);\n      }\n    }\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 898, "initialization": ["ByteBuffer byteBuffer = allocate(int)"], "initializationStart": [432], "initializationEnd": [465], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.put(byte,byte)"], "configurationStart": [536], "configurationEnd": [549], "guardCondition": "index<CONTENT_SIZE/2", "guardType": "LOOP {", "guardExpressionStart": 562, "guardExpressionEnd": 604, "guardBlockStart": 562, "guardBlockEnd": 657, "focalAPI": "value = byteBuffer.get(index)", "focalAPIStart": 639, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.put(byte,byte)"], "useStart": [613], "useEnd": [650], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.13/kernel-impl/src/test/java/org/sakaiproject/content/impl/test/ContentIntegrationTestDisabled.java", "rawCode": "  public void setUp() throws Exception {\n    log.debug(\"Setting up a ContentIntegrationTest test\");\n\n    // Connect to the required services\n    // authzGroupService = (AuthzGroupService) getService(AuthzGroupService.class.getName());\n    // siteService = (SiteService) getService(SiteService.class.getName());\n    // contentService = (ContentHostingService) getService(ContentHostingService.class.getName());\n\n    ByteBuffer buf = ByteBuffer.allocate(CONTENT_SIZE);\n\n    for (byte b = Byte.MIN_VALUE; b <= Byte.MAX_VALUE; b++) {\n      buf.put(b, b);\n    }\n\n    for (int i = 0; i < CONTENT_SIZE / 2; i++) {\n      buf.put(CONTENT_SIZE - i, buf.get(i));\n    }\n\n    log.debug(\"Done setting up a ContentIntegrationTest test\");\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 899, "initialization": ["ByteBuffer byteBuffer = wrap(byte[])"], "initializationStart": [223], "initializationEnd": [251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.order(ByteOrder)", "byteBuffer.asShortBuffer()"], "configurationStart": [257, 402], "configurationEnd": [291, 421], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 477, "focalAPIEnd": 492, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteBuffer.put(value)"], "useStart": [541], "useEnd": [560], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kevinwang/minecarft/tree/master/lwjgl-source-2.8.2/src/java/org/lwjgl/util/WaveData.java", "rawCode": "  private static ByteBuffer convertAudioBytes(byte[] audio_bytes, boolean two_bytes_data) {\n    ByteBuffer dest = ByteBuffer.allocateDirect(audio_bytes.length);\n    dest.order(ByteOrder.nativeOrder());\n    ByteBuffer src = ByteBuffer.wrap(audio_bytes);\n    src.order(ByteOrder.LITTLE_ENDIAN);\n    if (two_bytes_data) {\n      ShortBuffer dest_short = dest.asShortBuffer();\n      ShortBuffer src_short = src.asShortBuffer();\n      while (src_short.hasRemaining()) dest_short.put(src_short.get());\n    } else {\n      while (src.hasRemaining()) dest.put(src.get());\n    }\n    dest.rewind();\n    return dest;\n  }\n"}, {"dataset": "byteBufferGet", "exampleID": 900, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["byteBuffer.position(int)"], "configurationStart": [86], "configurationEnd": [99], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = byteBuffer.get()", "focalAPIStart": 105, "focalAPIEnd": 112, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.get(byte[])", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.get(byte[],int,int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getChar()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getDouble()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getFloat()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getInt()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getLong()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.getShort()", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.put(byte[])", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.put(byte[])", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.put(byte[],int,int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putChar(char)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putDouble(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putFloat(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putInt(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putLong(int)", "byteBuffer.position()", "byteBuffer.position(int)", "byteBuffer.putShort(short)", "byteBuffer.position()"], "useStart": [134, 184, 203, 235, 255, 274, 312, 332, 351, 384, 404, 423, 458, 478, 497, 531, 551, 570, 602, 622, 641, 674, 694, 713, 747, 779, 798, 835, 855, 874, 906, 926, 945, 983, 1003, 1022, 1058, 1078, 1097, 1133, 1153, 1172, 1207, 1227, 1246, 1279, 1299, 1318, 1352, 1372, 1391, 1434], "useEnd": [146, 197, 213, 247, 268, 290, 324, 345, 362, 396, 417, 436, 470, 491, 509, 543, 564, 580, 614, 635, 652, 686, 707, 725, 759, 792, 813, 847, 868, 884, 918, 939, 961, 995, 1016, 1036, 1070, 1091, 1111, 1145, 1166, 1185, 1219, 1240, 1257, 1291, 1312, 1330, 1364, 1385, 1412, 1446], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/libcore/java/nio/BufferTest.java", "rawCode": "  private void testRelativePositions(ByteBuffer b) throws Exception {\n    // gets\n    b.position(0);\n    b.get();\n    assertEquals(1, b.position());\n\n    byte[] buf = new byte[5];\n    b.position(0);\n    b.get(buf);\n    assertEquals(5, b.position());\n\n    b.position(0);\n    b.get(buf, 1, 3);\n    assertEquals(3, b.position());\n\n    b.position(0);\n    b.getChar();\n    assertEquals(2, b.position());\n\n    b.position(0);\n    b.getDouble();\n    assertEquals(8, b.position());\n\n    b.position(0);\n    b.getFloat();\n    assertEquals(4, b.position());\n\n    b.position(0);\n    b.getInt();\n    assertEquals(4, b.position());\n\n    b.position(0);\n    b.getLong();\n    assertEquals(8, b.position());\n\n    b.position(0);\n    b.getShort();\n    assertEquals(2, b.position());\n\n    // puts\n    b.position(0);\n    b.put((byte) 0);\n    assertEquals(1, b.position());\n\n    b.position(0);\n    b.put(buf);\n    assertEquals(5, b.position());\n\n    b.position(0);\n    b.put(buf, 1, 3);\n    assertEquals(3, b.position());\n\n    b.position(0);\n    b.putChar('x');\n    assertEquals(2, b.position());\n\n    b.position(0);\n    b.putDouble(0);\n    assertEquals(8, b.position());\n\n    b.position(0);\n    b.putFloat(0);\n    assertEquals(4, b.position());\n\n    b.position(0);\n    b.putInt(0);\n    assertEquals(4, b.position());\n\n    b.position(0);\n    b.putLong(0);\n    assertEquals(8, b.position());\n\n    b.position(0);\n    b.putShort((short) 0);\n    assertEquals(2, b.position());\n  }\n"}]