[{"dataset": "find", "exampleID": 5601, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [384], "initializationEnd": [408], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 432, "focalAPIEnd": 446, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [492], "useEnd": [508], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/black-knight/Q-Cumberless-Testing/tree/master/src/java/com/trollsahead/qcumberless/util/SimpleRubyStepDefinitionParser.java", "rawCode": "  private static StepDefinition parseLine(String line, String hooks) {\n    if (Util.isEmpty(line)) {\n      return null;\n    }\n    for (String keyword : Constants.getStepPrefixsForLocale(Language.EN)) {\n      if (!Util.isWord(keyword)) {\n        continue;\n      }\n      String pattern = buildStepDefinitionPattern(keyword);\n      if (line.matches(pattern)) {\n        Matcher matcher = Pattern.compile(pattern).matcher(line);\n        matcher.find();\n        return parseStepDefinition(keyword, matcher.group(1), hooks);\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "find", "exampleID": 5602, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [1123], "initializationEnd": [1159], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["Log.warn(String)"], "tryExpressionStart": 1048, "tryExpressionEnd": 1052, "tryBlockStart": 1048, "tryBlockEnd": 2241, "catchExpressionStart": 1832, "catchExpressionEnd": 1855, "catchBlockStart": 1832, "catchBlockEnd": 1930, "exceptionHandlingCallStart": [1863], "exceptionHandlingCallEnd": [1905], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 1181, "focalAPIEnd": 1189, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 1197, "followUpCheckExpressionEnd": 1205, "followUpCheckBlockStart": 1197, "followUpCheckBlockEnd": 1825, "use": ["matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [1331, 1355, 1396, 1438, 1478, 1518, 1558, 1599], "useEnd": [1341, 1365, 1406, 1448, 1488, 1528, 1569, 1610], "hasFinally": 1, "cleanUpCall": ["FileReader.close()"], "finallyExpressionStart": 1931, "finallyExpressionEnd": 1939, "finallyBlockStart": 1931, "finallyBlockEnd": 2241, "cleanUpCallStart": [1988], "cleanUpCallEnd": [2003], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java", "rawCode": "  /**\n   * Construct the ProcessInfo using the process' PID and procfs rooted at the specified directory\n   * and return the same. It is provided mainly to assist testing purposes.\n   *\n   * <p>Returns null on failing to read from procfs,\n   *\n   * @param pinfo ProcessInfo that needs to be updated\n   * @param procfsDir root of the proc file system\n   * @return updated ProcessInfo, null on errors.\n   */\n  private static ProcessInfo constructProcessInfo(ProcessInfo pinfo, String procfsDir) {\n    ProcessInfo ret = null;\n    // Read \"procfsDir/<pid>/stat\" file - typically /proc/<pid>/stat\n    BufferedReader in = null;\n    FileReader fReader = null;\n    try {\n      File pidDir = new File(procfsDir, pinfo.getPid());\n      fReader = new FileReader(new File(pidDir, PROCFS_STAT_FILE));\n      in = new BufferedReader(fReader);\n    } catch (FileNotFoundException f) {\n      // The process vanished in the interim!\n      LOG.warn(\"The process \" + pinfo.getPid() + \" may have finished in the interim.\");\n      return ret;\n    }\n\n    ret = pinfo;\n    try {\n      String str = in.readLine(); // only one line\n      Matcher m = PROCFS_STAT_FILE_FORMAT.matcher(str);\n      boolean mat = m.find();\n      if (mat) {\n        // Set (name) (ppid) (pgrpId) (session) (utime) (stime) (vsize) (rss)\n        pinfo.updateProcessInfo(\n            m.group(2),\n            m.group(3),\n            Integer.parseInt(m.group(4)),\n            Integer.parseInt(m.group(5)),\n            Long.parseLong(m.group(7)),\n            new BigInteger(m.group(8)),\n            Long.parseLong(m.group(10)),\n            Long.parseLong(m.group(11)));\n      } else {\n        LOG.warn(\n            \"Unexpected: procfs stat file is not in the expected format\"\n                + \" for process with pid \"\n                + pinfo.getPid());\n        ret = null;\n      }\n    } catch (IOException io) {\n      LOG.warn(\"Error reading the stream \" + io);\n      ret = null;\n    } finally {\n      // Close the streams\n      try {\n        fReader.close();\n        try {\n          in.close();\n        } catch (IOException i) {\n          LOG.warn(\"Error closing the stream \" + in);\n        }\n      } catch (IOException i) {\n        LOG.warn(\"Error closing the stream \" + fReader);\n      }\n    }\n\n    return ret;\n  }\n"}, {"dataset": "find", "exampleID": 5603, "initialization": ["Matcher matcher = new Matcher(*,CharSequence)"], "initializationStart": [185], "initializationEnd": [209], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 343, "focalAPIEnd": 357, "followUpCheck": "result && (true)", "checkType": "LOOP {", "followUpCheckExpressionStart": 364, "followUpCheckExpressionEnd": 416, "followUpCheckBlockStart": 364, "followUpCheckBlockEnd": 759, "use": ["matcher.start()", "matcher.end()", "matcher.find()"], "useStart": [446, 707, 738], "useEnd": [461, 720, 752], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ivmai/JCGO/tree/master/goclsp/clsp_fix/java/util/regex/Pattern.java", "rawCode": "  /**\n   * @param input The character sequence to be matched\n   * @param limit The result threshold\n   */\n  public String[] split(CharSequence input, int limit) {\n    Matcher matcher = new Matcher(this, input);\n    ArrayList list = new ArrayList();\n    int empties = 0;\n    int count = 0;\n    int start = 0;\n    int end;\n    boolean matched = matcher.find();\n\n    while (matched && (limit <= 0 || count < limit - 1)) {\n      ++count;\n      end = matcher.start();\n      if (start == end) empties++;\n      else {\n        while (empties > 0) {\n          list.add(\"\");\n          empties--;\n        }\n\n        String text = input.subSequence(start, end).toString();\n        list.add(text);\n      }\n      start = matcher.end();\n      matched = matcher.find();\n    }\n\n    // We matched nothing.\n    if (!matched && count == 0) return new String[] {input.toString()};\n\n    // Is the last token empty?\n    boolean emptyLast = (start == input.length());\n\n    // Can/Must we add empties or an extra last token at the end?\n    if (list.size() < limit || limit < 0 || (limit == 0 && !emptyLast)) {\n      if (limit > list.size()) {\n        int max = limit - list.size();\n        empties = (empties > max) ? max : empties;\n      }\n      while (empties > 0) {\n        list.add(\"\");\n        empties--;\n      }\n    }\n\n    // last token at end\n    if (limit != 0 || (limit == 0 && !emptyLast)) {\n      String t = input.subSequence(start, input.length()).toString();\n      if (\"\".equals(t) && limit == 0) ; // Don't add.\n      else list.add(t);\n    }\n\n    String[] output = new String[list.size()];\n    list.toArray(output);\n    return output;\n  }\n"}, {"dataset": "find", "exampleID": 5604, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [211], "initializationEnd": [227], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 240, "focalAPIEnd": 248, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xiaoxiang88888888/xiaoxiang88888888/tree/master/tool/src/main/java/com/xiaoxiang/tool/StringUtil.java", "rawCode": "  /**\n   * 验证 正则表达式\n   *\n   * @param regex 规则\n   * @param value 字符串\n   * @return boolean\n   */\n  public static boolean regex(String regex, String value) {\n    Pattern p = Pattern.compile(regex);\n    Matcher m = p.matcher(value);\n    return m.find();\n  }\n"}, {"dataset": "find", "exampleID": 5605, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [148], "initializationEnd": [184], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 201, "focalAPIEnd": 209, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.start()", "matcher.end()", "matcher.groupCount()", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group()", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.start()", "matcher.end()", "matcher.groupCount()", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group()", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.start()", "matcher.end()", "matcher.groupCount()", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group()", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.find()", "assertFalse(result)"], "useStart": [190, 232, 264, 294, 331, 364, 395, 428, 459, 492, 529, 567, 603, 639, 668, 657, 699, 732, 762, 800, 831, 864, 895, 929, 966, 1004, 1040, 1077, 1106, 1095, 1138, 1171, 1201, 1239, 1273, 1305, 1339, 1371, 1405, 1445, 1486, 1523, 1561, 1590, 1578], "useEnd": [210, 241, 271, 308, 341, 372, 405, 436, 469, 500, 538, 577, 613, 649, 676, 677, 708, 739, 776, 808, 841, 872, 905, 937, 975, 1014, 1050, 1087, 1114, 1115, 1147, 1178, 1215, 1249, 1281, 1315, 1347, 1381, 1413, 1454, 1496, 1533, 1571, 1598, 1599], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TaintDroid/android_platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/Pattern2Test.java", "rawCode": "  public void testGroups() throws PatternSyntaxException {\n    Pattern p;\n    Matcher m;\n\n    p = Pattern.compile(\"(p[0-9]*)#?(q[0-9]*)\");\n\n    m = p.matcher(\"p1#q3p2q42p5p71p63#q888\");\n    assertTrue(m.find());\n    assertEquals(0, m.start());\n    assertEquals(5, m.end());\n    assertEquals(2, m.groupCount());\n    assertEquals(0, m.start(0));\n    assertEquals(5, m.end(0));\n    assertEquals(0, m.start(1));\n    assertEquals(2, m.end(1));\n    assertEquals(3, m.start(2));\n    assertEquals(5, m.end(2));\n    assertEquals(\"p1#q3\", m.group());\n    assertEquals(\"p1#q3\", m.group(0));\n    assertEquals(\"p1\", m.group(1));\n    assertEquals(\"q3\", m.group(2));\n\n    assertTrue(m.find());\n    assertEquals(5, m.start());\n    assertEquals(10, m.end());\n    assertEquals(2, m.groupCount());\n    assertEquals(10, m.end(0));\n    assertEquals(5, m.start(1));\n    assertEquals(7, m.end(1));\n    assertEquals(7, m.start(2));\n    assertEquals(10, m.end(2));\n    assertEquals(\"p2q42\", m.group());\n    assertEquals(\"p2q42\", m.group(0));\n    assertEquals(\"p2\", m.group(1));\n    assertEquals(\"q42\", m.group(2));\n\n    assertTrue(m.find());\n    assertEquals(15, m.start());\n    assertEquals(23, m.end());\n    assertEquals(2, m.groupCount());\n    assertEquals(15, m.start(0));\n    assertEquals(23, m.end(0));\n    assertEquals(15, m.start(1));\n    assertEquals(18, m.end(1));\n    assertEquals(19, m.start(2));\n    assertEquals(23, m.end(2));\n    assertEquals(\"p63#q888\", m.group());\n    assertEquals(\"p63#q888\", m.group(0));\n    assertEquals(\"p63\", m.group(1));\n    assertEquals(\"q888\", m.group(2));\n    assertFalse(m.find());\n  }\n"}, {"dataset": "find", "exampleID": 5606, "initialization": ["Matcher matcher = RegexCache.getPatternForRegex(String)"], "initializationStart": [308], "initializationEnd": [352], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 386, "focalAPIEnd": 394, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group()"], "useStart": [450], "useEnd": [459], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/google-libphonenumber-mirror/tree/master/tags/libphonenumber-4.4/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java", "rawCode": "  private String getFormattingTemplate(String numberPattern, String numberFormat) {\n    // Creates a phone number consisting only of the digit 9 that matches the\n    // numberPattern by applying the pattern to the longestPhoneNumber string.\n    String longestPhoneNumber = \"999999999999999\";\n    Matcher m = regexCache.getPatternForRegex(numberPattern).matcher(longestPhoneNumber);\n    m.find(); // this will always succeed\n    String aPhoneNumber = m.group();\n    // No formatting template can be created if the number of digits entered so far is longer than\n    // the maximum the current formatting rule can accommodate.\n    if (aPhoneNumber.length() < nationalNumber.length()) {\n      return \"\";\n    }\n    // Formats the number according to numberFormat\n    String template = aPhoneNumber.replaceAll(numberPattern, numberFormat);\n    // Replaces each digit with character digitPlaceholder\n    template = template.replaceAll(\"9\", digitPlaceholder);\n    return template;\n  }\n"}, {"dataset": "find", "exampleID": 5607, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [272], "initializationEnd": [288], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 305, "focalAPIEnd": 313, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.group()"], "useStart": [294, 333], "useEnd": [314, 342], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thesmith/eventhorizon/tree/master/src/test/java/thesmith/eventhorizon/service/SocialGraphApiServiceImplTest.java", "rawCode": "  @Test\n  public void shouldReplaceLink() throws Exception {\n    String tweet = \"Panic Status Board: http://bit.ly/aTs0uZ\";\n    Pattern p =\n        Pattern.compile(\n            \"\\\\b(https?|ftp|file)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]\");\n    Matcher m = p.matcher(tweet);\n    assertTrue(m.find());\n    String url = m.group();\n    int start = tweet.indexOf(url);\n    String replacement = String.format(\"<a href='%s'>%s</a>\", url, url);\n    String beginning = tweet.substring(0, start);\n    String end = tweet.substring(start + url.length());\n    tweet = beginning + replacement + end;\n\n    System.err.println(tweet);\n    assertTrue(tweet.contains(\"<a href\"));\n  }\n"}, {"dataset": "find", "exampleID": 5608, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [253], "initializationEnd": [289], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 299, "focalAPIEnd": 311, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [343], "useEnd": [357], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/unclebob/fitnesse/tree/master/src/fitnesse/http/Request.java", "rawCode": "  private void parseEntityBody() throws IOException {\n    if (hasHeader(\"Content-Length\")) {\n      String contentType = getHeader(\"Content-Type\");\n      if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n        Matcher match = boundaryPattern.matcher(contentType);\n        match.find();\n        parseMultiPartContent(match.group(1));\n      } else {\n        entityBody = input.read(getContentLength());\n        parseQueryString(entityBody);\n      }\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5609, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [804], "initializationEnd": [829], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 857, "focalAPIEnd": 865, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [901], "useEnd": [911], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Photodeus/MsLuvaLuva/tree/master/src/com/popodeus/chat/MsLuvaLuva.java", "rawCode": "  @Override\n  protected void onKick(\n      final String channel,\n      final String kickerNick,\n      final String kickerLogin,\n      final String kickerHostname,\n      final String recipientNick,\n      final String reason) {\n    logger.logAction(\n        channel,\n        kickerNick,\n        recipientNick + \" was kicked from \" + channel + \" by \" + kickerNick + \" [\" + reason + \"]\");\n    log.fine(\"Kicked: \" + recipientNick);\n    if (recipientNick.equals(getNick())) {\n      final MsLuvaLuva _this = this;\n      TimerTask tt =\n          new TimerTask() {\n            public void run() {\n              _this.join(channel);\n            }\n          };\n      final int KICKOUT_TIME = 15000;\n      long time = KICKOUT_TIME;\n      if (reason.matches(\".*(\\\\d+).*\")) {\n        try {\n          final Matcher m = Pattern.compile(\"(\\\\d+)\").matcher(reason);\n          m.find();\n          time = Integer.parseInt(m.group(1));\n          if (time > 0 && time <= 300) {\n            time *= 1000;\n          } else {\n            time = KICKOUT_TIME;\n          }\n        } catch (Exception e) {\n        }\n      }\n      log.info(\"Was kicked, rejoining \" + channel + \" in \" + time + \"ms\");\n      Timer timer = new Timer();\n      timer.schedule(tt, time);\n    } else {\n      /*\n      Set<User> u = channel_users.get(channel);\n      if (u != null) {\n      u.remove(new User(User.Prefix.NONE, recipientNick));\n      }\n      */\n      scriptmanager.runOnEventScript(\n          this, Event.KICK, recipientNick, kickerLogin, kickerHostname, null, channel);\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5610, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 506, "focalAPIEnd": 520, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Wihidum/cep/tree/master/components/cep/org.wso2.carbon.cep.admin/4.0.2/src/main/java/org/wso2/carbon/cep/admin/internal/CEPAdminService.java", "rawCode": "  private boolean isServiceSatisfySearchString(String searchString, String bucketName) {\n    if (searchString != null) {\n      String regex =\n          searchString\n              .toLowerCase()\n              .replace(\"..?\", \".?\")\n              .replace(\"..*\", \".*\")\n              .replaceAll(\"\\\\?\", \".?\")\n              .replaceAll(\"\\\\*\", \".*?\");\n\n      Pattern pattern = Pattern.compile(regex);\n      Matcher matcher = pattern.matcher(bucketName.toLowerCase());\n\n      return regex.trim().length() == 0 || matcher.find();\n    }\n    return true;\n  }\n"}, {"dataset": "find", "exampleID": 5611, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.group(int)", "matcher.end()", "matcher.group(int)"], "configurationStart": [303, 413, 468], "configurationEnd": [313, 420, 478], "guardCondition": "!(matcher.group(2,).equals(\"DISABLED\",))", "guardType": "IF {", "guardExpressionStart": 319, "guardExpressionEnd": 353, "guardBlockStart": 319, "guardBlockEnd": 435, "focalAPI": "result = matcher.find()", "focalAPIStart": 561, "focalAPIEnd": 569, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["checkArgument(result,String,String)", "matcher.group(int)", "matcher.group(int)", "matcher.end()"], "useStart": [533, 625, 678, 905], "useEnd": [602, 635, 688, 912], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/threerings/narya/tree/master/tools/src/main/java/com/threerings/presents/tools/GeneratedSourceMerger.java", "rawCode": "  /**\n   * Returns a section name and its contents from the given matcher pointing to the start of a\n   * section. <code>m</code> is at the end of the section when this returns.\n   */\n  protected Section extractGeneratedSection(Matcher m, String input) {\n    int startIdx = m.start();\n    String name = m.group(1);\n    if (m.group(2).equals(\"DISABLED\")) {\n      return new Section(name, input.substring(startIdx, m.end()), true);\n    }\n    Preconditions.checkArgument(m.group(2).equals(\"START\"), \"'%s' END without START\", name);\n    Preconditions.checkArgument(m.find(), \"'%s' START without END\", name);\n    String endName = m.group(1);\n    Preconditions.checkArgument(\n        m.group(2).equals(\"END\"), \"'%s' START after '%s' START\", endName, name);\n    Preconditions.checkArgument(endName.equals(name), \"'%s' END after '%s' START\", endName, name);\n    return new Section(name, input.substring(startIdx, m.end()), false);\n  }\n"}, {"dataset": "find", "exampleID": 5612, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [242], "initializationEnd": [258], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 332, "focalAPIEnd": 340, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 346, "followUpCheckExpressionEnd": 361, "followUpCheckBlockStart": 346, "followUpCheckBlockEnd": 601, "use": ["matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [383, 414, 443, 469], "useEnd": [393, 424, 453, 479], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CS340Group/hit/tree/master/src/common/util/QueryParser.java", "rawCode": "  /**\n   * Helper method to parse out the required fields in the query. Expects the query to look like:\n   * obj.attr = value\n   */\n  private void Parse() {\n    Pattern p = Pattern.compile(\"((\\\\w*)\\\\.)?(\\\\w*)\\\\s(.*)\\\\s(.*)\");\n    Matcher m = p.matcher(query);\n    OperatorFactory c = new OperatorFactory();\n    boolean matchFound = m.find();\n    if (matchFound) {\n      objectName = m.group(2);\n      objectAttr = m.group(3);\n      operator = m.group(4);\n      value = m.group(5);\n    } else {\n      // If match isn't found then the query is in the wrong form.\n      assert (matchFound == true);\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5613, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [273], "initializationEnd": [297], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 325, "focalAPIEnd": 345, "followUpCheck": "result", "checkType": "LOOP {", "followUpCheckExpressionStart": 351, "followUpCheckExpressionEnd": 370, "followUpCheckBlockStart": 351, "followUpCheckBlockEnd": 1208, "use": ["matcher.group()", "matcher.end()", "matcher.find()", "matcher.start()"], "useStart": [448, 611, 683, 838], "useEnd": [469, 630, 703, 859], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnperry/CTP/tree/master/source/java/org/rsna/ctp/stdstages/anonymizer/dicom/PixelScript.java", "rawCode": "  private List<Signature> getSignatures(String s) {\n    LinkedList<Signature> signatures = new LinkedList<Signature>();\n    Pattern scriptPattern = Pattern.compile(\"\\\\{[^\\\\}]*\\\\}\");\n    Pattern regionPattern = Pattern.compile(\"\\\\([^\\\\)]*\\\\)\");\n\n    Matcher scriptMatcher = scriptPattern.matcher(s);\n    boolean foundScript = scriptMatcher.find();\n    while (foundScript) {\n      // capture the script and create the Signature\n      String script = scriptMatcher.group();\n      Signature signature = new Signature(script.substring(1, script.length() - 1));\n      signatures.add(signature);\n      int scriptEnd = scriptMatcher.end();\n\n      // find the next script\n      foundScript = scriptMatcher.find();\n\n      // get the text between the last script and this one\n      int scriptStart = s.length();\n      if (foundScript) scriptStart = scriptMatcher.start();\n      String regionString = s.substring(scriptEnd, scriptStart);\n\n      // find all the regions in the regionString and add them to the signature\n      Matcher regionMatcher = regionPattern.matcher(regionString);\n      while (regionMatcher.find()) {\n        String region = regionMatcher.group();\n        signature.addRegion(region);\n      }\n    }\n    return signatures;\n  }\n"}, {"dataset": "find", "exampleID": 5614, "initialization": ["Matcher matcher = Pattern.matcher(StringBuffer)"], "initializationStart": [519], "initializationEnd": [546], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 567, "focalAPIEnd": 586, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 688, "followUpCheckExpressionEnd": 703, "followUpCheckBlockStart": 688, "followUpCheckBlockEnd": 824, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eiNetwork/eiNetwork/tree/master/vufind/import/src/org/vufind/MarcRecordDetails.java", "rawCode": "  public String getLocationBoost(\n      String locationSpecifier, String locationSpecifier2, String activeLocation) {\n    Set<String> locationCodes = getLocationCodes(locationSpecifier, locationSpecifier2);\n\n    StringBuffer branchString = new StringBuffer();\n    for (String curBranch : locationCodes) {\n      branchString.append(curBranch + \" \");\n    }\n\n    boolean FoundMatch = false;\n    try {\n      Pattern Regex = Pattern.compile(\"(?:\\\\(\\\\d+\\\\))?(\" + activeLocation + \".*?)(\\\\s|$)\");\n      Matcher RegexMatcher = Regex.matcher(branchString);\n      FoundMatch = RegexMatcher.find();\n    } catch (PatternSyntaxException ex) {\n      // Syntax error in the regular expression\n    }\n    if (FoundMatch) {\n      // System.out.println(activeLocation + \" boost = 750\");\n      return \"750\";\n    } else {\n      return \"0\";\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5615, "initialization": ["Matcher matcher = SearchOptions.getRegexPattern()"], "initializationStart": [325], "initializationEnd": [356], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()", "matcher.region(int,int)"], "configurationStart": [683, 753], "configurationEnd": [700, 834], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 909, "focalAPIEnd": 923, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 936, "followUpCheckExpressionEnd": 946, "followUpCheckBlockStart": 936, "followUpCheckBlockEnd": 1878, "use": ["matcher.start()"], "useStart": [1126], "useEnd": [1141], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gephi/gephi/tree/master/modules/DataLaboratoryAPI/src/main/java/org/gephi/datalab/impl/SearchReplaceControllerImpl.java", "rawCode": "  private SearchResult matchRegex(\n      Object value,\n      SearchOptions searchOptions,\n      int rowIndex,\n      int columnIndex,\n      TimeFormat timeFormat,\n      DateTimeZone timeZone) {\n    boolean found;\n\n    String str = value != null ? AttributeUtils.print(value, timeFormat, timeZone) : \"\";\n\n    Matcher matcher = searchOptions.getRegexPattern().matcher(str);\n    if (str.isEmpty()) {\n      if (searchOptions.getRegionStart() > 0) {\n        return null;\n      }\n    } else if (searchOptions.getRegionStart() >= str.length()) {\n      return null; // No more to search in this value, go to next\n    }\n\n    if (searchOptions.isOnlyMatchWholeAttributeValue()) {\n      found = matcher.matches(); // Try to match the whole value\n    } else {\n      matcher.region(\n          searchOptions.getRegionStart(),\n          str.length()); // Try to match a group in the remaining part of the value\n      found = matcher.find();\n    }\n\n    if (found) {\n      searchOptions.setStartingRow(rowIndex); // For next search\n      searchOptions.setStartingColumn(columnIndex); // For next search\n      int end = matcher.end();\n      if (matcher.start() == end && !str.isEmpty()) {\n        return null; // Do not match empty string in not empty values\n      }\n      if (str.isEmpty()) {\n        end++; // To be able to search on next values when the value matched is empty\n      }\n      searchOptions.setRegionStart(\n          end); // Start next search after this match in this value. (If it is greater than the\n                // length of the value, it will be discarded at the beginning of this method next\n                // time)\n      return new SearchResult(\n          searchOptions,\n          null,\n          null,\n          rowIndex,\n          columnIndex,\n          matcher.start(),\n          matcher.end()); // Set node or edge values later\n    } else {\n      return null;\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5616, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [61], "initializationEnd": [121], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 148, "focalAPIEnd": 156, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/europeana/contrib/tree/master/kb/telplus/tpp/src/main/java/org/theeuropeanlibrary/telplus/tpp/AuthorisationManager.java", "rawCode": "  private boolean isIpAddress(String host) {\n    Matcher m = Pattern.compile(\"\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\").matcher(host);\n    return m.find();\n  }\n"}, {"dataset": "find", "exampleID": 5617, "initialization": ["Matcher matcher = getRegex()"], "initializationStart": [743], "initializationEnd": [758], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 778, "focalAPIEnd": 792, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseFromMatcher(matcher)", "matcher.end(int)"], "useStart": [827, 866], "useEnd": [852, 880], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/KommuSoft/SwopKul1011/tree/master/Branches/Proberen040411/ProjectSWOP20102011/src/projectswop20102011/utils/parsers/RegexParser.java", "rawCode": "  /**\n   * Parses the object out of the string returning the number of used characters in the string and\n   * the parsed object.\n   *\n   * @param text The text that will be parsed.\n   * @param parsedObjectHolder An output parameter thet contains a reference to the created object.\n   * @return The number of characters used by the parser.\n   * @throws ParsingException If the given text does not contains a textual representation of the\n   *     object to parse.\n   */\n  @Override\n  public int parse(String text, final ObjectHolder<? super T> parsedObjectHolder)\n      throws ParsingException {\n    if (!canParse(text)) {\n      throw new ParsingException(\"Unable to parse text to a generic type: Invalid format.\");\n    }\n    Matcher matcher = this.getRegex().matcher(text);\n    matcher.find();\n    parsedObjectHolder.setObject(parseFromMatcher(matcher));\n    return matcher.end(0);\n  }\n"}, {"dataset": "find", "exampleID": 5618, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 89, "focalAPIEnd": 103, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/passy/WAKiMail/tree/master/WAKiMail/src/main/java/net/rdrei/android/wakimail/wak/MailIterator.java", "rawCode": "  @Override\n  public boolean hasNext() {\n    // Seriously, I like this a lot.\n    return matcher.find();\n  }\n"}, {"dataset": "find", "exampleID": 5619, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [79], "initializationEnd": [139], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 163, "focalAPIEnd": 177, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group()"], "useStart": [199], "useEnd": [214], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Zenika/DORM/tree/master/core/core/src/main/java/com/zenika/dorm/core/repository/impl/DormRepositoryPatternAssociate.java", "rawCode": "  private String[] getOptions(String property) {\n    Matcher matcher =\n        Pattern.compile(\"\\\\{[A-Z-a-z-0-9.\\\\-+,?;.:§!*%^¨$£{} ]+\\\\}\").matcher(property);\n    matcher.find();\n    String result = matcher.group();\n    result = result.substring(1, result.length() - 1);\n    String[] options = exclude(result.split(\", \"), new String[] {\"optionally\"});\n    return options;\n  }\n"}, {"dataset": "find", "exampleID": 5620, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [136], "initializationEnd": [156], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 181, "focalAPIEnd": 189, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 195, "followUpCheckExpressionEnd": 202, "followUpCheckBlockStart": 195, "followUpCheckBlockEnd": 299, "use": ["matcher.group(int)", "matcher.group(int)"], "useStart": [236, 281], "useEnd": [246, 291], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7363/src/net/sourceforge/plantuml/acearth/PSystemXearthFactory.java", "rawCode": "  private void extractDimension(String startLine) {\n    final Pattern p = Pattern.compile(\"\\\\((\\\\d+),(\\\\d+)\\\\)\");\n    final Matcher m = p.matcher(startLine);\n    final boolean ok = m.find();\n    if (ok) {\n      width = Integer.parseInt(m.group(1));\n      height = Integer.parseInt(m.group(2));\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5621, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [714], "initializationEnd": [733], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 750, "focalAPIEnd": 758, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.start()", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.start()", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)"], "useStart": [739, 776, 825, 813, 882, 870, 972, 960, 1028, 1017, 1054, 1103, 1091, 1239, 1228, 1272, 1300, 1289, 1333, 1362, 1350, 1498, 1487, 1531, 1559, 1548, 1592, 1621, 1609, 1742, 1731, 1775, 1803, 1792, 1836, 1865, 1853, 1986, 1975, 2019, 2047, 2036, 2080, 2109, 2097], "useEnd": [759, 785, 833, 834, 890, 891, 980, 981, 1036, 1037, 1063, 1111, 1112, 1247, 1248, 1282, 1308, 1309, 1343, 1370, 1371, 1506, 1507, 1541, 1567, 1568, 1602, 1629, 1630, 1750, 1751, 1785, 1811, 1812, 1846, 1873, 1874, 1994, 1995, 2029, 2055, 2056, 2090, 2117, 2118], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/regex/src/test/java/org/apache/harmony/regex/tests/java/util/regex/ModeTest.java", "rawCode": "  @TestTargets({\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"The test verifies compile(String regex) and compile(String regex, int flags) methods with Pattern.MULTILINE mode.\",\n      method = \"compile\",\n      args = {java.lang.String.class}\n    ),\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"The test verifies compile(String regex) and compile(String regex, int flags) methods with Pattern.MULTILINE mode.\",\n      method = \"compile\",\n      args = {java.lang.String.class, int.class}\n    )\n  })\n  public void testMultiline() throws PatternSyntaxException {\n    Pattern p;\n    Matcher m;\n\n    p = Pattern.compile(\"^foo\");\n    m = p.matcher(\"foobar\");\n    assertTrue(m.find());\n    assertTrue(m.start() == 0 && m.end() == 3);\n    assertFalse(m.find());\n\n    m = p.matcher(\"barfoo\");\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"foo$\");\n    m = p.matcher(\"foobar\");\n    assertFalse(m.find());\n\n    m = p.matcher(\"barfoo\");\n    assertTrue(m.find());\n    assertTrue(m.start() == 3 && m.end() == 6);\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"^foo([0-9]*)\", Pattern.MULTILINE);\n    m = p.matcher(\"foo1bar\\nfoo2foo3\\nbarfoo4\");\n    assertTrue(m.find());\n    assertEquals(\"1\", m.group(1));\n    assertTrue(m.find());\n    assertEquals(\"2\", m.group(1));\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"foo([0-9]*)$\", Pattern.MULTILINE);\n    m = p.matcher(\"foo1bar\\nfoo2foo3\\nbarfoo4\");\n    assertTrue(m.find());\n    assertEquals(\"3\", m.group(1));\n    assertTrue(m.find());\n    assertEquals(\"4\", m.group(1));\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"(?m)^foo([0-9]*)\");\n    m = p.matcher(\"foo1bar\\nfoo2foo3\\nbarfoo4\");\n    assertTrue(m.find());\n    assertEquals(\"1\", m.group(1));\n    assertTrue(m.find());\n    assertEquals(\"2\", m.group(1));\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"(?m)foo([0-9]*)$\");\n    m = p.matcher(\"foo1bar\\nfoo2foo3\\nbarfoo4\");\n    assertTrue(m.find());\n    assertEquals(\"3\", m.group(1));\n    assertTrue(m.find());\n    assertEquals(\"4\", m.group(1));\n    assertFalse(m.find());\n  }\n"}, {"dataset": "find", "exampleID": 5622, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [241], "initializationEnd": [266], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 279, "focalAPIEnd": 287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.viewer/tree/master/plugins/org.eclipse.birt.report.viewer/birt/WEB-INF/classes/org/eclipse/birt/report/taglib/RequesterTag.java", "rawCode": "  /**\n   * Validate the requester id. Requester id only can include number, letter and underline\n   *\n   * @return\n   */\n  protected boolean __validateRequesterId() {\n    Pattern p = Pattern.compile(\"^\\\\w+$\"); // $NON-NLS-1$\n    Matcher m = p.matcher(viewer.getId());\n    return m.find();\n  }\n"}, {"dataset": "find", "exampleID": 5623, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [1405], "initializationEnd": [1431], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 1518, "focalAPIEnd": 1538, "followUpCheck": "result", "checkType": "LOOP {", "followUpCheckExpressionStart": 1978, "followUpCheckExpressionEnd": 1994, "followUpCheckBlockStart": 1978, "followUpCheckBlockEnd": 5868, "use": ["matcher.appendReplacement(StringBuffer,String)", "matcher.find()", "matcher.appendTail(StringBuffer)"], "useStart": [2266, 5841, 5873], "useEnd": [2318, 5861, 5905], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/acceleo/tree/master/plugins/org.eclipse.acceleo.traceability/src/org/eclipse/acceleo/internal/traceability/engine/AcceleoTraceabilityOperationVisitor.java", "rawCode": "  /**\n   * Handles the \"substitute\" and \"replace\" standard operations directly from the traceability\n   * visitor so as to record accurate traceability information.\n   *\n   * @param source String within which we need to replace substrings.\n   * @param substring The substring that is to be substituted.\n   * @param replacement The String which will be inserted in <em>source</em> where\n   *     <em>substring</em> was.\n   * @param substitutionTrace Traceability information of the replacement.\n   * @param substituteAll Indicates wheter we should substitute all occurences of the substring or\n   *     only the first.\n   * @param useInvocationTrace If <code>true</code>, {@link #invocationTraces} will be altered in\n   *     place of the last {@link AcceleoTraceabilityVisitor#recordedTraces}. Should only be <code>\n   *     true</code> when altering indentation.\n   * @return <em>source</em> with the first occurence of <em>substring</em> replaced by\n   *     <em>replacement</em> or <em>source</em> unchanged if it did not contain <em>substring</em>.\n   */\n  public String visitReplaceOperation(\n      String source,\n      String substring,\n      String replacement,\n      ExpressionTrace<C> substitutionTrace,\n      boolean substituteAll,\n      boolean useInvocationTrace) {\n    if (substring == null || replacement == null) {\n      throw new NullPointerException();\n    }\n\n    Matcher sourceMatcher = Pattern.compile(substring).matcher(source);\n    StringBuffer result = new StringBuffer();\n    boolean hasMatch = sourceMatcher.find();\n    // Note : despite its name, this could be negative\n    int addedLength = 0;\n\n    // protected area indentation markers must be ignored\n    final boolean hasProtectedMarker =\n        source.contains(AcceleoEvaluationVisitor.PROTECTED_AREA_MARKER);\n\n    // FIXME This loop does _not_ take group references into account except \"$0 at the start\"\n    final boolean startsWithZeroGroupRef = replacement.startsWith(\"$0\"); // $NON-NLS-1$\n    while (hasMatch) {\n      // If we've already changed the String size, take it into account\n      int startIndex = sourceMatcher.start() + addedLength;\n      int endIndex = sourceMatcher.end() + addedLength;\n      if (startsWithZeroGroupRef) {\n        startIndex = endIndex;\n      }\n      sourceMatcher.appendReplacement(result, replacement);\n      int replacementLength = result.length() - startIndex;\n      // We now remove from the replacementLength the length of the replaced substring\n      replacementLength -= endIndex - startIndex;\n      addedLength += replacementLength;\n\n      // Note that we could be out of a file block's scope\n      if (useInvocationTrace && visitor.getCurrentFiles().size() > 0) {\n        // We need the starting index of these traces\n        int offsetGap = -1;\n        for (ExpressionTrace<C> trace : visitor.getInvocationTraces()) {\n          for (Map.Entry<InputElement, Set<GeneratedText>> entry : trace.getTraces().entrySet()) {\n            for (GeneratedText text : entry.getValue()) {\n              if (offsetGap == -1 || text.getStartOffset() < offsetGap) {\n                offsetGap = text.getStartOffset();\n              }\n            }\n          }\n        }\n        startIndex += offsetGap;\n        endIndex += offsetGap;\n\n        if (hasProtectedMarker) {\n          int additionalGap = computeAdditionalGap(source, sourceMatcher.start());\n          startIndex += additionalGap;\n          endIndex += additionalGap;\n        }\n\n        for (ExpressionTrace<C> trace : visitor.getInvocationTraces()) {\n          changeTraceabilityIndicesOfReplaceOperation(\n              trace, startIndex, endIndex, replacementLength);\n        }\n        GeneratedFile generatedFile = visitor.getCurrentFiles().getLast();\n        final int fileLength = generatedFile.getLength();\n        for (Map.Entry<InputElement, Set<GeneratedText>> entry :\n            substitutionTrace.getTraces().entrySet()) {\n          for (GeneratedText text : entry.getValue()) {\n            // 3.4 compatibility : EcoreUtil.copy() wasn't generic. The cast is necessary\n            @SuppressWarnings(\"cast\")\n            GeneratedText copy = (GeneratedText) EcoreUtil.copy(text);\n            copy.setStartOffset(copy.getStartOffset() + startIndex);\n            copy.setEndOffset(copy.getEndOffset() + startIndex);\n            generatedFile.getGeneratedRegions().add(copy);\n            Iterator<ExpressionTrace<C>> traceIterator = visitor.getInvocationTraces().iterator();\n            boolean inserted = false;\n            while (traceIterator.hasNext() && !inserted) {\n              inserted = insertTextInTrace(traceIterator.next(), copy);\n            }\n          }\n        }\n        generatedFile.setLength(fileLength + replacementLength);\n      } else {\n        AbstractTrace trace = visitor.getLastExpressionTrace();\n        changeTraceabilityIndicesOfReplaceOperation(trace, startIndex, endIndex, replacementLength);\n        for (Map.Entry<InputElement, Set<GeneratedText>> entry :\n            substitutionTrace.getTraces().entrySet()) {\n          Set<GeneratedText> existingTraces = trace.getTraces().get(entry.getKey());\n          if (existingTraces == null) {\n            existingTraces = new CompactLinkedHashSet<GeneratedText>();\n            trace.getTraces().put(entry.getKey(), existingTraces);\n          }\n          for (GeneratedText text : entry.getValue()) {\n            // 3.4 compatibility : EcoreUtil.copy() wasn't generic. The cast is necessary\n            @SuppressWarnings(\"cast\")\n            GeneratedText copy = (GeneratedText) EcoreUtil.copy(text);\n            copy.setStartOffset(copy.getStartOffset() + startIndex);\n            copy.setEndOffset(copy.getEndOffset() + startIndex);\n            existingTraces.add(copy);\n          }\n        }\n      }\n\n      if (!substituteAll) {\n        // Do once\n        break;\n      }\n      hasMatch = sourceMatcher.find();\n    }\n    sourceMatcher.appendTail(result);\n    return result.toString();\n  }\n"}, {"dataset": "find", "exampleID": 5624, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [206], "initializationEnd": [222], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 243, "focalAPIEnd": 251, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jnharton/mud-server/tree/master/MUDServer/src/mud/utils/Utils.java", "rawCode": "  /**\n   * string matching\n   *\n   * @param input\n   * @param regexp\n   * @return\n   */\n  public static boolean match(String input, String regexp) {\n    Pattern p = Pattern.compile(regexp);\n    Matcher m = p.matcher(input);\n    boolean test = m.find();\n    return test;\n  }\n"}, {"dataset": "find", "exampleID": 5625, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [49], "initializationEnd": [76], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 101, "focalAPIEnd": 109, "followUpCheck": "result == false", "checkType": "IF", "followUpCheckExpressionStart": 115, "followUpCheckExpressionEnd": 131, "followUpCheckBlockStart": 115, "followUpCheckBlockEnd": 183, "use": ["matcher.group(int)"], "useStart": [215], "useEnd": [225], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7726/src/net/sourceforge/plantuml/FileGroup.java", "rawCode": "  private void recurse() {\n    final Matcher m = predirPath.matcher(pattern);\n    final boolean ok = m.find();\n    if (ok == false) {\n      throw new IllegalArgumentException();\n    }\n    final File parent;\n    if (m.group(1) == null) {\n      parent = new File(\".\");\n    } else {\n      parent = new File(m.group(1));\n    }\n    initWithDoubleStar(parent);\n  }\n"}, {"dataset": "find", "exampleID": 5626, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [104], "initializationEnd": [169], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 187, "focalAPIEnd": 195, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertFalse(result)"], "useStart": [175], "useEnd": [196], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TaintDroid/android_platform_libcore/tree/master/luni/src/test/java/libcore/java/util/regex/OldAndroidRegexTest.java", "rawCode": "  public void testMonsterRegexPerformance() {\n    long t0 = System.currentTimeMillis();\n    Matcher m = EMAIL_ADDRESS_PATTERN.matcher(\"donot repeate@RC8jjjjjjjjjjjjjjj\");\n    assertFalse(m.find());\n    long t1 = System.currentTimeMillis();\n    System.out.println(\"RegEx performance test finished, took \" + (t1 - t0) + \" ms.\");\n  }\n"}, {"dataset": "find", "exampleID": 5627, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [139], "initializationEnd": [165], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 182, "focalAPIEnd": 190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)"], "useStart": [171, 217, 246, 234, 378, 367, 413, 441, 430, 476, 505, 493, 615, 604, 650, 678, 667, 713, 742, 730], "useEnd": [191, 227, 254, 255, 386, 387, 423, 449, 450, 486, 513, 514, 623, 624, 660, 686, 687, 723, 750, 751], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/goodow/j2objc/tree/master/jre_emul/android/libcore/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/ModeTest.java", "rawCode": "  public void testCase() throws PatternSyntaxException {\n    Pattern p;\n    Matcher m;\n\n    p = Pattern.compile(\"([a-z]+)[0-9]+\");\n    m = p.matcher(\"cAT123#dog345\");\n    assertTrue(m.find());\n    assertEquals(\"dog\", m.group(1));\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"([a-z]+)[0-9]+\", Pattern.CASE_INSENSITIVE);\n    m = p.matcher(\"cAt123#doG345\");\n    assertTrue(m.find());\n    assertEquals(\"cAt\", m.group(1));\n    assertTrue(m.find());\n    assertEquals(\"doG\", m.group(1));\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"(?i)([a-z]+)[0-9]+\");\n    m = p.matcher(\"cAt123#doG345\");\n    assertTrue(m.find());\n    assertEquals(\"cAt\", m.group(1));\n    assertTrue(m.find());\n    assertEquals(\"doG\", m.group(1));\n    assertFalse(m.find());\n  }\n"}, {"dataset": "find", "exampleID": 5628, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [140], "initializationEnd": [166], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 179, "focalAPIEnd": 200, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mouyang/urlrewrite/tree/master/src/main/java/org/tuckey/web/filters/urlrewrite/substitution/BackReferenceReplacer.java", "rawCode": "  /** look for back reference a % followed by a number */\n  public static boolean containsBackRef(String to) {\n    Matcher backRefMatcher = backRefPattern.matcher(to);\n    return backRefMatcher.find();\n  }\n"}, {"dataset": "find", "exampleID": 5629, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [66], "initializationEnd": [89], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 117, "focalAPIEnd": 125, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "matcher.group(int)"], "useStart": [163, 224], "useEnd": [185, 246], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/orfjackal/jumi/tree/master/end-to-end-tests/src/test/java/fi/jumi/test/TextUIParser.java", "rawCode": "  private void parseFooter(String footerOutput) {\n    Matcher m = Pattern.compile(FOOTER).matcher(footerOutput);\n    m.find();\n    passingCount = Integer.parseInt(m.group(PASSING_COUNT));\n    failingCount = Integer.parseInt(m.group(FAILING_COUNT));\n  }\n"}, {"dataset": "find", "exampleID": 5630, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [463], "initializationEnd": [484], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["logError(*,String)"], "tryExpressionStart": 163, "tryExpressionEnd": 167, "tryBlockStart": 163, "tryBlockEnd": 658, "catchExpressionStart": 553, "catchExpressionEnd": 573, "catchBlockStart": 553, "catchBlockEnd": 658, "exceptionHandlingCallStart": [581], "exceptionHandlingCallEnd": [632], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 492, "focalAPIEnd": 500, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [519], "useEnd": [529], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SmartBear/soapui/tree/master/soapui/src/main/java/com/eviware/soapui/support/GroovyUtils.java", "rawCode": "  /**\n   * extracts error line number from groovy stact trace\n   *\n   * @return line number\n   */\n  public static String extractErrorLineNumber(Throwable t) {\n    try {\n      Writer wresult = new StringWriter();\n      PrintWriter printWriter = new PrintWriter(wresult);\n      t.printStackTrace(printWriter);\n      String stackTrace = wresult.toString();\n\n      Pattern p = Pattern.compile(\"at Script\\\\d+\\\\.run\\\\(Script\\\\d+\\\\.groovy:(\\\\d+)\\\\)\");\n      Matcher m = p.matcher(stackTrace);\n      m.find();\n      String b = m.group(1);\n      return b;\n    } catch (Exception e) {\n      SoapUI.logError(e, \"cannot get error line number!\");\n      return null;\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5631, "initialization": ["Matcher matcher = Pattern.matcher(String)", "Matcher matcher = Pattern.matcher(String)"], "initializationStart": [204, 555], "initializationEnd": [227, 578], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 595, "focalAPIEnd": 605, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.matches()", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertTrue(result)"], "useStart": [584, 758, 931, 919, 1032, 1021, 1216, 1205], "useEnd": [606, 771, 941, 942, 1042, 1043, 1226, 1227], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/PatternTest.java", "rawCode": "  public void testSequencesWithSurrogatesSupplementary() {\n    String patString = \"abcd\\uD8D3\";\n    String testString = \"abcd\\uD8D3\\uDFFC\";\n    Pattern pat = Pattern.compile(patString);\n    Matcher mat = pat.matcher(testString);\n    // BEGIN android-changed\n    // This one really doesn't make sense, as the above is a corrupt surrogate.\n    // Even if it's matched by the JDK, it's more of a bug than of a behavior one\n    // might want to duplicate.\n    // assertFalse(mat.find());\n    // END android-changed\n    testString = \"abcd\\uD8D3abc\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    patString = \"ab\\uDBEFcd\";\n    testString = \"ab\\uDBEFcd\";\n    pat = Pattern.compile(patString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n\n    patString = \"\\uDFFCabcd\";\n    testString = \"\\uD8D3\\uDFFCabcd\";\n    pat = Pattern.compile(patString);\n    mat = pat.matcher(testString);\n    assertFalse(mat.find());\n\n    testString = \"abc\\uDFFCabcdecd\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    patString = \"\\uD8D3\\uDFFCabcd\";\n    testString = \"abc\\uD8D3\\uD8D3\\uDFFCabcd\";\n    pat = Pattern.compile(patString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n  }\n"}, {"dataset": "find", "exampleID": 5632, "initialization": ["Matcher matcher = RegexCache.getPatternForRegex(String)"], "initializationStart": [308], "initializationEnd": [352], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 386, "focalAPIEnd": 394, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group()"], "useStart": [450], "useEnd": [459], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/google-libphonenumber-mirror/tree/master/tags/libphonenumber-3.9/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java", "rawCode": "  private String getFormattingTemplate(String numberPattern, String numberFormat) {\n    // Creates a phone number consisting only of the digit 9 that matches the\n    // numberPattern by applying the pattern to the longestPhoneNumber string.\n    String longestPhoneNumber = \"999999999999999\";\n    Matcher m = regexCache.getPatternForRegex(numberPattern).matcher(longestPhoneNumber);\n    m.find(); // this will always succeed\n    String aPhoneNumber = m.group();\n    // No formatting template can be created if the number of digits entered so far is longer than\n    // the maximum the current formatting rule can accommodate.\n    if (aPhoneNumber.length() < nationalNumber.length()) {\n      return \"\";\n    }\n    // Formats the number according to numberFormat\n    String template = aPhoneNumber.replaceAll(numberPattern, numberFormat);\n    // Replaces each digit with character digitPlaceholder\n    template = template.replaceAll(\"9\", digitPlaceholder);\n    return template;\n  }\n"}, {"dataset": "find", "exampleID": 5633, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 979, "focalAPIEnd": 993, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seweissman/wikiduper/tree/master/src/main/wikiduper/wikipedia/language/GermanWikipediaPage.java", "rawCode": "  @Override\n  protected void processPage(String s) {\n    this.language = LANGUAGE_CODE;\n\n    // parse out title\n    int start = s.indexOf(XML_START_TAG_TITLE);\n    int end = s.indexOf(XML_END_TAG_TITLE, start);\n    this.title = StringEscapeUtils.unescapeHtml(s.substring(start + 7, end));\n\n    // determine if article belongs to the article namespace\n    start = s.indexOf(XML_START_TAG_NAMESPACE);\n    end = s.indexOf(XML_END_TAG_NAMESPACE);\n    this.isArticle = s.substring(start + 4, end).trim().equals(\"0\");\n\n    // parse out the document id\n    start = s.indexOf(XML_START_TAG_ID);\n    end = s.indexOf(XML_END_TAG_ID);\n    this.mId = s.substring(start + 4, end);\n\n    // parse out actual text of article\n    this.textStart = s.indexOf(XML_START_TAG_TEXT);\n    this.textEnd = s.indexOf(XML_END_TAG_TEXT, this.textStart);\n\n    // determine if article is a disambiguation, redirection, and/or stub page.\n    Matcher matcher = disambPattern.matcher(page);\n    this.isDisambig = matcher.find();\n    this.isRedirect =\n        s.substring(\n                        this.textStart + XML_START_TAG_TEXT.length(),\n                        this.textStart\n                            + XML_START_TAG_TEXT.length()\n                            + IDENTIFIER_REDIRECTION_UPPERCASE.length())\n                    .compareTo(IDENTIFIER_REDIRECTION_UPPERCASE)\n                == 0\n            || s.substring(\n                        this.textStart + XML_START_TAG_TEXT.length(),\n                        this.textStart\n                            + XML_START_TAG_TEXT.length()\n                            + IDENTIFIER_REDIRECTION_LOWERCASE.length())\n                    .compareTo(IDENTIFIER_REDIRECTION_LOWERCASE)\n                == 0\n            || s.substring(\n                        this.textStart + XML_START_TAG_TEXT.length(),\n                        this.textStart\n                            + XML_START_TAG_TEXT.length()\n                            + IDENTIFIER_REDIRECTION_UPPERCASE_DE.length())\n                    .compareTo(IDENTIFIER_REDIRECTION_UPPERCASE_DE)\n                == 0\n            || s.substring(\n                        this.textStart + XML_START_TAG_TEXT.length(),\n                        this.textStart\n                            + XML_START_TAG_TEXT.length()\n                            + IDENTIFIER_REDIRECTION_LOWERCASE_DE.length())\n                    .compareTo(IDENTIFIER_REDIRECTION_LOWERCASE_DE)\n                == 0\n            || s.substring(\n                        this.textStart + XML_START_TAG_TEXT.length(),\n                        this.textStart\n                            + XML_START_TAG_TEXT.length()\n                            + IDENTIFIER_REDIRECTION_CAPITALIZED_DE.length())\n                    .compareTo(IDENTIFIER_REDIRECTION_CAPITALIZED_DE)\n                == 0;\n    this.isStub =\n        s.indexOf(IDENTIFIER_STUB_TEMPLATE, this.textStart) != -1\n            || s.indexOf(IDENTIFIER_STUB_WIKIPEDIA_NAMESPACE) != -1;\n  }\n"}, {"dataset": "find", "exampleID": 5634, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [577], "initializationEnd": [600], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(regex.getLength()==start)", "guardType": "IF {", "guardExpressionStart": 123, "guardExpressionEnd": 150, "guardBlockStart": 123, "guardBlockEnd": 432, "focalAPI": "result = matcher.find(start)", "focalAPIStart": 617, "focalAPIEnd": 626, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["set(result)"], "useStart": [606], "useEnd": [627], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zerovm/impala-port/tree/master/thirdparty/hive-0.10.0-cdh4.3.0/src/ql/src/java/org/apache/hadoop/hive/ql/udf/UDFRegExp.java", "rawCode": "  public BooleanWritable evaluate(Text s, Text regex) {\n    if (s == null || regex == null) {\n      return null;\n    }\n    if (regex.getLength() == 0) {\n      if (!warned) {\n        warned = true;\n        LOG.warn(\n            getClass().getSimpleName()\n                + \" regex is empty. Additional \"\n                + \"warnings for an empty regex will be suppressed.\");\n      }\n      result.set(false);\n      return result;\n    }\n    if (!regex.equals(lastRegex) || p == null) {\n      lastRegex.set(regex);\n      p = Pattern.compile(regex.toString());\n    }\n    Matcher m = p.matcher(s.toString());\n    result.set(m.find(0));\n    return result;\n  }\n"}, {"dataset": "find", "exampleID": 5635, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [199], "initializationEnd": [225], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 266, "focalAPIEnd": 274, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 291, "followUpCheckExpressionEnd": 305, "followUpCheckBlockStart": 291, "followUpCheckBlockEnd": 371, "use": ["matcher.find()"], "useStart": [277], "useEnd": [285], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tdsoul/drftpd/tree/master/src/plugins/org.drftpd.slaveselection.filter/src/org/drftpd/slaveselection/filter/MatchdirExFilter.java", "rawCode": "  public void process(\n      ScoreChart scorechart,\n      User user,\n      InetAddress source,\n      char direction,\n      InodeHandleInterface file,\n      RemoteSlave sourceSlave) {\n    Matcher m = _p.matcher(file.getPath());\n    boolean validPath = _negateExpr ? !m.find() : m.find();\n    if (validPath) {\n      AssignSlave.addScoresToChart(_assigns, scorechart);\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5636, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [229], "initializationEnd": [265], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 271, "focalAPIEnd": 279, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [321], "useEnd": [331], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TeamNyx/sdk/tree/master/ddms/libs/ddmuilib/src/com/android/ddmuilib/logcat/LogCatStackTraceParser.java", "rawCode": "  /**\n   * Get line number where exception was generated. Input line must be first validated with {@link\n   * LogCatStackTraceParser#isValidExceptionTrace(String)}.\n   */\n  public int getLineNumber(String line) {\n    Matcher m = EXCEPTION_LINE_PATTERN.matcher(line);\n    m.find();\n    try {\n      return Integer.parseInt(m.group(3));\n    } catch (NumberFormatException e) {\n      return 0;\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5637, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [148], "initializationEnd": [184], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 201, "focalAPIEnd": 209, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.start()", "matcher.end()", "matcher.groupCount()", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group()", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.start()", "matcher.end()", "matcher.groupCount()", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group()", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.start()", "matcher.end()", "matcher.groupCount()", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group()", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.find()", "assertFalse(result)"], "useStart": [190, 232, 264, 294, 331, 364, 395, 428, 459, 492, 529, 567, 603, 639, 668, 657, 699, 732, 762, 800, 831, 864, 895, 929, 966, 1004, 1040, 1077, 1106, 1095, 1138, 1171, 1201, 1239, 1273, 1305, 1339, 1371, 1405, 1445, 1486, 1523, 1561, 1590, 1578], "useEnd": [210, 241, 271, 308, 341, 372, 405, 436, 469, 500, 538, 577, 613, 649, 676, 677, 708, 739, 776, 808, 841, 872, 905, 937, 975, 1014, 1050, 1087, 1114, 1115, 1147, 1178, 1215, 1249, 1281, 1315, 1347, 1381, 1413, 1454, 1496, 1533, 1571, 1598, 1599], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rwl/j2objc/tree/master/jre_emul/apache_harmony/classlib/modules/regex/src/test/java/org/apache/harmony/tests/java/util/regex/Pattern2Test.java", "rawCode": "  public void testGroups() throws PatternSyntaxException {\n    Pattern p;\n    Matcher m;\n\n    p = Pattern.compile(\"(p[0-9]*)#?(q[0-9]*)\");\n\n    m = p.matcher(\"p1#q3p2q42p5p71p63#q888\");\n    assertTrue(m.find());\n    assertEquals(0, m.start());\n    assertEquals(5, m.end());\n    assertEquals(2, m.groupCount());\n    assertEquals(0, m.start(0));\n    assertEquals(5, m.end(0));\n    assertEquals(0, m.start(1));\n    assertEquals(2, m.end(1));\n    assertEquals(3, m.start(2));\n    assertEquals(5, m.end(2));\n    assertEquals(\"p1#q3\", m.group());\n    assertEquals(\"p1#q3\", m.group(0));\n    assertEquals(\"p1\", m.group(1));\n    assertEquals(\"q3\", m.group(2));\n\n    assertTrue(m.find());\n    assertEquals(5, m.start());\n    assertEquals(10, m.end());\n    assertEquals(2, m.groupCount());\n    assertEquals(10, m.end(0));\n    assertEquals(5, m.start(1));\n    assertEquals(7, m.end(1));\n    assertEquals(7, m.start(2));\n    assertEquals(10, m.end(2));\n    assertEquals(\"p2q42\", m.group());\n    assertEquals(\"p2q42\", m.group(0));\n    assertEquals(\"p2\", m.group(1));\n    assertEquals(\"q42\", m.group(2));\n\n    assertTrue(m.find());\n    assertEquals(15, m.start());\n    assertEquals(23, m.end());\n    assertEquals(2, m.groupCount());\n    assertEquals(15, m.start(0));\n    assertEquals(23, m.end(0));\n    assertEquals(15, m.start(1));\n    assertEquals(18, m.end(1));\n    assertEquals(19, m.start(2));\n    assertEquals(23, m.end(2));\n    assertEquals(\"p63#q888\", m.group());\n    assertEquals(\"p63#q888\", m.group(0));\n    assertEquals(\"p63\", m.group(1));\n    assertEquals(\"q888\", m.group(2));\n    assertFalse(m.find());\n  }\n"}, {"dataset": "find", "exampleID": 5638, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [190], "initializationEnd": [227], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 245, "focalAPIEnd": 253, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.start()", "matcher.end()", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.start()", "matcher.end()", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)"], "useStart": [234, 276, 308, 338, 371, 402, 435, 463, 592, 719, 848, 978, 1106, 1235, 1224, 1266, 1299, 1329, 1363, 1395, 1429, 1457, 1586, 1713, 1842, 1972, 2100, 2230, 2218, 2258, 2379, 2498, 2619, 2741, 2861], "useEnd": [254, 285, 315, 348, 379, 412, 443, 473, 600, 729, 859, 987, 1117, 1243, 1244, 1275, 1306, 1339, 1371, 1405, 1437, 1467, 1594, 1723, 1853, 1981, 2111, 2238, 2239, 2268, 2387, 2508, 2630, 2750, 2872], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/Matcher2Test.java", "rawCode": "  public void testErrorConditions2() throws PatternSyntaxException {\n    // Test match cursors in absence of a match\n    Pattern p = Pattern.compile(\"(foo[0-9])(bar[a-z])\");\n    Matcher m = p.matcher(\"foo1barzfoo2baryfoozbar5\");\n\n    assertTrue(m.find());\n    assertEquals(0, m.start());\n    assertEquals(8, m.end());\n    assertEquals(0, m.start(1));\n    assertEquals(4, m.end(1));\n    assertEquals(4, m.start(2));\n    assertEquals(8, m.end(2));\n\n    try {\n      m.start(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.end(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.group(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.start(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.end(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.group(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    assertTrue(m.find());\n    assertEquals(8, m.start());\n    assertEquals(16, m.end());\n    assertEquals(8, m.start(1));\n    assertEquals(12, m.end(1));\n    assertEquals(12, m.start(2));\n    assertEquals(16, m.end(2));\n\n    try {\n      m.start(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.end(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.group(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.start(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.end(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.group(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    assertFalse(m.find());\n\n    try {\n      m.start(3);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n\n    try {\n      m.end(3);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n\n    try {\n      m.group(3);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n\n    try {\n      m.start(-1);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n\n    try {\n      m.end(-1);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n\n    try {\n      m.group(-1);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5639, "initialization": ["Matcher matcher = compile(String,int)"], "initializationStart": [1618], "initializationEnd": [1652], "hasTryCatch": 1, "exceptionType": "PatternSyntaxException", "exceptionHandlingCall": ["new DataException(*,*,String)"], "tryExpressionStart": 1594, "tryExpressionEnd": 1598, "tryBlockStart": 1594, "tryBlockEnd": 1819, "catchExpressionStart": 1702, "catchExpressionEnd": 1735, "catchBlockStart": 1702, "catchBlockEnd": 1819, "exceptionHandlingCallStart": [1749], "exceptionHandlingCallEnd": [1812], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 1686, "focalAPIEnd": 1694, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.data/tree/master/plugins/org.eclipse.birt.data/src/org/eclipse/birt/data/engine/script/ScriptEvalUtil.java", "rawCode": "  private static boolean match(Object source, Object pattern) throws DataException {\n    String sourceStr = null;\n    try {\n      sourceStr = (source == null) ? \"\" : DataTypeUtil.toLocaleNeutralString(source);\n    } catch (BirtException e1) {\n      throw new DataException(e1.getLocalizedMessage(), e1);\n    }\n    String patternStr;\n    try {\n      patternStr = (pattern == null) ? \"\" : DataTypeUtil.toLocaleNeutralString(pattern);\n    } catch (BirtException e1) {\n      throw new DataException(e1.getLocalizedMessage(), e1);\n    }\n\n    // Pattern can be one of the following:\n    // (1)Java regular expression pattern\n    // (2)JavaScript RegExp construction syntax: \"/RegExpr/[flags]\", where flags\n    // can be a combination of 'g', 'm', 'i'\n    Matcher jsReExprMatcher = getJSReExprPatternMatcher(patternStr);\n    int flags = 0;\n    if (jsReExprMatcher.matches()) {\n      // This is a Javascript syntax\n      // Get the flags; we only expect \"m\", \"i\", \"g\"\n      String flagStr = patternStr.substring(jsReExprMatcher.start(2), jsReExprMatcher.end(2));\n      for (int i = 0; i < flagStr.length(); i++) {\n        switch (flagStr.charAt(i)) {\n          case 'm':\n            flags |= Pattern.MULTILINE;\n            break;\n          case 'i':\n            flags |= Pattern.CASE_INSENSITIVE;\n            break;\n          case 'g':\n            break; // this flag has no effect\n\n          default:\n            throw new DataException(ResourceConstants.MATCH_ERROR, patternStr);\n        }\n      }\n      patternStr = patternStr.substring(jsReExprMatcher.start(1), jsReExprMatcher.end(1));\n    }\n\n    try {\n      Matcher m = Pattern.compile(patternStr, flags).matcher(sourceStr);\n      return m.find();\n    } catch (PatternSyntaxException e) {\n      throw new DataException(ResourceConstants.MATCH_ERROR, e, patternStr);\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5640, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [104], "initializationEnd": [169], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 187, "focalAPIEnd": 195, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertFalse(result)"], "useStart": [175], "useEnd": [196], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/libcore/java/util/regex/OldAndroidRegexTest.java", "rawCode": "  public void testMonsterRegexPerformance() {\n    long t0 = System.currentTimeMillis();\n    Matcher m = EMAIL_ADDRESS_PATTERN.matcher(\"donot repeate@RC8jjjjjjjjjjjjjjj\");\n    assertFalse(m.find());\n    long t1 = System.currentTimeMillis();\n    System.out.println(\"RegEx performance test finished, took \" + (t1 - t0) + \" ms.\");\n  }\n"}, {"dataset": "find", "exampleID": 5641, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [291], "initializationEnd": [318], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 342, "focalAPIEnd": 354, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)"], "useStart": [324, 389, 470, 452, 518], "useEnd": [355, 403, 482, 483, 532], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SeqWare/seqware/tree/master/seqware-webservice/src/test/java/net/sourceforge/seqware/pipeline/plugins/GenericMetadataSaverTest.java", "rawCode": "  @Test\n  public void testMatcher() {\n    String string =\n        \"[SeqWare Pipeline] ERROR [2012/11/01 15:53:51] | \"\n            + \"MetadataWS.findObject with search string /288023 encountered error \"\n            + \"Internal Server Error\\nExperiment: null\\nSWID: 6740\";\n    Matcher match = swidPattern.matcher(string);\n    Assert.assertTrue(match.find());\n    Assert.assertEquals(\"6740\", match.group(1));\n    match = errorPattern.matcher(string);\n    Assert.assertTrue(match.find());\n    Assert.assertEquals(\"ERROR\", match.group(0));\n  }\n"}, {"dataset": "find", "exampleID": 5642, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [112], "initializationEnd": [134], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 148, "focalAPIEnd": 167, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["print(result)", "matcher.reset(String)", "matcher.find()", "print(result)"], "useStart": [142, 177, 217, 211], "useEnd": [168, 203, 236, 237], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/loveingenioustech/Study/tree/master/java-demo/src/regex/RegexAPIDemo.java", "rawCode": "  private void create() {\n\n    try {\n      Pattern regex = Pattern.compile(\"He\");\n\n      Matcher regexMatcher = regex.matcher(\"Hello\");\n      print(regexMatcher.find());\n\n      regexMatcher.reset(\"HaHa\");\n      print(regexMatcher.find());\n\n    } catch (PatternSyntaxException ex) {\n      // Syntax error in the regular expression\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5643, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [124], "initializationEnd": [143], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()"], "configurationStart": [160], "configurationEnd": [172], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find(start)", "focalAPIStart": 190, "focalAPIEnd": 200, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.lookingAt()"], "useStart": [179, 218], "useEnd": [201, 232], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/Pattern2Test.java", "rawCode": "  public void testSimpleMatch() throws PatternSyntaxException {\n    Pattern p = Pattern.compile(\"foo.*\");\n\n    Matcher m1 = p.matcher(\"foo123\");\n    assertTrue(m1.matches());\n    assertTrue(m1.find(0));\n    assertTrue(m1.lookingAt());\n\n    Matcher m2 = p.matcher(\"fox\");\n    assertFalse(m2.matches());\n    assertFalse(m2.find(0));\n    assertFalse(m2.lookingAt());\n\n    assertTrue(Pattern.matches(\"foo.*\", \"foo123\"));\n    assertFalse(Pattern.matches(\"foo.*\", \"fox\"));\n\n    assertFalse(Pattern.matches(\"bar\", \"foobar\"));\n\n    assertTrue(Pattern.matches(\"\", \"\"));\n  }\n"}, {"dataset": "find", "exampleID": 5644, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [154], "initializationEnd": [166], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 172, "focalAPIEnd": 180, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [193], "useEnd": [203], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7177/src/net/sourceforge/plantuml/cucadiagram/dot/CucaDiagramFileMaker.java", "rawCode": "  private static String getValue(String s, String param) {\n    final Pattern p = Pattern.compile(\"(?i)\" + param + \"=\\\"([^\\\"]+)\\\"\");\n    final Matcher m = p.matcher(s);\n    m.find();\n    return m.group(1);\n  }\n"}, {"dataset": "find", "exampleID": 5645, "initialization": ["Matcher matcher = RegexCache.getPatternForRegex(String)"], "initializationStart": [308], "initializationEnd": [352], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 386, "focalAPIEnd": 394, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group()"], "useStart": [450], "useEnd": [459], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/google-libphonenumber-mirror/tree/master/tags/libphonenumber-3.4/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java", "rawCode": "  private String getFormattingTemplate(String numberPattern, String numberFormat) {\n    // Creates a phone number consisting only of the digit 9 that matches the\n    // numberPattern by applying the pattern to the longestPhoneNumber string.\n    String longestPhoneNumber = \"999999999999999\";\n    Matcher m = regexCache.getPatternForRegex(numberPattern).matcher(longestPhoneNumber);\n    m.find(); // this will always succeed\n    String aPhoneNumber = m.group();\n    // Formats the number according to numberFormat\n    String template = aPhoneNumber.replaceAll(numberPattern, numberFormat);\n    // Replaces each digit with character digitPlaceholder\n    template = template.replaceAll(\"9\", digitPlaceholder);\n    return template;\n  }\n"}, {"dataset": "find", "exampleID": 5646, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 1547, "focalAPIEnd": 1559, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ksheedlo/closure-compiler/tree/master/lib/rhino/src/org/mozilla/javascript/RhinoException.java", "rawCode": "  /**\n   * Get the script stack of this exception as an array of {@link ScriptStackElement}s. If\n   * optimization is enabled, this includes java stack elements whose source and method names\n   * suggest they have been generated by the Rhino script compiler.\n   *\n   * @return the script stack for this exception\n   * @since 1.7R3\n   */\n  public ScriptStackElement[] getScriptStack() {\n    List<ScriptStackElement> list = new ArrayList<ScriptStackElement>();\n    ScriptStackElement[][] interpreterStack = null;\n    if (interpreterStackInfo != null) {\n      Evaluator interpreter = Context.createInterpreter();\n      if (interpreter instanceof Interpreter)\n        interpreterStack = ((Interpreter) interpreter).getScriptStackElements(this);\n    }\n    int interpreterStackIndex = 0;\n    StackTraceElement[] stack = getStackTrace();\n    // Pattern to recover function name from java method name -\n    // see Codegen.getBodyMethodName()\n    // kudos to Marc Guillemot for coming up with this\n    Pattern pattern = Pattern.compile(\"_c_(.*)_\\\\d+\");\n    for (StackTraceElement e : stack) {\n      String fileName = e.getFileName();\n      if (e.getMethodName().startsWith(\"_c_\")\n          && e.getLineNumber() > -1\n          && fileName != null\n          && !fileName.endsWith(\".java\")) {\n        String methodName = e.getMethodName();\n        Matcher match = pattern.matcher(methodName);\n        // the method representing the main script is always \"_c_script_0\" -\n        // at least we hope so\n        methodName = !\"_c_script_0\".equals(methodName) && match.find() ? match.group(1) : null;\n        list.add(new ScriptStackElement(fileName, methodName, e.getLineNumber()));\n      } else if (\"org.mozilla.javascript.Interpreter\".equals(e.getClassName())\n          && \"interpretLoop\".equals(e.getMethodName())\n          && interpreterStack != null\n          && interpreterStack.length > interpreterStackIndex) {\n        for (ScriptStackElement elem : interpreterStack[interpreterStackIndex++]) {\n          list.add(elem);\n        }\n      }\n    }\n    return list.toArray(new ScriptStackElement[list.size()]);\n  }\n"}, {"dataset": "find", "exampleID": 5647, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [655], "initializationEnd": [677], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 719, "focalAPIEnd": 733, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(boolean,result)", "matcher.find()", "assertEquals(boolean,result)", "matcher.find()", "assertEquals(boolean,result)"], "useStart": [700, 886, 866, 1061, 1041], "useEnd": [734, 900, 901, 1075, 1076], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.engine/tree/master/tests/org.eclipse.birt.report.engine.emitter.html.tests/test/org/eclipse/birt/report/engine/emitter/html/StyleTest.java", "rawCode": "  public void testCSSStyleClass() throws EngineException, IOException {\n    HTMLRenderOption options = new HTMLRenderOption();\n    options.setEmbeddable(true);\n    options.setEnableInlineStyle(false);\n\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\n    List instanceIDs = new ArrayList();\n    options.setInstanceIDs(instanceIDs);\n    options.setOutputStream(output);\n    IRenderTask task = createRenderTask(designFile);\n    task.setRenderOption(options);\n    task.render();\n    task.close();\n    String content = new String(output.toByteArray());\n    output.close();\n\n    String regex = \"<style type=\\\"text/css\\\">\";\n    Matcher matcher = Pattern.compile(regex).matcher(content);\n    assertEquals(true, matcher.find());\n\n    regex = \"<div[^<>]*class=\\\"[^<>]*CustomerStyle[^<>]*>aaaa</div>\";\n    matcher = Pattern.compile(regex).matcher(content);\n    assertEquals(false, matcher.find());\n\n    regex = \"<div[^<>]*style=\\\"[^<>]*color: rgb(255, 0, 0)[^<>]*>aaaa</div>\";\n    matcher = Pattern.compile(regex).matcher(content);\n    assertEquals(false, matcher.find());\n  }\n"}, {"dataset": "find", "exampleID": 5648, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(matcher==null)", "guardType": "IF {", "guardExpressionStart": 64, "guardExpressionEnd": 84, "guardBlockStart": 64, "guardBlockEnd": 98, "focalAPI": "result = matcher.find()", "focalAPIStart": 271, "focalAPIEnd": 285, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 295, "followUpCheckExpressionEnd": 307, "followUpCheckBlockStart": 295, "followUpCheckBlockEnd": 474, "use": ["matcher.start()", "matcher.end()"], "useStart": [326, 359], "useEnd": [341, 372], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ieure/lucene-solr-snapshot/tree/master/modules/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/PatternAnalyzer.java", "rawCode": "    @Override\n    public final boolean incrementToken() {\n      if (matcher == null) return false;\n      clearAttributes();\n      while (true) { // loop takes care of leading and trailing boundary cases\n        int start = pos;\n        int end;\n        boolean isMatch = matcher.find();\n        if (isMatch) {\n          end = matcher.start();\n          pos = matcher.end();\n        } else {\n          end = str.length();\n          matcher = null; // we're finished\n        }\n\n        if (start != end) { // non-empty match (header/trailer)\n          String text = str.substring(start, end);\n          if (toLowerCase) text = text.toLowerCase(locale);\n          termAtt.setEmpty().append(text);\n          offsetAtt.setOffset(start, end);\n          return true;\n        }\n        if (!isMatch) return false;\n      }\n    }\n"}, {"dataset": "find", "exampleID": 5649, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [86], "initializationEnd": [114], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.region(int,int)"], "configurationStart": [121], "configurationEnd": [136], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 153, "focalAPIEnd": 161, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertFalse(result)", "matcher.region(int,int)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertFalse(result)", "matcher.region(int,int)", "matcher.find()", "assertFalse(result)", "matcher.region(int,int)", "matcher.region(int,int)"], "useStart": [142, 179, 168, 206, 194, 222, 254, 243, 281, 269, 297, 331, 319, 384, 518], "useEnd": [162, 187, 188, 214, 215, 237, 262, 263, 289, 290, 313, 339, 340, 400, 533], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/libcore/java/util/regex/OldMatcherTest.java", "rawCode": "  public void testRegion() {\n    Pattern p = Pattern.compile(\"abba\");\n    Matcher m = p.matcher(\"Gabba gabba hey\");\n\n    m.region(0, 15);\n    assertTrue(m.find());\n    assertTrue(m.find());\n    assertFalse(m.find());\n\n    m.region(5, 15);\n    assertTrue(m.find());\n    assertFalse(m.find());\n\n    m.region(10, 15);\n    assertFalse(m.find());\n\n    Throwable t = null;\n\n    try {\n      m.region(-1, 15);\n    } catch (IndexOutOfBoundsException e) {\n      t = e;\n    }\n    assertNotNull(t);\n\n    t = null;\n    try {\n      m.region(0, 16);\n    } catch (IndexOutOfBoundsException e) {\n      t = e;\n    }\n    assertNotNull(t);\n  }\n"}, {"dataset": "find", "exampleID": 5650, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [151], "initializationEnd": [165], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 184, "focalAPIEnd": 192, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertFalse(result)"], "useStart": [172], "useEnd": [193], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rwl/j2objc/tree/master/jre_emul/apache_harmony/classlib/modules/regex/src/test/java/org/apache/harmony/tests/java/util/regex/MatcherTest.java", "rawCode": "  /** Inspired by HARMONY-3360 */\n  public void test3360() {\n    String str = \"!\\\"#%&'(),-./\";\n    Pattern p = Pattern.compile(\"\\\\s\");\n    Matcher m = p.matcher(str);\n\n    assertFalse(m.find());\n  }\n"}, {"dataset": "find", "exampleID": 5651, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [374], "initializationEnd": [401], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 427, "focalAPIEnd": 435, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 445, "followUpCheckExpressionEnd": 455, "followUpCheckBlockStart": 445, "followUpCheckBlockEnd": 518, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 741, "finallyExpressionEnd": 749, "finallyBlockStart": 741, "finallyBlockEnd": 774, "cleanUpCallStart": [757], "cleanUpCallEnd": [767], "url": "https://github.com/vaadin/gwt/tree/master/dev/codeserver/java/com/google/gwt/dev/codeserver/WebServer.java", "rawCode": "  /**\n   * Copies in to out line by line, escaping each line for html characters and highlighting error\n   * lines. Closes <code>in</code> when done.\n   */\n  private static void sendLogAsHtml(BufferedReader in, HtmlWriter out) throws IOException {\n    try {\n      out.startTag(\"pre\").nl();\n      String line = in.readLine();\n      while (line != null) {\n        Matcher m = ERROR_PATTERN.matcher(line);\n        boolean error = m.find();\n        if (error) {\n          out.startTag(\"span\", \"class=\", \"error\");\n        }\n        out.text(line);\n        if (error) {\n          out.endTag(\"span\");\n        }\n        out.nl(); // the readLine doesn't include the newline.\n        line = in.readLine();\n      }\n      out.endTag(\"pre\").nl();\n    } finally {\n      in.close();\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5652, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [139], "initializationEnd": [165], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 182, "focalAPIEnd": 190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)"], "useStart": [171, 217, 246, 234, 378, 367, 413, 441, 430, 476, 505, 493, 615, 604, 650, 678, 667, 713, 742, 730], "useEnd": [191, 227, 254, 255, 386, 387, 423, 449, 450, 486, 513, 514, 623, 624, 660, 686, 687, 723, 750, 751], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wsot/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/ModeTest.java", "rawCode": "  public void testCase() throws PatternSyntaxException {\n    Pattern p;\n    Matcher m;\n\n    p = Pattern.compile(\"([a-z]+)[0-9]+\");\n    m = p.matcher(\"cAT123#dog345\");\n    assertTrue(m.find());\n    assertEquals(\"dog\", m.group(1));\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"([a-z]+)[0-9]+\", Pattern.CASE_INSENSITIVE);\n    m = p.matcher(\"cAt123#doG345\");\n    assertTrue(m.find());\n    assertEquals(\"cAt\", m.group(1));\n    assertTrue(m.find());\n    assertEquals(\"doG\", m.group(1));\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"(?i)([a-z]+)[0-9]+\");\n    m = p.matcher(\"cAt123#doG345\");\n    assertTrue(m.find());\n    assertEquals(\"cAt\", m.group(1));\n    assertTrue(m.find());\n    assertEquals(\"doG\", m.group(1));\n    assertFalse(m.find());\n  }\n"}, {"dataset": "find", "exampleID": 5653, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [719], "initializationEnd": [741], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 783, "focalAPIEnd": 797, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(boolean,result)"], "useStart": [764], "useEnd": [798], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.engine/tree/master/tests/org.eclipse.birt.report.engine.emitter.html.tests/test/org/eclipse/birt/report/engine/emitter/html/HTMLEmitterOptimizeTest.java", "rawCode": "  public void testVisionOptimize() throws EngineException, IOException {\n    HTMLRenderOption options = new HTMLRenderOption();\n    options.setEnableAgentStyleEngine(false);\n    options.setEmbeddable(true);\n\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\n    List instanceIDs = new ArrayList();\n    options.setInstanceIDs(instanceIDs);\n    options.setOutputStream(output);\n    // options.setEnableMetadata( true );\n    IRenderTask task = createRenderTask(designFile);\n    task.setRenderOption(options);\n    task.render();\n    task.close();\n    String content = new String(output.toByteArray());\n    output.close();\n\n    String regex = \"<div style=\\\" text-decoration: underline;\";\n    Matcher matcher = Pattern.compile(regex).matcher(content);\n    assertEquals(true, matcher.find());\n  }\n"}, {"dataset": "find", "exampleID": 5654, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [70], "initializationEnd": [105], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 119, "focalAPIEnd": 127, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mogotest/selenium/tree/master/remote/server/src/java/org/openqa/selenium/server/SessionExtensionJsHandler.java", "rawCode": "  private String getSessionId(String pathInContext) {\n    Matcher m = PATH_PATTERN.matcher(pathInContext);\n    return (m.find() ? m.group(1) : null);\n  }\n"}, {"dataset": "find", "exampleID": 5655, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [125], "initializationEnd": [168], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 193, "focalAPIEnd": 201, "followUpCheck": "result == false", "checkType": "IF", "followUpCheckExpressionStart": 207, "followUpCheckExpressionEnd": 223, "followUpCheckBlockStart": 207, "followUpCheckBlockEnd": 250, "use": ["matcher.group(int)"], "useStart": [277], "useEnd": [287], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7746/src/net/sourceforge/plantuml/BlockUml.java", "rawCode": "  public String getFilename() {\n    if (OptionFlags.getInstance().isWord()) {\n      return null;\n    }\n    final Matcher m = patternFilename.matcher(data.get(0).trim());\n    final boolean ok = m.find();\n    if (ok == false) {\n      return null;\n    }\n    final String result = m.group(1);\n    for (int i = 0; i < result.length(); i++) {\n      final char c = result.charAt(i);\n      if (\"<>|\".indexOf(c) != -1) {\n        return null;\n      }\n    }\n    return result;\n  }\n"}, {"dataset": "find", "exampleID": 5656, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [124], "initializationEnd": [143], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()"], "configurationStart": [160], "configurationEnd": [172], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find(start)", "focalAPIStart": 190, "focalAPIEnd": 200, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.lookingAt()"], "useStart": [179, 218], "useEnd": [201, 232], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rwl/j2objc/tree/master/jre_emul/apache_harmony/classlib/modules/regex/src/test/java/org/apache/harmony/tests/java/util/regex/Pattern2Test.java", "rawCode": "  public void testSimpleMatch() throws PatternSyntaxException {\n    Pattern p = Pattern.compile(\"foo.*\");\n\n    Matcher m1 = p.matcher(\"foo123\");\n    assertTrue(m1.matches());\n    assertTrue(m1.find(0));\n    assertTrue(m1.lookingAt());\n\n    Matcher m2 = p.matcher(\"fox\");\n    assertFalse(m2.matches());\n    assertFalse(m2.find(0));\n    assertFalse(m2.lookingAt());\n\n    assertTrue(Pattern.matches(\"foo.*\", \"foo123\"));\n    assertFalse(Pattern.matches(\"foo.*\", \"fox\"));\n\n    assertFalse(Pattern.matches(\"bar\", \"foobar\"));\n  }\n"}, {"dataset": "find", "exampleID": 5657, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [408], "initializationEnd": [427], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "fail(*)", "printStackTrace()"], "tryExpressionStart": 82, "tryExpressionEnd": 86, "tryBlockStart": 82, "tryBlockEnd": 596, "catchExpressionStart": 504, "catchExpressionEnd": 525, "catchBlockStart": 504, "catchBlockEnd": 596, "exceptionHandlingCallStart": [545, 533, 569], "exceptionHandlingCallEnd": [560, 561, 589], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 487, "focalAPIEnd": 495, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(String,result)"], "useStart": [435], "useEnd": [496], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fcrepo/fcrepo-before33/tree/master/fcrepo-integrationtest/src/test/java/fedora/test/fesl/restapi/TestREST.java", "rawCode": "  @Test\n  public void testGetNextPID() {\n    log.info(\"[ testGetNextPID ]\");\n\n    try {\n      String url = \"/fedora/objects/nextPID\";\n      String response = httpUtils.post(url);\n      if (log.isDebugEnabled()) {\n        log.debug(\"http response:\\n\" + response);\n      }\n\n      String regex = \".*<td align=\\\"left\\\">.+\\\\:.+</td>.*\";\n      Pattern p = Pattern.compile(regex, Pattern.DOTALL);\n      Matcher m = p.matcher(response);\n      Assert.assertTrue(\"Expected object data not found\", m.find());\n    } catch (Exception re) {\n      Assert.fail(re.getMessage());\n      re.printStackTrace();\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5658, "initialization": ["Matcher matcher = RegexCache.getPatternForRegex(String)"], "initializationStart": [308], "initializationEnd": [352], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 386, "focalAPIEnd": 394, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group()"], "useStart": [450], "useEnd": [459], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/google-libphonenumber-mirror/tree/master/tags/libphonenumber-4.2/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java", "rawCode": "  private String getFormattingTemplate(String numberPattern, String numberFormat) {\n    // Creates a phone number consisting only of the digit 9 that matches the\n    // numberPattern by applying the pattern to the longestPhoneNumber string.\n    String longestPhoneNumber = \"999999999999999\";\n    Matcher m = regexCache.getPatternForRegex(numberPattern).matcher(longestPhoneNumber);\n    m.find(); // this will always succeed\n    String aPhoneNumber = m.group();\n    // No formatting template can be created if the number of digits entered so far is longer than\n    // the maximum the current formatting rule can accommodate.\n    if (aPhoneNumber.length() < nationalNumber.length()) {\n      return \"\";\n    }\n    // Formats the number according to numberFormat\n    String template = aPhoneNumber.replaceAll(numberPattern, numberFormat);\n    // Replaces each digit with character digitPlaceholder\n    template = template.replaceAll(\"9\", digitPlaceholder);\n    return template;\n  }\n"}, {"dataset": "find", "exampleID": 5659, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.reset(String)"], "configurationStart": [112], "configurationEnd": [154], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 169, "focalAPIEnd": 183, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tmyroadctfig/swingx/tree/master/swingx-core/src/main/java/org/jdesktop/swingx/sort/RowFilters.java", "rawCode": "    @Override\n    protected boolean include(Entry<? extends Object, ? extends Object> value, int index) {\n      matcher.reset(value.getStringValue(index));\n      return matcher.find();\n    }\n"}, {"dataset": "find", "exampleID": 5660, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [205], "initializationEnd": [235], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 249, "focalAPIEnd": 257, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Adobe-Consulting-Services/acs-aem-commons/tree/master/bundle/src/main/java/com/adobe/acs/commons/util/TextUtil.java", "rawCode": "  /**\n   * Looks for <..> substrings in the parameter string. If any are found it assume Rich text.\n   *\n   * @param str\n   * @return\n   */\n  public static boolean isRichText(String str) {\n    Matcher m = RICH_TEXT_PATTERN.matcher(str);\n\n    return m.find();\n  }\n"}, {"dataset": "find", "exampleID": 5661, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [114], "initializationEnd": [141], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 164, "focalAPIEnd": 178, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bwagner/dtbook-preptools/tree/master/test_src/ch/sbs/utils/preptools/RegexMeasureTest.java", "rawCode": "  private static Matcher makeMatcher(final String thePattern, final String theText) {\n    final Matcher matcher = Pattern.compile(thePattern).matcher(theText);\n    matcher.find();\n    return matcher;\n  }\n"}, {"dataset": "find", "exampleID": 5662, "initialization": ["Matcher matcher = Pattern.matcher(StringBuffer)"], "initializationStart": [1424], "initializationEnd": [1459], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 1543, "focalAPIEnd": 1566, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.appendReplacement(StringBuffer,String)", "matcher.appendTail(StringBuffer)"], "useStart": [1663, 1831], "useEnd": [1722, 1869], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/idega/com.idega.core/tree/master/src/java/com/idega/util/ModuleFileMerger.java", "rawCode": "  /**\n   * Process contents in the out source file (already existing and older module tags)\n   *\n   * @param inString\n   * @param outString\n   */\n  protected void processContents(StringBuffer inString, StringBuffer outString) {\n    // outString = new StringBuffer();\n    StringBuffer semiOutBuffer = new StringBuffer();\n    Pattern moduleBeginPattern =\n        Pattern.compile(\n            \"<!-- MODULE:BEGIN ([\\\\S]+)\\\\s([\\\\S]+)\\\\s[^\\\\n\\\\r]+\", Pattern.CASE_INSENSITIVE);\n    Matcher moduleBeginMatcher = moduleBeginPattern.matcher(inString);\n\n    // StringBuffer remainder = new StringBuffer();\n    // remainder.append(inString);\n    StringBuffer remainder = null;\n\n    while (moduleBeginMatcher.find()) {\n      // this pattern matches.\n      String moduleId = moduleBeginMatcher.group(1);\n      String version = moduleBeginMatcher.group(2);\n      StringBuffer oldModuleContents = new StringBuffer();\n      oldModuleContents.append(moduleBeginMatcher.group(0));\n      moduleBeginMatcher.appendReplacement(semiOutBuffer, \"\");\n\n      remainder = new StringBuffer();\n      moduleBeginMatcher.appendTail(remainder);\n\n      String regexString =\n          \"<!-- MODULE:END \"\n              + getRegExEscaped(moduleId)\n              + \" \"\n              + getRegExEscaped(version)\n              + \"[^\\\\n\\\\r]+\";\n      Pattern moduleEndPattern = Pattern.compile(regexString, Pattern.CASE_INSENSITIVE);\n      Matcher moduleEndMatcher = moduleEndPattern.matcher(remainder);\n\n      ModuleFile module = (ModuleFile) this.getModuleMap().get(moduleId);\n\n      moduleEndMatcher.find();\n      // This must work, i.e. find() must return a result, otherwise the file is corrupt\n      moduleEndMatcher.appendReplacement(oldModuleContents, \"$0\");\n      // Remainder is only whats left after the MODULE:END tag\n      remainder = new StringBuffer();\n      moduleEndMatcher.appendTail(remainder);\n      // Begin from where the last module tag ended for the next iteration:\n      moduleBeginMatcher = moduleBeginPattern.matcher(remainder);\n\n      if (module != null) {\n        appendModulePartWithComments(module, semiOutBuffer);\n      } else {\n        // Module not found in new sources\n        if (getIfRemoveOlderModules()) {\n          // Do nothing\n        } else {\n          semiOutBuffer.append(oldModuleContents);\n        }\n      }\n    }\n    moduleBeginMatcher.appendTail(semiOutBuffer);\n    // Cut </web-app> off the ending:\n    // replaceBuffer=new StringBuffer(outString.toString());\n    String out = semiOutBuffer.toString();\n\n    outString.append(out.substring(0, out.lastIndexOf(\"</\" + getRootXMLElement() + \">\")));\n  }\n"}, {"dataset": "find", "exampleID": 5663, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 1547, "focalAPIEnd": 1559, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/knutwalker/google-closure-compiler/tree/master/lib/rhino/src/org/mozilla/javascript/RhinoException.java", "rawCode": "  /**\n   * Get the script stack of this exception as an array of {@link ScriptStackElement}s. If\n   * optimization is enabled, this includes java stack elements whose source and method names\n   * suggest they have been generated by the Rhino script compiler.\n   *\n   * @return the script stack for this exception\n   * @since 1.7R3\n   */\n  public ScriptStackElement[] getScriptStack() {\n    List<ScriptStackElement> list = new ArrayList<ScriptStackElement>();\n    ScriptStackElement[][] interpreterStack = null;\n    if (interpreterStackInfo != null) {\n      Evaluator interpreter = Context.createInterpreter();\n      if (interpreter instanceof Interpreter)\n        interpreterStack = ((Interpreter) interpreter).getScriptStackElements(this);\n    }\n    int interpreterStackIndex = 0;\n    StackTraceElement[] stack = getStackTrace();\n    // Pattern to recover function name from java method name -\n    // see Codegen.getBodyMethodName()\n    // kudos to Marc Guillemot for coming up with this\n    Pattern pattern = Pattern.compile(\"_c_(.*)_\\\\d+\");\n    for (StackTraceElement e : stack) {\n      String fileName = e.getFileName();\n      if (e.getMethodName().startsWith(\"_c_\")\n          && e.getLineNumber() > -1\n          && fileName != null\n          && !fileName.endsWith(\".java\")) {\n        String methodName = e.getMethodName();\n        Matcher match = pattern.matcher(methodName);\n        // the method representing the main script is always \"_c_script_0\" -\n        // at least we hope so\n        methodName = !\"_c_script_0\".equals(methodName) && match.find() ? match.group(1) : null;\n        list.add(new ScriptStackElement(fileName, methodName, e.getLineNumber()));\n      } else if (\"org.mozilla.javascript.Interpreter\".equals(e.getClassName())\n          && \"interpretLoop\".equals(e.getMethodName())\n          && interpreterStack != null\n          && interpreterStack.length > interpreterStackIndex) {\n        for (ScriptStackElement elem : interpreterStack[interpreterStackIndex++]) {\n          list.add(elem);\n        }\n      }\n    }\n    return list.toArray(new ScriptStackElement[list.size()]);\n  }\n"}, {"dataset": "find", "exampleID": 5664, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [98], "initializationEnd": [114], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 132, "focalAPIEnd": 140, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)"], "useStart": [121, 165, 194, 183, 227, 256, 245, 289, 319, 307], "useEnd": [141, 175, 202, 203, 237, 264, 265, 299, 327, 328], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/libcore/java/util/regex/OldAndroidRegexTest.java", "rawCode": "  public void testFind() throws Exception {\n    Pattern p = Pattern.compile(\".\");\n    Matcher m = p.matcher(\"abc\");\n\n    assertTrue(m.find());\n    assertEquals(\"a\", m.group(0));\n\n    assertTrue(m.find());\n    assertEquals(\"b\", m.group(0));\n\n    assertTrue(m.find());\n    assertEquals(\"c\", m.group(0));\n\n    assertFalse(m.find());\n  }\n"}, {"dataset": "find", "exampleID": 5665, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [844], "initializationEnd": [867], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 874, "focalAPIEnd": 886, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [996, 1496, 1628], "useEnd": [1010, 1510, 1642], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/widteam/project/tree/master/03_grafikus/src/bhdlParser.java", "rawCode": "  /**\n   * Letrehoz egy Compositot, es ertelmezi a tartalmat. REKURZIV eljaras!\n   *\n   * @param owner Egy composit, melybol a parancs meg lett hivva\n   * @param source BHDL fajl\n   * @param command egy composit hivasos eljaras (pl. : composit(in sw1,gen1 out led1); )\n   * @return a letrehozott composit\n   * @throws ExceptionWireHasMultipleInputs\n   * @throws ExceptionWrongBoard Rosszul formazott BHDL\n   */\n  private static Composit CreateComposit(Composit owner, String source, String command)\n      throws ExceptionWireHasMultipleInputs, ExceptionWrongBoard {\n    // Lekerdezzuk a szulo nevet\n    String OwnerName = owner.GetName();\n    // Minta amely illeszkedik a composit hivasra\n    String reg_comp = \"([\\\\w ]+)\\\\(in(( |[\\\\w]*,?)+),\\\\s*out(( |[\\\\w]*,?)+)\\\\)(.*?);\";\n    Pattern regexp = Pattern.compile(reg_comp);\n    Matcher match = regexp.matcher(command);\n\n    match.find();\n    if (match.matches()) {\n      // a letrehozni kivant composit neve BHDL szerint\n      String comp_name = match.group(1).trim();\n      // letrehozzuk a Compositot\n      Composit myComposit = new Composit(OwnerName, comp_name);\n\n      /*\n       * itt azt fogjuk vizsgalni, , hogy a szulo compositbol hogy nez ki\n       * a most letrehozando composit, azaz a szulo milyen drotokat kot be\n       * ill ki a letrehozando compositba/bol Ezekbol egy listat epitunk,\n       * eltaroljuk. A lista tartalma tehat lehet: egy szulo beli elem\n       * neve egy szulo beli wire neve\n       */\n\n      String[] WiresIn = match.group(2).split(\",\");\n      for (int i = 0; i < WiresIn.length; i++) WiresIn[i] = WiresIn[i].trim();\n      String[] WiresOut = match.group(4).split(\",\");\n      for (int i = 0; i < WiresOut.length; i++) WiresOut[i] = WiresOut[i].trim();\n\n      /*\n       * Mivel azonban a most letrejott Compositban sajat nevek vannak,\n       * azokat meg kell keresni. Ehhez megvizsgaljuk a Composit\n       * leirasanak fejlecet. Mintaillesztest hasznalok, a kapott elemeket\n       * (kimeno, bemeno) egy listaba szervezem\n       */\n      String[] HeaderWiresOut = null;\n      String[] HeaderWiresIn = null;\n\n      // a Composit headerjenek megkeresesehez hasznalt mintaillesztes\n      String CompositeHeader = FindComposite(source, comp_name);\n      String strHeaderRegexp = \"([\\\\w, ]+)\\\\(in(( |[\\\\w]*,?)+),\\\\s*out(( |[\\\\w]*,?)+)\\\\)(.*)?;\";\n      Pattern HeaderRegexp = Pattern.compile(strHeaderRegexp);\n      Matcher MatchingHeader = HeaderRegexp.matcher(CompositeHeader);\n\n      MatchingHeader.find();\n      // Ha talat megfelelo fejreszt\n      if (MatchingHeader.matches()) {\n        // Megvizsgaljuk az aszerinti bemeno drotokat...\n        HeaderWiresIn = MatchingHeader.group(2).split(\",\");\n        // Tisztogatunk\n        for (int i = 0; i < HeaderWiresIn.length; i++) HeaderWiresIn[i] = HeaderWiresIn[i].trim();\n        // .. es a kimenoket is\n        HeaderWiresOut = MatchingHeader.group(4).split(\",\");\n        // Tisztigatunk\n        for (int i = 0; i < HeaderWiresOut.length; i++)\n          HeaderWiresOut[i] = HeaderWiresOut[i].trim();\n\n        /*\n         * A Composit fejlece alapjan megtalalt drotokat most letre is\n         * hozzuk. Mindegyiket hozzakotjuk a Composithoz es hozzadjuk a\n         * Composit listajahoz ezek a drotok a Compositon belul futnak.\n         */\n\n        Wire PinWire = null;\n        ;\n\n        // Bemeno drotok\n        for (String wire_in : HeaderWiresIn) {\n          // Letrehozzuk a PIN-t\n\n          // biztonsag, ha nem regexpelt volna jol\n          if (wire_in.isEmpty()) continue;\n\n          PIN pin = new PIN(myComposit, \"PIN\" + wire_in);\n          myComposit.pins_in.add(pin);\n\n          PinWire = new Wire(myComposit.GetName(), wire_in);\n          PinWire.SetConnection(null, pin);\n          pin.wireOut = PinWire;\n          myComposit.AddToWireList(PinWire);\n        }\n        // Kimeno drotok\n\n        for (String wire_out : HeaderWiresOut) {\n          // Letrehozzuk a PIN-t\n\n          // biztonsag, ha nem regexpelt volna jol\n          if (wire_out.isEmpty()) continue;\n\n          PIN pin = new PIN(myComposit, \"PIN\" + wire_out);\n          myComposit.pins_out.add(pin);\n\n          PinWire = new Wire(myComposit.GetName(), wire_out);\n          PinWire.SetConnection(pin, null);\n          pin.wireIn = PinWire;\n          myComposit.AddToWireList(PinWire);\n        }\n\n        /** REKURZIV FELDERITESE A TOBBI KOMPOZITNAK ReadComposit(myComposit,source,comp_name); * */\n        ReadComposit(myComposit, source, comp_name);\n\n        /*\n         * Ez pedig ahogy kivulrol nez ki az osszekottetes A drotok a\n         * Compositig futnak csak, Composit beli elemhez nem\n         * csatlakoznak (null).\n         */\n        // Bemeno drotok\n\n        Wire w = null;\n        for (int i = 0; i < WiresIn.length; i++) {\n          if (owner.GetWireByName(WiresIn[i]) != null) {\n            w = owner.GetWireByName(WiresIn[i]);\n          } else if (owner.GetElementByName(WiresIn[i]) != null) {\n            w = new Wire(owner.GetName());\n            owner.GetElementByName(WiresIn[i]).wireOut.add(w);\n            w.SetConnection(null, owner.GetElementByName(WiresIn[i]));\n            // ezt a drotot a szulo listajahoz adjuk, hiszen a szulo\n            // composit alapjan keszullt el\n            owner.AddToWireList(w);\n          }\n          // viszont a pin listahoz, megpedig a bemeno pin listahoz\n          // hozzadjuk\n          myComposit.pins_in.get(i).wireIn = w;\n          // megadjuk melyik PINhez csatlakozzek\n          w.SetConnection(myComposit.pins_in.get(i), null);\n        }\n        // Kimeno drotok\n        for (int i = 0; i < WiresOut.length; i++) {\n          if (owner.GetWireByName(WiresOut[i]) != null) {\n            w = owner.GetWireByName(WiresOut[i]);\n          } else if (owner.GetElementByName(WiresOut[i]) != null) {\n            w = new Wire(owner.GetName());\n            owner.GetElementByName(WiresOut[i]).wireIn.add(w);\n            w.SetConnection(owner.GetElementByName(WiresOut[i]), null);\n            // ezt a drotot a szulo listajahoz adjuk, hiszen a szulo\n            // composit alapjan keszullt el\n            owner.AddToWireList(w);\n          }\n          // viszont a pin listahoz, megpedig a bemeno pin listahoz\n          // hozzadjuk\n          myComposit.pins_out.get(i).wireOut = w;\n          // megadjuk melyik PINhez csatlakozzek\n          w.SetConnection(null, myComposit.pins_out.get(i));\n        }\n      }\n      Logger.Log(Logger.log_type.ADDITIONAL, \"Composit (\" + myComposit.GetID() + \") was created.\");\n      return myComposit;\n    }\n    return null;\n  }\n"}, {"dataset": "find", "exampleID": 5666, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [272], "initializationEnd": [293], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 322, "focalAPIEnd": 330, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 336, "followUpCheckExpressionEnd": 347, "followUpCheckBlockStart": 336, "followUpCheckBlockEnd": 385, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7930/src/net/sourceforge/plantuml/command/SingleLineCommand.java", "rawCode": "  public final CommandControl isValid(List<String> lines) {\n    if (lines.size() != 1) {\n      return CommandControl.NOT_OK;\n    }\n    if (isCommandForbidden()) {\n      return CommandControl.NOT_OK;\n    }\n    final String line = lines.get(0).trim();\n    final Matcher m = pattern.matcher(line);\n    final boolean result = m.find();\n    if (result) {\n      actionIfCommandValid();\n    }\n    return result ? CommandControl.OK : CommandControl.NOT_OK;\n  }\n"}, {"dataset": "find", "exampleID": 5667, "initialization": ["Matcher matcher = matcher(*)"], "initializationStart": [125], "initializationEnd": [168], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 193, "focalAPIEnd": 201, "followUpCheck": "result == false", "checkType": "IF", "followUpCheckExpressionStart": 207, "followUpCheckExpressionEnd": 223, "followUpCheckBlockStart": 207, "followUpCheckBlockEnd": 250, "use": ["matcher.group(int)"], "useStart": [277], "useEnd": [287], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7284/src/net/sourceforge/plantuml/BlockUml.java", "rawCode": "  public String getFilename() {\n    if (OptionFlags.getInstance().isWord()) {\n      return null;\n    }\n    final Matcher m = patternFilename.matcher(data.get(0).trim());\n    final boolean ok = m.find();\n    if (ok == false) {\n      return null;\n    }\n    final String result = m.group(1);\n    for (int i = 0; i < result.length(); i++) {\n      final char c = result.charAt(i);\n      if (\"<>|\".indexOf(c) != -1) {\n        return null;\n      }\n    }\n    return result;\n  }\n"}, {"dataset": "find", "exampleID": 5668, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [49], "initializationEnd": [76], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 101, "focalAPIEnd": 109, "followUpCheck": "result == false", "checkType": "IF", "followUpCheckExpressionStart": 115, "followUpCheckExpressionEnd": 131, "followUpCheckBlockStart": 115, "followUpCheckBlockEnd": 183, "use": ["matcher.group(int)"], "useStart": [215], "useEnd": [225], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wcurrie/plantuml-fork/tree/master/src/net/sourceforge/plantuml/FileGroup.java", "rawCode": "  private void recurse() {\n    final Matcher m = predirPath.matcher(pattern);\n    final boolean ok = m.find();\n    if (ok == false) {\n      throw new IllegalArgumentException();\n    }\n    final File parent;\n    if (m.group(1) == null) {\n      parent = new File(\".\");\n    } else {\n      parent = new File(m.group(1));\n    }\n    initWithDoubleStar(parent);\n  }\n"}, {"dataset": "find", "exampleID": 5669, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [119], "initializationEnd": [133], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 154, "focalAPIEnd": 162, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sonyfe25cp/EventsMachine/tree/master/gossip/src/main/java/gossip/urlTemp/ChinaNews.java", "rawCode": "  /**\n   * 判断是否是最终页\n   *\n   * @param url\n   * @return Jul 11, 2012\n   */\n  public boolean verify(String url) {\n    m = p.matcher(url);\n    boolean flag = m.find();\n    return flag;\n  }\n"}, {"dataset": "find", "exampleID": 5670, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [195], "initializationEnd": [218], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 235, "focalAPIEnd": 245, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertTrue(result)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.matches()"], "useStart": [224, 322, 310, 408, 397, 520, 509, 633, 622, 730, 719, 896, 885, 983, 971, 1069, 1058, 1181, 1170, 1294, 1283, 1391, 1380, 2042, 2031, 2221, 2210, 2351, 2339, 2486, 2475, 2713], "useEnd": [246, 332, 333, 418, 419, 530, 531, 643, 644, 740, 741, 906, 907, 993, 994, 1079, 1080, 1191, 1192, 1304, 1305, 1401, 1402, 2052, 2053, 2231, 2232, 2361, 2362, 2496, 2497, 2726], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/PatternTest.java", "rawCode": "  public void testPredefinedClassesWithSurrogatesSupplementary() {\n    String patString = \"[123\\\\D]\";\n    String testString = \"a\";\n    Pattern pat = Pattern.compile(patString);\n    Matcher mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    testString = \"5\";\n    mat = pat.matcher(testString);\n    assertFalse(mat.find());\n\n    testString = \"3\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    // low surrogate\n    testString = \"\\uDFC4\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    // high surrogate\n    testString = \"\\uDADA\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    testString = \"\\uDADA\\uDFC4\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    patString = \"[123[^\\\\p{javaDigit}]]\";\n    testString = \"a\";\n    pat = Pattern.compile(patString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    testString = \"5\";\n    mat = pat.matcher(testString);\n    assertFalse(mat.find());\n\n    testString = \"3\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    // low surrogate\n    testString = \"\\uDFC4\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    // high surrogate\n    testString = \"\\uDADA\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    testString = \"\\uDADA\\uDFC4\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    // surrogate characters\n    patString = \"\\\\p{Cs}\";\n    testString = \"\\uD916\\uDE27\";\n    pat = Pattern.compile(patString);\n    mat = pat.matcher(testString);\n\n    /*\n     * see http://www.unicode.org/reports/tr18/#Supplementary_Characters we\n     * have to treat text as code points not code units. \\\\p{Cs} matches any\n     * surrogate character but here testString is a one code point\n     * consisting of two code units (two surrogate characters) so we find\n     * nothing\n     */\n    // assertFalse(mat.find());\n    // swap low and high surrogates\n    testString = \"\\uDE27\\uD916\";\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    patString = \"[\\uD916\\uDE271\\uD91623&&[^\\\\p{Cs}]]\";\n    testString = \"1\";\n    pat = Pattern.compile(patString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    testString = \"\\uD916\";\n    pat = Pattern.compile(patString);\n    mat = pat.matcher(testString);\n    assertFalse(mat.find());\n\n    testString = \"\\uD916\\uDE27\";\n    pat = Pattern.compile(patString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.find());\n\n    // \\uD9A0\\uDE8E=\\u7828E\n    // \\u78281=\\uD9A0\\uDE81\n    patString = \"[a-\\uD9A0\\uDE8E]\";\n    testString = \"\\uD9A0\\uDE81\";\n    pat = Pattern.compile(patString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n  }\n"}, {"dataset": "find", "exampleID": 5671, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [2568], "initializationEnd": [2591], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 2609, "focalAPIEnd": 2626, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)"], "useStart": [2598, 2646, 2683, 2672, 2725, 2763, 2752, 2800, 2838, 2826], "useEnd": [2627, 2665, 2700, 2701, 2744, 2780, 2781, 2819, 2855, 2856], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/webx/citrus/tree/master/service/mail/src/test/java/com/alibaba/citrus/service/mail/MailServiceTests.java", "rawCode": "  @Test\n  public void mail_htmlTemplateContent() throws Exception {\n    // no template name\n    getAndAssertMail(\"htmlTemplateContent_empty\", \"GBK\", null);\n    assertThat(builder.getContent(), instanceOf(HTMLTemplateContent.class));\n\n    try {\n      getMessageAsText();\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e, exception(\"templateName\"));\n    }\n\n    // velocity - no resource\n    getAndAssertMail(\"htmlTemplateContent_vm\", \"GBK\", null);\n    assertThat(builder.getContent(), instanceOf(HTMLTemplateContent.class));\n\n    String eml = getMessageAsText();\n\n    assertThat(eml, containsRegex(\"Subject: \" + REGEX_EOL));\n    assertThat(eml, not(containsRegex(\"Content-Type: multipart/related;\")));\n    assertThat(eml, containsRegex(\"Content-Type: text/html; charset=GBK\"));\n    assertThat(eml, containsRegex(\"Content-Transfer-Encoding: 8bit\" + REGEX_EOL));\n    assertThat(eml, containsRegex(REGEX_EOL + REGEX_EOL + \"velocity\" + REGEX_EOL));\n    assertThat(eml, containsRegex(\"1 2 3 4 5 6 7 8 9 10\"));\n    assertThat(eml, containsString(\"image URL1: <img src=\\\"$image.getURI(\\\"java.gif\\\")\\\"/>\"));\n    assertThat(eml, containsString(\"image URL2: <img src=\\\"$image.getURI(\\\"java.gif\\\")\\\"/>\"));\n    assertThat(\n        eml, containsString(\"image URL3: <img src=\\\"$image.getURI(\\\"subdir/bible.jpg\\\")\\\"/>\"));\n\n    // freemarker - with resource but not used\n    getAndAssertMail(\"htmlTemplateContent_ftl\", \"GBK\", null);\n    assertThat(builder.getContent(), instanceOf(HTMLTemplateContent.class));\n\n    eml = getMessageAsText();\n\n    assertThat(eml, containsRegex(\"Subject: \" + REGEX_EOL));\n    assertThat(eml, not(containsRegex(\"Content-Type: multipart/related;\")));\n\n    assertThat(eml, containsRegex(\"Content-Type: text/plain; charset=GBK\"));\n    assertThat(eml, containsRegex(\"Content-Transfer-Encoding: 8bit\" + REGEX_EOL));\n    assertThat(eml, containsRegex(REGEX_EOL + REGEX_EOL + \"freemarker\" + REGEX_EOL));\n    assertThat(eml, containsRegex(\"1 2 3 4 5 6 7 8 9 10\"));\n    assertThat(eml, containsRegex(\"Constant\\\\[MailConstant\\\\]\"));\n    assertThat(eml, containsString(\"$hello\"));\n\n    // velocity - with resource and used\n    getAndAssertMail(\"htmlTemplateContent_vm_withResource\", \"GBK\", null);\n    assertThat(builder.getContent(), instanceOf(HTMLTemplateContent.class));\n\n    eml = getMessageAsText();\n\n    assertThat(eml, containsRegex(\"Subject: \" + REGEX_EOL));\n    assertThat(eml, containsRegex(\"Content-Type: multipart/related;\"));\n\n    Pattern cidPattern = Pattern.compile(\"<img src=\\\"cid:([^\\\\\\\"]+)\\\"/>\");\n    Matcher cidMatcher = cidPattern.matcher(eml);\n\n    assertTrue(cidMatcher.find());\n    String id1 = cidMatcher.group(1);\n\n    assertTrue(cidMatcher.find());\n    assertEquals(id1, cidMatcher.group(1));\n\n    assertTrue(cidMatcher.find());\n    String id2 = cidMatcher.group(1);\n\n    assertFalse(cidMatcher.find());\n\n    // part 1\n    assertThat(eml, containsRegex(\"Content-Type: text/html; charset=GBK\"));\n    assertThat(eml, containsRegex(\"Content-Transfer-Encoding: 8bit\" + REGEX_EOL));\n    assertThat(eml, containsRegex(REGEX_EOL + REGEX_EOL + \"velocity\" + REGEX_EOL));\n    assertThat(eml, containsRegex(\"1 2 3 4 5 6 7 8 9 10\"));\n    assertThat(eml, containsString(\"image URL1: <img src=\\\"cid:\" + id1));\n    assertThat(eml, containsString(\"image URL2: <img src=\\\"cid:\" + id1));\n    assertThat(eml, containsString(\"image URL3: <img src=\\\"cid:\" + id2));\n\n    // part 2\n    assertThat(eml, containsRegex(\"Content-Type: image/gif\"));\n    assertThat(eml, containsRegex(\"Content-Transfer-Encoding: base64\" + REGEX_EOL));\n    assertThat(eml, containsString(\"Content-ID: <\" + id1 + \">\"));\n    assertThat(eml, containsRegex(\"Content-Disposition: inline; filename=java.gif\" + REGEX_EOL));\n\n    // part 3\n    assertThat(eml, containsRegex(\"Content-Type: image/jpeg\"));\n    assertThat(eml, containsRegex(\"Content-Transfer-Encoding: base64\" + REGEX_EOL));\n    assertThat(eml, containsString(\"Content-ID: <\" + id2 + \">\"));\n    assertThat(eml, containsRegex(\"Content-Disposition: inline; filename=bible.jpg\" + REGEX_EOL));\n  }\n"}, {"dataset": "find", "exampleID": 5672, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [455], "initializationEnd": [481], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["toString()", "Request.complete()"], "tryExpressionStart": 68, "tryExpressionEnd": 72, "tryBlockStart": 68, "tryBlockEnd": 714, "catchExpressionStart": 630, "catchExpressionEnd": 652, "catchBlockStart": 630, "catchBlockEnd": 714, "exceptionHandlingCallStart": [673, 693], "exceptionHandlingCallEnd": [685, 707], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 491, "focalAPIEnd": 500, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [536], "useEnd": [547], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/EnderWiggin/Haven-and-Hearth-client-modified-by-Ender/tree/master/src/wikilib/WikiLib.java", "rawCode": "  private void searchPage(Request req) {\n    BufferedReader in;\n    try {\n      in = new BufferedReader(new InputStreamReader(req.url.openStream()));\n      String inputLine, content = \"\";\n      while ((inputLine = in.readLine()) != null) content += inputLine;\n      in.close();\n      if (content.indexOf(\"<div class='searchresults'>\") != -1) {\n        req.result = formatSearchResults(content);\n        req.complete();\n      } else {\n        Matcher ma = findTitle.matcher(content);\n        ma.find();\n        req.title = formatSymbols(ma.group(1));\n        req.result = formatPage(content);\n        req.complete();\n      }\n    } catch (IOException e) {\n      req.result = e.toString();\n      req.complete();\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5673, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [126], "initializationEnd": [146], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 232, "focalAPIEnd": 240, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.groupCount()", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)", "matcher.group(int)"], "useStart": [221, 264, 305, 340, 375, 409], "useEnd": [241, 278, 315, 350, 385, 419], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spacecaker/android_frameworks_base_CSM9.1/tree/master/tests/CoreTests/android/core/RegexTest.java", "rawCode": "  @SmallTest\n  public void testGroups() throws Exception {\n    Pattern p = Pattern.compile(\"(b)([c|d])(z*)\");\n    Matcher m = p.matcher(\"abcdefg\");\n\n    /* Must call find() first, otherwise group*() are undefined. */\n    assertTrue(m.find());\n\n    assertEquals(3, m.groupCount());\n\n    assertEquals(\"bc\", m.group(0));\n    assertEquals(\"b\", m.group(1));\n    assertEquals(\"c\", m.group(2));\n    assertEquals(\"\", m.group(3));\n  }\n"}, {"dataset": "find", "exampleID": 5674, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [49], "initializationEnd": [76], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 101, "focalAPIEnd": 109, "followUpCheck": "result == false", "checkType": "IF", "followUpCheckExpressionStart": 115, "followUpCheckExpressionEnd": 131, "followUpCheckBlockStart": 115, "followUpCheckBlockEnd": 183, "use": ["matcher.group(int)"], "useStart": [215], "useEnd": [225], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7650/src/net/sourceforge/plantuml/FileGroup.java", "rawCode": "  private void recurse() {\n    final Matcher m = predirPath.matcher(pattern);\n    final boolean ok = m.find();\n    if (ok == false) {\n      throw new IllegalArgumentException();\n    }\n    final File parent;\n    if (m.group(1) == null) {\n      parent = new File(\".\");\n    } else {\n      parent = new File(m.group(1));\n    }\n    initWithDoubleStar(parent);\n  }\n"}, {"dataset": "find", "exampleID": 5675, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [733], "initializationEnd": [759], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 776, "focalAPIEnd": 784, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)"], "useStart": [765, 811, 840, 828, 972, 961, 1007, 1035, 1024, 1070, 1099, 1087, 1209, 1198, 1244, 1272, 1261, 1307, 1336, 1324], "useEnd": [785, 821, 848, 849, 980, 981, 1017, 1043, 1044, 1080, 1107, 1108, 1217, 1218, 1254, 1280, 1281, 1317, 1344, 1345], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/regex/src/test/java/org/apache/harmony/regex/tests/java/util/regex/ModeTest.java", "rawCode": "  @TestTargets({\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"The test verifies compile(String regex) and compile(String regex, int flags) methods with Pattern.CASE_INSENSITIVE mode.\",\n      method = \"compile\",\n      args = {java.lang.String.class}\n    ),\n    @TestTargetNew(\n      level = TestLevel.PARTIAL_COMPLETE,\n      notes =\n          \"The test verifies compile(String regex) and compile(String regex, int flags) methods with Pattern.CASE_INSENSITIVE mode.\",\n      method = \"compile\",\n      args = {java.lang.String.class, int.class}\n    )\n  })\n  public void testCase() throws PatternSyntaxException {\n    Pattern p;\n    Matcher m;\n\n    p = Pattern.compile(\"([a-z]+)[0-9]+\");\n    m = p.matcher(\"cAT123#dog345\");\n    assertTrue(m.find());\n    assertEquals(\"dog\", m.group(1));\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"([a-z]+)[0-9]+\", Pattern.CASE_INSENSITIVE);\n    m = p.matcher(\"cAt123#doG345\");\n    assertTrue(m.find());\n    assertEquals(\"cAt\", m.group(1));\n    assertTrue(m.find());\n    assertEquals(\"doG\", m.group(1));\n    assertFalse(m.find());\n\n    p = Pattern.compile(\"(?i)([a-z]+)[0-9]+\");\n    m = p.matcher(\"cAt123#doG345\");\n    assertTrue(m.find());\n    assertEquals(\"cAt\", m.group(1));\n    assertTrue(m.find());\n    assertEquals(\"doG\", m.group(1));\n    assertFalse(m.find());\n  }\n"}, {"dataset": "find", "exampleID": 5676, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [164], "initializationEnd": [176], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 182, "focalAPIEnd": 190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [203], "useEnd": [213], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-6288/src/net/sourceforge/plantuml/cucadiagram/dot/CucaDiagramFileMaker.java", "rawCode": "  private static String getValuePx(String s, String param) {\n    final Pattern p = Pattern.compile(\"(?i)\" + param + \"=\\\"([^\\\"]+?)(?:px)?\\\"\");\n    final Matcher m = p.matcher(s);\n    m.find();\n    return m.group(1);\n  }\n"}, {"dataset": "find", "exampleID": 5677, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [136], "initializationEnd": [156], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 181, "focalAPIEnd": 189, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 195, "followUpCheckExpressionEnd": 202, "followUpCheckBlockStart": 195, "followUpCheckBlockEnd": 299, "use": ["matcher.group(int)", "matcher.group(int)"], "useStart": [236, 281], "useEnd": [246, 291], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7177/src/net/sourceforge/plantuml/acearth/PSystemXearthFactory.java", "rawCode": "  private void extractDimension(String startLine) {\n    final Pattern p = Pattern.compile(\"\\\\((\\\\d+),(\\\\d+)\\\\)\");\n    final Matcher m = p.matcher(startLine);\n    final boolean ok = m.find();\n    if (ok) {\n      width = Integer.parseInt(m.group(1));\n      height = Integer.parseInt(m.group(2));\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5678, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [103], "initializationEnd": [127], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 212, "focalAPIEnd": 226, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(String,result)"], "useStart": [148], "useEnd": [227], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zeph/grinder/tree/master/source/tests-src/net/grinder/testutility/AssertUtilities.java", "rawCode": "  public static void assertContainsPattern(String text, String pattern) {\n\n    final Matcher matcher = Pattern.compile(pattern).matcher(text);\n\n    assertTrue(\"'\" + text + \"' contains pattern '\" + pattern + \"'\", matcher.find());\n  }\n"}, {"dataset": "find", "exampleID": 5679, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [148], "initializationEnd": [164], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 181, "focalAPIEnd": 189, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.group(int)", "matcher.find()", "assertFalse(result)"], "useStart": [170, 216, 810, 799, 854, 911, 899], "useEnd": [190, 226, 818, 819, 864, 919, 920], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lightningdb/chililog-server/tree/master/src/test/java/org/chililog/server/engine/parsers/FieldParserTest.java", "rawCode": "  @Test\n  public void testPreParsingExamples() {\n    // Strip white spaces\n    Pattern p = Pattern.compile(\"[\\\\s]*([A-Z]+)[\\\\s]*\");\n    Matcher m = p.matcher(\"ABC\");\n    assertTrue(m.find());\n    assertEquals(\"ABC\", m.group(1));\n\n    // http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html\n    // Capturing groups are numbered by counting their opening parentheses from left to right. In\n    // the expression\n    // ((A)(B(C))), for example, there are four such groups:\n    //\n    // 1 ((A)(B(C)))\n    // 2 (A)\n    // 3 (B(C))\n    // 4 (C)\n    // Group zero always stands for the entire expression.\n\n    // Matching by group non capturing group\n    p = Pattern.compile(\"^(?:[0-9]+ [\\\\w\\\\.\\\\[\\\\]]+ )([\\\\w\\\\.]+) \");\n    m = p.matcher(\"913745345 [Main] com.test.abc - test\");\n    assertTrue(m.find());\n    assertEquals(\"com.test.abc\", m.group(1));\n\n    m = p.matcher(\"test\");\n    assertFalse(m.find());\n  }\n"}, {"dataset": "find", "exampleID": 5680, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [319], "initializationEnd": [331], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 337, "focalAPIEnd": 345, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [358], "useEnd": [368], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-6242/src/net/sourceforge/plantuml/cucadiagram/dot/CucaDiagramFileMaker.java", "rawCode": "  public static String getSvg(UGraphicSvg ug) throws IOException {\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ug.createXml(baos);\n    baos.close();\n    final String s = new String(baos.toByteArray(), \"UTF-8\");\n    final Pattern p = Pattern.compile(\"(?i)<g\\\\W.*</g>\");\n    final Matcher m = p.matcher(s);\n    m.find();\n    return m.group(0);\n  }\n"}, {"dataset": "find", "exampleID": 5681, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(matcher==null)", "guardType": "IF {", "guardExpressionStart": 64, "guardExpressionEnd": 84, "guardBlockStart": 64, "guardBlockEnd": 98, "focalAPI": "result = matcher.find()", "focalAPIStart": 271, "focalAPIEnd": 285, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 295, "followUpCheckExpressionEnd": 307, "followUpCheckBlockStart": 295, "followUpCheckBlockEnd": 474, "use": ["matcher.start()", "matcher.end()"], "useStart": [326, 359], "useEnd": [341, 372], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/alibaba/mdrill/tree/master/trunk/adhoc-solr/src/main/java/org/apache/lucene/analysis/miscellaneous/PatternAnalyzer.java", "rawCode": "    @Override\n    public final boolean incrementToken() {\n      if (matcher == null) return false;\n      clearAttributes();\n      while (true) { // loop takes care of leading and trailing boundary cases\n        int start = pos;\n        int end;\n        boolean isMatch = matcher.find();\n        if (isMatch) {\n          end = matcher.start();\n          pos = matcher.end();\n        } else {\n          end = str.length();\n          matcher = null; // we're finished\n        }\n\n        if (start != end) { // non-empty match (header/trailer)\n          String text = str.substring(start, end);\n          if (toLowerCase) text = text.toLowerCase(locale);\n          termAtt.setEmpty().append(text);\n          offsetAtt.setOffset(start, end);\n          return true;\n        }\n        if (!isMatch) return false;\n      }\n    }\n"}, {"dataset": "find", "exampleID": 5682, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [113], "initializationEnd": [136], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 153, "focalAPIEnd": 161, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.start()", "matcher.find()", "assertTrue(result)", "matcher.start()"], "useStart": [142, 184, 247, 236, 278], "useEnd": [162, 193, 255, 256, 287], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cbcrg/tcoffee-server/tree/master/test/models/CmdArgsTest.java", "rawCode": "  @Test\n  public void testPattern() {\n    Pattern p = Pattern.compile(\"[ \\\\t\\\\n\\\\x0B\\\\f\\\\r]-\");\n\n    Matcher m = p.matcher(\"hola -prop\");\n    assertTrue(m.find());\n    assertEquals(4, m.start());\n\n    m = p.matcher(\"hola \\n-prop\");\n    assertTrue(m.find());\n    assertEquals(5, m.start());\n  }\n"}, {"dataset": "find", "exampleID": 5683, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [141], "initializationEnd": [155], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 211, "focalAPIEnd": 219, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setString(Event,String,result)"], "useStart": [315], "useEnd": [349], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cloudera/flume/tree/master/flume-core/src/main/java/com/cloudera/flume/core/extractors/RegexExtractor.java", "rawCode": "  @Override\n  public void append(Event e) throws IOException, InterruptedException {\n    String s = new String(e.getBody());\n    Matcher m = pat.matcher(s);\n    String val = \"\"; // default\n    try {\n      val = m.find() ? m.group(grp) : \"\";\n    } catch (IndexOutOfBoundsException ioobe) {\n      val = \"\";\n    }\n    Attributes.setString(e, attr, val);\n    super.append(e);\n  }\n"}, {"dataset": "find", "exampleID": 5684, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [272], "initializationEnd": [293], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 322, "focalAPIEnd": 330, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 336, "followUpCheckExpressionEnd": 347, "followUpCheckBlockStart": 336, "followUpCheckBlockEnd": 385, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sixman9/plantuml/tree/master/src/net/sourceforge/plantuml/command/SingleLineCommand.java", "rawCode": "  public final CommandControl isValid(List<String> lines) {\n    if (lines.size() != 1) {\n      return CommandControl.NOT_OK;\n    }\n    if (isCommandForbidden()) {\n      return CommandControl.NOT_OK;\n    }\n    final String line = lines.get(0).trim();\n    final Matcher m = pattern.matcher(line);\n    final boolean result = m.find();\n    if (result) {\n      actionIfCommandValid();\n    }\n    return result ? CommandControl.OK : CommandControl.NOT_OK;\n  }\n"}, {"dataset": "find", "exampleID": 5685, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [929], "initializationEnd": [970], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 1006, "focalAPIEnd": 1014, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [1038], "useEnd": [1048], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/moriyoshi/play-forked/tree/master/framework/src/play/test/Fixtures.java", "rawCode": "  static void serialize(Map<?, ?> values, String prefix, Map<String, String[]> serialized) {\n    for (Object key : values.keySet()) {\n      Object value = values.get(key);\n      if (value == null) {\n        continue;\n      }\n      if (value instanceof Map<?, ?>) {\n        serialize((Map<?, ?>) value, prefix + \".\" + key, serialized);\n      } else if (value instanceof Date) {\n        serialized.put(\n            prefix + \".\" + key.toString(),\n            new String[] {new SimpleDateFormat(DateBinder.ISO8601).format(((Date) value))});\n      } else if (value instanceof List<?>) {\n        List<?> l = (List<?>) value;\n        String[] r = new String[l.size()];\n        int i = 0;\n        for (Object el : l) {\n          r[i++] = el.toString();\n        }\n        serialized.put(prefix + \".\" + key.toString(), r);\n      } else if (value instanceof String && value.toString().matches(\"<<<\\\\s*\\\\{[^}]+}\\\\s*\")) {\n        Matcher m = Pattern.compile(\"<<<\\\\s*\\\\{([^}]+)}\\\\s*\").matcher(value.toString());\n        m.find();\n        String file = m.group(1);\n        VirtualFile f = Play.getVirtualFile(file);\n        if (f != null && f.exists()) {\n          serialized.put(prefix + \".\" + key.toString(), new String[] {f.contentAsString()});\n        }\n      } else {\n        serialized.put(prefix + \".\" + key.toString(), new String[] {value.toString()});\n      }\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5686, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [319], "initializationEnd": [331], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 337, "focalAPIEnd": 345, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)"], "useStart": [358], "useEnd": [368], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7650/src/net/sourceforge/plantuml/cucadiagram/dot/CucaDiagramFileMaker.java", "rawCode": "  public static String getSvg(UGraphicSvg ug) throws IOException {\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ug.createXml(baos);\n    baos.close();\n    final String s = new String(baos.toByteArray(), \"UTF-8\");\n    final Pattern p = Pattern.compile(\"(?i)<g\\\\W.*</g>\");\n    final Matcher m = p.matcher(s);\n    m.find();\n    return m.group(0);\n  }\n"}, {"dataset": "find", "exampleID": 5687, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.reset(String)"], "configurationStart": [46], "configurationEnd": [64], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 121, "focalAPIEnd": 129, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertFalse(String,result)"], "useStart": [70], "useEnd": [130], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BertrandDechoux/Heritrix-3/tree/master/commons/src/test/java/org/archive/net/PublicSuffixesTest.java", "rawCode": "  public void testUnsegmentedHostname() {\n    m.reset(\"example\");\n    assertFalse(\"unexpected match found in 'example'\", m.find());\n  }\n"}, {"dataset": "find", "exampleID": 5688, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [136], "initializationEnd": [156], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 181, "focalAPIEnd": 189, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 195, "followUpCheckExpressionEnd": 202, "followUpCheckBlockStart": 195, "followUpCheckBlockEnd": 299, "use": ["matcher.group(int)", "matcher.group(int)"], "useStart": [236, 281], "useEnd": [246, 291], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7929/src/net/sourceforge/plantuml/jcckit/PSystemJcckitFactory.java", "rawCode": "  private void extractDimension(String startLine) {\n    final Pattern p = Pattern.compile(\"\\\\((\\\\d+),(\\\\d+)\\\\)\");\n    final Matcher m = p.matcher(startLine);\n    final boolean ok = m.find();\n    if (ok) {\n      width = Integer.parseInt(m.group(1));\n      height = Integer.parseInt(m.group(2));\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5689, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [412], "initializationEnd": [431], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "fail(*)", "printStackTrace()"], "tryExpressionStart": 88, "tryExpressionEnd": 92, "tryBlockStart": 88, "tryBlockEnd": 600, "catchExpressionStart": 508, "catchExpressionEnd": 529, "catchBlockStart": 508, "catchBlockEnd": 600, "exceptionHandlingCallStart": [549, 537, 573], "exceptionHandlingCallEnd": [564, 565, 593], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 491, "focalAPIEnd": 499, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(String,result)"], "useStart": [439], "useEnd": [500], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fcrepo/fcrepo-before33/tree/master/fcrepo-integrationtest/src/test/java/fedora/test/fesl/restapi/TestREST.java", "rawCode": "  @Test\n  public void testGetNextPIDXML() {\n    log.info(\"[ testGetNextPIDXML ]\");\n\n    try {\n      String url = \"/fedora/objects/nextPID?format=xml\";\n      String response = httpUtils.post(url);\n      if (log.isDebugEnabled()) {\n        log.debug(\"http response:\\n\" + response);\n      }\n\n      String regex = \".*<pid>.+\\\\:.+</pid>.*\";\n      Pattern p = Pattern.compile(regex, Pattern.DOTALL);\n      Matcher m = p.matcher(response);\n      Assert.assertTrue(\"Expected object data not found\", m.find());\n    } catch (Exception re) {\n      Assert.fail(re.getMessage());\n      re.printStackTrace();\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5690, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [136], "initializationEnd": [156], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 181, "focalAPIEnd": 189, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 195, "followUpCheckExpressionEnd": 202, "followUpCheckBlockStart": 195, "followUpCheckBlockEnd": 299, "use": ["matcher.group(int)", "matcher.group(int)"], "useStart": [236, 281], "useEnd": [246, 291], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7939/src/net/sourceforge/plantuml/acearth/PSystemXearthFactory.java", "rawCode": "  private void extractDimension(String startLine) {\n    final Pattern p = Pattern.compile(\"\\\\((\\\\d+),(\\\\d+)\\\\)\");\n    final Matcher m = p.matcher(startLine);\n    final boolean ok = m.find();\n    if (ok) {\n      width = Integer.parseInt(m.group(1));\n      height = Integer.parseInt(m.group(2));\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5691, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [1568], "initializationEnd": [1585], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 2870, "focalAPIEnd": 2882, "followUpCheck": "result", "checkType": "IF", "followUpCheckExpressionStart": 2894, "followUpCheckExpressionEnd": 2906, "followUpCheckBlockStart": 2894, "followUpCheckBlockEnd": 5241, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gkno/picard/tree/master/src/java/net/sf/samtools/util/SequenceUtil.java", "rawCode": "  /**\n   * Produce reference bases from an aligned SAMRecord with MD string and Cigar.\n   *\n   * @param rec Must contain non-empty CIGAR and MD attribute.\n   * @param includeReferenceBasesForDeletions If true, include reference bases that are deleted in\n   *     the read. This will make the returned array not line up with the read if there are\n   *     deletions.\n   * @return References bases corresponding to the read. If there is an insertion in the read,\n   *     reference contains '-'. If the read is soft-clipped, reference contains '0'. If there is a\n   *     skipped region and includeReferenceBasesForDeletions==true, reference will have Ns for the\n   *     skipped region.\n   */\n  public static byte[] makeReferenceFromAlignment(\n      final SAMRecord rec, final boolean includeReferenceBasesForDeletions) {\n    final String md = rec.getStringAttribute(SAMTag.MD.name());\n    if (md == null) {\n      throw new SAMException(\n          \"Cannot create reference from SAMRecord with no MD tag, read: \" + rec.getReadName());\n    }\n    // Not sure how long output will be, but it will be no longer than this.\n    int maxOutputLength = 0;\n    final Cigar cigar = rec.getCigar();\n    if (cigar == null) {\n      throw new SAMException(\n          \"Cannot create reference from SAMRecord with no CIGAR, read: \" + rec.getReadName());\n    }\n    for (final CigarElement cigarElement : cigar.getCigarElements()) {\n      maxOutputLength += cigarElement.getLength();\n    }\n    final byte[] ret = new byte[maxOutputLength];\n    int outIndex = 0;\n\n    final Matcher match = mdPat.matcher(md);\n    int curSeqPos = 0;\n\n    int savedBases = 0;\n    final byte[] seq = rec.getReadBases();\n    for (final CigarElement cigEl : cigar.getCigarElements()) {\n      final int cigElLen = cigEl.getLength();\n      final CigarOperator cigElOp = cigEl.getOperator();\n\n      if (cigElOp == CigarOperator.SKIPPED_REGION) {\n        // We've decided that MD tag will not contain bases for skipped regions, as they\n        // could be megabases long, so just put N in there if caller wants reference bases,\n        // otherwise ignore skipped regions.\n        if (includeReferenceBasesForDeletions) {\n          for (int i = 0; i < cigElLen; ++i) {\n            ret[outIndex++] = N;\n          }\n        }\n      }\n      // If it consumes reference bases, it's either a match or a deletion in the sequence\n      // read. Either way, we're going to need to parse through the MD.\n      else if (cigElOp.consumesReferenceBases()) {\n        // We have a match region, go through the MD\n        int basesMatched = 0;\n\n        // Do we have any saved matched bases?\n        while ((savedBases > 0) && (basesMatched < cigElLen)) {\n          ret[outIndex++] = seq[curSeqPos++];\n          savedBases--;\n          basesMatched++;\n        }\n\n        while (basesMatched < cigElLen) {\n          boolean matched = match.find();\n          if (matched) {\n            String mg;\n            if (((mg = match.group(1)) != null) && (mg.length() > 0)) {\n              // It's a number , meaning a series of matches\n              final int num = Integer.parseInt(mg);\n              for (int i = 0; i < num; i++) {\n                if (basesMatched < cigElLen) {\n                  ret[outIndex++] = seq[curSeqPos++];\n                } else {\n                  savedBases++;\n                }\n                basesMatched++;\n              }\n            } else if (((mg = match.group(2)) != null) && (mg.length() > 0)) {\n              // It's a single nucleotide, meaning a mismatch\n              if (basesMatched < cigElLen) {\n                ret[outIndex++] = StringUtil.charToByte(mg.charAt(0));\n                curSeqPos++;\n              } else {\n                throw new IllegalStateException(\"Should never happen.\");\n              }\n              basesMatched++;\n            } else if (((mg = match.group(3)) != null) && (mg.length() > 0)) {\n              // It's a deletion, starting with a caret\n              // don't include caret\n              if (includeReferenceBasesForDeletions) {\n                final byte[] deletedBases = StringUtil.stringToBytes(mg);\n                System.arraycopy(deletedBases, 1, ret, outIndex, deletedBases.length - 1);\n                outIndex += deletedBases.length - 1;\n              }\n              basesMatched += mg.length() - 1;\n\n              // Check just to make sure.\n              if (basesMatched != cigElLen) {\n                throw new SAMException(\n                    \"Got a deletion in CIGAR (\"\n                        + cigar\n                        + \", deletion \"\n                        + cigElLen\n                        + \" length) with an unequal ref insertion in MD (\"\n                        + md\n                        + \", md \"\n                        + basesMatched\n                        + \" length\");\n              }\n              if (cigElOp != CigarOperator.DELETION) {\n                throw new SAMException(\n                    \"Got an insertion in MD (\"\n                        + md\n                        + \") without a corresponding deletion in cigar (\"\n                        + cigar\n                        + \")\");\n              }\n\n            } else {\n              matched = false;\n            }\n          }\n\n          if (!matched) {\n            throw new SAMException(\n                \"Illegal MD pattern: \"\n                    + md\n                    + \" for read \"\n                    + rec.getReadName()\n                    + \" with CIGAR \"\n                    + rec.getCigarString());\n          }\n        }\n\n      } else if (cigElOp.consumesReadBases()) {\n        // We have an insertion in read\n        for (int i = 0; i < cigElLen; i++) {\n          final char c = (cigElOp == CigarOperator.SOFT_CLIP) ? '0' : '-';\n          ret[outIndex++] = StringUtil.charToByte(c);\n          curSeqPos++;\n        }\n      } else {\n        // It's an op that consumes neither read nor reference bases. Do we just ignore??\n      }\n    }\n    if (outIndex < ret.length) {\n      final byte[] shorter = new byte[outIndex];\n      System.arraycopy(ret, 0, shorter, 0, outIndex);\n      return shorter;\n    }\n    return ret;\n  }\n"}, {"dataset": "find", "exampleID": 5692, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [390], "initializationEnd": [403], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find(start)", "focalAPIStart": 416, "focalAPIEnd": 425, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/myprogrammingblog/polling-module/tree/master/web-polling/source/connection/JedisConnection.java", "rawCode": "  /**\n   * Tries to find the passed webkey in the contents of the passed string.\n   *\n   * @param cv the contents of the bigbluebutton cookie\n   * @param webkey the webkey that you want to search for\n   * @return true if the webkey is found, otherwise false\n   */\n  public boolean cookieCheck(String cv, String webkey) {\n    Pattern p = Pattern.compile(\",\" + webkey + \",\");\n    Matcher m = p.matcher(cv);\n    return m.find(0);\n  }\n"}, {"dataset": "find", "exampleID": 5693, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [680], "initializationEnd": [707], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 743, "focalAPIEnd": 760, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.start()"], "useStart": [827], "useEnd": [845], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/oodt/tree/master/metadata/src/main/java/org/apache/oodt/cas/metadata/util/PathUtils.java", "rawCode": "  /**\n   * Replaces String method of format\n   * [DATE_TO_MILLIS(<date-string>,<DateUtils.FormatType>,<epoch-date format: \"yyyy-MM-dd\">)] with\n   * milliseconds between <epoch-date> and <date-string>\n   */\n  public static String doDynamicDateToMillisReplacement(String string, Metadata metadata)\n      throws ParseException, CommonsException, CasMetadataException {\n    Pattern utcToTaiPattern =\n        Pattern.compile(\"\\\\[\\\\s*DATE_TO_MILLIS\\\\s*\\\\(.{1,}?\\\\,.{1,}?,.{1,}?\\\\)\\\\s*\\\\]\");\n    Matcher matcher = utcToTaiPattern.matcher(string);\n    while (matcher.find()) {\n      String dateToMillisString = string.substring(matcher.start(), matcher.end());\n      Matcher argMatcher = Pattern.compile(\"\\\\(.*\\\\)\").matcher(dateToMillisString);\n      argMatcher.find();\n      String argsString =\n          dateToMillisString.substring(argMatcher.start() + 1, argMatcher.end() - 1);\n      argsString = doDynamicReplacement(argsString, metadata);\n      String[] args = argsString.split(\",\");\n      String dateString = args[0].trim();\n      String dateType = args[1].trim();\n      String epochString = args[2].trim();\n      Calendar date = DateUtils.toCalendar(dateString, DateUtils.FormatType.valueOf(dateType));\n      Calendar epoch = DateUtils.toLocalCustomFormatCalendar(epochString, \"yyyy-MM-dd\");\n      String milliseconds = DateUtils.getTimeInMillis(date, epoch) + \"\";\n      string = StringUtils.replace(string, dateToMillisString, milliseconds);\n      matcher = utcToTaiPattern.matcher(string);\n    }\n    return string;\n  }\n"}, {"dataset": "find", "exampleID": 5694, "initialization": ["Matcher matcher = compile(String)"], "initializationStart": [1076], "initializationEnd": [1116], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 1151, "focalAPIEnd": 1159, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.find()", "assertTrue(result)"], "useStart": [1140, 1243, 1232], "useEnd": [1160, 1251, 1252], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/matthieu/simplex/tree/master/src/test/java/com/intalio/simplex/http/RestfulSimPELTest.java", "rawCode": "  public void testCounter() throws Exception {\n    server.start();\n    server.deploy(COUNTER);\n\n    ClientConfig cc = new DefaultClientConfig();\n    Client c = Client.create(cc);\n\n    // Starting the counter process\n    WebResource wr = c.resource(\"http://localhost:3434/counter\"); // TODO default on process name\n    ClientResponse createResponse =\n        wr.path(\"/\")\n            .accept(\"application/xml\")\n            .type(\"application/xml\")\n            .post(ClientResponse.class, \"<counter>3</counter>\");\n    String response = createResponse.getEntity(String.class);\n    String location = createResponse.getMetadata().get(\"Location\").get(0);\n    assertTrue(createResponse.getStatus() == 201);\n    assertTrue(location.matches(\".*/counter/[0-9]*$\"));\n    assertTrue(response.indexOf(\"<counter>3</counter>\") > 0);\n\n    // Requesting links\n    WebResource instance = c.resource(location);\n    ClientResponse queryResponse =\n        instance.path(\"/\").type(\"application/xml\").get(ClientResponse.class);\n    response = queryResponse.getEntity(String.class);\n\n    Matcher m = Pattern.compile(\"/counter/[0-9]*/value\").matcher(response);\n    assertTrue(m.find());\n    m = Pattern.compile(\"/counter/[0-9]*/dec\").matcher(response);\n    assertTrue(m.find());\n    assertTrue(queryResponse.getStatus() == 200);\n\n    // Requesting counter value to check the initial is correct\n    ClientResponse valueResponse =\n        instance.path(\"/value\").type(\"application/xml\").get(ClientResponse.class);\n    response = valueResponse.getEntity(String.class);\n    assertTrue(valueResponse.getStatus() == 200);\n    assertTrue(response.indexOf(\"3\") >= 0);\n\n    // Incrementing twice\n    ClientResponse incResponse;\n    for (int n = 0; n < 2; n++) {\n      incResponse = instance.path(\"/inc\").type(\"application/xml\").post(ClientResponse.class);\n      response = incResponse.getEntity(String.class);\n      assertTrue(incResponse.getStatus() == 200);\n      System.out.println(\"=> \" + response);\n      assertTrue(response.indexOf(\"\" + (4 + n)) >= 0);\n    }\n\n    // Checking value again, should be 5 now\n    valueResponse = instance.path(\"/value\").type(\"application/xml\").get(ClientResponse.class);\n    response = valueResponse.getEntity(String.class);\n    assertTrue(valueResponse.getStatus() == 200);\n    assertTrue(response.indexOf(\"5\") >= 0);\n\n    // Decrementing counter to 0 to let process complete\n    ClientResponse decResponse;\n    for (int n = 0; n < 5; n++) {\n      decResponse = instance.path(\"/dec\").type(\"application/xml\").post(ClientResponse.class);\n      response = decResponse.getEntity(String.class);\n      assertTrue(valueResponse.getStatus() == 200);\n      assertTrue(response.indexOf(\"\" + (4 - n)) >= 0);\n    }\n\n    // The process shouldn't be here anymore\n    Thread.sleep(1500);\n    queryResponse = instance.path(\"/\").type(\"application/xml\").get(ClientResponse.class);\n    assertTrue(queryResponse.getStatus() == 410);\n  }\n"}, {"dataset": "find", "exampleID": 5695, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [190], "initializationEnd": [227], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 245, "focalAPIEnd": 253, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.start()", "matcher.end()", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)", "matcher.find()", "assertTrue(result)", "matcher.start()", "matcher.end()", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)", "matcher.find()", "assertFalse(result)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)", "matcher.start(int)", "matcher.end(int)", "matcher.group(int)"], "useStart": [234, 276, 308, 338, 371, 402, 435, 463, 592, 719, 848, 978, 1106, 1235, 1224, 1266, 1299, 1329, 1363, 1395, 1429, 1457, 1586, 1713, 1842, 1972, 2100, 2230, 2218, 2258, 2379, 2498, 2619, 2741, 2861], "useEnd": [254, 285, 315, 348, 379, 412, 443, 473, 600, 729, 859, 987, 1117, 1243, 1244, 1275, 1306, 1339, 1371, 1405, 1437, 1467, 1594, 1723, 1853, 1981, 2111, 2238, 2239, 2268, 2387, 2508, 2630, 2750, 2872], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codefireX/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/Matcher2Test.java", "rawCode": "  public void testErrorConditions2() throws PatternSyntaxException {\n    // Test match cursors in absence of a match\n    Pattern p = Pattern.compile(\"(foo[0-9])(bar[a-z])\");\n    Matcher m = p.matcher(\"foo1barzfoo2baryfoozbar5\");\n\n    assertTrue(m.find());\n    assertEquals(0, m.start());\n    assertEquals(8, m.end());\n    assertEquals(0, m.start(1));\n    assertEquals(4, m.end(1));\n    assertEquals(4, m.start(2));\n    assertEquals(8, m.end(2));\n\n    try {\n      m.start(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.end(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.group(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.start(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.end(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.group(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    assertTrue(m.find());\n    assertEquals(8, m.start());\n    assertEquals(16, m.end());\n    assertEquals(8, m.start(1));\n    assertEquals(12, m.end(1));\n    assertEquals(12, m.start(2));\n    assertEquals(16, m.end(2));\n\n    try {\n      m.start(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.end(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.group(3);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.start(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.end(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    try {\n      m.group(-1);\n      fail(\"IndexOutOfBoundsException expected\");\n    } catch (IndexOutOfBoundsException e) {\n    }\n\n    assertFalse(m.find());\n\n    try {\n      m.start(3);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n\n    try {\n      m.end(3);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n\n    try {\n      m.group(3);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n\n    try {\n      m.start(-1);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n\n    try {\n      m.end(-1);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n\n    try {\n      m.group(-1);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5696, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [572], "initializationEnd": [595], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 602, "focalAPIEnd": 614, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group(int)", "matcher.group(int)"], "useStart": [641, 683], "useEnd": [655, 697], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/widteam/project/tree/master/03_grafikus/src/bhdlParser.java", "rawCode": "  /**\n   * Elvileg lehetoseg van a BHDL fajlban is megadni az Inputok kezdo ertekeit...\n   *\n   * @param owner a Composit, melyben a parancsot talaltuk\n   * @param command maga a prancs\n   * @return true, ha allitott az elemn, false egyebkent\n   * @throws ExceptionObjectNotFound\n   * @throws NumberFormatException\n   */\n  private static boolean SettingElement(Composit owner, String command)\n      throws NumberFormatException, ExceptionObjectNotFound {\n    String reg_set = \"set[ ]+([\\\\w]+)=([\\\\d]+);\";\n    Pattern regexp = Pattern.compile(reg_set);\n    Matcher match = regexp.matcher(command);\n\n    match.find();\n    String elementname = match.group(1).trim();\n    String value = match.group(2).trim();\n    String elementtype = owner.GetElementByName(elementname).GetType();\n    if (elementtype.equalsIgnoreCase(\"SWITCH\")) {\n      owner.SetSwitch(Integer.parseInt(value), owner.GetElementByName(elementname).GetID());\n      return true;\n    } else if (elementtype.equalsIgnoreCase(\"GENERATOR\")) {\n      owner.SetSequence(value, owner.GetElementByName(elementname).GetID());\n      return true;\n    }\n\n    return false;\n  }\n"}, {"dataset": "find", "exampleID": 5697, "initialization": ["Matcher matcher = matcher(String)"], "initializationStart": [136], "initializationEnd": [192], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 212, "focalAPIEnd": 220, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertThat(result,*)", "matcher.groupCount()", "matcher.group(int)", "matcher.group(int)", "matcher.find()", "assertThat(result,*)", "matcher.groupCount()", "matcher.group(int)"], "useStart": [201, 250, 291, 342, 522, 511, 560, 601], "useEnd": [231, 264, 301, 352, 530, 541, 574, 611], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jenkinsci/backlog-plugin/tree/master/src/test/java/hudson/plugins/backlog/BacklogChangelogAnnotatorTest.java", "rawCode": "  @Test\n  public final void testIssuePattern_WithUnderscore() {\n    {\n      String src = \"[[BLG_2-123]]について、対応しました。\";\n      Matcher m = BacklogChangelogAnnotator.ISSUE_KEY_PATTERN.matcher(src);\n\n      assertThat(m.find(), is(true));\n      assertThat(m.groupCount(), is(2));\n      assertThat(m.group(0), is(\"[[BLG_2-123]]\"));\n      assertThat(m.group(2), is(\"BLG_2-123\"));\n    }\n    {\n      String src = \"BLG_2-123について、対応しました。\";\n      Matcher m = BacklogChangelogAnnotator.ISSUE_KEY_PATTERN.matcher(src);\n\n      assertThat(m.find(), is(true));\n      assertThat(m.groupCount(), is(2));\n      assertThat(m.group(1), is(\"BLG_2-123\"));\n    }\n  }\n"}, {"dataset": "find", "exampleID": 5698, "initialization": ["Matcher matcher = RegexCache.getPatternForRegex(String)"], "initializationStart": [308], "initializationEnd": [352], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 386, "focalAPIEnd": 394, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["matcher.group()"], "useStart": [450], "useEnd": [459], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/google-libphonenumber-mirror/tree/master/tags/libphonenumber-6.1/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java", "rawCode": "  private String getFormattingTemplate(String numberPattern, String numberFormat) {\n    // Creates a phone number consisting only of the digit 9 that matches the\n    // numberPattern by applying the pattern to the longestPhoneNumber string.\n    String longestPhoneNumber = \"999999999999999\";\n    Matcher m = regexCache.getPatternForRegex(numberPattern).matcher(longestPhoneNumber);\n    m.find(); // this will always succeed\n    String aPhoneNumber = m.group();\n    // No formatting template can be created if the number of digits entered so far is longer than\n    // the maximum the current formatting rule can accommodate.\n    if (aPhoneNumber.length() < nationalNumber.length()) {\n      return \"\";\n    }\n    // Formats the number according to numberFormat\n    String template = aPhoneNumber.replaceAll(numberPattern, numberFormat);\n    // Replaces each digit with character DIGIT_PLACEHOLDER\n    template = template.replaceAll(\"9\", DIGIT_PLACEHOLDER);\n    return template;\n  }\n"}, {"dataset": "find", "exampleID": 5699, "initialization": ["Matcher matcher = Pattern.matcher(String)"], "initializationStart": [350], "initializationEnd": [369], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()"], "configurationStart": [386], "configurationEnd": [398], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find(start)", "focalAPIStart": 416, "focalAPIEnd": 426, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertTrue(result)", "matcher.lookingAt()"], "useStart": [405, 444], "useEnd": [427, 458], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/regex/src/test/java/org/apache/harmony/regex/tests/java/util/regex/Pattern2Test.java", "rawCode": "  @TestTargetNew(\n    level = TestLevel.PARTIAL_COMPLETE,\n    notes = \"Verifies matches(String regex, CharSequence input) method.\",\n    method = \"matches\",\n    args = {java.lang.String.class, java.lang.CharSequence.class}\n  )\n  public void testSimpleMatch() throws PatternSyntaxException {\n    Pattern p = Pattern.compile(\"foo.*\");\n\n    Matcher m1 = p.matcher(\"foo123\");\n    assertTrue(m1.matches());\n    assertTrue(m1.find(0));\n    assertTrue(m1.lookingAt());\n\n    Matcher m2 = p.matcher(\"fox\");\n    assertFalse(m2.matches());\n    assertFalse(m2.find(0));\n    assertFalse(m2.lookingAt());\n\n    assertTrue(Pattern.matches(\"foo.*\", \"foo123\"));\n    assertFalse(Pattern.matches(\"foo.*\", \"fox\"));\n\n    assertFalse(Pattern.matches(\"bar\", \"foobar\"));\n\n    assertTrue(Pattern.matches(\"\", \"\"));\n  }\n"}, {"dataset": "find", "exampleID": 5700, "initialization": ["Matcher matcher = Pattern.matcher(String)", "Matcher matcher = Pattern.matcher(String)"], "initializationStart": [238, 421], "initializationEnd": [261, 444], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["matcher.matches()"], "configurationStart": [279], "configurationEnd": [292], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = matcher.find()", "focalAPIStart": 462, "focalAPIEnd": 472, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertFalse(result)"], "useStart": [450], "useEnd": [473], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/PatternTest.java", "rawCode": "  public void testGroupsWithSurrogatesSupplementary() {\n\n    // this pattern matches nothing\n    String patString = \"(\\uD9A0)\\uDE81\";\n    String testString = \"\\uD9A0\\uDE81\";\n    Pattern pat = Pattern.compile(patString);\n    Matcher mat = pat.matcher(testString);\n    assertFalse(mat.matches());\n\n    patString = \"(\\uD9A0)\";\n    testString = \"\\uD9A0\\uDE81\";\n    pat = Pattern.compile(patString, Pattern.DOTALL);\n    mat = pat.matcher(testString);\n    assertFalse(mat.find());\n  }\n"}]