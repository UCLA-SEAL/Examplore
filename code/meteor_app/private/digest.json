[{"dataset": "digest", "exampleID": 5801, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [77], "initializationEnd": [109], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["getName()", "getLogger(*)", "log(*,*,*)"], "tryExpressionStart": 46, "tryExpressionEnd": 50, "tryBlockStart": 46, "tryBlockEnd": 523, "catchExpressionStart": 401, "catchExpressionEnd": 437, "catchBlockStart": 401, "catchBlockEnd": 523, "exceptionHandlingCallStart": [462, 445, 445], "exceptionHandlingCallEnd": [487, 488, 516], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [117], "configurationEnd": [140], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 166, "focalAPIEnd": 177, "followUpCheck": "i < result.length", "checkType": "LOOP", "followUpCheckExpressionStart": 231, "followUpCheckExpressionEnd": 272, "followUpCheckBlockStart": 231, "followUpCheckBlockEnd": 366, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tizianolattisi/suitepa/tree/master/src/com/axiastudio/suite/SuiteUtil.java", "rawCode": "  public static String digest(String s) {\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n      md.update(s.getBytes());\n      byte byteData[] = md.digest();\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < byteData.length; i++) {\n        sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n      }\n      return sb.toString();\n    } catch (NoSuchAlgorithmException ex) {\n      Logger.getLogger(SuiteUtil.class.getName()).log(Level.SEVERE, null, ex);\n    }\n    return null;\n  }\n"}, {"dataset": "digest", "exampleID": 5802, "initialization": ["MessageDigest messageDigest = getInstance(String)", "MessageDigest messageDigest = getInstance(String)"], "initializationStart": [400, 488], "initializationEnd": [432, 521], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [1037], "configurationEnd": [1056], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 1069, "focalAPIEnd": 1081, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kyau/connectbot/tree/master/src/com/trilead/ssh2/KnownHosts.java", "rawCode": "  /**\n   * Generates a \"raw\" fingerprint of a hostkey.\n   *\n   * @param type either \"md5\" or \"sha1\"\n   * @param keyType either \"ssh-rsa\" or \"ssh-dss\"\n   * @param hostkey the hostkey\n   * @return the raw fingerprint\n   */\n  private static final byte[] rawFingerPrint(String type, String keyType, byte[] hostkey) {\n    MessageDigest dig = null;\n\n    try {\n      if (\"md5\".equals(type)) {\n        dig = MessageDigest.getInstance(\"MD5\");\n      } else if (\"sha1\".equals(type)) {\n        dig = MessageDigest.getInstance(\"SHA1\");\n      } else {\n        throw new IllegalArgumentException(\"Unknown hash type \" + type);\n      }\n    } catch (NoSuchAlgorithmException e) {\n      throw new IllegalArgumentException(\"Unknown hash type \" + type);\n    }\n\n    if (keyType.startsWith(\"ecdsa-sha2-\")) {\n    } else if (\"ssh-rsa\".equals(keyType)) {\n    } else if (\"ssh-dss\".equals(keyType)) {\n    } else throw new IllegalArgumentException(\"Unknown key type \" + keyType);\n\n    if (hostkey == null) throw new IllegalArgumentException(\"hostkey is null\");\n\n    dig.update(hostkey);\n    return dig.digest();\n  }\n"}, {"dataset": "digest", "exampleID": 5803, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [590], "initializationEnd": [623], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [1510], "configurationEnd": [1535], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 1763, "focalAPIEnd": 1774, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["encode(result)"], "useStart": [1749], "useEnd": [1775], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/liquidware/liquidware_beagleboard_android_build/tree/master/tools/signapk/SignApk.java", "rawCode": "  /** Add the SHA1 of every file to the manifest, creating it if necessary. */\n  private static Manifest addDigestsToManifest(JarFile jar)\n      throws IOException, GeneralSecurityException {\n    Manifest input = jar.getManifest();\n    Manifest output = new Manifest();\n    Attributes main = output.getMainAttributes();\n    if (input != null) {\n      main.putAll(input.getMainAttributes());\n    } else {\n      main.putValue(\"Manifest-Version\", \"1.0\");\n      main.putValue(\"Created-By\", \"1.0 (Android SignApk)\");\n    }\n\n    BASE64Encoder base64 = new BASE64Encoder();\n    MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n    byte[] buffer = new byte[4096];\n    int num;\n\n    // We sort the input entries by name, and add them to the\n    // output manifest in sorted order. We expect that the output\n    // map will be deterministic.\n\n    TreeMap<String, JarEntry> byName = new TreeMap<String, JarEntry>();\n\n    for (Enumeration<JarEntry> e = jar.entries(); e.hasMoreElements(); ) {\n      JarEntry entry = e.nextElement();\n      byName.put(entry.getName(), entry);\n    }\n\n    for (JarEntry entry : byName.values()) {\n      String name = entry.getName();\n      if (!entry.isDirectory()\n          && !name.equals(JarFile.MANIFEST_NAME)\n          && !name.equals(CERT_SF_NAME)\n          && !name.equals(CERT_RSA_NAME)\n          && (stripPattern == null || !stripPattern.matcher(name).matches())) {\n        InputStream data = jar.getInputStream(entry);\n        while ((num = data.read(buffer)) > 0) {\n          md.update(buffer, 0, num);\n        }\n\n        Attributes attr = null;\n        if (input != null) attr = input.getAttributes(name);\n        attr = attr != null ? new Attributes(attr) : new Attributes();\n        attr.putValue(\"SHA1-Digest\", base64.encode(md.digest()));\n        output.getEntries().put(name, attr);\n      }\n    }\n\n    return output;\n  }\n"}, {"dataset": "digest", "exampleID": 5804, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [595, 618], "configurationEnd": [610, 635], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 655, "focalAPIEnd": 666, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Hash.setHash(result)", "messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.reset()"], "useStart": [674, 724, 1061, 1084, 1458], "useEnd": [687, 734, 1076, 1101, 1468], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/tags/release_3_2_1/appia/src/org/continuent/appia/test/xml/IntegritySession.java", "rawCode": "  /**\n   * Handles all events related to messenger features: TextEvent, DrawEvent, ImageEvent,\n   * ClearWhiteBoardEvent, MouseButtonEvent\n   *\n   * <p>If an event direction is DOWN an hash is generated otherwise received and calculated hashes\n   * are compared. <br>\n   * Different hashes mean that an event is ignored\n   *\n   * @param ev\n   */\n  private void handleInterestingEvent(GroupSendableEvent ev) {\n\n    Message message = ev.getMessage();\n    byte[] data;\n    Hash h = new Hash();\n    // String type;\n\n    if (ev.getDir() == Direction.DOWN) {\n      data = message.toByteArray();\n      md.update(data);\n      md.update(secret);\n      byte[] my = md.digest();\n      h.setHash(my);\n      message.pushObject(h);\n      md.reset();\n      // out.println(\"MD calculated\");\n      ev.setObjectsMessage(message);\n      try {\n        ev.go();\n      } catch (AppiaEventException e) {\n        e.printStackTrace();\n      }\n\n    } else {\n      // incoming hash\n      h = (Hash) message.popObject();\n      data = message.toByteArray();\n\n      // calculates hash\n      md.update(data);\n      md.update(secret);\n\n      if (MessageDigest.isEqual(md.digest(), h.getHash())) {\n        // out.println(\"Valid\");\n        try {\n          ev.go();\n        } catch (AppiaEventException e) {\n          e.printStackTrace();\n        }\n      }\n      // else{\n      // out.println(\"Error! Compromised message received!\");\n      // out.println(\"Message ignored!\");\n      // }\n      md.reset();\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5805, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [371], "initializationEnd": [403], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "new KrbCryptoException(*)"], "tryExpressionStart": 535, "tryExpressionEnd": 539, "tryBlockStart": 535, "tryBlockEnd": 679, "catchExpressionStart": 600, "catchExpressionEnd": 620, "catchBlockStart": 600, "catchBlockEnd": 679, "exceptionHandlingCallStart": [657, 634], "exceptionHandlingCallEnd": [671, 672], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [547], "configurationEnd": [563], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 580, "focalAPIEnd": 592, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/barchart/barchart-udt/tree/master/barchart-udt-reference-jdk6/src/main/java/sun/security/krb5/internal/crypto/RsaMd5CksumType.java", "rawCode": "  /**\n   * Calculates checksum using MD5.\n   *\n   * @param data the data used to generate the checksum.\n   * @param size length of the data.\n   * @return the checksum.\n   * @modified by Yanni Zhang, 12/08/99.\n   */\n  public byte[] calculateChecksum(byte[] data, int size) throws KrbCryptoException {\n    MessageDigest md5;\n    byte[] result = null;\n    try {\n      md5 = MessageDigest.getInstance(\"MD5\");\n    } catch (Exception e) {\n      throw new KrbCryptoException(\"JCE provider may not be installed. \" + e.getMessage());\n    }\n    try {\n      md5.update(data);\n      result = md5.digest();\n    } catch (Exception e) {\n      throw new KrbCryptoException(e.getMessage());\n    }\n    return result;\n  }\n"}, {"dataset": "digest", "exampleID": 5806, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [657], "initializationEnd": [693], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [699], "configurationEnd": [742], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 791, "focalAPIEnd": 801, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(int,result)"], "useStart": [773], "useEnd": [802], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jonathanellis/Clone-Detector/tree/master/src/uk/ac/ucl/cs/clonedetector/Index.java", "rawCode": "  /**\n   * Computes a fingerprint for a single line using the supplied algorithm.\n   *\n   * @param line The line to be fingerprinted.\n   * @param algorithm The algorithm to do the fingerprinting.\n   * @return The fingerprint of the line.\n   * @throws NoSuchAlgorithmException Thrown if the algorithm is not available on the system.\n   */\n  public static BigInteger computeFingerprint(String line, String algorithm)\n      throws NoSuchAlgorithmException {\n\n    if (algorithm.equals(\"StringHashCode\")) return BigInteger.valueOf(line.hashCode());\n\n    // Else hand over to MessageDigest:\n    if (line.equals(\"\")) return BigInteger.ZERO;\n\n    MessageDigest m = MessageDigest.getInstance(algorithm);\n    m.update(line.getBytes(), 0, line.length());\n    BigInteger fingerprint = new BigInteger(1, m.digest());\n    return fingerprint;\n  }\n"}, {"dataset": "digest", "exampleID": 5807, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [90], "initializationEnd": [122], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 59, "tryExpressionEnd": 63, "tryBlockStart": 59, "tryBlockEnd": 501, "catchExpressionStart": 414, "catchExpressionEnd": 449, "catchBlockStart": 414, "catchBlockEnd": 501, "exceptionHandlingCallStart": [457], "exceptionHandlingCallEnd": [476], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [130], "configurationEnd": [155], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 181, "focalAPIEnd": 192, "followUpCheck": "i < result.length", "checkType": "LOOP", "followUpCheckExpressionStart": 244, "followUpCheckExpressionEnd": 285, "followUpCheckBlockStart": 244, "followUpCheckBlockEnd": 379, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/irunarae/securoid_project/tree/master/client/Securoid_Hashing.java", "rawCode": "  public String MD5(String str) {\n    String MD5 = \"\";\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n      md.update(str.getBytes());\n      byte byteData[] = md.digest();\n      StringBuffer sb = new StringBuffer();\n      for (int i = 0; i < byteData.length; i++) {\n        sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n      }\n      MD5 = sb.toString();\n\n    } catch (NoSuchAlgorithmException e) {\n      e.printStackTrace();\n      MD5 = null;\n    }\n    return MD5;\n  }\n"}, {"dataset": "digest", "exampleID": 5808, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [84], "initializationEnd": [116], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()", "new RuntimeException(*)"], "tryExpressionStart": 54, "tryExpressionEnd": 58, "tryBlockStart": 54, "tryBlockEnd": 375, "catchExpressionStart": 284, "catchExpressionEnd": 304, "catchBlockStart": 284, "catchBlockEnd": 375, "exceptionHandlingCallStart": [312, 345], "exceptionHandlingCallEnd": [331, 368], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 177, "focalAPIEnd": 191, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new ByteArrayInputStream(result)"], "useStart": [152], "useEnd": [192], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Mobisocial/dungbeetle/tree/master/src/edu/stanford/mobisocial/dungbeetle/DBHelper.java", "rawCode": "  public static long hashPublicKey(byte[] data) {\n    try {\n      MessageDigest m = MessageDigest.getInstance(\"MD5\");\n      ByteArrayInputStream bais = new ByteArrayInputStream(m.digest(data));\n      DataInputStream dis = new DataInputStream(bais);\n      return dis.readLong();\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5809, "initialization": ["MessageDigest messageDigest = getInstance(String,String)"], "initializationStart": [192], "initializationEnd": [230], "hasTryCatch": 1, "exceptionType": "CertificateEncodingException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 111, "tryExpressionEnd": 115, "tryBlockStart": 111, "tryBlockEnd": 527, "catchExpressionStart": 315, "catchExpressionEnd": 354, "catchBlockStart": 315, "catchBlockEnd": 388, "exceptionHandlingCallStart": [362], "exceptionHandlingCallEnd": [381], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [238], "configurationEnd": [271], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 285, "focalAPIEnd": 307, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toHex(result)"], "useStart": [539], "useEnd": [556], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bomm/thera-pi-2/tree/master/Nebraska/src/nebraska/BCStatics2.java", "rawCode": "  public static String getMD5(X509Certificate cert) {\n    byte[] encryptCert;\n    byte[] dig = null;\n    ;\n    try {\n      encryptCert = cert.getEncoded();\n      MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\", \"BC\");\n      messageDigest.update(encryptCert);\n      dig = messageDigest.digest();\n    } catch (CertificateEncodingException e) {\n      e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n      e.printStackTrace();\n    } catch (NoSuchProviderException e) {\n      e.printStackTrace();\n    }\n    return NUtils.toHex(dig);\n  }\n"}, {"dataset": "digest", "exampleID": 5810, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [1297], "initializationEnd": [1329], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 1262, "tryExpressionEnd": 1266, "tryBlockStart": 1262, "tryBlockEnd": 1557, "catchExpressionStart": 1477, "catchExpressionEnd": 1497, "catchBlockStart": 1477, "catchBlockEnd": 1557, "exceptionHandlingCallStart": [1509], "exceptionHandlingCallEnd": [1546], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [1341], "configurationEnd": [1397], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 1440, "focalAPIEnd": 1451, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(int,result)"], "useStart": [1422], "useEnd": [1452], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/HSR01/KBS_JAVA/tree/master/java_backend/src/java_backend/PersoonNieuw.java", "rawCode": "  public void actionPerformed(ActionEvent ae) {\n    if (ae.getSource() == btOpslaan) {\n      // Controleer of de verplichte velden zijn ingevuld\n      if (pfWachtwoord.getText().equals(\"\")\n          || tfVoornaam.getText().equals(\"\")\n          || tfAchternaam.getText().equals(\"\")\n          || tfPlaatsnaam.getText().equals(\"\")\n          || tfPostcode.getText().equals(\"\")\n          || tfStraatnaam.getText().equals(\"\")\n          || tfHuisnummer.getText().equals(\"\")\n          || tfIBANnummer.getText().equals(\"\")\n          || tfMobielnummer.getText().equals(\"\")\n          || tfEmailadres.getText().equals(\"\")\n          || tfAchternaam.getText().equals(\"\")\n          || tfMobielnummer.getText().equals(\"\")) {\n        JOptionPane.showMessageDialog(\n            this,\n            \"Niet alle verplichte velden zijn ingevuld, Controleer de velden en probeer het opnieuw.\");\n      } else if (!isInteger(tfHuisnummer.getText())) {\n        JOptionPane.showMessageDialog(this, \"Het huisnummer is geen nummer.\");\n      } else if (!isValidEmailAddress(tfEmailadres.getText())) {\n        JOptionPane.showMessageDialog(this, \"Het e-mail adres is ongeldig.\");\n      } else {\n        // Hash het wachtwoord naar MD5\n        String wachtwoord = pfWachtwoord.getText();\n        try {\n          MessageDigest md = MessageDigest.getInstance(\"MD5\");\n          md.update(wachtwoord.getBytes(), 0, wachtwoord.length());\n          wachtwoord = new BigInteger(1, md.digest()).toString(16);\n        } catch (Exception o) {\n          System.out.println(\"Hash Error:\" + o);\n        }\n\n        // Datum maken\n        datDag = \"\" + this.dag.getSelectedItem();\n        if (datDag.length() < 2) {\n          datumDag = (String) \"0\" + dag.getSelectedItem();\n        } else {\n          datumDag = (String) \"\" + dag.getSelectedItem();\n        }\n\n        datMaand = (String) maand.getSelectedItem();\n        if (datMaand.equals(\"Januari\")) {\n          datumMaand = \"01\";\n        } else if (datMaand.equals(\"Februari\")) {\n          datumMaand = \"02\";\n        } else if (datMaand.equals(\"Maart\")) {\n          datumMaand = \"03\";\n        } else if (datMaand.equals(\"April\")) {\n          datumMaand = \"04\";\n        } else if (datMaand.equals(\"Mei\")) {\n          datumMaand = \"05\";\n        } else if (datMaand.equals(\"Juni\")) {\n          datumMaand = \"06\";\n        } else if (datMaand.equals(\"Juli\")) {\n          datumMaand = \"07\";\n        } else if (datMaand.equals(\"Augustus\")) {\n          datumMaand = \"08\";\n        } else if (datMaand.equals(\"September\")) {\n          datumMaand = \"09\";\n        } else if (datMaand.equals(\"Oktober\")) {\n          datumMaand = \"10\";\n        } else if (datMaand.equals(\"November\")) {\n          datumMaand = \"11\";\n        } else {\n          datumMaand = \"12\";\n        }\n\n        datumJaar = \"\" + jaar.getSelectedItem();\n\n        datum = datumDag + \"-\" + datumMaand + \"-\" + datumJaar;\n\n        // Rechten\n\n        rechten = (String) recht.getSelectedItem();\n        int gebruikerniveau = 0;\n        if (rechten.equals(\"Geblokkeerd\")) {\n          gebruikerniveau = 0;\n        }\n        if (rechten.equals(\"Verzender / Ontvanger / Klanten\")) {\n          gebruikerniveau = 1;\n        }\n        if (rechten.equals(\"TZT Point / BPS'er\")) {\n          gebruikerniveau = 2;\n        }\n        if (rechten.equals(\"TZT Medewerker\")) {\n          gebruikerniveau = 3;\n        }\n        if (rechten.equals(\"Hoofdkantoor\")) {\n          gebruikerniveau = 4;\n        }\n\n        // Sla de gegevens op in de database\n        Geocoding geo = new Geocoding();\n        Boolean geosucces = null;\n        try {\n          cords =\n              geo.QueryAndGetCoordinates(\n                  tfPlaatsnaam.getText(),\n                  tfStraatnaam.getText(),\n                  Integer.parseInt(tfHuisnummer.getText()));\n          this.latitude = \"\" + cords.Latitude;\n          this.longitude = \"\" + cords.Longitude;\n          geosucces = true;\n        } catch (MultipleAdressesFoundException ex) {\n          JOptionPane.showMessageDialog(this, \"Er gaat iets mis met toevoegen van de locatie.\");\n          geosucces = false;\n        }\n        // als er geen locatie is mag de persoon ook niet worden toegevoegd.\n        if (geosucces) {\n          // alle queries\n          // Connectie aanmaken\n          DbConnect dbc = new DbConnect();\n          // Locatie inserten\n          dbc.insertData(\n              \"Locatie\",\n              this.latitude,\n              this.longitude,\n              tfPlaatsnaam.getText(),\n              tfStraatnaam.getText(),\n              tfHuisnummer.getText(),\n              tfToevoeging.getText(),\n              tfPostcode.getText(),\n              tfMobielnummer.getText(),\n              \"0\");\n          // LocatieID ophalen van de insert query\n          int locatieID =\n              dbc.getLocatieID(\n                  \"SELECT LocatieID From Locatie where Plaatsnaam = '\"\n                      + tfPlaatsnaam.getText()\n                      + \"' and Straatnaam = '\"\n                      + tfStraatnaam.getText()\n                      + \"' and Huisnummer = '\"\n                      + tfHuisnummer.getText()\n                      + \"' and Toevoeging = '\"\n                      + tfToevoeging.getText()\n                      + \"' and Postcode = '\"\n                      + tfPostcode.getText()\n                      + \"'\");\n          // Gebruiekr inserten met bijgevoegd locatieID\n          dbc.nieuweGebruiker(\n              \"INSERT INTO `Persoon` (`PersoonID`, `LocatieID`, `Voornaam`, `Tussenvoegsel`, `Achternaam`, `Emailadres`, `Wachtwoord`, `Geboortedatum`, `Mobielnummer`, `Profielfoto`, `IBAN`, `Rechten`) VALUES ( '0','\"\n                  + locatieID\n                  + \"','\"\n                  + tfVoornaam.getText()\n                  + \"','\"\n                  + tfTussenvoegsel.getText()\n                  + \"','\"\n                  + tfAchternaam.getText()\n                  + \"','\"\n                  + tfEmailadres.getText()\n                  + \"','\"\n                  + wachtwoord\n                  + \"','\"\n                  + datum\n                  + \"','\"\n                  + tfMobielnummer.getText()\n                  + \"','\"\n                  + null\n                  + \"','\"\n                  + tfIBANnummer.getText()\n                  + \"','\"\n                  + gebruikerniveau\n                  + \"')\");\n          // PersoonID ophalen\n          int persoonID =\n              dbc.getPersoonID(\n                  \"SELECT PersoonID FROM `Persoon` Where Emailadres = '\"\n                      + tfEmailadres.getText()\n                      + \"'\");\n          // Insert naar Persoon_Locatie voor koppeling\n          dbc.nieuweGebruiker(\n              \"INSERT INTO `Persoon_Locatie` (LocatieID, PersoonID) VALUES (\"\n                  + locatieID\n                  + \",\"\n                  + persoonID\n                  + \")\");\n          JOptionPane.showMessageDialog(this, \"De persoon is toegevoegd!\");\n        }\n      }\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5811, "initialization": ["MessageDigest messageDigest = getInstance(String)", "byte[] input = String.getBytes(String)"], "initializationStart": [130, 189], "initializationEnd": [166, 216], "hasTryCatch": 1, "exceptionType": "InvalidKeyException", "exceptionHandlingCall": ["getMessage()", "warn(*)", "getMessage()", "debug(*,*)"], "tryExpressionStart": 99, "tryExpressionEnd": 103, "tryBlockStart": 99, "tryBlockEnd": 928, "catchExpressionStart": 389, "catchExpressionEnd": 419, "catchBlockStart": 389, "catchBlockEnd": 519, "exceptionHandlingCallStart": [439, 427, 475, 462], "exceptionHandlingCallEnd": [453, 454, 489, 493], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 238, "focalAPIEnd": 254, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new SecretKeySpec(result,String)"], "useStart": [282], "useEnd": [318], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ieb/sparsemapcontent/tree/master/core/src/main/java/org/sakaiproject/nakamura/lite/accesscontrol/PrincipalTokenValidator.java", "rawCode": "  private String signToken(Content token, String sharedKey, PrincipalValidatorPlugin plugin) {\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"SHA-512\");\n      byte[] input = sharedKey.getBytes(\"UTF-8\");\n      byte[] data = md.digest(input);\n      SecretKeySpec key = new SecretKeySpec(data, HMAC_SHA512);\n      return getHmac(token, plugin.getProtectedFields(), key);\n    } catch (InvalidKeyException e) {\n      LOGGER.warn(e.getMessage());\n      LOGGER.debug(e.getMessage(), e);\n      return null;\n    } catch (NoSuchAlgorithmException e) {\n      LOGGER.warn(e.getMessage());\n      LOGGER.debug(e.getMessage(), e);\n      return null;\n    } catch (IllegalStateException e) {\n      LOGGER.warn(e.getMessage());\n      LOGGER.debug(e.getMessage(), e);\n      return null;\n    } catch (UnsupportedEncodingException e) {\n      LOGGER.warn(e.getMessage());\n      LOGGER.debug(e.getMessage(), e);\n      return null;\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5812, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [2154], "initializationEnd": [2186], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["returnErrorException(*,*,*)", "println(*)", "printStackTrace()"], "tryExpressionStart": 599, "tryExpressionEnd": 603, "tryBlockStart": 599, "tryBlockEnd": 4595, "catchExpressionStart": 4342, "catchExpressionEnd": 4362, "catchBlockStart": 4342, "catchBlockEnd": 4560, "exceptionHandlingCallStart": [4450, 4438, 4534], "exceptionHandlingCallEnd": [4525, 4526, 4553], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [2196], "configurationEnd": [2227], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 2275, "focalAPIEnd": 2287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(int,result)", "messageDigest.update(byte[])", "messageDigest.digest()", "new BigInteger(int,result)"], "useStart": [2257, 3245, 3326, 3308], "useEnd": [2288, 3275, 3338, 3339], "hasFinally": 1, "cleanUpCall": ["PrintWriter.close()"], "finallyExpressionStart": 4561, "finallyExpressionEnd": 4569, "finallyBlockStart": 4561, "finallyBlockEnd": 4595, "cleanUpCallStart": [4298], "cleanUpCallEnd": [4309], "url": "https://github.com/leoncool/healthbook/tree/master/src/servlets/usercontrol/Register.java", "rawCode": "  /**\n   * Processes requests for both HTTP <code>GET</code> and <code>POST</code> methods.\n   *\n   * @param request servlet request\n   * @param response servlet response\n   * @throws ServletException if a servlet-specific error occurs\n   * @throws IOException if an I/O error occurs\n   */\n  public void processRequest(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    response.setContentType(\"text/html\");\n    response.setCharacterEncoding(\"UTF-8\");\n    request.setCharacterEncoding(\"UTF-8\");\n    PrintWriter out = response.getWriter();\n    try {\n      if (request.getParameter(\"loginID\") == null\n          || request.getParameter(\"password\") == null\n          || request.getParameter(\"email\") == null) {\n        // out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        ReturnParser.outputErrorException(response, ErrorDictionary.MISSING_DATA, null, null);\n        out.close();\n        return;\n      }\n      HttpSession httpsession = request.getSession(true);\n      // String code = (String) httpsession.getAttribute(\"verification.code\");\n      // String attempt = request.getParameter(\"code\");\n      // if (code != null && code.toLowerCase().equals(attempt.toLowerCase()))\n      // {\n      // } else\n      // {\n      // out.println(\"<status>WRONG_CODE</status>\");\n      // out.close();\n      // return;\n      // }\n      String loginID = request.getParameter(\"loginID\");\n      String Password = request.getParameter(\"password\");\n      String Email = request.getParameter(\"email\");\n\n      UserDAO userdao = new UserDAO();\n      if (userdao.EmailExists(Email) == true) {\n        ReturnParser.outputErrorException(response, ErrorDictionary.email_Exist, null, Email);\n        out.close();\n        return;\n      }\n      if (userdao.getLogin(loginID) == null) {\n        Users user = new Users();\n        user.setLoginID(loginID);\n        user.setEmail(Email);\n        Date now = new Date();\n        DateFormat df = DateFormat.getDateTimeInstance();\n        user.setCreatedTime(now);\n\n        // save MD5 password\n        String MD5password = null;\n        MessageDigest md5;\n        md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(Password.getBytes());\n        BigInteger hashPw = new BigInteger(1, md5.digest());\n        MD5password = hashPw.toString(16);\n        while (MD5password.length() < 32) {\n          MD5password = \"0\" + MD5password;\n        }\n        user.setPassword(MD5password);\n        user.setLanguage(\"en\");\n        Session session = HibernateUtil.beginTransaction();\n        session.save(user);\n        session.getTransaction().commit();\n        SubjectDAO subDao = new SubjectDAO(); // create Default Subject and Datastreams\n        // out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        out.println(ReturnParser.returnValidResult(ValidDictionary.Valid));\n\n        String emailSubject = \"\";\n        // if (language.equalsIgnoreCase(\"cn\")) {\n        // emailSubject = \"Via Cloud é€šçŸ¥-æ³¨å†Œç¡®è®¤ä¿¡ï¼�\";\n        // } else if (language.equalsIgnoreCase(\"en\")) {\n        // emailSubject = \"Notification-Registration Completedï¼�\";\n        // }\n        String MD5username = null;\n        md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(loginID.getBytes());\n        BigInteger hashlogin = new BigInteger(1, md5.digest());\n        MD5username = hashlogin.toString(16);\n        while (MD5username.length() < 32) {\n          MD5username = \"0\" + MD5username;\n        }\n        // propertiesDAO pptDao = new propertiesDAO();\n        // String fromEmailAddress = pptDao.getPropertySettingByNameID(\"supportEmailAddress\");\n        // String billingServletUrl = pptDao.getPropertySettingByNameID(\"billingServletUrl\");\n        //\n        // EmailTemplateEngine ete = new EmailTemplateEngine();\n        // String activeLink = billingServletUrl +\n        // \"/billingCN/UserControl?RequestType=Verify&&login=\" + LoginUsername + \"&&token=\" +\n        // MD5username;\n        // String emailBody = ete.register(LoginUsername, Password, activeLink, language);\n        // new EmailThread(emailSubject, emailBody, user.getEmail(), fromEmailAddress).start();\n\n      } else {\n        out.println(\n            ReturnParser.returnErrorException(ErrorDictionary.LoginID_Exist, null, loginID));\n        out.close();\n        return;\n      }\n\n    } catch (Exception e) {\n      // out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n      out.println(ReturnParser.returnErrorException(ErrorDictionary.unknownFault, null, null));\n      e.printStackTrace();\n    } finally {\n      out.close();\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5813, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [368], "initializationEnd": [400], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["fatal(*,*)"], "tryExpressionStart": 337, "tryExpressionEnd": 341, "tryBlockStart": 337, "tryBlockEnd": 537, "catchExpressionStart": 484, "catchExpressionEnd": 504, "catchBlockStart": 484, "catchBlockEnd": 537, "exceptionHandlingCallStart": [512], "exceptionHandlingCallEnd": [530], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[],int,int)"], "configurationStart": [408, 426], "configurationEnd": [418, 450], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 465, "focalAPIEnd": 476, "followUpCheck": "i < result.length", "checkType": "LOOP", "followUpCheckExpressionStart": 543, "followUpCheckExpressionEnd": 580, "followUpCheckBlockStart": 543, "followUpCheckBlockEnd": 645, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mogotest/selenium/tree/master/remote/server/src/java/org/openqa/jetty/http/DigestAuthenticator.java", "rawCode": "  public String newNonce(HttpRequest request) {\n    long ts = request.getTimeStamp();\n    long sk = nonceSecret;\n\n    byte[] nounce = new byte[24];\n    for (int i = 0; i < 8; i++) {\n      nounce[i] = (byte) (ts & 0xff);\n      ts = ts >> 8;\n      nounce[8 + i] = (byte) (sk & 0xff);\n      sk = sk >> 8;\n    }\n\n    byte[] hash = null;\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n      md.reset();\n      md.update(nounce, 0, 16);\n      hash = md.digest();\n    } catch (Exception e) {\n      log.fatal(this, e);\n    }\n\n    for (int i = 0; i < hash.length; i++) {\n      nounce[8 + i] = hash[i];\n      if (i == 23) break;\n    }\n\n    return new String(B64Code.encode(nounce));\n  }\n"}, {"dataset": "digest", "exampleID": 5814, "initialization": ["byte[] input = ByteArrayOutputStream.toByteArray()"], "initializationStart": [1127], "initializationEnd": [1144], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.reset()"], "configurationStart": [85], "configurationEnd": [96], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 1164, "focalAPIEnd": 1180, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["equals(result,byte[])"], "useStart": [1218], "useEnd": [1249], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/security/tests/java/security/MessageDigest2Test.java", "rawCode": "  private void testSerializationSHA_DATA_1(MessageDigest sha) throws Exception {\n    sha.reset();\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    DataOutputStream output = new DataOutputStream(out);\n\n    // Made up data\n    output.writeUTF(\"tests.api.java.security.MessageDigestTest$OptionalDataNotRead\");\n    // name\n    output.writeInt(0); // class modifiers\n    output.writeUTF(\"java.io.Serializable\"); // interfaces\n\n    // Fields\n    output.writeUTF(\"class$0\"); // name\n    output.writeInt(8); // modifiers\n    output.writeUTF(\"Ljava/lang/Class;\"); // signature\n\n    output.writeUTF(\"field1\"); // name\n    output.writeInt(2); // modifiers\n    output.writeUTF(\"I\"); // signature\n\n    output.writeUTF(\"field2\"); // name\n    output.writeInt(2); // modifiers\n    output.writeUTF(\"I\"); // signature\n\n    // clinit\n    output.writeUTF(\"<clinit>\"); // name\n    output.writeInt(8); // modifiers\n    output.writeUTF(\"()V\"); // signature\n\n    // constructors\n    output.writeUTF(\"<init>\"); // name\n    output.writeInt(1); // modifiers\n    output.writeUTF(\"()V\"); // signature\n\n    output.flush();\n    byte[] data = out.toByteArray();\n    byte[] hash = sha.digest(data);\n    assertTrue(\"SHA_DATA_1 NOT ok\", Arrays.equals(hash, SHA_DATA_1));\n  }\n"}, {"dataset": "digest", "exampleID": 5815, "initialization": ["byte[] input = ByteArrayOutputStream.toByteArray()"], "initializationStart": [1785], "initializationEnd": [1802], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.reset()"], "configurationStart": [85], "configurationEnd": [96], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 1822, "focalAPIEnd": 1838, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["equals(result,byte[])"], "useStart": [1876], "useEnd": [1907], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/security/tests/java/security/MessageDigest2Test.java", "rawCode": "  private void testSerializationSHA_DATA_2(MessageDigest sha) throws Exception {\n    sha.reset();\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    DataOutputStream output = new DataOutputStream(out);\n\n    // Made up data\n    output.writeUTF(\"tests.api.java.security.MessageDigestTest$InitializerFieldsTest3\");\n    output.writeInt(0); // class modifiers\n    output.writeUTF(\"java.io.Serializable\"); // interfaces\n\n    // Fields\n    output.writeUTF(\"sub_toBeNotSerialized\"); // name\n    output.writeInt(9); // modifiers\n    output.writeUTF(\"Ljava/lang/String;\"); // signature\n\n    output.writeUTF(\"sub_toBeNotSerialized2\"); // name\n    output.writeInt(9); // modifiers\n    output.writeUTF(\"Ljava/lang/String;\"); // signature\n\n    output.writeUTF(\"sub_toBeSerialized\"); // name\n    output.writeInt(1); // modifiers\n    output.writeUTF(\"Ljava/lang/String;\"); // signature\n\n    output.writeUTF(\"sub_toBeSerialized3\"); // name\n    output.writeInt(1); // modifiers\n    output.writeUTF(\"Ljava/lang/String;\"); // signature\n\n    output.writeUTF(\"sub_toBeSerialized4\"); // name\n    output.writeInt(1); // modifiers\n    output.writeUTF(\"Ljava/lang/String;\"); // signature\n\n    output.writeUTF(\"sub_toBeSerialized5\"); // name\n    output.writeInt(1); // modifiers\n    output.writeUTF(\"Ljava/lang/String;\"); // signature\n\n    // clinit\n    output.writeUTF(\"<clinit>\"); // name\n    output.writeInt(8); // modifiers\n    output.writeUTF(\"()V\"); // signature\n\n    // constructors\n    output.writeUTF(\"<init>\"); // name\n    output.writeInt(0); // modifiers\n    output.writeUTF(\"()V\"); // signature\n\n    // methods\n    output.writeUTF(\"equals\"); // name\n    output.writeInt(1); // modifiers\n    output.writeUTF(\"(Ljava.lang.Object;)Z\"); // signature\n\n    output.flush();\n\n    byte[] data = out.toByteArray();\n    byte[] hash = sha.digest(data);\n    assertTrue(\"SHA_DATA_2 NOT ok\", Arrays.equals(hash, SHA_DATA_2));\n  }\n"}, {"dataset": "digest", "exampleID": 5816, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [770], "initializationEnd": [803], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new RuntimeException(String)"], "tryExpressionStart": 738, "tryExpressionEnd": 742, "tryBlockStart": 738, "tryBlockEnd": 1950, "catchExpressionStart": 1865, "catchExpressionEnd": 1885, "catchBlockStart": 1865, "catchBlockEnd": 1950, "exceptionHandlingCallStart": [1899], "exceptionHandlingCallEnd": [1943], "configuration": ["messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [940, 963], "configurationEnd": [953, 976], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 991, "focalAPIEnd": 1003, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["messageDigest.digest(byte[])", "arraycopy(result,int,byte[],*,*)", "concat(result,byte[],int,*)"], "useStart": [1047, 1071, 1163], "useEnd": [1061, 1122, 1189], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/src/share/classes/com/sun/crypto/provider/PKCS12PBECipherCore.java", "rawCode": "  static byte[] derive(char[] chars, byte[] salt, int ic, int n, int type) {\n    // Add in trailing NULL terminator.\n    int length = chars.length * 2;\n    if (length != 0) {\n      length += 2;\n    }\n    byte[] passwd = new byte[length];\n    for (int i = 0, j = 0; i < chars.length; i++, j += 2) {\n      passwd[j] = (byte) ((chars[i] >>> 8) & 0xFF);\n      passwd[j + 1] = (byte) (chars[i] & 0xFF);\n    }\n    int v = 512 / 8;\n    int u = 160 / 8;\n    int c = roundup(n, u) / u;\n    byte[] D = new byte[v];\n    int s = roundup(salt.length, v);\n    int p = roundup(passwd.length, v);\n    byte[] I = new byte[s + p];\n    byte[] key = new byte[n];\n\n    Arrays.fill(D, (byte) type);\n    concat(salt, I, 0, s);\n    concat(passwd, I, s, p);\n\n    try {\n      MessageDigest sha = MessageDigest.getInstance(\"SHA1\");\n      byte[] Ai;\n      byte[] B = new byte[v];\n      byte[] tmp = new byte[v];\n\n      int i = 0;\n      for (; ; i++, n -= u) {\n        sha.update(D);\n        sha.update(I);\n        Ai = sha.digest();\n        for (int r = 1; r < ic; r++) Ai = sha.digest(Ai);\n        System.arraycopy(Ai, 0, key, u * i, Math.min(n, u));\n        if (i + 1 == c) break;\n        concat(Ai, B, 0, B.length);\n        BigInteger B1;\n        B1 = new BigInteger(1, B).add(BigInteger.ONE);\n\n        for (int j = 0; j < I.length; j += v) {\n          BigInteger Ij;\n          int trunc;\n\n          if (tmp.length != v) tmp = new byte[v];\n          System.arraycopy(I, j, tmp, 0, v);\n          Ij = new BigInteger(1, tmp);\n          Ij = Ij.add(B1);\n          tmp = Ij.toByteArray();\n          trunc = tmp.length - v;\n          if (trunc >= 0) {\n            System.arraycopy(tmp, trunc, I, j, v);\n          } else if (trunc < 0) {\n            Arrays.fill(I, j, j + (-trunc), (byte) 0);\n            System.arraycopy(tmp, 0, I, j + (-trunc), tmp.length);\n          }\n        }\n      }\n    } catch (Exception e) {\n      throw new RuntimeException(\"internal error: \" + e);\n    }\n    return key;\n  }\n"}, {"dataset": "digest", "exampleID": 5817, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [411], "initializationEnd": [443], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["new AssertionError(*)"], "tryExpressionStart": 380, "tryExpressionEnd": 384, "tryBlockStart": 380, "tryBlockEnd": 571, "catchExpressionStart": 494, "catchExpressionEnd": 529, "catchBlockStart": 494, "catchBlockEnd": 571, "exceptionHandlingCallStart": [543], "exceptionHandlingCallEnd": [564], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null)", "guardType": "IF {", "guardExpressionStart": 310, "guardExpressionEnd": 327, "guardBlockStart": 310, "guardBlockEnd": 375, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 467, "focalAPIEnd": 482, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["makeUuid(result,int)"], "useStart": [458], "useEnd": [486], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/main/java/java/util/UUID.java", "rawCode": "  /**\n   * Generates a variant 2, version 3 (name-based, MD5-hashed) UUID as per <a\n   * href=\"http://www.ietf.org/rfc/rfc4122.txt\">RFC 4122</a>.\n   *\n   * @param name the name used as byte array to create an UUID.\n   * @return an UUID instance.\n   */\n  public static UUID nameUUIDFromBytes(byte[] name) {\n    if (name == null) {\n      throw new NullPointerException();\n    }\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n      return makeUuid(md.digest(name), 3);\n    } catch (NoSuchAlgorithmException e) {\n      throw new AssertionError(e);\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5818, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [201], "initializationEnd": [234], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [240], "configurationEnd": [296], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 324, "focalAPIEnd": 337, "followUpCheck": "!Arrays.equals(result,receivedHash)", "checkType": "IF", "followUpCheckExpressionStart": 443, "followUpCheckExpressionEnd": 490, "followUpCheckBlockStart": 443, "followUpCheckBlockEnd": 576, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/sun/security/provider/certpath/CertId/CheckCertId.java", "rawCode": "  public static void main(String[] args) throws Exception {\n\n    X509CertImpl cert = loadCert(CERT_FILENAME);\n\n    /* Compute the hash in the same way as CertId constructor */\n    MessageDigest hash = MessageDigest.getInstance(\"SHA1\");\n    hash.update(cert.getSubjectX500Principal().getEncoded());\n    byte[] expectedHash = hash.digest();\n\n    CertId certId = new CertId(cert, null);\n    byte[] receivedHash = certId.getIssuerNameHash();\n\n    if (!Arrays.equals(expectedHash, receivedHash)) {\n      throw new Exception(\"Bad hash value for issuer name in CertId object\");\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5819, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [197], "configurationEnd": [262], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 349, "focalAPIEnd": 371, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["set(result)"], "useStart": [341], "useEnd": [372], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/forcedotcom/phoenix/tree/master/phoenix-core/src/main/java/com/salesforce/phoenix/expression/function/MD5Function.java", "rawCode": "  @Override\n  public boolean evaluate(Tuple tuple, ImmutableBytesWritable ptr) {\n    if (!getChildExpression().evaluate(tuple, ptr)) {\n      return false;\n    }\n\n    // Update the digest value\n    messageDigest.update(ptr.get(), ptr.getOffset(), ptr.getLength());\n    // Get the digest bytes (note this resets the messageDigest as well)\n    ptr.set(messageDigest.digest());\n    return true;\n  }\n"}, {"dataset": "digest", "exampleID": 5820, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [2413], "initializationEnd": [2446], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [2732], "configurationEnd": [2762], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 2812, "focalAPIEnd": 2825, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toHexString(result)"], "useStart": [2800], "useEnd": [2826], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ist-dsi/fears/tree/master/docs/install_test_files/InstallCert.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    String host;\n    int port;\n    char[] passphrase;\n    if ((args.length == 1) || (args.length == 2)) {\n      String[] c = args[0].split(\":\");\n      host = c[0];\n      port = (c.length <= 7) ? 8443 : Integer.parseInt(c[1]);\n      String p = (args.length == 1) ? \"changeit\" : args[1];\n      passphrase = p.toCharArray();\n    } else {\n      System.out.println(\"Usage: java InstallCert <host>[:port] [passphrase]\");\n      return;\n    }\n\n    File file = new File(\"jssecacerts\");\n    if (file.isFile() == false) {\n      char SEP = File.separatorChar;\n      File dir = new File(System.getProperty(\"java.home\") + SEP + \"lib\" + SEP + \"security\");\n      file = new File(dir, \"jssecacerts\");\n      if (file.isFile() == false) {\n        file = new File(dir, \"cacerts\");\n      }\n    }\n    System.out.println(\"Loading KeyStore \" + file + \"...\");\n    InputStream in = new FileInputStream(file);\n    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n    ks.load(in, passphrase);\n    in.close();\n\n    SSLContext context = SSLContext.getInstance(\"TLS\");\n    TrustManagerFactory tmf =\n        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    tmf.init(ks);\n    X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0];\n    SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);\n    context.init(null, new TrustManager[] {tm}, null);\n    SSLSocketFactory factory = context.getSocketFactory();\n\n    System.out.println(\"Opening connection to \" + host + \":\" + port + \"...\");\n    SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n    socket.setSoTimeout(10000);\n    try {\n      System.out.println(\"Starting SSL handshake...\");\n      socket.startHandshake();\n      socket.close();\n      System.out.println();\n      System.out.println(\"No errors, certificate is already trusted\");\n    } catch (SSLException e) {\n      System.out.println();\n      e.printStackTrace(System.out);\n    }\n\n    X509Certificate[] chain = tm.chain;\n    if (chain == null) {\n      System.out.println(\"Could not obtain server certificate chain\");\n      return;\n    }\n\n    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n    System.out.println();\n    System.out.println(\"Server sent \" + chain.length + \" certificate(s):\");\n    System.out.println();\n    MessageDigest sha1 = MessageDigest.getInstance(\"SHA1\");\n    MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n    for (int i = 0; i < chain.length; i++) {\n      X509Certificate cert = chain[i];\n      System.out.println(\" \" + (i + 1) + \" Subject \" + cert.getSubjectDN());\n      System.out.println(\" Issuer \" + cert.getIssuerDN());\n      sha1.update(cert.getEncoded());\n      System.out.println(\" sha1 \" + toHexString(sha1.digest()));\n      md5.update(cert.getEncoded());\n      System.out.println(\" md5 \" + toHexString(md5.digest()));\n      System.out.println();\n    }\n\n    System.out.println(\"Enter certificate to add to trusted keystore or 'q' to quit: [1]\");\n    String line = reader.readLine().trim();\n    int k;\n    try {\n      k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;\n    } catch (NumberFormatException e) {\n      System.out.println(\"KeyStore not changed\");\n      return;\n    }\n\n    X509Certificate cert = chain[k];\n    String alias = host + \"-\" + (k + 1);\n    ks.setCertificateEntry(alias, cert);\n\n    OutputStream out = new FileOutputStream(\"jssecacerts\");\n    ks.store(out, passphrase);\n    out.close();\n\n    System.out.println();\n    System.out.println(cert);\n    System.out.println();\n    System.out.println(\"Added certificate to keystore 'jssecacerts' using alias '\" + alias + \"'\");\n  }\n"}, {"dataset": "digest", "exampleID": 5821, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 84, "focalAPIEnd": 95, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iLuxo/jgit-clone/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackOutputStream.java", "rawCode": "  /** @return obtain the current SHA-1 digest. */\n  byte[] getDigest() {\n    return md.digest();\n  }\n"}, {"dataset": "digest", "exampleID": 5822, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [410], "initializationEnd": [442], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["new ForumException(String)"], "tryExpressionStart": 379, "tryExpressionEnd": 383, "tryBlockStart": 379, "tryBlockEnd": 857, "catchExpressionStart": 775, "catchExpressionEnd": 810, "catchBlockStart": 775, "catchBlockEnd": 857, "exceptionHandlingCallStart": [824], "exceptionHandlingCallEnd": [850], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [450], "configurationEnd": [475], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 497, "focalAPIEnd": 508, "followUpCheck": "i < result.length", "checkType": "LOOP", "followUpCheckExpressionStart": 517, "followUpCheckExpressionEnd": 554, "followUpCheckBlockStart": 517, "followUpCheckBlockEnd": 768, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mrdon/jforum-cvs/tree/master/src/net/jforum/util/MD5.java", "rawCode": "  /**\n   * Encodes a string\n   *\n   * @param str String to encode\n   * @return Encoded String\n   * @throws NoSuchAlgorithmException\n   */\n  public static String crypt(String str) {\n    if (str == null || str.length() == 0) {\n      throw new IllegalArgumentException(\"String to encript cannot be null or zero length\");\n    }\n\n    StringBuffer hexString = new StringBuffer();\n\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n      md.update(str.getBytes());\n      byte[] hash = md.digest();\n\n      for (int i = 0; i < hash.length; i++) {\n        if ((0xff & hash[i]) < 0x10) {\n          hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n        } else {\n          hexString.append(Integer.toHexString(0xFF & hash[i]));\n        }\n      }\n    } catch (NoSuchAlgorithmException e) {\n      throw new ForumException(\"\" + e);\n    }\n\n    return hexString.toString();\n  }\n"}, {"dataset": "digest", "exampleID": 5823, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [103], "initializationEnd": [135], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [176], "configurationEnd": [206], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 245, "focalAPIEnd": 255, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(int,result)"], "useStart": [227], "useEnd": [256], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/majorProject/IAnnotate/tree/master/src/iannotate/database/MessageEncryption.java", "rawCode": "  public static String encryptMD5(String pass) throws NoSuchAlgorithmException {\n    MessageDigest m = MessageDigest.getInstance(\"MD5\");\n    byte[] data = pass.getBytes();\n    m.update(data, 0, data.length);\n    BigInteger i = new BigInteger(1, m.digest());\n    return String.format(\"%1$032X\", i);\n  }\n"}, {"dataset": "digest", "exampleID": 5824, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [98], "initializationEnd": [144], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 53, "tryExpressionEnd": 57, "tryBlockStart": 53, "tryBlockEnd": 262, "catchExpressionStart": 206, "catchExpressionEnd": 227, "catchBlockStart": 206, "catchBlockEnd": 262, "exceptionHandlingCallStart": [235], "exceptionHandlingCallEnd": [255], "configuration": ["messageDigest.security.MessageDigest.update(byte[])"], "configurationStart": [153], "configurationEnd": [165], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 186, "focalAPIEnd": 197, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toHex(result)"], "useStart": [180], "useEnd": [198], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fnppl/openSDX/tree/master/src/org/fnppl/opensdx/keyserverfe/Helper.java", "rawCode": "  public static String getMD5ForData(byte[] b) {\n    try {\n      java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n\n      md.update(b);\n      return toHex(md.digest());\n    } catch (Exception ex) {\n      ex.printStackTrace();\n    }\n\n    return \"\";\n  }\n"}, {"dataset": "digest", "exampleID": 5825, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [150], "initializationEnd": [182], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["error(String,*)"], "tryExpressionStart": 57, "tryExpressionEnd": 61, "tryBlockStart": 57, "tryBlockEnd": 541, "catchExpressionStart": 292, "catchExpressionEnd": 327, "catchBlockStart": 292, "catchBlockEnd": 435, "exceptionHandlingCallStart": [335], "exceptionHandlingCallEnd": [400], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [191], "configurationEnd": [235], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 272, "focalAPIEnd": 283, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferToHex(result)"], "useStart": [250], "useEnd": [284], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dbroeglin/cipango/tree/master/extras/kaleo/src/main/java/org/cipango/kaleo/xcap/XcapService.java", "rawCode": "  public String getEtag(XcapResourceImpl resource) {\n    try {\n      if (resource.getDocument() == null) return \"notExist\";\n\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n      md.update(resource.getDocument().getBytes());\n      return HexString.bufferToHex(md.digest());\n    } catch (NoSuchAlgorithmException e) {\n      _log.error(\"Unable to initialize Message Digest (for etags).\", e);\n      return \"defaultEtag\";\n    } catch (Throwable e) {\n      _log.error(\"Unable to to create etags\", e);\n      return \"defaultEtag\";\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5826, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 122, "focalAPIEnd": 138, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(int,result)"], "useStart": [104], "useEnd": [139], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Blackrush/Shivas/tree/master/shivas-common/src/main/java/org/shivas/common/crypto/Sha1Cipher.java", "rawCode": "  public String cipherString(byte[] bytes) throws CipherException {\n    return String.format(\"%1$040x\", new BigInteger(1, md.digest(bytes)));\n  }\n"}, {"dataset": "digest", "exampleID": 5827, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [145], "initializationEnd": [179], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["idManager()", "createUuid()"], "tryExpressionStart": 127, "tryExpressionEnd": 131, "tryBlockStart": 127, "tryBlockEnd": 671, "catchExpressionStart": 436, "catchExpressionEnd": 471, "catchBlockStart": 436, "catchBlockEnd": 580, "exceptionHandlingCallStart": [549, 549], "exceptionHandlingCallEnd": [560, 573], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [188, 207, 264, 295, 360], "configurationEnd": [199, 256, 287, 352, 376], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 415, "focalAPIEnd": 427, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteArrayToHexStr(result)"], "useStart": [397], "useEnd": [428], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.5/kernel-impl/src/main/java/org/sakaiproject/tool/impl/SessionComponent.java", "rawCode": "  public String makeSessionId(HttpServletRequest req, Principal principal) {\n    MessageDigest sha;\n    String sessionId;\n\n    try {\n      sha = MessageDigest.getInstance(\"SHA-1\");\n\n      sha.reset();\n      sha.update(principal.getName().getBytes(\"UTF-8\"));\n      sha.update((byte) 0x0a);\n      sha.update(req.getHeader(\"user-agent\").getBytes(\"UTF-8\"));\n      sha.update(salt);\n\n      sessionId = byteArrayToHexStr(sha.digest());\n    } catch (NoSuchAlgorithmException e) {\n      // Fallback to new uuid rather than a non-hashed id\n      sessionId = idManager().createUuid();\n    } catch (UnsupportedEncodingException e) {\n      sessionId = idManager().createUuid();\n    }\n\n    return sessionId;\n  }\n"}, {"dataset": "digest", "exampleID": 5828, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [104], "initializationEnd": [137], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["Log.warn(String)"], "tryExpressionStart": 73, "tryExpressionEnd": 77, "tryBlockStart": 73, "tryBlockEnd": 578, "catchExpressionStart": 463, "catchExpressionEnd": 483, "catchBlockStart": 463, "catchBlockEnd": 578, "exceptionHandlingCallStart": [491], "exceptionHandlingCallEnd": [547], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [145], "configurationEnd": [157], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 182, "focalAPIEnd": 193, "followUpCheck": "i < result.length", "checkType": "LOOP", "followUpCheckExpressionStart": 295, "followUpCheckExpressionEnd": 335, "followUpCheckBlockStart": 295, "followUpCheckBlockEnd": 428, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tu-vu-duy/exo-ks/tree/master/eXoApplication/common/src/main/java/org/exoplatform/ks/common/CommonUtils.java", "rawCode": "  public static String generateCheckSum(byte[] b) throws Exception {\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n      md.update(b);\n      byte[] mdbytes = md.digest();\n\n      // convert the byte to hex format\n      StringBuffer sb = new StringBuffer(EMPTY_STR);\n      for (int i = 0; i < mdbytes.length; i++) {\n        sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));\n      }\n      return sb.toString();\n    } catch (Exception e) {\n      log.warn(\"Can not generate checksum for exporting data\");\n      return EMPTY_STR;\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5829, "initialization": ["MessageDigest messageDigest = newMessageDigest()"], "initializationStart": [223], "initializationEnd": [251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [257, 316, 343, 400, 425], "configurationEnd": [310, 337, 394, 419, 462], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 509, "focalAPIEnd": 520, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fromRaw(result)"], "useStart": [492], "useEnd": [521], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pdinc-oss/jgit/tree/master/org.eclipse.jgit.test/tst/org/eclipse/jgit/treewalk/FileTreeIteratorTest.java", "rawCode": "  @Test\n  public void testComputeFileObjectId() throws Exception {\n    final FileTreeIterator top =\n        new FileTreeIterator(trash, db.getFS(), db.getConfig().get(WorkingTreeOptions.KEY));\n\n    final MessageDigest md = Constants.newMessageDigest();\n    md.update(Constants.encodeASCII(Constants.TYPE_BLOB));\n    md.update((byte) ' ');\n    md.update(Constants.encodeASCII(paths[0].length()));\n    md.update((byte) 0);\n    md.update(Constants.encode(paths[0]));\n    final ObjectId expect = ObjectId.fromRaw(md.digest());\n\n    assertEquals(expect, top.getEntryObjectId());\n\n    // Verify it was cached by removing the file and getting it again.\n    //\n    FileUtils.delete(new File(trash, paths[0]));\n    assertEquals(expect, top.getEntryObjectId());\n  }\n"}, {"dataset": "digest", "exampleID": 5830, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [277], "configurationEnd": [322], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 354, "focalAPIEnd": 367, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["HexStringFromBytes(result)"], "useStart": [335], "useEnd": [368], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MiniSEC/adito_reload/tree/master/Alfresco-JLAN/core/source/java/org/alfresco/util/MD5.java", "rawCode": "  /**\n   * Thread-safe static digest (hashing) function.\n   *\n   * <p>If you want to avoid lock contention, create an instance of MD5 per-thead, anc call the\n   * unsynchronized method 'digest' instead.\n   */\n  public static synchronized String Digest(byte[] dataToHash) {\n    Md5_.update(dataToHash, 0, dataToHash.length);\n    return HexStringFromBytes(Md5_.digest());\n  }\n"}, {"dataset": "digest", "exampleID": 5831, "initialization": ["MessageDigest messageDigest = newSha1Digest()"], "initializationStart": [60], "initializationEnd": [75], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [93], "configurationEnd": [126], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 256, "focalAPIEnd": 267, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toHex(result)"], "useStart": [250], "useEnd": [268], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/torquebox/jruby-maven-plugins/tree/master/bundler-maven-plugin/src/main/java/de/saumya/mojo/bundler/InstallMojo.java", "rawCode": "  private String sha1(String text) {\n    MessageDigest md = newSha1Digest();\n    try {\n      md.update(text.getBytes(\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"should not happen\", e);\n    }\n    return toHex(md.digest());\n  }\n"}, {"dataset": "digest", "exampleID": 5832, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [341], "initializationEnd": [373], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 232, "tryExpressionEnd": 236, "tryBlockStart": 232, "tryBlockEnd": 852, "catchExpressionStart": 779, "catchExpressionEnd": 799, "catchBlockStart": 779, "catchBlockEnd": 852, "exceptionHandlingCallStart": [807], "exceptionHandlingCallEnd": [826], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [402], "configurationEnd": [424], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 458, "focalAPIEnd": 473, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/liudongpu/zapsrnpr/tree/master/zapcom/src/main/java/com/srnpr/zapcom/basehelper/SecrurityHelper.java", "rawCode": "  /**\n   * MD5加密自定义\n   *\n   * @param s\n   * @return\n   */\n  public static final String MD5Customer(String s) {\n    char hexDigits[] = {\n      'S', 'R', 'N', 'P', 'A', 'L', 'I', 'U', 'D', 'O', 'B', 'G', 'C', 'D', '3', '1'\n    };\n    try {\n      byte[] btInput = s.getBytes();\n      // 获得MD5摘要算法的 MessageDigest 对象\n      MessageDigest mdInst = MessageDigest.getInstance(\"MD5\");\n      // 使用指定的字节更新摘要\n      mdInst.update(btInput);\n      // 获得密文\n      byte[] md = mdInst.digest();\n      // 把密文转换成十六进制的字符串形式\n      int j = md.length;\n      char str[] = new char[j * 2];\n      int k = 0;\n      for (int i = 0; i < j; i++) {\n        byte byte0 = md[i];\n        str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n        str[k++] = hexDigits[byte0 & 0xf];\n      }\n      return new String(str);\n    } catch (Exception e) {\n      e.printStackTrace();\n      return null;\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5833, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [117], "initializationEnd": [149], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [193], "configurationEnd": [244], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 263, "focalAPIEnd": 274, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jrecursive/mecha/tree/master/src/java/mecha/util/ConsistentHash.java", "rawCode": "  private BigInteger hashFun(Object key) throws Exception {\n    String text = key.toString();\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] hash_bytes = new byte[40];\n    md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n    hash_bytes = md.digest();\n    BigInteger h = new BigInteger(1, hash_bytes);\n    return h;\n  }\n"}, {"dataset": "digest", "exampleID": 5834, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [79], "initializationEnd": [115], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 49, "tryExpressionEnd": 53, "tryBlockStart": 49, "tryBlockEnd": 231, "catchExpressionStart": 152, "catchExpressionEnd": 187, "catchBlockStart": 152, "catchBlockEnd": 231, "exceptionHandlingCallStart": [201], "exceptionHandlingCallEnd": [224], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 130, "focalAPIEnd": 144, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bitsofproof/supernode/tree/master/api/src/main/java/com/bitsofproof/supernode/common/Hash.java", "rawCode": "  public static byte[] sha256(byte[] data) {\n    try {\n      MessageDigest a = MessageDigest.getInstance(\"SHA-256\");\n      return a.digest(data);\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5835, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [179], "initializationEnd": [211], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["getMessage()", "new SecurityException(*)"], "tryExpressionStart": 148, "tryExpressionEnd": 152, "tryBlockStart": 148, "tryBlockEnd": 4358, "catchExpressionStart": 4251, "catchExpressionEnd": 4293, "catchBlockStart": 4251, "catchBlockEnd": 4358, "exceptionHandlingCallStart": [4329, 4307], "exceptionHandlingCallEnd": [4350, 4351], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 4003, "focalAPIEnd": 4014, "followUpCheck": "i < Math.min(8,result.length)", "checkType": "LOOP", "followUpCheckExpressionStart": 4022, "followUpCheckExpressionEnd": 4077, "followUpCheckBlockStart": 4022, "followUpCheckBlockEnd": 4140, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fanhongtao/JDK/tree/master/src/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3.java", "rawCode": "  private static long _computeSerialVersionUID(Class cl) {\n    ByteArrayOutputStream devnull = new ByteArrayOutputStream(512);\n\n    long h = 0;\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"SHA\");\n      DigestOutputStream mdo = new DigestOutputStream(devnull, md);\n      DataOutputStream data = new DataOutputStream(mdo);\n\n      data.writeUTF(cl.getName());\n\n      int classaccess = cl.getModifiers();\n      classaccess &= (Modifier.PUBLIC | Modifier.FINAL | Modifier.INTERFACE | Modifier.ABSTRACT);\n\n      /* Workaround for javac bug that only set ABSTRACT for\n       * interfaces if the interface had some methods.\n       * The ABSTRACT bit reflects that the number of methods > 0.\n       * This is required so correct hashes can be computed\n       * for existing class files.\n       * Previously this hack was previously present in the VM.\n       */\n      Method[] method = cl.getDeclaredMethods();\n      if ((classaccess & Modifier.INTERFACE) != 0) {\n        classaccess &= (~Modifier.ABSTRACT);\n        if (method.length > 0) {\n          classaccess |= Modifier.ABSTRACT;\n        }\n      }\n\n      data.writeInt(classaccess);\n\n      /*\n       * Get the list of interfaces supported,\n       * Accumulate their names their names in Lexical order\n       * and add them to the hash\n       */\n      if (!cl.isArray()) {\n        /* In 1.2fcs, getInterfaces() was modified to return\n         * {java.lang.Cloneable, java.io.Serializable} when\n         * called on array classes. These values would upset\n         * the computation of the hash, so we explicitly omit\n         * them from its computation.\n         */\n\n        Class interfaces[] = cl.getInterfaces();\n        Arrays.sort(interfaces, compareClassByName);\n\n        for (int i = 0; i < interfaces.length; i++) {\n          data.writeUTF(interfaces[i].getName());\n        }\n      }\n\n      /* Sort the field names to get a deterministic order */\n      Field[] field = cl.getDeclaredFields();\n      Arrays.sort(field, compareMemberByName);\n\n      for (int i = 0; i < field.length; i++) {\n        Field f = field[i];\n\n        /* Include in the hash all fields except those that are\n         * private transient and private static.\n         */\n        int m = f.getModifiers();\n        if (Modifier.isPrivate(m) && (Modifier.isTransient(m) || Modifier.isStatic(m))) continue;\n\n        data.writeUTF(f.getName());\n        data.writeInt(m);\n        data.writeUTF(getSignature(f.getType()));\n      }\n\n      // need to find the java replacement for hasStaticInitializer\n      if (hasStaticInitializer(cl)) {\n        data.writeUTF(\"<clinit>\");\n        data.writeInt(Modifier.STATIC); // TBD: what modifiers does it have\n        data.writeUTF(\"()V\");\n      }\n\n      /*\n       * Get the list of constructors including name and signature\n       * Sort lexically, add all except the private constructors\n       * to the hash with their access flags\n       */\n\n      MethodSignature[] constructors =\n          MethodSignature.removePrivateAndSort(cl.getDeclaredConstructors());\n      for (int i = 0; i < constructors.length; i++) {\n        MethodSignature c = constructors[i];\n        String mname = \"<init>\";\n        String desc = c.signature;\n        desc = desc.replace('/', '.');\n        data.writeUTF(mname);\n        data.writeInt(c.member.getModifiers());\n        data.writeUTF(desc);\n      }\n\n      /* Include in the hash all methods except those that are\n       * private transient and private static.\n       */\n      MethodSignature[] methods = MethodSignature.removePrivateAndSort(method);\n      for (int i = 0; i < methods.length; i++) {\n        MethodSignature m = methods[i];\n        String desc = m.signature;\n        desc = desc.replace('/', '.');\n        data.writeUTF(m.member.getName());\n        data.writeInt(m.member.getModifiers());\n        data.writeUTF(desc);\n      }\n\n      /* Compute the hash value for this class.\n       * Use only the first 64 bits of the hash.\n       */\n      data.flush();\n      byte hasharray[] = md.digest();\n      for (int i = 0; i < Math.min(8, hasharray.length); i++) {\n        h += (long) (hasharray[i] & 255) << (i * 8);\n      }\n    } catch (IOException ignore) {\n      /* can't happen, but be deterministic anyway. */\n      h = -1;\n    } catch (NoSuchAlgorithmException complain) {\n      throw new SecurityException(complain.getMessage());\n    }\n    return h;\n  }\n"}, {"dataset": "digest", "exampleID": 5836, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [233], "initializationEnd": [265], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [381], "configurationEnd": [406], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 498, "focalAPIEnd": 509, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(int,result)"], "useStart": [480], "useEnd": [510], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bryanjimenez/empanada/tree/master/hadoop/hadoop-1.2.1/src/test/org/apache/hadoop/hdfs/server/namenode/TestStorageRestore.java", "rawCode": "  /**\n   * This function returns a md5 hash of a file.\n   *\n   * @param file input file\n   * @return The md5 string\n   */\n  public String getFileMD5(File file) throws Exception {\n    String res = new String();\n    MessageDigest mD = MessageDigest.getInstance(\"MD5\");\n    DataInputStream dis = new DataInputStream(new FileInputStream(file));\n\n    try {\n      while (true) {\n        mD.update(dis.readByte());\n      }\n    } catch (EOFException eof) {\n    }\n\n    BigInteger bigInt = new BigInteger(1, mD.digest());\n    res = bigInt.toString(16);\n    dis.close();\n\n    return res;\n  }\n"}, {"dataset": "digest", "exampleID": 5837, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(char)", "messageDigest.update(byte[],int,int)", "messageDigest.update(byte[])", "messageDigest.update(byte[],int,int)"], "configurationStart": [207, 234, 267, 349, 582, 646, 775], "configurationEnd": [228, 261, 299, 381, 634, 676, 820], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 891, "focalAPIEnd": 913, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdcasey/JGit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/treewalk/WorkingTreeIterator.java", "rawCode": "  private byte[] computeHash(InputStream in, long length) throws IOException {\n    final MessageDigest contentDigest = state.contentDigest;\n    final byte[] contentReadBuffer = state.contentReadBuffer;\n\n    contentDigest.reset();\n    contentDigest.update(hblob);\n    contentDigest.update((byte) ' ');\n\n    long sz = length;\n    if (sz == 0) {\n      contentDigest.update((byte) '0');\n    } else {\n      final int bufn = contentReadBuffer.length;\n      int p = bufn;\n      do {\n        contentReadBuffer[--p] = digits[(int) (sz % 10)];\n        sz /= 10;\n      } while (sz > 0);\n      contentDigest.update(contentReadBuffer, p, bufn - p);\n    }\n    contentDigest.update((byte) 0);\n\n    for (; ; ) {\n      final int r = in.read(contentReadBuffer);\n      if (r <= 0) break;\n      contentDigest.update(contentReadBuffer, 0, r);\n      sz += r;\n    }\n    if (sz != length) return zeroid;\n    return contentDigest.digest();\n  }\n"}, {"dataset": "digest", "exampleID": 5838, "initialization": ["MessageDigest messageDigest = newMessageDigest()"], "initializationStart": [307], "initializationEnd": [335], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 648, "focalAPIEnd": 664, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fromRaw(result)"], "useStart": [631], "useEnd": [665], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdcasey/JGit/tree/master/org.eclipse.jgit.storage.dht/src/org/eclipse/jgit/storage/dht/DhtPackParser.java", "rawCode": "  private void putCachedPack() throws DhtException {\n    CachedPackInfo.Builder info = CachedPackInfo.newBuilder();\n\n    for (DhtInfo obj : objectMap) {\n      if (!obj.isInPack()) return;\n\n      if (!obj.isReferenced()) info.getTipListBuilder().addObjectName(obj.name());\n    }\n\n    MessageDigest version = Constants.newMessageDigest();\n    addChunkList(info, version, chunkByOrder[OBJ_TAG]);\n    addChunkList(info, version, chunkByOrder[OBJ_COMMIT]);\n    addChunkList(info, version, chunkByOrder[OBJ_TREE]);\n    addChunkList(info, version, chunkByOrder[OBJ_BLOB]);\n\n    info.setName(computePackName().name());\n    info.setVersion(ObjectId.fromRaw(version.digest()).name());\n\n    cachedPackKey = CachedPackKey.fromInfo(info.build());\n    for (List<ChunkKey> list : chunkByOrder) {\n      if (list == null) continue;\n      for (ChunkKey key : list) {\n        ChunkInfo oldInfo = infoByKey.get(key);\n        GitStore.ChunkInfo.Builder b = GitStore.ChunkInfo.newBuilder(oldInfo.getData());\n        b.setCachedPackKey(cachedPackKey.asString());\n        ChunkInfo newInfo = new ChunkInfo(key, b.build());\n        infoByKey.put(key, newInfo);\n\n        // A fragment was already put, and has to be re-put.\n        // Non-fragments will put later and do not put now.\n        if (newInfo.getData().getIsFragment()) db.repository().put(repo, newInfo, dbWriteBuffer);\n      }\n    }\n\n    db.repository().put(repo, info.build(), dbWriteBuffer);\n  }\n"}, {"dataset": "digest", "exampleID": 5839, "initialization": ["MessageDigest messageDigest = getInstance(String,String)"], "initializationStart": [187], "initializationEnd": [243], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 421, "focalAPIEnd": 437, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/willuhn/hbci4java/tree/master/src/org/kapott/hbci/passport/HBCIPassportDDV.java", "rawCode": "  public byte[] hash(byte[] data) {\n    /* hash-before-sign creates a RMD-160 hash, which will encrypted by\n     * the sign() method later */\n    MessageDigest dig;\n    try {\n      dig = MessageDigest.getInstance(\"RIPEMD160\", \"CryptAlgs4Java\");\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e);\n    } catch (NoSuchProviderException e) {\n      throw new RuntimeException(e);\n    }\n    return dig.digest(data);\n  }\n"}, {"dataset": "digest", "exampleID": 5840, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [147], "initializationEnd": [179], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 116, "tryExpressionEnd": 120, "tryBlockStart": 116, "tryBlockEnd": 1555, "catchExpressionStart": 1482, "catchExpressionEnd": 1502, "catchBlockStart": 1482, "catchBlockEnd": 1555, "exceptionHandlingCallStart": [1510], "exceptionHandlingCallEnd": [1529], "configuration": ["messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])"], "configurationStart": [212, 293, 322, 411, 440], "configurationEnd": [285, 314, 403, 432, 515], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 536, "focalAPIEnd": 547, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])", "messageDigest.digest()", "toString(result,int)", "messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])"], "useStart": [579, 597, 670, 699, 782, 812, 802, 881, 910, 999, 1028, 1083, 1112, 1171, 1200, 1287, 1316], "useEnd": [589, 662, 691, 761, 793, 838, 873, 902, 991, 1020, 1075, 1104, 1163, 1192, 1279, 1308, 1387], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/toddlipcon/jetty-hadoop-fix/tree/master/extras/client/src/main/java/org/mortbay/jetty/client/security/DigestAuthorization.java", "rawCode": "  protected String newResponse(\n      String cnonce, HttpExchange exchange, Realm securityRealm, Map details) {\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n      // calc A1 digest\n      md.update(securityRealm.getPrincipal().getBytes(StringUtil.__ISO_8859_1));\n      md.update((byte) ':');\n      md.update(String.valueOf(details.get(\"realm\")).getBytes(StringUtil.__ISO_8859_1));\n      md.update((byte) ':');\n      md.update(securityRealm.getCredentials().getBytes(StringUtil.__ISO_8859_1));\n      byte[] ha1 = md.digest();\n      // calc A2 digest\n      md.reset();\n      md.update(exchange.getMethod().getBytes(StringUtil.__ISO_8859_1));\n      md.update((byte) ':');\n      md.update(exchange.getURI().getBytes(StringUtil.__ISO_8859_1));\n      byte[] ha2 = md.digest();\n\n      md.update(TypeUtil.toString(ha1, 16).getBytes(StringUtil.__ISO_8859_1));\n      md.update((byte) ':');\n      md.update(String.valueOf(details.get(\"nonce\")).getBytes(StringUtil.__ISO_8859_1));\n      md.update((byte) ':');\n      md.update(NC.getBytes(StringUtil.__ISO_8859_1));\n      md.update((byte) ':');\n      md.update(cnonce.getBytes(StringUtil.__ISO_8859_1));\n      md.update((byte) ':');\n      md.update(String.valueOf(details.get(\"qop\")).getBytes(StringUtil.__ISO_8859_1));\n      md.update((byte) ':');\n      md.update(TypeUtil.toString(ha2, 16).getBytes(StringUtil.__ISO_8859_1));\n      byte[] digest = md.digest();\n\n      // check digest\n      return encode(digest);\n    } catch (Exception e) {\n      e.printStackTrace();\n      return null;\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5841, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [453], "initializationEnd": [489], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [495], "configurationEnd": [551], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 568, "focalAPIEnd": 579, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["convertToHex(result)"], "useStart": [593], "useEnd": [615], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/moai/moai-beta/tree/master/ant/host-source/source/project/external/tapjoy/project/src/com/tapjoy/TapjoyUtil.java", "rawCode": "  /**\n   * Converts a String into a SHA-256 hash.\n   *\n   * @param text Text to convert.\n   * @return SHA1 hash.\n   * @throws NoSuchAlgorithmException\n   * @throws UnsupportedEncodingException\n   */\n  public static String SHA256(String text)\n      throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    TapjoyLog.i(TAPJOY_UTIL, \"SHA256: \" + text);\n\n    MessageDigest md;\n    byte[] sha1hash = new byte[40];\n\n    // MD5, SHA-1, etc\n    md = MessageDigest.getInstance(\"SHA-256\");\n    md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n    sha1hash = md.digest();\n\n    return convertToHex(sha1hash);\n  }\n"}, {"dataset": "digest", "exampleID": 5842, "initialization": ["MessageDigest messageDigest = newMessageDigest()"], "initializationStart": [92], "initializationEnd": [120], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [126], "configurationEnd": [154], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 170, "focalAPIEnd": 181, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["write(result)"], "useStart": [160], "useEnd": [182], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iLuxo/jgit-clone/tree/master/org.eclipse.jgit.test/tst/org/eclipse/jgit/storage/file/PackFileTest.java", "rawCode": "  private void digest(TemporaryBuffer.Heap buf) throws IOException {\n    MessageDigest md = Constants.newMessageDigest();\n    md.update(buf.toByteArray());\n    buf.write(md.digest());\n  }\n"}, {"dataset": "digest", "exampleID": 5843, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [331], "configurationEnd": [352], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 368, "focalAPIEnd": 384, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pdudits/supergenpass-android/tree/master/src/info/staticfree/SuperGenPass/VisualHash.java", "rawCode": "  /**\n   * Sets the data and digests it into the visual hash.\n   *\n   * @param input the data to be hashed. This value is discarded immediately after computing the\n   *     hash.\n   */\n  public void setData(byte[] input) {\n    if (mHasher == null || (!mShowBlankData && input.length == 0)) {\n      mHash = null;\n    } else {\n      mHasher.update(input);\n      mHash = mHasher.digest();\n    }\n\n    invalidateSelf();\n  }\n"}, {"dataset": "digest", "exampleID": 5844, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [195], "initializationEnd": [227], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 440, "focalAPIEnd": 451, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["encode(result)"], "useStart": [399], "useEnd": [452], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/europeana/Europeana-Cloud/tree/master/service/mcs/rest/src/test/java/eu/europeana/cloud/service/mcs/rest/HugeFileResourceUploadIT.java", "rawCode": "    @Override\n    public Object answer(InvocationOnMock invocation) throws Throwable {\n      Object[] args = invocation.getArguments();\n      File file = (File) args[3];\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n      DigestInputStream inputStream = new DigestInputStream((InputStream) args[4], md);\n      consume(inputStream);\n      file.setFileName(\"terefere\");\n      file.setMd5(BaseEncoding.base16().lowerCase().encode(md.digest()));\n      return null;\n    }\n"}, {"dataset": "digest", "exampleID": 5845, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [109], "initializationEnd": [141], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 79, "tryExpressionEnd": 83, "tryBlockStart": 79, "tryBlockEnd": 308, "catchExpressionStart": 254, "catchExpressionEnd": 274, "catchBlockStart": 254, "catchBlockEnd": 308, "exceptionHandlingCallStart": [282], "exceptionHandlingCallEnd": [301], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [149], "configurationEnd": [189], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 222, "focalAPIEnd": 232, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(int,result)"], "useStart": [204], "useEnd": [233], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Kukambara/worldofzaar/tree/master/src/main/java/com/worldofzaar/util/HashConverter.java", "rawCode": "  public static String md5File(byte[] fileBytes) {\n    String hash = null;\n    try {\n      MessageDigest m = MessageDigest.getInstance(\"MD5\");\n      m.update(fileBytes, 0, fileBytes.length);\n      hash = new BigInteger(1, m.digest()).toString(16);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    return hash;\n  }\n"}, {"dataset": "digest", "exampleID": 5846, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [388], "initializationEnd": [420], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [594], "configurationEnd": [626], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 713, "focalAPIEnd": 723, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(int,result)"], "useStart": [695], "useEnd": [724], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MoSync/Eclipse/tree/master/com.mobilesorcery.sdk.builder.moblin/src/com/mobilesorcery/sdk/builder/linux/deb/BuilderUtil.java", "rawCode": "  /**\n   * Calculates the md5 has for a file and returns the hash as a hex string\n   *\n   * @param f File to hash\n   * @return 128 bit hash in hex\n   * @throws NoSuchAlgorithmException\n   * @throws FileNotFoundException\n   * @throws IOException\n   */\n  public String calcFileMD5Sum(File f)\n      throws NoSuchAlgorithmException, FileNotFoundException, IOException {\n    MessageDigest m = MessageDigest.getInstance(\"MD5\");\n    FileInputStream fos = new FileInputStream(f);\n\n    // Hash file\n    int size = (int) f.length();\n    while (size > 0) {\n      int count = fos.read(m_copyBuffer);\n      m.update(m_copyBuffer, 0, count);\n      size -= count;\n    }\n    fos.close();\n\n    BigInteger hash = new BigInteger(1, m.digest());\n    return hash.toString(16);\n  }\n"}, {"dataset": "digest", "exampleID": 5847, "initialization": ["MessageDigest messageDigest = HandshakeHash.getSHAClone()"], "initializationStart": [324], "initializationEnd": [351], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 965, "focalAPIEnd": 982, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["MessageDigest.update(result)"], "useStart": [954], "useEnd": [983], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/barchart/barchart-udt/tree/master/barchart-udt-reference-jdk6/src/main/java/sun/security/ssl/HandshakeMessage.java", "rawCode": "    private static void updateSignature(\n        Signature sig,\n        ProtocolVersion protocolVersion,\n        HandshakeHash handshakeHash,\n        String algorithm,\n        SecretKey masterKey)\n        throws SignatureException {\n      MessageDigest md5Clone = handshakeHash.getMD5Clone();\n      MessageDigest shaClone = handshakeHash.getSHAClone();\n      boolean tls = protocolVersion.v >= ProtocolVersion.TLS10.v;\n      if (algorithm.equals(\"RSA\")) {\n        if (tls) {\n          // nothing to do\n        } else { // SSLv3\n          updateDigest(md5Clone, MD5_pad1, MD5_pad2, masterKey);\n          updateDigest(shaClone, SHA_pad1, SHA_pad2, masterKey);\n        }\n        // need to use these hashes directly\n        RSASignature.setHashes(sig, md5Clone, shaClone);\n      } else { // DSA, ECDSA\n        if (tls) {\n          // nothing to do\n        } else { // SSLv3\n          updateDigest(shaClone, SHA_pad1, SHA_pad2, masterKey);\n        }\n        sig.update(shaClone.digest());\n      }\n    }\n"}, {"dataset": "digest", "exampleID": 5848, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [293], "initializationEnd": [326], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 262, "tryExpressionEnd": 266, "tryBlockStart": 262, "tryBlockEnd": 512, "catchExpressionStart": 398, "catchExpressionEnd": 434, "catchBlockStart": 398, "catchBlockEnd": 512, "exceptionHandlingCallStart": [442], "exceptionHandlingCallEnd": [505], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [334], "configurationEnd": [364], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 379, "focalAPIEnd": 390, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/T4g1/3eme/tree/master/Java/Etape 3/Library/src/Utils/Request.java", "rawCode": "  /**\n   * Donne le digest du string donné\n   *\n   * @param password\n   * @return Tableau de byte\n   */\n  public static byte[] getDigest(String password) {\n    // Brouille le mot de passe\n    password += \"CowLAN\";\n\n    // Construit le digest du mot de passe\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n      md.update(password.getBytes());\n      return md.digest();\n    } catch (NoSuchAlgorithmException ex) {\n      System.out.println(\"Algo SHA1 inexistant, digest non transmis\");\n    }\n\n    return null;\n  }\n"}, {"dataset": "digest", "exampleID": 5849, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 523, "focalAPIEnd": 535, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sake/bouncycastle-java/tree/master/test/src/org/bouncycastle/mail/smime/test/SMIMEEnvelopedTest.java", "rawCode": "  public void testSubKeyId() throws Exception {\n    MimeBodyPart _msg = SMIMETestUtil.makeMimeBodyPart(\"WallaWallaWashington\");\n\n    SMIMEEnvelopedGenerator gen = new SMIMEEnvelopedGenerator();\n\n    //\n    // create a subject key id - this has to be done the same way as\n    // it is done in the certificate associated with the private key\n    //\n    MessageDigest dig = MessageDigest.getInstance(\"SHA1\", \"BC\");\n    dig.update(_reciCert.getPublicKey().getEncoded());\n\n    gen.addKeyTransRecipient(_reciCert.getPublicKey(), dig.digest());\n\n    //\n    // generate a MimeBodyPart object which encapsulates the content\n    // we want encrypted.\n    //\n\n    MimeBodyPart mp = gen.generate(_msg, SMIMEEnvelopedGenerator.DES_EDE3_CBC, \"BC\");\n\n    SMIMEEnveloped m = new SMIMEEnveloped(mp);\n\n    dig.update(_reciCert.getPublicKey().getEncoded());\n\n    RecipientId recId = new KeyTransRecipientId(dig.digest());\n\n    RecipientInformationStore recipients = m.getRecipientInfos();\n    RecipientInformation recipient = recipients.get(recId);\n\n    MimeBodyPart res = SMIMEUtil.toMimeBodyPart(recipient.getContent(_reciKP.getPrivate(), \"BC\"));\n\n    verifyMessageBytes(_msg, res);\n  }\n"}, {"dataset": "digest", "exampleID": 5850, "initialization": ["byte[] input = padPassword(String)", "MessageDigest messageDigest = getInstance(String)"], "initializationStart": [1323, 1472], "initializationEnd": [1349, 1504], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 1690, "focalAPIEnd": 1721, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["messageDigest.digest(byte[])", "arraycopy(result,int,byte[],int,int)"], "useStart": [2004, 2715], "useEnd": [2035, 2783], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mosscode/icepdf/tree/master/core/src/org/icepdf/core/pobjects/security/StandardEncryption.java", "rawCode": "  /**\n   * Computing Owner password value, Algorithm 3.3.\n   *\n   * <p>AESv3 passwords are not handle by this method, instead use {@link\n   * #generalEncryptionAlgorithm(org.icepdf.core.pobjects.Reference, byte[], String, byte[])} If the\n   * result is not null then the encryptionDictionary will container values for\n   * isAuthenticatedOwnerPassword and isAuthenticatedUserPassword.\n   *\n   * @param ownerPassword owner pasword string. If there is no owner, password use the user password\n   *     instead.\n   * @param userPassword user password.\n   * @param isAuthentication if true, only steps 1-4 of the algorithm will be completed. If false,\n   *     all 8 steps of the algorithm will be completed <b>Note : </b><br>\n   *     There may be a bug in this algorithm when all 8 steps are called. 1-4 are work properly,\n   *     but 1-8 can not generate an O value that is the same as the orgional documents O. This is\n   *     not a currently a problem as we do not author PDF documents.\n   */\n  public byte[] calculateOwnerPassword(\n      String ownerPassword, String userPassword, boolean isAuthentication) {\n    // Step 1: padd the owner password, use the userPassword if empty.\n    if (\"\".equals(ownerPassword) && !\"\".equals(userPassword)) {\n      ownerPassword = userPassword;\n    }\n    byte[] paddedOwnerPassword = padPassword(ownerPassword);\n\n    // Step 2: Initialize the MD5 hash function and pass in step 2.\n    MessageDigest md5 = null;\n    try {\n      md5 = MessageDigest.getInstance(\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n      logger.log(Level.FINE, \"Could not fint MD5 Digest\", e);\n    }\n    // and pass in padded password from step 1\n    paddedOwnerPassword = md5.digest(paddedOwnerPassword);\n\n    // Step 3: Do the following 50 times: take the output from the previous\n    // MD5 hash and pass it as input into a new MD5 hash;\n    // only for R = 3\n    if (encryptionDictionary.getRevisionNumber() >= 3) {\n      for (int i = 0; i < 50; i++) {\n        paddedOwnerPassword = md5.digest(paddedOwnerPassword);\n      }\n    }\n\n    // Step 4: Create an RC4 encryption key using the first n bytes of the\n    // final MD5 hash, where n is always 5 for revision 2 and the value\n    // of the encryption dictionary's Length entry for revision 3.\n    // Set up an RC4 cipher and try to encrypt:\n\n    // grap the needed n bytes.\n    int dataSize = 5; // default for R == 2\n    if (encryptionDictionary.getRevisionNumber() >= 3) {\n      dataSize = encryptionDictionary.getKeyLength() / 8;\n    }\n    if (dataSize > paddedOwnerPassword.length) {\n      dataSize = paddedOwnerPassword.length;\n    }\n\n    // truncate the byte array RC4 encryption key\n    byte[] encryptionKey = new byte[dataSize];\n\n    System.arraycopy(paddedOwnerPassword, 0, encryptionKey, 0, dataSize);\n\n    // Key is needed by algorithm 3.7, Authenticating owner password\n    if (isAuthentication) {\n      return encryptionKey;\n    }\n\n    // Step 5: Pad or truncate the user password string\n    byte[] paddedUserPassword = padPassword(userPassword);\n\n    // Step 6: Encrypt the result of step 4, using the RC4 encryption\n    // function with the encryption key obtained in step 4\n    byte[] finalData = null;\n    try {\n      // Use above as key for the RC4 encryption function.\n      SecretKeySpec key = new SecretKeySpec(encryptionKey, \"RC4\");\n      Cipher rc4 = Cipher.getInstance(\"RC4\");\n      rc4.init(Cipher.ENCRYPT_MODE, key);\n\n      // finally add the stream or string data\n      finalData = rc4.update(paddedUserPassword);\n\n      // Step 7: Do the following 19 times: Take the output from the previous\n      // invocation of the RC4 function and pass it as input to a new\n      // invocation of the function; use an encryption key generated by taking\n      // each byte of the encryption key in step 4 and performing an XOR\n      // operation between that byte and the single-byte value of the\n      // iteration counter\n      if (encryptionDictionary.getRevisionNumber() >= 3) {\n\n        // key to be made on each interaction\n        byte[] indexedKey = new byte[encryptionKey.length];\n        // start the 19? interactions\n        for (int i = 1; i <= 19; i++) {\n\n          // build new key for each i xor on each byte\n          for (int j = 0; j < encryptionKey.length; j++) {\n            indexedKey[j] = (byte) (encryptionKey[j] ^ i);\n          }\n          // create new key and init rc4\n          key = new SecretKeySpec(indexedKey, \"RC4\");\n          // Cipher tmpRc4 = Cipher.getInstance(\"RC4\");\n          rc4.init(Cipher.ENCRYPT_MODE, key);\n          // encrypt the old data with the new key\n          finalData = rc4.update(finalData);\n        }\n      }\n\n    } catch (NoSuchAlgorithmException ex) {\n      logger.log(Level.FINE, \"NoSuchAlgorithmException.\", ex);\n    } catch (NoSuchPaddingException ex) {\n      logger.log(Level.FINE, \"NoSuchPaddingException.\", ex);\n    } catch (InvalidKeyException ex) {\n      logger.log(Level.FINE, \"InvalidKeyException.\", ex);\n    }\n\n    // Debug Code.\n    // String O = encryptionDictionary.getBigO();\n    // System.out.print(\"Original O \" + O.length() + \" \");\n    // byte[] bigO = new byte[O.length()];\n    // for (int i=0; i < bigO.length; i++){\n    // //bigO[i] = (byte)O.charAt(i);\n    // System.out.print((int)O.charAt(i));\n    // }\n    // System.out.println();\n    //\n    // System.out.print(\"new O \" + finalData.length + \" \");\n    // for (int i=0; i < finalData.length; i++){\n    // System.out.print((int)finalData[i]);\n    // }\n    // System.out.println();\n\n    // Step 8: return the final invocation of the RC4 function as O\n    return finalData;\n  }\n"}, {"dataset": "digest", "exampleID": 5851, "initialization": ["MessageDigest messageDigest = newMessageDigest()"], "initializationStart": [92], "initializationEnd": [120], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [126], "configurationEnd": [154], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 170, "focalAPIEnd": 181, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["write(result)"], "useStart": [160], "useEnd": [182], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iLuxo/jgit-clone/tree/master/org.eclipse.jgit.test/tst/org/eclipse/jgit/transport/PackParserTest.java", "rawCode": "  private void digest(TemporaryBuffer.Heap buf) throws IOException {\n    MessageDigest md = Constants.newMessageDigest();\n    md.update(buf.toByteArray());\n    buf.write(md.digest());\n  }\n"}, {"dataset": "digest", "exampleID": 5852, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [193], "initializationEnd": [225], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [320], "configurationEnd": [355], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 422, "focalAPIEnd": 439, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RomRaider/assembla.flat/tree/master/trunk/src/com/romraider/util/MD5Checksum.java", "rawCode": "  public static byte[] createChecksum(String filename) throws Exception {\n    InputStream fis = new FileInputStream(filename);\n\n    byte[] buffer = new byte[1024];\n    MessageDigest complete = MessageDigest.getInstance(\"MD5\");\n    int numRead;\n    do {\n      numRead = fis.read(buffer);\n      if (numRead > 0) {\n        complete.update(buffer, 0, numRead);\n      }\n    } while (numRead != -1);\n    fis.close();\n    return complete.digest();\n  }\n"}, {"dataset": "digest", "exampleID": 5853, "initialization": ["MessageDigest messageDigest = getInstance(String,Provider)"], "initializationStart": [330], "initializationEnd": [365], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 383, "focalAPIEnd": 395, "followUpCheck": "Arrays.equals(result,d2) == false", "checkType": "IF", "followUpCheckExpressionStart": 685, "followUpCheckExpressionEnd": 720, "followUpCheckBlockStart": 685, "followUpCheckBlockEnd": 772, "use": ["digest(messageDigest,ByteBuffer,Random)", "digest(messageDigest,ByteBuffer,Random)", "digest(messageDigest,ByteBuffer,Random)"], "useStart": [657, 911, 1165], "useEnd": [679, 933, 1187], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/sun/security/pkcs11/MessageDigest/ByteBuffers.java", "rawCode": "  public void main(Provider p) throws Exception {\n    if (p.getService(\"MessageDigest\", \"MD5\") == null) {\n      System.out.println(\"Provider does not support MD5, skipping\");\n      return;\n    }\n\n    Random random = new Random();\n    int n = 10 * 1024;\n    byte[] t = new byte[n];\n    random.nextBytes(t);\n\n    MessageDigest md = MessageDigest.getInstance(\"MD5\", p);\n    byte[] d1 = md.digest(t);\n\n    // test 1: ByteBuffer with an accessible backing array\n    ByteBuffer b1 = ByteBuffer.allocate(n + 256);\n    b1.position(random.nextInt(256));\n    b1.limit(b1.position() + n);\n    ByteBuffer b2 = b1.slice();\n    b2.put(t);\n    b2.clear();\n    byte[] d2 = digest(md, b2, random);\n    if (Arrays.equals(d1, d2) == false) {\n      throw new Exception(\"Test 1 failed\");\n    }\n\n    // test 2: direct ByteBuffer\n    ByteBuffer b3 = ByteBuffer.allocateDirect(t.length);\n    b3.put(t);\n    b3.clear();\n    byte[] d3 = digest(md, b3, random);\n    if (Arrays.equals(d1, d2) == false) {\n      throw new Exception(\"Test 2 failed\");\n    }\n\n    // test 3: ByteBuffer without an accessible backing array\n    b2.clear();\n    ByteBuffer b4 = b2.asReadOnlyBuffer();\n    byte[] d4 = digest(md, b4, random);\n    if (Arrays.equals(d1, d2) == false) {\n      throw new Exception(\"Test 3 failed\");\n    }\n    System.out.println(\"All tests passed\");\n  }\n"}, {"dataset": "digest", "exampleID": 5854, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [1138], "initializationEnd": [1171], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["getMessage()", "error(*,*)"], "tryExpressionStart": 1117, "tryExpressionEnd": 1121, "tryBlockStart": 1117, "tryBlockEnd": 1389, "catchExpressionStart": 1300, "catchExpressionEnd": 1335, "catchBlockStart": 1300, "catchBlockEnd": 1389, "exceptionHandlingCallStart": [1360, 1347], "exceptionHandlingCallEnd": [1374, 1378], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 1262, "focalAPIEnd": 1286, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["encodeBase64URLSafeString(result)"], "useStart": [1229], "useEnd": [1287], "hasFinally": 1, "cleanUpCall": ["getName()", "currentTimeMillis()", "apiCall(*,String,*)"], "finallyExpressionStart": 4241, "finallyExpressionEnd": 4249, "finallyBlockStart": 4241, "finallyBlockEnd": 4379, "cleanUpCallStart": [4289, 4341, 4257], "cleanUpCallEnd": [4329, 4367, 4372], "url": "https://github.com/ieb/sparsemapcontent/tree/master/core/src/main/java/org/sakaiproject/nakamura/lite/accesscontrol/AccessControlManagerImpl.java", "rawCode": "  @SuppressWarnings(\n    value = \"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\",\n    justification =\n        \"Not correct, the line in question doesnt check for a null, so the check is not redundant\"\n  )\n  public void setAcl(String objectType, String objectPath, AclModification[] aclModifications)\n      throws StorageClientException, AccessDeniedException {\n    long t = System.currentTimeMillis();\n    try {\n      checkOpen();\n      check(objectType, objectPath, Permissions.CAN_WRITE_ACL);\n      check(objectType, objectPath, Permissions.CAN_READ_ACL);\n      String key = this.getAclKey(objectType, objectPath);\n      Map<String, Object> currentAcl = getCached(keySpace, aclColumnFamily, key);\n      if (currentAcl == null) {\n        currentAcl = Maps.newHashMap();\n      }\n      // every ACL gets a secret key, which avoids doing it later with a\n      // special call\n      Map<String, Object> modifications = Maps.newLinkedHashMap();\n      if (!currentAcl.containsKey(_SECRET_KEY)) {\n        byte[] secretKeySeed = new byte[20];\n        secureRandom.nextBytes(secretKeySeed);\n        MessageDigest md;\n        try {\n          md = MessageDigest.getInstance(\"SHA1\");\n          modifications.put(\n              _SECRET_KEY, Base64.encodeBase64URLSafeString(md.digest(secretKeySeed)));\n        } catch (NoSuchAlgorithmException e) {\n          LOGGER.error(e.getMessage(), e);\n        }\n      }\n      if (!currentAcl.containsKey(_KEY)) {\n        modifications.put(_KEY, key);\n        modifications.put(_OBJECT_TYPE, objectType); // this is here to\n        // make\n        // data\n        // migration\n        // possible in\n        // the\n        // future\n        modifications.put(_PATH, objectPath); // same\n      }\n      for (AclModification m : aclModifications) {\n        String name = m.getAceKey();\n        if (READ_ONLY_PROPERTIES.contains(name)) {\n          continue;\n        }\n        if (m.isRemove()) {\n          modifications.put(name, null);\n        } else {\n\n          int originalbitmap = getBitMap(name, modifications, currentAcl);\n          int modifiedbitmap = m.modify(originalbitmap);\n          LOGGER.debug(\"Adding Modification {} {} \", name, modifiedbitmap);\n          modifications.put(name, modifiedbitmap);\n\n          // KERN-1515\n          // We need to modify the opposite key to apply the\n          // reverse of the change we just made. Otherwise,\n          // you can end up with ACLs with contradictions, like:\n          // anonymous@g=1, anonymous@d=1\n          if (containsKey(inverseKeyOf(name), modifications, currentAcl)) {\n            // XOR gives us a mask of only the bits that changed\n            int difference = originalbitmap ^ modifiedbitmap;\n            int otherbitmap = toInt(getBitMap(inverseKeyOf(name), modifications, currentAcl));\n\n            // Zero out the bits that have been modified\n            //\n            // KERN-1887: This was originally toggling the modified\n            // bits\n            // using: \"otherbitmap ^ difference\", but this would\n            // incorrectly grant permissions in some cases (see JIRA\n            // issue). To avoid inconsistencies between grant and\n            // deny\n            // lists, setting a bit in one list should unset the\n            // corresponding bit in the other.\n            int modifiedotherbitmap = otherbitmap & ~difference;\n\n            if (otherbitmap != modifiedotherbitmap) {\n              // We made a change. Record our modification.\n              modifications.put(inverseKeyOf(name), modifiedotherbitmap);\n            }\n          }\n        }\n      }\n      LOGGER.debug(\"Updating ACL {} {} \", key, modifications);\n      putCached(\n          keySpace,\n          aclColumnFamily,\n          key,\n          modifications,\n          (currentAcl == null || currentAcl.size() == 0));\n      storeListener.onUpdate(\n          objectType, objectPath, getCurrentUserId(), \"type:acl\", false, null, \"op:acl\");\n      // clear the compiled cache for this session.\n      List<String> keys = Lists.newArrayList();\n      for (Entry<String, int[]> e : cache.entrySet()) {\n        if (e.getKey().startsWith(key)) {\n          keys.add(e.getKey());\n        }\n      }\n      for (String k : keys) {\n        cache.remove(k);\n      }\n    } finally {\n      statsService.apiCall(\n          AccessControlManagerImpl.class.getName(), \"setAcl\", System.currentTimeMillis() - t);\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5855, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [145], "initializationEnd": [179], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["idManager()", "createUuid()"], "tryExpressionStart": 127, "tryExpressionEnd": 131, "tryBlockStart": 127, "tryBlockEnd": 727, "catchExpressionStart": 492, "catchExpressionEnd": 527, "catchBlockStart": 492, "catchBlockEnd": 636, "exceptionHandlingCallStart": [605, 605], "exceptionHandlingCallEnd": [616, 629], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [188, 207, 264, 368, 416], "configurationEnd": [199, 256, 287, 400, 432], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 471, "focalAPIEnd": 483, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteArrayToHexStr(result)"], "useStart": [453], "useEnd": [484], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/SAK-16600/kernel-impl/src/main/java/org/sakaiproject/tool/impl/SessionComponent.java", "rawCode": "  public String makeSessionId(HttpServletRequest req, Principal principal) {\n    MessageDigest sha;\n    String sessionId;\n\n    try {\n      sha = MessageDigest.getInstance(\"SHA-1\");\n\n      sha.reset();\n      sha.update(principal.getName().getBytes(\"UTF-8\"));\n      sha.update((byte) 0x0a);\n      String ua = req.getHeader(\"user-agent\");\n      if (ua != null) {\n        sha.update(ua.getBytes(\"UTF-8\"));\n      }\n      sha.update(salt);\n\n      sessionId = byteArrayToHexStr(sha.digest());\n    } catch (NoSuchAlgorithmException e) {\n      // Fallback to new uuid rather than a non-hashed id\n      sessionId = idManager().createUuid();\n    } catch (UnsupportedEncodingException e) {\n      sessionId = idManager().createUuid();\n    }\n\n    return sessionId;\n  }\n"}, {"dataset": "digest", "exampleID": 5856, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [145], "initializationEnd": [179], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["idManager()", "createUuid()"], "tryExpressionStart": 127, "tryExpressionEnd": 131, "tryBlockStart": 127, "tryBlockEnd": 671, "catchExpressionStart": 436, "catchExpressionEnd": 471, "catchBlockStart": 436, "catchBlockEnd": 580, "exceptionHandlingCallStart": [549, 549], "exceptionHandlingCallEnd": [560, 573], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [188, 207, 264, 295, 360], "configurationEnd": [199, 256, 287, 352, 376], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 415, "focalAPIEnd": 427, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteArrayToHexStr(result)"], "useStart": [397], "useEnd": [428], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.15/kernel-impl/src/main/java/org/sakaiproject/tool/impl/SessionComponent.java", "rawCode": "  public String makeSessionId(HttpServletRequest req, Principal principal) {\n    MessageDigest sha;\n    String sessionId;\n\n    try {\n      sha = MessageDigest.getInstance(\"SHA-1\");\n\n      sha.reset();\n      sha.update(principal.getName().getBytes(\"UTF-8\"));\n      sha.update((byte) 0x0a);\n      sha.update(req.getHeader(\"user-agent\").getBytes(\"UTF-8\"));\n      sha.update(salt);\n\n      sessionId = byteArrayToHexStr(sha.digest());\n    } catch (NoSuchAlgorithmException e) {\n      // Fallback to new uuid rather than a non-hashed id\n      sessionId = idManager().createUuid();\n    } catch (UnsupportedEncodingException e) {\n      sessionId = idManager().createUuid();\n    }\n\n    return sessionId;\n  }\n"}, {"dataset": "digest", "exampleID": 5857, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [145], "initializationEnd": [179], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["idManager()", "createUuid()"], "tryExpressionStart": 127, "tryExpressionEnd": 131, "tryBlockStart": 127, "tryBlockEnd": 671, "catchExpressionStart": 436, "catchExpressionEnd": 471, "catchBlockStart": 436, "catchBlockEnd": 580, "exceptionHandlingCallStart": [549, 549], "exceptionHandlingCallEnd": [560, 573], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [188, 207, 264, 295, 360], "configurationEnd": [199, 256, 287, 352, 376], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 415, "focalAPIEnd": 427, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteArrayToHexStr(result)"], "useStart": [397], "useEnd": [428], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/SAK-16693/kernel-impl/src/main/java/org/sakaiproject/tool/impl/SessionComponent.java", "rawCode": "  public String makeSessionId(HttpServletRequest req, Principal principal) {\n    MessageDigest sha;\n    String sessionId;\n\n    try {\n      sha = MessageDigest.getInstance(\"SHA-1\");\n\n      sha.reset();\n      sha.update(principal.getName().getBytes(\"UTF-8\"));\n      sha.update((byte) 0x0a);\n      sha.update(req.getHeader(\"user-agent\").getBytes(\"UTF-8\"));\n      sha.update(salt);\n\n      sessionId = byteArrayToHexStr(sha.digest());\n    } catch (NoSuchAlgorithmException e) {\n      // Fallback to new uuid rather than a non-hashed id\n      sessionId = idManager().createUuid();\n    } catch (UnsupportedEncodingException e) {\n      sessionId = idManager().createUuid();\n    }\n\n    return sessionId;\n  }\n"}, {"dataset": "digest", "exampleID": 5858, "initialization": ["MessageDigest messageDigest = newMD5()"], "initializationStart": [82], "initializationEnd": [90], "hasTryCatch": 1, "exceptionType": "UnsupportedEncodingException", "exceptionHandlingCall": ["new RuntimeException(String,*)"], "tryExpressionStart": 49, "tryExpressionEnd": 53, "tryBlockStart": 49, "tryBlockEnd": 296, "catchExpressionStart": 177, "catchExpressionEnd": 216, "catchBlockStart": 177, "catchBlockEnd": 296, "exceptionHandlingCallStart": [232], "exceptionHandlingCallEnd": [287], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [100], "configurationEnd": [133], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 155, "focalAPIEnd": 166, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["LHEX(result)"], "useStart": [150], "useEnd": [167], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mrdon/speakeasy-plugin/tree/master/plugin/src/test/java/it/com/atlassian/labs/speakeasy/util/jgit/HttpAuthMethod.java", "rawCode": "    private static String H(String data) {\n      try {\n        MessageDigest md = newMD5();\n        md.update(data.getBytes(\"UTF-8\"));\n        return LHEX(md.digest());\n      } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(\"UTF-8 encoding not available\", e);\n      }\n    }\n"}, {"dataset": "digest", "exampleID": 5859, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [92], "initializationEnd": [124], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [219], "configurationEnd": [245], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 269, "focalAPIEnd": 280, "followUpCheck": "i < result.length", "checkType": "LOOP", "followUpCheckExpressionStart": 331, "followUpCheckExpressionEnd": 372, "followUpCheckBlockStart": 331, "followUpCheckBlockEnd": 462, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Digt/TrustedNet/tree/master/Server/Portal/trustednet-portal/src/main/java/com/digt/util/HttpUtils.java", "rawCode": "  public static String generateId(String salt) {\n    MessageDigest md;\n    try {\n      md = MessageDigest.getInstance(\"MD5\");\n    } catch (NoSuchAlgorithmException ex) {\n      throw new RuntimeException(ex);\n    }\n\n    md.update(salt.getBytes());\n    byte byteData[] = md.digest();\n\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < byteData.length; i++) {\n      sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n    }\n\n    return sb.toString();\n  }\n"}, {"dataset": "digest", "exampleID": 5860, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [1337, 1399, 1438, 1501, 1538], "configurationEnd": [1391, 1430, 1493, 1530, 1563], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 1592, "focalAPIEnd": 1613, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fromRaw(result,int)"], "useStart": [1571], "useEnd": [1617], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/saces/jgit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/transport/IndexPack.java", "rawCode": "  private void resolveDeltas(\n      final long pos, final int oldCRC, int type, byte[] data, PackedObjectInfo oe)\n      throws IOException {\n    crc.reset();\n    position(pos);\n    int c = readFromFile();\n    final int typeCode = (c >> 4) & 7;\n    long sz = c & 15;\n    int shift = 4;\n    while ((c & 0x80) != 0) {\n      c = readFromFile();\n      sz += (c & 0x7f) << shift;\n      shift += 7;\n    }\n\n    switch (typeCode) {\n      case Constants.OBJ_COMMIT:\n      case Constants.OBJ_TREE:\n      case Constants.OBJ_BLOB:\n      case Constants.OBJ_TAG:\n        type = typeCode;\n        data = inflateFromFile((int) sz);\n        break;\n      case Constants.OBJ_OFS_DELTA:\n        {\n          c = readFromFile() & 0xff;\n          while ((c & 128) != 0) c = readFromFile() & 0xff;\n          data = BinaryDelta.apply(data, inflateFromFile((int) sz));\n          break;\n        }\n      case Constants.OBJ_REF_DELTA:\n        {\n          crc.update(buf, fillFromFile(20), 20);\n          use(20);\n          data = BinaryDelta.apply(data, inflateFromFile((int) sz));\n          break;\n        }\n      default:\n        throw new IOException(\"Unknown object type \" + typeCode + \".\");\n    }\n\n    final int crc32 = (int) crc.getValue();\n    if (oldCRC != crc32) throw new IOException(\"Corruption detected re-reading at \" + pos);\n    if (oe == null) {\n      objectDigest.update(Constants.encodedTypeString(type));\n      objectDigest.update((byte) ' ');\n      objectDigest.update(Constants.encodeASCII(data.length));\n      objectDigest.update((byte) 0);\n      objectDigest.update(data);\n      tempObjectId.fromRaw(objectDigest.digest(), 0);\n\n      verifySafeObject(tempObjectId, type, data);\n      oe = new PackedObjectInfo(pos, crc32, tempObjectId);\n      addObjectAndTrack(oe);\n    }\n\n    resolveChildDeltas(pos, type, data, oe);\n  }\n"}, {"dataset": "digest", "exampleID": 5861, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 84, "focalAPIEnd": 95, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdcasey/JGit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackOutputStream.java", "rawCode": "  /** @return obtain the current SHA-1 digest. */\n  byte[] getDigest() {\n    return md.digest();\n  }\n"}, {"dataset": "digest", "exampleID": 5862, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [190], "initializationEnd": [226], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.reset()"], "configurationStart": [232], "configurationEnd": [243], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 896, "focalAPIEnd": 908, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ByteArrayToBigIntegerWithoutSign(result)"], "useStart": [922], "useEnd": [977], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mmoutenot/SandFox/tree/master/mobile/android/base/sync/jpake/JPakeCrypto.java", "rawCode": "  private static BigInteger computeBHash(BigInteger g, BigInteger gr, BigInteger gx, String id)\n      throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    MessageDigest sha = MessageDigest.getInstance(\"SHA-256\");\n    sha.reset();\n\n    /*\n     * Note: you should ensure the items in H(...) have clear boundaries. It\n     * is simple if the other party knows sizes of g, gr, gx and signerID and\n     * hence the boundary is unambiguous. If not, you'd better prepend each\n     * item with its byte length, but I've omitted that here.\n     */\n\n    hashByteArrayWithLength(sha, BigIntegerHelper.BigIntegerToByteArrayWithoutSign(g));\n    hashByteArrayWithLength(sha, BigIntegerHelper.BigIntegerToByteArrayWithoutSign(gr));\n    hashByteArrayWithLength(sha, BigIntegerHelper.BigIntegerToByteArrayWithoutSign(gx));\n    hashByteArrayWithLength(sha, id.getBytes(\"UTF-8\"));\n\n    byte[] hash = sha.digest();\n\n    return BigIntegerHelper.ByteArrayToBigIntegerWithoutSign(hash);\n  }\n"}, {"dataset": "digest", "exampleID": 5863, "initialization": ["byte[] input = convertPNG(BufferedImage)", "byte[] input = convertJPG(BufferedImage)", "MessageDigest messageDigest = getInstance(String)"], "initializationStart": [808, 944, 1167], "initializationEnd": [831, 967, 1201], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new OmUnexpectedException(*)"], "tryExpressionStart": 1148, "tryExpressionEnd": 1152, "tryBlockStart": 1148, "tryBlockEnd": 1299, "catchExpressionStart": 3107, "catchExpressionEnd": 3129, "catchBlockStart": 3107, "catchBlockEnd": 3186, "exceptionHandlingCallStart": [3147], "exceptionHandlingCallEnd": [3175], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 1426, "focalAPIEnd": 1446, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteArrayToHexString(result)"], "useStart": [1397], "useEnd": [1447], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/branches/DEV_v1_8/trunk-archive/src/om/stdcomponent/CanvasComponent.java", "rawCode": "  @Override\n  protected void produceVisibleOutput(QContent qc, boolean bInit, boolean bPlain)\n      throws OmException {\n    // Plain mode just shows text equivalent (at present)\n    if (bPlain) {\n      // Put text equivalent\n      Element eDiv =\n          qc.createElement(\"div\"); // Can't use span because they aren't allowed to contain things\n      eDiv.setAttribute(\"style\", \"display:inline\");\n      addLangAttributes(eDiv);\n      qc.addInlineXHTML(eDiv);\n      XML.createText(eDiv, getString(\"alt\"));\n      qc.addTextEquivalent(getString(\"alt\"));\n\n      // Markers are not supported in plain mode\n      return;\n    }\n\n    // If image has changed, send new version\n    if (bChanged) {\n      byte[] imageData;\n      String mimeType;\n      if (getString(PROPERTY_TYPE).equals(\"png\")) {\n        imageData = QContent.convertPNG(bi);\n        mimeType = \"image/png\";\n      } else if (getString(PROPERTY_TYPE).equals(\"jpg\")) {\n        imageData = QContent.convertJPG(bi);\n        mimeType = \"image/jpeg\";\n      } else {\n        throw new OmUnexpectedException(\"Unknown canvas type. Only png and jpg are valid.\");\n      }\n      MessageDigest md;\n      try {\n        md = MessageDigest.getInstance(\"SHA-1\");\n      } catch (NoSuchAlgorithmException e) {\n        throw new OmUnexpectedException(e);\n      }\n      filename =\n          \"canvas-\"\n              + getID()\n              + \"-\"\n              + Strings.byteArrayToHexString(md.digest(imageData))\n              + \".\"\n              + getString(PROPERTY_TYPE);\n      qc.addResource(filename, mimeType, imageData);\n    }\n\n    Element eEnsureSpaces = qc.createElement(\"div\");\n    eEnsureSpaces.setAttribute(\"class\", \"canvas\");\n    addLangAttributes(eEnsureSpaces);\n    qc.addInlineXHTML(eEnsureSpaces);\n    XML.createText(eEnsureSpaces, \" \");\n\n    String sImageID = QDocument.ID_PREFIX + getID() + \"_img\";\n    Element eImg = XML.createChild(eEnsureSpaces, \"img\");\n    eImg.setAttribute(\"id\", sImageID);\n    eImg.setAttribute(\"onmousedown\", \"return false;\"); // Prevent Firefox drag/drop\n    eImg.setAttribute(\"src\", \"%%RESOURCES%%/\" + filename);\n    eImg.setAttribute(\"alt\", getString(\"alt\"));\n\n    // Get zoom, marker size and hotspot position.\n    double dZoom = getQuestion().getZoom();\n    int iMarkerSize;\n    if (dZoom >= 2.0) {\n      iMarkerSize = 31;\n    } else if (dZoom >= 1.5) {\n      iMarkerSize = 23;\n    } else {\n      iMarkerSize = 15;\n    }\n\n    int[] hotspotPositions = parseHotspotProperty(getString(PROPERTY_MARKERHOTSPOT), iMarkerSize);\n\n    String sMarkerPrefix = getString(PROPERTY_MARKERIMAGE);\n    if (bInit && !lMarkers.isEmpty()) {\n      if (sMarkerPrefix == null) {\n        setString(PROPERTY_MARKERIMAGE, \"canvasm\");\n        sMarkerPrefix = \"canvasm\" + iMarkerSize;\n        try {\n          qc.addResource(\n              sMarkerPrefix + \".gif\",\n              \"image/gif\",\n              IO.loadResource(CanvasComponent.class, sMarkerPrefix + \".gif\"));\n          qc.addResource(\n              sMarkerPrefix + \"d.gif\",\n              \"image/gif\",\n              IO.loadResource(CanvasComponent.class, sMarkerPrefix + \"d.gif\"));\n        } catch (IOException e) {\n          throw new OmUnexpectedException(e);\n        }\n      } else {\n        sMarkerPrefix += iMarkerSize;\n        try {\n          qc.addResource(\n              sMarkerPrefix + \".gif\",\n              \"image/gif\",\n              getQuestion().loadResource(sMarkerPrefix + \".gif\"));\n          qc.addResource(\n              sMarkerPrefix + \"d.gif\",\n              \"image/gif\",\n              getQuestion().loadResource(sMarkerPrefix + \"d.gif\"));\n        } catch (IOException e) {\n          throw new OmDeveloperException(\"Marker image not found: \" + sMarkerPrefix, e);\n        }\n      }\n    } else {\n      sMarkerPrefix += iMarkerSize;\n    }\n    if (!lMarkers.isEmpty()) {\n      Element eScript = XML.createChild(eEnsureSpaces, \"script\");\n      eScript.setAttribute(\"type\", \"text/javascript\");\n      XML.createText(\n          eScript,\n          \"addOnLoad(function() { canvasInit('\"\n              + getID()\n              + \"','\"\n              + QDocument.ID_PREFIX\n              + \"',\"\n              + isEnabled()\n              + \",\"\n              + hotspotPositions[0]\n              + \",\"\n              + hotspotPositions[1]\n              + \",\"\n              + ((int) (dZoom * 4.0))\n              + \",'\"\n              + (getQuestion().isFixedColour() ? getQuestion().getFixedColourFG() : \"black\")\n              + \"','\"\n              + (getQuestion().isFixedColour()\n                  ? getQuestion().getFixedColourBG()\n                  : convertHash(getBackground()))\n              + \"',\"\n              + (int) (dZoom * 10.0)\n              + \"); });\");\n      Element eDynamic = XML.createChild(eEnsureSpaces, \"div\");\n      eDynamic.setAttribute(\"id\", QDocument.ID_PREFIX + getID() + \"_dynamic\");\n    }\n\n    int index = 0;\n    for (Marker m : lMarkers) {\n      Element eMarker = XML.createChild(eEnsureSpaces, \"img\");\n      eMarker.setAttribute(\"id\", QDocument.ID_PREFIX + getID() + \"_marker\" + index);\n      eMarker.setAttribute(\n          \"src\", \"%%RESOURCES%%/\" + sMarkerPrefix + (isEnabled() ? \"\" : \"d\") + \".gif\");\n      eMarker.setAttribute(\"class\", \"canvasmarker\");\n      if (isEnabled()) eMarker.setAttribute(\"tabindex\", \"0\");\n      Element eScript = XML.createChild(eEnsureSpaces, \"script\");\n      eScript.setAttribute(\"type\", \"text/javascript\");\n      World w = m.sWorld == null ? null : getWorld(m.sWorld);\n      XML.createText(\n          eScript,\n          \"addOnLoad(function() { canvasMarkerInit('\"\n              + getID()\n              + \"','\"\n              + QDocument.ID_PREFIX\n              + \"','\"\n              + m.sLabelJS.replaceAll(\"'\", \"\\\\\\\\'\")\n              + \"',\"\n              + getWorldFactors(w, dZoom)\n              + \"); });\");\n      Element eInputX = XML.createChild(eEnsureSpaces, \"input\");\n      eInputX.setAttribute(\"type\", \"hidden\");\n      eInputX.setAttribute(\"value\", \"\" + (int) (m.iX * dZoom));\n      eInputX.setAttribute(\n          \"name\", QDocument.ID_PREFIX + \"canvasmarker_\" + getID() + \"_\" + index + \"x\");\n      eInputX.setAttribute(\"id\", eInputX.getAttribute(\"name\"));\n      Element eInputY = XML.createChild(eEnsureSpaces, \"input\");\n      eInputY.setAttribute(\"type\", \"hidden\");\n      eInputY.setAttribute(\"value\", \"\" + (int) (m.iY * dZoom));\n      eInputY.setAttribute(\n          \"name\", QDocument.ID_PREFIX + \"canvasmarker_\" + getID() + \"_\" + index + \"y\");\n      eInputY.setAttribute(\"id\", eInputY.getAttribute(\"name\"));\n\n      if (isEnabled())\n        qc.informFocusable(QDocument.ID_PREFIX + getID() + \"_marker\" + index, bPlain);\n\n      index++;\n    }\n    for (MarkerLine ml : lLines) {\n      World w = ml.sWorld == null ? null : getWorld(ml.sWorld);\n\n      Element eScript = XML.createChild(eEnsureSpaces, \"script\");\n      eScript.setAttribute(\"type\", \"text/javascript\");\n      XML.createText(\n          eScript,\n          \"addOnLoad(function() { canvasLineInit('\"\n              + getID()\n              + \"','\"\n              + QDocument.ID_PREFIX\n              + \"',\"\n              + ml.iFrom\n              + \",\"\n              + ml.iTo\n              + \",'\"\n              + ml.sLabelJS.replaceAll(\"'\", \"\\\\\\\\'\")\n              + \"',\"\n              + getWorldFactors(w, dZoom)\n              + \"); });\");\n    }\n\n    XML.createText(eEnsureSpaces, \" \");\n    qc.addTextEquivalent(getString(\"alt\"));\n  }\n"}, {"dataset": "digest", "exampleID": 5864, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [89], "initializationEnd": [121], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 224, "focalAPIEnd": 236, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["encode(result)"], "useStart": [210], "useEnd": [237], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Ichmed/Vloxlands/tree/master/src/com/vloxlands/util/Assistant.java", "rawCode": "  public static String MD5(byte[] b) {\n    MessageDigest md = null;\n    try {\n      md = MessageDigest.getInstance(\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n      e.printStackTrace();\n    }\n    return HexBin.encode(md.digest(b));\n  }\n"}, {"dataset": "digest", "exampleID": 5865, "initialization": ["MessageDigest messageDigest = getMessageDigest()"], "initializationStart": [210], "initializationEnd": [228], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [234], "configurationEnd": [259], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 272, "focalAPIEnd": 283, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/elitak/peertrust/tree/master/sandbox/Grid/gt4mfs/mfs/MathService/src/g4mfs/impl/crypto/CryptTools.java", "rawCode": "  /**\n   * Computes a messageDigest for a given String.\n   *\n   * @param arg the String to that the hash function should be applied.\n   */\n  public static byte[] hashString(String arg) {\n    MessageDigest md = getMessageDigest();\n    md.update(arg.getBytes());\n    return md.digest();\n  }\n"}, {"dataset": "digest", "exampleID": 5866, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [664], "initializationEnd": [696], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[])"], "configurationStart": [702, 725], "configurationEnd": [719, 755], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 826, "focalAPIEnd": 844, "followUpCheck": "i < result.length", "checkType": "LOOP", "followUpCheckExpressionStart": 957, "followUpCheckExpressionEnd": 1003, "followUpCheckBlockStart": 957, "followUpCheckBlockEnd": 1081, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BENGMN/soen490/tree/master/MasterServer/src/domain/user/UserFactory.java", "rawCode": "  /**\n   * Generates a unique ID by creating an md5 hash with the email and password and then converting\n   * the hex into decimal\n   *\n   * @param email\n   * @param password\n   * @return Returns a unique ID that is not shared by any user in the database.\n   * @throws NoSuchAlgorithmException\n   */\n  private static BigInteger createUniqueID(String email, String password)\n      throws NoSuchAlgorithmException {\n    // The seed is basically a concatenation of the email and password. It is unique to a user\n    String seed = email + password;\n    byte[] defaultBytes = seed.getBytes();\n\n    // This is where you pick your algorithm\n    MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n    algorithm.reset();\n    algorithm.update(defaultBytes);\n\n    // This is where the hashing happens\n    byte messageDigest[] = algorithm.digest();\n\n    // This is where you convert the hex code to decimal\n    StringBuffer hexString = new StringBuffer();\n    for (int i = 0; i < messageDigest.length; i++) {\n      hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n    }\n\n    return new BigInteger(hexString.toString(), 16);\n  }\n"}, {"dataset": "digest", "exampleID": 5867, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [2535], "initializationEnd": [2569], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": [], "tryExpressionStart": 2608, "tryExpressionEnd": 2612, "tryBlockStart": 2608, "tryBlockEnd": 10600, "catchExpressionStart": 12730, "catchExpressionEnd": 12751, "catchBlockStart": 12730, "catchBlockEnd": 13010, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [11142], "configurationEnd": [11160], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 11180, "focalAPIEnd": 11191, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getHexString(result)"], "useStart": [11216], "useEnd": [11253], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fakechris/JTrackerServer/tree/master/src/java/com/tracker/backend/webinterface/TorrentUpload.java", "rawCode": "  /**\n   * Reads a torrent given in the request, makes changes if necessary, then adds it to the database\n   * of tracked torrents.\n   *\n   * @param decodedTorrent the torrent decoded from original bencoded form.\n   * @param torrentDescription the torrent description to persist in the database.\n   * @param torrentName the torrent name to persist in the database.\n   * @param contextPath the context path of the running servlet. Used for checking the announce keys\n   *     in the torrent file.\n   * @return a TreeMap populated with the result of the operation, plus eventual warnings or error\n   *     messages.\n   *     <p>The keys this may contain is:\n   *     <ul>\n   *       <li><b>\"warning reason\"</b>: a human readable string describing a warning encountered\n   *           while adding the torrentfile (wrong announce for example). This is left empty if\n   *           there is no warning given.\n   *       <li><b>\"error reason\"</b>: a human readable description of why this torrent could not be\n   *           added to the database. This is left empty if there is no errors.\n   *       <li><b>\"redownload\"</b>: equals to \"true\" if the client needs to redownload the\n   *           torrentfile before {s,}he can begin seeding the torrent (for example if the\n   *           torrentfile had an incorrect announce URL, and was changed). Equals to \"false\" if\n   *           there is no reason to redownload the torrentfile.\n   *     </ul>\n   *\n   * @throws java.lang.Exception if there is some problem with the given torrentfile or the\n   *     persisting operation.\n   */\n  public static Map<String, String> addTorrent(\n      Map decodedTorrent, String torrentName, String torrentDescription, String contextPath)\n      throws Exception {\n    Long torrentLength = Long.valueOf(0);\n    Torrent t;\n    TorrentData tData;\n    TorrentFile tFile;\n\n    // list of files and their lengths\n    Vector<TorrentContent> torrentFiles = new Vector<TorrentContent>();\n\n    // the URL of this trackers announce, used for comparison with the\n    // URL given in the torrentfile.\n    String ourAnnounce = contextPath + \"/Announce\";\n\n    TreeMap<String, String> response = new TreeMap<String, String>();\n    // set some default replies\n    response.put(\"warning reason\", \"\");\n    response.put(\"error reason\", \"\");\n    response.put(\"redownload\", \"false\");\n\n    // set as null to avoid some nonsense when persisting, will be set\n    // by the decoded torrent\n    Map infoDictionary = null;\n\n    // for generating the info_hash\n    MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n\n    // process the input stream\n    try {\n      /*\n       * The torrent file layout is roughly like this:\n       * Mandatory:\n       * String announce (the URL of the tracker)\n       * Dictionary info (describes the files of the torrent)\n       * Mandatory:\n       * Integer piece length (number of bytes in each piece)\n       * String pieces (the SHA1 hashes of all the pieces)\n       *\n       * Optional:\n       * Integer private (determines if the torrent is private)\n       *\n       * If this is a single-file torrent:\n       * Mandatory:\n       * String name (filename of the file)\n       * Integer length (length of the file in bytes)\n       * Optional:\n       * String md5sum (MD5 sum of the file)\n       *\n       * If this is a multiple-file torrent:\n       * Mandatory:\n       * String name (the name of the directory to store the files in)\n       * List of Dictionaries files (one for each file)\n       * Mandatory:\n       * Integer length (length of the file in bytes)\n       * List path (a list of strings giving the path of the file)\n       * Optional:\n       * String md5sum (MD5 sum of the file)\n       * end of files\n       * end of info\n       * Optional:\n       * List announce-list (list of list of trackers)\n       * Integer creation date (the creation time of the torrent)\n       * String comment (a comment to the torrent)\n       * String created-by (gives the program used to create the torrent)\n       *\n       * The info hash used when tracking is the SHA1 hash of the\n       * _value_ of the info key, in other words, a bencoded\n       * dictionary.\n       *\n       * see:\n       * - http://wiki.theory.org/BitTorrentSpecification\n       * - http://bittorrent.org/beps/bep_0003.html (bittorrent specs)\n       * - http://bittorrent.org/beps/bep_0005.html (DHT specs)\n       * - http://bittorrent.org/beps/bep_0012.html (multitracker specs)\n       * for more information and links on optional keys like the\n       * announce-list.\n       */\n\n      String announceURL;\n\n      // make sure that the torrentfile contains a bare minimum\n      // of data.\n      if (!decodedTorrent.containsKey(\"info\")) {\n        log.log(Level.WARNING, \"Malformed torrentfile received.\" + \" missing 'info' dictionary.\");\n        throw new Exception(\"The Torrentfile given in upload is malformed.\");\n      }\n\n      // do we have an announce key?\n      if (!decodedTorrent.containsKey(\"announce\")) {\n        // add the announce key and rewrite it below\n        log.log(Level.FINE, \"Uploaded torrent missing announce key\");\n        decodedTorrent.put(\"announce\", \"\");\n      }\n\n      // make sure that we are the ones that track this torrent.\n      announceURL = (String) decodedTorrent.get((String) \"announce\");\n      if (!announceURL.equalsIgnoreCase(ourAnnounce)\n          || decodedTorrent.containsKey(\"announce-list\")) {\n        // check for the optional announce-list, if we are not\n        // given there either, or if this is not set, issue a\n        // warning and change the torrentfile.\n        if (!decodedTorrent.containsKey(\"announce-list\")) {\n          // rewrite the standard announce key\n          log.log(\n              Level.WARNING,\n              \"Uploaded torrent does not have\" + \"our announce (given was: \" + announceURL + \").\");\n          decodedTorrent.put(\"announce\", ourAnnounce);\n\n          // TODO: apply i10n here\n          response.put(\n              \"warning reason\",\n              \"The torrentfile did \"\n                  + \"not contain the correct announce URL, this \"\n                  + \"has been changed.\\n\");\n          response.put(\"redownload\", \"true\");\n        }\n        // announce-list found. Makes the \"announce\" key\n        // irrelevant. See this for more info:\n        // http://home.elp.rr.com/tur/multitracker-spec.txt\n        else {\n          // does it contain our announce string?\n          boolean valid = false;\n          // grab the announce-list and check every element\n          // for our announce URL.\n          Vector<Vector<String>> announceList =\n              (Vector<Vector<String>>) decodedTorrent.get(\"announce-list\");\n          Iterator announceListItr = announceList.iterator();\n\n          while (announceListItr.hasNext()) {\n            Vector<String> innerList = (Vector<String>) announceListItr.next();\n            Iterator innerItr = innerList.iterator();\n\n            while (innerItr.hasNext()) {\n              String announce = (String) innerItr.next();\n              if (announce.equalsIgnoreCase(ourAnnounce)) {\n                valid = true;\n                break;\n              }\n            }\n\n            if (valid) break;\n          }\n          if (!valid) {\n            log.log(\n                Level.WARNING,\n                \"Uploaded torrent does not \"\n                    + \"have our announce in announce-list (given \"\n                    + \"was: \"\n                    + announceList.toString()\n                    + \").\");\n            // add our announce URL to the top of the list\n            Vector<String> prependedAnnounce = new Vector<String>();\n            prependedAnnounce.add(ourAnnounce);\n            announceList.add(0, prependedAnnounce);\n\n            // TODO: apply i10n\n            response.put(\n                \"warning reason\",\n                \"The torrentfile \"\n                    + \"did not contain the correct announce URL \"\n                    + \"in it's announce list. This has been changed.\\n\");\n            response.put(\"redownload\", \"true\");\n          }\n        }\n      } // if wrong announce or announce-list\n\n      // check for the private setting\n      infoDictionary = (Map) decodedTorrent.get(\"info\");\n\n      if (infoDictionary.containsKey(\"private\")) {\n        Long privateField = (Long) infoDictionary.get(\"private\");\n        // is private enabled?\n        if (privateField == 1) {\n          // remove the private key and set appropriate warnings\n          infoDictionary.remove(\"private\");\n\n          log.log(Level.WARNING, \"Torrent uploaded with private\" + \"key enabled.\");\n          String warningReason = response.get(\"warning reason\");\n          warningReason += \"The torrentfile was set as private, \" + \"this has been removed.\";\n          response.put(\"warning reason\", warningReason);\n          response.put(\"redownload\", \"true\");\n        }\n      }\n\n      // set the torrentlength\n      // this is different if this is a single-file torrent or a\n      // multi-file torrent. Test for both.\n\n      // multi-file torrent - see diagram above\n      if (infoDictionary.containsKey(\"files\")) {\n        Vector<Map> files = (Vector<Map>) infoDictionary.get((String) \"files\");\n        Iterator fileItr = files.iterator();\n\n        while (fileItr.hasNext()) {\n          Map f = (Map) fileItr.next();\n\n          // grab length\n          Long length = (Long) f.get((String) \"length\");\n          torrentLength += length;\n\n          // grab path\n          Vector<String> filePath = (Vector<String>) f.get((String) \"path\");\n          Iterator pathItr = filePath.iterator();\n          StringBuilder path = new StringBuilder((String) infoDictionary.get((String) \"name\"));\n\n          // build up the path\n          while (pathItr.hasNext()) {\n            path.append('/');\n            path.append(pathItr.next());\n          }\n\n          TorrentContent c = new TorrentContent();\n          c.setFileName(path.toString());\n          c.setFileSize(length);\n\n          // populate the list\n          torrentFiles.add(c);\n        }\n      }\n      // single file torrent - see diagram above\n      else {\n        String name = (String) infoDictionary.get((String) \"name\");\n        Long length = (Long) infoDictionary.get((String) \"length\");\n\n        torrentLength = length;\n\n        TorrentContent c = new TorrentContent();\n        c.setFileName(name);\n        c.setFileSize(length);\n\n        // populate the list\n        torrentFiles.add(c);\n      }\n    } catch (Exception ex) {\n      log.log(Level.WARNING, \"Error when decoding given torrent.\", ex);\n      throw new Exception(\"Error when decoding torrent given in upload\", ex);\n    }\n\n    // persist!\n    // add the torrent to the database.\n    EntityManager em = emf.createEntityManager();\n    // grab the SHA1 hash of the (bencoded) info dictionary.\n    // the simplest way is to simply encode the info dictionary again\n    // (things may have changed), then do a SHA1-hash of the result.\n    String info = Bencode.encode(infoDictionary);\n    byte[] rawInfo = new byte[info.length()];\n    byte[] rawInfoHash = new byte[20];\n    for (int i = 0; i < rawInfo.length; i++) {\n      rawInfo[i] = (byte) info.charAt(i);\n    }\n    md.update(rawInfo);\n    rawInfoHash = md.digest();\n\n    String infoHash = StringUtils.getHexString(rawInfoHash);\n\n    // look for the info hash in the database to avoid duplicates,\n    // we can't have more than one torrent with a given info hash.\n    Query q =\n        em.createQuery(\"SELECT COUNT(t) FROM Torrent t WHERE \" + \"t.infoHash = '\" + infoHash + \"'\");\n\n    Long numElements = (Long) q.getSingleResult();\n    if (numElements >= 1) {\n      response.put(\n          \"error reason\",\n          \"We are already tracking this torrent! \"\n              + \"Please download and seed the existing torrent instead.\");\n      return response;\n    }\n\n    try {\n      t = new Torrent();\n      tData = new TorrentData();\n      tFile = new TorrentFile();\n\n      // set the info hash.\n      t.setInfoHash(infoHash);\n      // num seeders and all that is set by the Torrent constructor.\n\n      tData.setName(torrentName);\n      tData.setDescription(torrentDescription);\n      tData.setAdded(Calendar.getInstance().getTime());\n      tData.setTorrentSize(torrentLength);\n      tData.setTorrentContent(torrentFiles);\n\n      t.setTorrentData(tData);\n\n      // set the torrentfile\n      String bencodedTorrent = Bencode.encode(decodedTorrent);\n      tFile.setTorrentFile(bencodedTorrent);\n\n      t.setTorrentFile(tFile);\n\n      // persist this\n      em.getTransaction().begin();\n      em.persist(t);\n      // torrentData, torrentFile and torrentContent is automatically\n      // persisted through the Cascade operations specified in the\n      // entity classes.\n\n      em.getTransaction().commit();\n    } catch (Exception ex) {\n      if (em.getTransaction().isActive()) {\n        em.getTransaction().rollback();\n      }\n      log.log(Level.WARNING, \"Error when persisting the uploaded torrent.\", ex);\n      throw new Exception(\"Error when persising torrent given in upload\", ex);\n    } finally {\n      em.close();\n    }\n\n    return response;\n  }\n"}, {"dataset": "digest", "exampleID": 5868, "initialization": ["MessageDigest messageDigest = getInstance(*,*)"], "initializationStart": [202], "initializationEnd": [286], "hasTryCatch": 1, "exceptionType": "CertificateEncodingException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 111, "tryExpressionEnd": 115, "tryBlockStart": 111, "tryBlockEnd": 583, "catchExpressionStart": 371, "catchExpressionEnd": 410, "catchBlockStart": 371, "catchBlockEnd": 444, "exceptionHandlingCallStart": [418], "exceptionHandlingCallEnd": [437], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [294], "configurationEnd": [327], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 341, "focalAPIEnd": 363, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toHex(result)"], "useStart": [595], "useEnd": [612], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bomm/thera-pi/tree/master/Nebraska/src/nebraska/BCStatics.java", "rawCode": "  public static String getMD5(X509Certificate cert) {\n    byte[] encryptCert;\n    byte[] dig = null;\n    ;\n    try {\n      encryptCert = cert.getEncoded();\n      MessageDigest messageDigest =\n          MessageDigest.getInstance(Constants.HASH_ALGORITHM_MD5, Constants.SECURITY_PROVIDER);\n      messageDigest.update(encryptCert);\n      dig = messageDigest.digest();\n    } catch (CertificateEncodingException e) {\n      e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n      e.printStackTrace();\n    } catch (NoSuchProviderException e) {\n      e.printStackTrace();\n    }\n    return NUtils.toHex(dig);\n  }\n"}, {"dataset": "digest", "exampleID": 5869, "initialization": ["byte[] input = concatenate(byte[],byte[])", "MessageDigest messageDigest = getInstance(String)"], "initializationStart": [505, 606], "initializationEnd": [532, 640], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 771, "focalAPIEnd": 783, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mschn/wissl/tree/master/src/main/java/fr/msch/wissl/server/User.java", "rawCode": "  /**\n   * Generate salt in {@link User#salt}, use it along with {@link User#password} to create {@link\n   * User#sha1}. Nulls password once it is no longer needed\n   *\n   * @throws NoSuchAlgorithmException\n   */\n  public void hashPassword() throws SecurityError {\n    if (password == null || password.length < 4) {\n      throw new SecurityError(\"Password must be at least 4 characters long\");\n    }\n    Random rand = new SecureRandom();\n    salt = new byte[20];\n    rand.nextBytes(salt);\n\n    byte[] b = concatenate(password, salt);\n    password = null;\n\n    MessageDigest md = null;\n    try {\n      md = MessageDigest.getInstance(\"SHA-1\");\n    } catch (NoSuchAlgorithmException e) {\n      Logger.error(\"Cannot use SHA-1\", e);\n      throw new Error(e);\n    }\n    sha1 = md.digest(b);\n  }\n"}, {"dataset": "digest", "exampleID": 5870, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [122], "initializationEnd": [154], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [162], "configurationEnd": [184], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 204, "focalAPIEnd": 219, "followUpCheck": "i < result.length", "checkType": "LOOP", "followUpCheckExpressionStart": 271, "followUpCheckExpressionEnd": 306, "followUpCheckBlockStart": 271, "followUpCheckBlockEnd": 439, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/shunfa/crawlzilla/tree/master/v2.1/webmanager/src/nchc/fslab/crawlzilla/bean/adminLoginBean.java", "rawCode": "  public static final String _MD5(String s) {\n    try {\n      byte[] btInput = s.getBytes();\n      MessageDigest mdInst = MessageDigest.getInstance(\"MD5\");\n      mdInst.update(btInput);\n      byte[] md = mdInst.digest();\n      StringBuffer sb = new StringBuffer();\n      for (int i = 0; i < md.length; i++) {\n        int val = ((int) md[i]) & 0xff;\n        if (val < 16) sb.append(\"0\");\n        sb.append(Integer.toHexString(val));\n      }\n      return sb.toString();\n    } catch (Exception e) {\n      return null;\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5871, "initialization": ["MessageDigest messageDigest = getInstance(String)", "byte[] input = String.getBytes(String)"], "initializationStart": [368, 420], "initializationEnd": [404, 450], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 945, "focalAPIEnd": 961, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["hexString(result)"], "useStart": [935], "useEnd": [962], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/czakian/openmrs_gsoc/tree/master/api/src/main/java/org/openmrs/util/Security.java", "rawCode": "  /**\n   * This method will hash <code>strToEncode</code> using the old SHA-1 algorithm.\n   *\n   * @param strToEncode string to encode\n   * @return the SHA-1 encryption of a given string\n   */\n  private static String encodeStringSHA1(String strToEncode) throws APIException {\n    String algorithm = \"SHA1\";\n    MessageDigest md;\n    byte[] input;\n    try {\n      md = MessageDigest.getInstance(algorithm);\n      input = strToEncode.getBytes(encoding);\n    } catch (NoSuchAlgorithmException e) {\n      // Yikes! Can't encode password...what to do?\n      log.error(\n          \"Can't encode password because the given algorithm: \"\n              + algorithm\n              + \"was not found! (fail)\",\n          e);\n      throw new APIException(\"System cannot find SHA1 encryption algorithm\", e);\n    } catch (UnsupportedEncodingException e) {\n      throw new APIException(\"System cannot find \" + encoding + \" encoding\", e);\n    }\n    return hexString(md.digest(input));\n  }\n"}, {"dataset": "digest", "exampleID": 5872, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [106], "initializationEnd": [139], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [355], "configurationEnd": [384], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 438, "focalAPIEnd": 449, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteArraytoHexString(result)"], "useStart": [403], "useEnd": [450], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fcrepo/fcrepo-historical/tree/master/fcrepo-integrationtest/src/test/java/fedora/test/api/TestManagedDatastreams.java", "rawCode": "  private String computeChecksum(String csType, InputStream is) throws Exception {\n    MessageDigest md = MessageDigest.getInstance(csType);\n    if (is == null) {\n      throw new IllegalArgumentException(\"InputStream cannot be null\");\n    }\n    byte buffer[] = new byte[5000];\n    int numread;\n    while ((numread = is.read(buffer, 0, 5000)) > 0) {\n      md.update(buffer, 0, numread);\n    }\n    return StringUtility.byteArraytoHexString(md.digest());\n  }\n"}, {"dataset": "digest", "exampleID": 5873, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new SignatureException(String,BigInteger)"], "tryExpressionStart": 94, "tryExpressionEnd": 98, "tryBlockStart": 94, "tryBlockEnd": 2022, "catchExpressionStart": 1938, "catchExpressionEnd": 1958, "catchBlockStart": 1938, "catchBlockEnd": 2022, "exceptionHandlingCallStart": [1972], "exceptionHandlingCallEnd": [2015], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 1235, "focalAPIEnd": 1248, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["trimHash(result,ECParameterSpec)"], "useStart": [1226], "useEnd": [1257], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lightkeeper/lskeyczar/tree/master/java/code/unofficial/org/keyczar/jce/EcSignatureImpl.java", "rawCode": "  @Override\n  protected boolean engineVerify(byte[] sigBytes) throws SignatureException {\n    try {\n      // SEQUENCE.Template seqtemp = new SEQUENCE.Template();\n      // seqtemp.addElement( INTEGER.getTemplate() );\n      // seqtemp.addElement( INTEGER.getTemplate() );\n      // SEQUENCE seq = (SEQUENCE)seqtemp.decode(new\n      // ByteArrayInputStream(sigBytes));\n      // BigInteger r = (BigInteger)seq.elementAt(0);\n      // BigInteger s = (BigInteger)seq.elementAt(1);\n\n      // Arrggg, the following is a work around: JSS creates BigIntegers\n      // using BigInteger(byte[]) which, if the \"sign\" bit is set,\n      // create negative numbers. This, of course, destroys signature\n      // verification. In this case they should have used the\n      // BigInteger(1,byte[])\n      // constructor. Anyway, we do it manually...\n      SEQUENCE.Template foo = new SEQUENCE.Template();\n      foo.addElement(ANY.getTemplate());\n      foo.addElement(ANY.getTemplate());\n      SEQUENCE bar = (SEQUENCE) foo.decode(new ByteArrayInputStream(sigBytes));\n      BigInteger r = new BigInteger(1, ((ANY) bar.elementAt(0)).getContents());\n      BigInteger s = new BigInteger(1, ((ANY) bar.elementAt(1)).getContents());\n\n      BigInteger e = trimHash(hash.digest(), params);\n      BigInteger n = params.getOrder();\n\n      // r in [1,n-1]\n      if (r.compareTo(BigInteger.ONE) < 0 || r.compareTo(n) >= 0) return false;\n\n      // s in [1,n-1]\n      if (s.compareTo(BigInteger.ONE) < 0 || s.compareTo(n) >= 0) return false;\n\n      BigInteger c = s.modInverse(n);\n      BigInteger u1 = e.multiply(c).mod(n);\n      BigInteger u2 = r.multiply(c).mod(n);\n\n      BigInteger[] G = EcCore.internalPoint(params.getGenerator());\n      BigInteger[] W = EcCore.internalPoint(publicKey.getW());\n      BigInteger[] R1 = EcCore.multiplyPoints(G, u1, W, u2, params);\n      EcCore.toAffineX(R1, params);\n\n      BigInteger v = R1[0].mod(n);\n\n      return v.equals(r);\n    } catch (Exception e) {\n      throw new SignatureException(\"Internal error\", e);\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5874, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [2281], "initializationEnd": [2314], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [2600], "configurationEnd": [2630], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 2680, "focalAPIEnd": 2693, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toHexString(result)"], "useStart": [2668], "useEnd": [2694], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/biomart/biomart-rc7/tree/master/src/org/biomart/common/utils/InstallCert.java", "rawCode": "  public void test(String url) throws Exception {\n    String tmp = url.substring(8); // remove https://\n    int index0 = tmp.indexOf(\"/\");\n    tmp = tmp.substring(0, index0);\n\n    String[] c = tmp.split(\":\");\n    String host = c[0];\n    int port = Integer.parseInt(c[1]);\n    ;\n    char[] passphrase;\n\n    String p = \"changeit\";\n    passphrase = p.toCharArray();\n\n    File file = new File(\"jssecacerts\");\n    if (file.isFile() == false) {\n      char SEP = File.separatorChar;\n      File dir = new File(System.getProperty(\"java.home\") + SEP + \"lib\" + SEP + \"security\");\n      file = new File(dir, \"jssecacerts\");\n      if (file.isFile() == false) {\n        file = new File(dir, \"cacerts\");\n      }\n    }\n    System.out.println(\"Loading KeyStore \" + file + \"...\");\n    InputStream in = new FileInputStream(file);\n    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n    ks.load(in, passphrase);\n    in.close();\n\n    SSLContext context = SSLContext.getInstance(\"TLS\");\n    TrustManagerFactory tmf =\n        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    tmf.init(ks);\n    X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0];\n    SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);\n    context.init(null, new TrustManager[] {tm}, null);\n    SSLSocketFactory factory = context.getSocketFactory();\n\n    System.out.println(\"Opening connection to \" + host + \":\" + port + \"...\");\n    SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n    socket.setSoTimeout(10000);\n    try {\n      System.out.println(\"Starting SSL handshake...\");\n      socket.startHandshake();\n      socket.close();\n      System.out.println();\n      System.out.println(\"No errors, certificate is already trusted\");\n    } catch (SSLException e) {\n      System.out.println();\n      e.printStackTrace(System.out);\n    }\n\n    X509Certificate[] chain = tm.chain;\n    if (chain == null) {\n      System.out.println(\"Could not obtain server certificate chain\");\n      return;\n    }\n\n    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n    System.out.println();\n    System.out.println(\"Server sent \" + chain.length + \" certificate(s):\");\n    System.out.println();\n    MessageDigest sha1 = MessageDigest.getInstance(\"SHA1\");\n    MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n    for (int i = 0; i < chain.length; i++) {\n      X509Certificate cert = chain[i];\n      System.out.println(\" \" + (i + 1) + \" Subject \" + cert.getSubjectDN());\n      System.out.println(\" Issuer \" + cert.getIssuerDN());\n      sha1.update(cert.getEncoded());\n      System.out.println(\" sha1 \" + toHexString(sha1.digest()));\n      md5.update(cert.getEncoded());\n      System.out.println(\" md5 \" + toHexString(md5.digest()));\n      System.out.println();\n    }\n\n    int n =\n        JOptionPane.showConfirmDialog(\n            null, \"add certificate to trusted keystore?\", \"Question\", JOptionPane.YES_NO_OPTION);\n\n    if (n != 0) return;\n\n    X509Certificate cert = chain[n];\n    String alias = host;\n    ks.setCertificateEntry(alias, cert);\n\n    OutputStream out = new FileOutputStream(\"jssecacerts\");\n    ks.store(out, passphrase);\n    out.close();\n\n    System.out.println();\n    System.out.println(cert);\n    System.out.println();\n    System.out.println(\"Added certificate to keystore 'jssecacerts' using alias '\" + alias + \"'\");\n  }\n"}, {"dataset": "digest", "exampleID": 5875, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [98], "initializationEnd": [130], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [136], "configurationEnd": [161], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 186, "focalAPIEnd": 197, "followUpCheck": "i < result.length", "checkType": "LOOP", "followUpCheckExpressionStart": 293, "followUpCheckExpressionEnd": 334, "followUpCheckBlockStart": 293, "followUpCheckBlockEnd": 424, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/communicationfreedom/cffreedom-utils/tree/master/src/main/java/com/cffreedom/utils/Convert.java", "rawCode": "  public static String toMd5(String val) throws NoSuchAlgorithmException {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    md.update(val.getBytes());\n\n    byte byteData[] = md.digest();\n\n    // convert the byte to hex format method 1\n    StringBuffer sb = new StringBuffer();\n    for (int i = 0; i < byteData.length; i++) {\n      sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n    }\n\n    logger.debug(\"Digest(in hex format):: {}\", sb.toString());\n\n    // convert the byte to hex format method 2\n    StringBuffer hexString = new StringBuffer();\n    for (int i = 0; i < byteData.length; i++) {\n      String hex = Integer.toHexString(0xff & byteData[i]);\n      if (hex.length() == 1) hexString.append('0');\n      hexString.append(hex);\n    }\n\n    return hexString.toString();\n  }\n"}, {"dataset": "digest", "exampleID": 5876, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [520], "initializationEnd": [552], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [832, 866], "configurationEnd": [858, 898], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 924, "focalAPIEnd": 935, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(result)"], "useStart": [961], "useEnd": [981], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Top-Q/jsystem/tree/master/jsystem-core-projects/jsystemAgent/src/main/java/jsystem/runner/projectsync/MD5Calculator.java", "rawCode": "  /**\n   * Calculates scenario MD5.<br>\n   * The method was added to support special treatment to current scenario: When calculating project\n   * MD5, I want to ignore tests selections.<br>\n   * Regular file MD5 calculation will calculate also selection, so to workaround it, I load the\n   * scenario and calculate the MD5 of each test, and ignore selection.\n   *\n   * <p>TODO method is not operational yet.\n   */\n  private static String calculateScenarioMD5(Scenario scenario) throws Exception {\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    Vector<JTest> allTests = scenario.getTests();\n    for (JTest t : allTests) {\n      String name = t.getTestName() + t.getTestId();\n      String parameters = \"\";\n      if (t instanceof RunnerTest) {\n        parameters = ((RunnerTest) t).getPropertiesAsString();\n      }\n      md.update(name.getBytes());\n      md.update(parameters.getBytes());\n    }\n    byte[] hash = md.digest();\n    BigInteger result = new BigInteger(hash);\n    String rc = result.toString(16);\n    return rc;\n  }\n"}, {"dataset": "digest", "exampleID": 5877, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [118], "initializationEnd": [152], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(String)", "messageDigest.update(byte[])"], "configurationStart": [160, 181, 224, 260], "configurationEnd": [173, 216, 252, 290], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 477, "focalAPIEnd": 491, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(int,result)"], "useStart": [459], "useEnd": [492], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mjibson/goread-android/tree/master/goread/src/main/java/com/goread/goreader/GoRead.java", "rawCode": "  public static String hashStory(String feed, String story) {\n    MessageDigest cript = null;\n    try {\n      cript = MessageDigest.getInstance(\"SHA-1\");\n      cript.reset();\n      cript.update(feed.getBytes(\"utf8\"));\n      cript.update(\"|\".getBytes());\n      cript.update(story.getBytes());\n    } catch (NoSuchAlgorithmException e) {\n      e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    }\n    String sha = new BigInteger(1, cript.digest()).toString(16);\n    return sha;\n  }\n"}, {"dataset": "digest", "exampleID": 5878, "initialization": ["MessageDigest messageDigest = ThreadLocal<MessageDigest>.get()"], "initializationStart": [240], "initializationEnd": [249], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[])"], "configurationStart": [255, 272], "configurationEnd": [266, 298], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 318, "focalAPIEnd": 330, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gwhalin/Memcached-Java-Client/tree/master/src/com/meetup/memcached/SockIOPool.java", "rawCode": "  /**\n   * Internal private hashing method.\n   *\n   * <p>MD5 based hash algorithm for use in the consistent hashing approach.\n   *\n   * @param key\n   * @return\n   */\n  private static long md5HashingAlg(String key) {\n    MessageDigest md5 = MD5.get();\n    md5.reset();\n    md5.update(key.getBytes());\n    byte[] bKey = md5.digest();\n    long res =\n        ((long) (bKey[3] & 0xFF) << 24)\n            | ((long) (bKey[2] & 0xFF) << 16)\n            | ((long) (bKey[1] & 0xFF) << 8)\n            | (long) (bKey[0] & 0xFF);\n    return res;\n  }\n"}, {"dataset": "digest", "exampleID": 5879, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [96], "initializationEnd": [128], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 54, "tryExpressionEnd": 58, "tryBlockStart": 54, "tryBlockEnd": 430, "catchExpressionStart": 230, "catchExpressionEnd": 265, "catchBlockStart": 230, "catchBlockEnd": 346, "exceptionHandlingCallStart": [316], "exceptionHandlingCallEnd": [339], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [136], "configurationEnd": [185], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 200, "focalAPIEnd": 222, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.13/kernel-impl/src/main/java/org/sakaiproject/user/impl/AuthenticationCache.java", "rawCode": "  private byte[] getEncrypted(String plaintext) {\n    try {\n      MessageDigest messageDigest = MessageDigest.getInstance(\"SHA\");\n      messageDigest.update(plaintext.getBytes(\"UTF-8\"));\n      return messageDigest.digest();\n    } catch (NoSuchAlgorithmException e) {\n      // This seems highly unlikely.\n      throw new RuntimeException(e);\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5880, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[],int,int)"], "configurationStart": [93, 115], "configurationEnd": [103, 145], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 179, "focalAPIEnd": 190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["decodeInt32(result,int)"], "useStart": [164], "useEnd": [194], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chalstrick/jgit/tree/master/org.eclipse.jgit.pgm/src/org/eclipse/jgit/pgm/debug/TextHashFunctions.java", "rawCode": "        @Override\n        protected int hashRegion(byte[] raw, int ptr, int end) {\n          md.reset();\n          md.update(raw, ptr, end - ptr);\n          return NB.decodeInt32(md.digest(), 0);\n        }\n"}, {"dataset": "digest", "exampleID": 5881, "initialization": ["byte[] input = String.getBytes()"], "initializationStart": [72], "initializationEnd": [89], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 117, "focalAPIEnd": 138, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["hexString(result)"], "useStart": [152], "useEnd": [183], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sunriver/projects/tree/master/android/eoecn/src/cn/eoe/app/utils/MD5.java", "rawCode": "  public static final String encode(String source) {\n    byte[] btyes = source.getBytes();\n    byte[] encodedBytes = sDigest.digest(btyes);\n\n    return Utility.hexString(encodedBytes);\n  }\n"}, {"dataset": "digest", "exampleID": 5882, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [222], "initializationEnd": [254], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 159, "tryExpressionEnd": 163, "tryBlockStart": 159, "tryBlockEnd": 506, "catchExpressionStart": 423, "catchExpressionEnd": 443, "catchBlockStart": 423, "catchBlockEnd": 506, "exceptionHandlingCallStart": [452], "exceptionHandlingCallEnd": [479], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [315], "configurationEnd": [345], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 401, "focalAPIEnd": 413, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toHexString(result)"], "useStart": [389], "useEnd": [414], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/source3g/hermes/tree/master/hermes/hermes-common/src/main/java/com/source3g/hermes/utils/MD5.java", "rawCode": "  public static String md5sum(String filename) {\n\n    InputStream fis;\n\n    byte[] buffer = new byte[1024];\n\n    int numRead = 0;\n\n    MessageDigest md5;\n\n    try {\n\n      fis = new FileInputStream(filename);\n\n      md5 = MessageDigest.getInstance(\"MD5\");\n\n      while ((numRead = fis.read(buffer)) > 0) {\n\n        md5.update(buffer, 0, numRead);\n      }\n\n      fis.close();\n\n      return toHexString(md5.digest());\n\n    } catch (Exception e) {\n\n      System.out.println(\"error\");\n\n      return null;\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5883, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [158], "initializationEnd": [190], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 140, "tryExpressionEnd": 144, "tryBlockStart": 140, "tryBlockEnd": 1475, "catchExpressionStart": 1324, "catchExpressionEnd": 1359, "catchBlockStart": 1324, "catchBlockEnd": 1407, "exceptionHandlingCallStart": [1367], "exceptionHandlingCallEnd": [1400], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [990], "configurationEnd": [1027], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 1051, "focalAPIEnd": 1063, "followUpCheck": "j < result.length", "checkType": "LOOP", "followUpCheckExpressionStart": 1117, "followUpCheckExpressionEnd": 1155, "followUpCheckBlockStart": 1117, "followUpCheckBlockEnd": 1279, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ritzalam/red5/tree/master/src/org/red5/io/utils/RandomGUID.java", "rawCode": "  private void getRandomGUID(boolean secure) {\n    MessageDigest md5 = null;\n    StringBuilder sbValueBeforeMD5 = new StringBuilder();\n\n    try {\n      md5 = MessageDigest.getInstance(\"MD5\");\n      long time = System.currentTimeMillis();\n      long rand = 0;\n\n      if (secure) {\n        rand = mySecureRand.nextLong();\n      } else {\n        rand = myRand.nextLong();\n      }\n\n      // This StringBuffer can be a long as you need; the MD5\n      // hash will always return 128 bits. You can change\n      // the seed to include anything you want here.\n      // You could even stream a file through the MD5 making\n      // the odds of guessing it at least as great as that\n      // of guessing the contents of the file!\n      sbValueBeforeMD5.append(s_id);\n      sbValueBeforeMD5.append(':');\n      sbValueBeforeMD5.append(Long.toString(time));\n      sbValueBeforeMD5.append(':');\n      sbValueBeforeMD5.append(Long.toString(rand));\n\n      valueBeforeMD5 = sbValueBeforeMD5.toString();\n      md5.update(valueBeforeMD5.getBytes());\n\n      byte[] array = md5.digest();\n      StringBuilder sb = new StringBuilder();\n      for (int j = 0; j < array.length; ++j) {\n        int b = array[j] & 0xFF;\n        if (b < 0x10) sb.append('0');\n        sb.append(Integer.toHexString(b));\n      }\n\n      valueAfterMD5 = sb.toString();\n    } catch (NoSuchAlgorithmException e) {\n      System.out.println(\"Error: \" + e);\n    } catch (Exception e) {\n      System.out.println(\"Error:\" + e);\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5884, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [145], "initializationEnd": [179], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["idManager()", "createUuid()"], "tryExpressionStart": 127, "tryExpressionEnd": 131, "tryBlockStart": 127, "tryBlockEnd": 671, "catchExpressionStart": 436, "catchExpressionEnd": 471, "catchBlockStart": 436, "catchBlockEnd": 580, "exceptionHandlingCallStart": [549, 549], "exceptionHandlingCallEnd": [560, 573], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [188, 207, 264, 295, 360], "configurationEnd": [199, 256, 287, 352, 376], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 415, "focalAPIEnd": 427, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteArrayToHexStr(result)"], "useStart": [397], "useEnd": [428], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta02/kernel-impl/src/main/java/org/sakaiproject/tool/impl/SessionComponent.java", "rawCode": "  public String makeSessionId(HttpServletRequest req, Principal principal) {\n    MessageDigest sha;\n    String sessionId;\n\n    try {\n      sha = MessageDigest.getInstance(\"SHA-1\");\n\n      sha.reset();\n      sha.update(principal.getName().getBytes(\"UTF-8\"));\n      sha.update((byte) 0x0a);\n      sha.update(req.getHeader(\"user-agent\").getBytes(\"UTF-8\"));\n      sha.update(salt);\n\n      sessionId = byteArrayToHexStr(sha.digest());\n    } catch (NoSuchAlgorithmException e) {\n      // Fallback to new uuid rather than a non-hashed id\n      sessionId = idManager().createUuid();\n    } catch (UnsupportedEncodingException e) {\n      sessionId = idManager().createUuid();\n    }\n\n    return sessionId;\n  }\n"}, {"dataset": "digest", "exampleID": 5885, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [90], "initializationEnd": [124], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 73, "tryExpressionEnd": 77, "tryBlockStart": 73, "tryBlockEnd": 263, "catchExpressionStart": 184, "catchExpressionEnd": 219, "catchBlockStart": 184, "catchBlockEnd": 263, "exceptionHandlingCallStart": [233], "exceptionHandlingCallEnd": [256], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 160, "focalAPIEnd": 175, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["convertBytesToString(result)"], "useStart": [139], "useEnd": [176], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ferquies/2dam/tree/master/AD/Tema 2/h2/src/tools/org/h2/dev/util/Migrate.java", "rawCode": "  private static String getSHA1(byte[] data) {\n    MessageDigest md;\n    try {\n      md = MessageDigest.getInstance(\"SHA-1\");\n      return convertBytesToString(md.digest(data));\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5886, "initialization": ["MessageDigest messageDigest = newMessageDigest()"], "initializationStart": [98], "initializationEnd": [126], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 1294, "focalAPIEnd": 1307, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["write(result)"], "useStart": [1285], "useEnd": [1308], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/j16sdiz/egit-freenet/tree/master/org.spearce.jgit/src/org/spearce/jgit/dircache/DirCache.java", "rawCode": "  private void writeTo(final OutputStream os) throws IOException {\n    final MessageDigest foot = Constants.newMessageDigest();\n    final DigestOutputStream dos = new DigestOutputStream(os, foot);\n\n    // Write the header.\n    //\n    final byte[] tmp = new byte[128];\n    System.arraycopy(SIG_DIRC, 0, tmp, 0, SIG_DIRC.length);\n    NB.encodeInt32(tmp, 4, /* version */ 2);\n    NB.encodeInt32(tmp, 8, entryCnt);\n    dos.write(tmp, 0, 12);\n\n    // Write the individual file entries.\n    //\n    if (lastModified <= 0) {\n      // Write a new index, as no entries require smudging.\n      //\n      for (int i = 0; i < entryCnt; i++) sortedEntries[i].write(dos);\n    } else {\n      final int smudge_s = (int) (lastModified / 1000);\n      final int smudge_ns = ((int) (lastModified % 1000)) * 1000000;\n      for (int i = 0; i < entryCnt; i++) {\n        final DirCacheEntry e = sortedEntries[i];\n        if (e.mightBeRacilyClean(smudge_s, smudge_ns)) e.smudgeRacilyClean();\n        e.write(dos);\n      }\n    }\n\n    if (tree != null) {\n      final TemporaryBuffer bb = new TemporaryBuffer();\n      tree.write(tmp, bb);\n      bb.close();\n\n      NB.encodeInt32(tmp, 0, EXT_TREE);\n      NB.encodeInt32(tmp, 4, (int) bb.length());\n      dos.write(tmp, 0, 8);\n      bb.writeTo(dos, null);\n    }\n\n    os.write(foot.digest());\n    os.close();\n  }\n"}, {"dataset": "digest", "exampleID": 5887, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [145], "initializationEnd": [179], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["idManager()", "createUuid()"], "tryExpressionStart": 127, "tryExpressionEnd": 131, "tryBlockStart": 127, "tryBlockEnd": 727, "catchExpressionStart": 492, "catchExpressionEnd": 527, "catchBlockStart": 492, "catchBlockEnd": 636, "exceptionHandlingCallStart": [605, 605], "exceptionHandlingCallEnd": [616, 629], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [188, 207, 264, 368, 416], "configurationEnd": [199, 256, 287, 400, 432], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 471, "focalAPIEnd": 483, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteArrayToHexStr(result)"], "useStart": [453], "useEnd": [484], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0-rc08/kernel-impl/src/main/java/org/sakaiproject/tool/impl/SessionComponent.java", "rawCode": "  public String makeSessionId(HttpServletRequest req, Principal principal) {\n    MessageDigest sha;\n    String sessionId;\n\n    try {\n      sha = MessageDigest.getInstance(\"SHA-1\");\n\n      sha.reset();\n      sha.update(principal.getName().getBytes(\"UTF-8\"));\n      sha.update((byte) 0x0a);\n      String ua = req.getHeader(\"user-agent\");\n      if (ua != null) {\n        sha.update(ua.getBytes(\"UTF-8\"));\n      }\n      sha.update(salt);\n\n      sessionId = byteArrayToHexStr(sha.digest());\n    } catch (NoSuchAlgorithmException e) {\n      // Fallback to new uuid rather than a non-hashed id\n      sessionId = idManager().createUuid();\n    } catch (UnsupportedEncodingException e) {\n      sessionId = idManager().createUuid();\n    }\n\n    return sessionId;\n  }\n"}, {"dataset": "digest", "exampleID": 5888, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [206], "initializationEnd": [242], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 175, "tryExpressionEnd": 179, "tryBlockStart": 175, "tryBlockEnd": 644, "catchExpressionStart": 580, "catchExpressionEnd": 600, "catchBlockStart": 580, "catchBlockEnd": 644, "exceptionHandlingCallStart": [614], "exceptionHandlingCallEnd": [637], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [285], "configurationEnd": [317], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 341, "focalAPIEnd": 352, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["messageDigest.reset()", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.update(byte[])", "messageDigest.digest()"], "useStart": [363, 383, 423, 463, 523], "useEnd": [373, 413, 438, 493, 534], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seam/security/tree/master/impl/src/main/java/org/jboss/seam/security/management/PasswordHash.java", "rawCode": "  /** @deprecated Use PasswordHash.createPasswordKey() instead */\n  @Deprecated\n  public String generateSaltedHash(String password, String saltPhrase, String algorithm) {\n    try {\n      MessageDigest md = MessageDigest.getInstance(algorithm);\n\n      if (saltPhrase != null) {\n        md.update(saltPhrase.getBytes());\n        byte[] salt = md.digest();\n\n        md.reset();\n        md.update(password.getBytes());\n        md.update(salt);\n      } else {\n        md.update(password.getBytes());\n      }\n\n      byte[] raw = md.digest();\n      return Base64.encodeBytes(raw);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5889, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [168], "initializationEnd": [200], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["getMessage()", "e(String,*)"], "tryExpressionStart": 137, "tryExpressionEnd": 141, "tryBlockStart": 137, "tryBlockEnd": 668, "catchExpressionStart": 571, "catchExpressionEnd": 606, "catchBlockStart": 571, "catchBlockEnd": 668, "exceptionHandlingCallStart": [627, 614], "exceptionHandlingCallEnd": [641, 642], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null)", "guardType": "IF {", "guardExpressionStart": 54, "guardExpressionEnd": 72, "guardBlockStart": 54, "guardBlockEnd": 131, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 231, "focalAPIEnd": 247, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BigInteger(int,result)"], "useStart": [275], "useEnd": [307], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nloko/SyncMyPix/tree/master/src/com/nloko/android/Utils.java", "rawCode": "  public static String getMd5Hash(byte[] input) {\n    if (input == null) {\n      throw new IllegalArgumentException(\"input\");\n    }\n\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n      byte[] messageDigest = md.digest(input);\n      BigInteger number = new BigInteger(1, messageDigest);\n      // String md5 = number.toString(16);\n      StringBuffer md5 = new StringBuffer();\n      md5.append(number.toString(16));\n\n      while (md5.length() < 32) {\n        // md5 = \"0\" + md5;\n        md5.insert(0, \"0\");\n      }\n\n      return md5.toString();\n    } catch (NoSuchAlgorithmException e) {\n      Log.e(\"MD5\", e.getMessage());\n      return null;\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5890, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [172], "initializationEnd": [206], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest(input)", "focalAPIStart": 218, "focalAPIEnd": 233, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["copyOfRange(result,Integer,Integer)"], "useStart": [300], "useEnd": [348], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/citrixsystems/pathweaver/tree/master/services/loadbalancing/lb-common/src/main/java/org/daylight/pathweaver/common/crypto/HashUtil.java", "rawCode": "  public static byte[] sha1sum(byte[] data, Integer startIdxInc, Integer stopIdxExc)\n      throws NoSuchAlgorithmException {\n    byte[] out;\n    MessageDigest md;\n    md = MessageDigest.getInstance(\"SHA-1\");\n    out = md.digest(data);\n    if (startIdxInc != null && stopIdxExc != null) {\n      out = Arrays.copyOfRange(out, startIdxInc, stopIdxExc);\n    }\n    return out;\n  }\n"}, {"dataset": "digest", "exampleID": 5891, "initialization": ["MessageDigest messageDigest = getInstance(*)"], "initializationStart": [2267], "initializationEnd": [2306], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new DTFException(String,*)"], "tryExpressionStart": 1962, "tryExpressionEnd": 1966, "tryBlockStart": 1962, "tryBlockEnd": 3218, "catchExpressionStart": 3006, "catchExpressionEnd": 3028, "catchBlockStart": 3006, "catchBlockEnd": 3105, "exceptionHandlingCallStart": [3044], "exceptionHandlingCallEnd": [3096], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [2641], "configurationEnd": [2667], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 2898, "focalAPIEnd": 2909, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["convertToHex(result)"], "useStart": [2876], "useEnd": [2910], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rlgomes/dtf/tree/master/src/java/com/yahoo/dtf/actions/http/ApacheHttpOp.java", "rawCode": "  protected void attachResponseBody(HttpBase op, HttpMethodBase method, Event event)\n      throws DTFException {\n    if (!op.isPerfrun()) {\n      DTFInputStream dtfis = (DTFInputStream) Action.getContext(HTTP_DTFIS_CTX);\n      if (dtfis != null) {\n        Action.unRegisterContext(HTTP_DTFIS_CTX);\n        event.addAttribute(HttpBase.HTTP_EVENT_DATA, dtfis.getData());\n      }\n\n      /*\n       * Not using the getResponseAsString because the HttpClient will\n       * generate some warnings in the logs about inefficiency of such\n       * a thing.\n       */\n      try {\n        InputStream is = method.getResponseBodyAsStream();\n\n        if (op.getBandwidth() != null) is = Throttler.wrapInputStream(is, op.getBandwidth());\n\n        String charset = method.getResponseCharSet();\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        // getResponseBodyAsStream returns null when there was an error\n        // previously.\n        int totalRead = 0;\n        if (is != null) {\n          int read = 0;\n          byte[] buffer = new byte[4 * 1024];\n          while ((read = is.read(buffer)) != -1) {\n            baos.write(buffer, 0, read);\n            totalRead += read;\n          }\n        }\n\n        event.addAttribute(HttpBase.HTTP_EVENT_BODY, baos.toString(charset));\n        event.addAttribute(HttpBase.HTTP_EVENT_BODY_SIZE, totalRead);\n      } catch (IOException e) {\n        throw new DTFException(\"Error handling output stream.\", e);\n      }\n    } else {\n      /*\n       * get the hash that was calculated previously and attach to http\n       * event.\n       */\n      DTFInputStream dtfis = (DTFInputStream) Action.getContext(HTTP_DTFIS_CTX);\n      if (dtfis != null && !op.getHash().equals(\"none\")) {\n        event.addAttribute(HttpBase.HTTP_EVENT_DATA_HASH, dtfis.getHash());\n      }\n      Action.unRegisterContext(HTTP_DTFIS_CTX);\n\n      // performance run we don't save the data but instead just the\n      // sha1 of the object.\n      try {\n        InputStream is = method.getResponseBodyAsStream();\n\n        if (op.getBandwidth() != null) is = Throttler.wrapInputStream(is, op.getBandwidth());\n\n        MessageDigest md = null;\n        boolean calchash = false;\n        if (op.isPerfrun() && !op.getHash().equals(\"none\")) {\n          md = MessageDigest.getInstance(op.getHash());\n          calchash = true;\n        }\n\n        // getResponseBodyAsStream returns null when there was an error\n        // previously.\n        int totalRead = 0;\n        if (is != null) {\n          int read = 0;\n          byte[] buffer = new byte[4 * 1024];\n          while ((read = is.read(buffer)) != -1) {\n            if (calchash) md.update(buffer, 0, read);\n            totalRead += read;\n          }\n        }\n        event.addAttribute(HttpBase.HTTP_EVENT_BODY_SIZE, totalRead);\n        if (calchash) {\n          event.addAttribute(HttpBase.HTTP_EVENT_BODY_HASH, HashUtil.convertToHex(md.digest()));\n          event.addAttribute(HttpBase.HTTP_EVENT_HASH_ALGO, op.getHash());\n        }\n      } catch (IOException e) {\n        throw new DTFException(\"Error handling output stream.\", e);\n      } catch (NoSuchAlgorithmException e) {\n        throw new DTFException(\"Error handling output stream.\", e);\n      }\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5892, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.reset()", "messageDigest.update(byte[],int,int)", "messageDigest.update(byte[],int,int)"], "configurationStart": [704, 728, 1143], "configurationEnd": [722, 761, 1171], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 1383, "focalAPIEnd": 1402, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["RandomAccessFile.write(result)"], "useStart": [1408], "useEnd": [1431], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/j16sdiz/egit-freenet/tree/master/org.spearce.jgit/src/org/spearce/jgit/transport/IndexPack.java", "rawCode": "  private void fixHeaderFooter(final byte[] origcsum, final byte[] tailcsum) throws IOException {\n    final MessageDigest origDigest = Constants.newMessageDigest();\n    final MessageDigest tailDigest = Constants.newMessageDigest();\n    long origRemaining = originalEOF;\n\n    packOut.seek(0);\n    bAvail = 0;\n    bOffset = 0;\n    fillFromFile(12);\n\n    {\n      final int origCnt = (int) Math.min(bAvail, origRemaining);\n      origDigest.update(buf, 0, origCnt);\n      origRemaining -= origCnt;\n      if (origRemaining == 0) tailDigest.update(buf, origCnt, bAvail - origCnt);\n    }\n\n    NB.encodeInt32(buf, 8, entryCount);\n    packOut.seek(0);\n    packOut.write(buf, 0, 12);\n    packOut.seek(bAvail);\n\n    packDigest.reset();\n    packDigest.update(buf, 0, bAvail);\n    for (; ; ) {\n      final int n = packOut.read(buf);\n      if (n < 0) break;\n      if (origRemaining != 0) {\n        final int origCnt = (int) Math.min(n, origRemaining);\n        origDigest.update(buf, 0, origCnt);\n        origRemaining -= origCnt;\n        if (origRemaining == 0) tailDigest.update(buf, origCnt, n - origCnt);\n      } else tailDigest.update(buf, 0, n);\n\n      packDigest.update(buf, 0, n);\n    }\n\n    if (!Arrays.equals(origDigest.digest(), origcsum)\n        || !Arrays.equals(tailDigest.digest(), tailcsum))\n      throw new IOException(\"Pack corrupted while writing to filesystem\");\n\n    packcsum = packDigest.digest();\n    packOut.write(packcsum);\n  }\n"}, {"dataset": "digest", "exampleID": 5893, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 92, "focalAPIEnd": 111, "followUpCheck": "!Arrays.equals(result,srcHash)", "checkType": "IF", "followUpCheckExpressionStart": 866, "followUpCheckExpressionEnd": 903, "followUpCheckBlockStart": 866, "followUpCheckBlockEnd": 998, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SiteView/NEWECC9.2/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/transport/PackParser.java", "rawCode": "  private void readPackFooter() throws IOException {\n    sync();\n    final byte[] actHash = packDigest.digest();\n\n    final int c = fill(Source.INPUT, 20);\n    final byte[] srcHash = new byte[20];\n    System.arraycopy(buf, c, srcHash, 0, 20);\n    use(20);\n\n    if (bAvail != 0 && !expectDataAfterPackFooter)\n      throw new CorruptObjectException(\n          MessageFormat.format(\n              JGitText.get().expectedEOFReceived,\n              \"\\\\x\" + Integer.toHexString(buf[bOffset] & 0xff)));\n    if (isCheckEofAfterPackFooter()) {\n      int eof = in.read();\n      if (0 <= eof)\n        throw new CorruptObjectException(\n            MessageFormat.format(\n                JGitText.get().expectedEOFReceived, \"\\\\x\" + Integer.toHexString(eof)));\n    } else if (bAvail > 0 && expectDataAfterPackFooter) {\n      in.reset();\n      IO.skipFully(in, bOffset);\n    }\n\n    if (!Arrays.equals(actHash, srcHash))\n      throw new CorruptObjectException(JGitText.get().corruptObjectPackfileChecksumIncorrect);\n\n    onPackFooter(srcHash);\n  }\n"}, {"dataset": "digest", "exampleID": 5894, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [106], "initializationEnd": [142], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [148], "configurationEnd": [182], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 215, "focalAPIEnd": 226, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["byteArray2HexString(result)"], "useStart": [195], "useEnd": [227], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mediashelf/fedora-client/tree/master/fedora-client-core/src/main/java/com/yourmediashelf/fedora/util/ChecksumUtility.java", "rawCode": "  public static String checksum(String algorithm, String input) throws Exception {\n    MessageDigest md = MessageDigest.getInstance(algorithm);\n    md.update(input.getBytes(\"UTF-8\"));\n    return byteArray2HexString(md.digest());\n  }\n"}, {"dataset": "digest", "exampleID": 5895, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 41, "focalAPIEnd": 56, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mlundblad/bc-java/tree/master/pg/src/main/java/org/bouncycastle/openpgp/operator/jcajce/SHA1PGPDigestCalculator.java", "rawCode": "  public byte[] getDigest() {\n    return digest.digest();\n  }\n"}, {"dataset": "digest", "exampleID": 5896, "initialization": ["MessageDigest messageDigest = newMD5()"], "initializationStart": [92], "initializationEnd": [100], "hasTryCatch": 1, "exceptionType": "UnsupportedEncodingException", "exceptionHandlingCall": ["new RuntimeException(String,*)"], "tryExpressionStart": 61, "tryExpressionEnd": 65, "tryBlockStart": 61, "tryBlockEnd": 368, "catchExpressionStart": 253, "catchExpressionEnd": 292, "catchBlockStart": 253, "catchBlockEnd": 368, "exceptionHandlingCallStart": [306], "exceptionHandlingCallEnd": [361], "configuration": ["messageDigest.update(byte[])", "messageDigest.update(char)", "messageDigest.update(byte[])"], "configurationStart": [108, 151, 180], "configurationEnd": [143, 172, 213], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 233, "focalAPIEnd": 244, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["LHEX(result)"], "useStart": [228], "useEnd": [245], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gracefullife/gerrit/tree/master/gerrit-httpd/src/main/java/com/google/gerrit/httpd/ProjectDigestFilter.java", "rawCode": "  private static String KD(String secret, String data) {\n    try {\n      MessageDigest md = newMD5();\n      md.update(secret.getBytes(\"UTF-8\"));\n      md.update((byte) ':');\n      md.update(data.getBytes(\"UTF-8\"));\n      return LHEX(md.digest());\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"UTF-8 encoding not available\", e);\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5897, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [112], "initializationEnd": [144], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])", "messageDigest.update(byte[])"], "configurationStart": [226, 273], "configurationEnd": [263, 328], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 355, "focalAPIEnd": 367, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["md5ToString(result)"], "useStart": [383], "useEnd": [406], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ning/Arecibo/tree/master/aggregator/src/main/java/com/ning/arecibo/aggregator/dictionary/EventDictionary.java", "rawCode": "  private String getInputEventSignature(SortedMap<String, Class> typeMap) {\n    try {\n      MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n      for (SortedMap.Entry<String, Class> entry : typeMap.entrySet()) {\n        md5.update(entry.getKey().getBytes());\n        md5.update(entry.getValue().getSimpleName().getBytes());\n      }\n      byte[] d = md5.digest();\n\n      return UUIDUtil.md5ToString(d);\n    } catch (NoSuchAlgorithmException e) {\n      return null;\n    }\n  }\n"}, {"dataset": "digest", "exampleID": 5898, "initialization": ["MessageDigest messageDigest = newMD5()"], "initializationStart": [82], "initializationEnd": [90], "hasTryCatch": 1, "exceptionType": "UnsupportedEncodingException", "exceptionHandlingCall": ["new RuntimeException(String,*)"], "tryExpressionStart": 49, "tryExpressionEnd": 53, "tryBlockStart": 49, "tryBlockEnd": 296, "catchExpressionStart": 177, "catchExpressionEnd": 216, "catchBlockStart": 177, "catchBlockEnd": 296, "exceptionHandlingCallStart": [232], "exceptionHandlingCallEnd": [287], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [100], "configurationEnd": [133], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 155, "focalAPIEnd": 166, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["LHEX(result)"], "useStart": [150], "useEnd": [167], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iLuxo/jgit-clone/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/transport/HttpAuthMethod.java", "rawCode": "    private static String H(String data) {\n      try {\n        MessageDigest md = newMD5();\n        md.update(data.getBytes(\"UTF-8\"));\n        return LHEX(md.digest());\n      } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(\"UTF-8 encoding not available\", e);\n      }\n    }\n"}, {"dataset": "digest", "exampleID": 5899, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [126], "initializationEnd": [159], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[],int,int)"], "configurationStart": [288], "configurationEnd": [314], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 367, "focalAPIEnd": 378, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["arraycopy(result,int,byte[],int,*)"], "useStart": [350], "useEnd": [402], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/src/share/classes/com/sun/crypto/provider/DESedeWrapCipher.java", "rawCode": "  private static final byte[] getChecksum(byte[] in, int offset, int len) {\n    MessageDigest md = null;\n    try {\n      md = MessageDigest.getInstance(\"SHA1\");\n    } catch (NoSuchAlgorithmException nsae) {\n      throw new RuntimeException(\"SHA1 message digest not available\");\n    }\n    md.update(in, offset, len);\n    byte[] cks = new byte[8];\n    System.arraycopy(md.digest(), 0, cks, 0, cks.length);\n    return cks;\n  }\n"}, {"dataset": "digest", "exampleID": 5900, "initialization": ["MessageDigest messageDigest = getInstance(String)"], "initializationStart": [2412], "initializationEnd": [2445], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["messageDigest.update(byte[])"], "configurationStart": [2731], "configurationEnd": [2761], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "result = messageDigest.digest()", "focalAPIStart": 2811, "focalAPIEnd": 2824, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["toHexString(result)"], "useStart": [2799], "useEnd": [2825], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/caaers-docs/tree/master/archives/Phase-3/2.5-RC3/InstallCert.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    String host;\n    int port;\n    char[] passphrase;\n    if ((args.length == 1) || (args.length == 2)) {\n      String[] c = args[0].split(\":\");\n      host = c[0];\n      port = (c.length == 1) ? 443 : Integer.parseInt(c[1]);\n      String p = (args.length == 1) ? \"changeit\" : args[1];\n      passphrase = p.toCharArray();\n    } else {\n      System.out.println(\"Usage: java InstallCert <host>[:port] [passphrase]\");\n      return;\n    }\n\n    File file = new File(\"jssecacerts\");\n    if (file.isFile() == false) {\n      char SEP = File.separatorChar;\n      File dir = new File(System.getProperty(\"java.home\") + SEP + \"lib\" + SEP + \"security\");\n      file = new File(dir, \"jssecacerts\");\n      if (file.isFile() == false) {\n        file = new File(dir, \"cacerts\");\n      }\n    }\n    System.out.println(\"Loading KeyStore \" + file + \"...\");\n    InputStream in = new FileInputStream(file);\n    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n    ks.load(in, passphrase);\n    in.close();\n\n    SSLContext context = SSLContext.getInstance(\"TLS\");\n    TrustManagerFactory tmf =\n        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n    tmf.init(ks);\n    X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0];\n    SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);\n    context.init(null, new TrustManager[] {tm}, null);\n    SSLSocketFactory factory = context.getSocketFactory();\n\n    System.out.println(\"Opening connection to \" + host + \":\" + port + \"...\");\n    SSLSocket socket = (SSLSocket) factory.createSocket(host, port);\n    socket.setSoTimeout(10000);\n    try {\n      System.out.println(\"Starting SSL handshake...\");\n      socket.startHandshake();\n      socket.close();\n      System.out.println();\n      System.out.println(\"No errors, certificate is already trusted\");\n    } catch (SSLException e) {\n      System.out.println();\n      e.printStackTrace(System.out);\n    }\n\n    X509Certificate[] chain = tm.chain;\n    if (chain == null) {\n      System.out.println(\"Could not obtain server certificate chain\");\n      return;\n    }\n\n    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n    System.out.println();\n    System.out.println(\"Server sent \" + chain.length + \" certificate(s):\");\n    System.out.println();\n    MessageDigest sha1 = MessageDigest.getInstance(\"SHA1\");\n    MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n    for (int i = 0; i < chain.length; i++) {\n      X509Certificate cert = chain[i];\n      System.out.println(\" \" + (i + 1) + \" Subject \" + cert.getSubjectDN());\n      System.out.println(\" Issuer \" + cert.getIssuerDN());\n      sha1.update(cert.getEncoded());\n      System.out.println(\" sha1 \" + toHexString(sha1.digest()));\n      md5.update(cert.getEncoded());\n      System.out.println(\" md5 \" + toHexString(md5.digest()));\n      System.out.println();\n    }\n\n    System.out.println(\"Enter certificate to add to trusted keystore or 'q' to quit: [1]\");\n    String line = reader.readLine().trim();\n    int k;\n    try {\n      k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;\n    } catch (NumberFormatException e) {\n      System.out.println(\"KeyStore not changed\");\n      return;\n    }\n\n    X509Certificate cert = chain[k];\n    String alias = host + \"-\" + (k + 1);\n    ks.setCertificateEntry(alias, cert);\n\n    OutputStream out = new FileOutputStream(file);\n    ks.store(out, passphrase);\n    out.close();\n\n    System.out.println();\n    System.out.println(cert);\n    System.out.println();\n    System.out.println(\"Added certificate to keystore 'cacerts' using alias '\" + alias + \"'\");\n  }\n"}]