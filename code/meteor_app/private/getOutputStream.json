[{"dataset": "getOutputStream", "exampleID": 7901, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 1071, "focalAPIEnd": 1101, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamFilterTee(ConnectionDetails,outputStream,TCPProxyFilter,TerminalColour)", "socket.getInputStream()"], "useStart": [1013, 1178], "useEnd": [1136, 1207], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/elight/the_grinder/tree/master/grinder-http/src/main/java/net/grinder/tools/tcpproxy/AbstractTCPProxyEngine.java", "rawCode": "  /**\n   * Launch a pair of threads to handle bi-directional stream communication.\n   *\n   * @param localSocket Local socket.\n   * @param remoteSocket Remote socket.\n   * @param sourceEndPoint The local {@code EndPoint} to be used in the logging and filter output.\n   *     This may differ from the {@code localSocket} binding.\n   * @param targetEndPoint The remote {@code EndPoint} to be used in the logging and filter output.\n   *     This may differ from the {@code remoteSocket} binding. *\n   * @param isSecure Whether the connection is secure.\n   * @exception IOException If an I/O error occurs.\n   */\n  protected final void launchThreadPair(\n      Socket localSocket,\n      Socket remoteSocket,\n      EndPoint sourceEndPoint,\n      EndPoint targetEndPoint,\n      boolean isSecure)\n      throws IOException {\n\n    final ConnectionDetails connectionDetails =\n        new ConnectionDetails(sourceEndPoint, targetEndPoint, isSecure);\n\n    new FilteredStreamThread(\n        localSocket.getInputStream(),\n        new OutputStreamFilterTee(\n            connectionDetails, remoteSocket.getOutputStream(), m_requestFilter, m_requestColour));\n\n    new FilteredStreamThread(\n        remoteSocket.getInputStream(),\n        new OutputStreamFilterTee(\n            connectionDetails.getOtherEnd(),\n            localSocket.getOutputStream(),\n            m_responseFilter,\n            m_responseColour));\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7902, "initialization": ["Socket socket = new Socket(*,int)"], "initializationStart": [476], "initializationEnd": [527], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.getInputStream()"], "configurationStart": [754], "configurationEnd": [777], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 824, "focalAPIEnd": 848, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)", "socket.close()"], "useStart": [808, 1740], "useEnd": [855, 1754], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nloreti/ProtoProxyHTTP/tree/master/IlMarseProxy/src/main/java/filterManager/FilterManager.java", "rawCode": "  public static void main(String[] args) throws IOException {\n\n    // args\n    if (args.length != 2) // Test for correct # of\n    throw new IllegalArgumentException(\"Parameter(s): <Server> [<Port>]\");\n\n    // Server name or IP address\n    String server = args[0];\n\n    // Convert argument String to bytes using the default character encoding\n    int servPort = Integer.parseInt(args[1]);\n\n    // Create socket that is connected to server on specified port\n    Socket socket = new Socket(InetAddress.getByName(server), servPort);\n    System.out.println(\"Connected to server...\");\n\n    // InputStream in = socket.getInputStream();\n    // OutputStream out = socket.getOutputStream();\n    BufferedReader fromServer = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n    PrintWriter toServer = new PrintWriter(socket.getOutputStream(), true);\n    String curLine = \"\"; // Line read from standard in\n    System.out.println(\"Enter a line of text (type 'quit' to exit): \");\n    InputStreamReader converter = new InputStreamReader(System.in);\n    BufferedReader termIn = new BufferedReader(converter);\n    while (!curLine.equals(\"EXIT\")) {\n      curLine = termIn.readLine();\n      toServer.println(curLine);\n      // // Send the encoded string to the server\n      // out.write(curLine.getBytes(\"UTF-16LE\"));\n      //\n      // // Receive the response from the server\n      // byte[] data = new byte[50];\n      // // Bytes received in last read\n      // System.out.println(\"readin\");\n      // if (in.read(data) == -1)\n      // throw new SocketException(\"Connection closed prematurely\");\n      System.out.print(fromServer.readLine().replace('\\64', '\\n'));\n      System.out.println();\n    }\n    // Close the socket and its streams\n    socket.close();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7903, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 748, "focalAPIEnd": 783, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new MessageWriter(outputStream)", "socket.getInputStream()"], "useStart": [730, 1436], "useEnd": [784, 1470], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/htwg/UCE/tree/master/holepunching/src/main/java/de/fhkn/in/uce/holepunching/core/source/SourceConnectionAuthenticator.java", "rawCode": "  /**\n   * Authentication mechanism on the source side. It first sends an AuthenticationMessage. Then it\n   * waits for the AuthenticationAckMessage of the target. If AuthenticationAckMessage was positive\n   * it sends AuthenticationAckMessage to the target. If authentication is successful all hole\n   * punching threads get stopped.\n   */\n  @Override\n  public boolean authenticate(\n      final Socket toBeAuthenticated,\n      final Set<CancelableTask> relatedHolePunchingTasks,\n      final CancelableTask ownTask,\n      final Object sharedLock)\n      throws IOException {\n    boolean result = false;\n    logger.info(\"Trying to authenticate socket: {}\", toBeAuthenticated); // $NON-NLS-1$\n    final MessageWriter messageWriter = new MessageWriter(toBeAuthenticated.getOutputStream());\n    final MessageReader messageReader = this.hpUtil.getCustomHolePunchingMessageReader();\n    // sending authentication message\n    final Message authenticationMessage =\n        MessageStaticFactory.newSTUNMessageInstance(\n            STUNMessageClass.REQUEST, STUNMessageMethod.AUTHENTICATE);\n    authenticationMessage.addAttribute(new Token(this.authentikationToken));\n    logger.info(\"Sending AuthenticationMessage: {}\", authenticationMessage); // $NON-NLS-1$\n    messageWriter.writeMessage(authenticationMessage);\n    // receiving authentication acknowledgment message\n    final Message reveivedAckMessage =\n        messageReader.readSTUNMessage(toBeAuthenticated.getInputStream());\n    if (this.hpUtil.isAuthenticationAcknowledgmentMessage(reveivedAckMessage)) {\n      synchronized (sharedLock) {\n        // sending second authentication acknowledgment message\n        final Message secondAckMessage = reveivedAckMessage.buildSuccessResponse();\n        messageWriter.writeMessage(secondAckMessage);\n        logger.debug(\"Authentication successfull, stopping hole punching threads\"); // $NON-NLS-1$\n        this.hpUtil.stopCancableTasksExceptOwnTask(relatedHolePunchingTasks, ownTask);\n        result = true;\n      }\n    }\n    logger.debug(\"Authentication failed\"); // $NON-NLS-1$\n    return result;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7904, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [1113], "initializationEnd": [1141], "hasTryCatch": 1, "exceptionType": "ClassNotFoundException", "exceptionHandlingCall": ["new RemoteException(*)"], "tryExpressionStart": 343, "tryExpressionEnd": 347, "tryBlockStart": 343, "tryBlockEnd": 2212, "catchExpressionStart": 2006, "catchExpressionEnd": 2039, "catchBlockStart": 2006, "catchBlockEnd": 2082, "exceptionHandlingCallStart": [2053], "exceptionHandlingCallEnd": [2075], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 1193, "focalAPIEnd": 1215, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream)", "socket.getInputStream()", "socket.close()"], "useStart": [1168, 1531, 1838], "useEnd": [1216, 1552, 1850], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mnn/monnefcore/tree/master/src/main/java/monnef/core/external/javassist/tools/rmi/ObjectImporter.java", "rawCode": "  /**\n   * Calls a method on a remote object. It sends a POST request to the server (via an http proxy\n   * server if needed).\n   *\n   * <p>This method is called by only proxy objects.\n   */\n  public Object call(int objectid, int methodid, Object[] args) throws RemoteException {\n    boolean result;\n    Object rvalue;\n    String errmsg;\n\n    try {\n      /* This method establishes a raw tcp connection for sending\n       * a POST message. Thus the object cannot communicate a\n       * remote object beyond a fire wall. To avoid this problem,\n       * the connection should be established with a mechanism\n       * collaborating a proxy server. Unfortunately, java.lang.URL\n       * does not seem to provide such a mechanism.\n       *\n       * You might think that using HttpURLConnection is a better\n       * way than constructing a raw tcp connection. Unfortunately,\n       * URL.openConnection() does not return an HttpURLConnection\n       * object in Netscape's JVM. It returns a\n       * netscape.net.URLConnection object.\n       *\n       * lookupObject() has the same problem.\n       */\n      Socket sock = new Socket(servername, port);\n      OutputStream out = new BufferedOutputStream(sock.getOutputStream());\n      out.write(rmiCommand);\n      out.write(endofline);\n      out.write(endofline);\n\n      ObjectOutputStream dout = new ObjectOutputStream(out);\n      dout.writeInt(objectid);\n      dout.writeInt(methodid);\n      writeParameters(dout, args);\n      dout.flush();\n\n      InputStream ins = new BufferedInputStream(sock.getInputStream());\n      skipHeader(ins);\n      ObjectInputStream din = new ObjectInputStream(ins);\n      result = din.readBoolean();\n      rvalue = null;\n      errmsg = null;\n      if (result) rvalue = din.readObject();\n      else errmsg = din.readUTF();\n\n      din.close();\n      dout.close();\n      sock.close();\n\n      if (rvalue instanceof RemoteRef) {\n        RemoteRef ref = (RemoteRef) rvalue;\n        rvalue = createProxy(ref.oid, ref.classname);\n      }\n    } catch (ClassNotFoundException e) {\n      throw new RemoteException(e);\n    } catch (IOException e) {\n      throw new RemoteException(e);\n    } catch (Exception e) {\n      throw new RemoteException(e);\n    }\n\n    if (result) return rvalue;\n    else throw new RemoteException(errmsg);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7905, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 185, "focalAPIEnd": 204, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(byte[])", "outputStream.write(byte[])"], "useStart": [345, 379], "useEnd": [373, 399], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lemmy/dnsjava/tree/master/tags/dnsjava-1-6-6/org/xbill/DNS/SimpleResolver.java", "rawCode": "  private void writeTCP(Socket s, byte[] out) throws IOException {\n    if (Options.check(\"verbosemsg\")) System.err.println(hexdump.dump(\"TCP write\", out));\n    OutputStream outStream = s.getOutputStream();\n    byte[] lengthArray = new byte[2];\n    lengthArray[0] = (byte) (out.length >>> 8);\n    lengthArray[1] = (byte) (out.length & 0xFF);\n    outStream.write(lengthArray);\n    outStream.write(out);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7906, "initialization": ["Socket socket = new Socket(*,*)", "Socket socket = new Socket(*,int)"], "initializationStart": [394, 505], "initializationEnd": [465, 549], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 286, "tryExpressionEnd": 290, "tryBlockStart": 286, "tryBlockEnd": 1392, "catchExpressionStart": 1320, "catchExpressionEnd": 1341, "catchBlockStart": 1320, "catchBlockEnd": 1392, "exceptionHandlingCallStart": [1351], "exceptionHandlingCallEnd": [1383], "configuration": ["socket.close()", "socket.getInputStream()"], "configurationStart": [107, 677], "configurationEnd": [123, 702], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 765, "focalAPIEnd": 791, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)", "socket.getOutputStream()", "outputStream.write(*)", "socket.getOutputStream()", "outputStream.write(*)", "new PowerGenerator(int,socket)"], "useStart": [742, 1254, 1254, 1929, 1929, 2737], "useEnd": [792, 1280, 1309, 1955, 1984, 2775], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MitchJust/Kabouter/tree/master/kabouter-server/src/main/java/com/unicornlabs/kabouter/devices/test/TestDevice.java", "rawCode": "  public static void handleCommand(String command) {\n    if (command.equals(\"quit\")) {\n      try {\n        mySocket.close();\n        System.exit(0);\n      } catch (IOException ex) {\n        System.out.println(\"ex = \" + ex);\n      }\n    } else if (command.startsWith(\"connect\")) {\n      try {\n\n        String[] split = command.split(\" \");\n\n        if (split.length == 3) {\n\n          mySocket = new Socket(InetAddress.getByName(split[1]), Integer.parseInt(split[2]));\n        } else {\n          mySocket = new Socket(InetAddress.getLocalHost(), 4555);\n        }\n\n        System.out.println(\"Connection Established\");\n\n        socketin = new BufferedReader(new InputStreamReader(mySocket.getInputStream()));\n        socketout = new PrintWriter(new OutputStreamWriter(mySocket.getOutputStream()));\n\n        DeviceServerMessage newMessage = new DeviceServerMessage();\n\n        System.out.print(\"Device Id: \");\n        String devId = br.readLine();\n\n        newMessage.messageType = DeviceServerMessage.DEVICE_CONFIG;\n        newMessage.data = devId + \":KABOUTER_TEST_DEVICE\";\n\n        String jsonString = JSONUtils.ToJSON(newMessage);\n\n        System.out.println(\"Sending Config Message\");\n\n        System.out.println(\"jsonString = \" + jsonString);\n\n        mySocket.getOutputStream().write(jsonString.getBytes());\n\n      } catch (Exception ex) {\n        System.out.println(\"ex = \" + ex);\n      }\n    } else if (command.startsWith(\"changeio\")) {\n      try {\n        String[] split = command.split(\" \");\n        int newValue = Integer.parseInt(split[1]);\n\n        Integer[] newIo = new Integer[] {newValue, newValue};\n\n        DeviceServerMessage newMessage = new DeviceServerMessage();\n        newMessage.data = JSONUtils.ToJSON(newIo);\n        newMessage.messageType = DeviceServerMessage.IO_STATE_UPDATE;\n\n        String jsonString = JSONUtils.ToJSON(newMessage);\n\n        System.out.println(\"Sending IO Change Message\");\n\n        mySocket.getOutputStream().write(jsonString.getBytes());\n\n        String newIOMessage = socketin.readLine();\n\n        System.out.println(\"newIOMessage = \" + newIOMessage);\n        ServerDeviceMessage FromJSON = JSONUtils.FromJSON(newIOMessage, ServerDeviceMessage.class);\n        Integer[] newIOStates = JSONUtils.FromJSON(FromJSON.data, Integer[].class);\n\n        System.out.println(\"newIOStates = \" + newIOStates[0] + \", \" + newIOStates[1]);\n\n      } catch (IOException ex) {\n        System.out.println(\"ex = \" + ex);\n      } catch (com.google.gson.JsonSyntaxException jex) {\n        System.out.println(\"Exception: \" + jex);\n      }\n    } else if (command.startsWith(\"generatepower\")) {\n\n      String[] split = command.split(\" \");\n      int newValue = Integer.parseInt(split[1]);\n\n      myPowerGenerator = new PowerGenerator(newValue, mySocket);\n      myPowerGenerator.start();\n\n    } else if (command.startsWith(\"setbase\")) {\n\n      String[] split = command.split(\" \");\n      int newValue = Integer.parseInt(split[1]);\n\n      myPowerGenerator.setBaseLevel(newValue);\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7907, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [129], "initializationEnd": [164], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": [], "tryExpressionStart": 111, "tryExpressionEnd": 115, "tryBlockStart": 111, "tryBlockEnd": 631, "catchExpressionStart": 447, "catchExpressionEnd": 467, "catchBlockStart": 447, "catchBlockEnd": 493, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 290, "focalAPIEnd": 309, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream)", "socket.getInputStream()", "socket.close()"], "useStart": [265, 355, 557], "useEnd": [310, 373, 566], "hasFinally": 1, "cleanUpCall": ["Socket.close()"], "finallyExpressionStart": 494, "finallyExpressionEnd": 502, "finallyBlockStart": 494, "finallyBlockEnd": 631, "cleanUpCallStart": [557], "cleanUpCallEnd": [566], "url": "https://github.com/trendmicro/tme/tree/master/src/mist/src/com/trendmicro/mist/client/MistClient.java", "rawCode": "    private GateTalk.Command sendRequest(GateTalk.Command cmd) throws Exception {\n      Socket s = null;\n      try {\n        s = new Socket(\"127.0.0.1\", MISTD_PORT);\n        Packet pack = new Packet();\n        pack.setPayload(cmd.toByteArray());\n        pack.write(new BufferedOutputStream(s.getOutputStream()));\n        pack.read(new BufferedInputStream(s.getInputStream()));\n        return GateTalk.Command.parseFrom(pack.getPayload());\n      } catch (Exception e) {\n        throw e;\n      } finally {\n        if (s != null) {\n          try {\n            s.close();\n          } catch (Exception e) {\n          }\n        }\n      }\n    }\n"}, {"dataset": "getOutputStream", "exampleID": 7908, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.connect(SocketAddress)", "socket.getInputStream()"], "configurationStart": [55, 129], "configurationEnd": [98, 150], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 184, "focalAPIEnd": 206, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)"], "useStart": [163], "useEnd": [207], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sleuthkit/hadoop_framework/tree/master/core/src/main/java/com/lightboxtechnologies/spectrum/MRCoffeeClient.java", "rawCode": "  public void open(File pipe) throws IOException {\n    sock.connect(new AFUNIXSocketAddress(pipe));\n    in = new DataInputStream(sock.getInputStream());\n    out = new DataOutputStream(sock.getOutputStream());\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7909, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)", "Socket.close()"], "tryExpressionStart": 263, "tryExpressionEnd": 267, "tryBlockStart": 263, "tryBlockEnd": 1664, "catchExpressionStart": 1263, "catchExpressionEnd": 1285, "catchBlockStart": 1263, "catchBlockEnd": 1664, "exceptionHandlingCallStart": [1317, 1440], "exceptionHandlingCallEnd": [1373, 1461], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 309, "focalAPIEnd": 340, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)", "socket.getInputStream()", "socket.close()", "socket.close()"], "useStart": [293, 416, 1233, 1440], "useEnd": [347, 446, 1254, 1461], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openintents/sensorsimulator/tree/master/SensorSimulator/src/org/openintents/tools/simulator/SensorServerThread.java", "rawCode": "  /**\n   * Handles communication with the client.\n   *\n   * <p>In a simple protocol, all Android Sensors class methods are received and answered. If\n   * necessary, exceptions are thrown as specified in the Sensors class.\n   */\n  public void listenThread() {\n    try {\n      PrintWriter out = new PrintWriter(mClientSocket.getOutputStream(), true);\n      BufferedReader in = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream()));\n      String inputLine, outputLine;\n\n      outputLine = \"SensorSimulator\";\n      out.println(outputLine);\n\n      mSensorSimulator.addMessage(\"Incoming connection opened.\");\n\n      // here we treat different getSupportedSensors command from others\n      // (others have the name of the sensor in the input stream)\n      while ((inputLine = in.readLine()) != null) {\n        if (inputLine.compareTo(\"getSupportedSensors()\") == 0) {\n          String[] supportedSensors = getSupportedSensors();\n          out.println(supportedSensors.length);\n          for (int i = 0; i < supportedSensors.length; i++) {\n            out.println(supportedSensors[i]);\n          }\n        } else {\n          executeCommand(out, in, inputLine);\n        }\n      }\n      out.close();\n      in.close();\n      mClientSocket.close();\n\n    } catch (IOException e) {\n      if (mTalking) {\n        System.err.println(\"IOException in SensorServerThread.\");\n        try {\n          if (mClientSocket != null) {\n            mClientSocket.close();\n          }\n        } catch (IOException e2) {\n          System.err.println(\"Close failed as well.\");\n        }\n      } else {\n        // everything fine. Our mouth was shut deliberately.\n      }\n    }\n\n    // Here we finish program execution and we take ourselves out of the\n    // chained list:\n    if (mPreviousThread != null) {\n      mPreviousThread.mNextThread = mNextThread;\n    }\n    if (mNextThread != null) {\n      mNextThread.mPreviousThread = mPreviousThread;\n    }\n    mSensorSimulator.addMessage(\"Incoming connection closed.\");\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7910, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [355], "initializationEnd": [384], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getInetAddress()", "getHostAddress()", "safeLogging(String)", "BufferedWriter.close()"], "tryExpressionStart": 618, "tryExpressionEnd": 622, "tryBlockStart": 618, "tryBlockEnd": 1156, "catchExpressionStart": 720, "catchExpressionEnd": 744, "catchBlockStart": 720, "catchBlockEnd": 1156, "exceptionHandlingCallStart": [858, 858, 754, 960], "exceptionHandlingCallEnd": [885, 902, 903, 971], "configuration": ["socket.setSoTimeout(int)", "socket.getInputStream()"], "configurationStart": [392, 493], "configurationEnd": [424, 520], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 680, "focalAPIEnd": 708, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)"], "useStart": [657], "useEnd": [709], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Raphfrk/ServerPort/tree/master/com/raphfrk/bukkit/serverport/ServerPortClient.java", "rawCode": "  String connect() {\n\n    if (!isValid) {\n      if (peerServerName == null) {\n        return \"no peer server name provided\";\n      } else {\n        return \"unknown target server \\\"\" + peerServerName + \"\\\"\";\n      }\n    }\n\n    if (portnum <= 0) {\n      return \"Port number for \" + peerServerName + \" not set correctly\";\n    }\n\n    try {\n      connection = new Socket(hostname, portnum);\n      connection.setSoTimeout(timeout);\n\n      try {\n        in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n      } catch (IOException e1) {\n        return \"Unable to open input stream\";\n      }\n\n      try {\n        out = new BufferedWriter(new OutputStreamWriter(connection.getOutputStream()));\n      } catch (IOException ioe) {\n        MiscUtils.safeLogging(\n            \"[ServerPort] Unable to open out connection from \"\n                + connection.getInetAddress().getHostAddress());\n        try {\n          if (out != null) {\n            out.close();\n          }\n        } catch (IOException e) {\n          MiscUtils.safeLogging(\"[ServerPort] Connection close failed\");\n        }\n        return \"Unable to open output stream\";\n      }\n\n      return null;\n\n    } catch (SocketException skt) {\n\n      if (skt.getLocalizedMessage().equals(\"Connection refused: connect\")) {\n        return \"Target server port number not open\";\n      } else {\n        return \"Request timed out when trying to connect\";\n      }\n    } catch (IOException ioe) {\n      return \"IO error \";\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7911, "initialization": ["Socket socket = ServerSocket.accept()"], "initializationStart": [163], "initializationEnd": [182], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 30, "tryExpressionEnd": 34, "tryBlockStart": 30, "tryBlockEnd": 562, "catchExpressionStart": 504, "catchExpressionEnd": 524, "catchBlockStart": 504, "catchBlockEnd": 562, "exceptionHandlingCallStart": [534], "exceptionHandlingCallEnd": [553], "configuration": ["socket.getInputStream()"], "configurationStart": [268], "configurationEnd": [288], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 377, "focalAPIEnd": 398, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new ObjectOutputStream(outputStream)"], "useStart": [419], "useEnd": [452], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/darrinwillis/distributedSystems/tree/master/lab2/src/ProxyDispatcher.java", "rawCode": "    public void run() {\n      try {\n        ServerSocket serverSock = new ServerSocket(pd.port, pd.BACKLOG, pd.adr);\n        while (true) {\n          Socket soc = serverSock.accept();\n          System.out.println(\"client connected\");\n\n          InputStream inStream = soc.getInputStream();\n          pd.in = new ObjectInputStream(inStream);\n\n          OutputStream outStream = soc.getOutputStream();\n          pd.out = new ObjectOutputStream(outStream);\n\n          pd.executeMessage();\n        }\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n"}, {"dataset": "getOutputStream", "exampleID": 7912, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getStackTrace()", "println(*)"], "tryExpressionStart": 39, "tryExpressionEnd": 43, "tryBlockStart": 39, "tryBlockEnd": 1042, "catchExpressionStart": 970, "catchExpressionEnd": 990, "catchBlockStart": 970, "catchBlockEnd": 1042, "exceptionHandlingCallStart": [1017, 998], "exceptionHandlingCallEnd": [1034, 1035], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 223, "focalAPIEnd": 247, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(int)", "socket.getOutputStream()", "outputStream.write(int)", "socket.getInputStream()", "socket.getInputStream()", "socket.getOutputStream()", "outputStream.write(int)", "socket.getOutputStream()", "outputStream.write(int)", "socket.getInputStream()"], "useStart": [223, 268, 268, 328, 396, 542, 542, 589, 589, 785], "useEnd": [256, 292, 301, 351, 419, 566, 575, 613, 622, 808], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dntoll/robot/tree/master/Trilateration/src/daniel/IPSerialPort.java", "rawCode": "  @Override\n  public void run() {\n\n    try {\n      int d;\n      while (true) {\n\n        String buffer = this.writeBuffer.read();\n        for (int i = 0; i < buffer.length(); i++) {\n          d = buffer.charAt(i);\n          server.getOutputStream().write(1);\n          server.getOutputStream().write(d);\n        }\n        while (server.getInputStream().available() > 1) {\n          int protocol = server.getInputStream().read();\n          if (protocol == 0) {\n            server.getInputStream().read();\n\n            // keep alive\n            server.getOutputStream().write(0);\n            server.getOutputStream().write(0);\n            // System.out.println(\"Keep alive sent to \" + server.getPort());\n          } else {\n            // System.out.println(\"got a byte\");\n            d = server.getInputStream().read();\n            // System.out.write((byte)d);\n            this.readBuffer.write((byte) d);\n          }\n        }\n        Thread.sleep(0, 100);\n      }\n    } catch (Exception e) {\n      System.err.println(e.getStackTrace());\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7913, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "socket!=null", "guardType": "IF {", "guardExpressionStart": 632, "guardExpressionEnd": 655, "guardBlockStart": 632, "guardBlockEnd": 970, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 678, "focalAPIEnd": 706, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(char)", "socket.getOutputStream()", "outputStream.flush()", "socket.getInputStream()", "socket.getOutputStream()", "outputStream.close()", "socket.close()"], "useStart": [678, 728, 728, 774, 819, 819, 865], "useEnd": [718, 756, 764, 801, 847, 855, 883], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vanzin/jEdit/tree/master/org/gjt/sp/jedit/View.java", "rawCode": "  void close() {\n    EditBus.send(new ViewUpdate(this, ViewUpdate.CLOSED));\n    closed = true;\n\n    // save dockable window geometry, and close 'em\n    dockableWindowManager.close();\n\n    EditBus.removeFromBus(this);\n    dispose();\n\n    EditPane[] editPanes = getEditPanes();\n    for (EditPane ep : editPanes) ep.close();\n\n    // null some variables so that retaining references\n    // to closed views won't hurt as much.\n    toolBarManager = null;\n    toolBar = null;\n    searchBar = null;\n    splitPane = null;\n    inputHandler = null;\n    recorder = null;\n\n    getContentPane().removeAll();\n\n    // notify clients with -wait\n    if (waitSocket != null) {\n      try {\n        waitSocket.getOutputStream().write('\\0');\n        waitSocket.getOutputStream().flush();\n        waitSocket.getInputStream().close();\n        waitSocket.getOutputStream().close();\n        waitSocket.close();\n      } catch (IOException io) {\n        // Log.log(Log.ERROR,this,io);\n      }\n    }\n  } // }}}\n"}, {"dataset": "getOutputStream", "exampleID": 7914, "initialization": ["Socket socket = new Socket(InetAddress,*,*,int)"], "initializationStart": [341], "initializationEnd": [449], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["trace(String,*)"], "tryExpressionStart": 254, "tryExpressionEnd": 258, "tryBlockStart": 254, "tryBlockEnd": 942, "catchExpressionStart": 648, "catchExpressionEnd": 670, "catchBlockStart": 648, "catchBlockEnd": 942, "exceptionHandlingCallStart": [732], "exceptionHandlingCallEnd": [783], "configuration": ["socket.setKeepAlive(boolean)", "socket.setTcpNoDelay(boolean)"], "configurationStart": [459, 494], "configurationEnd": [484, 520], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 585, "focalAPIEnd": 609, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream,int)"], "useStart": [560], "useEnd": [616], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/odnoklassniki/apache-cassandra/tree/master/src/java/org/apache/cassandra/net/OutboundTcpConnection.java", "rawCode": "  private boolean connect() {\n    if (logger.isDebugEnabled()) logger.debug(\"attempting to connect to \" + endpoint);\n    long start = System.currentTimeMillis();\n    while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout()) {\n      try {\n        // zero means 'bind on any available port.'\n        socket =\n            new Socket(\n                endpoint, DatabaseDescriptor.getStoragePort(), FBUtilities.getLocalAddress(), 0);\n        socket.setKeepAlive(true);\n        socket.setTcpNoDelay(true);\n        output = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), 4096));\n        return true;\n      } catch (IOException e) {\n        socket = null;\n        if (logger.isTraceEnabled()) logger.trace(\"unable to connect to \" + endpoint, e);\n        try {\n          Thread.sleep(OPEN_RETRY_DELAY);\n        } catch (InterruptedException e1) {\n          throw new AssertionError(e1);\n        }\n      }\n    }\n    return false;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7915, "initialization": ["Socket socket = createSocket(InetAddress,int,boolean)"], "initializationStart": [605], "initializationEnd": [645], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.getInputStream()"], "configurationStart": [660], "configurationEnd": [687], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 703, "focalAPIEnd": 731, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ferquies/2dam/tree/master/AD/Tema 2/h2/src/tools/org/h2/dev/ftp/FtpClient.java", "rawCode": "  private void passive() throws IOException {\n    send(\"PASV\");\n    readCode(226, 227);\n    int first = message.indexOf('(') + 1;\n    int last = message.indexOf(')');\n    String[] address = StringUtils.arraySplit(message.substring(first, last), ',', true);\n    StatementBuilder buff = new StatementBuilder();\n    for (int i = 0; i < 4; i++) {\n      buff.appendExceptFirst(\".\");\n      buff.append(address[i]);\n    }\n    String ip = buff.toString();\n    InetAddress addr = InetAddress.getByName(ip);\n    int port = (Integer.parseInt(address[4]) << 8) | Integer.parseInt(address[5]);\n    Socket socketData = NetUtils.createSocket(addr, port, false);\n    inData = socketData.getInputStream();\n    outData = socketData.getOutputStream();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7916, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["Socket.close()"], "tryExpressionStart": 150, "tryExpressionEnd": 154, "tryBlockStart": 150, "tryBlockEnd": 1607, "catchExpressionStart": 1452, "catchExpressionEnd": 1476, "catchBlockStart": 1452, "catchBlockEnd": 1607, "exceptionHandlingCallStart": [1391], "exceptionHandlingCallEnd": [1402], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 270, "focalAPIEnd": 296, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream)", "outputStream.write(byte[],int,int)", "outputStream.flush()", "outputStream.close()", "socket.close()"], "useStart": [323, 1285, 1370, 1391, 1540], "useEnd": [343, 1309, 1381, 1402, 1556], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ajhalbleib/aicg/tree/master/appinventor/components/src/com/google/appinventor/components/runtime/util/NanoHTTPD.java", "rawCode": "    /** Sends given response to the socket. */\n    private void sendResponse(String status, String mime, Properties header, InputStream data) {\n      try {\n        if (status == null) throw new Error(\"sendResponse(): Status can't be null.\");\n\n        OutputStream out = mySocket.getOutputStream();\n        PrintWriter pw = new PrintWriter(out);\n        pw.print(\"HTTP/1.0 \" + status + \" \\r\\n\");\n\n        if (mime != null) pw.print(\"Content-Type: \" + mime + \"\\r\\n\");\n\n        if (header == null || header.getProperty(\"Date\") == null)\n          pw.print(\"Date: \" + gmtFrmt.format(new Date()) + \"\\r\\n\");\n\n        if (header != null) {\n          Enumeration e = header.keys();\n          while (e.hasMoreElements()) {\n            String key = (String) e.nextElement();\n            String value = header.getProperty(key);\n            pw.print(key + \": \" + value + \"\\r\\n\");\n          }\n        }\n\n        pw.print(\"\\r\\n\");\n        pw.flush();\n\n        if (data != null) {\n          int pending = data.available(); // This is to support partial sends, see serveFile()\n          byte[] buff = new byte[theBufferSize];\n          while (pending > 0) {\n            int read = data.read(buff, 0, ((pending > theBufferSize) ? theBufferSize : pending));\n            if (read <= 0) break;\n            out.write(buff, 0, read);\n            pending -= read;\n          }\n        }\n        out.flush();\n        out.close();\n        if (data != null) data.close();\n      } catch (IOException ioe) {\n        // Couldn't write? No can do.\n        try {\n          mySocket.close();\n        } catch (Throwable t) {\n        }\n      }\n    }\n"}, {"dataset": "getOutputStream", "exampleID": 7917, "initialization": ["Socket socket = new Socket(InetAddress,*)"], "initializationStart": [88], "initializationEnd": [123], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 70, "tryExpressionEnd": 74, "tryBlockStart": 70, "tryBlockEnd": 295, "catchExpressionStart": 190, "catchExpressionEnd": 212, "catchBlockStart": 190, "catchBlockEnd": 295, "exceptionHandlingCallStart": [220], "exceptionHandlingCallEnd": [288], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 160, "focalAPIEnd": 181, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new ObjectOutputStream(outputStream)"], "useStart": [137], "useEnd": [182], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IanField90/DrawAndTalk/tree/master/DrawTalk/src/cs2ts6/client/ClientSendThread.java", "rawCode": "  public void run() {\n    // Setup sockets\n    Socket skt = null;\n    try {\n      skt = new Socket(serverAddress, port + 2);\n      oos = new ObjectOutputStream(skt.getOutputStream());\n    } catch (IOException e) {\n      System.err.println(\"Error setting up ClientSender\\nCan only listen\");\n    }\n    // Inform user everyting is ready to GO (Both send/recieve active)\n    client.onServerSet(true, serverAddress.toString());\n    JOptionPane.showMessageDialog(\n        null, \"You can now send to the server\\nServer detected at: \" + serverAddress.toString());\n    try {\n      while (true) {\n        pkt = client.getPacketToSend();\n        oos.writeObject(pkt);\n        oos.flush();\n      }\n    } catch (Exception e) {\n      System.err.println(\"Lost connection to server\");\n      JOptionPane.showMessageDialog(null, \"No Longer connected to server\");\n      client.onServerSet(false, \"\");\n      // Reset Calling Thread so that it can be re-instantiated on next successful communication\n      caller.invertRunParam(); // If server disconnects - resets client to 'searching'\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7918, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [736], "initializationEnd": [758], "hasTryCatch": 1, "exceptionType": "UnknownHostException", "exceptionHandlingCall": ["println(String)", "println(String)", "BufferedReader.readLine()", "valueOf(*)", "println(String)", "exit(int)"], "tryExpressionStart": 711, "tryExpressionEnd": 715, "tryBlockStart": 711, "tryBlockEnd": 1568, "catchExpressionStart": 916, "catchExpressionEnd": 947, "catchBlockStart": 916, "catchBlockEnd": 1463, "exceptionHandlingCallStart": [957, 1027, 1182, 1166, 1390, 1430], "exceptionHandlingCallEnd": [1017, 1144, 1198, 1199, 1416, 1444], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 790, "focalAPIEnd": 816, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)", "socket.getInputStream()", "socket.getInetAddress()", "socket.close()"], "useStart": [774, 879, 1634, 2784], "useEnd": [823, 904, 1659, 2800], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/panickeraj/Project-Chatter/tree/master/Client/ChatterClient.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    boolean encryptMode = true;\n    ChatterClientRSA encoder = new ChatterClientRSA();\n    boolean needHost = true;\n    String host = \"pod5-5.cs.purdue.edu\";\n    Socket ccSocket = null;\n    // PrintWriter out = null;\n    PrintWriter out = null;\n    BufferedReader in = null;\n    BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));\n    // Get the host name from the user\n    // This well need to be edit when ported to the phone\n\n    // This establishes a connection\n    while (true) {\n      if (needHost) {\n        System.out.println(\"What Host would you like to connect to?\");\n        host = stdIn.readLine();\n      }\n\n      try {\n        ccSocket = new Socket(host, 4444);\n        out = new PrintWriter(ccSocket.getOutputStream(), true);\n        in = new BufferedReader(new InputStreamReader(ccSocket.getInputStream()));\n      } catch (UnknownHostException e) {\n        System.err.println(\"\\nDon't know about host: \" + host + \".\");\n        System.err.println(\n            \"Would you like to:\\n[1] retry current host\\n[2] enter new host\\n[3] exit Chatter\\n\");\n        int reply = Integer.valueOf(stdIn.readLine());\n        switch (reply) {\n          case 1:\n            needHost = false;\n            break;\n          case 2:\n            needHost = true;\n            break;\n          default:\n            System.err.println(\"Bye.\");\n            System.exit(1);\n        }\n      } catch (IOException e) {\n        System.err.println(\"Couldn't get I/O.\");\n        System.exit(1);\n      }\n      if (ccSocket != null) break;\n    }\n\n    System.out.println(ccSocket.getInetAddress() + \" : \" + ccSocket.getLocalAddress());\n\n    // connection verified with server\n    // generating string\n    // File f = new File(\"/Users/nathanwisniewski/Desktop/Project-Chatter/Client/key.txt\");\n\n    // Tries to open file key.txt and read out a string\n    String key = getKey();\n    out.println(key);\n\n    String fromServer;\n    String fromUser;\n    StringBuilder build = new StringBuilder();\n    int c;\n\n    while (true) {\n      build.delete(0, build.capacity());\n      build.trimToSize();\n      build.ensureCapacity(20);\n      while ((c = in.read()) != -1\n          && c\n              != 0) { // This is to make sure that the client reads until the buffer is empty.\n                      // Otherwise syncing issues occures.\n        build.append((char) c);\n      }\n      fromServer = build.toString();\n\n      System.out.println(\"Server: \" + fromServer);\n\n      if (fromServer.equals(\"Goodbye.\")) break;\n\n      fromUser = stdIn.readLine();\n      if (fromUser != null) {\n        System.out.println(\"Client: \" + fromUser);\n        out.println(fromUser);\n      }\n    }\n    out.close();\n    in.close();\n    stdIn.close();\n    ccSocket.close();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7919, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.setSoTimeout(int)", "socket.getInputStream()"], "configurationStart": [72, 116], "configurationEnd": [100, 139], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 156, "focalAPIEnd": 180, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/shikhar/sshj/tree/master/src/main/java/net/schmizz/sshj/SocketClient.java", "rawCode": "  void onConnect() throws IOException {\n    if (socket != null) {\n      socket.setSoTimeout(timeout);\n      input = socket.getInputStream();\n      output = socket.getOutputStream();\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7920, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 223, "focalAPIEnd": 255, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["DirectWriteHelper(outputStream,byte[])"], "useStart": [205], "useEnd": [261], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cchriste/visit/tree/master/src/java/Connection.java", "rawCode": "  public void DirectWrite(byte[] buf) throws IOException {\n    // Write to the process. From its point of view, we are writing to the\n    // socket from which it reads so write to its read connection.\n    DirectWriteHelper(readConnection.getOutputStream(), buf);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7921, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 544, "focalAPIEnd": 568, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream)"], "useStart": [519], "useEnd": [569], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/OWASP/OWASP-Proxy/tree/master/src/main/java/org/owasp/proxy/http/client/HttpClient.java", "rawCode": "  public void sendRequestHeader(byte[] header) throws IOException, MessageFormatException {\n    if (state == State.RESPONSE_CONTINUE) {\n      throw new IllegalStateException(\n          \"Cannot start a new request when the \"\n              + \"previous request content has not yet been sent\");\n    }\n    if (state != State.CONNECTED && state != State.RESPONSE_CONTENT_READ) {\n      throw new IllegalStateException(\n          \"Illegal state. Can't send request headers when state is \" + state);\n    }\n    OutputStream os = new BufferedOutputStream(socket.getOutputStream());\n\n    int resourceStart = -1;\n    String method = null;\n    for (int i = 0; i < header.length; i++) {\n      if (method == null && Character.isWhitespace(header[i])) {\n        method = AsciiString.create(header, 0, i - 1);\n      }\n      if (method != null && !Character.isWhitespace(header[i]) && resourceStart == -1) {\n        resourceStart = i;\n        break;\n      }\n      if (header[i] == '\\r' || header[i] == '\\n') {\n        throw new MessageFormatException(\"Encountered CR or LF when parsing the URI!\", header);\n      }\n    }\n    expectResponseContent = !\"HEAD\".equals(method);\n    if (!direct) {\n      if (resourceStart > 0) {\n        os.write(header, 0, resourceStart);\n        os.write((\"http://\" + target.getHostName() + \":\" + target.getPort()).getBytes());\n        os.write(header, resourceStart, header.length - resourceStart);\n      } else {\n        throw new MessageFormatException(\"Couldn't parse the URI!\", header);\n      }\n    } else {\n      os.write(header);\n    }\n    os.flush();\n    state = State.REQUEST_HEADER_SENT;\n    requestSubmissionTime = System.currentTimeMillis();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7922, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 227, "focalAPIEnd": 251, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(*)", "outputStream.flush()", "outputStream.close()", "socket.close()"], "useStart": [257, 302, 328, 354], "useEnd": [296, 322, 348, 368], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vyloy/lnvc/tree/master/stb/lorent_video/src/org/xmlrpc/android/XMLRPCServer.java", "rawCode": "  public void respond(Socket socket, Object[] params) throws IOException {\n\n    String content = methodResponse(params);\n    String response = RESPONSE + (content.length()) + NEWLINES + content;\n    OutputStream outputStream = socket.getOutputStream();\n    outputStream.write(response.getBytes());\n    outputStream.flush();\n    outputStream.close();\n    socket.close();\n    Log.d(Tag.LOG, \"response:\" + response);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7923, "initialization": ["Socket socket = createSocket(String,int,boolean)"], "initializationStart": [69], "initializationEnd": [106], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.getInputStream()"], "configurationStart": [129], "configurationEnd": [152], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 177, "focalAPIEnd": 201, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream,*)"], "useStart": [292], "useEnd": [335], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/coderplay/h2-bitmap/tree/master/h2/src/tools/org/h2/dev/ftp/FtpClient.java", "rawCode": "  private void connect(String url) throws IOException {\n    socket = NetUtils.createSocket(url, 21, false);\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n    reader = new BufferedReader(new InputStreamReader(in));\n    writer = new PrintWriter(new OutputStreamWriter(out, Constants.UTF8));\n    readCode(220);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7924, "initialization": ["Socket socket = newSocket(*,*)"], "initializationStart": [128], "initializationEnd": [170], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 206, "focalAPIEnd": 230, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["socket.getInputStream()", "outputStream.write(String)", "outputStream.flush()", "socket.setSoTimeout(int)", "socket.close()"], "useStart": [255, 345, 910, 929, 1226], "useEnd": [278, 741, 920, 954, 1240], "hasFinally": 1, "cleanUpCall": ["Socket.close()"], "finallyExpressionStart": 1210, "finallyExpressionEnd": 1218, "finallyBlockStart": 1210, "finallyBlockEnd": 1247, "cleanUpCallStart": [1226], "cleanUpCallEnd": [1240], "url": "https://github.com/jetty-project/jetty-plugin-support/tree/master/jetty-server/src/test/java/org/eclipse/jetty/server/HttpServerTestBase.java", "rawCode": "  @Test\n  public void testBlockedClient() throws Exception {\n    configureServer(new HelloWorldHandler());\n\n    Socket client = newSocket(HOST, _connector.getLocalPort());\n    try {\n      OutputStream os = client.getOutputStream();\n      InputStream is = client.getInputStream();\n\n      // Send a request with chunked input and expect 100\n      os.write(\n          (\"GET / HTTP/1.1\\r\\n\"\n                  + \"Host: \"\n                  + HOST\n                  + \":\"\n                  + _connector.getLocalPort()\n                  + \"\\r\\n\"\n                  + \"Transfer-Encoding: chunked\\r\\n\"\n                  + \"Expect: 100-continue\\r\\n\"\n                  + \"Connection: Keep-Alive\\r\\n\"\n                  + \"\\r\\n\")\n              .getBytes());\n\n      // Never send a body.\n      // HelloWorldHandler does not read content, so 100 is not sent.\n      // So close will have to happen anyway, without reset!\n\n      os.flush();\n\n      client.setSoTimeout(2000);\n      long start = System.currentTimeMillis();\n      String in = IO.toString(is);\n      assertTrue(System.currentTimeMillis() - start < 1000);\n      assertTrue(in.indexOf(\"Connection: close\") > 0);\n      assertTrue(in.indexOf(\"Hello world\") > 0);\n\n    } finally {\n      client.close();\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7925, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [82], "initializationEnd": [111], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.getInputStream()"], "configurationStart": [183], "configurationEnd": [206], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 275, "focalAPIEnd": 299, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)"], "useStart": [252], "useEnd": [300], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victorspivak/projects/tree/master/TryProject/src/svl/TestClient1.java", "rawCode": "  public static void main(String[] args) throws IOException {\n    Socket socket = new Socket(\"localhost\", 8888);\n\n    BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n    PrintWriter printer = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));\n\n    printer.println(\"3000\");\n    printer.flush();\n\n    while (true) {\n      System.out.println(reader.readLine());\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7926, "initialization": ["Socket socket = SocketFactory.createSocket(String,int)"], "initializationStart": [824], "initializationEnd": [855], "hasTryCatch": 1, "exceptionType": "AuthenticationException", "exceptionHandlingCall": ["reset()"], "tryExpressionStart": 708, "tryExpressionEnd": 712, "tryBlockStart": 708, "tryBlockEnd": 4308, "catchExpressionStart": 3249, "catchExpressionEnd": 3284, "catchBlockStart": 3249, "catchBlockEnd": 3322, "exceptionHandlingCallStart": [1654], "exceptionHandlingCallEnd": [1661], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 916, "focalAPIEnd": 940, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream,int)", "socket.getInputStream()"], "useStart": [891, 1121], "useEnd": [948, 1144], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bogeblad/infoglue2/tree/master/src/java/org/infoglue/common/util/cvsclient/MyConnection.java", "rawCode": "  /**\n   * Authenticate a connection with the server, using the specified postamble and preamble.\n   *\n   * @param preamble the preamble to use\n   * @param postamble the postamble to use\n   * @throws AuthenticationException if an error occurred\n   * @return the socket used to make the connection. The socket is guaranteed to be open if an\n   *     exception has not been thrown\n   */\n  private void openConnection(String preamble, String postamble)\n      throws AuthenticationException, CommandAbortedException {\n    if (hostName == null) {\n      String locMessage = \"The hostname was null, can't continue.\"; // NOI18N\n      throw new AuthenticationException(\"HostIsNull\", locMessage); // NOI18N\n    }\n\n    try {\n      SocketFactory sf = (socketFactory != null) ? socketFactory : SocketFactory.getDefault();\n      socket = sf.createSocket(hostName, port);\n\n      BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream(), 32768);\n      LoggedDataOutputStream outputStream = new LoggedDataOutputStream(bos);\n      setOutputStream(outputStream);\n\n      BufferedInputStream bis = new BufferedInputStream(socket.getInputStream(), 32768);\n      LoggedDataInputStream inputStream = new LoggedDataInputStream(bis);\n      setInputStream(inputStream);\n\n      outputStream.writeBytes(preamble, \"US-ASCII\");\n      outputStream.writeBytes(getRepository() + \"\\n\"); // NOI18N\n      outputStream.writeBytes(userName + \"\\n\"); // NOI18N\n      outputStream.writeBytes(getEncodedPasswordNotNull() + \"\\n\", \"US-ASCII\"); // NOI18N\n      outputStream.writeBytes(postamble, \"US-ASCII\");\n      outputStream.flush();\n\n      if (Thread.interrupted()) {\n        reset();\n        String localMsg =\n            CommandException.getLocalMessage(\"Client.connectionAborted\", null); // NOI18N\n        throw new CommandAbortedException(\n            \"Aborted during connecting to the server.\", localMsg); // NOI18N\n      }\n\n      // read first 11 bytes only (AUTHENTICATION_SUCCEEDED_RESPONSE\\n)\n      // I observed lock caused by missing '\\n' in reponse\n      // this method then blocks forever\n      byte rawResponse[] = inputStream.readBytes(AUTHENTICATION_SUCCEEDED_RESPONSE_RAW.length());\n      String response = new String(rawResponse, \"utf8\"); // NOI18N\n\n      if (Thread.interrupted()) {\n        reset();\n        String localMsg =\n            CommandException.getLocalMessage(\"Client.connectionAborted\", null); // NOI18N\n        throw new CommandAbortedException(\n            \"Aborted during connecting to the server.\", localMsg); // NOI18N\n      }\n\n      if (AUTHENTICATION_SUCCEEDED_RESPONSE_RAW.equals(response)) {\n        return;\n      }\n\n      if (AUTHENTICATION_FAILED_RESPONSE_RAW.equals(response)) {\n        String localizedMsg = getLocalMessage(\"AuthenticationException.badPassword\", null);\n        throw new AuthenticationException(\n            \"AuthenticationFailed\", // NOI18N\n            localizedMsg);\n      }\n\n      if (response == null) response = \"\"; // NOI18N\n      String locMessage =\n          getLocalMessage(\n              \"AuthenticationException.AuthenticationFailed\", // NOI18N\n              new Object[] {response});\n      throw new AuthenticationException(\n          \"AuthenticationFailed\", // NOI18N\n          locMessage);\n    } catch (AuthenticationException ex) {\n      reset();\n      throw ex;\n    } catch (ConnectException ex) {\n      reset();\n      String locMessage =\n          getLocalMessage(\n              \"AuthenticationException.ConnectException\", // NOI18N\n              new Object[] {hostName, Integer.toString(port)});\n      throw new AuthenticationException(\n          \"ConnectException\",\n          ex, // NOI18N\n          locMessage);\n    } catch (NoRouteToHostException ex) {\n      reset();\n      String locMessage =\n          getLocalMessage(\n              \"AuthenticationException.NoRouteToHostException\", // NOI18N\n              new Object[] {hostName});\n      throw new AuthenticationException(\n          \"NoRouteToHostException\",\n          ex, // NOI18N\n          locMessage);\n    } catch (IOException ex) {\n      reset();\n      String locMessage =\n          getLocalMessage(\n              \"AuthenticationException.IOException\", // NOI18N\n              new Object[] {hostName});\n      throw new AuthenticationException(\"IOException\", ex, locMessage); // NOI18N\n    }\n    /* catch (Throwable t) {\n    reset();\n    String locMessage = AuthenticationException.getBundleString(\n    \"AuthenticationException.Throwable\"); //NOI18N\n    throw new AuthenticationException(\"General error\", t, locMessage); //NOI18N\n    }\n    */\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7927, "initialization": ["Socket socket = new Socket()"], "initializationStart": [242], "initializationEnd": [254], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 76, "tryExpressionEnd": 80, "tryBlockStart": 76, "tryBlockEnd": 910, "catchExpressionStart": 665, "catchExpressionEnd": 687, "catchBlockStart": 665, "catchBlockEnd": 737, "exceptionHandlingCallStart": [695], "exceptionHandlingCallEnd": [730], "configuration": ["socket.setSoLinger(boolean,int)", "socket.setSoTimeout(int)", "socket.connect(SocketAddress)", "socket.getInputStream()"], "configurationStart": [262, 294, 323, 393], "configurationEnd": [286, 315, 367, 411], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 437, "focalAPIEnd": 456, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(byte[])", "socket.close()"], "useStart": [465, 795], "useEnd": [483, 804], "hasFinally": 1, "cleanUpCall": ["Socket.close()"], "finallyExpressionStart": 738, "finallyExpressionEnd": 746, "finallyBlockStart": 738, "finallyBlockEnd": 910, "cleanUpCallStart": [795], "cleanUpCallEnd": [804], "url": "https://github.com/elka-projekt/cs-voltdb/tree/master/third_party/java/src/org/apache/zookeeper_voltpatches/ServerAdminClient.java", "rawCode": "  public static void dump(String host, int port) {\n    Socket s = null;\n    try {\n      byte[] reqBytes = new byte[4];\n      ByteBuffer req = ByteBuffer.wrap(reqBytes);\n      req.putInt(ByteBuffer.wrap(\"dump\".getBytes()).getInt());\n      s = new Socket();\n      s.setSoLinger(false, 10);\n      s.setSoTimeout(20000);\n      s.connect(new InetSocketAddress(host, port));\n\n      InputStream is = s.getInputStream();\n      OutputStream os = s.getOutputStream();\n\n      os.write(reqBytes);\n\n      byte[] resBytes = new byte[1024];\n\n      int rc = is.read(resBytes);\n      String retv = new String(resBytes);\n      System.out.println(\"rc=\" + rc + \" retv=\" + retv);\n    } catch (IOException e) {\n      LOG.warn(\"Unexpected exception\", e);\n    } finally {\n      if (s != null) {\n        try {\n          s.close();\n        } catch (IOException e) {\n          LOG.warn(\"Unexpected exception\", e);\n        }\n      }\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7928, "initialization": ["Socket socket = new Socket(String,*)"], "initializationStart": [721], "initializationEnd": [765], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 617, "tryExpressionEnd": 621, "tryBlockStart": 617, "tryBlockEnd": 1258, "catchExpressionStart": 1136, "catchExpressionEnd": 1157, "catchBlockStart": 1136, "catchBlockEnd": 1258, "exceptionHandlingCallStart": [1165], "exceptionHandlingCallEnd": [1225], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 780, "focalAPIEnd": 799, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["socket.getInputStream()", "sendLine(String,outputStream)"], "useStart": [812, 839], "useEnd": [830, 858], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vanzin/jEdit/tree/master/org/gjt/sp/jedit/bsh/Remote.java", "rawCode": "  static String doBsh(String url, String text) {\n    OutputStream out;\n    InputStream in;\n    String host = \"\";\n    String port = \"\";\n    String returnValue = \"-1\";\n    String orgURL = url;\n\n    // Need some format checking here\n    try {\n      url = url.substring(6); // remove the bsh://\n      // get the index of the : between the host and the port is located\n      int index = url.indexOf(\":\");\n      host = url.substring(0, index);\n      port = url.substring(index + 1, url.length());\n    } catch (Exception ex) {\n      System.err.println(\"Bad URL: \" + orgURL + \": \" + ex);\n      return returnValue;\n    }\n\n    try {\n      System.out.println(\"Connecting to host : \" + host + \" at port : \" + port);\n      Socket s = new Socket(host, Integer.parseInt(port) + 1);\n\n      out = s.getOutputStream();\n      in = s.getInputStream();\n\n      sendLine(text, out);\n\n      BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n      String line;\n      while ((line = bin.readLine()) != null) System.out.println(line);\n\n      // Need to scrape a value from the last line?\n      returnValue = \"1\";\n      return returnValue;\n    } catch (Exception ex) {\n      System.err.println(\"Error communicating with server: \" + ex);\n      return returnValue;\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7929, "initialization": ["Socket socket = new Socket(*,*)"], "initializationStart": [193], "initializationEnd": [279], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 335, "focalAPIEnd": 365, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)", "readResponse(socket,String)", "readResponse(socket,String)", "readResponse(socket,String)", "readResponse(socket,String)", "socket.close()"], "useStart": [319, 668, 2153, 2554, 2791, 2863], "useEnd": [372, 706, 2187, 2600, 2825, 2883], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/DealerDotCom/grinder/tree/master/grinder-http/src/test/java/net/grinder/tools/tcpproxy/TestHTTPProxyTCPProxyEngine.java", "rawCode": "  private void httpProxyEngineGoodRequestTests(AbstractTCPProxyEngine engine) throws Exception {\n\n    final AcceptAndEcho echoer = new AcceptAndEcho();\n\n    final Socket clientSocket =\n        new Socket(engine.getListenEndPoint().getHost(), engine.getListenEndPoint().getPort());\n\n    final PrintWriter clientWriter = new PrintWriter(clientSocket.getOutputStream(), true);\n\n    final String message0 =\n        \"GET http://\"\n            + echoer.getEndPoint()\n            + \"/foo HTTP/1.1\\r\\n\"\n            + \"foo: bah\\r\\n\"\n            + \"\\r\\n\"\n            + \"A \\u00e0 message\";\n    clientWriter.print(message0);\n    clientWriter.flush();\n\n    final String response0 = readResponse(clientSocket, \"message$\");\n\n    AssertUtilities.assertStartsWith(response0, \"GET /foo HTTP/1.1\\r\\n\");\n    AssertUtilities.assertContainsHeader(response0, \"foo\", \"bah\");\n    AssertUtilities.assertContainsPattern(response0, \"\\r\\n\\r\\nA \\u00e0 message$\");\n\n    verify(m_requestFilter).connectionOpened(m_connectionDetailsCaptor.capture());\n\n    final ConnectionDetails requestConnectionDetails = m_connectionDetailsCaptor.getValue();\n    assertEquals(echoer.getEndPoint(), requestConnectionDetails.getRemoteEndPoint());\n\n    verify(m_requestFilter)\n        .handle(same(requestConnectionDetails), isA(new byte[0].getClass()), isA(Integer.class));\n\n    verify(m_responseFilter).connectionOpened(m_connectionDetailsCaptor.capture());\n\n    final ConnectionDetails responseConnectionDetails = m_connectionDetailsCaptor.getValue();\n    assertEquals(requestConnectionDetails.getOtherEnd(), responseConnectionDetails);\n\n    verify(m_responseFilter)\n        .handle(same(responseConnectionDetails), isA(new byte[0].getClass()), isA(Integer.class));\n\n    final String message1Headers =\n        \"POST http://\"\n            + echoer.getEndPoint()\n            + \"/blah?x=123&y=99 HTTP/1.0\\r\\n\"\n            + \"\\r\\n\"\n            + \"Another message\";\n    clientWriter.print(message1Headers);\n    clientWriter.flush();\n\n    final String message1PostBody = \"Some data, lah 0x810x820x830x84 dah\";\n    clientWriter.print(message1PostBody);\n    clientWriter.flush();\n\n    final String response1 = readResponse(clientSocket, \"dah$\");\n\n    AssertUtilities.assertStartsWith(response1, \"POST /blah?x=123&y=99 HTTP/1.0\\r\\n\");\n    AssertUtilities.assertContainsPattern(\n        response1, \"\\r\\n\\r\\nAnother message\" + message1PostBody + \"$\");\n\n    // Do again, but force engine to handle body in two parts.\n    clientWriter.print(message1Headers);\n    clientWriter.flush();\n\n    final String response2a = readResponse(clientSocket, \"Another message$\");\n\n    AssertUtilities.assertStartsWith(response2a, \"POST /blah?x=123&y=99 HTTP/1.0\\r\\n\");\n\n    clientWriter.print(message1PostBody);\n    clientWriter.flush();\n\n    final String response2b = readResponse(clientSocket, \"dah$\");\n    assertNotNull(response2b);\n\n    clientSocket.close();\n\n    waitUntilAllStreamThreadsStopped(engine);\n\n    // handle() must have been called at least 3 further times, but can be\n    // called more.\n    verify(m_requestFilter, atLeast(4))\n        .handle(same(requestConnectionDetails), isA(new byte[0].getClass()), isA(Integer.class));\n\n    verify(m_responseFilter, atLeast(4))\n        .handle(same(responseConnectionDetails), isA(new byte[0].getClass()), isA(Integer.class));\n\n    verify(m_requestFilter).connectionClosed(requestConnectionDetails);\n    verify(m_responseFilter).connectionClosed(responseConnectionDetails);\n\n    verifyNoMoreInteractions(m_requestFilter, m_responseFilter);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7930, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["Socket.close()"], "tryExpressionStart": 128, "tryExpressionEnd": 132, "tryBlockStart": 128, "tryBlockEnd": 475, "catchExpressionStart": 267, "catchExpressionEnd": 289, "catchBlockStart": 267, "catchBlockEnd": 475, "exceptionHandlingCallStart": [311], "exceptionHandlingCallEnd": [325], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 172, "focalAPIEnd": 196, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new ObjectOutputStream(outputStream)", "socket.getInputStream()", "socket.close()"], "useStart": [149, 235, 311], "useEnd": [197, 258, 325], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bbcnt/bomberman/tree/master/src/network/Connection.java", "rawCode": "  /** Cette méthode initialise les objets pour la gestion des inputs et outputs */\n  private void initialiseOutputInput() {\n    try {\n      output = new ObjectOutputStream(socket.getOutputStream());\n      input = new ObjectInputStream(socket.getInputStream());\n    } catch (IOException e) {\n      try {\n        socket.close();\n      } catch (IOException e2) {\n        e.printStackTrace();\n        System.exit(1);\n      }\n      e.printStackTrace();\n      System.exit(1);\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7931, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 132, "focalAPIEnd": 156, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/funambol-mirror/funambol-client-sdk/tree/master/v911/common/src/main/java-se/com/funambol/platform/SocketAdapter.java", "rawCode": "  /** Open and return an output stream for this Socket. */\n  public OutputStream openOutputStream() throws IOException {\n    return socket.getOutputStream();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7932, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [98], "initializationEnd": [120], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 75, "tryExpressionEnd": 79, "tryBlockStart": 75, "tryBlockEnd": 496, "catchExpressionStart": 289, "catchExpressionEnd": 311, "catchBlockStart": 289, "catchBlockEnd": 389, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.setSoTimeout(int)", "socket.getInputStream()"], "configurationStart": [131, 173], "configurationEnd": [156, 196], "guardCondition": "socket==null", "guardType": "IF {", "guardExpressionStart": 46, "guardExpressionEnd": 65, "guardBlockStart": 46, "guardBlockEnd": 525, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 212, "focalAPIEnd": 236, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)"], "useStart": [253], "useEnd": [278], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/concord-consortium/teemss/tree/master/Archive/ProbeSystem/source/TCPDataChannel.java", "rawCode": "  public boolean open() {\n    int count;\n\n    if (socket == null) {\n\n      try {\n        socket = new Socket(addr, port);\n\n        socket.setSoTimeout(1500);\n\n        inS = socket.getInputStream();\n        out = socket.getOutputStream();\n        outS = new DataOutputStream(out);\n\n      } catch (IOException e) {\n        socket = null;\n        status = ERROR;\n        return false;\n      } catch (SecurityException e) {\n        socket = null;\n        status = ERROR;\n        return false;\n      }\n\n      flushed = true;\n    }\n\n    return true;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7933, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.connect(InetSocketAddress,int)", "socket.setSoTimeout(int)", "socket.connect(InetSocketAddress,int)", "socket.setSoTimeout(int)"], "configurationStart": [237, 308, 571, 650], "configurationEnd": [300, 328, 642, 670], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 1563, "focalAPIEnd": 1585, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(*)", "outputStream.flush()", "socket.getInputStream()"], "useStart": [1594, 1649, 1765], "useEnd": [1641, 1660, 1786], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kyau/connectbot/tree/master/src/com/trilead/ssh2/transport/TransportManager.java", "rawCode": "  private void establishConnection(ProxyData proxyData, int connectTimeout) throws IOException {\n    /* See the comment for createInetAddress() */\n\n    if (proxyData == null) {\n      InetAddress addr = createInetAddress(hostname);\n      sock.connect(new InetSocketAddress(addr, port), connectTimeout);\n      sock.setSoTimeout(0);\n      return;\n    }\n\n    if (proxyData instanceof HTTPProxyData) {\n      HTTPProxyData pd = (HTTPProxyData) proxyData;\n\n      /* At the moment, we only support HTTP proxies */\n\n      InetAddress addr = createInetAddress(pd.proxyHost);\n      sock.connect(new InetSocketAddress(addr, pd.proxyPort), connectTimeout);\n      sock.setSoTimeout(0);\n\n      /* OK, now tell the proxy where we actually want to connect to */\n\n      StringBuffer sb = new StringBuffer();\n\n      sb.append(\"CONNECT \");\n      sb.append(hostname);\n      sb.append(':');\n      sb.append(port);\n      sb.append(\" HTTP/1.0\\r\\n\");\n\n      if ((pd.proxyUser != null) && (pd.proxyPass != null)) {\n        String credentials = pd.proxyUser + \":\" + pd.proxyPass;\n        char[] encoded = Base64.encode(credentials.getBytes(\"ISO-8859-1\"));\n        sb.append(\"Proxy-Authorization: Basic \");\n        sb.append(encoded);\n        sb.append(\"\\r\\n\");\n      }\n\n      if (pd.requestHeaderLines != null) {\n        for (int i = 0; i < pd.requestHeaderLines.length; i++) {\n          if (pd.requestHeaderLines[i] != null) {\n            sb.append(pd.requestHeaderLines[i]);\n            sb.append(\"\\r\\n\");\n          }\n        }\n      }\n\n      sb.append(\"\\r\\n\");\n\n      OutputStream out = sock.getOutputStream();\n\n      out.write(sb.toString().getBytes(\"ISO-8859-1\"));\n      out.flush();\n\n      /* Now parse the HTTP response */\n\n      byte[] buffer = new byte[1024];\n      InputStream in = sock.getInputStream();\n\n      int len = ClientServerHello.readLineRN(in, buffer);\n\n      String httpReponse = new String(buffer, 0, len, \"ISO-8859-1\");\n\n      if (httpReponse.startsWith(\"HTTP/\") == false)\n        throw new IOException(\"The proxy did not send back a valid HTTP response.\");\n\n      /* \"HTTP/1.X XYZ X\" => 14 characters minimum */\n\n      if ((httpReponse.length() < 14)\n          || (httpReponse.charAt(8) != ' ')\n          || (httpReponse.charAt(12) != ' '))\n        throw new IOException(\"The proxy did not send back a valid HTTP response.\");\n\n      int errorCode = 0;\n\n      try {\n        errorCode = Integer.parseInt(httpReponse.substring(9, 12));\n      } catch (NumberFormatException ignore) {\n        throw new IOException(\"The proxy did not send back a valid HTTP response.\");\n      }\n\n      if ((errorCode < 0) || (errorCode > 999))\n        throw new IOException(\"The proxy did not send back a valid HTTP response.\");\n\n      if (errorCode != 200) {\n        throw new HTTPProxyException(httpReponse.substring(13), errorCode);\n      }\n\n      /* OK, read until empty line */\n\n      while (true) {\n        len = ClientServerHello.readLineRN(in, buffer);\n        if (len == 0) break;\n      }\n      return;\n    }\n\n    throw new IOException(\"Unsupported ProxyData\");\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7934, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["sendASyncUndelivered(*,*)", "printStackTrace()"], "tryExpressionStart": 182, "tryExpressionEnd": 186, "tryBlockStart": 182, "tryBlockEnd": 899, "catchExpressionStart": 693, "catchExpressionEnd": 715, "catchBlockStart": 693, "catchBlockEnd": 899, "exceptionHandlingCallStart": [758, 857], "exceptionHandlingCallEnd": [812, 876], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 455, "focalAPIEnd": 479, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(*)", "socket.getOutputStream()", "outputStream.flush()", "socket.close()"], "useStart": [455, 581, 581, 1040], "useEnd": [501, 605, 613, 1054], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/tags/release_4_1_1/appia/src/core/net/sf/appia/protocols/tcpcomplete/TcpCompleteSession.java", "rawCode": "    public void run() {\n      MessageContainer container = null;\n      while (isRunning()) {\n        container = queue.removeNext();\n        if (container == null) continue;\n        try {\n          if (TcpCompleteConfig.debugOn)\n            debug(\n                \"Sending message to the socket for \"\n                    + container.who\n                    + \" with \"\n                    + container.data.length\n                    + \" bytes\");\n          socket.getOutputStream().write(container.data);\n          if (TcpCompleteConfig.debugOn) debug(\"Flushing data...\");\n          socket.getOutputStream().flush();\n          if (TcpCompleteConfig.debugOn) debug(\"Flushing done...\");\n        } catch (IOException e) {\n          if (isRunning()) {\n            sendASyncUndelivered(container.channel, container.who);\n            if (TcpCompleteConfig.debugOn) e.printStackTrace();\n          }\n        }\n      }\n      try {\n        if (TcpCompleteConfig.debugOn && log.isDebugEnabled())\n          log.debug(\"Closing socket \" + socket);\n        socket.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n"}, {"dataset": "getOutputStream", "exampleID": 7935, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [418], "initializationEnd": [447], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.getInputStream()"], "configurationStart": [516], "configurationEnd": [534], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 566, "focalAPIEnd": 585, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)"], "useStart": [550], "useEnd": [592], "hasFinally": 1, "cleanUpCall": ["PrintWriter.close()"], "finallyExpressionStart": 1663, "finallyExpressionEnd": 1671, "finallyBlockStart": 1663, "finallyBlockEnd": 1782, "cleanUpCallStart": [1706], "cleanUpCallEnd": [1717], "url": "https://github.com/IanDarwin/darwinsys-api/tree/master/src/main/java/com/darwinsys/mail/SmtpUtils.java", "rawCode": "  public boolean verifySender(final String user, final String host) throws IOException {\n    PrintWriter out = null;\n    Socket s = null;\n    try {\n      String mxHost = null;\n      try {\n        mxHost = new DNSUtils(myDnsServer).findMX(host);\n      } catch (NamingException e) {\n        System.out.println(\"verifySender: cannot vrfy MX\");\n        return false; // Should be trinary, for \"unknown\"?\n      }\n      s = new Socket(mxHost, SMTP_PORT);\n      BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()));\n      out = new PrintWriter(s.getOutputStream(), true);\n      String greeting = readLine(in);\n      if (greeting != null) {\n        System.out.println(greeting);\n      }\n      send(out, \"HELO \" + myHostName);\n      String heloResp = readLine(in);\n      if (heloResp != null) {\n        System.out.println(heloResp);\n      }\n      send(out, \"MAIL From:<smtp_verifier@\" + myHostName + \">\");\n      String mailResp = readLine(in);\n      if (mailResp != null) {\n        System.out.println(mailResp);\n      }\n      String errorUser = \"postmaster\";\n      send(out, \"RCPT To:<\" + errorUser + \"@\" + host + \">\");\n      String vrfyResp = readLine(in);\n      if (vrfyResp == null) {\n        throw new IllegalStateException(\"Read Null Line in middle of SMTP conversation\");\n      }\n      if (vrfyResp.startsWith(\"550\")) {\n        return false;\n      }\n\n      send(out, \"QUIT\");\n      String quitResp = readLine(in);\n      if (quitResp != null) {\n        System.out.println(quitResp);\n      }\n\n      return true;\n    } catch (UnknownHostException e) {\n      return false;\n    } catch (NoRouteToHostException e) {\n      return false;\n\n    } finally {\n      if (out != null) {\n        out.close();\n      }\n      if (s != null) {\n        s.close();\n      }\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7936, "initialization": ["Socket socket = new Socket(InetAddress,int)"], "initializationStart": [233], "initializationEnd": [255], "hasTryCatch": 1, "exceptionType": "InterruptedIOException", "exceptionHandlingCall": ["Socket.close()", "println(String)"], "tryExpressionStart": 217, "tryExpressionEnd": 221, "tryBlockStart": 217, "tryBlockEnd": 344, "catchExpressionStart": 905, "catchExpressionEnd": 938, "catchBlockStart": 905, "catchBlockEnd": 1033, "exceptionHandlingCallStart": [948, 967], "exceptionHandlingCallEnd": [957, 1003], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 439, "focalAPIEnd": 458, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)", "socket.getOutputStream()", "outputStream.write(byte[])", "socket.setSoTimeout(int)", "socket.getInputStream()", "socket.close()", "socket.close()", "socket.close()"], "useStart": [418, 488, 488, 524, 766, 948, 1689, 2242], "useEnd": [459, 507, 518, 552, 784, 957, 1698, 2251], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lemmy/dnsjava/tree/master/tags/dnsjava-0-3/DNS/Resolver.java", "rawCode": "  public Message sendAXFR(Message query) throws IOException {\n    byte[] out, in;\n    Socket s;\n    int inLength;\n    DataInputStream dataIn;\n    int soacount = 0;\n    Message response;\n    boolean first = true;\n\n    try {\n      s = new Socket(addr, port);\n    } catch (SocketException e) {\n      System.out.println(e);\n      return null;\n    }\n\n    if (tsig != null) tsig.apply(query);\n\n    out = query.toWire();\n    new DataOutputStream(s.getOutputStream()).writeShort(out.length);\n    s.getOutputStream().write(out);\n    s.setSoTimeout(timeoutValue);\n\n    response = new Message();\n    response.getHeader().setID(query.getHeader().getID());\n    if (tsig != null) tsig.verifyAXFRStart();\n    while (soacount < 2) {\n      try {\n        dataIn = new DataInputStream(s.getInputStream());\n        inLength = dataIn.readUnsignedShort();\n        in = new byte[inLength];\n        dataIn.readFully(in);\n      } catch (InterruptedIOException e) {\n        s.close();\n        System.out.println(\";; No response\");\n        return null;\n      }\n      Message m = new Message(in);\n      if (m.getHeader().getCount(Section.QUESTION) != 0\n          || m.getHeader().getCount(Section.ANSWER) <= 0\n          || m.getHeader().getCount(Section.AUTHORITY) != 0) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(\"Invalid AXFR: \");\n        for (int i = 0; i < 4; i++) {\n          Enumeration e = m.getSection(i);\n          System.out.println(\"--\");\n          while (e.hasMoreElements()) {\n            Record r;\n            r = (Record) e.nextElement();\n            System.out.println(r);\n          }\n          System.out.println();\n        }\n        System.out.println(sb.toString());\n        s.close();\n        return null;\n      }\n      for (int i = 1; i < 4; i++) {\n        Enumeration e = m.getSection(i);\n        while (e.hasMoreElements()) {\n          Record r = (Record) e.nextElement();\n          response.addRecord(i, r);\n          if (r instanceof SOARecord) soacount++;\n        }\n      }\n      if (tsig != null) {\n        boolean required = (soacount > 1 || first);\n        boolean ok = tsig.verifyAXFR(m, in, query.getTSIG(), required, first);\n        System.out.println(\"TSIG verify: \" + ok);\n      }\n      first = false;\n    }\n\n    s.close();\n    return response;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7937, "initialization": ["Socket socket = new Socket(InetAddress,int)"], "initializationStart": [233], "initializationEnd": [255], "hasTryCatch": 1, "exceptionType": "InterruptedIOException", "exceptionHandlingCall": ["Socket.close()", "println(String)"], "tryExpressionStart": 217, "tryExpressionEnd": 221, "tryBlockStart": 217, "tryBlockEnd": 344, "catchExpressionStart": 905, "catchExpressionEnd": 938, "catchBlockStart": 905, "catchBlockEnd": 1033, "exceptionHandlingCallStart": [948, 967], "exceptionHandlingCallEnd": [957, 1003], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 439, "focalAPIEnd": 458, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)", "socket.getOutputStream()", "outputStream.write(byte[])", "socket.setSoTimeout(int)", "socket.getInputStream()", "socket.close()", "socket.close()", "socket.close()"], "useStart": [418, 488, 488, 524, 766, 948, 1689, 2242], "useEnd": [459, 507, 518, 552, 784, 957, 1698, 2251], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lemmy/dnsjava/tree/master/tags/dnsjava-0-5/DNS/Resolver.java", "rawCode": "  public Message sendAXFR(Message query) throws IOException {\n    byte[] out, in;\n    Socket s;\n    int inLength;\n    DataInputStream dataIn;\n    int soacount = 0;\n    Message response;\n    boolean first = true;\n\n    try {\n      s = new Socket(addr, port);\n    } catch (SocketException e) {\n      System.out.println(e);\n      return null;\n    }\n\n    if (tsig != null) tsig.apply(query);\n\n    out = query.toWire();\n    new DataOutputStream(s.getOutputStream()).writeShort(out.length);\n    s.getOutputStream().write(out);\n    s.setSoTimeout(timeoutValue);\n\n    response = new Message();\n    response.getHeader().setID(query.getHeader().getID());\n    if (tsig != null) tsig.verifyAXFRStart();\n    while (soacount < 2) {\n      try {\n        dataIn = new DataInputStream(s.getInputStream());\n        inLength = dataIn.readUnsignedShort();\n        in = new byte[inLength];\n        dataIn.readFully(in);\n      } catch (InterruptedIOException e) {\n        s.close();\n        System.out.println(\";; No response\");\n        return null;\n      }\n      Message m = new Message(in);\n      if (m.getHeader().getCount(Section.QUESTION) != 0\n          || m.getHeader().getCount(Section.ANSWER) <= 0\n          || m.getHeader().getCount(Section.AUTHORITY) != 0) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(\"Invalid AXFR: \");\n        for (int i = 0; i < 4; i++) {\n          Enumeration e = m.getSection(i);\n          System.out.println(\"--\");\n          while (e.hasMoreElements()) {\n            Record r;\n            r = (Record) e.nextElement();\n            System.out.println(r);\n          }\n          System.out.println();\n        }\n        System.out.println(sb.toString());\n        s.close();\n        return null;\n      }\n      for (int i = 1; i < 4; i++) {\n        Enumeration e = m.getSection(i);\n        while (e.hasMoreElements()) {\n          Record r = (Record) e.nextElement();\n          response.addRecord(i, r);\n          if (r instanceof SOARecord) soacount++;\n        }\n      }\n      if (tsig != null) {\n        boolean required = (soacount > 1 || first);\n        boolean ok = tsig.verifyAXFR(m, in, query.getTSIG(), required, first);\n        System.out.println(\"TSIG verify: \" + ok);\n      }\n      first = false;\n    }\n\n    s.close();\n    return response;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7938, "initialization": ["Socket socket = ServerSocket.accept()"], "initializationStart": [173], "initializationEnd": [194], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 36, "tryExpressionEnd": 40, "tryBlockStart": 36, "tryBlockEnd": 971, "catchExpressionStart": 917, "catchExpressionEnd": 937, "catchBlockStart": 917, "catchBlockEnd": 971, "exceptionHandlingCallStart": [945], "exceptionHandlingCallEnd": [964], "configuration": ["socket.getInputStream()"], "configurationStart": [249], "configurationEnd": [272], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 304, "focalAPIEnd": 328, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)"], "useStart": [288], "useEnd": [335], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Zucka/girafAdmin/tree/master/other/savanah/Serverside/savannah/src/dk/aau/cs/giraf/savannah/test/TestingPurposeServer.java", "rawCode": "  public static void server() {\n    try {\n      serverSocket = new ServerSocket(50000);\n      System.out.println(\"Server running, listening on port 50000\");\n\n      client = serverSocket.accept();\n\n      in = new BufferedReader(new InputStreamReader(client.getInputStream()));\n      out = new PrintWriter(client.getOutputStream(), true);\n\n      boolean done = false;\n      boolean skippedProlog = false;\n      while (!done) {\n        while (in.ready()) {\n          if (!skippedProlog) {\n            in.readLine();\n            skippedProlog = true;\n          }\n          msg = msg + in.readLine();\n          // out.println(msg);\n          if (!(in.ready())) {\n            done = true;\n          }\n        }\n      }\n      System.out.println(msg);\n\n      SAXBuilder sax = new SAXBuilder();\n      Document d = sax.build(new StringReader(msg));\n      System.out.println(\"2\");\n      System.out.println(d.toString());\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7939, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 1067, "tryExpressionEnd": 1071, "tryBlockStart": 1067, "tryBlockEnd": 1244, "catchExpressionStart": 1125, "catchExpressionEnd": 1147, "catchBlockStart": 1125, "catchBlockEnd": 1244, "exceptionHandlingCallStart": [1200], "exceptionHandlingCallEnd": [1219], "configuration": ["socket.close()"], "configurationStart": [763], "configurationEnd": [781], "guardCondition": "!(socket==null) && !(!(socket.isConnected()))", "guardType": "IF {", "guardExpressionStart": 711, "guardExpressionEnd": 734, "guardBlockStart": 711, "guardBlockEnd": 742, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 1087, "focalAPIEnd": 1115, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(*)", "outputStream.write(char)", "outputStream.write(char)", "outputStream.write(char)"], "useStart": [1299, 1345, 1379, 1403], "useEnd": [1333, 1359, 1393, 1418], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chr15m/PdDroidParty/tree/master/src/cx/mccormick/pddroidparty/DroidNetClient.java", "rawCode": "  public void receiveMessage(String symbol, Object... args) {\n    if (symbol.equals(\"connect\")\n        && (args.length == 2)\n        && args[0].getClass().equals(String.class)\n        && args[1].getClass().equals(Float.class)) {\n      if (port != 0) {\n        Log.d(TAG, \"already connected\");\n        return;\n      }\n      try {\n        host = InetAddress.getByName(args[0].toString());\n        port = (int) (float) (Float) args[1];\n        ClientThread = new Thread(ClientRun);\n        ClientThread.start();\n      } catch (UnknownHostException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n      }\n    } else if (symbol.equals(\"disconnect\")) {\n      if (port == 0) return;\n      if (connection == null) return;\n      try {\n        connection.close();\n      } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n        port = 0;\n      }\n\n    } else if (symbol.equals(\"send\")) {\n      if (connection == null) return;\n      if (!connection.isConnected()) return;\n      OutputStream out;\n      try {\n        out = connection.getOutputStream();\n      } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n        return;\n      }\n      try {\n        for (Object o : args) {\n          out.write(o.toString().getBytes());\n          out.write(' ');\n        }\n        out.write(';');\n        out.write('\\n');\n\n      } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n      }\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7940, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [526], "initializationEnd": [555], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 579, "focalAPIEnd": 603, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(*)", "socket.getInputStream()", "socket.close()"], "useStart": [609, 654, 838], "useEnd": [631, 677, 852], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/com/sun/net/httpserver/Test4.java", "rawCode": "  public static void doClient(int port) throws Exception {\n    String s =\n        \"GET /test/1.html HTTP/1.1\\r\\nContent-length: 20\\r\\n\"\n            + \"\\r\\n\"\n            + body1\n            + \"GET /test/2.html HTTP/1.1\\r\\nContent-length: 30\\r\\n\"\n            + \"\\r\\n\"\n            + body2\n            + \"GET /test/3.html HTTP/1.1\\r\\nContent-length: 10\\r\\n\"\n            + \"\\r\\n\"\n            + body3\n            + \"GET /test/4.html HTTP/1.1\\r\\nContent-length: 10\\r\\n\"\n            + \"\\r\\n\"\n            + body4;\n\n    Socket socket = new Socket(\"localhost\", port);\n    OutputStream os = socket.getOutputStream();\n    os.write(s.getBytes());\n    InputStream is = socket.getInputStream();\n    int c, count = 0;\n    byte[] b = new byte[1024];\n    while ((c = is.read(b, count, b.length - count)) != -1) {\n      count += c;\n    }\n    is.close();\n    socket.close();\n    s = new String(b, 0, count, \"ISO8859_1\");\n    if (!compare(s, result)) {\n      throw new RuntimeException(\"wrong string result\");\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7941, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [104], "initializationEnd": [136], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 161, "focalAPIEnd": 185, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["socket.getInputStream()", "outputStream.write(byte[])", "outputStream.close()", "socket.close()"], "useStart": [208, 2323, 3091, 3107], "useEnd": [231, 2336, 3101, 3121], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/weishengshui/posserver/tree/master/main/src/test/java/com/chinarewards/qqgbpvn/main/ProtocolOnMinaTest.java", "rawCode": "  public void testSendFirmwareUpdateRequestViaJavaSocket_Free() throws Exception {\n\n    Socket socket = new Socket(\"192.168.1.42\", 1234);\n\n    OutputStream os = socket.getOutputStream();\n    InputStream is = socket.getInputStream();\n\n    byte[] msg =\n        new byte[] {\n          // SEQ\n          0,\n          0,\n          0,\n          24,\n          // ACK\n          0x20,\n          0,\n          0,\n          0x04,\n          // flags\n          0,\n          0,\n          // checksum (auto-calculated)\n          0,\n          0,\n          // message length\n          0,\n          0,\n          0,\n          0x20,\n          // command ID\n          0,\n          0,\n          0,\n          13,\n          // POS ID\n          'R',\n          'E',\n          'W',\n          'A',\n          'R',\n          'D',\n          'S',\n          '-',\n          '0',\n          '0',\n          '0',\n          '1'\n        };\n\n    msg =\n        new byte[] {\n          // SEQ\n          0,\n          0,\n          0,\n          24,\n          // ACK\n          0x20,\n          0,\n          0,\n          0x04,\n          // flags\n          0,\n          0,\n          // checksum (auto-calculated)\n          0,\n          0,\n          // message length\n          0,\n          0,\n          0,\n          0x20,\n          // command ID\n          0,\n          0,\n          0,\n          5,\n          // POS ID\n          'R',\n          'E',\n          'W',\n          'A',\n          'R',\n          'D',\n          'S',\n          '-',\n          '0',\n          '0',\n          '0',\n          '1'\n        };\n\n    // calculate checksum\n    int checksum = Tools.checkSum(msg, msg.length);\n    Tools.putUnsignedShort(msg, checksum, 10);\n\n    System.out.println(\"Packet size: \" + msg.length);\n\n    int loop = 5;\n\n    long runForSeconds = 1;\n    // write response\n    log.info(\"Send request to server\");\n    for (int j = 0; j < loop; j++) {\n      msg[3] = (byte) 0x0a;\n      msg[3] += (byte) j;\n\n      // uncomment the following to enable individual CORRECT checksum\n      // to be sent\n\n      boolean doSaneChecksum = true;\n\n      if (j == 3) {\n        doSaneChecksum = false;\n      }\n\n      if (doSaneChecksum) {\n        msg[10] = 0;\n        msg[11] = 0;\n        int checksum2 = Tools.checkSum(msg, msg.length);\n        Tools.putUnsignedShort(msg, checksum2, 10);\n      }\n\n      os.write(msg);\n      // os.flush();\n      // Thread.sleep(1);\n\n      msg[31] += 1;\n    }\n\n    // os.flush();\n    // Thread.sleep(1000);\n    // os.write(msg);\n    // os.flush();\n\n    // session.write(\"Client First Message\");\n    Thread.sleep(runForSeconds * 1000);\n    // read\n    log.info(\"Read response\");\n    byte[] response = new byte[30 * loop];\n    int n = is.read(response);\n    System.out.println(\"Number of bytes read: \" + n + \"\\n\");\n    CodecUtil.debugRaw(log, response);\n\n    for (int i = 0; i < n; i++) {\n      String s = Integer.toHexString((byte) response[i]);\n      if (s.length() < 2) s = \"0\" + s;\n      if (s.length() > 2) s = s.substring(s.length() - 2);\n      System.out.print(s + \" \");\n      if ((i + 1) % 8 == 0) System.out.println(\"\");\n    }\n\n    os.close();\n    socket.close();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7942, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [167], "initializationEnd": [196], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 247, "focalAPIEnd": 269, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(String)", "outputStream.flush()", "socket.close()"], "useStart": [281, 327, 376], "useEnd": [315, 344, 388], "hasFinally": 1, "cleanUpCall": ["Socket.close()"], "finallyExpressionStart": 356, "finallyExpressionEnd": 364, "finallyBlockStart": 356, "finallyBlockEnd": 399, "cleanUpCallStart": [376], "cleanUpCallEnd": [388], "url": "https://github.com/mehant/incubator-drill/tree/master/exec/java-exec/src/test/java/org/apache/drill/exec/util/MiniZooKeeperCluster.java", "rawCode": "  private static boolean waitForServerDown(int port, long timeout) {\n    long start = System.currentTimeMillis();\n    while (true) {\n      try {\n        Socket sock = new Socket(\"localhost\", port);\n        try {\n          OutputStream outstream = sock.getOutputStream();\n          outstream.write(\"stat\".getBytes());\n          outstream.flush();\n        } finally {\n          sock.close();\n        }\n      } catch (IOException e) {\n        return true;\n      }\n\n      if (System.currentTimeMillis() > start + timeout) {\n        break;\n      }\n      try {\n        Thread.sleep(250);\n      } catch (InterruptedException e) {\n        // ignore\n      }\n    }\n    return false;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7943, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.getInputStream()"], "configurationStart": [492], "configurationEnd": [515], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 542, "focalAPIEnd": 566, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputWrap(outputStream)"], "useStart": [522], "useEnd": [567], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BertrandDechoux/Heritrix-3/tree/master/modules/src/main/java/org/archive/modules/fetcher/FetchFTP.java", "rawCode": "  /**\n   * Saves the given socket to the given recorder.\n   *\n   * @param curi the curi that owns the recorder\n   * @param socket the socket whose streams to save\n   * @param recorder the recorder to save them to\n   * @throws IOException if a network or file error occurs\n   * @throws InterruptedException if the thread is interrupted\n   */\n  private void saveToRecorder(CrawlURI curi, Socket socket, Recorder recorder)\n      throws IOException, InterruptedException {\n    recorder.inputWrap(socket.getInputStream());\n    recorder.outputWrap(socket.getOutputStream());\n    recorder.markContentBegin();\n\n    // Read the remote file/dir listing in its entirety.\n    long softMax = 0;\n    long hardMax = getMaxLengthBytes();\n    long timeout = (long) getTimeoutSeconds() * 1000L;\n    int maxRate = getMaxFetchKBSec();\n    RecordingInputStream input = recorder.getRecordedInput();\n    input.setLimits(hardMax, timeout, maxRate);\n    input.readFullyOrUntil(softMax);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7944, "initialization": ["Socket socket = new Socket(*,*)"], "initializationStart": [125], "initializationEnd": [167], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 269, "focalAPIEnd": 288, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)", "socket.getInputStream()", "socket.close()"], "useStart": [246, 531, 1890], "useEnd": [289, 549, 1899], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.13.1/trunk-archive/src/om/loadtest/TNTester.java", "rawCode": "  private String sendRequestGetCookie(int iServer, Map mTokens, HttpScript.Item i)\n      throws IOException {\n    Socket s = new Socket(HOSTS[iServer], PORTS[iServer]);\n    // Again with the dodgy charset assumptions\n    OutputStreamWriter osw = new OutputStreamWriter(s.getOutputStream());\n    String sRequest = i.getRequest();\n    sRequest = XML.replaceTokens(sRequest, \"%%\", mTokens);\n    osw.write(sRequest + \"\\r\\n\");\n    if (i.getData() != null) osw.write(i.getData());\n    osw.flush();\n\n    // Get input\n    InputStream is = s.getInputStream();\n    String sLine = \"\";\n    int iContentLength = 0;\n    String sCookie = null;\n    boolean bFirst = true;\n    while (true) {\n      int iChar = is.read();\n      if (iChar == -1) throw new IOException(\"Unexpected EOF in socket input\");\n      if (iChar == 10) {\n        if (sLine.equals(\"\")) break; // End of headers\n        Matcher m = HttpScript.CONTENTLENGTH.matcher(sLine);\n        if (m.matches()) iContentLength = Integer.parseInt(m.group(1));\n        m = SETCOOKIE.matcher(sLine);\n        if (m.matches()) sCookie = m.group(1);\n        if (bFirst) {\n          bFirst = false;\n          Matcher mStatus = HttpScript.STATUSCODE.matcher(sLine);\n          if (!mStatus.matches()) throw new IOException(\"Unexpected HTTP status format: \" + sLine);\n          if (Integer.parseInt(mStatus.group(1)) != i.getExpectedResponse()) {\n            throw new IOException(\n                \"Unexpected response code: \"\n                    + sLine\n                    + \" (expecting \"\n                    + i.getExpectedResponse()\n                    + \")\\n\"\n                    + IO.loadString(is));\n          }\n        }\n        // System.err.println(sLine);\n        sLine = \"\";\n      } else if (iChar != 13) {\n        sLine += (char) iChar;\n      }\n    }\n\n    for (int iContent = 0; iContent < iContentLength; iContent++) {\n      is.read();\n    }\n\n    s.close();\n\n    if (sCookie == null) throw new IOException(\"Didn't obtain cookie\");\n    return sCookie;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7945, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [454], "initializationEnd": [494], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()", "Logger.debug(String)"], "tryExpressionStart": 303, "tryExpressionEnd": 307, "tryBlockStart": 303, "tryBlockEnd": 428, "catchExpressionStart": 862, "catchExpressionEnd": 888, "catchBlockStart": 862, "catchBlockEnd": 1006, "exceptionHandlingCallStart": [898, 931], "exceptionHandlingCallEnd": [921, 972], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 534, "focalAPIEnd": 568, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new ObjectOutputStream(outputStream)", "socket.getInputStream()", "socket.close()"], "useStart": [511, 630, 1272], "useEnd": [569, 663, 1296], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kennyhelsens/compomics-relims/tree/master/compomics-relims/src/main/java/com/compomics/relims/modes/networking/client/connectivity/connectors/ServerConnector.java", "rawCode": "  public boolean createOnServer(TaskContainer taskMap) throws IOException {\n\n    boolean isAvailable = false;\n    logger.debug(\"Creating socket to '\" + controllerIP + \"' on port \" + controllerPort);\n    boolean loading = true;\n    Map<Long, String> myCurrentProjects = null;\n    while (loading) {\n      try {\n        Thread.currentThread().sleep(1000);\n      } catch (InterruptedException ex) {\n        logger.error(ex);\n      }\n      socketConnection = new Socket(controllerIP, controllerPort);\n      output = new ObjectOutputStream(socketConnection.getOutputStream());\n      output.flush();\n\n      input = new ObjectInputStream(socketConnection.getInputStream());\n      logger.debug(\"Input- and outputstreams are ready...\");\n\n      try {\n        output.writeInt(0);\n        output.writeObject(taskMap);\n        output.flush();\n        loading = false;\n      } catch (IOException IOExc) {\n        IOExc.printStackTrace();\n        logger.debug(\"Could not send results...\");\n        loading = false;\n      }\n      try {\n        isAvailable = (boolean) input.readBoolean();\n        loading = false;\n      } catch (IOException IOExc) {\n        IOExc.printStackTrace();\n        loading = false;\n      }\n      if (!loading) {\n        logger.debug(\"Tasks were sent !\");\n        socketConnection.close();\n        break;\n      }\n    }\n\n    return isAvailable;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7946, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["Socket.close()"], "tryExpressionStart": 150, "tryExpressionEnd": 154, "tryBlockStart": 150, "tryBlockEnd": 1426, "catchExpressionStart": 1271, "catchExpressionEnd": 1295, "catchBlockStart": 1271, "catchBlockEnd": 1426, "exceptionHandlingCallStart": [1210], "exceptionHandlingCallEnd": [1221], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 270, "focalAPIEnd": 296, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream)", "outputStream.write(byte[],int,int)", "outputStream.flush()", "outputStream.close()", "socket.close()"], "useStart": [323, 1133, 1189, 1210, 1359], "useEnd": [343, 1157, 1200, 1221, 1375], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rodolfoasantos/catch-the-pigeon/tree/master/android/CatchThePigeonAndroid/src/br/eng/mosaic/pigeon/test/helper/NanoHTTPD.java", "rawCode": "    /** Sends given response to the socket. */\n    private void sendResponse(String status, String mime, Properties header, InputStream data) {\n      try {\n        if (status == null) throw new Error(\"sendResponse(): Status can't be null.\");\n\n        OutputStream out = mySocket.getOutputStream();\n        PrintWriter pw = new PrintWriter(out);\n        pw.print(\"HTTP/1.0 \" + status + \" \\r\\n\");\n\n        if (mime != null) pw.print(\"Content-Type: \" + mime + \"\\r\\n\");\n\n        if (header == null || header.getProperty(\"Date\") == null)\n          pw.print(\"Date: \" + gmtFrmt.format(new Date()) + \"\\r\\n\");\n\n        if (header != null) {\n          Enumeration<Object> e = header.keys();\n          while (e.hasMoreElements()) {\n            String key = (String) e.nextElement();\n            String value = header.getProperty(key);\n            pw.print(key + \": \" + value + \"\\r\\n\");\n          }\n        }\n\n        pw.print(\"\\r\\n\");\n        pw.flush();\n\n        if (data != null) {\n          byte[] buff = new byte[2048];\n          while (true) {\n            int read = data.read(buff, 0, 2048);\n            if (read <= 0) break;\n            out.write(buff, 0, read);\n          }\n        }\n        out.flush();\n        out.close();\n        if (data != null) data.close();\n      } catch (IOException ioe) {\n        // Couldn't write? No can do.\n        try {\n          mySocket.close();\n        } catch (Throwable t) {\n        }\n      }\n    }\n"}, {"dataset": "getOutputStream", "exampleID": 7947, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [451], "initializationEnd": [490], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "println(String)"], "tryExpressionStart": 390, "tryExpressionEnd": 394, "tryBlockStart": 390, "tryBlockEnd": 1217, "catchExpressionStart": 1112, "catchExpressionEnd": 1132, "catchBlockStart": 1112, "catchBlockEnd": 1217, "exceptionHandlingCallStart": [1175, 1140], "exceptionHandlingCallEnd": [1189, 1190], "configuration": ["socket.getInputStream()"], "configurationStart": [544], "configurationEnd": [567], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 623, "focalAPIEnd": 647, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)"], "useStart": [602], "useEnd": [648], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IndieC8/ISFE-20110020/tree/master/Documents/NetBeansProjects/ISFE-20110020/src/java/Integracion/ConexionSAT/SAT.java", "rawCode": "  /**\n   * Metodo encargado de realizar la conexio y la solicitud los folios al sevidor simulado del SAT\n   *\n   * @param numFolios este parametro establece el numero de folios que se habran de solicitar con el\n   *     SAT\n   */\n  public boolean manejoDeFolios(int numFolios) {\n    Integer arrayFolios[] = new Integer[numFolios];\n    Folio almacenaFolios = new Folio();\n    int i = 0;\n    try {\n      int puertoServicio = 8091;\n      Socket socket = new Socket(\"localhost\", puertoServicio);\n      DataInputStream entrada = new DataInputStream(socket.getInputStream());\n      DataOutputStream salida = new DataOutputStream(socket.getOutputStream());\n      // aqui ira el envio de informacion para la solicitud de Folios\n      salida.writeInt(numFolios);\n      while (i < numFolios) {\n        arrayFolios[i] = entrada.readInt();\n        if (almacenaFolios.almacenarBloqueFolios(arrayFolios[i]) == true) {\n          System.out.println(\"Folio almacenado correctamente\");\n        } else {\n          System.out.println(\"Los folios no se han podido almacenar\");\n        }\n        i++;\n      }\n      return true;\n    } catch (Exception e) {\n      System.out.println(\"Excepcion: \" + e.getMessage());\n      return false;\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7948, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [281], "initializationEnd": [310], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 260, "tryExpressionEnd": 264, "tryBlockStart": 260, "tryBlockEnd": 1417, "catchExpressionStart": 1237, "catchExpressionEnd": 1259, "catchBlockStart": 1237, "catchBlockEnd": 1289, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 340, "focalAPIEnd": 364, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)", "socket.getInputStream()", "socket.close()"], "useStart": [324, 425, 1322], "useEnd": [371, 448, 1332], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1290, "finallyExpressionEnd": 1298, "finallyBlockStart": 1290, "finallyBlockEnd": 1417, "cleanUpCallStart": [1322], "cleanUpCallEnd": [1332], "url": "https://github.com/chenopodium/IGV/tree/master/launcher/src/org/broad/igv/Launcher.java", "rawCode": "  private static boolean loadDirectly(\n      int port, String file, String name, String locus, String genome, String merge)\n      throws IOException {\n    boolean success;\n    Socket socket = null;\n    PrintWriter out = null;\n    BufferedReader in = null;\n    try {\n      socket = new Socket(\"127.0.0.1\", port);\n      out = new PrintWriter(socket.getOutputStream(), true);\n      in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n      if (genome != null) {\n        out.println(\"genome \" + genome);\n        String response = in.readLine();\n        System.out.println(response);\n      }\n      if (file != null) {\n        String cmd = \"load \" + file;\n        if (name != null) cmd += \" name=\" + name;\n        if (merge != null) cmd += \" merge=\" + merge;\n        out.println(cmd);\n        String response = in.readLine();\n        System.out.println(response);\n      }\n      if (locus != null) {\n        out.println(\"goto \" + locus);\n        String response = in.readLine();\n        System.out.println(response);\n      }\n\n      out.println(\"tofront\");\n      String response = in.readLine();\n      System.out.println(response);\n      success = true;\n\n    } catch (UnknownHostException e) {\n      success = false;\n    } catch (IOException e) {\n      success = false;\n    } finally {\n      if (in != null) in.close();\n      if (out != null) out.close();\n      if (socket != null) socket.close();\n    }\n    return success;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7949, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 170, "focalAPIEnd": 197, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeData(String,outputStream)", "socket.getInputStream()"], "useStart": [203, 273], "useEnd": [238, 299], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/unclebob/fitnesse/tree/master/src/fitnesse/testsystems/fit/FitClient.java", "rawCode": "  @Override\n  public synchronized void acceptSocket(Socket socket) throws IOException, InterruptedException {\n    checkForPulse();\n    fitSocket = socket;\n    fitInput = fitSocket.getOutputStream();\n    FitProtocol.writeData(\"\", fitInput);\n    fitOutput = new StreamReader(fitSocket.getInputStream());\n\n    fitListeningThread = new Thread(new FitListeningRunnable(), \"FitClient fitOutput\");\n    fitListeningThread.start();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7950, "initialization": ["Socket socket = newSocket(*,*)"], "initializationStart": [273], "initializationEnd": [315], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 351, "focalAPIEnd": 375, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new ResponseReader(socket)", "outputStream.write(*)", "outputStream.flush()", "socket.close()"], "useStart": [418, 1767, 1805, 1962], "useEnd": [1007, 1795, 1815, 1976], "hasFinally": 1, "cleanUpCall": ["Socket.close()", "getCount()", "assertEquals(int,*)"], "finallyExpressionStart": 1946, "finallyExpressionEnd": 1954, "finallyBlockStart": 1946, "finallyBlockEnd": 2051, "cleanUpCallStart": [1962, 2027, 1985], "cleanUpCallEnd": [1976, 2043, 2044], "url": "https://github.com/thomasbecker/jetty-7/tree/master/jetty-server/src/test/java/org/eclipse/jetty/server/ConnectorCloseTestBase.java", "rawCode": "  @Test\n  public void testCloseBetweenRequests() throws Exception {\n    int maxLength = 32;\n    int requestCount = iterations(maxLength);\n    final CountDownLatch latch = new CountDownLatch(requestCount);\n\n    configureServer(new HelloWorldHandler());\n\n    Socket client = newSocket(HOST, _connector.getLocalPort());\n    try {\n      OutputStream os = client.getOutputStream();\n\n      ResponseReader reader =\n          new ResponseReader(client) {\n            private int _index = 0;\n\n            /* ------------------------------------------------------------ */\n            @Override\n            protected int doRead() throws IOException, InterruptedException {\n              int count = super.doRead();\n              if (count > 0) {\n                int idx;\n                while ((idx = _response.indexOf(\"HTTP/1.1 200 OK\", _index)) >= 0) {\n                  latch.countDown();\n                  _index = idx + 15;\n                }\n              }\n\n              return count;\n            }\n          };\n\n      Thread runner = new Thread(reader);\n      runner.start();\n\n      for (int pipeline = 1; pipeline < maxLength; pipeline++) {\n        if (pipeline == maxLength / 2) _connector.close();\n\n        String request = \"\";\n        for (int i = 0; i < pipeline; i++) {\n          request +=\n              \"GET /data?writes=1&block=16&id=\"\n                  + i\n                  + \" HTTP/1.1\\r\\n\"\n                  + \"host: \"\n                  + HOST\n                  + \":\"\n                  + _connector.getLocalPort()\n                  + \"\\r\\n\"\n                  + \"user-agent: testharness/1.0 (blah foo/bar)\\r\\n\"\n                  + \"accept-encoding: nothing\\r\\n\"\n                  + \"cookie: aaa=1234567890\\r\\n\"\n                  + \"\\r\\n\";\n        }\n        os.write(request.getBytes());\n        os.flush();\n\n        Thread.sleep(25);\n      }\n\n      latch.await(30, TimeUnit.SECONDS);\n\n      reader.setDone();\n      runner.join();\n    } finally {\n      client.close();\n\n      assertEquals(requestCount, requestCount - latch.getCount());\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7951, "initialization": ["Socket socket = new Socket(String,*)"], "initializationStart": [178], "initializationEnd": [228], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.setSoTimeout(int)", "socket.setSoLinger(boolean,int)"], "configurationStart": [236, 270], "configurationEnd": [262, 298], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 817, "focalAPIEnd": 841, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(*)", "socket.getOutputStream()", "outputStream.flush()", "socket.getInputStream()", "socket.close()", "socket.setSoTimeout(int)", "socket.setSoLinger(boolean,int)", "socket.getOutputStream()", "outputStream.write(*)", "socket.getOutputStream()", "outputStream.flush()", "socket.getInputStream()", "socket.close()"], "useStart": [817, 877, 877, 1030, 1062, 2599, 2635, 2748, 2748, 2808, 2808, 2955, 2989], "useEnd": [867, 901, 909, 1053, 1076, 2625, 2663, 2772, 2798, 2832, 2840, 2978, 3003], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thomasbecker/jetty-spdy/tree/master/jetty-server/src/test/java/org/eclipse/jetty/server/StressTest.java", "rawCode": "  private void doPaths(int thread, String name, boolean persistent) throws Exception {\n    if (persistent) {\n      long start = System.currentTimeMillis();\n      Socket socket = new Socket(\"localhost\", _connector.getLocalPort());\n      socket.setSoTimeout(30000);\n      socket.setSoLinger(false, 0);\n\n      long connected = System.currentTimeMillis();\n\n      for (int i = 0; i < __tests.length; i++) {\n        String uri = __tests[i] + \"/\" + name + \"/\" + i;\n\n        String close = ((i + 1) < __tests.length) ? \"\" : \"Connection: close\\r\\n\";\n        String request =\n            \"GET \"\n                + uri\n                + \" HTTP/1.1\\r\\n\"\n                + \"Host: localhost\\r\\n\"\n                + \"start: \"\n                + start\n                + \"\\r\\n\"\n                + close\n                + \"\\r\\n\";\n\n        socket.getOutputStream().write(request.getBytes());\n        socket.getOutputStream().flush();\n        Thread.yield();\n      }\n\n      long written = System.currentTimeMillis();\n\n      String response = IO.toString(socket.getInputStream());\n      socket.close();\n\n      long end = System.currentTimeMillis();\n\n      int bodies = count(response, \"HTTP/1.1 200 OK\");\n      if (__tests.length != bodies) System.err.println(\"responses=\\n\" + response + \"\\n---\");\n      assertEquals(name, __tests.length, bodies);\n\n      long bind = connected - start;\n      long flush = (written - connected) / __tests.length;\n      long read = (end - written) / __tests.length;\n\n      int offset = 0;\n      for (int i = 0; i < __tests.length; i++) {\n        offset = response.indexOf(\"DATA \" + __tests[i], offset);\n        assertTrue(offset >= 0);\n        offset += __tests[i].length() + 5;\n\n        if (bind < 0 || flush < 0 || read < 0) {\n          System.err.println(bind + \",\" + flush + \",\" + read);\n        }\n\n        _latencies[0].add((i == 0) ? new Long(bind) : 0);\n        _latencies[1].add((i == 0) ? new Long(bind + flush) : flush);\n        _latencies[5].add((i == 0) ? new Long(bind + flush + read) : (flush + read));\n      }\n    } else {\n      for (int i = 0; i < __tests.length; i++) {\n        String uri = __tests[i] + \"/\" + name + \"/\" + i;\n\n        long start = System.currentTimeMillis();\n        String close = \"Connection: close\\r\\n\";\n        String request =\n            \"GET \"\n                + uri\n                + \" HTTP/1.1\\r\\n\"\n                + \"Host: localhost\\r\\n\"\n                + \"start: \"\n                + start\n                + \"\\r\\n\"\n                + close\n                + \"\\r\\n\";\n\n        Socket socket = new Socket(\"localhost\", _connector.getLocalPort());\n        socket.setSoTimeout(10000);\n        socket.setSoLinger(false, 0);\n\n        _latencies[0].add(new Long(System.currentTimeMillis() - start));\n\n        socket.getOutputStream().write(request.getBytes());\n        socket.getOutputStream().flush();\n\n        _latencies[1].add(new Long(System.currentTimeMillis() - start));\n\n        String response = IO.toString(socket.getInputStream());\n        socket.close();\n        long end = System.currentTimeMillis();\n\n        String endOfResponse = \"\\r\\n\\r\\n\";\n        assertTrue(\"response = '\" + response + \"'\", response.contains(endOfResponse));\n        response = response.substring(response.indexOf(endOfResponse) + endOfResponse.length());\n\n        assertTrue(uri, response.startsWith(\"DATA \" + __tests[i]));\n        long latency = end - start;\n\n        _latencies[5].add(new Long(latency));\n      }\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7952, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.setTcpNoDelay(boolean)", "socket.connect(InetSocketAddress,int)", "socket.setSoTimeout(int)"], "configurationStart": [49, 78, 146], "configurationEnd": [72, 140, 171], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 227, "focalAPIEnd": 248, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["socket.getInputStream()"], "useStart": [303], "useEnd": [323], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/KPWhiver/SpectroPolaris/tree/master/SpectroPolarisClient/src/stkl/spectropolarisclient/Client.java", "rawCode": "  public void connect() throws IOException {\n    skt.setTcpNoDelay(true);\n    skt.connect(new InetSocketAddress(d_ip, SERVER_PORT), TIMEOUT);\n    skt.setSoTimeout(TIMEOUT);\n    connected = true;\n    instance = this;\n\n    out = skt.getOutputStream();\n    in = new DataInputStream(new BufferedInputStream(skt.getInputStream()));\n\n    sentInit(d_name, d_color);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7953, "initialization": ["Socket socket = ServerSocket.accept()"], "initializationStart": [214], "initializationEnd": [225], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getMessage()", "closeChannel(Channel,String,boolean)"], "tryExpressionStart": 905, "tryExpressionEnd": 909, "tryBlockStart": 905, "tryBlockEnd": 1502, "catchExpressionStart": 1154, "catchExpressionEnd": 1176, "catchBlockStart": 1154, "catchBlockEnd": 1502, "exceptionHandlingCallStart": [1398, 1307], "exceptionHandlingCallEnd": [1412, 1425], "configuration": ["socket.getInetAddress()", "socket.close()"], "configurationStart": [616, 811], "configurationEnd": [634, 820], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 1007, "focalAPIEnd": 1026, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new StreamForwarder(Channel,*,*,*,outputStream,String)", "socket.getInputStream()", "new StreamForwarder(Channel,StreamForwarder,socket,*,*,String)"], "useStart": [937, 1092, 1060], "useEnd": [1044, 1110, 1144], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/greenqloud/cyberduck/tree/master/source/ch/ethz/ssh2/channel/LocalAcceptThread.java", "rawCode": "  @Override\n  public void run() {\n    try {\n      cm.registerThread(this);\n    } catch (IOException e) {\n      stopWorking();\n      return;\n    }\n\n    while (true) {\n      Socket s = null;\n\n      try {\n        s = ss.accept();\n      } catch (IOException e) {\n        stopWorking();\n        return;\n      }\n\n      Channel cn = null;\n      StreamForwarder r2l = null;\n      StreamForwarder l2r = null;\n\n      try {\n        /* This may fail, e.g., if the remote port is closed (in optimistic terms: not open yet) */\n\n        cn =\n            cm.openDirectTCPIPChannel(\n                host_to_connect, port_to_connect, s.getInetAddress().getHostAddress(), s.getPort());\n\n      } catch (IOException e) {\n        /* Simply close the local socket and wait for the next incoming connection */\n\n        try {\n          s.close();\n        } catch (IOException ignore) {\n        }\n\n        continue;\n      }\n\n      try {\n        r2l =\n            new StreamForwarder(\n                cn, null, null, cn.stdoutStream, s.getOutputStream(), \"RemoteToLocal\");\n        l2r = new StreamForwarder(cn, r2l, s, s.getInputStream(), cn.stdinStream, \"LocalToRemote\");\n      } catch (IOException e) {\n        try {\n          /* This message is only visible during debugging, since we discard the channel immediatelly */\n          cn.cm.closeChannel(\n              cn, \"Weird error during creation of StreamForwarder (\" + e.getMessage() + \")\", true);\n        } catch (IOException ignore) {\n        }\n\n        continue;\n      }\n\n      r2l.setDaemon(true);\n      l2r.setDaemon(true);\n      r2l.start();\n      l2r.start();\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7954, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [251], "initializationEnd": [273], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.getInputStream()"], "configurationStart": [336], "configurationEnd": [363], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 501, "focalAPIEnd": 529, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream,*)"], "useStart": [476], "useEnd": [539], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/manuelnaranjo/AIRi/tree/master/AIRcam/src/net/aircable/aircam/SL4A.java", "rawCode": "  public void connect() throws UnknownHostException, IOException, JSONException {\n    proxy = AndroidProxy.sProxy;\n    host = proxy.getAddress().getHostName();\n    port = proxy.getAddress().getPort();\n    secret = proxy.getSecret();\n\n    connection = new Socket(host, port);\n    input =\n        new BufferedReader(new InputStreamReader(connection.getInputStream(), \"8859_1\"), 1 << 13);\n    output =\n        new PrintWriter(\n            new OutputStreamWriter(\n                new BufferedOutputStream(connection.getOutputStream(), 1 << 13), \"8859_1\"),\n            true);\n    id = 0;\n    if (this.secret != null)\n      try {\n        this.callMethod(\"_authenticate\", new JSONArray('[' + this.secret + ']'));\n      } catch (RuntimeException e) {\n        if (!e.getMessage().contains(\"Unknown RPC\")) throw e;\n      }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7955, "initialization": ["Socket socket = new Socket(String,*)"], "initializationStart": [158], "initializationEnd": [208], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 238, "focalAPIEnd": 260, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream)", "socket.getInputStream()"], "useStart": [222, 426], "useEnd": [261, 447], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IanDarwin/javasrc/tree/master/src/main/java/netweb/HttpDemo.java", "rawCode": "    private void doNetworkIO(String hostName, String portString, String requestString)\n        throws UnknownHostException, IOException {\n      Socket sock = new Socket(hostName, Integer.parseInt(portString));\n      out = new PrintWriter(sock.getOutputStream());\n      send(requestString);\n      send(\"Host: \" + hostName);\n      send(\"\");\n      out.flush();\n\n      BufferedReader is = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n      String line;\n\n      while ((line = is.readLine()) != null) {\n        System.out.println(line);\n        outputArea.append(line);\n        outputArea.append(\"\\n\");\n      }\n      is.close();\n      sock.close();\n    }\n"}, {"dataset": "getOutputStream", "exampleID": 7956, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 222, "focalAPIEnd": 241, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)"], "useStart": [201], "useEnd": [242], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lemmy/dnsjava/tree/master/tags/dnsjava-1-3-0-beta/org/xbill/DNS/SimpleResolver.java", "rawCode": "  private void writeTCP(Socket s, byte[] out) throws IOException {\n    DataOutputStream dataOut;\n\n    if (Options.check(\"verbosemsg\")) System.err.println(hexdump.dump(\"TCP write\", out));\n    dataOut = new DataOutputStream(s.getOutputStream());\n    dataOut.writeShort(out.length);\n    dataOut.write(out);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7957, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.getInputStream()"], "configurationStart": [930], "configurationEnd": [953], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 1004, "focalAPIEnd": 1028, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)"], "useStart": [983], "useEnd": [1029], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vyloy/lnvc/tree/master/common/smack_src_3_2_1/source/org/jivesoftware/smackx/bytestreams/socks5/Socks5Client.java", "rawCode": "  /**\n   * Initializes the connection to the SOCKS5 proxy by negotiating authentication method and\n   * requesting a stream for the given digest. Currently only the no-authentication method is\n   * supported by the Socks5Client.\n   *\n   * <p>Returns <code>true</code> if a stream could be established, otherwise <code>false</code>. If\n   * <code>false</code> is returned the given Socket should be closed.\n   *\n   * @param socket connected to a SOCKS5 proxy\n   * @return <code>true</code> if if a stream could be established, otherwise <code>false</code>. If\n   *     <code>false</code> is returned the given Socket should be closed.\n   * @throws IOException if a network error occurred\n   */\n  protected boolean establish(Socket socket) throws IOException {\n\n    /*\n     * use DataInputStream/DataOutpuStream to assure read and write is completed in a single\n     * statement\n     */\n    DataInputStream in = new DataInputStream(socket.getInputStream());\n    DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n    // authentication negotiation\n    byte[] cmd = new byte[3];\n\n    cmd[0] = (byte) 0x05; // protocol version 5\n    cmd[1] = (byte) 0x01; // number of authentication methods supported\n    cmd[2] = (byte) 0x00; // authentication method: no-authentication required\n\n    out.write(cmd);\n    out.flush();\n\n    byte[] response = new byte[2];\n    in.readFully(response);\n\n    // check if server responded with correct version and no-authentication method\n    if (response[0] != (byte) 0x05 || response[1] != (byte) 0x00) {\n      return false;\n    }\n\n    // request SOCKS5 connection with given address/digest\n    byte[] connectionRequest = createSocks5ConnectRequest();\n    out.write(connectionRequest);\n    out.flush();\n\n    // receive response\n    byte[] connectionResponse;\n    try {\n      connectionResponse = Socks5Utils.receiveSocks5Message(in);\n    } catch (XMPPException e) {\n      return false; // server answered in an unsupported way\n    }\n\n    // verify response\n    connectionRequest[1] = (byte) 0x00; // set expected return status to 0\n    return Arrays.equals(connectionRequest, connectionResponse);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7958, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 867, "focalAPIEnd": 896, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream)"], "useStart": [842], "useEnd": [897], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TaintDroid/android_platform_libcore/tree/master/luni/src/main/java/java/util/logging/SocketHandler.java", "rawCode": "  private void initSocket(String host, String port) throws IOException {\n    // check the validity of the host name\n    if (host == null || host.isEmpty()) {\n      throw new IllegalArgumentException(\"host == null || host.isEmpty()\");\n    }\n    // check the validity of the port number\n    int p = 0;\n    try {\n      p = Integer.parseInt(port);\n    } catch (NumberFormatException e) {\n      throw new IllegalArgumentException(\"Illegal port argument\");\n    }\n    if (p <= 0) {\n      throw new IllegalArgumentException(\"Illegal port argument\");\n    }\n    // establish the network connection\n    try {\n      this.socket = new Socket(host, p);\n    } catch (IOException e) {\n      getErrorManager()\n          .error(\"Failed to establish the network connection\", e, ErrorManager.OPEN_FAILURE);\n      throw e;\n    }\n    super.internalSetOutputStream(new BufferedOutputStream(this.socket.getOutputStream()));\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7959, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [124], "initializationEnd": [153], "hasTryCatch": 1, "exceptionType": "UnknownHostException", "exceptionHandlingCall": ["println(String)", "exit(int)"], "tryExpressionStart": 23, "tryExpressionEnd": 27, "tryBlockStart": 23, "tryBlockEnd": 1783, "catchExpressionStart": 1529, "catchExpressionEnd": 1560, "catchBlockStart": 1529, "catchBlockEnd": 1652, "exceptionHandlingCallStart": [1568, 1631], "exceptionHandlingCallEnd": [1623, 1645], "configuration": ["socket.getInputStream()"], "configurationStart": [197], "configurationEnd": [226], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 249, "focalAPIEnd": 279, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/m-harper/TP2/tree/master/src/edu/mharper/tp2/GameClient.java", "rawCode": "  void connect() {\n    try {\n      clientSocket = null;\n\n      // replace Fanorona Server to 127.0.0.1\n      clientSocket = new Socket(\"127.0.0.1\", port);\n\n      // data stream\n      c_sockInput = clientSocket.getInputStream();\n      c_sockOutput = clientSocket.getOutputStream();\n\n      byte[] buf = new byte[1024];\n      // c_sockOutput.write(buf, 0, buf.length);\n\n      // WELCOME acknowledge\n      System.out.println(readCmd(buf));\n\n      // INFO statement\n      String str = readCmd(buf);\n      StringTokenizer st = new StringTokenizer(str);\n      st.nextToken();\n\n      int row = Integer.parseInt(st.nextToken());\n      int column = Integer.parseInt(st.nextToken());\n      st.nextToken();\n      str = st.nextToken();\n      ;\n      int time = Integer.parseInt(str);\n\n      Main.horizontalSpaces = row;\n      Main.verticalSpaces = column;\n      Main.defaultTime = time;\n      Main.windowHeight = Main.verticalSpaces * Main.tileSize;\n      Main.windowWidth = Main.horizontalSpaces * Main.tileSize;\n      Main.maxTurns = 10 * column;\n\n      // READ statement\n      writeCmd(\"READY\");\n\n      // BEGIN statement\n      System.out.println(readCmd(buf));\n\n      waitForMoves();\n\n      // Game started\n      /*str=readCmd(buf);\n      st = new StringTokenizer(str);\n      int x_prev = Integer.parseInt(st.nextToken());\n      int y_prev = Integer.parseInt(st.nextToken());\n      int x_next = Integer.parseInt(st.nextToken());\n      int y_next = Integer.parseInt(st.nextToken());*/\n\n      // remove(x_prev,y_prev,x_next,y_next);\n\n    } catch (UnknownHostException e) {\n      System.err.println(\"Don't know about host: 127.0.0.1.\");\n      System.exit(1);\n    } catch (IOException e) {\n      System.err.println(\"Couldn't get I/O for the connection to 127.0.0.1.\");\n      System.exit(1);\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7960, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "log(*)"], "tryExpressionStart": 62, "tryExpressionEnd": 66, "tryBlockStart": 62, "tryBlockEnd": 3019, "catchExpressionStart": 2947, "catchExpressionEnd": 2977, "catchBlockStart": 2947, "catchBlockEnd": 3019, "exceptionHandlingCallStart": [2989, 2985], "exceptionHandlingCallEnd": [3011, 3012], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 170, "focalAPIEnd": 195, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["socket.getInputStream()", "new PrintStream(outputStream)", "outputStream.close()", "socket.close()"], "useStart": [220, 427, 2886, 2923], "useEnd": [244, 446, 2896, 2938], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dyne/ZShaolin/tree/master/termapk/src/com/spartacusrex/spartacuside/web/sockethandler.java", "rawCode": "  public void run() {\n    log(\"Socket handler started\");\n\n    try {\n      // Wait a second..\n      Thread.sleep(250);\n\n      // Get the streams..\n      OutputStream os = mSocket.getOutputStream();\n      InputStream is = mSocket.getInputStream();\n\n      // Convert to something useful\n      BufferedReader br =\n          new BufferedReader(new InputStreamReader(new BufferedInputStream(is, 8192)), 8192);\n      PrintStream ps = new PrintStream(os);\n\n      // Read in complete command\n      StringBuffer sbuffer = new StringBuffer(\"\");\n      String in = null;\n      boolean keepalive = true;\n\n      while (keepalive && mRunning) {\n\n        // while( mRunning && (in = br.readLine()) != null){\n        if (mRunning && (in = br.readLine()) != null) {\n          /*if(in.equals(\"\")){\n          break;\n          }*/\n\n          // String in = br.readLine();\n          log(\"Server Read Line : \" + in);\n          sbuffer.append(in + \"\\n\");\n        }\n\n        // Log complete\n        String com = sbuffer.toString();\n\n        log(\"Server Complete : \" + com);\n\n        // Write somethinfg to the stream\n        ps.println(\"1 The server says hello!!\");\n        ps.println(\"2 The server says hello!!\");\n        ps.println(\"3 The server says hello!!\");\n\n        // Now process the command\n        if (false && !com.equals(\"\")) {\n          // Get Command Part\n          int space1 = com.indexOf(\" \");\n          int space2 = com.indexOf(\" \", space1 + 1);\n          String command = com.substring(0, space1).trim();\n          String getfile = com.substring(space1, space2).trim();\n\n          String urlfile = URLDecoder.decode(getfile);\n\n          log(\"READ FILE : .\" + urlfile);\n\n          File httpfile = new File(urlfile);\n\n          boolean head = command.equalsIgnoreCase(\"HEAD\");\n          boolean get = command.equalsIgnoreCase(\"GET\");\n\n          int index = com.indexOf(\"Keep-Alive\");\n          keepalive = (index != -1);\n          // log(\"FULL COMMAND : \"+com+\" INDEX:\"+index);\n\n          // Get the required range\n          long[] range = getRange(com);\n          if (range[0] == -1) {\n            range[0] = 0;\n            range[1] = httpfile.length();\n            log(\"No Range Specified..!\");\n          }\n\n          log(\"Write Head \" + range[0] + \" \" + range[1]);\n          writeHead(ps, httpfile);\n\n          // rangeavail = false;\n          if (get) {\n            log(\"Write File xx \" + range[0] + \" \" + range[1]);\n            // writeFromStream(ps, httpfile,range);\n            writeFile(ps, httpfile, range);\n          }\n\n          ps.flush();\n\n        } else {\n          // No Input\n          log(\"No Input - pausing..\");\n          keepalive = false;\n          Thread.sleep(100);\n        }\n\n        log(\"keepalive \" + keepalive);\n        if (keepalive) {\n          sbuffer = new StringBuffer(\"\");\n          in = null;\n        }\n      }\n\n      // Close streams..\n      ps.close();\n      os.close();\n      is.close();\n\n      mSocket.close();\n\n    } catch (Exception iOException) {\n      log(iOException.toString());\n    }\n\n    // Tell the server\n    mServer.sockethandlerFinished(this);\n\n    log(\"Finished\");\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7961, "initialization": ["Socket socket = new Socket()"], "initializationStart": [2081], "initializationEnd": [2093], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["Thread.printStackTrace()"], "tryExpressionStart": 2271, "tryExpressionEnd": 2275, "tryBlockStart": 2271, "tryBlockEnd": 3470, "catchExpressionStart": 3412, "catchExpressionEnd": 3432, "catchBlockStart": 3412, "catchBlockEnd": 3470, "exceptionHandlingCallStart": [3442], "exceptionHandlingCallEnd": [3461], "configuration": ["socket.setSoTimeout(int)", "socket.connect(InetSocketAddress,int)"], "configurationStart": [2101, 2853], "configurationEnd": [2126, 2891], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 3118, "focalAPIEnd": 3142, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(int)", "socket.close()"], "useStart": [3118, 3388], "useEnd": [3153, 3402], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ferquies/2dam/tree/master/AD/Tema 2/h2/src/tools/org/h2/build/Build.java", "rawCode": "  /** Test the local network of this machine. */\n  public void testNetwork() {\n    try {\n      long start = System.currentTimeMillis();\n      System.out.println(\"localhost:\");\n      System.out.println(\" \" + InetAddress.getByName(\"localhost\"));\n      for (InetAddress address : InetAddress.getAllByName(\"localhost\")) {\n        System.out.println(\" \" + address);\n      }\n      InetAddress localhost = InetAddress.getLocalHost();\n      System.out.println(\"getLocalHost:\" + localhost);\n      for (InetAddress address : InetAddress.getAllByName(localhost.getHostAddress())) {\n        System.out.println(\" \" + address);\n      }\n      InetAddress address = InetAddress.getByName(localhost.getHostAddress());\n      System.out.println(\"byName:\" + address);\n      ServerSocket serverSocket;\n      try {\n        serverSocket = new ServerSocket(0);\n      } catch (Exception e) {\n        e.printStackTrace();\n        serverSocket = new ServerSocket(0);\n      }\n      System.out.println(serverSocket);\n      int port = serverSocket.getLocalPort();\n      final ServerSocket accept = serverSocket;\n      start = System.currentTimeMillis();\n      Thread thread =\n          new Thread() {\n            @Override\n            public void run() {\n              try {\n                System.out.println(\"server accepting\");\n                Socket s = accept.accept();\n                Thread.sleep(100);\n                System.out.println(\"server accepted:\" + s);\n                System.out.println(\"server read:\" + s.getInputStream().read());\n                Thread.sleep(200);\n                s.getOutputStream().write(234);\n                Thread.sleep(100);\n                System.out.println(\"server closing\");\n                s.close();\n                System.out.println(\"server done\");\n              } catch (Throwable t) {\n                t.printStackTrace();\n              }\n            }\n          };\n      thread.start();\n      System.out.println(\"time: \" + (System.currentTimeMillis() - start));\n      Thread.sleep(1000);\n      start = System.currentTimeMillis();\n      final Socket socket = new Socket();\n      socket.setSoTimeout(2000);\n      final InetSocketAddress socketAddress = new InetSocketAddress(address, port);\n      System.out.println(\"client:\" + socketAddress);\n      try {\n        Thread t =\n            new Thread() {\n              @Override\n              public void run() {\n                try {\n                  socket.connect(socketAddress, 2000);\n                } catch (IOException e) {\n                  e.printStackTrace();\n                }\n              }\n            };\n        t.start();\n        t.join(5000);\n        if (!socket.isConnected()) {\n          final InetSocketAddress localhostAddress = new InetSocketAddress(\"localhost\", port);\n          System.out.println(\"not connected, trying localhost:\" + socketAddress);\n          socket.connect(localhostAddress, 2000);\n        }\n        System.out.println(\"time: \" + (System.currentTimeMillis() - start));\n        Thread.sleep(200);\n        start = System.currentTimeMillis();\n        System.out.println(\"client:\" + socket.toString());\n        socket.getOutputStream().write(123);\n        System.out.println(\"time: \" + (System.currentTimeMillis() - start));\n        Thread.sleep(100);\n        start = System.currentTimeMillis();\n        System.out.println(\"client read:\" + socket.getInputStream().read());\n        socket.close();\n      } catch (Throwable t) {\n        t.printStackTrace();\n      }\n      thread.join(5000);\n      System.out.println(\"time: \" + (System.currentTimeMillis() - start));\n      if (thread.isAlive()) {\n        System.out.println(\"thread is still alive, interrupting\");\n        thread.interrupt();\n      }\n      Thread.sleep(100);\n      System.out.println(\"done\");\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7962, "initialization": ["Socket socket = getClamdSocket()"], "initializationStart": [345], "initializationEnd": [361], "hasTryCatch": 1, "exceptionType": "UnsupportedEncodingException", "exceptionHandlingCall": ["getInetAddress()", "getMessage()", "Log.error(String)", "new VirusScanIncompleteException(String,*)"], "tryExpressionStart": 846, "tryExpressionEnd": 850, "tryBlockStart": 846, "tryBlockEnd": 3876, "catchExpressionStart": 2721, "catchExpressionEnd": 2760, "catchBlockStart": 2721, "catchBlockEnd": 2956, "exceptionHandlingCallStart": [1498, 2864, 2768, 2893], "exceptionHandlingCallEnd": [1521, 2878, 2879, 2949], "configuration": ["socket.getInputStream()"], "configurationStart": [997], "configurationEnd": [1020], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 1131, "focalAPIEnd": 1155, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)", "socket.getInetAddress()", "socket.close()"], "useStart": [1108, 1498, 3802], "useEnd": [1156, 1521, 3816], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 3426, "finallyExpressionEnd": 3434, "finallyBlockStart": 3426, "finallyBlockEnd": 3876, "cleanUpCallStart": [3489], "cleanUpCallEnd": [3503], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/KNL-1011/kernel-impl/src/main/java/org/sakaiproject/antivirus/impl/ClamAVScanner.java", "rawCode": "  protected void doScan(InputStream in) throws VirusScanIncompleteException, VirusFoundException {\n    logger.debug(\"doingScan!\");\n    Socket socket = null;\n    String virus = null;\n    long start = System.currentTimeMillis();\n    // this could be a null or zero lenght stream\n    if (in == null) {\n      return;\n    }\n\n    try {\n      socket = getClamdSocket();\n    } catch (UnknownHostException e) {\n      logger.error(\"could not connect to host for virus check: \" + e);\n      throw new VirusScanIncompleteException(SCAN_INCOMPLETE_MSG);\n    }\n    if (socket == null || !socket.isConnected()) {\n      logger.warn(\"scan is inclomplete!\");\n      throw new VirusScanIncompleteException(SCAN_INCOMPLETE_MSG);\n    }\n    BufferedReader reader = null;\n    PrintWriter writer = null;\n    Socket streamSocket = null;\n    boolean virusFound = false;\n    try {\n\n      // prepare the reader and writer for the commands\n      boolean autoFlush = true;\n      reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"ASCII\"));\n      writer =\n          new PrintWriter(\n              new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), autoFlush);\n      // write a request for a port to use for streaming out the data to scan\n      writer.println(\"STREAM\");\n\n      // parse and get the \"stream\" port#\n      int streamPort = getStreamPortFromAnswer(reader.readLine());\n\n      // get the \"stream\" socket and the related (buffered) output stream\n      streamSocket = new Socket(socket.getInetAddress(), streamPort);\n      OutputStream os = streamSocket.getOutputStream();\n\n      // stream out the message to the scanner\n      int data;\n      // -1 signals the end of the data stream\n      while ((data = in.read()) > -1) {\n        os.write(data);\n      }\n      os.flush();\n      os.close();\n      streamSocket.close();\n\n      String logMessage = \"\";\n      String answer = null;\n      for (int i = 0; i < 100; ++i) {\n        answer = reader.readLine();\n        if (answer != null) {\n          answer = answer.trim();\n\n          // if a virus is found the answer will be '... FOUND'\n          if (answer.substring(answer.length() - FOUND_STRING.length()).equals(FOUND_STRING)) {\n            virusFound = true;\n            logMessage = answer + \" (by virus scanner)\";\n            // virus = answer.substring(answer.indexOf(\":\" + 1));\n            virus = answer.substring(0, answer.indexOf(FOUND_STRING)).trim();\n            logger.debug(logMessage);\n          } else {\n            logger.debug(\"no virus found: \" + answer);\n          }\n        } else {\n          break;\n        }\n      }\n      long finish = System.currentTimeMillis();\n      logger.debug(\"Content scanned in \" + (finish - start));\n    } catch (UnsupportedEncodingException e) {\n      logger.error(\n          \"Exception caught calling CLAMD on \" + socket.getInetAddress() + \": \" + e.getMessage());\n      throw new VirusScanIncompleteException(SCAN_INCOMPLETE_MSG, e);\n    } catch (IOException e) {\n      // we expect a connection reset if we tried to send too much data to clamd\n      if (\"Connection reset\".equals(e.getMessage())) {\n        logger.warn(\"Clamd reset the connection maybe due to the file being too large\");\n        return;\n      }\n      logger.error(\n          \"Exception caught calling CLAMD on \" + socket.getInetAddress() + \": \" + e.getMessage());\n      throw new VirusScanIncompleteException(SCAN_INCOMPLETE_MSG, e);\n\n    } finally {\n\n      if (reader != null) {\n        try {\n          reader.close();\n        } catch (IOException e) {\n        }\n      }\n      if (writer != null) {\n        writer.close();\n      }\n      if (streamSocket != null) {\n        try {\n          streamSocket.close();\n        } catch (IOException e) {\n\n        }\n      }\n      if (socket != null) {\n        try {\n          socket.close();\n        } catch (IOException e) {\n\n        }\n      }\n    }\n    if (virusFound) {\n      logger.info(\"Virus detected!: \" + virus);\n      throw new VirusFoundException(virus);\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7963, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [75], "initializationEnd": [104], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 129, "focalAPIEnd": 148, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["socket.getInputStream()", "outputStream.write(byte[])", "outputStream.flush()", "outputStream.close()", "socket.close()"], "useStart": [171, 401, 419, 1099, 1116], "useEnd": [189, 413, 430, 1110, 1125], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/weishengshui/posserver/tree/master/testing/src/main/java/com/chinarewards/qqgbpvn/testing/util/SocketUtil.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    Socket s = new Socket(\"127.0.0.1\", 1234);\n    OutputStream out = s.getOutputStream();\n    InputStream in = s.getInputStream();\n\n    byte[] x = {\n      0, 0, 0, 1, 32, 0, 0, 4, 0, 0, -102, -74, 0, 0, 0, 32, 0, 0, 0, 5, 84, 45, 48, 48, 48, 48, 48,\n      48, 48, 48, 48, 49\n    };\n    System.out.println(\"package length:\" + x.length);\n\n    out.write(x);\n    out.flush();\n\n    byte[] res = new byte[0];\n    byte[] b = new byte[BUFF_SIZE];\n    int amt = -1;\n\n    while (true) {\n      amt = in.read(b);\n      logger.debug(\"read bytes amt:\" + amt);\n\n      byte[] temp = new byte[res.length + amt];\n      System.arraycopy(res, 0, temp, 0, res.length);\n      System.arraycopy(b, 0, temp, res.length, amt);\n      res = temp;\n\n      if (res.length > (12 + 4)) {\n        byte[] messageSizeBytes = new byte[4];\n        System.arraycopy(res, 12, messageSizeBytes, 0, 4);\n        long messageSize = Tools.byteToUnsignedInt(messageSizeBytes);\n\n        if (new Long(\"\" + res.length).equals(messageSize)) {\n          break;\n        }\n      }\n    }\n\n    out.close();\n    s.close();\n\n    System.out.println(Arrays.toString(res));\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7964, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 149, "focalAPIEnd": 177, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)"], "useStart": [126], "useEnd": [178], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sneaker/Mediastopf/tree/master/Code/src/ms/utils/networking/BasicNetIO.java", "rawCode": "  protected void sendMessage(String message) throws IOException {\n    PrintWriter sender = null;\n    sender = new PrintWriter(new OutputStreamWriter(commSocket.getOutputStream()), false);\n\n    sender.println(message);\n    sender.flush();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7965, "initialization": ["Socket socket = new Socket(*,*)"], "initializationStart": [262], "initializationEnd": [304], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 406, "focalAPIEnd": 425, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)", "socket.getInputStream()", "socket.close()"], "useStart": [383, 703, 2409], "useEnd": [426, 721, 2418], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.7.2/trunk/src/om/loadtest/TNTester.java", "rawCode": "  private void sendRequestGetMedia(int iServer, Map mTokens, HttpScript.Item i, StepStats ss)\n      throws IOException {\n    if (DEBUG) System.err.print(\" \" + i.getURL());\n    ss.sPath = i.getURL();\n    long lBefore = System.currentTimeMillis();\n\n    Socket s = new Socket(HOSTS[iServer], PORTS[iServer]);\n    // Again with the dodgy charset assumptions\n    OutputStreamWriter osw = new OutputStreamWriter(s.getOutputStream());\n    String sRequest = i.getRequest();\n    sRequest = XML.replaceTokens(sRequest, \"%%\", mTokens).replaceAll(\"HTTP/1.1\", \"HTTP/1.0\");\n    osw.write(sRequest + \"\\r\\n\");\n    if (i.getData() != null) osw.write(i.getData());\n    osw.flush();\n\n    // Get input\n    InputStream is = s.getInputStream();\n    String sLine = \"\";\n    int iContentLength = -1;\n    boolean bFirst = true;\n    while (true) {\n      int iChar = is.read();\n      if (iChar == -1) throw new IOException(\"Unexpected EOF in socket input\");\n      if (iChar == 10) {\n        if (sLine.equals(\"\")) break; // End of headers\n        Matcher m = HttpScript.CONTENTLENGTH.matcher(sLine);\n        if (m.matches()) iContentLength = Integer.parseInt(m.group(1));\n        if (bFirst) {\n          bFirst = false;\n          Matcher mStatus = HttpScript.STATUSCODE.matcher(sLine);\n          if (!mStatus.matches()) throw new IOException(\"Unexpected HTTP status format: \" + sLine);\n          if (Integer.parseInt(mStatus.group(1)) != i.getExpectedResponse())\n            throw new IOException(\n                \"Unexpected response code: \"\n                    + sLine\n                    + \" (expecting \"\n                    + i.getExpectedResponse()\n                    + \")\\n\"\n                    + IO.loadString(is));\n        }\n        // System.err.println(sLine);\n        sLine = \"\";\n      } else if (iChar != 13) {\n        sLine += (char) iChar;\n      }\n    }\n\n    byte[] abData;\n    if (iContentLength != -1) {\n      abData = new byte[iContentLength];\n      for (int iRead = 0; iRead < abData.length; ) {\n        int iThisTime = is.read(abData, iRead, abData.length - iRead);\n        if (iThisTime == -1) throw new IOException(\"Didn't get all data\");\n        iRead += iThisTime;\n      }\n    } else {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      while (true) {\n        int iRead = is.read();\n        if (iRead == -1) break;\n        baos.write(iRead);\n      }\n      abData = baos.toByteArray();\n    }\n    s.close();\n\n    ss.lTime = System.currentTimeMillis() - lBefore;\n    if (DEBUG) {\n      System.err.print(\" [\" + abData.length + \" bytes]\");\n      System.err.println(\" (\" + ss.lTime + \" ms)\");\n    }\n\n    // OK now go through looking for *.gif, jpg, .css, .png\n    String sContent = new String(abData);\n    Set<String> sDone = new HashSet<String>();\n    Matcher m = MEDIALINK.matcher(sContent);\n    while (m.find()) {\n      String sURL = m.group(1);\n      if (sDone.contains(sURL)) continue;\n      sDone.add(sURL);\n\n      sURL =\n          \"http://\"\n              + HOSTS[iServer]\n              + (PORTS[iServer] != 80 ? (\":\" + PORTS[iServer]) : \"\")\n              + \"/om-tn/simple1/\"\n              + sURL;\n      sURL = sURL.replaceAll(\"simple1/../\", \"\");\n\n      loadMedia(mTokens, new URL(sURL), ss);\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7966, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 100, "focalAPIEnd": 134, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new HangingOutputStream(outputStream,Properties,String)"], "useStart": [76], "useEnd": [159], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Yoldark34/NemoVelo/tree/master/libs/mysql-connector-java-5.1.24/src/testsuite/UnreliableSocketFactory.java", "rawCode": "    public OutputStream getOutputStream() throws IOException {\n      return new HangingOutputStream(underlyingSocket.getOutputStream(), props, aliasedHostname);\n    }\n"}, {"dataset": "getOutputStream", "exampleID": 7967, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()", "getMessage()", "getBytes(String)"], "tryExpressionStart": 252, "tryExpressionEnd": 256, "tryBlockStart": 252, "tryBlockEnd": 2075, "catchExpressionStart": 1280, "catchExpressionEnd": 1300, "catchBlockStart": 1280, "catchBlockEnd": 1583, "exceptionHandlingCallStart": [1308, 1438, 1421], "exceptionHandlingCallEnd": [1327, 1452, 1471], "configuration": ["socket.getInputStream()"], "configurationStart": [292], "configurationEnd": [315], "guardCondition": "!(null==socket)", "guardType": "IF {", "guardExpressionStart": 38, "guardExpressionEnd": 57, "guardBlockStart": 38, "guardBlockEnd": 65, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 354, "focalAPIEnd": 378, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)"], "useStart": [333], "useEnd": [379], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/delver/simplenlg/tree/master/src/simplenlg/server/RealisationRequest.java", "rawCode": "  @Override\n  public void run() {\n    if (null == socket) return;\n\n    DataInputStream input = null;\n    DataOutputStream output = null;\n\n    if (DEBUG) {\n      System.out.println(\"Client connected from \" + socket.getRemoteSocketAddress());\n    }\n\n    try {\n      input = new DataInputStream(socket.getInputStream());\n      output = new DataOutputStream(socket.getOutputStream());\n\n      // read the message length\n      int msgLen = input.readInt();\n\n      // create a buffer\n      byte[] data = new byte[msgLen];\n      // read the entire message (blocks until complete)\n      input.readFully(data);\n\n      if (data.length < 1) {\n        throw new Exception(\"Client did not send data.\");\n      }\n\n      // now convert the raw bytes to utf-8\n      String tmp = new String(data, \"UTF-8\");\n      StringReader reader = new StringReader(tmp);\n\n      // get the realisation\n      String result = doRealisation(reader).trim();\n\n      // convert the string to raw bytes\n      byte[] tmp2 = result.getBytes(\"UTF-8\");\n\n      // write the length\n      output.writeInt(tmp2.length);\n      // write the data\n      output.write(tmp2);\n\n      if (DEBUG) {\n        String text = \"The following realisation was sent to client:\";\n        System.out.println(text + \"\\n\\t\" + result);\n      }\n\n    } catch (Exception e) {\n      e.printStackTrace();\n      try {\n        // attempt to send the error message to the client\n        byte[] tmp = (\"Exception: \" + e.getMessage()).getBytes(\"UTF-8\");\n        output.writeInt(tmp.length);\n        output.write(tmp);\n      } catch (IOException e1) {\n      }\n    } catch (XMLRealiserException e) {\n      e.printStackTrace();\n      try {\n        // attempt to send the error message to the client\n        byte[] tmp = (\"Exception: \" + e.getMessage()).getBytes(\"UTF-8\");\n        output.writeInt(tmp.length);\n        output.write(tmp);\n      } catch (IOException e1) {\n      }\n    } finally {\n      try {\n        socket.close();\n        socket = null;\n      } catch (IOException e) {\n        System.err.println(\"Could not close client socket!\");\n      }\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7968, "initialization": ["Socket socket = new Socket()"], "initializationStart": [162], "initializationEnd": [174], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.connect(InetSocketAddress,int)", "socket.getLocalAddress()"], "configurationStart": [180, 332], "configurationEnd": [235, 356], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 535, "focalAPIEnd": 559, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)", "socket.getInputStream()"], "useStart": [512, 750], "useEnd": [560, 773], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Cougar/mirror-openhab/tree/master/bundles/binding/org.openhab.binding.samsungtv/src/main/java/de/quist/samy/remocon/RemoteSession.java", "rawCode": "  private String initialize() throws UnknownHostException, IOException {\n    logger.debug(\"Creating socket for host \" + host + \" on port \" + port);\n\n    socket = new Socket();\n    socket.connect(new InetSocketAddress(host, port), 5000);\n\n    logger.debug(\"Socket successfully created and connected\");\n    InetAddress localAddress = socket.getLocalAddress();\n    logger.debug(\"Local address is \" + localAddress.getHostAddress());\n\n    logger.debug(\"Sending registration message\");\n    writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n    writer.append((char) 0x00);\n    writeText(writer, APP_STRING);\n    writeText(writer, getRegistrationPayload(localAddress.getHostAddress()));\n    writer.flush();\n\n    InputStream in = socket.getInputStream();\n    reader = new InputStreamReader(in);\n    String result = readRegistrationReply(reader);\n    // sendPart2();\n    int i;\n    while ((i = in.available()) > 0) {\n      in.skip(i);\n    }\n    return result;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7969, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 869, "focalAPIEnd": 888, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["socket.getInputStream()", "socket.setSoTimeout(int)", "outputStream.write(byte[],int,*)", "outputStream.write(byte[],int,int)", "outputStream.write(String)"], "useStart": [911, 935, 1064, 1109, 1139], "useEnd": [929, 954, 1101, 1131, 1165], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CSEMike/OneSwarm/tree/master/az_src/jsocks/net/sourceforge/jsocks/test/TestService.java", "rawCode": "  /**\n   * Generates characters and sends them to the socket.\n   *\n   * <p>Unlike usual chargen (port 19), each next line of the generated output is send after\n   * increasingly larger time intervals. It starts from wait_time (ms), and each next time wait time\n   * is doubled. Eg. 1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 ... well you got the idea.\n   *\n   * <p>It starts if either connection is clsoed or the wait time grows bigger than max_wait.\n   *\n   * @param s Socket on which to perform service.\n   * @param wait_time Time in ms, from which timing sequence should begin.\n   * @param max_wait Time in ms, after reaching timeout greater than this value, chargen will stop.\n   */\n  public static void chargen(Socket s, long wait_time, long max_wait) throws IOException {\n    byte[] buf = chargenSequence.getBytes();\n    int pos = 0;\n    OutputStream out = s.getOutputStream();\n    InputStream in = s.getInputStream();\n    s.setSoTimeout(100); // 0.1 ms\n\n    log(\"Starting \\\"chargen\\\" on \" + s);\n    while (true) {\n      log(\"Sending message.\");\n      out.write(buf, pos, buf.length - pos);\n      out.write(buf, 0, pos);\n      out.write(\"\\n\".getBytes());\n      pos++;\n      try {\n        if (wait_time > max_wait) break;\n\n        log(\"Going to sleep for \" + wait_time + \" ms.\");\n        Thread.currentThread().sleep(wait_time);\n        wait_time *= 2;\n        if (in.read() < 0) break; // Connection closed\n      } catch (InterruptedException ie) {\n      } catch (InterruptedIOException ioe) {\n      }\n    }\n    log(\"Chargen finished.\");\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7970, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 389, "focalAPIEnd": 413, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new StreamOutputStream(*,outputStream)", "socket.getOutputStream()", "new BlockOutputStream(*,outputStream)", "socket.getOutputStream()", "new CompressedOutputStream(*,outputStream)"], "useStart": [360, 510, 482, 641, 608], "useEnd": [414, 534, 535, 665, 666], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/redstar3894/android-gcc/tree/master/libjava/classpath/gnu/java/net/protocol/ftp/ActiveModeDTP.java", "rawCode": "  /** Returns an output stream to which a local file can be written for upload. */\n  public OutputStream getOutputStream() throws IOException {\n    if (inProgress) {\n      throw new IOException(\"Transfer in progress\");\n    }\n    if (acceptThread != null) {\n      waitFor();\n    }\n    switch (transferMode) {\n      case FTPConnection.MODE_STREAM:\n        out = new StreamOutputStream(this, socket.getOutputStream());\n        break;\n      case FTPConnection.MODE_BLOCK:\n        out = new BlockOutputStream(this, socket.getOutputStream());\n        break;\n      case FTPConnection.MODE_COMPRESSED:\n        out = new CompressedOutputStream(this, socket.getOutputStream());\n        break;\n      default:\n        throw new IllegalStateException(\"invalid transfer mode\");\n    }\n    out.setTransferComplete(false);\n    return out;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7971, "initialization": ["Socket socket = new Socket(String,*)"], "initializationStart": [568], "initializationEnd": [619], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 649, "focalAPIEnd": 673, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(String)", "outputStream.flush()", "socket.setSoTimeout(int)", "socket.getInputStream()", "outputStream.write(*)", "outputStream.write(*)", "outputStream.write(*)", "outputStream.write(*)", "outputStream.write(*)", "outputStream.write(*)", "outputStream.flush()"], "useStart": [681, 1267, 1290, 1345, 2243, 2271, 2299, 2327, 2355, 2383, 2411], "useEnd": [1259, 1281, 1317, 1368, 2261, 2289, 2317, 2345, 2373, 2401, 2425], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thomasbecker/jetty-spdy/tree/master/jetty-websocket/src/test/java/org/eclipse/jetty/websocket/WebSocketMessageRFC6455Test.java", "rawCode": "  @Test\n  public void testCloseOut() throws Exception {\n    int[][] tests = {\n      {-1, 0, -1},\n      {-1, 0, -1},\n      {0, 2, 1000},\n      {0, 2 + 4, 1000},\n      {1000, 2, 1000},\n      {1000, 2 + 4, 1000},\n      {1005, 0, -1},\n      {1005, 0, -1},\n      {1006, 0, -1},\n      {1006, 0, -1},\n      {9000, 2, 9000},\n      {9000, 2 + 4, 9000}\n    };\n\n    String[] mesg = {\n      null, \"Not Sent\", null, \"mesg\", null, \"mesg\", null, \"mesg\", null, \"mesg\", null, \"mesg\"\n    };\n\n    for (int t = 0; t < tests.length; t++) {\n      String tst = \"\" + t;\n      Socket socket = new Socket(\"localhost\", __connector.getLocalPort());\n      OutputStream output = socket.getOutputStream();\n      output.write(\n          (\"GET /chat HTTP/1.1\\r\\n\"\n                  + \"Host: server.example.com\\r\\n\"\n                  + \"Upgrade: websocket\\r\\n\"\n                  + \"Connection: Upgrade\\r\\n\"\n                  + \"Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\\r\\n\"\n                  + \"Sec-WebSocket-Origin: http://example.com\\r\\n\"\n                  + \"Sec-WebSocket-Protocol: chat\\r\\n\"\n                  + \"Sec-WebSocket-Version: \"\n                  + WebSocketConnectionRFC6455.VERSION\n                  + \"\\r\\n\"\n                  + \"\\r\\n\")\n              .getBytes(\"ISO-8859-1\"));\n      output.flush();\n\n      socket.setSoTimeout(100000);\n      InputStream input = socket.getInputStream();\n\n      lookFor(\"HTTP/1.1 101 Switching Protocols\\r\\n\", input);\n      skipTo(\"Sec-WebSocket-Accept: \", input);\n      lookFor(\"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\", input);\n      skipTo(\"\\r\\n\\r\\n\", input);\n\n      assertTrue(__serverWebSocket.awaitConnected(1000));\n      assertNotNull(__serverWebSocket.connection);\n\n      __serverWebSocket.getConnection().close(tests[t][0], mesg[t]);\n\n      byte[] buf = new byte[128];\n      int len = input.read(buf);\n      assertEquals(tst, 2 + tests[t][1], len);\n      assertEquals(tst, (byte) 0x88, buf[0]);\n\n      if (len >= 4) {\n        int code = (0xff & buf[2]) * 0x100 + (0xff & buf[3]);\n        assertEquals(tst, tests[t][2], code);\n\n        if (len > 4) {\n          String m = new String(buf, 4, len - 4, \"UTF-8\");\n          assertEquals(tst, mesg[t], m);\n        }\n      } else assertEquals(tst, tests[t][2], -1);\n\n      try {\n        output.write(0x88);\n        output.write(0x80);\n        output.write(0x00);\n        output.write(0x00);\n        output.write(0x00);\n        output.write(0x00);\n        output.flush();\n      } catch (IOException e) {\n        System.err.println(\"socket \" + socket);\n        throw e;\n      }\n\n      len = input.read(buf);\n      assertEquals(tst, -1, len);\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7972, "initialization": ["Socket socket = ServerSocket.accept()"], "initializationStart": [795], "initializationEnd": [816], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "fail(String)"], "tryExpressionStart": 451, "tryExpressionEnd": 455, "tryBlockStart": 451, "tryBlockEnd": 11492, "catchExpressionStart": 11064, "catchExpressionEnd": 11084, "catchBlockStart": 11064, "catchBlockEnd": 11492, "exceptionHandlingCallStart": [11470, 11378], "exceptionHandlingCallEnd": [11482, 11483], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 910, "focalAPIEnd": 936, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(*)", "outputStream.flush()", "socket.sendUrgentData(byte)", "outputStream.write(*)", "outputStream.flush()", "socket.getOutputStream()", "outputStream.write(*)", "outputStream.flush()", "socket.sendUrgentData(byte)", "outputStream.write(*)", "outputStream.flush()", "socket.getOutputStream()", "outputStream.write(*)", "outputStream.flush()", "socket.sendUrgentData(byte)", "socket.sendUrgentData(byte)", "outputStream.write(*)", "outputStream.flush()", "socket.getOutputStream()", "outputStream.write(*)", "outputStream.flush()", "socket.sendUrgentData(byte)", "outputStream.write(*)", "outputStream.flush()", "outputStream.write(*)", "outputStream.flush()", "socket.sendUrgentData(byte)", "outputStream.write(*)", "outputStream.flush()", "outputStream.write(*)", "outputStream.flush()", "socket.sendUrgentData(byte)", "outputStream.write(*)", "outputStream.flush()", "socket.getOutputStream()", "socket.sendUrgentData(byte)"], "useStart": [1028, 1076, 1204, 1263, 1311, 2497, 2622, 2670, 2793, 2853, 2901, 4092, 4217, 4265, 4392, 4451, 4511, 4559, 5960, 6091, 6141, 6270, 6332, 6382, 7199, 7249, 7383, 7477, 7527, 8421, 8471, 8606, 8668, 8718, 10337, 10474], "useEnd": [1066, 1093, 1253, 1301, 1328, 2523, 2660, 2687, 2842, 2891, 2918, 4118, 4255, 4282, 4441, 4500, 4549, 4576, 5986, 6129, 6158, 6319, 6370, 6399, 7237, 7266, 7432, 7515, 7544, 8459, 8488, 8655, 8706, 8735, 10363, 10523], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/libcore/java/net/OldSocketTest.java", "rawCode": "  public void test_sendUrgentDataI() {\n\n    // Some platforms may not support urgent data in this case we will not\n    // run these tests. For now run on all platforms until we find those\n    // that do not support urgent data\n    String platform = System.getProperty(\"os.name\");\n    if (!platform.equals(\"Dummy\")) {\n      // validate that when OOBInline is false that any urgent data\n      // is silently ignored\n      String urgentData = \"U\";\n      try {\n        InetSocketAddress theAddress =\n            new InetSocketAddress(InetAddress.getLocalHost(), Support_PortManager.getNextPort());\n        Socket theSocket = new Socket();\n        ServerSocket serverSocket = new ServerSocket();\n        serverSocket.bind(theAddress);\n        theSocket.connect(theAddress);\n        Socket servSock = serverSocket.accept();\n        InputStream theInput = theSocket.getInputStream();\n        OutputStream theOutput = servSock.getOutputStream();\n\n        // send the regular data\n        String sendString = new String(\"Test\");\n        theOutput.write(sendString.getBytes());\n        theOutput.flush();\n\n        // send the urgent data which should not be received\n        theSocket.setOOBInline(false);\n        servSock.sendUrgentData(urgentData.getBytes()[0]);\n        theOutput.write(sendString.getBytes());\n        theOutput.flush();\n\n        // give things some time to settle\n        Thread.sleep(1000);\n\n        int totalBytesRead = 0;\n        byte[] myBytes = new byte[100];\n        while (theInput.available() > 0) {\n          int bytesRead = theInput.read(myBytes, totalBytesRead, myBytes.length - totalBytesRead);\n          totalBytesRead = totalBytesRead + bytesRead;\n        }\n\n        String receivedString = new String(myBytes, 0, totalBytesRead);\n        // assertTrue(\"Urgent Data seems to have been received:\"\n        // + receivedString + \":\" + sendString, receivedString\n        // .equals(sendString + sendString));\n\n        theSocket.close();\n        serverSocket.close();\n\n        // now validate that urgent data is received as expected. Expect\n        // that it should be between the two writes.\n        theAddress =\n            new InetSocketAddress(InetAddress.getLocalHost(), Support_PortManager.getNextPort());\n        theSocket = new Socket();\n        serverSocket = new ServerSocket();\n        serverSocket.bind(theAddress);\n        theSocket.connect(theAddress);\n        servSock = serverSocket.accept();\n        theInput = theSocket.getInputStream();\n        theOutput = servSock.getOutputStream();\n\n        // send the regular data\n        sendString = new String(\"Test - Urgent Data\");\n        theOutput.write(sendString.getBytes());\n        theOutput.flush();\n\n        // send the urgent data which should be received\n        theSocket.setOOBInline(true);\n        servSock.sendUrgentData(urgentData.getBytes()[0]);\n\n        theOutput.write(sendString.getBytes());\n        theOutput.flush();\n\n        Thread.sleep(1000);\n\n        totalBytesRead = 0;\n        myBytes = new byte[100];\n        while (theInput.available() > 0) {\n          int bytesRead = theInput.read(myBytes, totalBytesRead, myBytes.length - totalBytesRead);\n          totalBytesRead = totalBytesRead + bytesRead;\n        }\n\n        receivedString = new String(myBytes, 0, totalBytesRead);\n        assertTrue(\n            \"Urgent Data was not received with one urgent byte:\"\n                + receivedString\n                + \":\"\n                + sendString\n                + urgentData\n                + sendString,\n            receivedString.equals(sendString + urgentData + sendString));\n\n        theSocket.close();\n        serverSocket.close();\n\n        // now test case where we try to send two urgent bytes.\n        theAddress =\n            new InetSocketAddress(InetAddress.getLocalHost(), Support_PortManager.getNextPort());\n        theSocket = new Socket();\n        serverSocket = new ServerSocket();\n        serverSocket.bind(theAddress);\n        theSocket.connect(theAddress);\n        servSock = serverSocket.accept();\n        theInput = theSocket.getInputStream();\n        theOutput = servSock.getOutputStream();\n\n        // send the regular data\n        sendString = new String(\"Test - Urgent Data\");\n        theOutput.write(sendString.getBytes());\n        theOutput.flush();\n\n        // send the urgent data which should not be received\n        theSocket.setOOBInline(true);\n        servSock.sendUrgentData(urgentData.getBytes()[0]);\n        servSock.sendUrgentData(urgentData.getBytes()[0]);\n\n        theOutput.write(sendString.getBytes());\n        theOutput.flush();\n\n        Thread.sleep(1000);\n\n        totalBytesRead = 0;\n        myBytes = new byte[100];\n        while (theInput.available() > 0) {\n          int bytesRead = theInput.read(myBytes, totalBytesRead, myBytes.length - totalBytesRead);\n          totalBytesRead = totalBytesRead + bytesRead;\n        }\n\n        receivedString = new String(myBytes, 0, totalBytesRead);\n        assertTrue(\n            \"Did not get right byte of urgent data when two sent:\"\n                + receivedString\n                + \":\"\n                + sendString\n                + urgentData\n                + urgentData\n                + sendString,\n            receivedString.equals(sendString + urgentData + urgentData + sendString));\n\n        theSocket.close();\n        serverSocket.close();\n\n        /*\n         * TODO : These do not currently pass on XP SP2 and Server 2003\n         */\n        if (!platform.startsWith(\"Windows\")) {\n          // now test the case were we send turn the OOBInline on/off\n          theAddress =\n              new InetSocketAddress(InetAddress.getLocalHost(), Support_PortManager.getNextPort());\n          theSocket = new Socket();\n          serverSocket = new ServerSocket();\n          serverSocket.bind(theAddress);\n          theSocket.connect(theAddress);\n          servSock = serverSocket.accept();\n          theInput = theSocket.getInputStream();\n          theOutput = servSock.getOutputStream();\n\n          // send the regular data\n          sendString = new String(\"Test - Urgent Data\");\n          theOutput.write(sendString.getBytes());\n          theOutput.flush();\n\n          // send the urgent data which should be received\n          theSocket.setOOBInline(true);\n          servSock.sendUrgentData(urgentData.getBytes()[0]);\n\n          theOutput.write(sendString.getBytes());\n          theOutput.flush();\n\n          Thread.sleep(1000);\n\n          totalBytesRead = 0;\n          myBytes = new byte[100];\n          while (theInput.available() > 0) {\n            int bytesRead = theInput.read(myBytes, totalBytesRead, myBytes.length - totalBytesRead);\n            totalBytesRead = totalBytesRead + bytesRead;\n          }\n\n          receivedString = new String(myBytes, 0, totalBytesRead);\n          assertTrue(\n              \"Did not get urgent data when turning on/off(1):\"\n                  + receivedString\n                  + \":\"\n                  + sendString\n                  + urgentData\n                  + sendString,\n              receivedString.equals(sendString + urgentData + sendString));\n\n          // send the regular data\n          sendString = new String(\"Test - Urgent Data\");\n          theOutput.write(sendString.getBytes());\n          theOutput.flush();\n\n          // send the urgent data which should not be received\n          theSocket.setOOBInline(false);\n          servSock.sendUrgentData(urgentData.getBytes()[0]);\n\n          // send trailing data\n          theOutput.write(sendString.getBytes());\n          theOutput.flush();\n\n          Thread.sleep(1000);\n\n          totalBytesRead = 0;\n          myBytes = new byte[100];\n          while (theInput.available() > 0) {\n            int bytesRead = theInput.read(myBytes, totalBytesRead, myBytes.length - totalBytesRead);\n            totalBytesRead = totalBytesRead + bytesRead;\n          }\n\n          receivedString = new String(myBytes, 0, totalBytesRead);\n          // assertTrue(\n          // \"Got unexpected data data when turning on/off(2):\"\n          // + receivedString + \":\" + sendString\n          // + sendString, receivedString\n          // .equals(sendString + sendString));\n\n          // now turn back on and get data. Here we also\n          // get the previously sent byte of urgent data as it is\n          // still in the urgent buffer\n\n          // send the regular data\n          sendString = new String(\"Test - Urgent Data\");\n          theOutput.write(sendString.getBytes());\n          theOutput.flush();\n\n          // send the urgent data which should be received again\n          theSocket.setOOBInline(true);\n          servSock.sendUrgentData(urgentData.getBytes()[0]);\n\n          theOutput.write(sendString.getBytes());\n          theOutput.flush();\n\n          Thread.sleep(1000);\n\n          totalBytesRead = 0;\n          myBytes = new byte[100];\n          while (theInput.available() > 0) {\n            int bytesRead = theInput.read(myBytes, totalBytesRead, myBytes.length - totalBytesRead);\n            totalBytesRead = totalBytesRead + bytesRead;\n          }\n\n          receivedString = new String(myBytes, 0, totalBytesRead);\n          // depending on the platform we may get the previously sent\n          // urgent data or not (examples windows-yes, Linux-no).\n          // So accept either so long as we get the urgent data from\n          // when it was on.\n          // assertTrue(\n          // \"Did not get urgent data when turning on/off(3) GOT:\"\n          // + receivedString + \":Expected\" + urgentData\n          // + sendString + urgentData + sendString\n          // + \":OR:\" + sendString + urgentData\n          // + sendString,\n          // (receivedString.equals(urgentData + sendString\n          // + urgentData + sendString) || receivedString\n          // .equals(sendString + urgentData\n          // + sendString)));\n\n          theSocket.close();\n          serverSocket.close();\n        }\n\n        // now test the case where there is only urgent data\n        theAddress =\n            new InetSocketAddress(InetAddress.getLocalHost(), Support_PortManager.getNextPort());\n        theSocket = new Socket();\n        serverSocket = new ServerSocket();\n        serverSocket.bind(theAddress);\n        theSocket.connect(theAddress);\n        servSock = serverSocket.accept();\n        theInput = theSocket.getInputStream();\n        theOutput = servSock.getOutputStream();\n\n        // send the urgent data which should not be received.\n        theSocket.setOOBInline(true);\n        servSock.sendUrgentData(urgentData.getBytes()[0]);\n\n        Thread.sleep(1000);\n\n        totalBytesRead = 0;\n        myBytes = new byte[100];\n        while (theInput.available() > 0) {\n          int bytesRead = theInput.read(myBytes, totalBytesRead, myBytes.length - totalBytesRead);\n          totalBytesRead = totalBytesRead + bytesRead;\n        }\n\n        receivedString = new String(myBytes, 0, totalBytesRead);\n        assertTrue(\n            \"Did not get urgent data only urgent data sent:\" + receivedString + \":\" + urgentData,\n            receivedString.equals(urgentData));\n\n      } catch (Exception e) {\n        // for platforms that do not support urgent data we expect an\n        // exception. For the others report an error.\n        // TODO : Need to introduce a better test for the exception\n        // so that the failure only occurs on platforms that support\n        // urgent data\n        fail(\n            \"Platform:\" + platform + \": Got exception during sendUrgent data tests\" + e.toString());\n      }\n    }\n\n    try {\n      Socket theSocket = new Socket();\n      theSocket.close();\n      theSocket.sendUrgentData(0);\n      fail(\"IOException was not thrown.\");\n    } catch (IOException ioe) {\n      // expected\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7973, "initialization": ["Socket socket = new Socket(InetAddress,int)"], "initializationStart": [245], "initializationEnd": [282], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 315, "focalAPIEnd": 341, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)", "socket.getInputStream()"], "useStart": [294, 373], "useEnd": [342, 398], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/relekang/fp/tree/master/project/src/no/ntnu/fp/net/co/SimpleConnection.java", "rawCode": "  public void connect(InetAddress remoteAddress, int remotePort)\n      throws IOException, SocketTimeoutException {\n\n    System.out.println(\n        \"Trying to connect to: \" + remoteAddress.getHostAddress() + \" : \" + remotePort);\n    mySocket = new Socket(remoteAddress, remotePort);\n\n    os = new DataOutputStream(mySocket.getOutputStream());\n    is = new DataInputStream(mySocket.getInputStream());\n\n    stop = false;\n\n    System.out.println(\"Connection established!\");\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7974, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [247], "initializationEnd": [283], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["sendError(*,String)"], "tryExpressionStart": 228, "tryExpressionEnd": 232, "tryBlockStart": 228, "tryBlockEnd": 609, "catchExpressionStart": 424, "catchExpressionEnd": 446, "catchBlockStart": 424, "catchBlockEnd": 609, "exceptionHandlingCallStart": [454], "exceptionHandlingCallEnd": [588], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 334, "focalAPIEnd": 356, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream)", "socket.getInputStream()", "socket.close()"], "useStart": [309, 394, 3257], "useEnd": [357, 415, 3269], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/purplescout/PurpleMow/tree/master/android/webclient/src/main/java/se/purplescout/purplemow/webapp/test/servlet/ProxyServlet.java", "rawCode": "  public void service(HttpServletRequest req, HttpServletResponse res)\n      throws ServletException, IOException {\n    //\n    // Connect to \"remote\" server:\n    Socket sock;\n    OutputStream out;\n    InputStream in;\n    //\n    try {\n      sock = new Socket(remoteServer, remotePort); // !!!!!!!!\n      out = new BufferedOutputStream(sock.getOutputStream());\n      in = new BufferedInputStream(sock.getInputStream());\n    } catch (IOException e) {\n      res.sendError(\n          HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n          \"Socket opening: \" + remoteServer + \" \" + remotePort);\n      return;\n    }\n    try {\n      //\n      // Build up a HTTP request from pure strings:\n      StringBuffer sb = new StringBuffer(200);\n      sb.append(req.getMethod());\n      sb.append(' ');\n      String pi = req.getPathInfo();\n      sb.append(remotePath);\n      if (pi != null) {\n        appendCleaned(sb, pi);\n      } else sb.append(\"/\");\n      if (req.getQueryString() != null) {\n        sb.append('?');\n        appendCleaned(sb, req.getQueryString());\n      }\n      sb.append(' ');\n      sb.append(\"HTTP/1.0\");\n      sb.append(CRLF);\n      log(sb.toString());\n      out.write(sb.toString().getBytes());\n      java.util.Enumeration en = req.getHeaderNames();\n      while (en.hasMoreElements()) {\n        String k = (String) en.nextElement();\n        // Filter incoming headers:\n        if (\"Host\".equalsIgnoreCase(k)) {\n          sb.setLength(0);\n          sb.append(k);\n          sb.append(\": \");\n          sb.append(remoteServer);\n          sb.append(\":\");\n          sb.append(remotePort);\n          sb.append(CRLF);\n          log(\"c[\" + k + \"]: \" + sb + \" \" + req.getHeader(k));\n          out.write(sb.toString().getBytes());\n        }\n        //\n        // Throw away persistant connections between servers\n        // Throw away request potentially causing a 304 response.\n        else if (!\"Connection\".equalsIgnoreCase(k)\n            && !\"If-Modified-Since\".equalsIgnoreCase(k)\n            && !\"If-None-Match\".equalsIgnoreCase(k)) {\n          sb.setLength(0);\n          sb.append(k);\n          sb.append(\": \");\n          sb.append(req.getHeader(k));\n          sb.append(CRLF);\n          log(\"=[\" + k + \"]: \" + req.getHeader(k));\n          out.write(sb.toString().getBytes());\n        } else {\n          log(\"*[\" + k + \"]: \" + req.getHeader(k));\n        }\n      }\n      // Finish request header by an empty line\n      out.write(CRLF.getBytes());\n      // Copy post data\n      InputStream inr = req.getInputStream();\n      copyStream(inr, out);\n      out.flush();\n      log(\"Remote request finished. Reading answer.\");\n\n      // Now we have finished the outgoing request.\n      // We'll now see, what is coming back from remote:\n\n      // Get the answer, treat its header and copy the stream data:\n      if (treatHeader(in, req, res)) {\n        log(\"+ copyStream\");\n        // if ( debugFlag ) res.setContentType(\"text/plain\");\n        out = res.getOutputStream();\n        copyStream(in, out);\n      } else log(\"- copyStream\");\n    } catch (IOException e) {\n      log(\"out-in.open!\");\n      // res.sendError( HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n      // \"out-in open!\");\n      return;\n    }\n    try {\n      // out.close();\n      in.close();\n      sock.close();\n    } catch (IOException ignore) {\n      log(\"Exception \" + ignore);\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7975, "initialization": ["Socket socket = ServerSocket.accept()"], "initializationStart": [74], "initializationEnd": [89], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 44, "tryExpressionEnd": 48, "tryBlockStart": 44, "tryBlockEnd": 964, "catchExpressionStart": 904, "catchExpressionEnd": 926, "catchBlockStart": 904, "catchBlockEnd": 964, "exceptionHandlingCallStart": [936], "exceptionHandlingCallEnd": [955], "configuration": ["socket.getInputStream()"], "configurationStart": [197], "configurationEnd": [220], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 557, "focalAPIEnd": 581, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)", "outputStream.flush()", "outputStream.close()"], "useStart": [630, 807, 851], "useEnd": [660, 821, 865], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JohannesBuchner/ics/tree/master/ics/src/test/java/com/jakeapp/jake/ics/TestSocketFileTransferWithMocks.java", "rawCode": "    @Override\n    public void run() {\n      try {\n        Socket client = server.accept();\n        log.debug(\"got a client\");\n        char[] incontent = new char[1000];\n        InputStream input = client.getInputStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(input));\n        int inlen = br.read(incontent);\n        log.debug(\"got \" + inlen + \" bytes: \" + new String(incontent));\n        log.debug(\"should be: \" + key);\n        Assert.assertEquals(new String(incontent).trim(), key.toString());\n        OutputStream output = client.getOutputStream();\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(output));\n        log.debug(\"writing content ...\");\n        bw.write(content);\n        log.debug(\"writing content ... done\");\n        bw.flush();\n        output.flush();\n        bw.close();\n        output.close();\n        log.debug(\"closed\");\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n"}, {"dataset": "getOutputStream", "exampleID": 7976, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [92], "initializationEnd": [110], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["Language.get(String,String)", "wrapsay(String)"], "tryExpressionStart": 71, "tryExpressionEnd": 75, "tryBlockStart": 71, "tryBlockEnd": 491, "catchExpressionStart": 317, "catchExpressionEnd": 339, "catchBlockStart": 317, "catchBlockEnd": 491, "exceptionHandlingCallStart": [355, 347], "exceptionHandlingCallEnd": [394, 414], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 145, "focalAPIEnd": 169, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)", "socket.getInputStream()"], "useStart": [124, 285], "useEnd": [170, 308], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jomat/psyced/tree/master/utility/veChat.java", "rawCode": "  public void doConnect(String ho, int po, String ni, String pa) {\n    try {\n      socket = new Socket(ho, po);\n      out = new DataOutputStream(socket.getOutputStream());\n      // in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n      in = new DataInputStream(socket.getInputStream());\n    } catch (IOException e) {\n      wrapsay(l.get(LANG, \"_direct_connection_error\") + \"(\" + e + \").\\n\");\n      socket = null;\n      in = null;\n      out = null;\n      return;\n    }\n    try {\n      String t = getParameter(\"DEFPLACE\");\n      if (t != null) send(\"=_place \" + t + \"\\n\");\n      if (LAYOUT != null) send(\"=_layout \" + LAYOUT + \"\\n\");\n      if (LANG != null) send(\"=_language \" + LANG + \"\\n\");\n      if (pa != null) send(\"=_password \" + pa + \"\\n\");\n\n      if (input.getText().length() > 0) nick = executeInput();\n      else send((ni == null ? defNick : ni) + \"\\n\");\n    } catch (Exception e) {\n      wrapsay(l.get(LANG, \"_login_error\") + \"(\" + e + \").\\n\");\n      return;\n    }\n    haveConnected(ni);\n\n    // potentially throw old thread away\n    engine = new Thread(this);\n    engine.start();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7977, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ClassNotFoundException", "exceptionHandlingCall": ["new ProtocolException(*)"], "tryExpressionStart": 326, "tryExpressionEnd": 330, "tryBlockStart": 326, "tryBlockEnd": 797, "catchExpressionStart": 599, "catchExpressionEnd": 638, "catchBlockStart": 599, "catchBlockEnd": 687, "exceptionHandlingCallStart": [654], "exceptionHandlingCallEnd": [678], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 392, "focalAPIEnd": 422, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.writeObject(*)", "outputStream.flush()"], "useStart": [432, 487], "useEnd": [477, 498], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/biomart/biomart-rc7/tree/master/src/org/biomart/runner/controller/MartRunnerProtocol.java", "rawCode": "    /**\n     * Request a list of current jobs as {@link JobPlan} objects.\n     *\n     * @param clientSocket the socket to the host.\n     * @return the list of jobs.\n     * @throws ProtocolException if something went wrong.\n     */\n    public static JobList listJobs(final Socket clientSocket) throws ProtocolException {\n      try {\n        final ObjectOutputStream oos = (ObjectOutputStream) clientSocket.getOutputStream();\n        oos.writeObject(MartRunnerProtocol.LIST_JOBS);\n        oos.flush();\n        return (JobList) ((ObjectInputStream) clientSocket.getInputStream()).readObject();\n      } catch (final ClassNotFoundException e) {\n        throw new ProtocolException(e);\n      } catch (final Throwable e) {\n        throw new ProtocolException(Resources.get(\"protocolIOProbs\"), e);\n      }\n    }\n"}, {"dataset": "getOutputStream", "exampleID": 7978, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [153], "initializationEnd": [183], "hasTryCatch": 1, "exceptionType": "UnknownHostException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 132, "tryExpressionEnd": 136, "tryBlockStart": 132, "tryBlockEnd": 634, "catchExpressionStart": 420, "catchExpressionEnd": 451, "catchBlockStart": 420, "catchBlockEnd": 520, "exceptionHandlingCallStart": [459], "exceptionHandlingCallEnd": [513], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 213, "focalAPIEnd": 237, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)", "socket.getInputStream()", "socket.close()"], "useStart": [197, 298, 397], "useEnd": [244, 321, 411], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/uio-jpt/pt-compiler/tree/master/JastAddJ/Java1.4Frontend/server/TestReset.java", "rawCode": "  public static void main(String[] args) {\n    Socket socket = null;\n    PrintWriter out = null;\n    BufferedReader in = null;\n\n    try {\n      socket = new Socket(\"localhost\", 12345);\n      out = new PrintWriter(socket.getOutputStream(), true);\n      in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n      out.println(\"reset\");\n      out.close();\n      in.close();\n      socket.close();\n\n    } catch (UnknownHostException e) {\n      System.err.println(\"Don't know about host: localhost\");\n    } catch (IOException e) {\n      System.err.println(\"Couldn't get I/O for \" + \"the connection to: localhost\");\n    }\n    System.exit(0);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7979, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.getInputStream()"], "configurationStart": [235], "configurationEnd": [258], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 309, "focalAPIEnd": 333, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)"], "useStart": [293], "useEnd": [340], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Senseg/Py4A/tree/master/android/Common/src/com/googlecode/android_scripting/jsonrpc/JsonRpcServer.java", "rawCode": "  @Override\n  protected void handleConnection(Socket socket) throws Exception {\n    RpcReceiverManager receiverManager = mRpcReceiverManagerFactory.create();\n    BufferedReader reader =\n        new BufferedReader(new InputStreamReader(socket.getInputStream()), 8192);\n    PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);\n    boolean passedAuthentication = false;\n    String data;\n    while ((data = reader.readLine()) != null) {\n      Log.v(\"Received: \" + data);\n      JSONObject request = new JSONObject(data);\n      int id = request.getInt(\"id\");\n      String method = request.getString(\"method\");\n      JSONArray params = request.getJSONArray(\"params\");\n\n      // First RPC must be _authenticate if a handshake was specified.\n      if (!passedAuthentication && mHandshake != null) {\n        if (!checkHandshake(method, params)) {\n          SecurityException exception = new SecurityException(\"Authentication failed!\");\n          send(writer, JsonRpcResult.error(id, exception));\n          shutdown();\n          throw exception;\n        }\n        passedAuthentication = true;\n        send(writer, JsonRpcResult.result(id, true));\n        continue;\n      }\n\n      MethodDescriptor rpc = receiverManager.getMethodDescriptor(method);\n      if (rpc == null) {\n        send(writer, JsonRpcResult.error(id, new RpcError(\"Unknown RPC.\")));\n        continue;\n      }\n      try {\n        send(writer, JsonRpcResult.result(id, rpc.invoke(receiverManager, params)));\n      } catch (Throwable t) {\n        Log.e(\"Invocation error.\", t);\n        send(writer, JsonRpcResult.error(id, t));\n      }\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7980, "initialization": ["Socket socket = ServerSocket.accept()"], "initializationStart": [395], "initializationEnd": [416], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)", "exit(int)"], "tryExpressionStart": 646, "tryExpressionEnd": 650, "tryBlockStart": 646, "tryBlockEnd": 908, "catchExpressionStart": 810, "catchExpressionEnd": 832, "catchBlockStart": 810, "catchBlockEnd": 908, "exceptionHandlingCallStart": [840, 887], "exceptionHandlingCallEnd": [879, 901], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 680, "focalAPIEnd": 710, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)", "socket.getInputStream()", "socket.close()"], "useStart": [664, 771, 1203], "useEnd": [717, 800, 1223], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wox2/migrace_databaze/tree/master/skola/Fel_bc/3.semestr/PSI/TCP/server/Server.java", "rawCode": "  public static void main(String[] args) throws IOException {\n    PrintWriter out = null;\n    BufferedReader in = null;\n    ServerSocket serverSocket = null;\n    try {\n      serverSocket = new ServerSocket(1313);\n    } catch (IOException e) {\n      System.err.println(\"Could not listen on port: 1313.\");\n      System.exit(1);\n    }\n    Socket clientSocket = null;\n    try {\n      clientSocket = serverSocket.accept();\n    } catch (IOException e) {\n      System.err.println(\"Accept failed.\");\n      System.exit(1);\n    }\n    System.out.println(\n        \"client accepted from: \" + clientSocket.getInetAddress() + \":\" + clientSocket.getPort());\n    try {\n      out = new PrintWriter(clientSocket.getOutputStream(), true);\n      in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n    } catch (IOException e) {\n      System.err.println(\"Couldn't get I/O.\");\n      System.exit(1);\n    }\n    String inputLine, outputLine;\n    while ((inputLine = in.readLine()) != null) {\n      System.out.println(\"request: \" + inputLine);\n      outputLine = inputLine.toUpperCase();\n      out.println(outputLine);\n    }\n    System.out.println(\"server ending\");\n    out.close();\n    in.close();\n    clientSocket.close();\n    serverSocket.close();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7981, "initialization": ["Socket socket = new Socket(String,*)"], "initializationStart": [73], "initializationEnd": [124], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 152, "focalAPIEnd": 176, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(String)", "outputStream.flush()", "socket.setSoTimeout(int)", "socket.getInputStream()", "socket.close()"], "useStart": [182, 674, 777, 829, 1269], "useEnd": [668, 688, 802, 852, 1283], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thomasbecker/jetty-7/tree/master/jetty-websocket/src/test/java/org/eclipse/jetty/websocket/WebSocketMessageD08Test.java", "rawCode": "  @Test\n  public void testClose() throws Exception {\n    Socket socket = new Socket(\"localhost\", __connector.getLocalPort());\n    OutputStream output = socket.getOutputStream();\n    output.write(\n        (\"GET /chat HTTP/1.1\\r\\n\"\n                + \"Host: server.example.com\\r\\n\"\n                + \"Upgrade: websocket\\r\\n\"\n                + \"Connection: Upgrade\\r\\n\"\n                + \"Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\\r\\n\"\n                + \"Sec-WebSocket-Origin: http://example.com\\r\\n\"\n                + \"Sec-WebSocket-Protocol: onConnect\\r\\n\"\n                + \"Sec-WebSocket-Version: 8\\r\\n\"\n                + \"\\r\\n\")\n            .getBytes(\"ISO-8859-1\"));\n    output.flush();\n\n    // Make sure the read times out if there are problems with the implementation\n    socket.setSoTimeout(1000);\n\n    InputStream input = socket.getInputStream();\n\n    lookFor(\"HTTP/1.1 101 Switching Protocols\\r\\n\", input);\n    skipTo(\"Sec-WebSocket-Accept: \", input);\n    lookFor(\"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\", input);\n    skipTo(\"\\r\\n\\r\\n\", input);\n\n    assertTrue(__serverWebSocket.awaitConnected(1000));\n    assertNotNull(__serverWebSocket.connection);\n\n    assertEquals(0x81, input.read());\n    assertEquals(0x0f, input.read());\n    lookFor(\"sent on connect\", input);\n    socket.close();\n\n    assertTrue(__serverWebSocket.awaitDisconnected(500));\n\n    try {\n      __serverWebSocket.connection.sendMessage(\"Don't send\");\n      assertTrue(false);\n    } catch (IOException e) {\n      assertTrue(true);\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7982, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "e(String,*,*)"], "tryExpressionStart": 1388, "tryExpressionEnd": 1392, "tryBlockStart": 1388, "tryBlockEnd": 2135, "catchExpressionStart": 1918, "catchExpressionEnd": 1938, "catchBlockStart": 1918, "catchBlockEnd": 1981, "exceptionHandlingCallStart": [1956, 1946], "exceptionHandlingCallEnd": [1970, 1974], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 1520, "focalAPIEnd": 1544, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(byte[],int,*)", "socket.getOutputStream()", "outputStream.write(byte[],int,int)", "socket.getOutputStream()", "outputStream.flush()", "socket.close()"], "useStart": [1520, 1744, 1744, 1846, 1846, 2114], "useEnd": [1576, 1768, 1794, 1870, 1878, 2128], "hasFinally": 1, "cleanUpCall": ["InputStream.close()"], "finallyExpressionStart": 1982, "finallyExpressionEnd": 1990, "finallyBlockStart": 1982, "finallyBlockEnd": 2135, "cleanUpCallStart": [2026], "cleanUpCallEnd": [2038], "url": "https://github.com/madeye/dbartists/tree/master/src/org/dbartists/StreamProxy.java", "rawCode": "  private void processRequest(HttpRequest request, Socket client)\n      throws IllegalStateException, IOException {\n    if (request == null) {\n      return;\n    }\n    Log.d(LOG_TAG, \"processing\");\n    String url = request.getRequestLine().getUri();\n\n    String cache = getFileName(title);\n    File f = new File(cache);\n    if (!f.exists()) f.createNewFile();\n\n    HttpResponse realResponse = download(url);\n    if (realResponse == null) {\n      return;\n    }\n\n    Log.d(LOG_TAG, \"downloading...\");\n\n    InputStream data = realResponse.getEntity().getContent();\n\n    int totalFileSize = -1;\n    for (Header h : realResponse.getAllHeaders()) {\n      if (h.getName().toLowerCase().equals(\"content-length\"))\n        try {\n          totalFileSize = Integer.valueOf(h.getValue());\n        } catch (NumberFormatException e) {\n          // Ignore\n        }\n    }\n    StringBuilder httpString = new StringBuilder();\n    httpString.append(\"HTTP/1.1 200 OK\\r\\n\");\n    httpString.append(\"Content-Type: audio/mpeg\\r\\n\");\n    httpString.append(\"Connection: close\\r\\n\");\n    httpString.append(\"Accept-Ranges: bytes\\r\\n\");\n    if (totalFileSize != -1) httpString.append(\"Content-Length: \" + totalFileSize + \"\\r\\n\");\n    httpString.append(\"Content-Disposition: inline; filename=\" + cache + \".mp3\\r\\n\\r\\n\");\n\n    Log.d(LOG_TAG, \"headers done\");\n\n    OutputStream output = new FileOutputStream(cache);\n\n    try {\n      byte[] buffer = httpString.toString().getBytes();\n      int readBytes;\n      Log.d(LOG_TAG, \"writing to client\");\n      client.getOutputStream().write(buffer, 0, buffer.length);\n\n      // Start streaming content.\n      byte[] buff = new byte[1024 * 250];\n      while (isRunning && (readBytes = data.read(buff, 0, buff.length)) != -1) {\n        client.getOutputStream().write(buff, 0, readBytes);\n        output.write(buff, 0, readBytes);\n        client.getOutputStream().flush();\n        output.flush();\n      }\n    } catch (Exception e) {\n      Log.e(\"\", e.getMessage(), e);\n    } finally {\n      if (data != null) {\n        data.close();\n      }\n      if (output != null) {\n        output.close();\n      }\n      client.close();\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7983, "initialization": ["Socket socket = new Socket()"], "initializationStart": [245], "initializationEnd": [257], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.connect(SocketAddress)"], "configurationStart": [275], "configurationEnd": [332], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 362, "focalAPIEnd": 386, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(*)", "outputStream.write(*)", "outputStream.write(*)", "outputStream.write(*)", "socket.close()"], "useStart": [470, 777, 1124, 1581, 2241], "useEnd": [498, 805, 1152, 1609, 2255], "hasFinally": 1, "cleanUpCall": ["ConnectionServer.stop()", "Socket.close()", "CSThread.join()"], "finallyExpressionStart": 2207, "finallyExpressionEnd": 2215, "finallyBlockStart": 2207, "finallyBlockEnd": 2335, "cleanUpCallStart": [2224, 2241, 2263], "cleanUpCallEnd": [2233, 2255, 2278], "url": "https://github.com/pmlt/comp354/tree/master/code/src/tests/ConnectionServerTest.java", "rawCode": "  @Test\n  public void testSendData() throws UnknownHostException, IOException, InterruptedException {\n    CSThread csThread = new CSThread();\n    csThread.start();\n    // Wait for CS to bind socket...\n    Thread.sleep(1000);\n    Socket socket = new Socket();\n    try {\n      socket.connect(new InetSocketAddress(\"localhost\", 11233));\n      OutputStream stream = socket.getOutputStream();\n\n      // Try sending garbage\n      String msg = \"gfenrwjgfe fbd fbb fwwq\";\n      stream.write(msg.getBytes());\n      Thread.sleep(1000); // Allow for overhead of network\n      assertNull(lastVessel); // Should NOT have called update()\n\n      // Try sending netstring-encoded garbage\n      msg = \"gfenrwjgfe fbd fbb fwwq\";\n      msg = msg.length() + \":\" + msg; // Netstring encoding\n      stream.write(msg.getBytes());\n      Thread.sleep(1000); // Allow for overhead of network\n      assertNull(lastVessel); // Should NOT have called update()\n\n      // Try sending bad vessel values\n      msg = \"{\\\"id\\\":[1,2,3],\\\"type\\\":\\\"WRONGENUMVALUE\\\",\\\"coords\\\":0,\\\"course\\\":{}}\";\n      msg = msg.length() + \":\" + msg; // Netstring encoding\n      stream.write(msg.getBytes());\n      Thread.sleep(1000); // Allow for overhead of network\n      assertNull(lastVessel); // Should NOT have called update()\n\n      // Try sending correct data\n      Calendar curTime = Calendar.getInstance();\n      UpdateData ud =\n          new UpdateData(\n              \"myid\", VesselType.CARGO_BOAT, new Coord(10, -10), new Course(20, -20), curTime);\n      msg = ud.toJSON();\n      msg = msg.length() + \":\" + msg + \",\";\n      stream.write(msg.getBytes()); // Write with netstring encoding\n      Thread.sleep(1000); // Allow for overhead of network\n      assertNotNull(lastVessel);\n      Calendar timestamp = lastVessel.getLastTimestamp();\n      assertEquals(curTime, timestamp);\n      assertEquals(\"myid\", lastVessel.getId());\n      assertEquals(VesselType.CARGO_BOAT, lastVessel.getType());\n\n      try {\n        assertEquals(new Coord(10, -10), lastVessel.getCoord(timestamp));\n        assertEquals(new Course(20, -20), lastVessel.getCourse(timestamp));\n      } catch (Exception e) {\n        fail(\"Caught exception: \" + e.getMessage());\n      }\n    } finally {\n\n      cs.stop();\n      socket.close();\n      csThread.join(); // Wait for ConnectionServer to cleanly shut down\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7984, "initialization": ["Socket socket = ServerSocket.accept()"], "initializationStart": [542], "initializationEnd": [557], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["error(String,String,*)"], "tryExpressionStart": 322, "tryExpressionEnd": 326, "tryBlockStart": 322, "tryBlockEnd": 1452, "catchExpressionStart": 1350, "catchExpressionEnd": 1372, "catchBlockStart": 1350, "catchBlockEnd": 1452, "exceptionHandlingCallStart": [1382], "exceptionHandlingCallEnd": [1443], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 1165, "focalAPIEnd": 1195, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream)", "socket.close()"], "useStart": [1149, 1310], "useEnd": [1196, 1330], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mwcaisse/RPIServer/tree/master/RPIRemote/src/main/java/com/ricex/rpi/server/Server.java", "rawCode": "  public void run() {\n    try {\n      socket = new ServerSocket(port);\n\n    } catch (IOException e) {\n      log.error(\"Unable to start server with name {}\", name, e);\n      return;\n    }\n    running = true;\n\n    log.info(\"{} Server started\", name);\n\n    // listen for conenctions to the server\n    while (running) {\n      try {\n        /*\n         * before we check for new clients, let update the current list\n         * of clients\n         */\n        updateConnectedClients();\n\n        // wait for connections\n        Socket clientSocket = socket.accept();\n        log.info(\"User connected to {} server\", name);\n\n        // check if server is not full\n        if (connectedClients.size() < maxConnections) {\n          // create the client, and add to the connected clients\n          T rPIClient = createClient(clientSocket);\n          connectedClients.put(rPIClient.getId(), rPIClient);\n          notifyConnectionListeners(true, rPIClient);\n        } else {\n          log.info(\"No more connections allow to server {}\", name);\n          // we are at max connections.\n          // TODO: why is this using a print writer.\n          PrintWriter out = new PrintWriter(clientSocket.getOutputStream());\n          out.println(\"No more connections allowed, sorry. Come back later.\");\n          out.close();\n          clientSocket.close();\n        }\n      } catch (IOException e) {\n        log.error(\"A server error has occured on server {}\", name, e);\n      }\n    }\n    /*\n     * disconnectClients();\n     * log.info(\"Server {} has stopped\", name);\n     */\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7985, "initialization": ["Socket socket = new Socket()"], "initializationStart": [181], "initializationEnd": [193], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.connect(SocketAddress)"], "configurationStart": [201], "configurationEnd": [292], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 349, "focalAPIEnd": 373, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)", "socket.close()"], "useStart": [326, 593], "useEnd": [374, 604], "hasFinally": 1, "cleanUpCall": ["BufferedWriter.close()"], "finallyExpressionStart": 534, "finallyExpressionEnd": 542, "finallyBlockStart": 534, "finallyBlockEnd": 758, "cleanUpCallStart": [593], "cleanUpCallEnd": [604], "url": "https://github.com/mozilla-b2g/android-sdk/tree/master/hierarchyviewer/src/com/android/hierarchyviewer/scene/ViewManager.java", "rawCode": "  private static void sendCommand(String command, IDevice device, Window window, String params) {\n    Socket socket = null;\n    BufferedWriter out = null;\n\n    try {\n      socket = new Socket();\n      socket.connect(new InetSocketAddress(\"127.0.0.1\", DeviceBridge.getDeviceLocalPort(device)));\n\n      out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n\n      out.write(command + \" \" + window.encode() + \" \" + params);\n      out.newLine();\n      out.flush();\n    } catch (IOException e) {\n      // Empty\n    } finally {\n      try {\n        if (out != null) {\n          out.close();\n        }\n        if (socket != null) {\n          socket.close();\n        }\n      } catch (IOException ex) {\n        ex.printStackTrace();\n      }\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7986, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 920, "focalAPIEnd": 950, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream)", "socket.getInputStream()"], "useStart": [895, 1020], "useEnd": [951, 1049], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/barchart/barchart-udt/tree/master/barchart-udt-reference-jdk6/src/main/java/sun/net/NetworkServer.java", "rawCode": "  public final void run() {\n    if (serverSocket != null) {\n      Thread.currentThread().setPriority(Thread.MAX_PRIORITY);\n      // System.out.print(\"Server starts \" + serverSocket + \"\\n\");\n      while (true) {\n        try {\n          Socket ns = serverSocket.accept();\n          // System.out.print(\"New connection \" + ns + \"\\n\");\n          NetworkServer n = (NetworkServer) clone();\n          n.serverSocket = null;\n          n.clientSocket = ns;\n          new Thread(n).start();\n        } catch (Exception e) {\n          System.out.print(\"Server failure\\n\");\n          e.printStackTrace();\n          try {\n            serverSocket.close();\n          } catch (IOException e2) {\n          }\n          System.out.print(\"cs=\" + serverSocket + \"\\n\");\n          break;\n        }\n      }\n      // close();\n    } else {\n      try {\n        clientOutput =\n            new PrintStream(\n                new BufferedOutputStream(clientSocket.getOutputStream()), false, \"ISO8859_1\");\n        clientInput = new BufferedInputStream(clientSocket.getInputStream());\n        serviceRequest();\n        // System.out.print(\"Service handler exits\n        // \"+clientSocket+\"\\n\");\n      } catch (Exception e) {\n        // System.out.print(\"Service handler failure\\n\");\n        // e.printStackTrace();\n      }\n      try {\n        close();\n      } catch (IOException e2) {\n      }\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7987, "initialization": ["Socket socket = new Socket(InetAddress,int)"], "initializationStart": [225], "initializationEnd": [247], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)", "println(String)"], "tryExpressionStart": 254, "tryExpressionEnd": 258, "tryBlockStart": 254, "tryBlockEnd": 3311, "catchExpressionStart": 1121, "catchExpressionEnd": 1143, "catchBlockStart": 1121, "catchBlockEnd": 1319, "exceptionHandlingCallStart": [1199, 1241], "exceptionHandlingCallEnd": [1227, 1277], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 488, "focalAPIEnd": 507, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DataOutputStream(outputStream)", "outputStream.write(byte[])", "socket.setSoTimeout(int)", "socket.getInputStream()", "socket.close()"], "useStart": [515, 572, 595, 930, 3295], "useEnd": [541, 587, 623, 948, 3304], "hasFinally": 1, "cleanUpCall": ["Socket.close()"], "finallyExpressionStart": 3279, "finallyExpressionEnd": 3287, "finallyBlockStart": 3279, "finallyBlockEnd": 3311, "cleanUpCallStart": [3295], "cleanUpCallEnd": [3304], "url": "https://github.com/lemmy/dnsjava/tree/master/tags/dnsjava-1-2-2/org/xbill/DNS/SimpleResolver.java", "rawCode": "  private Message sendAXFR(Message query) throws IOException {\n    byte[] out, in;\n    Socket s;\n    int inLength;\n    DataInputStream dataIn;\n    int soacount = 0;\n    Message m, response;\n    boolean first = true;\n\n    s = new Socket(addr, port);\n\n    try {\n      query = (Message) query.clone();\n      if (tsig != null) tsig.apply(query, null);\n\n      out = query.toWire();\n      if (Options.check(\"verbosemsg\")) System.err.println(hexdump.dump(\"out\", out));\n      OutputStream sOut = s.getOutputStream();\n      new DataOutputStream(sOut).writeShort(out.length);\n      sOut.write(out);\n      s.setSoTimeout(timeoutValue);\n\n      response = new Message();\n      response.getHeader().setID(query.getHeader().getID());\n      if (tsig != null) {\n        tsig.verifyAXFRStart();\n        response.TSIGsigned = true;\n        response.TSIGverified = true;\n      }\n      while (soacount < 2) {\n        try {\n          InputStream sIn = s.getInputStream();\n          dataIn = new DataInputStream(sIn);\n          inLength = dataIn.readUnsignedShort();\n          in = new byte[inLength];\n          dataIn.readFully(in);\n        } catch (IOException e) {\n          if (Options.check(\"verbose\")) {\n            System.err.println(\";;\" + e);\n            System.err.println(\";; No response\");\n          }\n          throw e;\n        }\n        if (Options.check(\"verbosemsg\")) System.err.println(hexdump.dump(\"in\", in));\n        try {\n          m = new Message(in);\n        } catch (IOException e) {\n          throw new WireParseException(\"Error parsing message\");\n        }\n        if (m.getHeader().getRcode() != Rcode.NOERROR) {\n          if (soacount == 0) return m;\n          else {\n            if (Options.check(\"verbosemsg\")) {\n              System.err.println(\"Invalid AXFR packet: \");\n              System.err.println(m);\n            }\n            throw new WireParseException(\"Invalid AXFR message\");\n          }\n        }\n        if (m.getHeader().getCount(Section.QUESTION) > 1\n            || m.getHeader().getCount(Section.ANSWER) <= 0\n            || m.getHeader().getCount(Section.AUTHORITY) != 0) {\n          if (Options.check(\"verbosemsg\")) {\n            System.err.println(\"Invalid AXFR packet: \");\n            System.err.println(m);\n          }\n          throw new WireParseException(\"Invalid AXFR message\");\n        }\n        for (int i = 1; i < 4; i++) {\n          Enumeration e = m.getSection(i);\n          while (e.hasMoreElements()) {\n            Record r = (Record) e.nextElement();\n            response.addRecord(r, i);\n            if (r instanceof SOARecord) soacount++;\n          }\n        }\n        if (tsig != null) {\n          boolean required = (soacount > 1 || first);\n          byte error = tsig.verifyAXFR(m, in, query.getTSIG(), required, first);\n          boolean ok = (error == Rcode.NOERROR);\n          if (!ok) response.TSIGverified = false;\n          if (Options.check(\"verbose\")) {\n            String status;\n            if (m.getTSIG() == null) {\n              if (!ok) status = \"expected\";\n              else status = \"<>\";\n            } else {\n              if (!ok) status = \"failed\";\n              else status = \"ok\";\n            }\n            System.err.println(\"TSIG verify: \" + status);\n          }\n        }\n        first = false;\n      }\n    } finally {\n      s.close();\n    }\n    return response;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7988, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 91, "focalAPIEnd": 115, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(*)", "outputStream.write(byte[])"], "useStart": [176, 252], "useEnd": [217, 275], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/djmailhot/CSE461projects/tree/master/Net/src/edu/uw/cs/cse461/Net/TCPMessageHandler/TCPMessageHandler.java", "rawCode": "  public void sendMessage(byte[] buf) throws IOException {\n    OutputStream outputStream = socket.getOutputStream();\n    // write out the header: the length of the payload\n    outputStream.write(intToByte(buf.length));\n    // write out the payload\n    outputStream.write(buf);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7989, "initialization": ["Socket socket = new Socket()", "Socket socket = new Socket()"], "initializationStart": [452, 941], "initializationEnd": [464, 953], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.setSoTimeout(int)", "socket.connect(InetSocketAddress,int)", "socket.setTcpNoDelay(boolean)", "socket.setSoTimeout(int)", "socket.getInputStream()"], "configurationStart": [470, 587, 647, 965, 1135], "configurationEnd": [519, 637, 674, 1014, 1156], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 1206, "focalAPIEnd": 1228, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream)"], "useStart": [1181], "useEnd": [1229], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benh/twesos/tree/master/third_party/zookeeper-3.3.1/src/java/main/org/apache/zookeeper/server/quorum/Learner.java", "rawCode": "  /**\n   * Establish a connection with the Leader found by findLeader. Retries 5 times before giving up.\n   *\n   * @param addr - the address of the Leader to connect to.\n   * @throws IOException - if the socket connection fails on the 5th attempt\n   * @throws ConnectException\n   * @throws InterruptedException\n   */\n  protected void connectToLeader(InetSocketAddress addr)\n      throws IOException, ConnectException, InterruptedException {\n    sock = new Socket();\n    sock.setSoTimeout(self.tickTime * self.initLimit);\n    for (int tries = 0; tries < 5; tries++) {\n      try {\n        sock.connect(addr, self.tickTime * self.syncLimit);\n        sock.setTcpNoDelay(nodelay);\n        break;\n      } catch (IOException e) {\n        if (tries == 4) {\n          LOG.error(\"Unexpected exception\", e);\n          throw e;\n        } else {\n          LOG.warn(\"Unexpected exception, tries=\" + tries + \", connecting to \" + addr, e);\n          sock = new Socket();\n          sock.setSoTimeout(self.tickTime * self.initLimit);\n        }\n      }\n      Thread.sleep(1000);\n    }\n    leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));\n    bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n    leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7990, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [169], "initializationEnd": [198], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 42, "tryExpressionEnd": 46, "tryBlockStart": 42, "tryBlockEnd": 1721, "catchExpressionStart": 1544, "catchExpressionEnd": 1566, "catchBlockStart": 1544, "catchBlockEnd": 1604, "exceptionHandlingCallStart": [1576], "exceptionHandlingCallEnd": [1595], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 235, "focalAPIEnd": 254, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new ObjectOutputStream(outputStream)", "socket.getInputStream()", "socket.close()"], "useStart": [212, 290, 1649], "useEnd": [255, 308, 1658], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xwic/appkit/tree/master/de.xwic.appkit.core/src_test/de/xwic/appkit/core/cluster/TestClient.java", "rawCode": "  public void start(String[] args) {\n\n    try {\n\n      int port = 11150;\n      if (args.length > 0) {\n        port = Integer.parseInt(args[0]);\n      }\n      Socket s = new Socket(\"localhost\", port);\n      out = new ObjectOutputStream(s.getOutputStream());\n      in = new ObjectInputStream(s.getInputStream());\n\n      out.writeObject(new Message(Message.CMD_IDENTIFY_CLIENT, \"Console\"));\n      Response res = (Response) in.readObject();\n      System.out.println(res);\n\n      System.out.println(\"Enter commands or 'exit' to exit.\");\n      BufferedReader bis = new BufferedReader(new InputStreamReader(System.in));\n      String line;\n      try {\n        while (true) {\n          System.out.println();\n          System.out.print(\":\");\n          line = bis.readLine();\n\n          if (line.equals(\"exit\")) {\n            break;\n          }\n\n          Message msg;\n          int idx = line.indexOf(' ');\n          if (idx != -1) {\n            String cmd = line.substring(0, idx);\n            String arg = line.substring(idx + 1);\n            msg = new Message(cmd, arg);\n          } else {\n            msg = new Message(line);\n          }\n\n          long start = System.currentTimeMillis();\n          System.out.println(\"Sending \" + msg);\n          out.writeObject(msg);\n          Response response = (Response) in.readObject();\n\n          System.out.println(\"[\" + (System.currentTimeMillis() - start) + \"] >> \" + response);\n          if (response.getData() != null) {\n            System.out.println(response.getData());\n          }\n        }\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n\n      out.close();\n      in.close();\n      s.close();\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7991, "initialization": ["Socket socket = ServerSocket.accept()"], "initializationStart": [484], "initializationEnd": [505], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)", "println(String)", "notifyListener(*)"], "tryExpressionStart": 337, "tryExpressionEnd": 341, "tryBlockStart": 337, "tryBlockEnd": 1044, "catchExpressionStart": 852, "catchExpressionEnd": 874, "catchBlockStart": 852, "catchBlockEnd": 1044, "exceptionHandlingCallStart": [884, 936, 982], "exceptionHandlingCallEnd": [926, 972, 1035], "configuration": ["socket.setKeepAlive(boolean)"], "configurationStart": [515], "configurationEnd": [546], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 578, "focalAPIEnd": 608, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)", "socket.getInputStream()"], "useStart": [562, 671], "useEnd": [615, 700], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bigbluebutton/bigbluebutton/tree/master/deskshare/applet/src/main/java/org/bigbluebutton/deskshare/client/LifeLine.java", "rawCode": "    @Override\n    public void run() {\n      try {\n        serverSocket = new ServerSocket();\n        serverSocket.bind(new InetSocketAddress(\"127.0.0.1\", port));\n      } catch (IOException e) {\n        System.err.println(\"Could not listen on port: \" + port);\n        notifyListener(ExitCode.CANNOT_BIND_TO_LIFELINE_PORT);\n      }\n\n      try {\n        System.out.println(\n            \"Starting listener on [\" + serverSocket.getInetAddress() + \":\" + port + \"]\");\n        clientSocket = serverSocket.accept();\n        clientSocket.setKeepAlive(true);\n        out = new PrintWriter(clientSocket.getOutputStream(), true);\n        in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n        String inputLine;\n        connected = true;\n        while ((inputLine = in.readLine()) != null) {\n          // do nothing\n        }\n      } catch (IOException e) {\n        System.out.println(\"IOException listener\");\n        System.err.println(\"Accept failed.\");\n        notifyListener(ExitCode.ERROR_ON_LIFELINE_CONNECTION);\n      }\n      close();\n      System.out.println(\"Stopped listener\");\n      notifyListener(ExitCode.LIFELINE_CONNECTION_CLOSED);\n    }\n"}, {"dataset": "getOutputStream", "exampleID": 7992, "initialization": ["Socket socket = new Socket(*,*)"], "initializationStart": [139], "initializationEnd": [179], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 251, "focalAPIEnd": 270, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OutputStreamWriter(outputStream)", "socket.getInputStream()"], "useStart": [228, 770], "useEnd": [271, 788], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gilsondev/jsf2-api/tree/master/jsf-ri/systest/src/com/sun/faces/facelets/FaceletsTestCase.java", "rawCode": "  private String issueHttpRequest(String methodName, int[] rc, String path) throws Exception {\n\n    URL url = getURL(path);\n    Socket s = new Socket(url.getHost(), url.getPort());\n    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n    String requestLine = methodName + \" /\" + contextPath + path + \" HTTP/1.1\\r\\n\";\n    writer.write(requestLine);\n    writer.write(\"Host: \" + url.getHost() + \":\" + url.getPort() + \"\\r\\n\");\n    writer.write(\"User-Agent: systest-client\\r\\n\");\n    writer.write(\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n\");\n    writer.write(\"Connection: close\\r\\n\");\n    writer.write(\"\\r\\n\");\n    writer.flush();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n    String cur = null;\n    StringBuilder builder = new StringBuilder();\n    rc[0] = -1;\n    while (null != (cur = reader.readLine())) {\n      if (-1 == rc[0]) {\n        String[] tokens = cur.split(\"\\\\s\");\n        rc[0] = Integer.valueOf(tokens[1]);\n      }\n      builder.append(cur).append(\"\\n\");\n    }\n    writer.close();\n\n    return builder.toString();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7993, "initialization": ["Socket socket = new Socket()"], "initializationStart": [71], "initializationEnd": [83], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["socket.connect(SocketAddress)", "socket.getInputStream()"], "configurationStart": [89, 155], "configurationEnd": [132, 178], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 203, "focalAPIEnd": 227, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["handle(InputStream,outputStream)"], "useStart": [313], "useEnd": [328], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/crashub/crash/tree/master/shell/src/main/java/org/crsh/util/AbstractSocketClient.java", "rawCode": "  public final void connect() throws IOException {\n    Socket socket = new Socket();\n    socket.connect(new InetSocketAddress(port));\n    InputStream in = socket.getInputStream();\n    OutputStream out = socket.getOutputStream();\n\n    //\n    this.socket = socket;\n    this.in = in;\n    this.out = out;\n\n    //\n    handle(in, out);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7994, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 142, "focalAPIEnd": 166, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["socket.getInputStream()", "outputStream.write(byte[])", "outputStream.flush()", "socket.close()", "outputStream.close()"], "useStart": [192, 265, 290, 433, 472], "useEnd": [215, 284, 304, 447, 486], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bomm/thera-pi-2/tree/master/RehaxSwing/src/splashWin/RehaxSwing.java", "rawCode": "  private void serverStarten() throws IOException {\n    this.server = new Socket(\"localhost\", 1235);\n    OutputStream output = (OutputStream) server.getOutputStream();\n    InputStream input = server.getInputStream();\n\n    byte[] bytes = this.stand.getBytes();\n\n    output.write(bytes);\n    output.flush();\n    int zahl = input.available();\n    if (zahl > 0) {\n      byte[] lesen = new byte[zahl];\n      input.read(lesen);\n    }\n\n    server.close();\n    input.close();\n    output.close();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7995, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 334, "focalAPIEnd": 358, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new StreamOutputStream(*,outputStream)", "socket.getOutputStream()", "new BlockOutputStream(*,outputStream)", "socket.getOutputStream()", "new CompressedOutputStream(*,outputStream)"], "useStart": [305, 455, 427, 586, 553], "useEnd": [359, 479, 480, 610, 611], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/plugins/email/ext/src/inetlib-1.1.1/source/gnu/inet/ftp/PassiveModeDTP.java", "rawCode": "  /** Returns an output stream to which a local file can be written for upload. */\n  public OutputStream getOutputStream() throws IOException {\n    if (inProgress) {\n      throw new IOException(\"Transfer in progress\");\n    }\n    switch (transferMode) {\n      case FTPConnection.MODE_STREAM:\n        out = new StreamOutputStream(this, socket.getOutputStream());\n        break;\n      case FTPConnection.MODE_BLOCK:\n        out = new BlockOutputStream(this, socket.getOutputStream());\n        break;\n      case FTPConnection.MODE_COMPRESSED:\n        out = new CompressedOutputStream(this, socket.getOutputStream());\n        break;\n      default:\n        throw new IllegalStateException(\"Invalid transfer mode\");\n    }\n    out.setTransferComplete(false);\n    return out;\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7996, "initialization": ["Socket socket = new Socket()"], "initializationStart": [134], "initializationEnd": [146], "hasTryCatch": 1, "exceptionType": "InterruptedIOException", "exceptionHandlingCall": ["getMessage()", "Log.error(String)"], "tryExpressionStart": 115, "tryExpressionEnd": 119, "tryBlockStart": 115, "tryBlockEnd": 658, "catchExpressionStart": 381, "catchExpressionEnd": 417, "catchBlockStart": 381, "catchBlockEnd": 521, "exceptionHandlingCallStart": [448, 425], "exceptionHandlingCallEnd": [465, 466], "configuration": ["socket.connect(InetSocketAddress,int)", "socket.getInputStream()"], "configurationStart": [227, 295], "configurationEnd": [282, 316], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 329, "focalAPIEnd": 351, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eastseven/tsm/tree/master/tsm/src/main/java/com/em/UnionSocket.java", "rawCode": "  /**\n   * @param ip\n   * @param port\n   * @return\n   */\n  protected boolean connectHSM(String ip, int port) {\n    try {\n      sock = new Socket();\n      // sock.setTcpNoDelay(false);\n      // sock.setSoLinger(true, 10);\n      sock.connect(new InetSocketAddress(ip, port), iTimeOut);\n      is = sock.getInputStream();\n      os = sock.getOutputStream();\n      IsConn = true;\n\n    } catch (InterruptedIOException iioe) {\n      logger.error(\"连接超时:\" + iioe.getMessage());\n      TimeOutFlag = true;\n      IsConn = false;\n    } catch (Exception e) {\n      IsConn = false;\n      logger.error(\"连接远程主机异常:\" + e.getMessage());\n    } finally {\n      return IsConn;\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7997, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getName()", "getLogger(*)", "log(*,*,*)"], "tryExpressionStart": 141, "tryExpressionEnd": 145, "tryBlockStart": 141, "tryBlockEnd": 6440, "catchExpressionStart": 6144, "catchExpressionEnd": 6167, "catchBlockStart": 6144, "catchBlockEnd": 6269, "exceptionHandlingCallStart": [6196, 6179, 6179], "exceptionHandlingCallEnd": [6229, 6230, 6258], "configuration": ["socket.getInputStream()"], "configurationStart": [324], "configurationEnd": [347], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 455, "focalAPIEnd": 479, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new BufferedOutputStream(outputStream)", "socket.close()"], "useStart": [430, 3703], "useEnd": [480, 3717], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pmghalvorsen/DistFileSystem/tree/master/DistFileSystem/src/distserver/ServUserManagement.java", "rawCode": "  @Override\n  public void run() {\n    this.distConfig = DistConfig.get_Instance();\n    this.userManage = UserManagement.get_Instance();\n\n    try {\n      System.out.println(\"In thread for managing users\");\n\n      // Get the input stream for the client\n      BufferedReader inStream = new BufferedReader(new InputStreamReader(client.getInputStream()));\n      // Get the output stream for the client\n      BufferedOutputStream bos = new BufferedOutputStream(client.getOutputStream());\n      // Setup the writer to the client\n      PrintWriter outStream = new PrintWriter(bos, false);\n      System.out.println(\"Got streams\");\n\n      // Send acknowledgment everything is set\n      outStream.println(ConnectionCodes.USERMANAGEMENT);\n      outStream.flush();\n\n      // Get the ID of the initiator\n      String origID = inStream.readLine();\n      // Get the user name of the requester\n      String origUserName = inStream.readLine();\n      // Get the group to modify\n      String groupName = inStream.readLine();\n      // Get what they want to be done\n      Integer manageCode = Integer.parseInt(inStream.readLine());\n\n      // The results of the usermanagement\n      String[] results = new String[2];\n      int num;\n      String[] userToChange = null;\n\n      switch (manageCode) {\n        case ConnectionCodes.NEWGROUP:\n          // Send confirm signal\n          outStream.println(ConnectionCodes.NEWGROUP);\n          outStream.flush();\n          // Create the group\n          results = userManage.create_Group(groupName, origUserName, \"1\");\n          // Send the code and string\n          outStream.println(results[0]);\n          outStream.println(results[1]);\n          outStream.flush();\n          break;\n        case ConnectionCodes.ADDUSERTOGROUP:\n          // Send confirm signal\n          outStream.println(ConnectionCodes.ADDUSERTOGROUP);\n          outStream.flush();\n          // Get the number of users to add\n          num = Integer.parseInt(inStream.readLine());\n          userToChange = new String[num];\n\n          for (int index = 0; index < num; index++) {\n            userToChange[index] = inStream.readLine();\n            results = userManage.add_UserToGroup(userToChange[index], groupName, origUserName, \"1\");\n          }\n\n          // Send the results back\n          outStream.println(results[0]);\n          outStream.println(results[1]);\n          outStream.flush();\n          break;\n        case ConnectionCodes.REMOVEUSERFROMGROUP:\n          // Send confirm signal\n          outStream.println(ConnectionCodes.REMOVEUSERFROMGROUP);\n          outStream.flush();\n          num = Integer.parseInt(inStream.readLine());\n          userToChange = new String[num];\n\n          for (int index = 0; index < num; index++) {\n            userToChange[index] = inStream.readLine();\n            results =\n                userManage.remove_UserFromGroup(userToChange[index], groupName, origUserName, \"1\");\n          }\n          // Send back the results\n          outStream.println(results[0]);\n          outStream.println(results[1]);\n          outStream.flush();\n          break;\n        default:\n          // The code wasn't recognized, send back that signal\n          outStream.println(ConnectionCodes.UNRECOGNIZEDCODE);\n          outStream.flush();\n          results[0] = Integer.toString(Constants.FAILURE);\n          results[1] = \"The code \" + manageCode + \", was unrecognized as a user management code.\";\n          // Send back the results\n          outStream.println(results[0]);\n          outStream.println(results[1]);\n          outStream.flush();\n          break;\n      }\n\n      // Close all the connections and streams\n      outStream.close();\n      bos.close();\n      inStream.close();\n      client.close();\n\n      // Check if the signal succeeded\n      // And this is not the originator\n      if (Integer.parseInt(results[0]) == Constants.SUCCESS\n          && !NodeSearchTable.get_Instance().get_ownID().equals(origID)) {\n\n        // Setup and forward the information to the next node\n        String nextIP = NodeSearchTable.get_Instance().get_IPAt(0);\n\n        try {\n          Socket successor = new Socket(nextIP, distConfig.get_servPortNumber());\n          successor.setSoTimeout(5000);\n\n          // Get the streams\n          bos = new BufferedOutputStream(successor.getOutputStream());\n          outStream = new PrintWriter(bos, false);\n\n          // Get input stream\n          inStream = new BufferedReader(new InputStreamReader(successor.getInputStream()));\n\n          // Send first signal\n          outStream.println(ConnectionCodes.USERMANAGEMENT);\n          outStream.flush();\n\n          // Receive ack\n          inStream.readLine();\n\n          // Send the originating ID, username\n          outStream.println(origID);\n          outStream.println(origUserName);\n          outStream.flush();\n\n          // Send the next code and group name\n          outStream.println(groupName);\n          outStream.println(manageCode);\n          outStream.flush();\n\n          // Receive ack\n          Integer ack = Integer.parseInt(inStream.readLine());\n\n          switch (ack) {\n            case ConnectionCodes.NEWGROUP:\n              break;\n\n            case ConnectionCodes.ADDUSERTOGROUP:\n              outStream.println(userToChange.length);\n              outStream.flush();\n              for (int index = 0; index < userToChange.length; index++) {\n                outStream.println(userToChange[index]);\n                outStream.flush();\n              }\n              break;\n\n            case ConnectionCodes.REMOVEUSERFROMGROUP:\n              outStream.println(userToChange.length);\n              outStream.flush();\n              for (int index = 0; index < userToChange.length; index++) {\n                outStream.println(userToChange[index]);\n                outStream.flush();\n              }\n              break;\n          }\n\n          System.out.println(inStream.readLine());\n          System.out.println(inStream.readLine());\n\n          // Close connection\n          outStream.close();\n          bos.close();\n          inStream.close();\n          successor.close();\n        }\n        // Catch any potential errors\n        catch (IOException ex) {\n          Logger.getLogger(ServCheckPosition.class.getName()).log(Level.SEVERE, null, ex);\n        }\n      }\n\n    }\n    // Catch any potential errors\n    catch (IOException ex) {\n      Logger.getLogger(ServCheckPosition.class.getName()).log(Level.SEVERE, null, ex);\n    }\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7998, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [356], "initializationEnd": [385], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 421, "focalAPIEnd": 451, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrintWriter(outputStream,boolean)"], "useStart": [405], "useEnd": [458], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vogella/eclipse-platform/tree/master/ant/org.eclipse.ant.launching/remote/org/eclipse/ant/internal/launching/remote/logger/RemoteAntBuildLogger.java", "rawCode": "  /** Connect to the remote Ant build listener. */\n  protected void connect() {\n    if (fDebugMode) {\n      System.out.println(\n          \"RemoteAntBuildLogger: trying to connect\"\n              + fHost\n              + \":\"\n              + fEventPort); // $NON-NLS-1$ //$NON-NLS-2$\n    }\n\n    for (int i = 1; i < 5; i++) {\n      try {\n        fEventSocket = new Socket(fHost, fEventPort);\n        fWriter = new PrintWriter(fEventSocket.getOutputStream(), true);\n        return;\n      } catch (IOException e) {\n      }\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n      }\n    }\n    shutDown();\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 7999, "initialization": ["Socket socket = new Socket(String,int)"], "initializationStart": [354], "initializationEnd": [382], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()", "new ObjectNotFoundException(String,*)"], "tryExpressionStart": 328, "tryExpressionEnd": 332, "tryBlockStart": 328, "tryBlockEnd": 1072, "catchExpressionStart": 968, "catchExpressionEnd": 988, "catchBlockStart": 968, "catchBlockEnd": 1072, "exceptionHandlingCallStart": [996, 1029], "exceptionHandlingCallEnd": [1015, 1065], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 409, "focalAPIEnd": 431, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["outputStream.write(byte[])", "outputStream.write(byte[])", "outputStream.write(byte[])", "new ObjectOutputStream(outputStream)", "socket.getInputStream()", "socket.close()"], "useStart": [439, 471, 499, 554, 678, 895], "useEnd": [463, 491, 519, 581, 699, 907], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/voberoi/jchord/tree/master/libsrc/javassist/src/javassist/tools/rmi/ObjectImporter.java", "rawCode": "  /**\n   * Finds the object exported by the server with the specified name. It sends a POST request to the\n   * server (via an http proxy server if needed).\n   *\n   * @param name the name of the exported object.\n   * @return the proxy object.\n   */\n  public Object lookupObject(String name) throws ObjectNotFoundException {\n    try {\n      Socket sock = new Socket(servername, port);\n      OutputStream out = sock.getOutputStream();\n      out.write(lookupCommand);\n      out.write(endofline);\n      out.write(endofline);\n\n      ObjectOutputStream dout = new ObjectOutputStream(out);\n      dout.writeUTF(name);\n      dout.flush();\n\n      InputStream in = new BufferedInputStream(sock.getInputStream());\n      skipHeader(in);\n      ObjectInputStream din = new ObjectInputStream(in);\n      int n = din.readInt();\n      String classname = din.readUTF();\n      din.close();\n      dout.close();\n      sock.close();\n\n      if (n >= 0) return createProxy(n, classname);\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new ObjectNotFoundException(name, e);\n    }\n\n    throw new ObjectNotFoundException(name);\n  }\n"}, {"dataset": "getOutputStream", "exampleID": 8000, "initialization": ["Socket socket = new Socket(*,*)"], "initializationStart": [145], "initializationEnd": [190], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "JTextField.setText(String)"], "tryExpressionStart": 64, "tryExpressionEnd": 68, "tryBlockStart": 64, "tryBlockEnd": 378, "catchExpressionStart": 284, "catchExpressionEnd": 305, "catchBlockStart": 284, "catchBlockEnd": 378, "exceptionHandlingCallStart": [355, 313], "exceptionHandlingCallEnd": [370, 371], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "outputStream = socket.getOutputStream()", "focalAPIStart": 198, "focalAPIEnd": 222, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Fat-Zer/tdelibs/tree/master/tdehtml/java/tests/badapplets/BadApplet.java", "rawCode": "  void connectSocketButton_actionPerformed(ActionEvent e) {\n    try {\n      Integer thePort = new Integer(port.getText());\n      Socket socket = new Socket(url.getText(), thePort.intValue());\n      socket.getOutputStream();\n      output.setText(\"Socket connection successful\");\n    } catch (Exception ex) {\n      output.setText(\"Socket unsuccessfull: \" + ex.getMessage());\n    }\n  }\n"}]