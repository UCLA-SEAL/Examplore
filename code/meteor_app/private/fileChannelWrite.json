[{"dataset": "fileChannelWrite", "exampleID": 2101, "initialization": ["FileChannel fileChannel = getWriteChannel()"], "initializationStart": [452], "initializationEnd": [469], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position(int)", "src.rewind()"], "configurationStart": [519, 550], "configurationEnd": [542, 567], "guardCondition": "!(src.capacity()!=this.bytesPerTile)", "guardType": "IF {", "guardExpressionStart": 134, "guardExpressionEnd": 179, "guardBlockStart": 134, "guardBlockEnd": 393, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 575, "focalAPIEnd": 602, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/deegree/deegree3/tree/master/deegree-core/deegree-core-coverage/src/main/java/org/deegree/coverage/raster/io/grid/GridWriter.java", "rawCode": "  /**\n   * @param newBytes\n   * @throws IOException\n   */\n  public void writeEntireFile(ByteBuffer newBytes) throws IOException {\n    if (newBytes.capacity() != this.bytesPerTile) {\n      throw new IllegalArgumentException(\n          \"byte buffer is to small, required bytes:\"\n              + (this.bytesPerTile)\n              + \", provided bytes: \"\n              + newBytes.capacity());\n    }\n    synchronized (LOCK) {\n      FileChannel fileChannel = getWriteChannel();\n      FileLock lock = fileChannel.lock();\n      fileChannel.position(0);\n      newBytes.rewind();\n      fileChannel.write(newBytes);\n      lock.release();\n      closeWriteStream();\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2102, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,offset,length)", "focalAPIStart": 120, "focalAPIEnd": 165, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()", "fileChannel.write(ByteBuffer[],int,int)"], "useStart": [679, 724], "useEnd": [706, 769], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/libcore/java/nio/channels/OldFileChannelTest.java", "rawCode": "  public void test_write$LByteBufferII_Null() throws Exception {\n    ByteBuffer[] writeBuffers = null;\n\n    try {\n      readOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    try {\n      writeOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    try {\n      readWriteFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    // first throws NullPointerException\n    readOnlyFileChannel.close();\n    try {\n      readOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    writeOnlyFileChannel.close();\n    try {\n      writeOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    readWriteFileChannel.close();\n    try {\n      readWriteFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2103, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = allocate(int)"], "initializationStart": [369, 411], "initializationEnd": [385, 433], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new StoreException(*)"], "tryExpressionStart": 307, "tryExpressionEnd": 311, "tryBlockStart": 307, "tryBlockEnd": 1189, "catchExpressionStart": 962, "catchExpressionEnd": 984, "catchBlockStart": 962, "catchBlockEnd": 1026, "exceptionHandlingCallStart": [998], "exceptionHandlingCallEnd": [1019], "configuration": ["src.flip()"], "configurationStart": [632], "configurationEnd": [642], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 652, "focalAPIEnd": 670, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)", "writeNode(*,fileChannel,ByteOrder)", "fileChannel.close()"], "useStart": [881, 908, 1057], "useEnd": [899, 954, 1072], "hasFinally": 1, "cleanUpCall": ["FileChannel.close()"], "finallyExpressionStart": 1027, "finallyExpressionEnd": 1035, "finallyBlockStart": 1027, "finallyBlockEnd": 1189, "cleanUpCallStart": [1057], "cleanUpCallEnd": [1072], "url": "https://github.com/victortey/geotool/tree/master/modules/plugin/shapefile/src/main/java/org/geotools/index/quadtree/fs/FileSystemIndexStore.java", "rawCode": "  /** @see org.geotools.index.quadtree.IndexStore#store(org.geotools.index.quadtree.QuadTree) */\n  public void store(QuadTree tree) throws StoreException {\n    // For efficiency, trim the tree\n    tree.trim();\n\n    // Open the stream...\n    FileOutputStream fos = null;\n    FileChannel channel = null;\n\n    try {\n      fos = new FileOutputStream(file);\n      channel = fos.getChannel();\n\n      ByteBuffer buf = ByteBuffer.allocate(8);\n\n      if (this.byteOrder > IndexHeader.NATIVE_ORDER) {\n        LOGGER.finest(\"Writing file header\");\n\n        IndexHeader header = new IndexHeader(byteOrder);\n        header.writeTo(buf);\n        buf.flip();\n        channel.write(buf);\n      }\n\n      ByteOrder order = byteToOrder(this.byteOrder);\n\n      buf.clear();\n      buf.order(order);\n\n      buf.putInt(tree.getNumShapes());\n      buf.putInt(tree.getMaxDepth());\n      buf.flip();\n\n      channel.write(buf);\n\n      this.writeNode(tree.getRoot(), channel, order);\n    } catch (IOException e) {\n      throw new StoreException(e);\n    } finally {\n      try {\n        channel.close();\n      } catch (Exception e) {\n      }\n\n      try {\n        fos.close();\n      } catch (Exception e) {\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2104, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = wrap(byte[])"], "initializationStart": [512, 550], "initializationEnd": [528, 578], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 584, "focalAPIEnd": 596, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/molgenis/molgenis_apps-legacy/tree/master/apps/designgg/org/molgenis/designgg/Utils.java", "rawCode": "  /**\n   * Retrieves a file from the harddrive.\n   *\n   * @param completefilename File name of a file to retrieve\n   * @return Byte array of the file.\n   * @throws Exception Any Exception that occurred.\n   */\n  public static void setFile(String fullFileName, byte[] fileContent) throws Exception {\n    File f = new File(fullFileName);\n    f.getParentFile().mkdirs();\n\n    // Open the file and then get a channel from the stream\n    FileOutputStream fos = new FileOutputStream(fullFileName);\n    FileChannel fc = fos.getChannel();\n    ByteBuffer bb = ByteBuffer.wrap(fileContent);\n    fc.write(bb);\n\n    // Get the file's size and then map it into memory\n    // int fileSize = fileContent.length;\n\n    // MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE, 0,\n    // fileSize);\n    // We write the contents of the file with one shot\n    // mbb.put(fileContent);\n\n    fos.close();\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2105, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [157], "configurationEnd": [168], "guardCondition": "src.remaining()>0", "guardType": "LOOP {", "guardExpressionStart": 201, "guardExpressionEnd": 229, "guardBlockStart": 201, "guardBlockEnd": 253, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 230, "focalAPIEnd": 252, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gvtools/gvtools-legacy/tree/master/libraries/libFMap/src/com/iver/cit/gvsig/fmap/drivers/shp/write/SHPFileWrite.java", "rawCode": "  /**\n   * Drain internal buffers into underlying channels.\n   *\n   * @throws IOException DOCUMENT ME!\n   */\n  private void drain() throws IOException {\n    m_bb.flip();\n    m_indexBuffer.flip();\n\n    while (m_bb.remaining() > 0) shpChannel.write(m_bb);\n\n    while (m_indexBuffer.remaining() > 0) shxChannel.write(m_indexBuffer);\n\n    m_bb.flip().limit(m_bb.capacity());\n    m_indexBuffer.flip().limit(m_indexBuffer.capacity());\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2106, "initialization": ["FileChannel fileChannel = RandomAccessFile.getChannel()", "ByteBuffer src = allocate(int)"], "initializationStart": [468, 580], "initializationEnd": [484, 622], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.rewind()"], "configurationStart": [650], "configurationEnd": [661], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 669, "focalAPIEnd": 682, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.truncate(int)", "fileChannel.close()"], "useStart": [690, 743], "useEnd": [719, 754], "hasFinally": 1, "cleanUpCall": ["FileChannel.close()", "RandomAccessFile.close()", "FileChannel.close()", "FileInputStream.close()"], "finallyExpressionStart": 727, "finallyExpressionEnd": 735, "finallyBlockStart": 727, "finallyBlockEnd": 818, "cleanUpCallStart": [743, 762, 781, 800], "cleanUpCallEnd": [754, 773, 792, 811], "url": "https://github.com/thiago-silva/epic-java/tree/master/test/tools/javac/6567415/T6567415.java", "rawCode": "  static void enlargeClassFile() throws IOException {\n    File f = new File(TEST_CLASS);\n    if (!f.exists()) {\n      System.out.println(\"file not found: \" + TEST_CLASS);\n      System.exit(1);\n    }\n    File tfile = new File(f.getAbsolutePath() + \".tmp\");\n    f.renameTo(tfile);\n\n    RandomAccessFile raf = null;\n    FileChannel wfc = null;\n\n    FileInputStream fis = null;\n    FileChannel rfc = null;\n\n    try {\n      raf = new RandomAccessFile(f, \"rw\");\n      wfc = raf.getChannel();\n\n      fis = new FileInputStream(tfile);\n      rfc = fis.getChannel();\n\n      ByteBuffer bb = MappedByteBuffer.allocate(BAD_FILE_LENGTH);\n      rfc.read(bb);\n      bb.rewind();\n      wfc.write(bb);\n      wfc.truncate(BAD_FILE_LENGTH);\n    } finally {\n      wfc.close();\n      raf.close();\n      rfc.close();\n      fis.close();\n    }\n    System.out.println(\"file length = \" + f.length());\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2107, "initialization": ["FileChannel fileChannel = getFileChannel()"], "initializationStart": [616], "initializationEnd": [632], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.remaining()", "fileChannel.position(long)"], "configurationStart": [573, 638], "configurationEnd": [588, 662], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 747, "focalAPIEnd": 765, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)"], "useStart": [861], "useEnd": [879], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chris-martin/h2/tree/master/h2/src/main/org/h2/store/fs/FilePathSplit.java", "rawCode": "  @Override\n  public int write(ByteBuffer src) throws IOException {\n    if (filePointer >= length && filePointer > maxLength) {\n      // may need to extend and create files\n      long oldFilePointer = filePointer;\n      long x = length - (length % maxLength) + maxLength;\n      for (; x < filePointer; x += maxLength) {\n        if (x > length) {\n          // expand the file size\n          position(x - 1);\n          write(ByteBuffer.wrap(new byte[1]));\n        }\n        filePointer = oldFilePointer;\n      }\n    }\n    long offset = filePointer % maxLength;\n    int len = src.remaining();\n    FileChannel channel = getFileChannel();\n    channel.position(offset);\n    int l = (int) Math.min(len, maxLength - offset);\n    if (l == len) {\n      l = channel.write(src);\n    } else {\n      int oldLimit = src.limit();\n      src.limit(src.position() + l);\n      l = channel.write(src);\n      src.limit(oldLimit);\n    }\n    filePointer += l;\n    length = Math.max(length, filePointer);\n    return l;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2108, "initialization": ["long position = DbaseFileHeaderNIO.getHeaderLength()", "long position = getRecordLength()"], "initializationStart": [733, 769], "initializationEnd": [757, 793], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.position(int)", "src.put(char)", "src.put(*)"], "configurationStart": [800, 861, 1317], "configurationEnd": [818, 883, 1357], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 1370, "focalAPIEnd": 1403, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gvtools/gvtools-legacy/tree/master/libraries/libFMap/src/com/iver/cit/gvsig/fmap/drivers/shp/DbaseFileWriterNIO.java", "rawCode": "  /**\n   * Write a single dbase record. Useful to update a dbf.\n   *\n   * @param record The entries to write.\n   * @throws IOException If IO error occurs.\n   * @throws DbaseFileException If the entry doesn't comply to the header.\n   */\n  public void writeRecord(Object[] record, int numReg) throws IOException {\n\n    if (!(channel instanceof FileChannel)) {\n      throw new IOException(\n          \"DbaseFileWriterNIO: channel is not a FileChannel. Cannot position properly\");\n    }\n\n    if (record.length != header.getNumFields()) {\n      throw new IOException(\n          \"Wrong number of fields \" + record.length + \" expected \" + header.getNumFields());\n    }\n\n    FileChannel fileChannel = (FileChannel) channel;\n    long newPos = header.getHeaderLength() + numReg * header.getRecordLength();\n\n    buffer.position(0);\n\n    // put the 'not-deleted' marker\n    buffer.put((byte) ' ');\n\n    for (int i = 0; i < header.getNumFields(); i++) {\n      String fieldString = fieldString(record[i], i);\n      // if ( header.getFieldLength(i) != fieldString.getBytes().length) {\n      // System.out.println(i + \" : \" + header.getFieldName(i));\n      // }\n\n      String tmp = fieldString;\n      while (fieldString.length() < tmp.getBytes(charset.name()).length) {\n        tmp = tmp.substring(0, tmp.length() - 2);\n      }\n      buffer.put(tmp.getBytes(charset.name()));\n    }\n\n    fileChannel.write(buffer, newPos);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2109, "initialization": ["ByteBuffer src = allocate(*)", "FileChannel fileChannel = RandomAccessFile.getChannel()"], "initializationStart": [517, 586], "initializationEnd": [555, 607], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getMessage()", "Logger.error(String)"], "tryExpressionStart": 688, "tryExpressionEnd": 692, "tryBlockStart": 688, "tryBlockEnd": 866, "catchExpressionStart": 753, "catchExpressionEnd": 775, "catchBlockStart": 753, "catchBlockEnd": 866, "exceptionHandlingCallStart": [838, 783], "exceptionHandlingCallEnd": [852, 859], "configuration": ["src.put(*)", "src.flip()"], "configurationStart": [614, 648], "configurationEnd": [642, 658], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 700, "focalAPIEnd": 721, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pgnunes/Meerkat-Monitor/tree/master/src/org/meerkat/util/FileUtil.java", "rawCode": "  /**\n   * writeToFile\n   *\n   * @param filename\n   * @param contents\n   */\n  public final void writeToFile(String filename, String contents) {\n    RandomAccessFile destFile = null;\n    File tmpFile;\n    try {\n      tmpFile = new File(filename);\n      if (tmpFile.exists()) {\n        tmpFile.delete();\n      }\n      destFile = new RandomAccessFile(filename, \"rw\");\n    } catch (FileNotFoundException e) {\n      log.error(\"Error accessing file: \" + filename + \" (\" + e.getMessage() + \")\");\n    }\n\n    ByteBuffer buf = ByteBuffer.allocate(contents.length());\n    FileChannel outChannel = destFile.getChannel();\n\n    buf.put(contents.getBytes());\n    buf.flip(); // buffer set for read\n\n    try {\n      outChannel.write(buf);\n      destFile.close();\n    } catch (IOException e) {\n      log.error(\"Error writing to file \" + filename + \" (\" + e.getMessage() + \")\");\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2110, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.array()", "src.remaining()", "src.position()"], "configurationStart": [74, 101, 232], "configurationEnd": [85, 116, 246], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 299, "focalAPIEnd": 317, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.position()"], "useStart": [359], "useEnd": [377], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yudis/h2database/tree/master/h2/src/main/org/h2/store/fs/FilePathRec.java", "rawCode": "  public int write(ByteBuffer src) throws IOException {\n    byte[] buff = src.array();\n    int len = src.remaining();\n    if (src.position() != 0 || len != buff.length) {\n      byte[] b = new byte[len];\n      System.arraycopy(buff, src.position(), b, 0, len);\n      buff = b;\n    }\n    int result = channel.write(src);\n    rec.log(Recorder.WRITE, name, buff, channel.position());\n    return result;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2111, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [953], "initializationEnd": [985], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new UnderlyingStorageException(String,*)"], "tryExpressionStart": 890, "tryExpressionEnd": 894, "tryBlockStart": 890, "tryBlockEnd": 2361, "catchExpressionStart": 2241, "catchExpressionEnd": 2263, "catchBlockStart": 2241, "catchBlockEnd": 2361, "exceptionHandlingCallStart": [2277], "exceptionHandlingCallEnd": [2354], "configuration": ["fileChannel.position(int)", "src.put(byte)", "src.flip()"], "configurationStart": [902, 993, 1055], "configurationEnd": [925, 1021, 1068], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1076, "focalAPIEnd": 1101, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.position(long)", "fileChannel.read(ByteBuffer)", "fileChannel.position(long)", "fileChannel.truncate(long)", "fileChannel.force(boolean)", "fileChannel.position(int)", "fileChannel.write(ByteBuffer)", "fileChannel.force(boolean)", "fileChannel.close()"], "useStart": [1458, 1516, 1624, 1781, 1847, 2003, 2034, 2092, 2124], "useEnd": [1492, 1545, 1659, 1816, 1871, 2026, 2059, 2116, 2143], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/neo4j-attic/graphdb/tree/master/kernel/src/main/java/org/neo4j/kernel/impl/nioneo/store/IdGeneratorImpl.java", "rawCode": "  /**\n   * Closes the id generator flushing defragged ids in memory to file. The file will be truncated to\n   * the minimal size required to hold all defragged ids and it will be marked as clean (not\n   * sticky).\n   *\n   * <p>An invoke to the <CODE>nextId</CODE> or <CODE>freeId</CODE> after this method has been\n   * invoked will result in an <CODE>IOException</CODE> since the highest returned id has been set\n   * to a negative value.\n   *\n   * @throws IOException If unable to close this id generator\n   */\n  public synchronized void close() {\n    if (nextFreeId.get() == -1) {\n      return;\n    }\n\n    // write out lists\n    if (releasedIdList.size() > 0) {\n      writeIdBatch();\n    }\n    if (defragedIdList.size() > 0) {\n      while (defragedIdList.size() > 0) {\n        releasedIdList.add(defragedIdList.removeFirst());\n      }\n      writeIdBatch();\n    }\n\n    // write header\n    try {\n      fileChannel.position(0);\n      ByteBuffer buffer = ByteBuffer.allocate(HEADER_SIZE);\n      buffer.put(STICKY_GENERATOR).putLong(nextFreeId.get());\n      buffer.flip();\n      fileChannel.write(buffer);\n      // move data to remove fragmentation in file\n      if (totalBytesRead > HEADER_SIZE) {\n        long writePosition = HEADER_SIZE;\n        long readPosition = readBlocksTo;\n        if (totalBytesRead < readBlocksTo) {\n          readPosition = totalBytesRead;\n        }\n        int bytesRead = -1;\n        do {\n          writeBuffer.clear();\n          fileChannel.position(readPosition);\n          bytesRead = fileChannel.read(writeBuffer);\n          readPosition += bytesRead;\n          writeBuffer.flip();\n          fileChannel.position(writePosition);\n          writePosition += fileChannel.write(writeBuffer);\n        } while (bytesRead > 0);\n        // truncate\n        fileChannel.truncate(writePosition);\n      }\n      // flush\n      fileChannel.force(false);\n      // remove sticky\n      buffer.clear();\n      buffer.put(CLEAN_GENERATOR);\n      buffer.limit(1);\n      buffer.flip();\n      fileChannel.position(0);\n      fileChannel.write(buffer);\n      // flush and close\n      fileChannel.force(false);\n      fileChannel.close();\n      fileChannel = null;\n      // make this generator unusable\n      nextFreeId.set(-1);\n    } catch (IOException e) {\n      throw new UnderlyingStorageException(\"Unable to close id generator \" + fileName, e);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2112, "initialization": ["ByteBuffer src = MoSyncThread.getBinaryResource(int)", "FileChannel fileChannel = FileOutputStream.getChannel()"], "initializationStart": [475, 1815], "initializationEnd": [519, 1849], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["e(String,String)", "printStackTrace()"], "tryExpressionStart": 1420, "tryExpressionEnd": 1424, "tryBlockStart": 1420, "tryBlockEnd": 2380, "catchExpressionStart": 2178, "catchExpressionEnd": 2199, "catchBlockStart": 2178, "catchBlockEnd": 2380, "exceptionHandlingCallStart": [2207, 2302], "exceptionHandlingCallEnd": [2294, 2322], "configuration": ["src.position(int)"], "configurationStart": [1904], "configurationEnd": [1925], "guardCondition": "!(!(checkIfMimeAudioType(src,offset,))) && !(null==src)", "guardType": "IF {", "guardExpressionStart": 525, "guardExpressionEnd": 547, "guardBlockStart": 525, "guardBlockEnd": 710, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1955, "focalAPIEnd": 1979, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()"], "useStart": [2047], "useEnd": [2062], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MoSync/MoSync/tree/master/runtimes/java/platforms/androidJNI/AndroidProject/src/com/mosync/internal/android/MoSyncSound.java", "rawCode": "  /**\n   * If the given resource is an audio file, store it as a file. This is done because we need an\n   * audio file to play the sound.\n   *\n   * @param soundHandle The handle to the sound object. The audio object\n   * @param dataOffset Offset into data object where mime type + audio data begins. begins with a\n   *     null terminated mime string, then follows audio data.\n   */\n  void storeIfBinaryAudioResource(int soundHandle, int offset) {\n    ByteBuffer audioData = mMoSyncThread.getBinaryResource(soundHandle);\n    if (null == audioData) {\n      SYSLOG(\"MoSyncAudio.storeIfBinaryAudioResource: \" + \"Sound data object not found\");\n      // TODO: What about returning an error code?\n      return;\n    }\n\n    // Is there a mime type at the offset?\n    if (!checkIfMimeAudioType(audioData, offset)) {\n      // No it was not.\n      SYSLOG(\"MoSyncAudio.storeIfBinaryAudioResource: \" + \"Not an audio object!\");\n      // TODO: What about returning an error code?\n      return;\n    }\n\n    // Check that we can read the mime string.\n    String mimeType = readMimeString(audioData, offset);\n    if (mimeType == null) {\n      SYSLOG(\"MoSyncAudio.storeIfBinaryAudioResource: No mime type!\");\n      // TODO: What about returning an error code?\n      return;\n    }\n    /*\n    // Determine the length of the audio data.\n    int mimeStringLength = mimeType.length() + 1;\n    */\n    // Write the entire data object to file.\n    try {\n      // Create file name.\n      String fileName = \"MOSYNCTEMP:audio\" + soundHandle + \".tmp\";\n\n      // Create a temporary audio file.\n      FileOutputStream audioFileOutputStream =\n          getActivity()\n              .openFileOutput(fileName, Context.MODE_WORLD_READABLE | Context.MODE_WORLD_WRITEABLE);\n\n      // Open a file channel to write audio data to.\n      FileChannel channel = audioFileOutputStream.getChannel();\n\n      // Set position to start of audio data.\n      audioData.position(0);\n\n      // Write data.\n      channel.write(audioData);\n\n      // Close the channel, also closes the output stream.\n      channel.close();\n\n      // Add entry to audio resource table.\n      mAudioStores.put(soundHandle, new AudioStore(fileName));\n    } catch (Exception ex) {\n      Log.e(\"MoSyncSound.storeIfBinaryAudioResource\", \"Unable to save temporary audio file.\");\n      ex.printStackTrace();\n      // TODO: What about returning an error code?\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2113, "initialization": ["FileChannel fileChannel = openChannel(long)"], "initializationStart": [235], "initializationEnd": [253], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["fatal(String,*)"], "tryExpressionStart": 154, "tryExpressionEnd": 158, "tryBlockStart": 154, "tryBlockEnd": 1964, "catchExpressionStart": 1892, "catchExpressionEnd": 1912, "catchBlockStart": 1892, "catchBlockEnd": 1964, "exceptionHandlingCallStart": [1920], "exceptionHandlingCallEnd": [1957], "configuration": ["src.clear()"], "configurationStart": [325], "configurationEnd": [338], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 420, "focalAPIEnd": 454, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.size()", "fileChannel.write(ByteBuffer,long)"], "useStart": [1721, 1807], "useEnd": [1735, 1841], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benh/twesos/tree/master/third_party/zookeeper-3.3.1/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/Bookie.java", "rawCode": "  @Override\n  public void run() {\n    LinkedList<QueueEntry> toFlush = new LinkedList<QueueEntry>();\n    ByteBuffer lenBuff = ByteBuffer.allocate(4);\n    try {\n      long logId = System.currentTimeMillis();\n      FileChannel logFile = openChannel(logId);\n      BufferedChannel bc = new BufferedChannel(logFile, 65536);\n      zeros.clear();\n      long nextPrealloc = preAllocSize;\n      long lastFlushPosition = 0;\n      logFile.write(zeros, nextPrealloc);\n      // TODO: Currently, when we roll over the journal logs, the older\n      // ones are never garbage collected. We should remove a journal log\n      // once all of its entries have been synced with the entry logs.\n      while (true) {\n        QueueEntry qe = null;\n        if (toFlush.isEmpty()) {\n          qe = queue.take();\n        } else {\n          qe = queue.poll();\n          if (qe == null || bc.position() > lastFlushPosition + 512 * 1024) {\n            // logFile.force(false);\n            bc.flush(true);\n            lastFlushPosition = bc.position();\n            lastLogMark.setLastLogMark(logId, lastFlushPosition);\n            for (QueueEntry e : toFlush) {\n              e.cb.writeComplete(0, e.ledgerId, e.entryId, null, e.ctx);\n            }\n            toFlush.clear();\n          }\n        }\n        if (qe == null) {\n          continue;\n        }\n        lenBuff.clear();\n        lenBuff.putInt(qe.entry.remaining());\n        lenBuff.flip();\n        //\n        // we should be doing the following, but then we run out of\n        // direct byte buffers\n        // logFile.write(new ByteBuffer[] { lenBuff, qe.entry });\n        bc.write(lenBuff);\n        bc.write(qe.entry);\n        if (bc.position() > nextPrealloc) {\n          nextPrealloc = (logFile.size() / preAllocSize + 1) * preAllocSize;\n          zeros.clear();\n          logFile.write(zeros, nextPrealloc);\n        }\n        toFlush.add(qe);\n      }\n    } catch (Exception e) {\n      LOG.fatal(\"Bookie thread exiting\", e);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2114, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [144], "configurationEnd": [162], "guardCondition": "!(src==null)", "guardType": "IF {", "guardExpressionStart": 87, "guardExpressionEnd": 111, "guardBlockStart": 87, "guardBlockEnd": 137, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 170, "focalAPIEnd": 191, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.position()", "fileChannel.force(boolean)"], "useStart": [253, 296], "useEnd": [266, 311], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benh/twesos/tree/master/third_party/zookeeper-3.3.1/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/BufferedChannel.java", "rawCode": "  public void flush(boolean sync) throws IOException {\n    synchronized (this) {\n      if (writeBuffer == null) {\n        return;\n      }\n      writeBuffer.flip();\n      bc.write(writeBuffer);\n      writeBuffer.clear();\n      writeBufferStartPosition = bc.position();\n    }\n    if (sync) {\n      bc.force(false);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2115, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [1923], "initializationEnd": [1945], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.size()", "src.putInt(int,int)"], "configurationStart": [182, 1969], "configurationEnd": [201, 1988], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 1994, "focalAPIEnd": 2043, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()"], "useStart": [2470], "useEnd": [2490], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mdcurtis/micromanager-upstream/tree/master/mmstudio/src/org/micromanager/acquisition/MultipageTiffReader.java", "rawCode": "  private void fixIndexMap(long firstIFD, String fileName) throws IOException {\n    long filePosition = firstIFD;\n    indexMap_ = new HashMap<String, Long>();\n    long progBarMax = (fileChannel_.size() / 2L);\n    final ProgressBar progressBar =\n        new ProgressBar(\n            \"Fixing \" + fileName,\n            0,\n            progBarMax >= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) progBarMax);\n    progressBar.setRange(0, progBarMax >= Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) progBarMax);\n    progressBar.setProgress(0);\n    progressBar.setVisible(true);\n    long nextIFDOffsetLocation = 0;\n    IFDData data;\n    while (filePosition > 0) {\n      try {\n        data = readIFD(filePosition);\n        if (data.nextIFD == 0) {\n          break;\n        }\n        TaggedImage ti = readTaggedImage(data);\n        if (ti.tags == null\n            || ti.tags.length() == 0) { // Blank placeholder image, dont add to index map\n          filePosition = data.nextIFD;\n          nextIFDOffsetLocation = data.nextIFDOffsetLocation;\n          continue;\n        }\n        String label;\n        label = MDUtils.getLabel(ti.tags);\n        if (label == null) {\n          break;\n        }\n        indexMap_.put(label, filePosition);\n\n        final int progress = (int) (filePosition / 2L);\n        SwingUtilities.invokeLater(\n            new Runnable() {\n              @Override\n              public void run() {\n                progressBar.setProgress(progress);\n              }\n            });\n\n        if (data.nextIFD <= filePosition || data.nextIFDOffsetLocation <= nextIFDOffsetLocation) {\n          break; // so no recoverable data is ever lost\n        }\n        filePosition = data.nextIFD;\n        nextIFDOffsetLocation = data.nextIFDOffsetLocation;\n      } catch (Exception e) {\n        break;\n      }\n    }\n    progressBar.setVisible(false);\n\n    filePosition += writeIndexMap(filePosition);\n\n    ByteBuffer buffer = ByteBuffer.allocate(4).order(byteOrder_);\n    buffer.putInt(0, 0);\n    fileChannel_.write(buffer, nextIFDOffsetLocation);\n\n    JSONArray settings = null;\n    try {\n      settings =\n          DisplaySettings.getDisplaySettingsFromSummary(summaryMetadata_).getJSONArray(\"Channels\");\n    } catch (Exception ex) {\n      ReportingUtils.showError(\n          ex, \"Problem saving file. PLease test to make sure file can be opened\");\n    }\n    filePosition += writeDisplaySettings(settings, filePosition);\n\n    // raFile_.setLength(filePosition + 8);\n\n    fileChannel_.close();\n    raFile_.close();\n    // reopen\n    createFileChannel(false);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2116, "initialization": ["ByteBuffer src = wrap(byte[])"], "initializationStart": [805], "initializationEnd": [831], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new VirtualFileMappingException(String,*)"], "tryExpressionStart": 374, "tryExpressionEnd": 378, "tryBlockStart": 374, "tryBlockEnd": 1588, "catchExpressionStart": 1479, "catchExpressionEnd": 1501, "catchBlockStart": 1479, "catchBlockEnd": 1588, "exceptionHandlingCallStart": [1515], "exceptionHandlingCallEnd": [1581], "configuration": ["src.rewind()"], "configurationStart": [921], "configurationEnd": [932], "guardCondition": "!(fileChannel==null)", "guardType": "IF {", "guardExpressionStart": 168, "guardExpressionEnd": 184, "guardBlockStart": 168, "guardBlockEnd": 245, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 948, "focalAPIEnd": 961, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)", "fileChannel.write(ByteBuffer)", "fileChannel.force(boolean)"], "useStart": [1008, 1337, 1455], "useEnd": [1021, 1379, 1471], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rmarins/accord/tree/master/odetteftp/core/src/main/java/org/neociclo/odetteftp/protocol/data/CompressionMapping.java", "rawCode": "  @Override\n  public long writeData(VirtualFile virtualFile, DataExchangeBuffer deb, FileChannel out)\n      throws OdetteFtpException {\n\n    int bytesWritten = 0;\n\n    if (out == null) {\n      throw new NullPointerException(\"fileChannel\");\n    }\n\n    ByteBuffer data = deb.readData();\n    Iterator<SubrecordHeader> subrecordHeaders = new SubrecordHeaderIterator(data);\n\n    try {\n      while (subrecordHeaders.hasNext()) {\n\n        SubrecordHeader header = subrecordHeaders.next();\n        int count = header.getCount();\n        boolean compressed = header.isCompressed();\n\n        if (count > 0) {\n          byte[] subrecord = new byte[(compressed ? 1 : count)];\n          // read the subrecord\n          data.get(subrecord);\n\n          // write down to the output file channel\n          ByteBuffer bb = ByteBuffer.wrap(subrecord);\n          if (compressed) {\n            for (int i = 0; i < count; i++) {\n              bb.rewind();\n              out.write(bb);\n            }\n          } else {\n            out.write(bb);\n          }\n\n          bytesWritten += count;\n        }\n\n        /*\n         * Handle the endOfRecord flag when Virtual File is TEXTFILE format\n         * to add line separator at the end of each line/record.\n         */\n        if (header.isEndOfRecord() && virtualFile.getRecordFormat() == TEXTFILE) {\n          out.write(ByteBuffer.wrap(LINE_SEPARATOR));\n          bytesWritten += LINE_SEPARATOR.length;\n        }\n      }\n\n      out.force(false);\n    } catch (IOException e) {\n      throw new VirtualFileMappingException(\"Write data operation failed.\", e);\n    }\n\n    deb.setUnitCount(bytesWritten);\n\n    return bytesWritten;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2117, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = ByteBuffer.duplicate()"], "initializationStart": [268, 979], "initializationEnd": [284, 999], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "src.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 1013, "guardExpressionEnd": 1037, "guardBlockStart": 1013, "guardBlockEnd": 1080, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1054, "focalAPIEnd": 1065, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["FileOutputStream.close()"], "finallyExpressionStart": 1466, "finallyExpressionEnd": 1474, "finallyBlockStart": 1466, "finallyBlockEnd": 1508, "cleanUpCallStart": [1486], "cleanUpCallEnd": [1497], "url": "https://github.com/elka-projekt/cs-voltdb/tree/master/tests/bench/iotest/IOBench.java", "rawCode": "    @Override\n    public Object call() throws Exception {\n      final File f = File.createTempFile(\"foo\", \"bar\", new File(\"/var/voltdb\"));\n      f.deleteOnExit();\n      try {\n        final FileOutputStream fos = new FileOutputStream(f);\n        final FileChannel fc = fos.getChannel();\n        try {\n          synchronized (readyLock) {\n            readyThreads++;\n            readyLock.notify();\n          }\n\n          synchronized (goLock) {\n            while (!goNow) {\n              goLock.wait();\n            }\n          }\n          for (int ii = 0; ii < 128; ii++) {\n            final int percentDone = (int) ((ii / 128.0) * 100.0);\n            if (extra_output && percentDone % 25 == 0) {\n              System.out.println(\n                  \"Thread \"\n                      + Thread.currentThread().getId()\n                      + \" is \"\n                      + percentDone\n                      + \"% complete with parallel test\");\n            }\n            ByteBuffer b = m_buffer.duplicate();\n            while (b.hasRemaining()) {\n              fc.write(b);\n            }\n          }\n          fos.getFD().sync();\n\n          if (extra_output) {\n            System.out.println(\"Thread \" + Thread.currentThread().getId() + \" is finished\");\n          }\n          synchronized (readyLock) {\n            readyThreads--;\n            readyLock.notifyAll();\n            while (readyThreads > 0) {\n              readyLock.wait();\n            }\n          }\n        } finally {\n          fos.close();\n        }\n      } finally {\n        f.delete();\n      }\n      return null;\n    }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2118, "initialization": ["ByteBuffer src = RawPage.bufferForReading(int)", "long position = getPageOffset(*)"], "initializationStart": [220, 283], "initializationEnd": [244, 314], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 251, "tryExpressionEnd": 255, "tryBlockStart": 251, "tryBlockEnd": 427, "catchExpressionStart": 361, "catchExpressionEnd": 383, "catchBlockStart": 361, "catchBlockEnd": 427, "exceptionHandlingCallStart": [397], "exceptionHandlingCallEnd": [420], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 322, "focalAPIEnd": 353, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rweng/jb-tree/tree/master/src/main/java/de/rwhq/io/rm/FileResourceManager.java", "rawCode": "  @Override\n  public void writePage(final RawPage page) {\n    if (LOG.isDebugEnabled()) LOG.debug(\"writing page to disk: \" + page.id());\n\n    ensureOpen();\n    ensurePageExists(page.id());\n\n    final ByteBuffer buffer = page.bufferForReading(0);\n\n    try {\n      final long offset = header.getPageOffset(page.id());\n      ioChannel.write(buffer, offset);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2119, "initialization": ["FileChannel fileChannel = RandomAccessFile.getChannel()", "ByteBuffer src = allocateDirect(int)"], "initializationStart": [373, 434], "initializationEnd": [389, 471], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [676], "configurationEnd": [686], "guardCondition": "src.remaining()<4", "guardType": "IF {", "guardExpressionStart": 639, "guardExpressionEnd": 663, "guardBlockStart": 639, "guardBlockEnd": 745, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 698, "focalAPIEnd": 711, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)", "fileChannel.close()", "fileChannel.read(ByteBuffer)", "fileChannel.read(ByteBuffer)", "fileChannel.close()", "fileChannel.close()"], "useStart": [845, 875, 1223, 1392, 1538, 1935], "useEnd": [858, 885, 1235, 1404, 1548, 1945], "hasFinally": 1, "cleanUpCall": ["FileChannel.close()"], "finallyExpressionStart": 1866, "finallyExpressionEnd": 1874, "finallyBlockStart": 1866, "finallyBlockEnd": 2076, "cleanUpCallStart": [875], "cleanUpCallEnd": [885], "url": "https://github.com/stratosphere/stratosphere/tree/master/stratosphere-runtime/src/test/java/eu/stratosphere/nephele/services/iomanager/IOManagerPerformanceBenchmark.java", "rawCode": "  @SuppressWarnings(\"resource\")\n  private final void speedTestNIO(int bufferSize, boolean direct) throws IOException {\n    final Channel.ID tmpChannel = ioManager.createChannel();\n\n    File tempFile = null;\n    FileChannel fs = null;\n\n    try {\n      tempFile = new File(tmpChannel.getPath());\n\n      RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\");\n      fs = raf.getChannel();\n\n      ByteBuffer buf =\n          direct ? ByteBuffer.allocateDirect(bufferSize) : ByteBuffer.allocate(bufferSize);\n\n      long writeStart = System.currentTimeMillis();\n\n      int valsLeft = NUM_INTS_WRITTEN;\n      while (valsLeft-- > 0) {\n        if (buf.remaining() < 4) {\n          buf.flip();\n          fs.write(buf);\n          buf.clear();\n        }\n        buf.putInt(valsLeft);\n      }\n\n      if (buf.position() > 0) {\n        buf.flip();\n        fs.write(buf);\n      }\n\n      fs.close();\n      raf.close();\n      fs = null;\n\n      long writeElapsed = System.currentTimeMillis() - writeStart;\n\n      // ----------------------------------------------------------------\n\n      raf = new RandomAccessFile(tempFile, \"r\");\n      fs = raf.getChannel();\n      buf.clear();\n\n      long readStart = System.currentTimeMillis();\n\n      fs.read(buf);\n      buf.flip();\n\n      valsLeft = NUM_INTS_WRITTEN;\n      while (valsLeft-- > 0) {\n        if (buf.remaining() < 4) {\n          buf.compact();\n          fs.read(buf);\n          buf.flip();\n        }\n        if (buf.getInt() != valsLeft) {\n          throw new IOException();\n        }\n      }\n\n      fs.close();\n      raf.close();\n\n      long readElapsed = System.currentTimeMillis() - readStart;\n\n      LOG.info(\n          \"NIO Channel with buffer \"\n              + bufferSize\n              + \": write \"\n              + writeElapsed\n              + \" msecs, read \"\n              + readElapsed\n              + \" msecs.\");\n    } finally {\n      // close if possible\n      if (fs != null) {\n        fs.close();\n        fs = null;\n      }\n      // try to delete the file\n      if (tempFile != null) {\n        tempFile.delete();\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2120, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = wrap(byte[])"], "initializationStart": [813, 856], "initializationEnd": [829, 876], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "0<src.remaining()", "guardType": "LOOP {", "guardExpressionStart": 886, "guardExpressionEnd": 913, "guardBlockStart": 886, "guardBlockEnd": 928, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 914, "focalAPIEnd": 927, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.force(boolean)"], "useStart": [937], "useEnd": [951], "hasFinally": 1, "cleanUpCall": ["FileOutputStream.close()"], "finallyExpressionStart": 988, "finallyExpressionEnd": 996, "finallyBlockStart": 988, "finallyBlockEnd": 1022, "cleanUpCallStart": [1004], "cleanUpCallEnd": [1015], "url": "https://github.com/SiteView/NEWECC9.2/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/storage/file/ReflogWriter.java", "rawCode": "  private ReflogWriter log(final String refName, final byte[] rec) throws IOException {\n    final File log = logFor(refName);\n    final boolean write =\n        forceWrite || (isLogAllRefUpdates() && shouldAutoCreateLog(refName)) || log.isFile();\n    if (!write) return this;\n\n    WriteConfig wc = getRepository().getConfig().get(WriteConfig.KEY);\n    FileOutputStream out;\n    try {\n      out = new FileOutputStream(log, true);\n    } catch (FileNotFoundException err) {\n      final File dir = log.getParentFile();\n      if (dir.exists()) throw err;\n      if (!dir.mkdirs() && !dir.isDirectory())\n        throw new IOException(MessageFormat.format(JGitText.get().cannotCreateDirectory, dir));\n      out = new FileOutputStream(log, true);\n    }\n    try {\n      if (wc.getFSyncRefFiles()) {\n        FileChannel fc = out.getChannel();\n        ByteBuffer buf = ByteBuffer.wrap(rec);\n        while (0 < buf.remaining()) fc.write(buf);\n        fc.force(true);\n      } else out.write(rec);\n    } finally {\n      out.close();\n    }\n    return this;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2121, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = allocate(*)"], "initializationStart": [369, 411], "initializationEnd": [385, 447], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [475], "configurationEnd": [485], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 493, "focalAPIEnd": 507, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()"], "useStart": [557], "useEnd": [567], "hasFinally": 1, "cleanUpCall": ["FileChannel.close()"], "finallyExpressionStart": 515, "finallyExpressionEnd": 523, "finallyBlockStart": 515, "finallyBlockEnd": 636, "cleanUpCallStart": [557], "cleanUpCallEnd": [567], "url": "https://github.com/cuckoo03/repository/tree/master/java_networking/src/com/Exam4_11CopyByteBufferTest.java", "rawCode": "  private static void copyByteBuffer() throws IOException {\n    // TODO Auto-generated method stub\n    FileInputStream fis = null;\n    FileOutputStream fos = null;\n    FileChannel in = null;\n    FileChannel out = null;\n    try {\n      fis = new FileInputStream(filePath);\n      fos = new FileOutputStream(\"copyByteBuffer.zip\");\n      in = fis.getChannel();\n      out = fos.getChannel();\n\n      ByteBuffer buf = ByteBuffer.allocate((int) in.size());\n      in.read(buf);\n      buf.flip();\n      out.write(buf);\n    } finally {\n      if (in != null) {\n        in.close();\n      }\n      if (out != null) {\n        out.close();\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2122, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [413], "initializationEnd": [435], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position(int)", "src.putInt(int)", "src.flip()"], "configurationStart": [360, 587, 618], "configurationEnd": [385, 610, 631], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 639, "focalAPIEnd": 660, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeIFD(fileChannel,int)"], "useStart": [672], "useEnd": [699], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asascience/THREDDS/tree/master/cdm/src/main/java/ucar/nc2/geotiff/GeoTiff.java", "rawCode": "  void writeMetadata(int imageNumber) throws IOException {\n    if (file == null) init();\n\n    // geokeys all get added at once\n    writeGeoKeys();\n\n    // tags gotta be in order\n    Collections.sort(tags);\n    if (imageNumber == 1) {\n      writeHeader(channel);\n    } else {\n      // now this is not the first image we need to fill the Offset of nextIFD\n      channel.position(lastIFD);\n      ByteBuffer buffer = ByteBuffer.allocate(4);\n      if (debugRead)\n        System.out.println(\n            \"position before writing nextIFD= \" + channel.position() + \" IFD is \" + firstIFD);\n      buffer.putInt(firstIFD);\n      buffer.flip();\n      channel.write(buffer);\n    }\n    writeIFD(channel, firstIFD);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2123, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 85, "focalAPIEnd": 103, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yudis/h2database/tree/master/h2/src/test/org/h2/test/utils/FilePathUnstable.java", "rawCode": "  public int write(ByteBuffer src) throws IOException {\n    checkError();\n    return channel.write(src);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2124, "initialization": ["ByteBuffer src = allocateDirect(int)", "FileChannel fileChannel = FileOutputStream.getChannel()"], "initializationStart": [904, 1030], "initializationEnd": [935, 1046], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [1110], "configurationEnd": [1120], "guardCondition": "inputChannel.read(src,)!=-1", "guardType": "LOOP {", "guardExpressionStart": 1059, "guardExpressionEnd": 1095, "guardBlockStart": 1059, "guardBlockEnd": 1196, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1134, "focalAPIEnd": 1158, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()"], "useStart": [1239], "useEnd": [1260], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apavlo/h-store/tree/master/src/frontend/org/voltdb/utils/VoltFile.java", "rawCode": "  public static void moveSubRootContents(File fromSubRoot, File toSubRoot) throws IOException {\n    assert (fromSubRoot.exists() && fromSubRoot.isDirectory());\n    assert (toSubRoot.exists() && toSubRoot.isDirectory());\n\n    for (File f : fromSubRoot.listFiles()) {\n      File fInOtherSubroot = new File(toSubRoot, f.getName());\n\n      if (f.isDirectory()) {\n        if (!fInOtherSubroot.exists()) {\n          if (!fInOtherSubroot.mkdir()) {\n            throw new IOException(\"Can't create directory \" + fInOtherSubroot);\n          }\n        }\n        moveSubRootContents(f, fInOtherSubroot);\n      } else {\n        if (!fInOtherSubroot.exists()) {\n          if (!fInOtherSubroot.createNewFile()) {\n            throw new IOException();\n          }\n\n          FileInputStream fis = new FileInputStream(f);\n          FileOutputStream fos = new FileOutputStream(fInOtherSubroot);\n          ByteBuffer buf = ByteBuffer.allocateDirect(8192);\n          FileChannel inputChannel = fis.getChannel();\n          FileChannel outputChannel = fos.getChannel();\n\n          while (inputChannel.read(buf) != -1) {\n            buf.flip();\n            outputChannel.write(buf);\n            buf.clear();\n          }\n          inputChannel.close();\n          outputChannel.close();\n        } else {\n          throw new IOException(fInOtherSubroot + \" already exists\");\n        }\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2125, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [85], "configurationEnd": [103], "guardCondition": "src.remaining()>0 && !(src==null)", "guardType": "IF {", "guardExpressionStart": 48, "guardExpressionEnd": 72, "guardBlockStart": 48, "guardBlockEnd": 80, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 185, "focalAPIEnd": 228, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/plugin/shapefile/src/main/java/org/geotools/data/shapefile/indexed/attribute/AttributeIndexWriter.java", "rawCode": "  private void drain() throws IOException {\n    if (writeBuffer == null) return;\n    writeBuffer.flip();\n    int written = 0;\n    while (writeBuffer.remaining() > 0) {\n      written += currentChannel.write(writeBuffer, position);\n    }\n    position += written;\n    writeBuffer.flip().limit(writeBuffer.capacity());\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2126, "initialization": ["ByteBuffer src = allocate(*)"], "initializationStart": [353], "initializationEnd": [401], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.put(*)", "src.flip()"], "configurationStart": [473, 497], "configurationEnd": [490, 507], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 513, "focalAPIEnd": 528, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openstreetmap/mkgmap/tree/master/src/uk/me/parabola/imgfmt/sys/FileNode.java", "rawCode": "  /**\n   * Write out any unsaved data to disk.\n   *\n   * @throws IOException If there is an error writing to disk.\n   */\n  private void sync() throws IOException {\n    if (!writeable) return;\n\n    // Ensure that a complete block is written out.\n    int bs = blockManager.getBlockSize();\n    long rem = bs - (file.position() % bs);\n\n    ByteBuffer buf = ByteBuffer.allocate(blockManager.getBlockSize());\n\n    // Complete any partial block.\n    for (int i = 0; i < rem; i++) buf.put((byte) 0);\n\n    buf.flip();\n    file.write(buf);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2127, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [136], "initializationEnd": [158], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.order(*)", "src.putLong(int,int)"], "configurationStart": [164, 305], "configurationEnd": [202, 330], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 349, "focalAPIEnd": 367, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)", "fileChannel.write(ByteBuffer)"], "useStart": [373, 756], "useEnd": [407, 776], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/maesse/CubeTech/tree/master/src/cubetech/collision/CubeMap.java", "rawCode": "  public static void serializeChunks(FileChannel out, OpenLongObjectHashMap chunks)\n      throws IOException {\n    ByteBuffer tempBuf = ByteBuffer.allocate(8);\n    tempBuf.order(ByteOrder.nativeOrder());\n    // Write header\n    // 8b long chunkcount\n    // 56b reserved\n    int count = chunks.size();\n    tempBuf.putLong(0, count).position(0);\n\n    out.write(tempBuf);\n    out.write(ByteBuffer.allocate(56));\n\n    // write chunks\n    Common.Log(\"Writing %d cube chunks to file\", count);\n    int totalChunkSize = 0;\n    for (Object object : chunks.values().elements()) {\n      CubeChunk chunk = (CubeChunk) object;\n\n      // write compressed chunk data\n      ByteBuffer chunkData = chunk.createByteBuffer();\n      totalChunkSize += chunkData.limit();\n      out.write(chunkData);\n    }\n    Common.Log(\"Compressed map data: %d kbytes\", totalChunkSize / 1024);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2128, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.transferFrom(FileChannel,int,int)", "fileChannel.position(int)"], "configurationStart": [563, 639], "configurationEnd": [633, 685], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 691, "focalAPIEnd": 726, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jeyboy/MUSIC/tree/master/lib/audiotagger/org/jaudiotagger/audio/mp4/Mp4TagWriter.java", "rawCode": "  /**\n   * Write the data including new ilst\n   *\n   * <p>can be used as long as we dont have to adjust the size of moov header\n   *\n   * @param fileReadChannel\n   * @param fileWriteChannel\n   * @param oldIlstSize\n   * @param startIlstWithinFile\n   * @param rawIlstData\n   * @throws IOException\n   */\n  private void writeDataUptoIncludingIlst(\n      FileChannel fileReadChannel,\n      FileChannel fileWriteChannel,\n      int oldIlstSize,\n      int startIlstWithinFile,\n      ByteBuffer rawIlstData)\n      throws IOException {\n    fileReadChannel.position(0);\n    fileWriteChannel.transferFrom(fileReadChannel, 0, startIlstWithinFile);\n    fileWriteChannel.position(startIlstWithinFile);\n    fileWriteChannel.write(rawIlstData);\n    fileReadChannel.position(startIlstWithinFile + oldIlstSize);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2129, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 118, "focalAPIEnd": 146, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/undertow-io/undertow/tree/master/core/src/main/java/io/undertow/websockets/core/function/ChannelFunctionFileChannel.java", "rawCode": "  @Override\n  public int write(ByteBuffer src, long position) throws IOException {\n    beforeWriting(src);\n    return channel.write(src, position);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2130, "initialization": ["ByteBuffer src = wrap(byte[])"], "initializationStart": [102], "initializationEnd": [120], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.position(int)", "src.limit(*)"], "configurationStart": [126, 149], "configurationEnd": [143, 169], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 175, "focalAPIEnd": 193, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MarkBennett/dart/tree/master/editor/attic/plugins/com.google.dart.indexer/src/com/google/dart/indexer/pagedstorage/filesystem/NioFileObject.java", "rawCode": "  @Override\n  public void write(byte[] b, int off, int len) throws IOException {\n    ByteBuffer buf = ByteBuffer.wrap(b);\n    buf.position(off);\n    buf.limit(off + len);\n    channel.write(buf);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2131, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [106], "configurationEnd": [124], "guardCondition": "src.remaining()>0", "guardType": "LOOP {", "guardExpressionStart": 154, "guardExpressionEnd": 189, "guardBlockStart": 154, "guardBlockEnd": 220, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 190, "focalAPIEnd": 219, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdeolive/geotools-old/tree/master/modules/plugin/shapefile/src/main/java/org/geotools/data/shapefile/shp/ShapefileWriter.java", "rawCode": "  /** Drain internal buffers into underlying channels. */\n  private void drain() throws IOException {\n    shapeBuffer.flip();\n    indexBuffer.flip();\n    while (shapeBuffer.remaining() > 0) shpChannel.write(shapeBuffer);\n    while (indexBuffer.remaining() > 0) shxChannel.write(indexBuffer);\n    shapeBuffer.flip().limit(shapeBuffer.capacity());\n    indexBuffer.flip().limit(indexBuffer.capacity());\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2132, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [118], "initializationEnd": [140], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position(int)", "src.put(char)", "src.put(char)", "src.putShort(*)", "src.putInt(int)", "src.flip()"], "configurationStart": [72, 146, 174, 202, 235, 265], "configurationEnd": [91, 168, 196, 229, 258, 278], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 284, "focalAPIEnd": 305, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Unidata/thredds/tree/master/cdm/src/main/java/ucar/nc2/geotiff/GeoTiff.java", "rawCode": "  private int writeHeader(FileChannel channel) throws IOException {\n    channel.position(0);\n\n    ByteBuffer buffer = ByteBuffer.allocate(8);\n    buffer.put((byte) 'M');\n    buffer.put((byte) 'M');\n    buffer.putShort((short) 42);\n    buffer.putInt(firstIFD);\n\n    buffer.flip();\n    channel.write(buffer);\n\n    return firstIFD;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2133, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new IndexException(*)"], "tryExpressionStart": 324, "tryExpressionEnd": 328, "tryBlockStart": 324, "tryBlockEnd": 2097, "catchExpressionStart": 2033, "catchExpressionEnd": 2055, "catchBlockStart": 2033, "catchBlockEnd": 2097, "exceptionHandlingCallStart": [2069], "exceptionHandlingCallEnd": [2090], "configuration": ["src.clear()", "fileChannel.position(int)", "fileChannel.read(ByteBuffer)", "src.flip()", "src.getInt()", "src.getInt()", "src.clear()", "src.putInt(int)", "src.putInt(int)", "src.flip()", "fileChannel.position(int)"], "configurationStart": [504, 526, 573, 601, 635, 669, 760, 784, 817, 844, 867], "configurationEnd": [518, 559, 593, 614, 650, 684, 774, 807, 834, 857, 900], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 916, "focalAPIEnd": 937, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.force(boolean)", "fileChannel.position(int)", "fileChannel.read(ByteBuffer)", "fileChannel.position(int)", "fileChannel.write(ByteBuffer)", "fileChannel.position(int)", "fileChannel.write(ByteBuffer)", "fileChannel.force(boolean)"], "useStart": [947, 1260, 1311, 1509, 1671, 1731, 1895, 1927], "useEnd": [966, 1293, 1331, 1542, 1692, 1772, 1916, 1946], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gvtools/gvtools-legacy/tree/master/libraries/libGDBMS/src/main/java/com/hardcode/gdbms/engine/data/indexes/hashMap/DiskIndex.java", "rawCode": "  /**\n   * DOCUMENT ME!\n   *\n   * @param v DOCUMENT ME!\n   * @param position DOCUMENT ME!\n   * @throws IndexException\n   * @see\n   *     com.hardcode.gdbms.engine.data.indexes.hashMap.Index#add(com.hardcode.gdbms.engine.values.Value,\n   *     int)\n   */\n  public void add(Object v, int position) throws IndexException {\n    try {\n      int aux;\n\n      // Obtenemos la posición en el hashtable\n      int pos = Math.abs(v.hashCode());\n      pos = (pos % positionCount);\n\n      // Leemos el contenido\n      buffer.clear();\n      channel.position(byteNumber(pos));\n      aux = channel.read(buffer);\n      buffer.flip();\n\n      int value = buffer.getInt();\n      int next = buffer.getInt();\n\n      if (value == -1) {\n        // Si la cubeta está por ocupar\n        buffer.clear();\n        buffer.putInt(position);\n        buffer.putInt(-1);\n        buffer.flip();\n        channel.position(byteNumber(pos));\n        aux = channel.write(buffer);\n        channel.force(true);\n\n        return;\n      } else {\n        // Si la cubeta está ocupada\n\n        /*\n         * iteramos hasta que encontremos el último nodo de la lista\n         */\n        while (next != -1) {\n          pos = next;\n\n          // Se lee el siguiente registro\n          buffer.clear();\n          channel.position(byteNumber(pos));\n          aux = channel.read(buffer);\n          buffer.flip();\n          value = buffer.getInt();\n          next = buffer.getInt();\n        }\n\n        // Modificamos la entrada para que enlace con la nueva\n        channel.position(byteNumber(pos));\n        buffer.clear();\n        buffer.putInt(value);\n        buffer.putInt(recordCount);\n        buffer.flip();\n        aux = channel.write(buffer);\n\n        // Ponemos la nueva\n        channel.position(byteNumber(recordCount));\n        buffer.clear();\n        buffer.putInt(position);\n        buffer.putInt(-1);\n        buffer.flip();\n        aux = channel.write(buffer);\n\n        channel.force(true);\n\n        // Actualizamos el número de registros\n        recordCount++;\n      }\n    } catch (IOException e) {\n      throw new IndexException(e);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2134, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [523], "initializationEnd": [548], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 661, "focalAPIEnd": 678, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["get()", "new IOException(*)"], "finallyExpressionStart": 2337, "finallyExpressionEnd": 2345, "finallyBlockStart": 2337, "finallyBlockEnd": 2609, "cleanUpCallStart": [1866, 2387], "cleanUpCallEnd": [1880, 2456], "url": "https://github.com/jdcasey/JGit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/lib/GitIndex.java", "rawCode": "  /**\n   * Write content of index to disk.\n   *\n   * @throws IOException\n   */\n  public void write() throws IOException {\n    checkWriteOk();\n    File tmpIndex = new File(cacheFile.getAbsoluteFile() + \".tmp\");\n    File lock = new File(cacheFile.getAbsoluteFile() + \".lock\");\n    if (!lock.createNewFile()) throw new IOException(JGitText.get().indexFileIsInUse);\n    try {\n      FileOutputStream fileOutputStream = new FileOutputStream(tmpIndex);\n      FileChannel fc = fileOutputStream.getChannel();\n      ByteBuffer buf = ByteBuffer.allocate(4096);\n      MessageDigest newMessageDigest = Constants.newMessageDigest();\n      header = new Header(entries);\n      header.write(buf);\n      buf.flip();\n      newMessageDigest.update(buf.array(), buf.arrayOffset(), buf.limit());\n      fc.write(buf);\n      buf.flip();\n      buf.clear();\n      for (Iterator i = entries.values().iterator(); i.hasNext(); ) {\n        Entry e = (Entry) i.next();\n        e.write(buf);\n        buf.flip();\n        newMessageDigest.update(buf.array(), buf.arrayOffset(), buf.limit());\n        fc.write(buf);\n        buf.flip();\n        buf.clear();\n      }\n      buf.put(newMessageDigest.digest());\n      buf.flip();\n      fc.write(buf);\n      fc.close();\n      fileOutputStream.close();\n      if (cacheFile.exists()) {\n        if (db.getFS().retryFailedLockFileCommit()) {\n          // file deletion fails on windows if another\n          // thread is reading the file concurrently\n          // So let's try 10 times...\n          boolean deleted = false;\n          for (int i = 0; i < 10; i++) {\n            if (cacheFile.delete()) {\n              deleted = true;\n              break;\n            }\n            try {\n              Thread.sleep(100);\n            } catch (InterruptedException e) {\n              // ignore\n            }\n          }\n          if (!deleted) throw new IOException(JGitText.get().couldNotRenameDeleteOldIndex);\n        } else {\n          if (!cacheFile.delete())\n            throw new IOException(JGitText.get().couldNotRenameDeleteOldIndex);\n        }\n      }\n      if (!tmpIndex.renameTo(cacheFile))\n        throw new IOException(JGitText.get().couldNotRenameTemporaryIndexFileToIndex);\n      changed = false;\n      statDirty = false;\n      lastCacheTime = cacheFile.lastModified();\n      db.fireEvent(new IndexChangedEvent());\n    } finally {\n      if (!lock.delete())\n        throw new IOException(JGitText.get().couldNotDeleteLockFileShouldNotHappen);\n      if (tmpIndex.exists() && !tmpIndex.delete())\n        throw new IOException(JGitText.get().couldNotDeleteTemporaryIndexFileShouldNotHappen);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2135, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [664], "initializationEnd": [686], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.truncate(long)", "src.put(char)", "src.flip()"], "configurationStart": [509, 696, 725], "configurationEnd": [529, 715, 735], "guardCondition": "!(fileChannel.size()!=newSize)", "guardType": "IF {", "guardExpressionStart": 539, "guardExpressionEnd": 564, "guardBlockStart": 539, "guardBlockEnd": 611, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 745, "focalAPIEnd": 758, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/java/nio/channels/FileChannel/Truncate.java", "rawCode": "  /** Test behavior of truncate method when file is opened for append */\n  static void appendTest(File blah) throws Exception {\n    for (int i = 0; i < 10; i++) {\n      long testSize = generator.nextInt(1000) + 10;\n      initTestFile(blah, testSize);\n      try (FileChannel fc =\n          (i < 5)\n              ? new FileOutputStream(blah, true).getChannel()\n              : FileChannel.open(blah.toPath(), APPEND)) {\n        // truncate file\n        long newSize = generator.nextInt((int) testSize);\n        fc.truncate(newSize);\n        if (fc.size() != newSize) throw new RuntimeException(\"Truncate failed\");\n\n        // write one byte\n        ByteBuffer buf = ByteBuffer.allocate(1);\n        buf.put((byte) 'x');\n        buf.flip();\n        fc.write(buf);\n        if (fc.size() != (newSize + 1)) throw new RuntimeException(\"Unexpected size\");\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2136, "initialization": ["FileChannel fileChannel = RandomAccessFile.getChannel()", "ByteBuffer src = wrap(*)"], "initializationStart": [156, 588], "initializationEnd": [175, 620], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["print(*)", "exit(int)"], "tryExpressionStart": 73, "tryExpressionEnd": 77, "tryBlockStart": 73, "tryBlockEnd": 1104, "catchExpressionStart": 855, "catchExpressionEnd": 879, "catchBlockStart": 855, "catchBlockEnd": 933, "exceptionHandlingCallStart": [887, 912], "exceptionHandlingCallEnd": [904, 926], "configuration": ["fileChannel.size()", "fileChannel.position(int)", "fileChannel.size()", "src.capacity()"], "configurationStart": [261, 544, 647, 679], "configurationEnd": [270, 558, 656, 698], "guardCondition": "src.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 706, "guardExpressionEnd": 737, "guardBlockStart": 706, "guardBlockEnd": 775, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 748, "focalAPIEnd": 766, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.truncate(long)", "fileChannel.close()"], "useStart": [819, 992], "useEnd": [839, 1002], "hasFinally": 1, "cleanUpCall": ["FileChannel.close()"], "finallyExpressionStart": 934, "finallyExpressionEnd": 942, "finallyBlockStart": 934, "finallyBlockEnd": 1104, "cleanUpCallStart": [992], "cleanUpCallEnd": [1002], "url": "https://github.com/blangel/ply/tree/master/java-scripts/ply-filter-file/src/main/java/net/ocheyedan/ply/script/FilterScript.java", "rawCode": "  private static void filter(File file) {\n    FileChannel fc = null;\n    try {\n      RandomAccessFile stream = new RandomAccessFile(file, \"rw\");\n      fc = stream.getChannel();\n      MappedByteBuffer mappedByteBuffer = fc.map(FileChannel.MapMode.READ_WRITE, 0, fc.size());\n      String text = Charset.defaultCharset().decode(mappedByteBuffer).toString();\n      text =\n          Filter.filter(\n              text,\n              Context.named(\"ply\"),\n              String.valueOf(System.identityHashCode(file)),\n              Props.get());\n      fc.position(0);\n      ByteBuffer filtered = ByteBuffer.wrap(text.getBytes());\n      long currentSize = fc.size();\n      long newSize = filtered.capacity();\n      while (filtered.hasRemaining()) {\n        fc.write(filtered);\n      }\n      if (newSize < currentSize) {\n        fc.truncate(newSize);\n      }\n    } catch (IOException ioe) {\n      Output.print(ioe);\n      System.exit(1);\n    } finally {\n      if (fc != null) {\n        try {\n          fc.close();\n        } catch (IOException ioe) {\n          throw new AssertionError(ioe);\n        }\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2137, "initialization": ["ByteBuffer src = allocateDirect(*)", "FileChannel fileChannel = FileOutputStream.getChannel()"], "initializationStart": [293, 558], "initializationEnd": [335, 582], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.asFloatBuffer()"], "configurationStart": [367], "configurationEnd": [385], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 704, "focalAPIEnd": 716, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()"], "useStart": [850], "useEnd": [860], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bcdev/beam-globalbedo/tree/master/beam-globalbedo-albedo-inversion/src/test/java/org/esa/beam/globalbedo/inversion/util/IOTest.java", "rawCode": "  public void testWriteFloatArray1() throws Exception {\n    float[][] fArray = new float[dim1][dim2];\n\n    for (int i = 0; i < dim1; i++) {\n      for (int j = 0; j < dim2; j++) {\n        fArray[i][j] = i * j * 1.0f;\n      }\n    }\n\n    long t1 = System.currentTimeMillis();\n    ByteBuffer bb = ByteBuffer.allocateDirect(dim1 * dim2 * 4);\n    FloatBuffer floatBuffer = bb.asFloatBuffer();\n\n    // Create an output stream to the file.\n    FileOutputStream file_output = new FileOutputStream(testfile);\n    // Create a writable file channel\n    FileChannel ch = file_output.getChannel();\n    for (int i = 0; i < dim1; i++) {\n      floatBuffer.put(fArray[i], 0, dim2);\n      // floatBuffer.clear();\n    }\n    ch.write(bb);\n    long t2 = System.currentTimeMillis();\n    System.out.println(\"write test 1 time: = \" + (t2 - t1));\n    file_output.close();\n    ch.close();\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2138, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = allocate(*)"], "initializationStart": [452, 498], "initializationEnd": [476, 534], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.putFloat(int,*)"], "configurationStart": [640], "configurationEnd": [672], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 839, "focalAPIEnd": 851, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()"], "useStart": [925], "useEnd": [935], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bcdev/beam-globalbedo/tree/master/beam-globalbedo-albedo-inversion/src/test/java/org/esa/beam/globalbedo/inversion/util/IOTest.java", "rawCode": "  public void testWriteFloatArray2() throws Exception {\n    float[][] fArray = new float[dim1][dim2];\n\n    for (int i = 0; i < dim1; i++) {\n      for (int j = 0; j < dim2; j++) {\n        fArray[i][j] = (i * dim1 + j) * 1.0f;\n      }\n    }\n\n    long t1 = System.currentTimeMillis();\n    // Create an output stream to the file.\n    FileOutputStream file_output = new FileOutputStream(testfile);\n    // Create a writable file channel\n    FileChannel ch = file_output.getChannel();\n    ByteBuffer bb = ByteBuffer.allocate(dim1 * dim2 * 4);\n\n    int index = 0;\n    for (int i = 0; i < dim1; i++) {\n      for (int j = 0; j < dim2; j++) {\n        bb.putFloat(index, fArray[i][j]);\n        index += 4;\n      }\n    }\n\n    // Write the ByteBuffer contents; the bytes between the ByteBuffer's\n    // position and the limit is written to the file\n    ch.write(bb);\n\n    long t2 = System.currentTimeMillis();\n    file_output.close();\n    ch.close();\n    System.out.println(\"write test 2 time: = \" + (t2 - t1));\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2139, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [93], "initializationEnd": [122], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.close()"], "configurationStart": [129], "configurationEnd": [156], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 174, "focalAPIEnd": 212, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)"], "useStart": [1012], "useEnd": [1056], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codefireX/platform_libcore/tree/master/luni/src/test/java/libcore/java/nio/channels/OldFileChannelTest.java", "rawCode": "  public void test_writeLByteBuffer_Closed() throws Exception {\n    ByteBuffer writeBuffer = ByteBuffer.allocate(CAPACITY);\n\n    readOnlyFileChannel.close();\n    try {\n      readOnlyFileChannel.write(writeBuffer);\n      fail(\"should throw ClosedChannelException\");\n    } catch (ClosedChannelException e) {\n      // expected\n    }\n\n    writeOnlyFileChannel.close();\n    try {\n      writeOnlyFileChannel.write(writeBuffer);\n      fail(\"should throw ClosedChannelException\");\n    } catch (ClosedChannelException e) {\n      // expected\n    }\n\n    readWriteFileChannel.close();\n    try {\n      readWriteFileChannel.write(writeBuffer);\n      fail(\"should throw ClosedChannelException\");\n    } catch (ClosedChannelException e) {\n      // expected\n    }\n\n    // should throw ClosedChannelException first\n    try {\n      readWriteFileChannel.read((ByteBuffer) null);\n      fail(\"should throw ClosedChannelException\");\n    } catch (NullPointerException e) {\n    } catch (ClosedChannelException e) {\n    }\n\n    try {\n      readOnlyFileChannel.write((ByteBuffer) null);\n      fail(\"should throw ClosedChannelException\");\n    } catch (NullPointerException e) {\n    } catch (ClosedChannelException e) {\n    }\n\n    writeOnlyFileChannel.close();\n    try {\n      writeOnlyFileChannel.write((ByteBuffer) null);\n      fail(\"should throw ClosedChannelException\");\n    } catch (NullPointerException e) {\n    } catch (ClosedChannelException e) {\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2140, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.array()", "src.remaining()", "src.position()"], "configurationStart": [74, 101, 232], "configurationEnd": [85, 116, 246], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 299, "focalAPIEnd": 317, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.position()"], "useStart": [359], "useEnd": [377], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/agueganno/h2geometry/tree/master/h2/src/main/org/h2/store/fs/FilePathRec.java", "rawCode": "  public int write(ByteBuffer src) throws IOException {\n    byte[] buff = src.array();\n    int len = src.remaining();\n    if (src.position() != 0 || len != buff.length) {\n      byte[] b = new byte[len];\n      System.arraycopy(buff, src.position(), b, 0, len);\n      buff = b;\n    }\n    int result = channel.write(src);\n    rec.log(Recorder.WRITE, name, buff, channel.position());\n    return result;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2141, "initialization": ["ByteBuffer src = wrap(byte[])"], "initializationStart": [91], "initializationEnd": [109], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.position(int)", "src.limit(*)"], "configurationStart": [115, 138], "configurationEnd": [132, 158], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 164, "focalAPIEnd": 182, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/angusmacdonald/h2o/tree/master/src/main/org/h2/store/fs/FileObjectDiskChannel.java", "rawCode": "  public void write(byte[] b, int off, int len) throws IOException {\n\n    ByteBuffer buf = ByteBuffer.wrap(b);\n    buf.position(off);\n    buf.limit(off + len);\n    channel.write(buf);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2142, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [131], "initializationEnd": [153], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position(int)", "src.putShort(*)", "src.flip()"], "configurationStart": [81, 184, 216], "configurationEnd": [104, 210, 229], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 235, "focalAPIEnd": 256, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeIFDEntry(fileChannel,*,int)", "fileChannel.position(int)", "fileChannel.write(ByteBuffer)"], "useStart": [411, 559, 811], "useEnd": [446, 598, 832], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asascience/THREDDS/tree/master/cdm/src/main/java/ucar/nc2/geotiff/GeoTiff.java", "rawCode": "  private void writeIFD(FileChannel channel, int start) throws IOException {\n    channel.position(start);\n\n    ByteBuffer buffer = ByteBuffer.allocate(2);\n    int n = tags.size();\n    buffer.putShort((short) n);\n    buffer.flip();\n    channel.write(buffer);\n\n    start += 2;\n    startOverflowData = start + 12 * tags.size() + 4;\n    nextOverflowData = startOverflowData;\n\n    for (IFDEntry elem : tags) {\n      writeIFDEntry(channel, elem, start);\n      start += 12;\n    }\n    // firstIFD = startOverflowData;\n    // position to where the \"next IFD\" goes\n    channel.position(startOverflowData - 4);\n    lastIFD = startOverflowData - 4;\n    if (debugRead) System.out.println(\"pos before writing nextIFD= \" + channel.position());\n    buffer = ByteBuffer.allocate(4);\n    buffer.putInt(0);\n    buffer.flip();\n    channel.write(buffer);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2143, "initialization": ["ByteBuffer src = allocate(*)"], "initializationStart": [353], "initializationEnd": [401], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.put(*)", "src.flip()"], "configurationStart": [473, 497], "configurationEnd": [490, 507], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 513, "focalAPIEnd": 528, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/balp/mkgmap/tree/master/src/uk/me/parabola/imgfmt/sys/FileNode.java", "rawCode": "  /**\n   * Write out any unsaved data to disk.\n   *\n   * @throws IOException If there is an error writing to disk.\n   */\n  private void sync() throws IOException {\n    if (!writeable) return;\n\n    // Ensure that a complete block is written out.\n    int bs = blockManager.getBlockSize();\n    long rem = bs - (file.position() % bs);\n\n    ByteBuffer buf = ByteBuffer.allocate(blockManager.getBlockSize());\n\n    // Complete any partial block.\n    for (int i = 0; i < rem; i++) buf.put((byte) 0);\n\n    buf.flip();\n    file.write(buf);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2144, "initialization": ["ByteBuffer src = allocateDirect(int)"], "initializationStart": [140], "initializationEnd": [175], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.put(ByteBuffer)", "src.flip()"], "configurationStart": [451, 565], "configurationEnd": [471, 583], "guardCondition": "src.remaining()==0", "guardType": "IF {", "guardExpressionStart": 521, "guardExpressionEnd": 554, "guardBlockStart": 521, "guardBlockEnd": 702, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 593, "focalAPIEnd": 614, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.position()"], "useStart": [680], "useEnd": [693], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benh/twesos/tree/master/third_party/zookeeper-3.3.1/src/contrib/bookkeeper/src/java/org/apache/bookkeeper/bookie/BufferedChannel.java", "rawCode": "  public synchronized int write(ByteBuffer src) throws IOException {\n    int copied = 0;\n    if (writeBuffer == null) {\n      writeBuffer = ByteBuffer.allocateDirect(capacity);\n    }\n    while (src.remaining() > 0) {\n      int truncated = 0;\n      if (writeBuffer.remaining() < src.remaining()) {\n        truncated = src.remaining() - writeBuffer.remaining();\n        src.limit(src.limit() - truncated);\n      }\n      copied += src.remaining();\n      writeBuffer.put(src);\n      src.limit(src.limit() + truncated);\n      if (writeBuffer.remaining() == 0) {\n        writeBuffer.flip();\n        bc.write(writeBuffer);\n        writeBuffer.clear();\n        writeBufferStartPosition = bc.position();\n      }\n    }\n    position += copied;\n    return copied;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2145, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = allocate(int)"], "initializationStart": [169, 225], "initializationEnd": [185, 250], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.put(*)", "src.flip()"], "configurationStart": [364, 428], "configurationEnd": [394, 441], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 471, "focalAPIEnd": 492, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/buzheng/buzheng-study-java/tree/master/src/main/java/org/buzheng/study/nio/WriteToFile.java", "rawCode": "  public static void main(String[] args) throws Exception {\n\n    FileOutputStream fos = new FileOutputStream(\"e:\\\\nio_dest.txt\");\n\n    // 获取通道\n    FileChannel channel = fos.getChannel();\n\n    // 建立缓冲区\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n    // 将数据写入缓冲区\n    // for (int i = 0; i < message.length; i++) {\n    // buffer.put(message[i]);\n    // }\n\n    buffer.put(message.getBytes());\n\n    // 写入前一定要将位置指针重置到缓冲区最前\n    buffer.flip();\n\n    // 将缓冲区的数据通过通道写入文件\n    channel.write(buffer);\n\n    fos.close();\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2146, "initialization": ["ByteBuffer src = wrap(*,int,*)"], "initializationStart": [494], "initializationEnd": [552], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position(long)"], "configurationStart": [433], "configurationEnd": [462], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 560, "focalAPIEnd": 582, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dCache/dcache/tree/master/modules/srm-common/src/main/java/org/dcache/srm/util/GridftpClient.java", "rawCode": "    @Override\n    public synchronized void write(Buffer buffer) throws IOException {\n      if (_source) {\n        String error = \"DiskDataSourceSink is source and write is called\";\n        logger.error(error);\n        throw new IllegalStateException(error);\n      }\n\n      _last_transfer_time = System.currentTimeMillis();\n      int read = buffer.getLength();\n      long offset = buffer.getOffset();\n      if (offset >= 0) {\n        _fileChannel.position(offset);\n      }\n      ByteBuffer bb = ByteBuffer.wrap(buffer.getBuffer(), 0, buffer.getLength());\n      _fileChannel.write(bb);\n      _transferred += read;\n    }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2147, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.remaining()"], "configurationStart": [178], "configurationEnd": [193], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 343, "focalAPIEnd": 367, "followUpCheck": "written < 0", "checkType": "IF", "followUpCheckExpressionStart": 375, "followUpCheckExpressionEnd": 391, "followUpCheckBlockStart": 375, "followUpCheckBlockEnd": 416, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/waldheinz/fat32-lib/tree/master/src/main/java/de/waldheinz/fs/util/FileDisk.java", "rawCode": "  @Override\n  public void write(long devOffset, ByteBuffer src) throws IOException {\n    checkClosed();\n\n    if (this.readOnly) throw new ReadOnlyException();\n\n    int toWrite = src.remaining();\n\n    if ((devOffset + toWrite) > getSize()) throw new IOException(\"writing past end of file\");\n\n    while (toWrite > 0) {\n      final int written = fc.write(src, devOffset);\n      if (written < 0) throw new IOException();\n      toWrite -= written;\n      devOffset += written;\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2148, "initialization": ["ByteBuffer src = allocateDirect(int)"], "initializationStart": [1027], "initializationEnd": [1058], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.clear()", "src.flip()"], "configurationStart": [1150, 1240], "configurationEnd": [1161, 1250], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1267, "focalAPIEnd": 1283, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/czarneckid/blojsom-sourceforge/tree/master/branches/blojsom-2_29-final/blojsom-2.0/src/org/blojsom/util/BlojsomUtils.java", "rawCode": "  /**\n   * Recursively copy a directory from a source to a target\n   *\n   * @param sourceDirectory Source directory\n   * @param targetDirectory Destination directory\n   * @throws IOException If there is an error copying the files and directories\n   * @since blojsom 2.06\n   */\n  public static void copyDirectory(File sourceDirectory, File targetDirectory) throws IOException {\n    File[] sourceFiles = sourceDirectory.listFiles(FILE_FILTER);\n    File[] sourceDirectories = sourceDirectory.listFiles(DIRECTORY_FILTER);\n\n    targetDirectory.mkdirs();\n\n    // Copy the files\n    if (sourceFiles != null && sourceFiles.length > 0) {\n      for (int i = 0; i < sourceFiles.length; i++) {\n        File sourceFile = sourceFiles[i];\n\n        FileInputStream fis = new FileInputStream(sourceFile);\n        FileOutputStream fos =\n            new FileOutputStream(targetDirectory + File.separator + sourceFile.getName());\n        FileChannel fcin = fis.getChannel();\n        FileChannel fcout = fos.getChannel();\n\n        ByteBuffer buf = ByteBuffer.allocateDirect(8192);\n        long size = fcin.size();\n        long n = 0;\n        while (n < size) {\n          buf.clear();\n          if (fcin.read(buf) < 0) {\n            break;\n          }\n          buf.flip();\n          n += fcout.write(buf);\n        }\n\n        fcin.close();\n        fcout.close();\n        fis.close();\n        fos.close();\n      }\n    }\n\n    // Copy the directories\n    if (sourceDirectories != null && sourceDirectories.length > 0) {\n      for (int i = 0; i < sourceDirectories.length; i++) {\n        File directory = sourceDirectories[i];\n        File newTargetDirectory = new File(targetDirectory, directory.getName());\n\n        copyDirectory(directory, newTargetDirectory);\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2149, "initialization": ["ByteBuffer src = allocateDirect(int)", "FileChannel fileChannel = RandomAccessFile.getChannel()"], "initializationStart": [376, 441], "initializationEnd": [407, 470], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [539], "configurationEnd": [564], "guardCondition": "data.read(src,)>=0", "guardType": "LOOP {", "guardExpressionStart": 482, "guardExpressionEnd": 524, "guardBlockStart": 482, "guardBlockEnd": 664, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 578, "focalAPIEnd": 611, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 683, "finallyExpressionEnd": 691, "finallyBlockStart": 683, "finallyBlockEnd": 786, "cleanUpCallStart": [743], "cleanUpCallEnd": [767], "url": "https://github.com/dmontag/graphdb-traversal-context/tree/master/ha/src/main/java/org/neo4j/kernel/ha/ToFileStoreWriter.java", "rawCode": "  public void write(String path, ReadableByteChannel data, boolean hasData) throws IOException {\n    try {\n      File file = new File(basePath, path);\n      RandomAccessFile randomAccessFile = null;\n      try {\n        file.getParentFile().mkdirs();\n        randomAccessFile = new RandomAccessFile(file, \"rw\");\n        if (hasData) {\n          ByteBuffer intermediateBuffer = ByteBuffer.allocateDirect(1024);\n          FileChannel channel = randomAccessFile.getChannel();\n          while (data.read(intermediateBuffer) >= 0) {\n            intermediateBuffer.flip();\n            channel.write(intermediateBuffer);\n            intermediateBuffer.clear();\n          }\n        }\n      } finally {\n        if (randomAccessFile != null) {\n          randomAccessFile.close();\n        }\n      }\n    } catch (Throwable t) {\n      t.printStackTrace();\n      throw new IOException(t);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2150, "initialization": ["ByteBuffer src = wrap(*)"], "initializationStart": [1424], "initializationEnd": [1483], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["gc()"], "tryExpressionStart": 1335, "tryExpressionEnd": 1339, "tryBlockStart": 1335, "tryBlockEnd": 1887, "catchExpressionStart": 1806, "catchExpressionEnd": 1828, "catchBlockStart": 1806, "catchBlockEnd": 1887, "exceptionHandlingCallStart": [1865], "exceptionHandlingCallEnd": [1876], "configuration": ["fileChannel.close()", "fileChannel.position(int)"], "configurationStart": [718, 1351], "configurationEnd": [737, 1392], "guardCondition": "!(fileChannel==null)", "guardType": "IF {", "guardExpressionStart": 500, "guardExpressionEnd": 524, "guardBlockStart": 500, "guardBlockEnd": 546, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1495, "focalAPIEnd": 1520, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.position()", "fileChannel.truncate(int)", "fileChannel.force(boolean)", "fileChannel.close()", "fileChannel.close()"], "useStart": [1553, 1532, 1588, 1702, 1929], "useEnd": [1575, 1576, 1612, 1721, 1948], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/neo4j-attic/graphdb/tree/master/kernel/src/main/java/org/neo4j/kernel/impl/nioneo/store/CommonAbstractStore.java", "rawCode": "  /**\n   * Closes this store. This will cause all buffers and channels to be closed. Requesting an\n   * operation from after this method has been invoked is illegal and an exception will be thrown.\n   *\n   * <p>This method will start by invoking the {@link #closeStorage} method giving the implementing\n   * store way to do anything that it needs to do before the fileChannel is closed.\n   *\n   * @throws IOException If problem when invoking {@link #closeStorage()}\n   */\n  public void close() {\n    if (fileChannel == null) {\n      return;\n    }\n    closeStorage();\n    if (windowPool != null) {\n      windowPool.close();\n      windowPool = null;\n    }\n    if (isReadOnly() && !isBackupSlave()) {\n      try {\n        fileChannel.close();\n      } catch (IOException e) {\n        throw new UnderlyingStorageException(e);\n      }\n      return;\n    }\n    long highId = idGenerator.getHighId();\n    int recordSize = -1;\n    if (this instanceof AbstractDynamicStore) {\n      recordSize = ((AbstractDynamicStore) this).getBlockSize();\n    } else if (this instanceof AbstractStore) {\n      recordSize = ((AbstractStore) this).getRecordSize();\n    }\n    closeIdGenerator();\n    boolean success = false;\n    IOException storedIoe = null;\n    // hack for WINBLOWS\n    if (!readOnly || backupSlave) {\n      for (int i = 0; i < 10; i++) {\n        try {\n          fileChannel.position(highId * recordSize);\n          ByteBuffer buffer = ByteBuffer.wrap(UTF8.encode(getTypeAndVersionDescriptor()));\n          fileChannel.write(buffer);\n          fileChannel.truncate(fileChannel.position());\n          fileChannel.force(false);\n          if (fileLock != null) {\n            fileLock.release();\n          }\n          fileChannel.close();\n          fileChannel = null;\n          success = true;\n          break;\n        } catch (IOException e) {\n          storedIoe = e;\n          System.gc();\n        }\n      }\n    } else {\n      try {\n        fileChannel.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n    if (!success) {\n      throw new UnderlyingStorageException(\n          \"Unable to close store \" + getStorageFileName(), storedIoe);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2151, "initialization": ["FileChannel fileChannel = java.io.RandomAccessFile.getChannel()", "ByteBuffer src = allocate(int)"], "initializationStart": [610, 1104], "initializationEnd": [627, 1140], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.asIntBuffer()", "src.clear()"], "configurationStart": [1231, 1390], "configurationEnd": [1249, 1402], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1450, "focalAPIEnd": 1469, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()"], "useStart": [1626], "useEnd": [1641], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Unidata/thredds/tree/master/cdm/src/timing/java/ucar/nc2/TimeMMap.java", "rawCode": "  static void writeChannelDirect(String filename, long fileSize, int recordSize, Stat stat)\n      throws Exception {\n    String name = \"writeCD \";\n    long endTime, size = 0;\n    long startTime = System.currentTimeMillis();\n\n    long fileSizeBytes = fileSize * 1000 * 1000; // Mbytes\n    int recordSizeBytes = recordSize * 1000; // Kbytes\n    int n = (int) (fileSizeBytes / recordSizeBytes); // number of writes\n\n    String rfilename = filename + random.nextInt();\n    java.io.RandomAccessFile file = new java.io.RandomAccessFile(rfilename, \"rw\");\n    file.setLength(fileSizeBytes);\n\n    FileChannel channel = file.getChannel();\n    if (debug)\n      System.out.println(\n          \"Opened file to write:'\"\n              + rfilename\n              + \"', size=\"\n              + channel.size()\n              + \" fileSize = \"\n              + fileSize\n              + \" Mb; recSize = \"\n              + recordSize\n              + \" Kb; nrecs = \"\n              + n);\n\n    int nelems = recordSizeBytes / 4;\n    int[] data = new int[nelems];\n    for (int i = 0; i < nelems; i++) data[i] = i;\n\n    ByteBuffer buff = ByteBuffer.allocate(recordSizeBytes);\n    // ByteBuffer buff = ByteBuffer.allocateDirect(recordSizeBytes);\n    IntBuffer src = buff.asIntBuffer();\n    // showBufferInfo(\" start bb \", buff);\n    // showBufferInfo(\" start ib \", src);\n    // n = 2;\n    for (int i = 0; i < n; i++) {\n      buff.clear();\n      src.clear();\n      src.put(data);\n      channel.write(buff);\n      showBufferInfo(\" end bb \", buff);\n      showBufferInfo(\" end ib \", src);\n      System.out.println(\" channel pos= \" + channel.position());\n    }\n\n    channel.close();\n    file.close();\n\n    endTime = System.currentTimeMillis();\n    long diff = endTime - startTime;\n    if (stat != null) stat.avg(name + filename, diff);\n    if (showEach || stat == null)\n      System.out.println(\n          \"timeWrite to \" + rfilename + \"; n records = \" + n + \" took \" + diff + \" msecs\");\n\n    if (check) checkWrite(rfilename);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2152, "initialization": ["ByteBuffer src = getBuffer(int)"], "initializationStart": [338], "initializationEnd": [360], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position()", "fileChannel.position(int)", "src.clear()", "src.limit(int)", "src.put(byte)", "src.flip()"], "configurationStart": [95, 175, 372, 398, 425, 458], "configurationEnd": [113, 209, 386, 413, 446, 471], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 483, "focalAPIEnd": 504, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.position(long)"], "useStart": [644], "useEnd": [670], "hasFinally": 1, "cleanUpCall": ["FileChannel.position(long)"], "finallyExpressionStart": 626, "finallyExpressionEnd": 634, "finallyBlockStart": 626, "finallyBlockEnd": 679, "cleanUpCallStart": [644], "cleanUpCallEnd": [670], "url": "https://github.com/neo4j-contrib/neo4j-rdf/tree/master/src/main/java/org/neo4j/rdf/fulltext/PersistentQueue.java", "rawCode": "  public synchronized void markAsCompleted(Entry... entries) {\n    try {\n      long position = channel.position();\n      try {\n        for (Entry entry : entries) {\n          channel.position(entry.position());\n          if (readNextEntryHeader(true).state == COMPLETED) {\n            continue;\n          }\n\n          ByteBuffer buffer = getBuffer(HEADER_SIZE);\n          buffer.clear();\n          buffer.limit(1);\n          buffer.put(COMPLETED);\n          buffer.flip();\n          channel.write(buffer);\n          numberOfEntriesReadButNotYetCompleted.decrementAndGet();\n        }\n        // channel.force( false );\n      } finally {\n        channel.position(position);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2153, "initialization": ["FileChannel fileChannel = java.io.RandomAccessFile.getChannel()", "ByteBuffer src = allocate(int)"], "initializationStart": [610, 1104], "initializationEnd": [627, 1140], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.asIntBuffer()", "src.clear()"], "configurationStart": [1231, 1390], "configurationEnd": [1249, 1402], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1450, "focalAPIEnd": 1469, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()"], "useStart": [1626], "useEnd": [1641], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asascience/THREDDS/tree/master/cdm/src/timing/java/ucar/nc2/TimeMMap.java", "rawCode": "  static void writeChannelDirect(String filename, long fileSize, int recordSize, Stat stat)\n      throws Exception {\n    String name = \"writeCD \";\n    long endTime, size = 0;\n    long startTime = System.currentTimeMillis();\n\n    long fileSizeBytes = fileSize * 1000 * 1000; // Mbytes\n    int recordSizeBytes = recordSize * 1000; // Kbytes\n    int n = (int) (fileSizeBytes / recordSizeBytes); // number of writes\n\n    String rfilename = filename + random.nextInt();\n    java.io.RandomAccessFile file = new java.io.RandomAccessFile(rfilename, \"rw\");\n    file.setLength(fileSizeBytes);\n\n    FileChannel channel = file.getChannel();\n    if (debug)\n      System.out.println(\n          \"Opened file to write:'\"\n              + rfilename\n              + \"', size=\"\n              + channel.size()\n              + \" fileSize = \"\n              + fileSize\n              + \" Mb; recSize = \"\n              + recordSize\n              + \" Kb; nrecs = \"\n              + n);\n\n    int nelems = recordSizeBytes / 4;\n    int[] data = new int[nelems];\n    for (int i = 0; i < nelems; i++) data[i] = i;\n\n    ByteBuffer buff = ByteBuffer.allocate(recordSizeBytes);\n    // ByteBuffer buff = ByteBuffer.allocateDirect(recordSizeBytes);\n    IntBuffer src = buff.asIntBuffer();\n    // showBufferInfo(\" start bb \", buff);\n    // showBufferInfo(\" start ib \", src);\n    // n = 2;\n    for (int i = 0; i < n; i++) {\n      buff.clear();\n      src.clear();\n      src.put(data);\n      channel.write(buff);\n      showBufferInfo(\" end bb \", buff);\n      showBufferInfo(\" end ib \", src);\n      System.out.println(\" channel pos= \" + channel.position());\n    }\n\n    channel.close();\n    file.close();\n\n    endTime = System.currentTimeMillis();\n    long diff = endTime - startTime;\n    if (stat != null) stat.avg(name + filename, diff);\n    if (showEach || stat == null)\n      System.out.println(\n          \"timeWrite to \" + rfilename + \"; n records = \" + n + \" took \" + diff + \" msecs\");\n\n    if (check) checkWrite(rfilename);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2154, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.position()", "src.limit(*)", "src.rewind()"], "configurationStart": [125, 162, 193], "configurationEnd": [138, 185, 204], "guardCondition": "true||src.position()==src.limit()", "guardType": "IF {", "guardExpressionStart": 112, "guardExpressionEnd": 153, "guardBlockStart": 112, "guardBlockEnd": 249, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 212, "focalAPIEnd": 224, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jeromerobert/jCAE/tree/master/amibe/src/org/jcae/mesh/amibe/algos3d/RandomizeGroups.java", "rawCode": "  private static void flushChannel(FileChannel fc, ByteBuffer bb, boolean force)\n      throws IOException {\n    if (force || bb.position() == bb.limit()) {\n      bb.limit(bb.position());\n      bb.rewind();\n      fc.write(bb);\n      bb.clear();\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2155, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [553], "initializationEnd": [575], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.force(boolean)", "fileChannel.position(int)", "src.put(*)", "src.put(*)"], "configurationStart": [371, 503, 608, 659], "configurationEnd": [393, 524, 631, 682], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 701, "focalAPIEnd": 727, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.force(boolean)", "fileChannel.close()"], "useStart": [733, 761], "useEnd": [755, 778], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/elka-projekt/cs-voltdb/tree/master/src/frontend/org/voltdb/DeprecatedDefaultSnapshotDataTarget.java", "rawCode": "  @Override\n  public void close() throws IOException, InterruptedException {\n    try {\n      m_outstandingWriteTasksLock.lock();\n      try {\n        while (m_outstandingWriteTasks.get() > 0) {\n          m_noMoreOutstandingWriteTasksCondition.await();\n        }\n      } finally {\n        m_outstandingWriteTasksLock.unlock();\n      }\n      m_syncTask.cancel(false);\n      m_channel.force(false);\n    } finally {\n      m_bytesAllowedBeforeSync.release(m_bytesWrittenSinceLastSync.getAndSet(0));\n    }\n    m_channel.position(8);\n    ByteBuffer completed = ByteBuffer.allocate(1);\n    if (m_writeFailed) {\n      completed.put((byte) 0).flip();\n    } else {\n      completed.put((byte) 1).flip();\n    }\n    m_channel.write(completed);\n    m_channel.force(false);\n    m_channel.close();\n    if (m_onCloseHandler != null) {\n      m_onCloseHandler.run();\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2156, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [120], "initializationEnd": [145], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.put(byte)", "src.flip()", "fileChannel.position(int)"], "configurationStart": [191, 225, 241], "configurationEnd": [212, 234, 267], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 274, "focalAPIEnd": 291, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.force(boolean)", "fileChannel.position(int)", "fileChannel.size()"], "useStart": [298, 325, 362], "useEnd": [318, 344, 376], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jmesnil/hornetq-old/tree/master/src/main/org/hornetq/core/journal/impl/NIOSequentialFile.java", "rawCode": "  public void fill(final int position, final int size, final byte fillCharacter) throws Exception {\n    ByteBuffer bb = ByteBuffer.allocate(size);\n\n    for (int i = 0; i < size; i++) {\n      bb.put(fillCharacter);\n    }\n\n    bb.flip();\n\n    channel.position(position);\n\n    channel.write(bb);\n\n    channel.force(false);\n\n    channel.position(0);\n\n    fileSize = channel.size();\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2157, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [157], "configurationEnd": [175], "guardCondition": "src.remaining()>0", "guardType": "LOOP {", "guardExpressionStart": 204, "guardExpressionEnd": 239, "guardBlockStart": 204, "guardBlockEnd": 288, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 251, "focalAPIEnd": 287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/boundlessgeo/geotools-2.7.x/tree/master/modules/plugin/shapefile/src/main/java/org/geotools/data/shapefile/indexed/IndexedFidWriter.java", "rawCode": "  /**\n   * Drain internal buffers into underlying channels.\n   *\n   * @throws IOException DOCUMENT ME!\n   */\n  private void drain() throws IOException {\n    writeBuffer.flip();\n\n    int written = 0;\n\n    while (writeBuffer.remaining() > 0) written += channel.write(writeBuffer, position);\n\n    position += written;\n\n    writeBuffer.flip().limit(writeBuffer.capacity());\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2158, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.put(int,*)", "src.rewind()"], "configurationStart": [70, 97], "configurationEnd": [89, 108], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 116, "focalAPIEnd": 133, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jeromerobert/jCAE/tree/master/amibe/src/org/jcae/mesh/xmldata/AmibeWriter.java", "rawCode": "    @Override\n    public void write(int b) throws IOException {\n      bb.put(0, (byte) b);\n      bb.rewind();\n      channel.write(bb);\n    }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2159, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IllegalArgumentException", "exceptionHandlingCall": ["dumpTrace(*)"], "tryExpressionStart": 146, "tryExpressionEnd": 150, "tryBlockStart": 146, "tryBlockEnd": 275, "catchExpressionStart": 194, "catchExpressionEnd": 229, "catchBlockStart": 194, "catchBlockEnd": 275, "exceptionHandlingCallStart": [238], "exceptionHandlingCallEnd": [250], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 166, "focalAPIEnd": 184, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CSEMike/OneSwarm/tree/master/az_src/src/org/gudy/azureus2/core3/util/DirectByteBuffer.java", "rawCode": "  public int write(byte subsystem, FileChannel chan) throws IOException {\n\n    if (TRACE) {\n\n      traceUsage(subsystem, OP_WRITE_FC);\n    }\n\n    try {\n      return (chan.write(buffer));\n\n    } catch (IllegalArgumentException e) {\n\n      dumpTrace(e);\n\n      throw (e);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2160, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["fatal(String,*)", "new RuntimeException(*)"], "tryExpressionStart": 195, "tryExpressionEnd": 199, "tryBlockStart": 195, "tryBlockEnd": 1253, "catchExpressionStart": 1132, "catchExpressionEnd": 1152, "catchBlockStart": 1132, "catchBlockEnd": 1253, "exceptionHandlingCallStart": [1160, 1223], "exceptionHandlingCallEnd": [1209, 1246], "configuration": ["src.put(byte[],int,int)", "src.rewind()", "src.limit(int)"], "configurationStart": [405, 443, 470], "configurationEnd": [431, 458, 490], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 502, "focalAPIEnd": 523, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)"], "useStart": [1041], "useEnd": [1062], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jpercent/catena/tree/master/src/main/java/syndeticlogic/catena/text/io/old/RawInvertedFileWriter.java", "rawCode": "  @Override\n  public long writeFile(\n      SortedMap<String, InvertedList> postings,\n      List<InvertedListDescriptor> invertedListDescriptors) {\n    long fileOffset = 0;\n    int count = 0;\n    try {\n      byte[] jvm = new byte[BLOCK_SIZE];\n      int offset = 0;\n      for (InvertedList list : postings.values()) {\n        int length = list.size();\n        if (offset + length >= BLOCK_SIZE) {\n          direct.put(jvm, 0, offset);\n          direct.rewind();\n          direct.limit(offset);\n          channel.write(direct);\n          direct.rewind();\n          direct.limit(direct.capacity());\n          offset = 0;\n        }\n        int written = list.encode(jvm, offset);\n        assert written == length;\n        count++;\n        invertedListDescriptors.add(\n            new InvertedListDescriptor(\n                list.getWord(), fileOffset, length, list.getDocumentFrequency()));\n        offset += length;\n        fileOffset += length;\n      }\n      direct.put(jvm, 0, offset);\n      direct.rewind();\n      direct.limit(offset);\n      channel.write(direct);\n      direct.rewind();\n      direct.limit(direct.capacity());\n    } catch (Throwable t) {\n      log.fatal(\"exception writing index file \" + t, t);\n      throw new RuntimeException(t);\n    }\n    System.err.println(\"Words indexed = \" + count);\n    return fileOffset;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2161, "initialization": ["ByteBuffer src = ChannelBuffer.toByteBuffer()"], "initializationStart": [358], "initializationEnd": [379], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 678, "focalAPIEnd": 707, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/oobium/framework/tree/master/org.oobium.app/src/org/oobium/app/server/netty4/AbstractDiskHttpData.java", "rawCode": "  @Override\n  public void addContent(ChannelBuffer buffer, boolean last) throws IOException {\n    if (buffer != null) {\n      int localsize = buffer.readableBytes();\n      if (definedSize > 0 && definedSize < size + localsize) {\n        throw new IOException(\"Out of size: \" + (size + localsize) + \" > \" + definedSize);\n      }\n      ByteBuffer byteBuffer = buffer.toByteBuffer();\n      int written = 0;\n      if (file == null) {\n        file = tempFile();\n      }\n      if (fileChannel == null) {\n        FileOutputStream outputStream = new FileOutputStream(file);\n        fileChannel = outputStream.getChannel();\n      }\n      while (written < localsize) {\n        written += fileChannel.write(byteBuffer);\n        fileChannel.force(false);\n      }\n      size += localsize;\n      buffer.readerIndex(buffer.readerIndex() + written);\n    }\n    if (last) {\n      if (file == null) {\n        file = tempFile();\n      }\n      if (fileChannel == null) {\n        FileOutputStream outputStream = new FileOutputStream(file);\n        fileChannel = outputStream.getChannel();\n      }\n      fileChannel.close();\n      fileChannel = null;\n      completed = true;\n    } else {\n      if (buffer == null) {\n        throw new NullPointerException(\"buffer\");\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2162, "initialization": ["ByteBuffer src = allocate(*)"], "initializationStart": [321], "initializationEnd": [389], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.order(ByteOrder)", "src.putInt(int)", "src.putDouble(*)", "src.putDouble(*)", "src.putDouble(*)", "src.putDouble(*)", "src.putInt(*)", "src.putInt(*)", "src.putInt(*)", "src.flip()"], "configurationStart": [396, 418, 480, 514, 548, 582, 617, 713, 756, 795], "configurationEnd": [412, 436, 508, 542, 576, 610, 650, 743, 789, 805], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 812, "focalAPIEnd": 830, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeNode(*,fileChannel,ByteOrder)"], "useStart": [893], "useEnd": [943], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/geotools/geotools/tree/master/modules/plugin/shapefile/src/main/java/org/geotools/data/shapefile/index/quadtree/fs/FileSystemIndexStore.java", "rawCode": "  /**\n   * Wites a tree node to the qix file\n   *\n   * @param node The node\n   * @param order byte order\n   * @throws IOException\n   */\n  private void writeNode(Node node, FileChannel channel, ByteOrder order)\n      throws IOException, StoreException {\n    int offset = this.getSubNodeOffset(node);\n\n    ByteBuffer buf = ByteBuffer.allocate((4 * 8) + (3 * 4) + (node.getNumShapeIds() * 4));\n\n    buf.order(order);\n    buf.putInt(offset);\n\n    Envelope env = node.getBounds();\n    buf.putDouble(env.getMinX());\n    buf.putDouble(env.getMinY());\n    buf.putDouble(env.getMaxX());\n    buf.putDouble(env.getMaxY());\n\n    buf.putInt(node.getNumShapeIds());\n\n    for (int i = 0; i < node.getNumShapeIds(); i++) {\n      buf.putInt(node.getShapeId(i));\n    }\n\n    buf.putInt(node.getNumSubNodes());\n    buf.flip();\n\n    channel.write(buf);\n\n    for (int i = 0; i < node.getNumSubNodes(); i++) {\n      this.writeNode(node.getSubNode(i), channel, order);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2163, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [149], "initializationEnd": [172], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position(int)", "src.putShort(*)", "src.putShort(*)", "src.putInt(*)", "src.put(*)", "src.flip()"], "configurationStart": [100, 179, 227, 271, 474, 502], "configurationEnd": [123, 221, 265, 295, 494, 515], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 523, "focalAPIEnd": 544, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)", "fileChannel.position(int)", "fileChannel.write(ByteBuffer)"], "useStart": [642, 691, 909], "useEnd": [663, 725, 931], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asascience/THREDDS/tree/master/cdm/src/main/java/ucar/nc2/geotiff/GeoTiff.java", "rawCode": "  private void writeIFDEntry(FileChannel channel, IFDEntry ifd, int start) throws IOException {\n    channel.position(start);\n    ByteBuffer buffer = ByteBuffer.allocate(12);\n\n    buffer.putShort((short) ifd.tag.getCode());\n    buffer.putShort((short) ifd.type.code);\n    buffer.putInt(ifd.count);\n\n    int size = ifd.count * ifd.type.size;\n    if (size <= 4) {\n      int done = writeValues(buffer, ifd);\n      for (int k = 0; k < 4 - done; k++) // fill out to 4 bytes\n      buffer.put((byte) 0);\n      buffer.flip();\n      channel.write(buffer);\n\n    } else { // write offset\n      buffer.putInt(nextOverflowData);\n      buffer.flip();\n      channel.write(buffer);\n      // write data\n      channel.position(nextOverflowData);\n      // System.out.println(\" write offset = \"+ifd.tag.getName());\n      ByteBuffer vbuffer = ByteBuffer.allocate(size);\n      writeValues(vbuffer, ifd);\n      vbuffer.flip();\n      channel.write(vbuffer);\n      nextOverflowData += size;\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2164, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [413], "initializationEnd": [435], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position(int)", "src.putInt(int)", "src.flip()"], "configurationStart": [360, 587, 618], "configurationEnd": [385, 610, 631], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 639, "focalAPIEnd": 660, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeIFD(fileChannel,int)"], "useStart": [672], "useEnd": [699], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Unidata/thredds/tree/master/cdm/src/main/java/ucar/nc2/geotiff/GeoTiff.java", "rawCode": "  void writeMetadata(int imageNumber) throws IOException {\n    if (file == null) init();\n\n    // geokeys all get added at once\n    writeGeoKeys();\n\n    // tags gotta be in order\n    Collections.sort(tags);\n    if (imageNumber == 1) {\n      writeHeader(channel);\n    } else {\n      // now this is not the first image we need to fill the Offset of nextIFD\n      channel.position(lastIFD);\n      ByteBuffer buffer = ByteBuffer.allocate(4);\n      if (debugRead)\n        System.out.println(\n            \"position before writing nextIFD= \" + channel.position() + \" IFD is \" + firstIFD);\n      buffer.putInt(firstIFD);\n      buffer.flip();\n      channel.write(buffer);\n    }\n    writeIFD(channel, firstIFD);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2165, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = allocate(*)"], "initializationStart": [230, 291], "initializationEnd": [259, 336], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.order(*)", "src.flip()"], "configurationStart": [342, 408], "configurationEnd": [379, 421], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 428, "focalAPIEnd": 449, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.force(boolean)", "close(fileChannel)"], "useStart": [455, 481], "useEnd": [474, 506], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iansealy/picard-detct/tree/master/src/java/net/sf/picard/illumina/parser/fakers/BciFileFaker.java", "rawCode": "  public void fakeBciFile(final File bci, final List<Integer> expectedTiles) throws IOException {\n    tiles = expectedTiles;\n    final FileOutputStream fileOutputStream = new FileOutputStream(bci);\n    final FileChannel channel = fileOutputStream.getChannel();\n    final ByteBuffer buffer = ByteBuffer.allocate(8 * expectedTiles.size());\n    buffer.order(ByteOrder.LITTLE_ENDIAN);\n\n    fakeFile(buffer);\n    buffer.flip();\n\n    channel.write(buffer);\n    channel.force(true);\n\n    CloserUtil.close(channel);\n    CloserUtil.close(fileOutputStream);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2166, "initialization": ["ByteBuffer src = allocateDirect(int)"], "initializationStart": [1027], "initializationEnd": [1058], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.clear()", "src.flip()"], "configurationStart": [1150, 1240], "configurationEnd": [1161, 1250], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1267, "focalAPIEnd": 1283, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/czarneckid/blojsom-sourceforge/tree/master/branches/blojsom-2_23-final/blojsom-2.0/src/org/blojsom/util/BlojsomUtils.java", "rawCode": "  /**\n   * Recursively copy a directory from a source to a target\n   *\n   * @param sourceDirectory Source directory\n   * @param targetDirectory Destination directory\n   * @throws IOException If there is an error copying the files and directories\n   * @since blojsom 2.06\n   */\n  public static void copyDirectory(File sourceDirectory, File targetDirectory) throws IOException {\n    File[] sourceFiles = sourceDirectory.listFiles(FILE_FILTER);\n    File[] sourceDirectories = sourceDirectory.listFiles(DIRECTORY_FILTER);\n\n    targetDirectory.mkdirs();\n\n    // Copy the files\n    if (sourceFiles != null && sourceFiles.length > 0) {\n      for (int i = 0; i < sourceFiles.length; i++) {\n        File sourceFile = sourceFiles[i];\n\n        FileInputStream fis = new FileInputStream(sourceFile);\n        FileOutputStream fos =\n            new FileOutputStream(targetDirectory + File.separator + sourceFile.getName());\n        FileChannel fcin = fis.getChannel();\n        FileChannel fcout = fos.getChannel();\n\n        ByteBuffer buf = ByteBuffer.allocateDirect(8192);\n        long size = fcin.size();\n        long n = 0;\n        while (n < size) {\n          buf.clear();\n          if (fcin.read(buf) < 0) {\n            break;\n          }\n          buf.flip();\n          n += fcout.write(buf);\n        }\n\n        fcin.close();\n        fcout.close();\n        fis.close();\n        fos.close();\n      }\n    }\n\n    // Copy the directories\n    if (sourceDirectories != null && sourceDirectories.length > 0) {\n      for (int i = 0; i < sourceDirectories.length; i++) {\n        File directory = sourceDirectories[i];\n        File newTargetDirectory = new File(targetDirectory, directory.getName());\n\n        copyDirectory(directory, newTargetDirectory);\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2167, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.position()", "src.limit(*)", "src.position(int)"], "configurationStart": [152, 228, 311], "configurationEnd": [173, 267, 333], "guardCondition": "src.position()!=0", "guardType": "IF {", "guardExpressionStart": 148, "guardExpressionEnd": 179, "guardBlockStart": 148, "guardBlockEnd": 518, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 407, "focalAPIEnd": 432, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mauricio/jai-imageio/tree/master/src/share/classes/com/sun/media/imageio/stream/FileChannelImageOutputStream.java", "rawCode": "  /** Write to the <code>FileChannel</code> any remaining bytes in the byte output buffer. */\n  private void flushBuffer() throws IOException {\n    if (byteBuffer.position() != 0) {\n      // Set the limit to the position.\n      byteBuffer.limit(byteBuffer.position());\n\n      // Set the position to zero.\n      byteBuffer.position(0);\n\n      // Write all bytes between zero and the previous position.\n      channel.write(byteBuffer);\n\n      // Prepare for subsequent put() calls if any.\n      byteBuffer.clear();\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2168, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [67], "initializationEnd": [97], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["convert(*)"], "tryExpressionStart": 35, "tryExpressionEnd": 39, "tryBlockStart": 35, "tryBlockEnd": 736, "catchExpressionStart": 685, "catchExpressionEnd": 705, "catchBlockStart": 685, "catchBlockEnd": 736, "exceptionHandlingCallStart": [719], "exceptionHandlingCallEnd": [729], "configuration": ["src.put(*)", "src.rewind()", "fileChannel.position(int)"], "configurationStart": [495, 534, 577], "configurationEnd": [526, 549, 593], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 601, "focalAPIEnd": 619, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.position(int)", "fileChannel.write(ByteBuffer)"], "useStart": [627, 659], "useEnd": [651, 677], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/coderplay/h2-bitmap/tree/master/h2/src/tools/org/h2/dev/store/btree/MVStore.java", "rawCode": "  private void writeHeader() {\n    try {\n      ByteBuffer header = ByteBuffer.allocate(blockSize);\n      String h =\n          \"H:3,\"\n              + \"versionRead:1,\"\n              + \"versionWrite:1,\"\n              + \"blockSize:\"\n              + blockSize\n              + \",\"\n              + \"rootChunk:\"\n              + rootChunkStart\n              + \",\"\n              + \"lastMapId:\"\n              + lastMapId\n              + \",\"\n              + \"version:\"\n              + currentVersion;\n      header.put(h.getBytes(\"UTF-8\"));\n      header.rewind();\n      writeCount++;\n      file.position(0);\n      file.write(header);\n      file.position(blockSize);\n      file.write(header);\n    } catch (Exception e) {\n      throw convert(e);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2169, "initialization": ["FileChannel fileChannel = RandomAccessFile.getChannel()", "ByteBuffer src = allocateDirect(int)"], "initializationStart": [341, 402], "initializationEnd": [357, 439], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [644], "configurationEnd": [654], "guardCondition": "src.remaining()<4", "guardType": "IF {", "guardExpressionStart": 607, "guardExpressionEnd": 631, "guardBlockStart": 607, "guardBlockEnd": 713, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 666, "focalAPIEnd": 679, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)", "fileChannel.close()", "fileChannel.read(ByteBuffer)", "fileChannel.read(ByteBuffer)", "fileChannel.close()", "fileChannel.close()"], "useStart": [813, 843, 1172, 1341, 1487, 1882], "useEnd": [826, 853, 1184, 1353, 1497, 1892], "hasFinally": 1, "cleanUpCall": ["FileChannel.close()"], "finallyExpressionStart": 1813, "finallyExpressionEnd": 1821, "finallyBlockStart": 1813, "finallyBlockEnd": 2023, "cleanUpCallStart": [843], "cleanUpCallEnd": [853], "url": "https://github.com/stratosphere-eu/stratosphere/tree/master/nephele/nephele-server/src/test/java/eu/stratosphere/nephele/services/iomanager/IOManagerPerformanceBenchmark.java", "rawCode": "  private final void speedTestNIO(int bufferSize, boolean direct) throws IOException {\n    final Channel.ID tmpChannel = ioManager.createChannel();\n\n    File tempFile = null;\n    FileChannel fs = null;\n\n    try {\n      tempFile = new File(tmpChannel.getPath());\n\n      RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\");\n      fs = raf.getChannel();\n\n      ByteBuffer buf =\n          direct ? ByteBuffer.allocateDirect(bufferSize) : ByteBuffer.allocate(bufferSize);\n\n      long writeStart = System.currentTimeMillis();\n\n      int valsLeft = NUM_INTS_WRITTEN;\n      while (valsLeft-- > 0) {\n        if (buf.remaining() < 4) {\n          buf.flip();\n          fs.write(buf);\n          buf.clear();\n        }\n        buf.putInt(valsLeft);\n      }\n\n      if (buf.position() > 0) {\n        buf.flip();\n        fs.write(buf);\n      }\n\n      fs.close();\n      fs = null;\n\n      long writeElapsed = System.currentTimeMillis() - writeStart;\n\n      // ----------------------------------------------------------------\n\n      raf = new RandomAccessFile(tempFile, \"r\");\n      fs = raf.getChannel();\n      buf.clear();\n\n      long readStart = System.currentTimeMillis();\n\n      fs.read(buf);\n      buf.flip();\n\n      valsLeft = NUM_INTS_WRITTEN;\n      while (valsLeft-- > 0) {\n        if (buf.remaining() < 4) {\n          buf.compact();\n          fs.read(buf);\n          buf.flip();\n        }\n        if (buf.getInt() != valsLeft) {\n          throw new IOException();\n        }\n      }\n\n      fs.close();\n      fs = null;\n\n      long readElapsed = System.currentTimeMillis() - readStart;\n\n      LOG.info(\n          \"NIO Channel with buffer \"\n              + bufferSize\n              + \": write \"\n              + writeElapsed\n              + \" msecs, read \"\n              + readElapsed\n              + \" msecs.\");\n    } finally {\n      // close if possible\n      if (fs != null) {\n        fs.close();\n        fs = null;\n      }\n      // try to delete the file\n      if (tempFile != null) {\n        tempFile.delete();\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2170, "initialization": ["ByteBuffer src = wrap(String)"], "initializationStart": [131], "initializationEnd": [172], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["error(*)"], "tryExpressionStart": 890, "tryExpressionEnd": 894, "tryBlockStart": 890, "tryBlockEnd": 1007, "catchExpressionStart": 1313, "catchExpressionEnd": 1336, "catchBlockStart": 1313, "catchBlockEnd": 1367, "exceptionHandlingCallStart": [1174], "exceptionHandlingCallEnd": [1190], "configuration": ["fileChannel.position(int)"], "configurationStart": [1016], "configurationEnd": [1039], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1049, "focalAPIEnd": 1074, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/feuyeux/quiland/tree/master/java/air-io/src/main/java/feuyeux/io/nio2/TestChannelLock.java", "rawCode": "  public static void main(String[] args) {\n    Path path = Paths.get(\"C:/rafaelnadal/email\", \"vamos.txt\");\n    ByteBuffer buffer = ByteBuffer.wrap(\"Vamos Rafa!\".getBytes());\n\n    try (FileChannel fileChannel =\n        FileChannel.open(path, EnumSet.of(StandardOpenOption.READ, StandardOpenOption.WRITE))) {\n\n      // Use the file channel to create a lock on the file.\n      // This method blocks until it can retrieve the lock.\n      FileLock lock = fileChannel.lock();\n\n      // Try acquiring the lock without blocking. This method returns\n      // null or throws an exception if the file is already locked.\n      // try {\n      // lock = fileChannel.tryLock();\n      // } catch (OverlappingFileLockException e) {\n      // File is already locked in this thread or virtual machine\n      // }\n\n      if (lock.isValid()) {\n\n        System.out.println(\"Writing to a locked file ...\");\n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException ex) {\n          logger.error(ex);\n        }\n        fileChannel.position(0);\n        fileChannel.write(buffer);\n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException ex) {\n          logger.error(ex);\n        }\n      }\n\n      // Release the lock\n      lock.release();\n\n      System.out.println(\"\\nLock released!\");\n\n    } catch (IOException ex) {\n      logger.error(ex);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2171, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,offset,length)", "focalAPIStart": 120, "focalAPIEnd": 165, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()", "fileChannel.write(ByteBuffer[],int,int)"], "useStart": [679, 724], "useEnd": [706, 769], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TaintDroid/android_platform_libcore/tree/master/luni/src/test/java/libcore/java/nio/channels/OldFileChannelTest.java", "rawCode": "  public void test_write$LByteBufferII_Null() throws Exception {\n    ByteBuffer[] writeBuffers = null;\n\n    try {\n      readOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    try {\n      writeOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    try {\n      readWriteFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    // first throws NullPointerException\n    readOnlyFileChannel.close();\n    try {\n      readOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    writeOnlyFileChannel.close();\n    try {\n      writeOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    readWriteFileChannel.close();\n    try {\n      readWriteFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2172, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [60], "configurationEnd": [73], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 79, "focalAPIEnd": 104, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/neo4j-attic/graphdb/tree/master/kernel/src/main/java/org/neo4j/kernel/impl/transaction/xaframework/DirectLogBuffer.java", "rawCode": "  private LogBuffer flipAndWrite() throws IOException {\n    buffer.flip();\n    fileChannel.write(buffer);\n    return this;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2173, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.clear()", "src.putDouble(double)", "src.flip()"], "configurationStart": [209, 241, 278], "configurationEnd": [231, 268, 299], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 309, "focalAPIEnd": 363, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dmontag/graphdb-traversal-context/tree/master/kernel/src/main/java/org/neo4j/kernel/impl/transaction/xaframework/MemoryMappedLogBuffer.java", "rawCode": "  public LogBuffer putDouble(double d) throws IOException {\n    if (mappedBuffer == null || (MAPPED_SIZE - mappedBuffer.position()) < 8) {\n      getNewMappedBuffer();\n      if (mappedBuffer == null) {\n        fallbackBuffer.clear();\n        fallbackBuffer.putDouble(d);\n        fallbackBuffer.flip();\n        fileChannel.write(fallbackBuffer, mappedStartPosition);\n        mappedStartPosition += 8;\n        return this;\n      }\n    }\n    mappedBuffer.putDouble(d);\n    return this;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2174, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.remaining()"], "configurationStart": [121], "configurationEnd": [136], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 330, "focalAPIEnd": 355, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yudis/h2database/tree/master/h2/src/tools/org/h2/dev/store/FilePathCache.java", "rawCode": "    public int write(ByteBuffer src, long position) throws IOException {\n      if (cache.size() > 0) {\n        int len = src.remaining();\n        long p = getCachePos(position);\n        while (len > 0) {\n          cache.remove(p);\n          p += CACHE_BLOCK_SIZE;\n          len -= CACHE_BLOCK_SIZE;\n        }\n      }\n      return base.write(src, position);\n    }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2175, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position(long)", "src.flip()"], "configurationStart": [446, 485], "configurationEnd": [477, 503], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 511, "focalAPIEnd": 537, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.position()"], "useStart": [561], "useEnd": [579], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/encog/encog-java-core/tree/master/src/main/java/org/encog/ml/data/buffer/EncogEGBFile.java", "rawCode": "  /**\n   * Check a write, make sure there is enough room to write.\n   *\n   * @param writeBuffer The buffer.\n   * @param inWriteLocation The write location.\n   * @return The new write location.\n   * @throws IOException If an IO error occurs.\n   */\n  private long checkWrite(final ByteBuffer writeBuffer, final long inWriteLocation)\n      throws IOException {\n    long writeLocation = inWriteLocation;\n\n    if (!writeBuffer.hasRemaining()) {\n      this.fc.position(writeLocation);\n      writeBuffer.flip();\n      this.fc.write(writeBuffer);\n      writeLocation = this.fc.position();\n      writeBuffer.clear();\n      writeBuffer.order(ByteOrder.LITTLE_ENDIAN);\n    }\n\n    return writeLocation;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2176, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.clear()", "src.putLong(long)", "src.flip()"], "configurationStart": [205, 237, 272], "configurationEnd": [227, 262, 293], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 303, "focalAPIEnd": 357, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/neo4j-attic/graphdb/tree/master/kernel/src/main/java/org/neo4j/kernel/impl/transaction/xaframework/MemoryMappedLogBuffer.java", "rawCode": "  public LogBuffer putLong(long l) throws IOException {\n    if (mappedBuffer == null || (MAPPED_SIZE - mappedBuffer.position()) < 8) {\n      getNewMappedBuffer();\n      if (mappedBuffer == null) {\n        fallbackBuffer.clear();\n        fallbackBuffer.putLong(l);\n        fallbackBuffer.flip();\n        fileChannel.write(fallbackBuffer, mappedStartPosition);\n        mappedStartPosition += 8;\n        return this;\n      }\n    }\n    mappedBuffer.putLong(l);\n    return this;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2177, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [93], "initializationEnd": [122], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.close()"], "configurationStart": [129], "configurationEnd": [156], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 174, "focalAPIEnd": 212, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)"], "useStart": [1012], "useEnd": [1056], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/test/java/libcore/java/nio/channels/OldFileChannelTest.java", "rawCode": "  public void test_writeLByteBuffer_Closed() throws Exception {\n    ByteBuffer writeBuffer = ByteBuffer.allocate(CAPACITY);\n\n    readOnlyFileChannel.close();\n    try {\n      readOnlyFileChannel.write(writeBuffer);\n      fail(\"should throw ClosedChannelException\");\n    } catch (ClosedChannelException e) {\n      // expected\n    }\n\n    writeOnlyFileChannel.close();\n    try {\n      writeOnlyFileChannel.write(writeBuffer);\n      fail(\"should throw ClosedChannelException\");\n    } catch (ClosedChannelException e) {\n      // expected\n    }\n\n    readWriteFileChannel.close();\n    try {\n      readWriteFileChannel.write(writeBuffer);\n      fail(\"should throw ClosedChannelException\");\n    } catch (ClosedChannelException e) {\n      // expected\n    }\n\n    // should throw ClosedChannelException first\n    try {\n      readWriteFileChannel.read((ByteBuffer) null);\n      fail(\"should throw ClosedChannelException\");\n    } catch (NullPointerException e) {\n    } catch (ClosedChannelException e) {\n    }\n\n    try {\n      readOnlyFileChannel.write((ByteBuffer) null);\n      fail(\"should throw ClosedChannelException\");\n    } catch (NullPointerException e) {\n    } catch (ClosedChannelException e) {\n    }\n\n    writeOnlyFileChannel.close();\n    try {\n      writeOnlyFileChannel.write((ByteBuffer) null);\n      fail(\"should throw ClosedChannelException\");\n    } catch (NullPointerException e) {\n    } catch (ClosedChannelException e) {\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2178, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [157], "configurationEnd": [175], "guardCondition": "src.remaining()>0", "guardType": "LOOP {", "guardExpressionStart": 204, "guardExpressionEnd": 239, "guardBlockStart": 204, "guardBlockEnd": 288, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 251, "focalAPIEnd": 287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/unsupported/shapefile-ng/src/main/java/org/geotools/data/shapefile/ng/fid/IndexedFidWriter.java", "rawCode": "  /**\n   * Drain internal buffers into underlying channels.\n   *\n   * @throws IOException DOCUMENT ME!\n   */\n  private void drain() throws IOException {\n    writeBuffer.flip();\n\n    int written = 0;\n\n    while (writeBuffer.remaining() > 0) written += channel.write(writeBuffer, position);\n\n    position += written;\n\n    writeBuffer.flip().limit(writeBuffer.capacity());\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2179, "initialization": ["ByteBuffer src = allocate(*)"], "initializationStart": [395], "initializationEnd": [463], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.order(ByteOrder)", "src.putInt(int)", "src.putDouble(*)", "src.putDouble(*)", "src.putDouble(*)", "src.putDouble(*)", "src.putInt(*)", "src.putInt(*)", "src.putInt(*)", "src.flip()"], "configurationStart": [470, 492, 554, 588, 622, 656, 691, 787, 830, 869], "configurationEnd": [486, 510, 582, 616, 650, 684, 724, 817, 863, 879], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 886, "focalAPIEnd": 904, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeNode(*,fileChannel,ByteOrder)"], "useStart": [967], "useEnd": [1017], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/boundlessgeo/geotools-2.7.x/tree/master/modules/plugin/shapefile/src/main/java/org/geotools/index/quadtree/fs/FileSystemIndexStore.java", "rawCode": "  /**\n   * Wites a tree node to the qix file\n   *\n   * @param node The node\n   * @param channel DOCUMENT ME!\n   * @param order byte order\n   * @throws IOException\n   * @throws StoreException DOCUMENT ME!\n   */\n  private void writeNode(Node node, FileChannel channel, ByteOrder order)\n      throws IOException, StoreException {\n    int offset = this.getSubNodeOffset(node);\n\n    ByteBuffer buf = ByteBuffer.allocate((4 * 8) + (3 * 4) + (node.getNumShapeIds() * 4));\n\n    buf.order(order);\n    buf.putInt(offset);\n\n    Envelope env = node.getBounds();\n    buf.putDouble(env.getMinX());\n    buf.putDouble(env.getMinY());\n    buf.putDouble(env.getMaxX());\n    buf.putDouble(env.getMaxY());\n\n    buf.putInt(node.getNumShapeIds());\n\n    for (int i = 0; i < node.getNumShapeIds(); i++) {\n      buf.putInt(node.getShapeId(i));\n    }\n\n    buf.putInt(node.getNumSubNodes());\n    buf.flip();\n\n    channel.write(buf);\n\n    for (int i = 0; i < node.getNumSubNodes(); i++) {\n      this.writeNode(node.getSubNode(i), channel, order);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2180, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = PEOldMSHeader.get()"], "initializationStart": [197, 800], "initializationEnd": [213, 817], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 837, "focalAPIEnd": 860, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.transferFrom(FileChannel,int,int)", "fileChannel.position(long)", "fileChannel.write(ByteBuffer)", "fileChannel.position(long)", "fileChannel.write(ByteBuffer)", "fileChannel.position(long)", "fileChannel.write(ByteBuffer)", "fileChannel.write(ByteBuffer,int)", "fileChannel.position(long)", "fileChannel.position(int)", "fileChannel.write(ByteBuffer,int)", "fileChannel.transferFrom(*,long,*)", "fileChannel.position(long)", "fileChannel.write(ByteBuffer)", "fileChannel.position(long)", "fileChannel.write(ByteBuffer)"], "useStart": [899, 1055, 1101, 1324, 1561, 2353, 2577, 2861, 3832, 3953, 4056, 4131, 5980, 6026, 6246, 6514], "useEnd": [954, 1081, 1122, 1344, 1575, 2373, 2594, 2890, 3852, 3994, 4106, 4191, 6006, 6047, 6266, 6528], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BrunoReX/jsmooth/tree/master/src/net/charabia/jsmoothgen/pe/PEFile.java", "rawCode": "  public void dumpTo(File destination) throws IOException, CloneNotSupportedException {\n    int outputcount = 0;\n    FileOutputStream fos = new FileOutputStream(destination);\n    FileChannel out = fos.getChannel();\n\n    //\n    // Make a copy of the Header, for safe modifications\n    //\n    PEOldMSHeader oldmsheader = (PEOldMSHeader) this.m_oldmsheader.clone();\n    PEHeader peheader = (PEHeader) m_header.clone();\n    Vector sections = new Vector();\n    for (int i = 0; i < m_sections.size(); i++) {\n      PESection sect = (PESection) m_sections.get(i);\n      PESection cs = (PESection) sect.clone();\n      sections.add(cs);\n    }\n\n    //\n    // First, write the old MS Header, the one starting\n    // with \"MZ\"...\n    //\n    long newexeoffset = oldmsheader.e_lfanew;\n    ByteBuffer msheadbuffer = oldmsheader.get();\n    outputcount = out.write(msheadbuffer);\n    this.m_channel.position(64);\n    out.transferFrom(this.m_channel, 64, newexeoffset - 64);\n\n    //\n    // Then Write the new Header...\n    //\n    ByteBuffer headbuffer = peheader.get();\n    out.position(newexeoffset);\n    outputcount = out.write(headbuffer);\n\n    //\n    // After the header, there are all the section\n    // headers...\n    //\n    long offset =\n        oldmsheader.e_lfanew + (m_header.NumberOfRvaAndSizes * 8) + 24 + getPeHeaderOffset();\n    out.position(offset);\n    for (int i = 0; i < sections.size(); i++) {\n      // System.out.println(\" offset: \" + out.position());\n      PESection sect = (PESection) sections.get(i);\n\n      ByteBuffer buf = sect.get();\n      outputcount = out.write(buf);\n    }\n\n    //\n    // Now, we write the real data: each of the section\n    // and their data...\n    //\n\n    // Not sure why it's always at 1024... ?\n    offset = 1024;\n\n    //\n    // Dump each section data\n    //\n\n    long virtualAddress = offset;\n    if ((virtualAddress % peheader.SectionAlignment) > 0)\n      virtualAddress += peheader.SectionAlignment - (virtualAddress % peheader.SectionAlignment);\n\n    long resourceoffset = m_header.ResourceDirectory_VA;\n    for (int i = 0; i < sections.size(); i++) {\n      PESection sect = (PESection) sections.get(i);\n      if (resourceoffset == sect.VirtualAddress) {\n        // System.out.println(\"Dumping RES section \" + i + \" at \" + offset + \" from \" +\n        // sect.PointerToRawData + \" (VA=\" + virtualAddress + \")\");\n        out.position(offset);\n        long sectoffset = offset;\n        PEResourceDirectory prd = this.getResourceDirectory();\n        ByteBuffer resbuf = prd.buildResource(sect.VirtualAddress);\n        resbuf.position(0);\n\n        out.write(resbuf);\n        offset += resbuf.capacity();\n        long rem = offset % this.m_header.FileAlignment;\n        if (rem != 0) offset += this.m_header.FileAlignment - rem;\n\n        if (out.size() + 1 < offset) {\n          ByteBuffer padder = ByteBuffer.allocate(1);\n          out.write(padder, offset - 1);\n        }\n\n        long virtualSize = resbuf.capacity();\n        if ((virtualSize % peheader.SectionAlignment) > 0)\n          virtualSize += peheader.SectionAlignment - (virtualSize % peheader.SectionAlignment);\n\n        sect.PointerToRawData = sectoffset;\n        sect.SizeOfRawData = resbuf.capacity();\n        if ((sect.SizeOfRawData % this.m_header.FileAlignment) > 0)\n          sect.SizeOfRawData +=\n              (this.m_header.FileAlignment - (sect.SizeOfRawData % this.m_header.FileAlignment));\n        sect.VirtualAddress = virtualAddress;\n        sect.VirtualSize = virtualSize;\n        // System.out.println(\" VS=\" + virtualSize + \" at VA=\" + virtualAddress);\n        virtualAddress += virtualSize;\n\n      } else if (sect.PointerToRawData > 0) {\n        // System.out.println(\"Dumping section \" + i + \"/\" + sect.getName() + \" at \" + offset + \"\n        // from \" + sect.PointerToRawData + \" (VA=\" + virtualAddress + \")\");\n        out.position(offset);\n        this.m_channel.position(sect.PointerToRawData);\n        long sectoffset = offset;\n\n        out.position(offset + sect.SizeOfRawData);\n        ByteBuffer padder = ByteBuffer.allocate(1);\n        out.write(padder, offset + sect.SizeOfRawData - 1);\n\n        long outted = out.transferFrom(this.m_channel, offset, sect.SizeOfRawData);\n        offset += sect.SizeOfRawData;\n        // System.out.println(\"offset before alignment, \" + offset);\n\n        long rem = offset % this.m_header.FileAlignment;\n        if (rem != 0) {\n          offset += this.m_header.FileAlignment - rem;\n        }\n        // System.out.println(\"offset after alignment, \" + offset);\n\n        // long virtualSize = sect.SizeOfRawData;\n        // if ((virtualSize % peheader.SectionAlignment)>0)\n        // virtualSize += peheader.SectionAlignment - (virtualSize%peheader.SectionAlignment);\n\n        sect.PointerToRawData = sectoffset;\n        // sect.SizeOfRawData =\n        sect.VirtualAddress = virtualAddress;\n        // sect.VirtualSize = virtualSize;\n\n        virtualAddress += sect.VirtualSize;\n        if ((virtualAddress % peheader.SectionAlignment) > 0)\n          virtualAddress +=\n              peheader.SectionAlignment - (virtualAddress % peheader.SectionAlignment);\n\n      } else {\n        // generally a BSS, with a virtual size but no\n        // data in the file...\n        // System.out.println(\"Dumping section \" + i + \" at \" + offset + \" from \" +\n        // sect.PointerToRawData + \" (VA=\" + virtualAddress + \")\");\n        long virtualSize = sect.VirtualSize;\n        if ((virtualSize % peheader.SectionAlignment) > 0)\n          virtualSize += peheader.SectionAlignment - (virtualSize % peheader.SectionAlignment);\n\n        sect.VirtualAddress = virtualAddress;\n        // sect.VirtualSize = virtualSize;\n        virtualAddress += virtualSize;\n      }\n    }\n\n    //\n    // Now that all the sections have been written, we have the\n    // correct VirtualAddress and Sizes, so we can update the new\n    // header and all the section headers...\n\n    peheader.updateVAAndSize(m_sections, sections);\n    headbuffer = peheader.get();\n    out.position(newexeoffset);\n    outputcount = out.write(headbuffer);\n\n    // peheader.dump(System.out);\n    // System.out.println(\"Dumping the section again...\");\n    offset = oldmsheader.e_lfanew + (m_header.NumberOfRvaAndSizes * 8) + 24 + getPeHeaderOffset();\n    out.position(offset);\n    for (int i = 0; i < sections.size(); i++) {\n      // System.out.println(\" offset: \" + out.position());\n      PESection sect = (PESection) sections.get(i);\n      // sect.dump(System.out);\n      ByteBuffer buf = sect.get();\n      outputcount = out.write(buf);\n    }\n\n    fos.flush();\n    fos.close();\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2181, "initialization": ["ByteBuffer src = getWriteBuffer(int)"], "initializationStart": [133], "initializationEnd": [158], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.put(char)"], "configurationStart": [194], "configurationEnd": [216], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 316, "focalAPIEnd": 341, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brettwooldridge/bitronix-hp/tree/master/btm-nio-journal/src/main/java/bitronix/tm/journal/nio/NioJournalFile.java", "rawCode": "  private void eraseRemainingBytesInJournal() throws IOException {\n    final int blockSize = 4 * 1024;\n    final ByteBuffer buffer = getWriteBuffer(blockSize);\n    while (buffer.hasRemaining()) buffer.put((byte) ' ');\n\n    do {\n      buffer.flip().limit((int) Math.min(remainingCapacity(), blockSize));\n    } while (fileChannel.write(buffer) != 0);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2182, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = allocate(int)"], "initializationStart": [517, 655], "initializationEnd": [536, 677], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.put(byte[])"], "configurationStart": [685], "configurationEnd": [702], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 785, "focalAPIEnd": 806, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)", "fileChannel.write(ByteBuffer)"], "useStart": [1254, 1725], "useEnd": [1275, 1746], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wicknicks/cuenet/tree/master/src/test/java/esl/cuenet/index/benchmarks/NIOBenchmarks.java", "rawCode": "  @Test\n  public void writeByteBuffers() throws Exception {\n\n    File temp1 = File.createTempFile(\"ByteBuffersWriteTest1\", null);\n    File temp2 = File.createTempFile(\"ByteBuffersWriteTest2\", null);\n    File temp3 = File.createTempFile(\"ByteBuffersWriteTest3\", null);\n\n    logger.info(temp1.getAbsolutePath());\n\n    int N = 4096;\n    Random generator = new Random();\n    byte[] bytes = new byte[N];\n    generator.nextBytes(bytes);\n\n    FileOutputStream stream = new FileOutputStream(temp1);\n    FileChannel channel = stream.getChannel();\n\n    long _start_time = System.currentTimeMillis();\n\n    for (int i = 0; i < 1000; i++) {\n\n      ByteBuffer buffer = ByteBuffer.allocate(N);\n      buffer.put(bytes);\n      // for (int j=0; j<N; j++) buffer.put(j, (byte)generator.nextInt());\n      channel.write(buffer);\n    }\n    stream.close();\n\n    logger.info(\"Time to save ByteBuffer (1000): \" + (System.currentTimeMillis() - _start_time));\n\n    stream = new FileOutputStream(temp2);\n    channel = stream.getChannel();\n\n    _start_time = System.currentTimeMillis();\n\n    for (int i = 0; i < 10000; i++) {\n\n      ByteBuffer buffer = ByteBuffer.allocate(N);\n      buffer.put(bytes);\n      // for (int j=0; j<N; j++) buffer.put(j, (byte)generator.nextInt());\n      channel.write(buffer);\n    }\n    stream.close();\n\n    logger.info(\"Time to save ByteBuffer (10000): \" + (System.currentTimeMillis() - _start_time));\n\n    stream = new FileOutputStream(temp3);\n    channel = stream.getChannel();\n\n    _start_time = System.currentTimeMillis();\n\n    for (int i = 0; i < 100000; i++) {\n\n      ByteBuffer buffer = ByteBuffer.allocate(N);\n      buffer.put(bytes);\n      // for (int j=0; j<N; j++) buffer.put(j, (byte)generator.nextInt());\n      channel.write(buffer);\n    }\n    stream.close();\n\n    logger.info(\"Time to save ByteBuffer (100000): \" + (System.currentTimeMillis() - _start_time));\n\n    temp1.deleteOnExit();\n    temp2.deleteOnExit();\n    temp3.deleteOnExit();\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2183, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [322], "initializationEnd": [348], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [392], "configurationEnd": [405], "guardCondition": "in.read(src,)!=-1", "guardType": "LOOP {", "guardExpressionStart": 354, "guardExpressionEnd": 383, "guardBlockStart": 354, "guardBlockEnd": 505, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 436, "focalAPIEnd": 453, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/quchunguang/test/tree/master/testjava/TIJ4-code/io/ChannelCopy.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    if (args.length != 2) {\n      System.out.println(\"arguments: sourcefile destfile\");\n      System.exit(1);\n    }\n    FileChannel in = new FileInputStream(args[0]).getChannel(),\n        out = new FileOutputStream(args[1]).getChannel();\n    ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n    while (in.read(buffer) != -1) {\n      buffer.flip(); // Prepare for writing\n      out.write(buffer);\n      buffer.clear(); // Prepare for reading\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2184, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.position(int)"], "configurationStart": [278], "configurationEnd": [294], "guardCondition": "position+4096>=fileChannel.size()", "guardType": "IF {", "guardExpressionStart": 95, "guardExpressionEnd": 128, "guardBlockStart": 95, "guardBlockEnd": 590, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 318, "focalAPIEnd": 341, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benh/twesos/tree/master/frameworks/hadoop-0.20.2/src/hdfs/org/apache/hadoop/hdfs/server/namenode/FSEditLog.java", "rawCode": "    private void preallocate() throws IOException {\n      long position = fc.position();\n      if (position + 4096 >= fc.size()) {\n        FSNamesystem.LOG.debug(\"Preallocating Edit log, current size \" + fc.size());\n        long newsize = position + 1024 * 1024; // 1MB\n        fill.position(0);\n        int written = fc.write(fill, newsize);\n        FSNamesystem.LOG.debug(\n            \"Edit log size is now \"\n                + fc.size()\n                + \" written \"\n                + written\n                + \" bytes \"\n                + \" at offset \"\n                + newsize);\n      }\n    }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2185, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = wrap(*)"], "initializationStart": [578, 625], "initializationEnd": [594, 657], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["error(String,*)"], "tryExpressionStart": 324, "tryExpressionEnd": 328, "tryBlockStart": 324, "tryBlockEnd": 1217, "catchExpressionStart": 1015, "catchExpressionEnd": 1041, "catchBlockStart": 1015, "catchBlockEnd": 1092, "exceptionHandlingCallStart": [1049], "exceptionHandlingCallEnd": [1085], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "src.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 665, "guardExpressionEnd": 691, "guardBlockStart": 665, "guardBlockEnd": 729, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 702, "focalAPIEnd": 720, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["close(fileChannel)", "close(fileChannel)"], "useStart": [736, 1160], "useEnd": [755, 1179], "hasFinally": 1, "cleanUpCall": ["close(FileChannel)"], "finallyExpressionStart": 1093, "finallyExpressionEnd": 1101, "finallyBlockStart": 1093, "finallyBlockEnd": 1217, "cleanUpCallStart": [736], "cleanUpCallEnd": [755], "url": "https://github.com/killme2008/Metamorphosis/tree/master/metamorphosis-client/src/main/java/com/taobao/metamorphosis/client/consumer/storage/LocalOffsetStorage.java", "rawCode": "  @Override\n  public void commitOffset(final String group, final Collection<TopicPartitionRegInfo> infoList) {\n    if (infoList == null || infoList.isEmpty()) {\n      return;\n    }\n    this.groupInfoMap.put(group, (List<TopicPartitionRegInfo>) infoList);\n    FileOutputStream out = null;\n    FileChannel channel = null;\n    try {\n      final String json = JSONUtils.serializeObject(this.groupInfoMap);\n      // write to temp file\n      File tmpFile = new File(this.filePath + \".tmp.\" + this.counter.incrementAndGet());\n      out = new FileOutputStream(tmpFile);\n      channel = out.getChannel();\n      final ByteBuffer buf = ByteBuffer.wrap(json.getBytes());\n      while (buf.hasRemaining()) {\n        channel.write(buf);\n      }\n      this.close(channel);\n      this.close(out);\n      // rename temp file to target file.\n      synchronized (this) {\n        if (!tmpFile.renameTo(new File(this.filePath))) {\n          throw new IOException(\"Could not rename temp file to \" + this.filePath);\n        }\n      }\n    } catch (final Exception e) {\n      log.error(\"commitOffset failed \", e);\n    } finally {\n      if (channel != null && channel.isOpen()) {\n        this.close(channel);\n      }\n      this.close(out);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2186, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ClosedChannelException", "exceptionHandlingCall": ["reopen(*)"], "tryExpressionStart": 174, "tryExpressionEnd": 178, "tryBlockStart": 174, "tryBlockEnd": 351, "catchExpressionStart": 290, "catchExpressionEnd": 323, "catchBlockStart": 290, "catchBlockEnd": 351, "exceptionHandlingCallStart": [333], "exceptionHandlingCallEnd": [342], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 195, "focalAPIEnd": 216, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ansell/openrdf-sesame/tree/master/core/util/src/main/java/info/aduna/io/NioFile.java", "rawCode": "  /** Performs a protected {@link FileChannel#write(ByteBuffer, long)} call. */\n  public int write(ByteBuffer buf, long offset) throws IOException {\n    while (true) {\n      try {\n        return fc.write(buf, offset);\n      } catch (ClosedByInterruptException e) {\n        throw e;\n      } catch (ClosedChannelException e) {\n        reopen(e);\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2187, "initialization": ["ByteBuffer src = allocateDirect(int)"], "initializationStart": [1027], "initializationEnd": [1058], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.clear()", "src.flip()"], "configurationStart": [1150, 1240], "configurationEnd": [1161, 1250], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1267, "focalAPIEnd": 1283, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/czarneckid/blojsom-sourceforge/tree/master/branches/blojsom-2_26-final/blojsom-2.0/src/org/blojsom/util/BlojsomUtils.java", "rawCode": "  /**\n   * Recursively copy a directory from a source to a target\n   *\n   * @param sourceDirectory Source directory\n   * @param targetDirectory Destination directory\n   * @throws IOException If there is an error copying the files and directories\n   * @since blojsom 2.06\n   */\n  public static void copyDirectory(File sourceDirectory, File targetDirectory) throws IOException {\n    File[] sourceFiles = sourceDirectory.listFiles(FILE_FILTER);\n    File[] sourceDirectories = sourceDirectory.listFiles(DIRECTORY_FILTER);\n\n    targetDirectory.mkdirs();\n\n    // Copy the files\n    if (sourceFiles != null && sourceFiles.length > 0) {\n      for (int i = 0; i < sourceFiles.length; i++) {\n        File sourceFile = sourceFiles[i];\n\n        FileInputStream fis = new FileInputStream(sourceFile);\n        FileOutputStream fos =\n            new FileOutputStream(targetDirectory + File.separator + sourceFile.getName());\n        FileChannel fcin = fis.getChannel();\n        FileChannel fcout = fos.getChannel();\n\n        ByteBuffer buf = ByteBuffer.allocateDirect(8192);\n        long size = fcin.size();\n        long n = 0;\n        while (n < size) {\n          buf.clear();\n          if (fcin.read(buf) < 0) {\n            break;\n          }\n          buf.flip();\n          n += fcout.write(buf);\n        }\n\n        fcin.close();\n        fcout.close();\n        fis.close();\n        fos.close();\n      }\n    }\n\n    // Copy the directories\n    if (sourceDirectories != null && sourceDirectories.length > 0) {\n      for (int i = 0; i < sourceDirectories.length; i++) {\n        File directory = sourceDirectories[i];\n        File newTargetDirectory = new File(targetDirectory, directory.getName());\n\n        copyDirectory(directory, newTargetDirectory);\n      }\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2188, "initialization": ["ByteBuffer src = newEncoded(ISpaceProbe,Charset,String,List<String>)", "FileChannel fileChannel = FileOutputStream.getChannel()"], "initializationStart": [571, 714], "initializationEnd": [613, 730], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["triedTo(String,*)", "Ds.a(String,ByteBuffer)", "ISpaceProbe.failFile(Ds,File)", "new DiskException()"], "tryExpressionStart": 736, "tryExpressionEnd": 740, "tryBlockStart": 736, "tryBlockEnd": 1069, "catchExpressionStart": 813, "catchExpressionEnd": 842, "catchBlockStart": 813, "catchBlockEnd": 1018, "exceptionHandlingCallStart": [864, 924, 950, 992], "exceptionHandlingCallEnd": [916, 942, 978, 1011], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "src.hasRemaining()", "guardType": "LOOP {", "guardExpressionStart": 748, "guardExpressionEnd": 773, "guardBlockStart": 748, "guardBlockEnd": 806, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 784, "focalAPIEnd": 797, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["close(ISpaceProbe,File,FileOutputStream)"], "finallyExpressionStart": 1019, "finallyExpressionEnd": 1027, "finallyBlockStart": 1019, "finallyBlockEnd": 1069, "cleanUpCallStart": [1035], "cleanUpCallEnd": [1062], "url": "https://github.com/craig-a-roach/geowx/tree/master/ebx/src/main/java/com/metservice/boron/UBoron.java", "rawCode": "  public static void saveText(\n      ISpaceProbe probe, File destFile, Charset charset, String zTerm, List<String> zlLines)\n      throws DiskException {\n    if (probe == null) throw new IllegalArgumentException(\"object is null\");\n    if (destFile == null) throw new IllegalArgumentException(\"object is null\");\n    if (charset == null) throw new IllegalArgumentException(\"object is null\");\n    if (zTerm == null) throw new IllegalArgumentException(\"object is null\");\n    if (zlLines == null) throw new IllegalArgumentException(\"object is null\");\n    final ByteBuffer bb = newEncoded(probe, charset, zTerm, zlLines);\n    final FileOutputStream fos = newFileOutputStream(probe, destFile);\n    final FileChannel fch = fos.getChannel();\n    try {\n      while (bb.hasRemaining()) {\n        fch.write(bb);\n      }\n    } catch (final IOException ex) {\n      final Ds ds = Ds.triedTo(\"Write encoded text to file channel\", ex);\n      ds.a(\"buffer\", bb);\n      probe.failFile(ds, destFile);\n      throw new DiskException();\n    } finally {\n      close(probe, destFile, fos);\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2189, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = wrap(byte[])"], "initializationStart": [813, 856], "initializationEnd": [829, 876], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "0<src.remaining()", "guardType": "LOOP {", "guardExpressionStart": 886, "guardExpressionEnd": 913, "guardBlockStart": 886, "guardBlockEnd": 928, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 914, "focalAPIEnd": 927, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.force(boolean)"], "useStart": [937], "useEnd": [951], "hasFinally": 1, "cleanUpCall": ["FileOutputStream.close()"], "finallyExpressionStart": 988, "finallyExpressionEnd": 996, "finallyBlockStart": 988, "finallyBlockEnd": 1022, "cleanUpCallStart": [1004], "cleanUpCallEnd": [1015], "url": "https://github.com/pdinc-oss/jgit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/storage/file/ReflogWriter.java", "rawCode": "  private ReflogWriter log(final String refName, final byte[] rec) throws IOException {\n    final File log = logFor(refName);\n    final boolean write =\n        forceWrite || (isLogAllRefUpdates() && shouldAutoCreateLog(refName)) || log.isFile();\n    if (!write) return this;\n\n    WriteConfig wc = getRepository().getConfig().get(WriteConfig.KEY);\n    FileOutputStream out;\n    try {\n      out = new FileOutputStream(log, true);\n    } catch (FileNotFoundException err) {\n      final File dir = log.getParentFile();\n      if (dir.exists()) throw err;\n      if (!dir.mkdirs() && !dir.isDirectory())\n        throw new IOException(MessageFormat.format(JGitText.get().cannotCreateDirectory, dir));\n      out = new FileOutputStream(log, true);\n    }\n    try {\n      if (wc.getFSyncRefFiles()) {\n        FileChannel fc = out.getChannel();\n        ByteBuffer buf = ByteBuffer.wrap(rec);\n        while (0 < buf.remaining()) fc.write(buf);\n        fc.force(true);\n      } else out.write(rec);\n    } finally {\n      out.close();\n    }\n    return this;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2190, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.flip()"], "configurationStart": [157], "configurationEnd": [175], "guardCondition": "src.remaining()>0", "guardType": "LOOP {", "guardExpressionStart": 204, "guardExpressionEnd": 239, "guardBlockStart": 204, "guardBlockEnd": 288, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 251, "focalAPIEnd": 287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/plugin/shapefile/src/main/java/org/geotools/data/shapefile/indexed/IndexedFidWriter.java", "rawCode": "  /**\n   * Drain internal buffers into underlying channels.\n   *\n   * @throws IOException DOCUMENT ME!\n   */\n  private void drain() throws IOException {\n    writeBuffer.flip();\n\n    int written = 0;\n\n    while (writeBuffer.remaining() > 0) written += channel.write(writeBuffer, position);\n\n    position += written;\n\n    writeBuffer.flip().limit(writeBuffer.capacity());\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2191, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,offset,length)", "focalAPIStart": 120, "focalAPIEnd": 165, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()", "fileChannel.write(ByteBuffer[],int,int)"], "useStart": [679, 724], "useEnd": [706, 769], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/test/java/libcore/java/nio/channels/OldFileChannelTest.java", "rawCode": "  public void test_write$LByteBufferII_Null() throws Exception {\n    ByteBuffer[] writeBuffers = null;\n\n    try {\n      readOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    try {\n      writeOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    try {\n      readWriteFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    // first throws NullPointerException\n    readOnlyFileChannel.close();\n    try {\n      readOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    writeOnlyFileChannel.close();\n    try {\n      writeOnlyFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n\n    readWriteFileChannel.close();\n    try {\n      readWriteFileChannel.write(writeBuffers, 1, 2);\n      fail(\"should throw NullPointerException\");\n    } catch (NullPointerException e) {\n      // expected\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2192, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = allocateDirect(*)"], "initializationStart": [706, 757], "initializationEnd": [732, 793], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["showMessageDialog(*,String,String,*)"], "tryExpressionStart": 32, "tryExpressionEnd": 36, "tryBlockStart": 32, "tryBlockEnd": 1433, "catchExpressionStart": 1260, "catchExpressionEnd": 1281, "catchBlockStart": 1260, "catchBlockEnd": 1433, "exceptionHandlingCallStart": [1289], "exceptionHandlingCallEnd": [1410], "configuration": ["src.order(*)", "src.putFloat(*)", "src.compact()"], "configurationStart": [801, 966, 1059], "configurationEnd": [834, 1009, 1071], "guardCondition": "!(src.hasRemaining())", "guardType": "IF {", "guardExpressionStart": 929, "guardExpressionEnd": 951, "guardBlockStart": 929, "guardBlockEnd": 1146, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 1085, "focalAPIEnd": 1109, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)"], "useStart": [1192], "useEnd": [1216], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/PieceMaker/OpenJUMP/tree/master/src/org/openjump/core/rasterimage/GridFloat.java", "rawCode": "  public int writeGrid() {\n\n    try {\n\n      if (raster == null) {\n        // Create raster\n        SampleModel sampleModel =\n            RasterFactory.createBandedSampleModel(DataBuffer.TYPE_FLOAT, nCols, nRows, 1);\n        dataArray = new float[nCols * nRows];\n        DataBuffer db = new DataBufferFloat(dataArray, nCols * nRows);\n        java.awt.Point point = new java.awt.Point();\n        point.setLocation(xllCorner, yllCorner);\n        raster = RasterFactory.createRaster(sampleModel, db, point);\n      }\n\n      if (writeHdr() != 0) return -1;\n\n      File fileOut = new File(fltFullFileName);\n      FileOutputStream fileOutStream = new FileOutputStream(fileOut);\n      FileChannel fileChannelOut = fileOutStream.getChannel();\n\n      ByteBuffer bb = ByteBuffer.allocateDirect(nCols * 4);\n      bb.order(ByteOrder.LITTLE_ENDIAN);\n\n      for (int r = 0; r < nRows; r++) {\n        for (int c = 0; c < nCols; c++) {\n          if (bb.hasRemaining()) {\n            bb.putFloat(raster.getSampleFloat(c, r, 0));\n          } else {\n            c--;\n            bb.compact();\n            fileChannelOut.write(bb);\n            bb.clear();\n          }\n        }\n      }\n\n      bb.compact();\n      fileChannelOut.write(bb);\n      bb.clear();\n\n      return 0;\n\n    } catch (Exception ex) {\n      JOptionPane.showMessageDialog(\n          null, \"Error while reading flt file: \" + ex, \"Error\", JOptionPane.ERROR_MESSAGE);\n      return 1;\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2193, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["fatal(String,*)", "new RuntimeException(*)"], "tryExpressionStart": 269, "tryExpressionEnd": 273, "tryBlockStart": 269, "tryBlockEnd": 2776, "catchExpressionStart": 2655, "catchExpressionEnd": 2675, "catchBlockStart": 2655, "catchBlockEnd": 2776, "exceptionHandlingCallStart": [2683, 2746], "exceptionHandlingCallEnd": [2732, 2769], "configuration": ["fileChannel.position(int)", "src.put(byte[],int,int)", "src.rewind()", "src.limit(int)"], "configurationStart": [341, 699, 737, 764], "configurationEnd": [365, 725, 752, 784], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 796, "focalAPIEnd": 817, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)", "fileChannel.write(ByteBuffer)", "fileChannel.write(ByteBuffer)", "fileChannel.position(int)", "fileChannel.write(ByteBuffer)"], "useStart": [1174, 1569, 1948, 2039, 2567], "useEnd": [1195, 1590, 1969, 2058, 2592], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jpercent/catena/tree/master/src/main/java/syndeticlogic/catena/text/io/old/DictionaryWriter.java", "rawCode": "  public long writeDictionary(\n      Map<Integer, String> idToDoc,\n      Map<String, Integer> prefixes,\n      List<InvertedListDescriptor> invertedListDescriptors) {\n    long fileOffset = 0;\n    DocumentDescriptor doc = new DocumentDescriptor();\n    int count = 0;\n    try {\n      int header = Type.BYTE.length() + Type.LONG.length();\n      channel.position(header);\n      fileOffset = header;\n\n      byte[] jvm = new byte[BLOCK_SIZE];\n      int offset = 0;\n      for (Map.Entry<Integer, String> document : idToDoc.entrySet()) {\n        doc.setDocId(document.getKey());\n        doc.setDoc(document.getValue());\n        int length = doc.size();\n        if (offset + length >= BLOCK_SIZE) {\n          direct.put(jvm, 0, offset);\n          direct.rewind();\n          direct.limit(offset);\n          channel.write(direct);\n          direct.rewind();\n          direct.limit(direct.capacity());\n          offset = 0;\n        }\n        int written = doc.encode(jvm, offset);\n        assert written == length;\n        offset += length;\n        fileOffset += length;\n        count++;\n      }\n      direct.put(jvm, 0, offset);\n      direct.rewind();\n      direct.limit(offset);\n      channel.write(direct);\n      direct.rewind();\n      direct.limit(direct.capacity());\n\n      long docIdOffset = fileOffset;\n      offset = 0;\n      for (InvertedListDescriptor desc : invertedListDescriptors) {\n        int length = desc.size();\n        if (offset + length >= BLOCK_SIZE) {\n          direct.put(jvm, 0, offset);\n          direct.rewind();\n          direct.limit(offset);\n          channel.write(direct);\n          direct.rewind();\n          direct.limit(direct.capacity());\n          offset = 0;\n        }\n        int written = desc.encode(jvm, offset);\n        assert written == length;\n        offset += length;\n        fileOffset += length;\n        count++;\n      }\n      direct.put(jvm, 0, offset);\n      direct.rewind();\n      direct.limit(offset);\n      channel.write(direct);\n      direct.rewind();\n      direct.limit(direct.capacity());\n      channel.position(0);\n      ByteBuffer headerData = ByteBuffer.wrap(jvm);\n      Codec.getCodec().encode(docIdOffset, jvm, 0);\n      byte postingsCoding = 0;\n      if (InvertedList.getTableType() == TableType.VariableByteCodedTable) {\n        postingsCoding = 1;\n      }\n      Codec.getCodec().encode(postingsCoding, jvm, Type.LONG.length());\n      // Codec.getCodec().encode(prefixLength, jvm, Type.LONG.length()+Type.BYTE.length());\n      headerData.limit(Type.LONG.length() + Type.BYTE.length() + Type.INTEGER.length());\n      channel.write(headerData);\n      System.err.println(\"Dictionary items \" + count);\n    } catch (Throwable t) {\n      log.fatal(\"exception writing index file \" + t, t);\n      throw new RuntimeException(t);\n    }\n    return fileOffset;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2194, "initialization": ["FileChannel fileChannel = FileOutputStream.getChannel()", "ByteBuffer src = allocateDirect(*)"], "initializationStart": [152, 211], "initializationEnd": [181, 251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.clear()"], "configurationStart": [289], "configurationEnd": [307], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 313, "focalAPIEnd": 342, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.close()"], "useStart": [349], "useEnd": [368], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benjaminvm/vm/tree/master/libcore/nio/src/test/java/org/apache/harmony/nio/tests/java/nio/MappedByteBufferTest.java", "rawCode": "  private void fillTempFile() throws IOException {\n    FileOutputStream fileOutputStream = new FileOutputStream(tmpFile);\n    FileChannel fileChannel = fileOutputStream.getChannel();\n    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER_LENGTH);\n\n    loadTestData1(byteBuffer);\n    byteBuffer.clear();\n    fileChannel.write(byteBuffer);\n\n    fileChannel.close();\n    fileOutputStream.close();\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2195, "initialization": ["ByteBuffer src = allocate(*)"], "initializationStart": [353], "initializationEnd": [401], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.put(*)", "src.flip()"], "configurationStart": [473, 497], "configurationEnd": [490, 507], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 513, "focalAPIEnd": 528, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/burto/mkgmap/tree/master/src/uk/me/parabola/imgfmt/sys/FileNode.java", "rawCode": "  /**\n   * Write out any unsaved data to disk.\n   *\n   * @throws IOException If there is an error writing to disk.\n   */\n  private void sync() throws IOException {\n    if (!writeable) return;\n\n    // Ensure that a complete block is written out.\n    int bs = blockManager.getBlockSize();\n    long rem = bs - (file.position() % bs);\n\n    ByteBuffer buf = ByteBuffer.allocate(blockManager.getBlockSize());\n\n    // Complete any partial block.\n    for (int i = 0; i < rem; i++) buf.put((byte) 0);\n\n    buf.flip();\n    file.write(buf);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2196, "initialization": ["ByteBuffer src = allocate(int)"], "initializationStart": [149], "initializationEnd": [172], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position(int)", "src.putShort(*)", "src.putShort(*)", "src.putInt(*)", "src.put(*)", "src.flip()"], "configurationStart": [100, 179, 227, 271, 474, 502], "configurationEnd": [123, 221, 265, 295, 494, 515], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 523, "focalAPIEnd": 544, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)", "fileChannel.position(int)", "fileChannel.write(ByteBuffer)"], "useStart": [642, 691, 909], "useEnd": [663, 725, 931], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Unidata/thredds/tree/master/cdm/src/main/java/ucar/nc2/geotiff/GeoTiff.java", "rawCode": "  private void writeIFDEntry(FileChannel channel, IFDEntry ifd, int start) throws IOException {\n    channel.position(start);\n    ByteBuffer buffer = ByteBuffer.allocate(12);\n\n    buffer.putShort((short) ifd.tag.getCode());\n    buffer.putShort((short) ifd.type.code);\n    buffer.putInt(ifd.count);\n\n    int size = ifd.count * ifd.type.size;\n    if (size <= 4) {\n      int done = writeValues(buffer, ifd);\n      for (int k = 0; k < 4 - done; k++) // fill out to 4 bytes\n      buffer.put((byte) 0);\n      buffer.flip();\n      channel.write(buffer);\n\n    } else { // write offset\n      buffer.putInt(nextOverflowData);\n      buffer.flip();\n      channel.write(buffer);\n      // write data\n      channel.position(nextOverflowData);\n      // System.out.println(\" write offset = \"+ifd.tag.getName());\n      ByteBuffer vbuffer = ByteBuffer.allocate(size);\n      writeValues(vbuffer, ifd);\n      vbuffer.flip();\n      channel.write(vbuffer);\n      nextOverflowData += size;\n    }\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2197, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.array()", "src.remaining()", "src.position()"], "configurationStart": [74, 101, 232], "configurationEnd": [85, 116, 246], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 299, "focalAPIEnd": 317, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.position()"], "useStart": [359], "useEnd": [377], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/coderplay/h2-bitmap/tree/master/h2/src/main/org/h2/store/fs/FilePathRec.java", "rawCode": "  public int write(ByteBuffer src) throws IOException {\n    byte[] buff = src.array();\n    int len = src.remaining();\n    if (src.position() != 0 || len != buff.length) {\n      byte[] b = new byte[len];\n      System.arraycopy(buff, src.position(), b, 0, len);\n      buff = b;\n    }\n    int result = channel.write(src);\n    rec.log(Recorder.WRITE, name, buff, channel.position());\n    return result;\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2198, "initialization": ["ByteBuffer src = wrap(byte[])"], "initializationStart": [266], "initializationEnd": [284], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["fileChannel.position(long)", "src.position(int)"], "configurationStart": [131, 421], "configurationEnd": [157, 439], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 449, "focalAPIEnd": 470, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer)"], "useStart": [628], "useEnd": [649], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/felipelalli/micaroni/tree/master/lab/sandbox/campinas-db/src/br/eti/fml/campinas/util/FileUtil.java", "rawCode": "  public static void fillWith(byte whichOne, FileChannel channel, long position, long sizeInBytes)\n      throws IOException {\n\n    channel.position(position);\n\n    byte[] b = new byte[(int) (512 * ByteUtil.KB)];\n    Arrays.fill(b, whichOne);\n    ByteBuffer buffer = ByteBuffer.wrap(b);\n\n    int filled = 0;\n    long remaining;\n\n    do {\n      remaining = sizeInBytes - filled;\n\n      if (remaining >= b.length) {\n        buffer.position(0);\n        channel.write(buffer);\n        filled += b.length;\n      } else {\n        assert remaining <= Integer.MAX_VALUE;\n\n        buffer = ByteBuffer.wrap(b, 0, (int) remaining);\n        channel.write(buffer);\n        filled += remaining;\n      }\n    } while (remaining > 0L);\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2199, "initialization": ["ByteBuffer src = allocate(*)"], "initializationStart": [214], "initializationEnd": [255], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.putInt(int,*)", "src.putInt(int,int)", "src.putInt(*,*)", "src.putInt(*,*)"], "configurationStart": [279, 339, 528, 616], "configurationEnd": [333, 368, 580, 676], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src,position)", "focalAPIStart": 706, "focalAPIEnd": 746, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fileChannel.write(ByteBuffer,int)"], "useStart": [928], "useEnd": [957], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mdcurtis/micromanager-upstream/tree/master/mmstudio/src/org/micromanager/acquisition/MultipageTiffReader.java", "rawCode": "  private int writeIndexMap(long filePosition) throws IOException {\n    // Write 4 byte header, 4 byte number of entries, and 20 bytes for each entry\n    int numMappings = indexMap_.size();\n    ByteBuffer buffer = ByteBuffer.allocate(8 + 20 * numMappings).order(byteOrder_);\n    buffer.putInt(0, MultipageTiffWriter.INDEX_MAP_HEADER);\n    buffer.putInt(4, numMappings);\n    int position = 2;\n    for (String label : indexMap_.keySet()) {\n      String[] indecies = label.split(\"_\");\n      for (String index : indecies) {\n        buffer.putInt(4 * position, Integer.parseInt(index));\n        position++;\n      }\n      buffer.putInt(4 * position, indexMap_.get(label).intValue());\n      position++;\n    }\n    fileChannel_.write(buffer, filePosition);\n\n    ByteBuffer header = ByteBuffer.allocate(8).order(byteOrder_);\n    header.putInt(0, MultipageTiffWriter.INDEX_MAP_OFFSET_HEADER);\n    header.putInt(4, (int) filePosition);\n    fileChannel_.write(header, 8);\n    return buffer.capacity();\n  }\n"}, {"dataset": "fileChannelWrite", "exampleID": 2200, "initialization": ["ByteBuffer src = allocate(*)"], "initializationStart": [395], "initializationEnd": [463], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["src.order(ByteOrder)", "src.putInt(int)", "src.putDouble(*)", "src.putDouble(*)", "src.putDouble(*)", "src.putDouble(*)", "src.putInt(*)", "src.putInt(*)", "src.putInt(*)", "src.flip()"], "configurationStart": [470, 492, 554, 588, 622, 656, 691, 787, 830, 869], "configurationEnd": [486, 510, 582, 616, 650, 684, 724, 817, 863, 879], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "written = fileChannel.write(src)", "focalAPIStart": 886, "focalAPIEnd": 904, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeNode(*,fileChannel,ByteOrder)"], "useStart": [967], "useEnd": [1017], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdeolive/geotools-old/tree/master/modules/plugin/shapefile/src/main/java/org/geotools/index/quadtree/fs/FileSystemIndexStore.java", "rawCode": "  /**\n   * Wites a tree node to the qix file\n   *\n   * @param node The node\n   * @param channel DOCUMENT ME!\n   * @param order byte order\n   * @throws IOException\n   * @throws StoreException DOCUMENT ME!\n   */\n  private void writeNode(Node node, FileChannel channel, ByteOrder order)\n      throws IOException, StoreException {\n    int offset = this.getSubNodeOffset(node);\n\n    ByteBuffer buf = ByteBuffer.allocate((4 * 8) + (3 * 4) + (node.getNumShapeIds() * 4));\n\n    buf.order(order);\n    buf.putInt(offset);\n\n    Envelope env = node.getBounds();\n    buf.putDouble(env.getMinX());\n    buf.putDouble(env.getMinY());\n    buf.putDouble(env.getMaxX());\n    buf.putDouble(env.getMaxY());\n\n    buf.putInt(node.getNumShapeIds());\n\n    for (int i = 0; i < node.getNumShapeIds(); i++) {\n      buf.putInt(node.getShapeId(i));\n    }\n\n    buf.putInt(node.getNumSubNodes());\n    buf.flip();\n\n    channel.write(buf);\n\n    for (int i = 0; i < node.getNumSubNodes(); i++) {\n      this.writeNode(node.getSubNode(i), channel, order);\n    }\n  }\n"}]