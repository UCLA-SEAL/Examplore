[{"dataset": "nextToken", "exampleID": 9001, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace(*)"], "tryExpressionStart": 230, "tryExpressionEnd": 234, "tryBlockStart": 230, "tryBlockEnd": 1160, "catchExpressionStart": 1096, "catchExpressionEnd": 1116, "catchBlockStart": 1096, "catchBlockEnd": 1160, "exceptionHandlingCallStart": [1124], "exceptionHandlingCallEnd": [1153], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 993, "focalAPIEnd": 1007, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/DevBoost/EMFText/tree/master/Deprecated/org.emftext.commons.antlr3_3_0/src/org/antlr/runtime3_3_0/debug/RemoteDebugEventSocketListener.java", "rawCode": "  public String[] getEventElements(String event) {\n    if (event == null) {\n      return null;\n    }\n    String[] elements = new String[MAX_EVENT_ELEMENTS];\n    String str = null; // a string element if present (must be last)\n    try {\n      int firstQuoteIndex = event.indexOf('\"');\n      if (firstQuoteIndex >= 0) {\n        // treat specially; has a string argument like \"a comment\\n\n        // Note that the string is terminated by \\n not end quote.\n        // Easier to parse that way.\n        String eventWithoutString = event.substring(0, firstQuoteIndex);\n        str = event.substring(firstQuoteIndex + 1, event.length());\n        event = eventWithoutString;\n      }\n      StringTokenizer st = new StringTokenizer(event, \"\\t\", false);\n      int i = 0;\n      while (st.hasMoreTokens()) {\n        if (i >= MAX_EVENT_ELEMENTS) {\n          // ErrorManager.internalError(\"event has more than \"+MAX_EVENT_ELEMENTS+\" args: \"+event);\n          return elements;\n        }\n        elements[i] = st.nextToken();\n        i++;\n      }\n      if (str != null) {\n        elements[i] = str;\n      }\n    } catch (Exception e) {\n      e.printStackTrace(System.err);\n    }\n    return elements;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9002, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [846], "initializationEnd": [869], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["stringTokenizer.countTokens()"], "configurationStart": [888], "configurationEnd": [904], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1079, "focalAPIEnd": 1093, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jponge/izpack-full-svn-history-copy/tree/master/izpack-src/tags/4.3.2/src/lib/com/izforge/izpack/util/IoHelper.java", "rawCode": "  /**\n   * Extracts a long value from a string in a special manner. The string will be broken into tokens\n   * with a standard StringTokenizer. Arround the assumed place (with the given half range) the\n   * tokens are scaned reverse for a token which represents a long. if useNotIdentifier is not null,\n   * tokens which are contains this string will be ignored. The first founded long returns.\n   *\n   * @param in the string which should be parsed\n   * @param assumedPlace token number which should contain the value\n   * @param halfRange half range for detection range\n   * @param useNotIdentifier string which determines tokens which should be ignored\n   * @return founded long\n   */\n  private static long extractLong(\n      String in, int assumedPlace, int halfRange, String useNotIdentifier) {\n    long retval = -1;\n    StringTokenizer st = new StringTokenizer(in);\n    int length = st.countTokens();\n    int i;\n    int currentRange = 0;\n    String[] interestedEntries = new String[halfRange + halfRange];\n    for (i = 0; i < length - halfRange + assumedPlace; ++i) {\n      st.nextToken(); // Forget this entries.\n    }\n\n    for (i = 0;\n        i < halfRange + halfRange;\n        ++i) { // Put the interesting Strings into an intermediaer array.\n      if (st.hasMoreTokens()) {\n        interestedEntries[i] = st.nextToken();\n        currentRange++;\n      }\n    }\n\n    for (i = currentRange - 1; i >= 0; --i) {\n      if (useNotIdentifier != null && interestedEntries[i].indexOf(useNotIdentifier) > -1) {\n        continue;\n      }\n      try {\n        retval = Long.parseLong(interestedEntries[i]);\n      } catch (NumberFormatException nfe) {\n        continue;\n      }\n      break;\n    }\n    return retval;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9003, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "UpgradeException", "exceptionHandlingCall": ["error(String,*)"], "tryExpressionStart": 1293, "tryExpressionEnd": 1297, "tryBlockStart": 1293, "tryBlockEnd": 1491, "catchExpressionStart": 5556, "catchExpressionEnd": 5583, "catchBlockStart": 5556, "catchBlockEnd": 5663, "exceptionHandlingCallStart": [5591], "exceptionHandlingCallEnd": [5656], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 3002, "focalAPIEnd": 3016, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(nextToken)"], "useStart": [2976], "useEnd": [3017], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aldaris/opensso/tree/master/products/upgrade/services/50_iPlanetAMPlatformService/20_30/Migrate.java", "rawCode": "  /**\n   * Updates the <code>iPlanetAMPlatformService<code> service schema.\n   *\n   * @return true if successful otherwise false.\n   */\n  public boolean migrateService() {\n    String classMethod = \"iPlanetAMPlatformService/20_30:migrateService: \";\n    boolean isSuccess = false;\n    try {\n      String fileName = UpgradeUtils.getAbsolutePath(SERVICE_DIR, SCHEMA_FILE1);\n      UpgradeUtils.addAttributeToSchema(SERVICE_NAME, schemaType, fileName);\n      // add subschema\n      fileName = UpgradeUtils.getAbsolutePath(SERVICE_DIR, SCHEMA_FILE);\n      UpgradeUtils.addSubSchema(SERVICE_NAME, null, schemaType, fileName);\n      fileName = UpgradeUtils.getAbsolutePath(SERVICE_DIR, SCHEMA_FILE2);\n      UpgradeUtils.createService(fileName);\n\n      UpgradeUtils.removeAttributeSchema(SERVICE_NAME, schemaType, ATTR_LOGIN_URL, null);\n      UpgradeUtils.removeAttributeSchema(SERVICE_NAME, schemaType, ATTR_LOGOUT_URL, null);\n      UpgradeUtils.removeAttributeSchema(SERVICE_NAME, schemaType, ATTR_SERVER_VALIDATOR, null);\n      UpgradeUtils.removeAttributeSchema(SERVICE_NAME, schemaType, ATTR_SITE_VALIDATOR, null);\n      UpgradeUtils.removeAttributeSchema(SERVICE_NAME, schemaType, ATTR_LOCALES, null);\n\n      // read serverdefaults.properties\n      Properties properties = new Properties();\n      try {\n        properties.load(new FileInputStream(UpgradeUtils.getServerDefaultsPath()));\n      } catch (IOException ioe) {\n        UpgradeUtils.debug.error(\"Error loading properties\", ioe);\n      }\n      Set vSet = new HashSet();\n      Enumeration propertiesNames = properties.propertyNames();\n      while (propertiesNames.hasMoreElements()) {\n        String propertyName = (String) propertiesNames.nextElement();\n        String value = (String) properties.get(propertyName);\n        vSet.add(propertyName + \"=\" + value);\n      }\n      // add to server-default subconfig\n      UpgradeUtils.addServerDefaults(SERVICE_NAME, SERVER_ATTR, null, INSTANCE_ID, vSet, null);\n      if (UpgradeUtils.debug.messageEnabled()) {\n        UpgradeUtils.debug.message(\n            classMethod + \"serverdefaults.properties \" + \"values are :\" + vSet);\n      }\n\n      // get the values of site list.\n      Set attrValueSet = UpgradeUtils.getAttributeValue(SERVICE_NAME, ATTR_SITE_LIST, schemaType);\n      Iterator i = attrValueSet.iterator();\n      while (i.hasNext()) {\n        String attrVal = (String) i.next();\n        String siteURL = null;\n        String remStr = null;\n        int index = attrVal.indexOf(\"|\");\n        if (index != -1) {\n          siteURL = attrVal.substring(0, index);\n          remStr = attrVal.substring(index + 1);\n        }\n        index = remStr.indexOf(\"|\");\n        if (index != -1) {\n          String siteId = remStr.substring(0, index);\n          String accessPointStr = remStr.substring(index + 1);\n          StringTokenizer st = new StringTokenizer(accessPointStr, \"|\");\n          Set accessPoints = new HashSet();\n          while (st.hasMoreTokens()) {\n            accessPoints.add((String) st.nextToken());\n          }\n          UpgradeUtils.createSite(siteURL, accessPoints);\n        }\n      }\n\n      /* Get existing/pre-migrated AMConfig.properties,\n       * get the latest AMConfig.properties from the deployed\n       * OpenSSO pointing to old DIT. Read the\n       * \"com.iplanet.am.version\" from the latest OpenSSO bits\n       * and replace only property in the existing/pre-migrated\n       * AMConfig.properties.\n       */\n\n      String serverStr = UpgradeUtils.getServerName() + \"/\" + UpgradeUtils.getDeployURI();\n      Properties amconfigProp = UpgradeUtils.getServerProperties();\n      Properties p =\n          UpgradeUtils.getProperties(\n              UpgradeUtils.getConfigDir() + File.separator + \"AMConfig.properties\");\n      String prodVersion = (String) p.get(\"com.iplanet.am.version\");\n      if (prodVersion != null) {\n        amconfigProp.put(\"com.iplanet.am.version\", prodVersion);\n        UpgradeUtils.storeProperties(amconfigProp);\n      }\n      // get value of iplanet-am-platform-server-list attribute\n      attrValueSet = UpgradeUtils.getAttributeValue(SERVICE_NAME, PLATFORM_ATTR, schemaType);\n\n      Iterator attrValIterator = attrValueSet.iterator();\n      while (attrValIterator.hasNext()) {\n        String value = (String) attrValIterator.next();\n        StringTokenizer st = new StringTokenizer(value, \"|\");\n        String serverName = st.nextToken();\n        String serverId = st.nextToken();\n        String siteId = null;\n        if (st.countTokens() == 3) {\n          siteId = st.nextToken();\n        }\n        // get complete instance name with deployURI\n        String serverInstance = UpgradeUtils.getServerInstance(serverName);\n        if (serverName != null && serverName.equalsIgnoreCase(serverStr)) {\n          Set values = getValues(amconfigProp);\n          // read serverconfig XML\n          String serverconfigXML = UpgradeUtils.getServerConfigXML();\n          if (UpgradeUtils.debug.messageEnabled()) {\n            UpgradeUtils.debug.message(\n                classMethod + \"AMConfig.properties \" + \"values are :\" + values);\n            UpgradeUtils.debug.message(classMethod + \"serverconfigXMl is :\" + serverconfigXML);\n          }\n          UpgradeUtils.addServerDefaults(\n              SERVICE_NAME, SERVER_ATTR, serverInstance, serverId, values, serverconfigXML);\n        } else {\n          UpgradeUtils.createServiceInstance(serverInstance, serverId);\n        }\n        if (siteId != null) {\n          UpgradeUtils.addToSite(serverInstance, siteId);\n        }\n      }\n      isSuccess = true;\n    } catch (UpgradeException e) {\n      UpgradeUtils.debug.error(\"Error loading data:\" + SERVICE_NAME, e);\n    }\n    return isSuccess;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9004, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [595], "initializationEnd": [635], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 645, "guardExpressionEnd": 671, "guardBlockStart": 645, "guardBlockEnd": 767, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 750, "focalAPIEnd": 764, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getSingleOrStaticValueSource(nextToken)"], "useStart": [702], "useEnd": [765], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/netspective/sparx-2001/tree/master/Sparx/java/com/netspective/sparx/util/value/QueryResultsListValue.java", "rawCode": "  public void initializeSource(String srcParams) {\n    super.initializeSource(srcParams);\n    int delimPos = srcParams.indexOf('/');\n    if (delimPos >= 0) {\n      stmtMgrName = srcParams.substring(0, delimPos);\n      stmtName = srcParams.substring(delimPos + 1);\n    } else stmtName = srcParams;\n\n    delimPos = stmtName.indexOf('?');\n    if (delimPos >= 0) {\n      String queryParamsStr = srcParams.substring(delimPos + 1);\n      stmtName = stmtName.substring(0, delimPos);\n\n      if (queryParamsStr.length() > 0) {\n        List queryParamsList = new ArrayList();\n        StringTokenizer st = new StringTokenizer(queryParamsStr, \",\");\n        while (st.hasMoreTokens())\n          queryParamsList.add(ValueSourceFactory.getSingleOrStaticValueSource(st.nextToken()));\n        queryParams =\n            (SingleValueSource[])\n                queryParamsList.toArray(new SingleValueSource[queryParamsList.size()]);\n      }\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9005, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [105], "initializationEnd": [134], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 258, "focalAPIEnd": 279, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["decode(nextToken)", "stringTokenizer.nextToken()", "decode(nextToken)", "stringTokenizer.nextToken()", "decode(nextToken)", "stringTokenizer.nextToken()", "decode(nextToken)", "stringTokenizer.nextToken()", "decode(nextToken)", "stringTokenizer.nextToken()", "decode(nextToken)", "stringTokenizer.nextToken()", "decode(nextToken)", "stringTokenizer.nextToken()", "decode(nextToken)"], "useStart": [244, 324, 310, 390, 376, 456, 442, 522, 508, 588, 574, 654, 640, 720, 706], "useEnd": [280, 345, 346, 411, 412, 477, 478, 543, 544, 609, 610, 675, 676, 741, 742], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ThatGuyOverTher/Frost/tree/master/frost-wot/source/frost/util/FrostCrypt.java", "rawCode": "  public synchronized String detachedSign(byte[] message, String key) {\n\n    StringTokenizer keycutter = new StringTokenizer(key, \":\");\n    RSAPrivateCrtKeyParameters privKey =\n        new RSAPrivateCrtKeyParameters(\n            new BigInteger(Base64.decode(keycutter.nextToken())),\n            new BigInteger(Base64.decode(keycutter.nextToken())),\n            new BigInteger(Base64.decode(keycutter.nextToken())),\n            new BigInteger(Base64.decode(keycutter.nextToken())),\n            new BigInteger(Base64.decode(keycutter.nextToken())),\n            new BigInteger(Base64.decode(keycutter.nextToken())),\n            new BigInteger(Base64.decode(keycutter.nextToken())),\n            new BigInteger(Base64.decode(keycutter.nextToken())));\n\n    signer.init(true, privKey);\n    signer.update(message, 0, message.length);\n\n    byte[] signature = null;\n    try {\n      signature = signer.generateSignature();\n    } catch (CryptoException e) {\n      logger.log(Level.SEVERE, \"Exception thrown in detachedSign(String message, String key)\", e);\n    }\n    signer.reset();\n    try {\n      String result = new String(Base64.encode(signature), \"ISO-8859-1\");\n      return result;\n    } catch (UnsupportedEncodingException ex) {\n      logger.log(Level.SEVERE, \"ISO-8859-1 encoding is not supported.\", ex);\n    }\n    return null;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9006, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [1185], "initializationEnd": [1226], "hasTryCatch": 1, "exceptionType": "NoSuchElementException", "exceptionHandlingCall": ["Logger.info(String)", "new BadResumptionTokenException()"], "tryExpressionStart": 1318, "tryExpressionEnd": 1322, "tryBlockStart": 1318, "tryBlockEnd": 1638, "catchExpressionStart": 1513, "catchExpressionEnd": 1546, "catchBlockStart": 1513, "catchBlockEnd": 1638, "exceptionHandlingCallStart": [1554, 1598], "exceptionHandlingCallEnd": [1584, 1631], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1345, "focalAPIEnd": 1366, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()", "stringTokenizer.nextToken()", "stringTokenizer.nextToken()", "remove(nextToken)", "HashMap.put(nextToken,Object[])", "StringBuffer.append(nextToken)"], "useStart": [1402, 1438, 1484, 1728, 3241, 3589], "useEnd": [1423, 1459, 1505, 1766, 3288, 3627], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dvn/dvn-svn-import-test4/tree/master/tags/release-2.1/src/DVN-web/src/edu/harvard/iq/dvn/core/web/oai/catalog/DVNOAICatalog.java", "rawCode": "  /**\n   * Retrieve the next set of records associated with the resumptionToken\n   *\n   * @param resumptionToken implementation-dependent format taken from the previous listRecords()\n   *     Map result.\n   * @return a Map object containing entries for \"headers\" and \"identifiers\" Iterators (both\n   *     containing Strings) as well as an optional \"resumptionMap\" Map.\n   * @exception BadResumptionTokenException the value of the resumptionToken argument is invalid or\n   *     expired.\n   */\n  public Map listRecords(String resumptionToken) throws BadResumptionTokenException {\n    Map listRecordsMap = new HashMap();\n    ArrayList records = new ArrayList();\n    purge(); // clean out old resumptionTokens\n\n    /**\n     * ******************************************************************** YOUR CODE GOES HERE\n     * ********************************************************************\n     */\n    /**\n     * ******************************************************************** parse your\n     * resumptionToken and look it up in the resumptionResults, if necessary\n     * ********************************************************************\n     */\n    StringTokenizer tokenizer = new StringTokenizer(resumptionToken, \":\");\n    String resumptionId;\n    int oldCount;\n    String set;\n    String metadataPrefix;\n    try {\n      resumptionId = tokenizer.nextToken();\n      oldCount = Integer.parseInt(tokenizer.nextToken());\n      set = tokenizer.nextToken();\n      metadataPrefix = tokenizer.nextToken();\n    } catch (NoSuchElementException e) {\n      logger.info(\"No such element\");\n      throw new BadResumptionTokenException();\n    }\n\n    /* Get some more records from your database */\n    Object[] nativeItem = (Object[]) resumptionResults.remove(resumptionId);\n    if (nativeItem == null) {\n      logger.info(\"nativeItem null\");\n      throw new BadResumptionTokenException();\n    }\n    int count;\n\n    /* load the headers and identifiers ArrayLists. */\n    for (count = 0; count < maxListSize && count + oldCount < nativeItem.length; ++count) {\n      try {\n        String record = constructRecord(nativeItem[count + oldCount], metadataPrefix);\n        records.add(record);\n      } catch (CannotDisseminateFormatException e) {\n        /* the client hacked the resumptionToken beyond repair */\n        logger.info(\"Cannot Disseminate Format \" + nativeItem.toString() + count);\n        throw new BadResumptionTokenException();\n      }\n    }\n\n    /* decide if you're done */\n    if (count + oldCount < nativeItem.length) {\n      resumptionId = getResumptionId(set);\n\n      /**\n       * *************************************************************** Store an object appropriate\n       * for your database API in the resumptionResults Map in place of nativeItems. This object\n       * should probably encapsulate the information necessary to perform the next resumption of\n       * ListIdentifiers. It might even be possible to encode everything you need in the\n       * resumptionToken, in which case you won't need the resumptionResults Map. Here, I've done a\n       * silly combination of the two. Stateless resumptionTokens have some advantages.\n       * ***************************************************************\n       */\n      resumptionResults.put(resumptionId, nativeItem);\n\n      /**\n       * *************************************************************** Construct the\n       * resumptionToken String however you see fit.\n       * ***************************************************************\n       */\n      StringBuffer resumptionTokenSb = new StringBuffer();\n      resumptionTokenSb.append(resumptionId);\n      resumptionTokenSb.append(\":\");\n      resumptionTokenSb.append(Integer.toString(oldCount + count));\n      resumptionTokenSb.append(\":\");\n      resumptionTokenSb.append(set);\n      resumptionTokenSb.append(\":\");\n      resumptionTokenSb.append(metadataPrefix);\n\n      /**\n       * *************************************************************** Use the following line if\n       * you wish to include the optional resumptionToken attributes in the response. Otherwise, use\n       * the line after it that I've commented out.\n       * ***************************************************************\n       */\n      listRecordsMap.put(\n          \"resumptionMap\",\n          getResumptionMap(resumptionTokenSb.toString(), nativeItem.length, oldCount));\n      // listRecordsMap.put(\"resumptionMap\",\n      // getResumptionMap(resumptionTokenSb.toString()));\n    }\n    /**\n     * ********************************************************************* END OF CUSTOM CODE\n     * SECTION *********************************************************************\n     */\n    listRecordsMap.put(\"records\", records.iterator());\n    return listRecordsMap;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9007, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [244], "initializationEnd": [277], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 283, "focalAPIEnd": 300, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()", "stringTokenizer.nextToken()", "stringTokenizer.nextToken()", "stringTokenizer.nextToken()", "add(nextToken)"], "useStart": [315, 367, 397, 546, 529], "useEnd": [332, 384, 414, 563, 564], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/b0n541/jskat-multimodule/tree/master/jskat-base/src/test/java/org/jskat/control/iss/MessageParserTest.java", "rawCode": "  /** Tests showing cards */\n  @Test\n  public void testParseTableUpdatePlayerShowCards() {\n\n    final String playerResign =\n        \"table .3 foo play 2 SC.HT.HA.SJ.SQ.SK.CJ 164.1 177.0 156.4\"; // $NON-NLS-1$\n\n    final StringTokenizer token = new StringTokenizer(playerResign);\n    token.nextToken(); // table\n    token.nextToken(); // .3\n    final String creator = token.nextToken(); // foo\n    token.nextToken(); // play\n    final List<String> detailParams = new ArrayList<String>();\n    while (token.hasMoreTokens()) {\n      detailParams.add(token.nextToken());\n    }\n\n    final MoveInformation moveInfo = MessageParser.getMoveInformation(detailParams);\n\n    assertEquals(MoveType.SHOW_CARDS, moveInfo.getType());\n    final CardList ouvertCards = moveInfo.getOuvertCards();\n    assertEquals(6, ouvertCards.size());\n    assertTrue(ouvertCards.contains(Card.HT));\n    assertTrue(ouvertCards.contains(Card.HA));\n    assertTrue(ouvertCards.contains(Card.SJ));\n    assertTrue(ouvertCards.contains(Card.SQ));\n    assertTrue(ouvertCards.contains(Card.SK));\n    assertTrue(ouvertCards.contains(Card.CJ));\n  }\n"}, {"dataset": "nextToken", "exampleID": 9008, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [261], "initializationEnd": [291], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreElements()", "guardType": "LOOP {", "guardExpressionStart": 347, "guardExpressionEnd": 382, "guardBlockStart": 347, "guardBlockEnd": 417, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 394, "focalAPIEnd": 415, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(nextToken)"], "useStart": [383], "useEnd": [416], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jortizcs/sfs_applications/tree/master/energylens/sfs_transactions/sfs/db/txactions/SfsGlobalTransactionManager.java", "rawCode": "  private static String getParent(String path) {\n    logger.info(\"Getting parent of \" + path);\n    if (path == null || path.equals(\"/\")) {\n      logger.info(\"Returning NULL::\" + path + \" has no parent\");\n      return null;\n    }\n    StringTokenizer tokenizer = new StringTokenizer(path, \"/\");\n    Vector<String> tokens = new Vector<String>();\n    while (tokenizer.hasMoreElements()) tokens.add(tokenizer.nextToken());\n    StringBuffer parentPathBuffer = new StringBuffer();\n    if (tokens.size() == 1) parentPathBuffer.append(\"/\");\n    else\n      for (int i = 0; i < tokens.size() - 1; i++)\n        parentPathBuffer.append(\"/\").append(tokens.elementAt(i));\n    logger.info(\"Parent_path=\" + parentPathBuffer.toString());\n    return parentPathBuffer.toString();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9009, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [119], "initializationEnd": [142], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreElements()", "guardType": "LOOP {", "guardExpressionStart": 148, "guardExpressionEnd": 176, "guardBlockStart": 148, "guardBlockEnd": 681, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 200, "focalAPIEnd": 214, "followUpCheck": "nextToken.equals(\"#define\")", "checkType": "IF", "followUpCheckExpressionStart": 249, "followUpCheckExpressionEnd": 277, "followUpCheckBlockStart": 249, "followUpCheckBlockEnd": 675, "use": ["stringTokenizer.nextToken()", "stringTokenizer.nextToken()", "stringTokenizer.nextToken()", "StringBuffer.append(nextToken)"], "useStart": [348, 410, 547, 624], "useEnd": [362, 424, 561, 641], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mbien/jake2/tree/master/test/ConvertDefines.java", "rawCode": "  public static String convertDefine(String in) {\n    StringBuffer out = new StringBuffer();\n\n    StringTokenizer tk = new StringTokenizer(in);\n    while (tk.hasMoreElements()) {\n      String token = tk.nextToken();\n\n      // finds the define\n      if (token.equals(\"#define\")) {\n        out.append(\" public final static int \");\n        out.append(tk.nextToken());\n        out.append(\"= \");\n        out.append(tk.nextToken());\n        out.append(\";\\t\");\n\n        // append rest and out.\n        while (tk.hasMoreElements()) {\n          out.append(tk.nextToken());\n          out.append(\" \");\n        }\n      } else {\n        out.append(token);\n        out.append(\" \");\n      }\n    }\n    return out.toString();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9010, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [449], "initializationEnd": [489], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 540, "guardExpressionEnd": 569, "guardBlockStart": 540, "guardBlockEnd": 776, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 592, "focalAPIEnd": 609, "followUpCheck": "!dataRoot.hasNode(nextToken)", "checkType": "IF", "followUpCheckExpressionStart": 617, "followUpCheckExpressionEnd": 645, "followUpCheckBlockStart": 617, "followUpCheckBlockEnd": 770, "use": ["addNode(nextToken,*)", "Node.getNode(nextToken)"], "useStart": [667, 739], "useEnd": [703, 761], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.12/kernel-impl/src/test/java/org/sakaiproject/jcr/test/PropertyTestData.java", "rawCode": "  /**\n   * Creates a test node at {@link #TEST_DATA_PATH} with a boolean, double, long, calendar and a\n   * path property.\n   */\n  public void testFillInTestData() throws RepositoryException, IOException {\n    if (superuser.getRootNode().hasNode(TEST_DATA_PATH)) {\n      // delete previous data\n      superuser.getRootNode().getNode(TEST_DATA_PATH).remove();\n      superuser.save();\n    }\n    // create nodes to testPath\n    StringTokenizer names = new StringTokenizer(TEST_DATA_PATH, \"/\");\n    Node dataRoot = superuser.getRootNode();\n    while (names.hasMoreTokens()) {\n      String name = names.nextToken();\n      if (!dataRoot.hasNode(name)) {\n        dataRoot = dataRoot.addNode(name, testNodeType);\n      } else {\n        dataRoot = dataRoot.getNode(name);\n      }\n    }\n\n    dataRoot.setProperty(\"boolean\", true);\n    dataRoot.setProperty(\"double\", Math.PI);\n    dataRoot.setProperty(\"long\", 90834953485278298l);\n    Calendar c = Calendar.getInstance();\n    c.set(2005, 6, 18, 17, 30);\n    dataRoot.setProperty(\"calendar\", c);\n    dataRoot.setProperty(\"path\", superuser.getValueFactory().createValue(\"/\", PropertyType.PATH));\n    dataRoot.setProperty(\"multi\", new String[] {\"one\", \"two\", \"three\"});\n    superuser.save();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9011, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [554], "initializationEnd": [594], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 645, "guardExpressionEnd": 674, "guardBlockStart": 645, "guardBlockEnd": 881, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 697, "focalAPIEnd": 714, "followUpCheck": "!dataRoot.hasNode(nextToken)", "checkType": "IF", "followUpCheckExpressionStart": 722, "followUpCheckExpressionEnd": 750, "followUpCheckBlockStart": 722, "followUpCheckBlockEnd": 875, "use": ["addNode(nextToken,*)", "Node.getNode(nextToken)"], "useStart": [772, 844], "useEnd": [808, 866], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/SAK-15710/kernel-impl/src/test/java/org/sakaiproject/jcr/test/QueryTestData.java", "rawCode": "  /**\n   * Creates four nodes under {@link #TEST_DATA_PATH}. Three nodes with name {@link #nodeName1} and\n   * a fourth with name {@link #nodeName2}. Each node has a String property named {@link\n   * #propertyName1} with some content set.\n   */\n  public void testFillInSearchData() throws RepositoryException {\n    if (superuser.getRootNode().hasNode(TEST_DATA_PATH)) {\n      // delete previous data\n      superuser.getRootNode().getNode(TEST_DATA_PATH).remove();\n      superuser.save();\n    }\n    // create nodes to testPath\n    StringTokenizer names = new StringTokenizer(TEST_DATA_PATH, \"/\");\n    Node dataRoot = superuser.getRootNode();\n    while (names.hasMoreTokens()) {\n      String name = names.nextToken();\n      if (!dataRoot.hasNode(name)) {\n        dataRoot = dataRoot.addNode(name, testNodeType);\n      } else {\n        dataRoot = dataRoot.getNode(name);\n      }\n    }\n\n    Node n1 = dataRoot.addNode(nodeName1);\n    log.println(\"Adding node: \" + n1.getPath());\n    Node n2 = dataRoot.addNode(nodeName1);\n    log.println(\"Adding node: \" + n2.getPath());\n    Node n3 = dataRoot.addNode(nodeName1);\n    log.println(\"Adding node: \" + n3.getPath());\n    Node n4 = dataRoot.addNode(nodeName2);\n    log.println(\"Adding node: \" + n4.getPath());\n\n    n1.setProperty(propertyName1, \"You can have it good, cheap, or fast. Any two.\");\n    n2.setProperty(propertyName1, \"foo bar\");\n    n3.setProperty(propertyName1, \"Hello world!\");\n    n4.setProperty(propertyName1, \"Apache Jackrabbit\");\n    superuser.save();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9012, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "UpgradeException", "exceptionHandlingCall": ["error(String,*)"], "tryExpressionStart": 229, "tryExpressionEnd": 233, "tryBlockStart": 229, "tryBlockEnd": 1547, "catchExpressionStart": 1440, "catchExpressionEnd": 1467, "catchBlockStart": 1440, "catchBlockEnd": 1547, "exceptionHandlingCallStart": [1475], "exceptionHandlingCallEnd": [1540], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1324, "focalAPIEnd": 1338, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aldaris/opensso/tree/master/products/upgrade/services/50_iPlanetAMLoggingService/30_40/Migrate.java", "rawCode": "  /**\n   * Updates the <code>iPlanetAMLoggingService<code> service schema.\n   *\n   * @return true if successful otherwise false.\n   */\n  public boolean migrateService() {\n    boolean isSuccess = false;\n    String[] fileList;\n    try {\n      String dbLogging =\n          UpgradeUtils.getAttributeValueString(SERVICE_NAME, LOGGING_TYPE_ATTR, schemaType);\n      String buffTime =\n          UpgradeUtils.getAttributeValueString(SERVICE_NAME, BUFF_TIME_ATTR, schemaType);\n      String buffSize =\n          UpgradeUtils.getAttributeValueString(SERVICE_NAME, BUFF_SIZE_ATTR, schemaType);\n      String timerStat =\n          UpgradeUtils.getAttributeValueString(SERVICE_NAME, BUFF_STATUS_ATTR, schemaType);\n      int i = 0;\n      if ((dbLogging != null && dbLogging.equals(FILE_DB_TYPE))\n          && (timerStat != null && timerStat.equals(OFF_TIMER_STAT))\n          && (buffSize != null && buffSize.equals(BUFF_SIZE_ONE))\n          && (buffTime != null && buffTime.equals(BUFF_TIME))) {\n        fileList = new String[3];\n        fileList[0] = UpgradeUtils.getAbsolutePath(SERVICE_DIR, SCHEMA_FILE);\n        i++;\n      } else {\n        fileList = new String[2];\n      }\n      StringTokenizer st = new StringTokenizer(files);\n      while (st.hasMoreTokens()) {\n        fileList[i] = UpgradeUtils.getAbsolutePath(SERVICE_DIR, (String) st.nextToken());\n        i++;\n      }\n      UpgradeUtils.importServiceData(fileList);\n      isSuccess = true;\n    } catch (UpgradeException e) {\n      UpgradeUtils.debug.error(\"Error loading data:\" + SERVICE_NAME, e);\n    }\n    return isSuccess;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9013, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [1149], "initializationEnd": [1190], "hasTryCatch": 1, "exceptionType": "NoSuchElementException", "exceptionHandlingCall": ["new BadResumptionTokenException()"], "tryExpressionStart": 1321, "tryExpressionEnd": 1325, "tryBlockStart": 1321, "tryBlockEnd": 1625, "catchExpressionStart": 1538, "catchExpressionEnd": 1571, "catchBlockStart": 1538, "catchBlockEnd": 1625, "exceptionHandlingCallStart": [1585], "exceptionHandlingCallEnd": [1618], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1348, "focalAPIEnd": 1369, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()", "stringTokenizer.nextToken()", "stringTokenizer.nextToken()", "HashMap.get(nextToken)", "StringBuffer.append(nextToken)"], "useStart": [1405, 1462, 1509, 1726, 2913], "useEnd": [1426, 1483, 1530, 1761, 2951], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/europeana/contrib/tree/master/repox/branches/repox_rhine/src/main/java/org/oclc/oai/server/catalog/NewJDBCOAICatalog.java", "rawCode": "  /**\n   * Retrieve the next set of identifiers associated with the resumptionToken\n   *\n   * @param resumptionToken implementation-dependent format taken from the previous\n   *     listIdentifiers() Map result.\n   * @return a Map object containing entries for \"headers\" and \"identifiers\" Iterators (both\n   *     containing Strings) as well as an optional \"resumptionMap\" Map.\n   * @exception BadResumptionTokenException the value of the resumptionToken is invalid or expired.\n   * @exception OAIInternalServerError signals an http status code 500 problem\n   */\n  public Map listIdentifiers(String resumptionToken)\n      throws BadResumptionTokenException, OAIInternalServerError {\n    purge(); // clean out old resumptionTokens\n    Map listIdentifiersMap = new HashMap();\n    ArrayList headers = new ArrayList();\n    ArrayList identifiers = new ArrayList();\n\n    /**\n     * ******************************************************************** parse your\n     * resumptionToken and look it up in the resumptionResults, if necessary\n     * ********************************************************************\n     */\n    StringTokenizer tokenizer = new StringTokenizer(resumptionToken, \"!\");\n    String resumptionId;\n    int oldCount;\n    String metadataPrefix;\n    int numRows;\n    StatementResultSet stmtRs = null;\n    try {\n      resumptionId = tokenizer.nextToken();\n      oldCount = Integer.parseInt(tokenizer.nextToken());\n      numRows = Integer.parseInt(tokenizer.nextToken());\n      metadataPrefix = tokenizer.nextToken();\n    } catch (NoSuchElementException e) {\n      throw new BadResumptionTokenException();\n    }\n\n    try {\n      /* Get some more records from your database */\n      stmtRs = (StatementResultSet) resumptionResults.get(resumptionId);\n      if (stmtRs == null) {\n        throw new BadResumptionTokenException();\n      }\n      int count;\n\n      if (stmtRs.getRow() != oldCount) {\n        // System.out.println(\"JDBCOAICatalog.listIdentifiers: reuse of old resumptionToken?\");\n        stmtRs.absolute(oldCount);\n      }\n\n      /* load the headers and identifiers ArrayLists. */\n      for (count = 0; count < maxListSize && stmtRs.next(); ++count) {\n        HashMap nativeItem = stmtRs.getColumnValues();\n        /* Use the RecordFactory to extract header/identifier pairs for each item */\n        Iterator setSpecs = getSetSpecs(nativeItem);\n        String[] header = getRecordFactory().createHeader(nativeItem, setSpecs);\n        headers.add(header[0]);\n        identifiers.add(header[1]);\n      }\n\n      /* decide if you're done. */\n      if (oldCount + count < numRows) {\n        /**\n         * *************************************************************** Construct the\n         * resumptionToken String however you see fit.\n         * ***************************************************************\n         */\n        StringBuffer resumptionTokenSb = new StringBuffer();\n        resumptionTokenSb.append(resumptionId);\n        resumptionTokenSb.append(\"!\");\n        resumptionTokenSb.append(Integer.toString(oldCount + count));\n        resumptionTokenSb.append(\"!\");\n        resumptionTokenSb.append(Integer.toString(numRows));\n        resumptionTokenSb.append(\"!\");\n        resumptionTokenSb.append(metadataPrefix);\n\n        /**\n         * *************************************************************** Use the following line if\n         * you wish to include the optional resumptionToken attributes in the response. Otherwise,\n         * use the line after it that I've commented out.\n         * ***************************************************************\n         */\n        listIdentifiersMap.put(\n            \"resumptionMap\", getResumptionMap(resumptionTokenSb.toString(), numRows, oldCount));\n      } else {\n        stmtRs.close();\n        stmtRs = null;\n      }\n    } catch (SQLException e) {\n      if (stmtRs != null) {\n        try {\n          stmtRs.close();\n        } catch (SQLException e1) {\n          e1.printStackTrace();\n        }\n      }\n      e.printStackTrace();\n      throw new OAIInternalServerError(e.getMessage());\n    }\n\n    listIdentifiersMap.put(\"headers\", headers.iterator());\n    listIdentifiersMap.put(\"identifiers\", identifiers.iterator());\n    return listIdentifiersMap;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9014, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String,boolean)"], "initializationStart": [567], "initializationEnd": [607], "hasTryCatch": 1, "exceptionType": "sun.misc.REException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 619, "tryExpressionEnd": 623, "tryBlockStart": 619, "tryBlockEnd": 891, "catchExpressionStart": 760, "catchExpressionEnd": 792, "catchBlockStart": 760, "catchBlockEnd": 891, "exceptionHandlingCallStart": [806], "exceptionHandlingCallEnd": [878], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 637, "guardExpressionEnd": 663, "guardBlockStart": 637, "guardBlockEnd": 747, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 689, "focalAPIEnd": 703, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["nextToken.toLowerCase()"], "useStart": [689], "useEnd": [717], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AllBinary/phoneme-components-cdc/tree/master/src/share/classes/sun/net/www/http/HttpClient.java", "rawCode": "  /** @return true if host matches a host specified via the http.nonProxyHosts property */\n  private boolean matchNonProxyHosts(String host) {\n    synchronized (getClass()) {\n      String rawList =\n          (String)\n              java.security.AccessController.doPrivileged(\n                  new sun.security.action.GetPropertyAction(\"http.nonProxyHosts\"));\n      if (rawList == null) {\n        nonProxyHostsPool = null;\n      } else {\n        if (!rawList.equals(nonProxyHostsSource)) {\n          RegexpPool pool = new RegexpPool();\n          StringTokenizer st = new StringTokenizer(rawList, \"|\", false);\n          try {\n            while (st.hasMoreTokens()) {\n              pool.add(st.nextToken().toLowerCase(), Boolean.TRUE);\n            }\n          } catch (sun.misc.REException ex) {\n            System.err.println(\"Error in http.nonProxyHosts system property: \" + ex);\n          }\n          nonProxyHostsPool = pool;\n        }\n      }\n      nonProxyHostsSource = rawList;\n    }\n\n    /*\n     * Match against non-proxy hosts\n     */\n    if (nonProxyHostsPool == null) {\n      return false;\n    }\n    if (nonProxyHostsPool.match(host) != null) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9015, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [101], "initializationEnd": [129], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 244, "guardExpressionEnd": 270, "guardBlockStart": 244, "guardBlockEnd": 578, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 286, "focalAPIEnd": 300, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(nextToken)"], "useStart": [318], "useEnd": [340], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/caadapter/tree/master/software/caadapter/src/java/gov/nih/nci/caadapter/ui/help/HelpContentViewer.java", "rawCode": "  private void setMainNodeAtFirst(String id, DefaultMutableTreeNode node) {\n    StringTokenizer st = new StringTokenizer(id, \".\");\n    // int id_s = 0;\n    String curr = \"\";\n    DefaultMutableTreeNode tempNode = headOfMain;\n    int n = 0;\n\n    while (st.hasMoreTokens()) {\n      curr = st.nextToken();\n      int seq = Integer.parseInt(curr);\n      if (n == 0) seq = seq + 1;\n      if ((tempNode.getChildCount()) >= seq) {\n        tempNode = (DefaultMutableTreeNode) tempNode.getChildAt(seq - 1);\n      } else {\n        tempNode.add(node);\n        break;\n      }\n      n++;\n    }\n    return;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9016, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,*,boolean)"], "initializationStart": [145], "initializationEnd": [199], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 205, "guardExpressionEnd": 238, "guardBlockStart": 205, "guardBlockEnd": 402, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 262, "focalAPIEnd": 283, "followUpCheck": "!(LINE_SEPARATOR.equals(nextToken))", "checkType": "IF", "followUpCheckExpressionStart": 291, "followUpCheckExpressionEnd": 327, "followUpCheckBlockStart": 291, "followUpCheckBlockEnd": 396, "use": ["nextToken.replaceAll(String,String)"], "useStart": [350], "useEnd": [386], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codjo/codjo-release-test/tree/master/src/test/java/net/codjo/test/release/TestReportTest.java", "rawCode": "  static List<String> processLogContent(String logContent) {\n    List<String> objects = new ArrayList<String>();\n    StringTokenizer tokenizer = new StringTokenizer(logContent, TestReport.TAB, false);\n    while (tokenizer.hasMoreTokens()) {\n      String token = tokenizer.nextToken();\n      if (!(LINE_SEPARATOR.equals(token))) {\n        objects.add(token.replaceAll(LINE_SEPARATOR, \"\"));\n      }\n    }\n    return objects;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9017, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String,boolean)"], "initializationStart": [439], "initializationEnd": [475], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 484, "guardExpressionEnd": 514, "guardBlockStart": 484, "guardBlockEnd": 581, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 552, "focalAPIEnd": 570, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["get(nextToken)"], "useStart": [539], "useEnd": [571], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/allardhoeve/pcgen-multiline-objects/tree/master/pcgen/code/src/java/pcgen/io/EntityEncoder.java", "rawCode": "  /**\n   * encode characters. \"\\n\" -> \"&nl;\" \"\\r\" -> \"&cr;\" \"\\f\" -> \"&lf;\" \":\" -> \"&colon;\" \"|\" ->\n   * \"&pipe;\" \"[\" -> \"&lbracket;\" \"]\" -> \"&rbracket;\" \"&\" -> \"&amp;\" <br>\n   * author: Thomas Behr 09-09-02\n   *\n   * @param s the String to encode\n   * @return the encoded String\n   */\n  public static String encode(String s) {\n    final StringBuilder buffer = new StringBuilder();\n    if (s != null) {\n      final StringTokenizer tokens = new StringTokenizer(s, ENCODE, true);\n\n      while (tokens.hasMoreTokens()) {\n        buffer.append(ENTITIES.get(tokens.nextToken()));\n      }\n    }\n    return buffer.toString();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9018, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [1126], "initializationEnd": [1162], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 1219, "guardExpressionEnd": 1245, "guardBlockStart": 1219, "guardBlockEnd": 1441, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1269, "focalAPIEnd": 1283, "followUpCheck": "true || nextToken.length() > 0", "checkType": "IF", "followUpCheckExpressionStart": 1353, "followUpCheckExpressionEnd": 1398, "followUpCheckBlockStart": 1353, "followUpCheckBlockEnd": 1435, "use": ["nextToken.trim()", "List<String>.add(nextToken)"], "useStart": [1325, 1409], "useEnd": [1337, 1426], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/koentsje/forge-furnace/tree/master/container-api/src/main/java/org/jboss/forge/furnace/util/Strings.java", "rawCode": "  /**\n   * Tokenize the given String into a String array via a StringTokenizer.\n   *\n   * <p>The given delimiters string is supposed to consist of any number of delimiter characters.\n   * Each of those characters can be used to separate tokens. A delimiter is always a single\n   * character; for multi-character delimiters, consider using delimitedListToStringArray\n   *\n   * @param str the String to tokenize\n   * @param delimiters the delimiter characters, assembled as String (each of those characters is\n   *     individually considered as delimiter)\n   * @param trimTokens trim the tokens via String's trim\n   * @param ignoreEmptyTokens omit empty tokens from the result array (only applies to tokens that\n   *     are empty after trimming; StringTokenizer will not consider subsequent delimiters as token\n   *     in the first place).\n   * @return an array of the tokens (null if the input String was null)\n   */\n  public static String[] tokenizeToStringArray(\n      String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n    if (str == null) {\n      return null;\n    }\n    StringTokenizer st = new StringTokenizer(str, delimiters);\n    List<String> tokens = new ArrayList<String>();\n    while (st.hasMoreTokens()) {\n      String token = st.nextToken();\n      if (trimTokens) {\n        token = token.trim();\n      }\n      if (!ignoreEmptyTokens || token.length() > 0) {\n        tokens.add(token);\n      }\n    }\n    return tokens.toArray(new String[tokens.size()]);\n  }\n"}, {"dataset": "nextToken", "exampleID": 9019, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [205], "initializationEnd": [243], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["stringTokenizer.countTokens()"], "configurationStart": [262], "configurationEnd": [278], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "IF {", "guardExpressionStart": 505, "guardExpressionEnd": 528, "guardBlockStart": 505, "guardBlockEnd": 544, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 529, "focalAPIEnd": 543, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jponge/izpack-full-svn-history-copy/tree/master/izpack-src/tags/milestone-3-7-0-M3/src/lib/com/izforge/izpack/panels/JDKPathPanel.java", "rawCode": "  private final boolean compareVersions(\n      String in,\n      String template,\n      boolean isMin,\n      int assumedPlace,\n      int halfRange,\n      String useNotIdentifier) {\n    StringTokenizer st = new StringTokenizer(in, \" \\t\\n\\r\\f\\\"\");\n    int length = st.countTokens();\n    int i;\n    int currentRange = 0;\n    String[] interestedEntries = new String[halfRange + halfRange];\n    int praeScan = 0;\n    praeScan = assumedPlace - halfRange;\n    for (i = 0; i < assumedPlace - halfRange; ++i)\n      if (st.hasMoreTokens()) st.nextToken(); // Forget this entries.\n\n    for (i = 0;\n        i < halfRange + halfRange;\n        ++i) { // Put the interesting Strings into an intermediaer array.\n      if (st.hasMoreTokens()) {\n        interestedEntries[i] = st.nextToken();\n        currentRange++;\n      }\n    }\n\n    for (i = 0; i < currentRange; ++i) {\n      if (useNotIdentifier != null && interestedEntries[i].indexOf(useNotIdentifier) > -1) continue;\n      if (Character.getType(interestedEntries[i].charAt(0)) != Character.DECIMAL_DIGIT_NUMBER)\n        continue;\n      break;\n    }\n    if (i == currentRange) {\n      detectedVersion = \"<not found>\";\n      return (false);\n    }\n    detectedVersion = interestedEntries[i];\n    StringTokenizer current = new StringTokenizer(interestedEntries[i], \"._-\");\n    StringTokenizer needed = new StringTokenizer(template, \"._-\");\n    while (needed.hasMoreTokens() && current.hasMoreTokens()) {\n      String cur = current.nextToken();\n      String nee = needed.nextToken();\n      if (Integer.parseInt(cur) < Integer.parseInt(nee))\n        if (isMin) return (false);\n        else return (true);\n      if (Integer.parseInt(cur) > Integer.parseInt(nee))\n        if (isMin) return (true);\n        else return (false);\n    }\n    return (true);\n  }\n"}, {"dataset": "nextToken", "exampleID": 9020, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*)"], "initializationStart": [293], "initializationEnd": [322], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 328, "guardExpressionEnd": 354, "guardBlockStart": 328, "guardBlockEnd": 436, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 378, "focalAPIEnd": 392, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["LinkedList<Object>.add(nextToken)"], "useStart": [414], "useEnd": [429], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pcalcado/cmu-sphinx4/tree/master/src/sphinx4/edu/cmu/sphinx/util/NISTAlign.java", "rawCode": "  /**\n   * Converts the given String or words to a LinkedList.\n   *\n   * @param s the String of words to parse to a LinkedList\n   * @return a list, one word per item\n   */\n  LinkedList<Object> toList(String s) {\n    LinkedList<Object> list = new LinkedList<Object>();\n    StringTokenizer st = new StringTokenizer(s.trim());\n    while (st.hasMoreTokens()) {\n      String token = st.nextToken().toLowerCase();\n      list.add(token);\n    }\n    return list;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9021, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [650], "initializationEnd": [680], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 715, "focalAPIEnd": 733, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseFloat(nextToken)", "stringTokenizer.nextToken()", "parseFloat(nextToken)", "stringTokenizer.nextToken()", "parseFloat(nextToken)"], "useStart": [698, 769, 752, 1192, 1175], "useEnd": [734, 787, 788, 1210, 1211], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fisherevans/LRK/tree/master/src/org/newdawn/slick/svg/inkscape/Util.java", "rawCode": "  /**\n   * Get a transform defined in the XML\n   *\n   * @param element The element from which the transform should be read\n   * @param attribute The name of the attribute holding the transform\n   * @return The transform to be applied\n   */\n  static Transform getTransform(Element element, String attribute) {\n    String str = element.getAttribute(attribute);\n    if (str == null) {\n      return new Transform();\n    }\n\n    if (str.equals(\"\")) {\n      return new Transform();\n    } else if (str.startsWith(\"translate\")) {\n      str = str.substring(0, str.length() - 1);\n      str = str.substring(\"translate(\".length());\n      StringTokenizer tokens = new StringTokenizer(str, \", \");\n      float x = Float.parseFloat(tokens.nextToken());\n      float y = Float.parseFloat(tokens.nextToken());\n\n      return Transform.createTranslateTransform(x, y);\n    } else if (str.startsWith(\"matrix\")) {\n      float[] pose = new float[6];\n      str = str.substring(0, str.length() - 1);\n      str = str.substring(\"matrix(\".length());\n      StringTokenizer tokens = new StringTokenizer(str, \", \");\n      float[] tr = new float[6];\n      for (int j = 0; j < tr.length; j++) {\n        tr[j] = Float.parseFloat(tokens.nextToken());\n      }\n\n      pose[0] = tr[0];\n      pose[1] = tr[2];\n      pose[2] = tr[4];\n      pose[3] = tr[1];\n      pose[4] = tr[3];\n      pose[5] = tr[5];\n\n      return new Transform(pose);\n    }\n\n    return new Transform();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9022, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [3351], "initializationEnd": [3378], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 3386, "guardExpressionEnd": 3416, "guardBlockStart": 3386, "guardBlockEnd": 3549, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 3475, "focalAPIEnd": 3493, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PUSH(ConstantPoolGen,nextToken)"], "useStart": [3461], "useEnd": [3494], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/xena/ext/src/xalan-j_2_7_1/src/org/apache/xalan/xsltc/compiler/Output.java", "rawCode": "  /**\n   * Compile code that passes the information in this <xsl:output> element to the appropriate fields\n   * in the translet\n   */\n  public void translate(ClassGenerator classGen, MethodGenerator methodGen) {\n\n    // Do nothing if other <xsl:output> element has higher precedence\n    if (_disabled) return;\n\n    ConstantPoolGen cpg = classGen.getConstantPool();\n    InstructionList il = methodGen.getInstructionList();\n\n    int field = 0;\n    il.append(classGen.loadTranslet());\n\n    // Only update _version field if set and different from default\n    if ((_version != null) && (!_version.equals(XML_VERSION))) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_version\", STRING_SIG);\n      il.append(DUP);\n      il.append(new PUSH(cpg, _version));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Only update _method field if \"method\" attribute used\n    if (_method != null) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_method\", STRING_SIG);\n      il.append(DUP);\n      il.append(new PUSH(cpg, _method));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Only update if _encoding field is \"encoding\" attribute used\n    if (_encoding != null) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_encoding\", STRING_SIG);\n      il.append(DUP);\n      il.append(new PUSH(cpg, _encoding));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Only update if \"omit-xml-declaration\" used and set to 'yes'\n    if (_omitHeader) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_omitHeader\", \"Z\");\n      il.append(DUP);\n      il.append(new PUSH(cpg, _omitHeader));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Add 'standalone' decaration to output - use text as is\n    if (_standalone != null) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_standalone\", STRING_SIG);\n      il.append(DUP);\n      il.append(new PUSH(cpg, _standalone));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Set system/public doctype only if both are set\n    field = cpg.addFieldref(TRANSLET_CLASS, \"_doctypeSystem\", STRING_SIG);\n    il.append(DUP);\n    il.append(new PUSH(cpg, _doctypeSystem));\n    il.append(new PUTFIELD(field));\n    field = cpg.addFieldref(TRANSLET_CLASS, \"_doctypePublic\", STRING_SIG);\n    il.append(DUP);\n    il.append(new PUSH(cpg, _doctypePublic));\n    il.append(new PUTFIELD(field));\n\n    // Add 'medye-type' decaration to output - if used\n    if (_mediaType != null) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_mediaType\", STRING_SIG);\n      il.append(DUP);\n      il.append(new PUSH(cpg, _mediaType));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Compile code to set output indentation on/off\n    if (_indent) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_indent\", \"Z\");\n      il.append(DUP);\n      il.append(new PUSH(cpg, _indent));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Compile code to set indent amount.\n    if (_indentamount != null && !_indentamount.equals(EMPTYSTRING)) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_indentamount\", \"I\");\n      il.append(DUP);\n      il.append(new PUSH(cpg, Integer.parseInt(_indentamount)));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Forward to the translet any elements that should be output as CDATA\n    if (_cdata != null) {\n      int index = cpg.addMethodref(TRANSLET_CLASS, \"addCdataElement\", \"(Ljava/lang/String;)V\");\n\n      StringTokenizer tokens = new StringTokenizer(_cdata);\n      while (tokens.hasMoreTokens()) {\n        il.append(DUP);\n        il.append(new PUSH(cpg, tokens.nextToken()));\n        il.append(new INVOKEVIRTUAL(index));\n      }\n    }\n    il.append(POP); // Cleanup - pop last translet reference off stack\n  }\n"}, {"dataset": "nextToken", "exampleID": 9023, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [554], "initializationEnd": [594], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 645, "guardExpressionEnd": 674, "guardBlockStart": 645, "guardBlockEnd": 881, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 697, "focalAPIEnd": 714, "followUpCheck": "!dataRoot.hasNode(nextToken)", "checkType": "IF", "followUpCheckExpressionStart": 722, "followUpCheckExpressionEnd": 750, "followUpCheckBlockStart": 722, "followUpCheckBlockEnd": 875, "use": ["addNode(nextToken,*)", "Node.getNode(nextToken)"], "useStart": [772, 844], "useEnd": [808, 866], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta12/kernel-impl/src/test/java/org/sakaiproject/jcr/test/QueryTestData.java", "rawCode": "  /**\n   * Creates four nodes under {@link #TEST_DATA_PATH}. Three nodes with name {@link #nodeName1} and\n   * a fourth with name {@link #nodeName2}. Each node has a String property named {@link\n   * #propertyName1} with some content set.\n   */\n  public void testFillInSearchData() throws RepositoryException {\n    if (superuser.getRootNode().hasNode(TEST_DATA_PATH)) {\n      // delete previous data\n      superuser.getRootNode().getNode(TEST_DATA_PATH).remove();\n      superuser.save();\n    }\n    // create nodes to testPath\n    StringTokenizer names = new StringTokenizer(TEST_DATA_PATH, \"/\");\n    Node dataRoot = superuser.getRootNode();\n    while (names.hasMoreTokens()) {\n      String name = names.nextToken();\n      if (!dataRoot.hasNode(name)) {\n        dataRoot = dataRoot.addNode(name, testNodeType);\n      } else {\n        dataRoot = dataRoot.getNode(name);\n      }\n    }\n\n    Node n1 = dataRoot.addNode(nodeName1);\n    log.println(\"Adding node: \" + n1.getPath());\n    Node n2 = dataRoot.addNode(nodeName1);\n    log.println(\"Adding node: \" + n2.getPath());\n    Node n3 = dataRoot.addNode(nodeName1);\n    log.println(\"Adding node: \" + n3.getPath());\n    Node n4 = dataRoot.addNode(nodeName2);\n    log.println(\"Adding node: \" + n4.getPath());\n\n    n1.setProperty(propertyName1, \"You can have it good, cheap, or fast. Any two.\");\n    n2.setProperty(propertyName1, \"foo bar\");\n    n3.setProperty(propertyName1, \"Hello world!\");\n    n4.setProperty(propertyName1, \"Apache Jackrabbit\");\n    superuser.save();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9024, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [151], "initializationEnd": [184], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 205, "guardExpressionEnd": 232, "guardBlockStart": 205, "guardBlockEnd": 292, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 245, "focalAPIEnd": 260, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["nextToken.trim()"], "useStart": [276], "useEnd": [284], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vrockai/picketlink-idm/tree/master/picketlink-idm-core/src/main/java/org/picketlink/idm/impl/configuration/jaxb2/SystemPropertiesSubstitutionConverter.java", "rawCode": "  private static List<String> parseStringList(String l, String separator) {\n    List<String> tmp = new LinkedList<String>();\n    StringTokenizer tok = new StringTokenizer(l, separator);\n    String t;\n\n    while (tok.hasMoreTokens()) {\n      t = tok.nextToken();\n      tmp.add(t.trim());\n    }\n\n    return tmp;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9025, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [80], "initializationEnd": [125], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "IF {", "guardExpressionStart": 213, "guardExpressionEnd": 243, "guardBlockStart": 213, "guardBlockEnd": 306, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 271, "focalAPIEnd": 292, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()", "stringTokenizer.nextToken()"], "useStart": [368, 468], "useEnd": [389, 489], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mnlk2-custom/android_packages_apps_Settings/tree/master/src/com/android/settings/TextToSpeechSettings.java", "rawCode": "  private void parseLocaleInfo(String locale) {\n    StringTokenizer tokenizer = new StringTokenizer(locale, LOCALE_DELIMITER);\n    mDefaultLanguage = \"\";\n    mDefaultCountry = \"\";\n    mDefaultLocVariant = \"\";\n    if (tokenizer.hasMoreTokens()) {\n      mDefaultLanguage = tokenizer.nextToken().trim();\n    }\n    if (tokenizer.hasMoreTokens()) {\n      mDefaultCountry = tokenizer.nextToken().trim();\n    }\n    if (tokenizer.hasMoreTokens()) {\n      mDefaultLocVariant = tokenizer.nextToken().trim();\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9026, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*,String)"], "initializationStart": [313], "initializationEnd": [405], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 437, "focalAPIEnd": 451, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["nextToken.trim()"], "useStart": [437], "useEnd": [458], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/allati/eclipse-rbe/tree/master/src/com/essiembre/eclipse/rbe/ui/editor/resources/PDEUtils.java", "rawCode": "  private static String getManifestEntryValue(IResource manifest, String entryKey) {\n    if (manifest instanceof IFile) {\n      String content = getFileContent((IFile) manifest, \"UTF8\"); // $NON-NLS-1$\n      int index = content.indexOf(entryKey);\n      if (index != -1) {\n        StringTokenizer st =\n            new StringTokenizer(\n                content.substring(index + entryKey.length()), \";:\\r\\n\"); // $NON-NLS-1$\n        return st.nextToken().trim();\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9027, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [763], "initializationEnd": [793], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 801, "guardExpressionEnd": 827, "guardBlockStart": 801, "guardBlockEnd": 1009, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 860, "focalAPIEnd": 874, "followUpCheck": "\"-\".equals(nextToken)", "checkType": "IF", "followUpCheckExpressionStart": 884, "followUpCheckExpressionEnd": 913, "followUpCheckBlockStart": 884, "followUpCheckBlockEnd": 1001, "use": ["loadMenuItem(ActionContext,nextToken,boolean)"], "useStart": [957], "useEnd": [999], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vanzin/jEdit/tree/master/org/gjt/sp/jedit/GUIUtilities.java", "rawCode": "  /**\n   * Creates a popup menu.\n   *\n   * @param context An action context; either <code>jEdit.getActionContext()</code> or <code>\n   *     VFSBrowser.getActionContext()</code>.\n   * @param name The menu name\n   * @param textArea the textArea wanting to show the popup. If not null, include context menu items\n   *     defined by services.\n   * @param evt additional context info about where the mouse was when menu was requested\n   * @return the popup menu\n   * @since jEdit 4.3pre15\n   */\n  public static JPopupMenu loadPopupMenu(\n      ActionContext context, String name, JEditTextArea textArea, MouseEvent evt) {\n    JPopupMenu menu = new JPopupMenu();\n\n    String menuItems = jEdit.getProperty(name);\n    if (menuItems != null) {\n      StringTokenizer st = new StringTokenizer(menuItems);\n      while (st.hasMoreTokens()) {\n        String menuItemName = st.nextToken();\n        if (\"-\".equals(menuItemName)) menu.addSeparator();\n        else menu.add(loadMenuItem(context, menuItemName, false));\n      }\n    }\n    // load menu items defined by services\n    if (textArea != null) {\n      List<JMenuItem> list = GUIUtilities.getServiceContextMenuItems(textArea, evt);\n      if (!list.isEmpty()) {\n        menu.addSeparator();\n      }\n      for (JMenuItem mi : list) {\n        menu.add(mi);\n      }\n    }\n\n    return menu;\n  } // }}}\n"}, {"dataset": "nextToken", "exampleID": 9028, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [81], "initializationEnd": [113], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["stringTokenizer.countTokens()"], "configurationStart": [131], "configurationEnd": [149], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 263, "focalAPIEnd": 279, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseFloat(nextToken)"], "useStart": [246], "useEnd": [280], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olamedia/jagatoo/tree/master/src/org/jagatoo/loaders/models/collada/stax/XMLFloatArray.java", "rawCode": "  public static float[] toArray(String floatValues) {\n    StringTokenizer tknz = new StringTokenizer(floatValues);\n    int count = tknz.countTokens();\n    float[] floats = new float[count];\n    for (int i = 0; i < count; i++) {\n      floats[i] = Float.parseFloat(tknz.nextToken());\n    }\n    return floats;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9029, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NoSuchElementException", "exceptionHandlingCall": ["getString(String)", "new IllegalArgumentException(*)"], "tryExpressionStart": 179, "tryExpressionEnd": 183, "tryBlockStart": 179, "tryBlockEnd": 393, "catchExpressionStart": 227, "catchExpressionEnd": 268, "catchBlockStart": 227, "catchBlockEnd": 393, "exceptionHandlingCallStart": [342, 313], "exceptionHandlingCallEnd": [370, 371], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 198, "focalAPIEnd": 219, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/embest-tech/rowboat-frameworks-base/tree/master/awt/java/awt/AWTKeyStroke.java", "rawCode": "  /**\n   * Gets the next token.\n   *\n   * @param tokenizer the tokenizer.\n   * @return the next token.\n   */\n  private static String getNextToken(StringTokenizer tokenizer) {\n    try {\n      return tokenizer.nextToken();\n    } catch (NoSuchElementException exception) {\n      // awt.66=Invalid format\n      throw new IllegalArgumentException(Messages.getString(\"awt.66\")); // $NON-NLS-1$\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9030, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [1293], "initializationEnd": [1329], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 1370, "guardExpressionEnd": 1396, "guardBlockStart": 1370, "guardBlockEnd": 1592, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1420, "focalAPIEnd": 1434, "followUpCheck": "true || nextToken.length() > 0", "checkType": "IF", "followUpCheckExpressionStart": 1504, "followUpCheckExpressionEnd": 1549, "followUpCheckBlockStart": 1504, "followUpCheckBlockEnd": 1586, "use": ["nextToken.trim()", "List.add(nextToken)"], "useStart": [1476, 1560], "useEnd": [1488, 1577], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jiongs/cocit/tree/master/src/core/com/kmetop/demsy/lang/Str.java", "rawCode": "  /**\n   * Tokenize the given String into a String array via a StringTokenizer.\n   *\n   * <p>The given delimiters string is supposed to consist of any number of delimiter characters.\n   * Each of those characters can be used to separate tokens. A delimiter is always a single\n   * character; for multi-character delimiters, consider using <code>delimitedListToStringArray\n   * </code>\n   *\n   * @param str the String to tokenize\n   * @param delimiters the delimiter characters, assembled as String (each of those characters is\n   *     individually considered as delimiter)\n   * @param trimTokens trim the tokens via String's <code>trim</code>\n   * @param ignoreEmptyTokens omit empty tokens from the result array (only applies to tokens that\n   *     are empty after trimming; StringTokenizer will not consider subsequent delimiters as token\n   *     in the first place).\n   * @return an array of the tokens (<code>null</code> if the input String was <code>null</code>)\n   * @see java.util.StringTokenizer\n   * @see java.lang.String#trim()\n   * @see #delimitedListToStringArray\n   */\n  public static String[] tokenizeToStringArray(\n      String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n\n    if (str == null) {\n      return null;\n    }\n    StringTokenizer st = new StringTokenizer(str, delimiters);\n    List tokens = new ArrayList();\n    while (st.hasMoreTokens()) {\n      String token = st.nextToken();\n      if (trimTokens) {\n        token = token.trim();\n      }\n      if (!ignoreEmptyTokens || token.length() > 0) {\n        tokens.add(token);\n      }\n    }\n    return toStringArray(tokens);\n  }\n"}, {"dataset": "nextToken", "exampleID": 9031, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String,boolean)"], "initializationStart": [867], "initializationEnd": [919], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 1004, "guardExpressionEnd": 1042, "guardBlockStart": 1004, "guardBlockEnd": 1874, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1073, "focalAPIEnd": 1087, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["nextToken.length()", "locateInZipFile(nextToken,String,boolean,boolean)"], "useStart": [1174, 1377], "useEnd": [1187, 1425], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openjdk-mirror/jdk7u-corba/tree/master/src/share/classes/com/sun/tools/corba/se/idl/som/cff/FileLocator.java", "rawCode": "  /**\n   * locateClassFile returns a DataInputStream with mark/reset capability that can be used to read\n   * the requested class file. The CLASSPATH is used to locate the class.\n   *\n   * @param classFileName The name of the class to locate. The class name should be given in\n   *     fully-qualified form, for example:\n   *     <pre>\n   * java.lang.Object\n   * java.io.DataInputStream\n   * </pre>\n   *\n   * @exception java.io.FileNotFoundException The requested class file could not be found.\n   * @exception java.io.IOException The requested class file could not be opened.\n   */\n  public static DataInputStream locateClassFile(String classFileName)\n      throws FileNotFoundException, IOException {\n\n    boolean notFound = true;\n    StringTokenizer st;\n    String path = \"\";\n    String pathNameForm;\n    File cf = null;\n    NamedDataInputStream result;\n\n    st = new StringTokenizer(classPath, pathSeparator, false);\n    pathNameForm = classFileName.replace('.', File.separatorChar) + \".class\";\n\n    while (st.hasMoreTokens() && notFound) {\n\n      try {\n        path = st.nextToken();\n      } catch (NoSuchElementException nse) {\n        break;\n      }\n      int pLen = path.length();\n      String pathLast4 = pLen > 3 ? path.substring(pLen - 4) : \"\";\n      if (pathLast4.equalsIgnoreCase(\".zip\") || pathLast4.equalsIgnoreCase(\".jar\")) {\n\n        try {\n\n          result = locateInZipFile(path, classFileName, true, true);\n          if (result == null) continue;\n          return (DataInputStream) result;\n\n        } catch (ZipException zfe) {\n          continue;\n        } catch (IOException ioe) {\n          continue;\n        }\n\n      } else {\n        try {\n          cf = new File(path + File.separator + pathNameForm);\n        } catch (NullPointerException npe) {\n          continue;\n        }\n        if ((cf != null) && cf.exists()) notFound = false;\n      }\n    }\n\n    if (notFound) {\n\n      /* Make one last attempt to find the file in the current\n       * directory\n       */\n\n      int lastdot = classFileName.lastIndexOf('.');\n      String simpleName = (lastdot >= 0) ? classFileName.substring(lastdot + 1) : classFileName;\n\n      result =\n          new NamedDataInputStream(\n              new BufferedInputStream(new FileInputStream(simpleName + \".class\")),\n              simpleName + \".class\",\n              false);\n      return (DataInputStream) result;\n    }\n\n    result =\n        new NamedDataInputStream(\n            new BufferedInputStream(new FileInputStream(cf)),\n            path + File.separator + pathNameForm,\n            false);\n    return (DataInputStream) result;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9032, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [218], "initializationEnd": [244], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 580, "focalAPIEnd": 595, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()", "stringTokenizer.nextToken()"], "useStart": [751, 1305], "useEnd": [766, 1321], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dreedyman/Rio/tree/master/rio-tools/rio-cli/src/main/java/org/rioproject/tools/cli/MonitorControl.java", "rawCode": "    public String process(final String input, final BufferedReader br, final PrintStream out) {\n      if (out == null) throw new IllegalArgumentException(\"Must have an output PrintStream\");\n      StringTokenizer tok = new StringTokenizer(input);\n      String deployment = null;\n      DeployOptions deployOptions = new DeployOptions();\n      deployOptions.deployTimeout = (Long) CLI.getInstance().settings.get(CLI.DEPLOY_WAIT);\n      BufferedReader reader = br;\n      boolean oarDeployment = false;\n\n      if (tok.countTokens() > 1) {\n        /* First token is \"deploy\" */\n        tok.nextToken();\n        /* Next token is the deploy-descriptor */\n        // deployment = tok.nextToken();\n        while (tok.hasMoreTokens()) {\n          String value = tok.nextToken();\n          if (value.endsWith(\".xml\") || value.endsWith(\".groovy\")) {\n            /* value is the deploy-descriptor */\n            deployment = value;\n          } else if (value.endsWith(\"oar\")) {\n            /* value is the oar file */\n            deployment = value;\n            oarDeployment = true;\n          } else if (value.startsWith(\"-t\")) {\n            StringTokenizer tok1 = new StringTokenizer(value, \" =\");\n            if (tok1.countTokens() < 2) return (getUsage());\n            /* First token will be \"delay\" */\n            tok1.nextToken();\n            /* Next token must be the timeout value */\n            value = tok1.nextToken();\n            try {\n              deployOptions.deployTimeout = Long.parseLong(value);\n            } catch (NumberFormatException e) {\n              return (getUsage());\n            }\n          } else if (value.startsWith(\"-r\")) {\n            StringTokenizer tok1 = new StringTokenizer(value, \" =\");\n            if (tok1.countTokens() < 2) return (getUsage());\n            /* First token will be \"-r\" */\n            tok1.nextToken();\n            /* Next token must be the repositories value */\n            value = tok1.nextToken();\n            deployOptions.repositories = value;\n          } else if (value.startsWith(\"-\")) {\n            /* strip the \"-\" off */\n            value = value.substring(1);\n            while (value.length() > 0) {\n              if (value.startsWith(\"i\")) {\n                deployOptions.noPrompt = true;\n              } else if (value.startsWith(\"u\")) {\n                deployOptions.update = true;\n              } else if (value.startsWith(\"v\")) {\n                deployOptions.verbose = true;\n              } else {\n                return (getUsage());\n              }\n              value = value.substring(1);\n            }\n          } else {\n            /* If its none of the above then we must have a\n             * directory name to deploy */\n            deployment = value;\n            oarDeployment = true;\n          }\n        }\n      } else {\n        return (getUsage());\n      }\n      OperationalString deploy = null;\n      if (!oarDeployment) {\n        try {\n          deploy = loadDeployment(deployment);\n          if (deploy == null) {\n            return (deployment + \": Cannot find file [\" + deployment + \"]\\n\");\n          }\n          if (deployOptions.repositories != null) {\n            String[] parts = deployOptions.repositories.split(\";\");\n            List<RemoteRepository> remoteRepositories = new ArrayList<RemoteRepository>();\n            for (String part : parts) {\n              RemoteRepository r = new RemoteRepository();\n              r.setUrl(part);\n              remoteRepositories.add(r);\n            }\n            for (ServiceElement service : deploy.getServices()) {\n              service.setRemoteRepositories(remoteRepositories);\n            }\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          return (\"Problem loading [\"\n              + deployment\n              + \"], Exception : \"\n              + e.getLocalizedMessage()\n              + \"\\n\");\n        }\n      }\n\n      ServiceItem[] items =\n          CLI.getInstance().finder.findMonitors(null, null, deployOptions.verbose);\n      if (items.length == 0) return (\"No Provision Monitor instances discovered\\n\");\n\n      if (items.length == 1 || deployOptions.noPrompt()) {\n        if (oarDeployment) {\n          return (deploy(items[0], deployment, deployOptions, out));\n        } else {\n          return (deploy(items[0], deploy, deployOptions, reader, out));\n        }\n      }\n      if (reader == null) reader = new BufferedReader(new InputStreamReader(System.in));\n      out.println(Formatter.asList(items) + \"\\n\");\n      printRequest(out);\n      while (true) {\n        try {\n          String response = reader.readLine();\n          if (response == null) {\n            break;\n          }\n          if (response.equals(\"c\")) break;\n          try {\n            int num = Integer.parseInt(response);\n            if (num < 1 || num > (items.length + 1)) {\n              printRequest(out);\n            } else {\n              if (oarDeployment) {\n                deploy(items[0], deployment, deployOptions, out);\n              } else {\n                deploy(items[num - 1], deploy, deployOptions, reader, out);\n              }\n              break;\n            }\n          } catch (NumberFormatException e) {\n            out.println(\"Invalid choice [\" + response + \"]\");\n            printRequest(out);\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return (\"\");\n    }\n"}, {"dataset": "nextToken", "exampleID": 9033, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [436], "initializationEnd": [461], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 616, "focalAPIEnd": 630, "followUpCheck": "nextToken.equals(\":\")", "checkType": "IF", "followUpCheckExpressionStart": 1221, "followUpCheckExpressionEnd": 1239, "followUpCheckBlockStart": 1221, "followUpCheckBlockEnd": 1249, "use": ["stringTokenizer.nextToken()", "fromString(nextToken,*)", "addSearch(nextToken,List)", "stringTokenizer.nextToken()", "addSearch(nextToken,List)", "stringTokenizer.nextToken()", "addSearch(nextToken,List)", "stringTokenizer.nextToken()", "addServer(nextToken,List)"], "useStart": [839, 911, 1068, 1195, 1260, 1432, 1497, 1669, 1734], "useEnd": [853, 935, 1089, 1209, 1281, 1446, 1518, 1683, 1755], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1968, "finallyExpressionEnd": 1976, "finallyBlockStart": 1968, "finallyBlockEnd": 2055, "cleanUpCallStart": [1998], "cleanUpCallEnd": [2008], "url": "https://github.com/lemmy/dnsjava/tree/master/tags/dnsjava-1-5-2-pre/org/xbill/DNS/FindServer.java", "rawCode": "  /** Parses the output of winipcfg or ipconfig. */\n  private static void findWin(InputStream in) {\n    BufferedReader br = new BufferedReader(new InputStreamReader(in));\n    try {\n      List lserver = new ArrayList();\n      List lsearch = new ArrayList();\n      String line = null;\n      boolean readingServers = false;\n      boolean readingSearches = false;\n      while ((line = br.readLine()) != null) {\n        StringTokenizer st = new StringTokenizer(line);\n        if (!st.hasMoreTokens()) {\n          readingServers = false;\n          readingSearches = false;\n          continue;\n        }\n        String s = st.nextToken();\n        if (line.indexOf(\":\") != -1) {\n          readingServers = false;\n          readingSearches = false;\n        }\n\n        if (line.indexOf(\"Host Name\") != -1) {\n          while (st.hasMoreTokens()) s = st.nextToken();\n          Name name;\n          try {\n            name = Name.fromString(s, null);\n          } catch (TextParseException e) {\n            continue;\n          }\n          if (name.labels() == 1) continue;\n          addSearch(s, lsearch);\n        } else if (line.indexOf(\"Primary Dns Suffix\") != -1) {\n          while (st.hasMoreTokens()) s = st.nextToken();\n          if (s.equals(\":\")) continue;\n          addSearch(s, lsearch);\n          readingSearches = true;\n        } else if (readingSearches || line.indexOf(\"DNS Suffix\") != -1) {\n          while (st.hasMoreTokens()) s = st.nextToken();\n          if (s.equals(\":\")) continue;\n          addSearch(s, lsearch);\n          readingSearches = true;\n        } else if (readingServers || line.indexOf(\"DNS Servers\") != -1) {\n          while (st.hasMoreTokens()) s = st.nextToken();\n          if (s.equals(\":\")) continue;\n          addServer(s, lserver);\n          readingServers = true;\n        }\n      }\n\n      if (servers == null && lserver.size() > 0)\n        servers = (String[]) lserver.toArray(new String[lserver.size()]);\n    } catch (IOException e) {\n    } finally {\n      try {\n        br.close();\n      } catch (IOException e) {\n      }\n    }\n    return;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9034, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,*)"], "initializationStart": [319], "initializationEnd": [376], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 384, "guardExpressionEnd": 415, "guardBlockStart": 384, "guardBlockEnd": 883, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 442, "focalAPIEnd": 461, "followUpCheck": "nextToken.startsWith(\"extension=\")", "checkType": "IF", "followUpCheckExpressionStart": 543, "followUpCheckExpressionEnd": 579, "followUpCheckBlockStart": 543, "followUpCheckBlockEnd": 740, "use": ["nextToken.substring(String)", "Map<String, String>.put(String,nextToken)", "List<String>.add(nextToken)"], "useStart": [624, 693, 833], "useEnd": [663, 729, 864], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spring-projects/eclipse-integration-commons/tree/master/org.springsource.ide.eclipse.commons.configurator/src/org/springsource/ide/eclipse/commons/internal/configurator/Configurator.java", "rawCode": "  public void executePendingRequests() {\n    String configureTargets =\n        Activator.getDefault().getPreferenceStore().getString(Activator.PROPERTY_CONFIGURE_TARGETS);\n    List<String> newConfigureTargets = new ArrayList<String>();\n    if (StringUtils.hasLength(configureTargets)) {\n      StringTokenizer targets = new StringTokenizer(configureTargets, File.pathSeparator);\n      while (targets.hasMoreTokens()) {\n        String target = targets.nextToken();\n        Map<String, String> parameters = new HashMap<String, String>();\n        if (target.startsWith(\"extension=\")) {\n          parameters.put(PARAM_EXTENSION, target.substring(\"extension=\".length()));\n        } else {\n          parameters.put(PARAM_TARGET, target);\n        }\n        IStatus status = execute(parameters, true);\n        if (!status.isOK()) {\n          newConfigureTargets.add(target);\n        }\n      }\n    }\n    Activator.getDefault()\n        .getPreferenceStore()\n        .setValue(\n            Activator.PROPERTY_CONFIGURE_TARGETS,\n            StringUtils.collectionToDelimitedString(newConfigureTargets, File.pathSeparator));\n  }\n"}, {"dataset": "nextToken", "exampleID": 9035, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [211], "initializationEnd": [249], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["stringTokenizer.countTokens()"], "configurationStart": [299], "configurationEnd": [315], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 322, "guardExpressionEnd": 348, "guardBlockStart": 322, "guardBlockEnd": 384, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 361, "focalAPIEnd": 375, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["nextToken.trim()"], "useStart": [361], "useEnd": [382], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/gmf.notation/tree/master/org.eclipse.gmf.runtime.notation/src/org/eclipse/gmf/runtime/notation/impl/NotationFactoryImpl.java", "rawCode": "  /**\n   *\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   *\n   * @generated NOT\n   */\n  public List createFilterKeyListFromString(EDataType eDataType, String initialValue) {\n    StringTokenizer st = new StringTokenizer(initialValue, \",\"); // $NON-NLS-1$\n    List newList = new ArrayList(st.countTokens());\n    while (st.hasMoreTokens()) newList.add(st.nextToken().trim());\n    return newList;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9036, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [1605], "initializationEnd": [1632], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 1639, "guardExpressionEnd": 1672, "guardBlockStart": 1639, "guardBlockEnd": 3576, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1689, "focalAPIEnd": 1710, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new FieldSpec(nextToken)", "Vector<Serializable>.add(nextToken)", "Vector<Serializable>.add(nextToken)"], "useStart": [1739, 2998, 3523], "useEnd": [1759, 3014, 3539], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jponge/izpack-full-svn-history-copy/tree/master/izpack-src/tags/4.3.0/src/lib/com/izforge/izpack/panels/RuleInputField.java", "rawCode": "  /**\n   * Creates the items that make up this field. Both separators and input fields are considered\n   * items. The items created are stored in <code>items</code>. In addition, all fields are stored\n   * in <code>inputFields</code>.\n   *\n   * @param format a string that specifies the layout of the input fields and separators.\n   */\n  /*--------------------------------------------------------------------------*/\n  /*\n   * $ @design\n   *\n   * I used a simple StringTokenizer to break the format string into individual tokens. The\n   * approach in building up the field is to consider each token a potential definition for an\n   * input field. Therefore I attempt to create an instance of FieldSpec from each token.\n   * FieldSpec analyzes the token and if it does not represent a valid specification for an input\n   * field throws an exception. If I catch an exception, I know the token does not represent a\n   * valid field specification. In this case I treat the token as a separator, even though this\n   * might not be what the user had intended. However, this approach allows me to implement robust\n   * behavior (no exception thrown) even though the user might have made a mistake in the\n   * definition. The mistake should become immediately obvious when testing the code, since a\n   * input field definition would show up as separator between two fields.\n   * --------------------------------------------------------------------------\n   */\n  private void createItems(String format) {\n    Object item;\n    JTextField field;\n    String token;\n    FieldSpec spec;\n    StringTokenizer tokenizer = new StringTokenizer(format);\n\n    while (tokenizer.hasMoreTokens()) {\n      token = tokenizer.nextToken();\n      try {\n        spec = new FieldSpec(token);\n        field =\n            new RuleTextField(\n                spec.getColumns(),\n                spec.getEditLength(),\n                spec.getType(),\n                spec.getUnlimitedEdit(),\n                toolkit);\n\n        // ------------------------------------------------\n        // if the previous item is also a field, insert a\n        // space as separator\n        // ------------------------------------------------\n        if (items.size() > 0) {\n          item = items.lastElement();\n\n          if (item instanceof JTextField) {\n            items.add(\" \");\n          }\n        }\n\n        items.add(field);\n        inputFields.add(field);\n        field.addFocusListener(this);\n        field.addKeyListener(this);\n        field.addCaretListener(this);\n      }\n      // --------------------------------------------------\n      // if we were not successful creating an input field,\n      // the token must be a separator or the definition\n      // has an error. Simply insert it as separator,\n      // when testing the installer the error should become\n      // obvious to the developer.\n      // --------------------------------------------------\n      catch (Throwable exception) {\n        if (items.size() == 0) {\n          items.add(token);\n        } else {\n          item = items.lastElement();\n\n          // ----------------------------------------------\n          // if the previous item is also a separator,\n          // simply concatenate the token with a space\n          // inserted in between, don't add it as new\n          // separator.\n          // ----------------------------------------------\n          if (item instanceof String) {\n            items.setElementAt(item + \" \" + token, (items.size() - 1));\n          } else {\n            items.add(token);\n          }\n        }\n      }\n    }\n\n    // ----------------------------------------------------\n    // add the fields and separators to the component\n    // ----------------------------------------------------\n    for (int i = 0; i < items.size(); i++) {\n      item = items.elementAt(i);\n\n      if (item instanceof String) {\n        add(new JLabel((String) item));\n      } else {\n        add((JTextField) item);\n      }\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9037, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [223], "initializationEnd": [255], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 261, "guardExpressionEnd": 287, "guardBlockStart": 261, "guardBlockEnd": 581, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 317, "focalAPIEnd": 331, "followUpCheck": "nextToken.equals(\"userpassword\")", "checkType": "IF", "followUpCheckExpressionStart": 436, "followUpCheckExpressionEnd": 469, "followUpCheckBlockStart": 436, "followUpCheckBlockEnd": 497, "use": ["Set<String>.add(nextToken)"], "useStart": [547], "useEnd": [574], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinhrobbins/FlashCards_App/tree/master/FlashCards_WebServices/src/main/java/org/robbins/flashcards/webservices/base/AbstractResource.java", "rawCode": "  protected Set<String> getFieldsAsSet(final String fields) {\n\n    if (StringUtils.isEmpty(fields)) {\n      return null;\n    }\n\n    final Set<String> filterProperties = new HashSet<String>();\n    final StringTokenizer st = new StringTokenizer(fields, \",\");\n    while (st.hasMoreTokens()) {\n      final String field = st.nextToken();\n\n      // never allow 'userpassword' to be passed even if it was\n      // specifically requested\n      if (field.equals(\"userpassword\")) {\n        continue;\n      }\n\n      // add the field to the Set<String>\n      filterProperties.add(field);\n    }\n    return filterProperties;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9038, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [3493], "initializationEnd": [3524], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 3639, "guardExpressionEnd": 3672, "guardBlockStart": 3639, "guardBlockEnd": 4172, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 3695, "focalAPIEnd": 3716, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PoliticalArea(nextToken)", "Vector.addElement(nextToken)"], "useStart": [3751, 3935], "useEnd": [3781, 3969], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/halset/openmap/tree/master/src/main/java/com/bbn/openmap/layer/shape/areas/AreaHandler.java", "rawCode": "  /**\n   * Go through the properties, loading the shapefile, information file and attributes files, and\n   * resolve how everything should be drawn. Might take awhile if the files are large. Called from\n   * getRectangle, which is called when the AreaShapeLayer is added to the map.\n   *\n   * @param prefix property file entry header name\n   * @param props the properties to look through.\n   */\n  public void initialize(String prefix, Properties props) {\n\n    if (props == null) {\n      Debug.error(\n          \"AreaHandler: initialize received bad input:\\n\\tprefix: \"\n              + prefix\n              + \"\\n\\tproperties: \"\n              + (props == null ? \"null\" : \"OK\"));\n      politicalAreas = null;\n      return;\n    }\n\n    prefix = PropUtils.getScopedPropertyPrefix(prefix);\n\n    politicalAreas = new Hashtable();\n\n    // OK, Get the graphics. We are not expecting that all the\n    // graphics in the file are not too much to handle. Also, we\n    // test for the serialized graphics file first, and if it\n    // isn't designated, then look for a shapefile and spatial\n    // index file to create an OMGraphicsList.\n    String cacheFile = props.getProperty(prefix + CacheFileProperty);\n\n    // First find the resource, if not, then try as a file-URL...\n    try {\n      cacheURL = PropUtils.getResourceOrFileOrURL(this, cacheFile);\n\n      if (cacheURL != null) {\n        omgraphics = readCachedGraphics(cacheURL);\n      } else {\n        // We'll use the spatial index set from the\n        // ShapeLayer.\n\n        // Now, get the attribute file\n        String dbfFile = props.getProperty(prefix + dbfFileProperty);\n        URL dbfFileURL = null;\n        if (dbfFile != null) {\n          dbfFileURL = PropUtils.getResourceOrFileOrURL(this, dbfFile);\n        }\n        if (dbfFileURL != null) {\n          InputStream is = dbfFileURL.openStream();\n          dbfModel = new DbfTableModel(new DbfInputStream(is));\n        }\n        if (dbfModel == null) {\n          String csvFile = props.getProperty(prefix + csvFileProperty);\n          URL infofileURL = null;\n          if (csvFile != null) {\n            infofileURL = PropUtils.getResourceOrFileOrURL(this, csvFile);\n          }\n\n          // Read them in.\n          if (infofileURL != null) {\n            infoFile = new CSVShapeInfoFile(csvFile);\n            infoFile.setHeadersExist(\n                PropUtils.booleanFromProperties(props, prefix + csvHeaderProperty, true));\n            infoFile.loadData(true);\n          }\n        }\n      }\n    } catch (java.net.MalformedURLException murle) {\n      omgraphics = new OMGraphicList();\n    } catch (java.io.IOException ioe) {\n      omgraphics = new OMGraphicList();\n    } catch (Exception exc) {\n      omgraphics = new OMGraphicList();\n    }\n\n    // This is handled properly yet. The PoliticalArea should be\n    // updated to handle URLs for area points, and have different\n    // icons for different areas.\n    // String defaultPointImageURLString =\n    // props.getProperty(prefix + pointImageURLProperty);\n\n    // Now, match the attributes to the graphics. Find the\n    // indexes of the name and the search key. Also figure out\n    // which areas have special coloring needs.\n    keyIndex = PropUtils.intFromProperties(props, prefix + keyIndexProperty, keyIndex);\n    nameIndex = PropUtils.intFromProperties(props, prefix + nameIndexProperty, nameIndex);\n    String areas = props.getProperty(prefix + areasProperty);\n\n    if (areas == null) areas = \"\";\n\n    StringTokenizer tokenizer = new StringTokenizer(areas, \" \");\n    // All this uses the properties to set the individual colors\n    // of any area\n    String currentArea;\n\n    while (tokenizer.hasMoreTokens()) {\n      currentArea = tokenizer.nextToken();\n\n      PoliticalArea newParams = new PoliticalArea(currentArea);\n\n      if (Debug.debugging(\"areas\")) {\n        Debug.output(\"AreaHandler: setting SPECIALIZED attributes for \\\"\" + newParams.id + \"\\\"\");\n      }\n\n      areasItems.addElement(currentArea);\n\n      newParams.drawingAttributes =\n          new DrawingAttributes(prefix + areasProperty + \".\" + currentArea, props);\n\n      politicalAreas.put(newParams.id.toUpperCase().intern(), newParams);\n    }\n\n    if (Debug.debugging(\"areas\")) {\n      Debug.output(\"AreaHandler: finished initialization\");\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9039, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [218], "initializationEnd": [248], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new RuntimeException(String)"], "tryExpressionStart": 257, "tryExpressionEnd": 261, "tryBlockStart": 257, "tryBlockEnd": 561, "catchExpressionStart": 465, "catchExpressionEnd": 485, "catchBlockStart": 465, "catchBlockEnd": 561, "exceptionHandlingCallStart": [501], "exceptionHandlingCallEnd": [552], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 299, "focalAPIEnd": 314, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["map(nextToken)", "stringTokenizer.nextToken()", "map(nextToken)"], "useStart": [295, 390, 386], "useEnd": [315, 405, 406], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/agilebirds/openflexo/tree/master/flexodesktop/externalmodels/flexocrazybean/src/main/java/cb/generator/Factory.java", "rawCode": "  protected Dimension getCardinality(Role role) {\n    int from = 1, to = 1;\n\n    if (role.getClientCardinality() != null) {\n      String card = role.getClientCardinality().getStringValue();\n      StringTokenizer tok = new StringTokenizer(card, \".\");\n\n      try {\n        from = Integer.parseInt(map(tok.nextToken()));\n\n        if (tok.hasMoreTokens()) {\n          to = Integer.parseInt(map(tok.nextToken()));\n        } else {\n          to = from;\n        }\n      } catch (Exception e) {\n        throw new RuntimeException(\"Invalid cardinality \" + card);\n      }\n    } else {\n      Role other = role.getOtherRole();\n\n      if (other.isAggregate()) {\n        from = 0;\n        to = Integer.MAX_VALUE;\n      }\n    }\n\n    return new Dimension(from, to);\n  }\n"}, {"dataset": "nextToken", "exampleID": 9040, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String,boolean)"], "initializationStart": [1611], "initializationEnd": [1658], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["e(*,String)"], "tryExpressionStart": 1220, "tryExpressionEnd": 1224, "tryBlockStart": 1220, "tryBlockEnd": 1433, "catchExpressionStart": 1993, "catchExpressionEnd": 2013, "catchBlockStart": 1993, "catchBlockEnd": 2105, "exceptionHandlingCallStart": [2025], "exceptionHandlingCallEnd": [2094], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "IF {", "guardExpressionStart": 1781, "guardExpressionEnd": 1808, "guardBlockStart": 1781, "guardBlockEnd": 2113, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1861, "focalAPIEnd": 1879, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["base64Decode(nextToken)", "stringTokenizer.nextToken()", "base64Decode(nextToken)", "stringTokenizer.nextToken()", "base64Decode(nextToken)", "stringTokenizer.nextToken()", "base64Decode(nextToken)"], "useStart": [1840, 2217, 2196, 2345, 2324, 2474, 2453], "useEnd": [1880, 2235, 2236, 2363, 2364, 2492, 2493], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jca02266/k9mail/tree/master/src/com/fsck/k9/activity/MessageCompose.java", "rawCode": "  /**\n   * Parse an identity string. Handles both legacy and new (!) style identities.\n   *\n   * @param identityString\n   * @return\n   */\n  private Map<IdentityField, String> parseIdentityHeader(final String identityString) {\n    Map<IdentityField, String> identity = new HashMap<IdentityField, String>();\n\n    if (K9.DEBUG) Log.d(K9.LOG_TAG, \"Decoding identity: \" + identityString);\n\n    if (identityString == null || identityString.length() < 1) {\n      return identity;\n    }\n\n    if (identityString.charAt(0) == '!' && identityString.length() > 2) {\n      Uri.Builder builder = new Uri.Builder();\n      builder.encodedQuery(identityString.substring(1)); // Need to cut off the ! at the beginning.\n      Uri uri = builder.build();\n      for (IdentityField key : IdentityField.values()) {\n        String value = uri.getQueryParameter(key.value());\n        if (value != null) {\n          identity.put(key, value);\n        }\n      }\n\n      if (K9.DEBUG) Log.d(K9.LOG_TAG, \"Decoded identity: \" + identity.toString());\n\n      // Sanity check our Integers so that recipients of this result don't have to.\n      for (IdentityField key : IdentityField.getIntegerFields()) {\n        if (identity.get(key) != null) {\n          try {\n            Integer.parseInt(identity.get(key));\n          } catch (NumberFormatException e) {\n            Log.e(K9.LOG_TAG, \"Invalid \" + key.name() + \" field in identity: \" + identity.get(key));\n          }\n        }\n      }\n    } else {\n      // Legacy identity\n\n      if (K9.DEBUG) Log.d(K9.LOG_TAG, \"Got a saved legacy identity: \" + identityString);\n      StringTokenizer tokens = new StringTokenizer(identityString, \":\", false);\n\n      // First item is the body length. We use this to separate the composed reply from the quoted\n      // text.\n      if (tokens.hasMoreTokens()) {\n        String bodyLengthS = Utility.base64Decode(tokens.nextToken());\n        try {\n          identity.put(IdentityField.LENGTH, Integer.valueOf(bodyLengthS).toString());\n        } catch (Exception e) {\n          Log.e(K9.LOG_TAG, \"Unable to parse bodyLength '\" + bodyLengthS + \"'\");\n        }\n      }\n      if (tokens.hasMoreTokens()) {\n        identity.put(IdentityField.SIGNATURE, Utility.base64Decode(tokens.nextToken()));\n      }\n      if (tokens.hasMoreTokens()) {\n        identity.put(IdentityField.NAME, Utility.base64Decode(tokens.nextToken()));\n      }\n      if (tokens.hasMoreTokens()) {\n        identity.put(IdentityField.EMAIL, Utility.base64Decode(tokens.nextToken()));\n      }\n    }\n\n    return identity;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9041, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [263], "initializationEnd": [298], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreElements()", "guardType": "LOOP {", "guardExpressionStart": 304, "guardExpressionEnd": 332, "guardBlockStart": 304, "guardBlockEnd": 660, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 349, "focalAPIEnd": 363, "followUpCheck": "(line.length() + nextToken.length()) < 79", "checkType": "IF", "followUpCheckExpressionStart": 371, "followUpCheckExpressionEnd": 413, "followUpCheckBlockStart": 371, "followUpCheckBlockEnd": 654, "use": ["StringBuffer.append(nextToken)", "StringBuffer.append(nextToken)"], "useStart": [483, 612], "useEnd": [501, 630], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bruceMacLeod/motech-server-pillreminder-0.18/tree/master/tools/SMPPSim/src/java/com/seleniumsoftware/SMPPSim/util/LoggingUtilities.java", "rawCode": "  public static void logDecodedPdu(Pdu p) {\n    // Split into max 80 character lines around comma delimited boundaries\n    int i = 0;\n    String pdustring = p.toString();\n    StringBuffer line = new StringBuffer();\n    String token = \"\";\n    StringTokenizer st = new StringTokenizer(pdustring, \",\");\n    while (st.hasMoreElements()) {\n      token = st.nextToken();\n      if ((line.length() + token.length()) < 79) {\n        if (i > 0) {\n          line.append(\",\");\n        }\n        line.append(token);\n        i++;\n      } else {\n        logger.info(line.toString());\n        line = new StringBuffer();\n        line.append(token);\n        i = 1;\n      }\n    }\n    if (line.length() > 0) logger.info(line.toString());\n  }\n"}, {"dataset": "nextToken", "exampleID": 9042, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*,String)"], "initializationStart": [260], "initializationEnd": [350], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["stringTokenizer.countTokens()"], "configurationStart": [396], "configurationEnd": [412], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 519, "focalAPIEnd": 533, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["StringBuffer.append(nextToken)", "StringBuffer.append(nextToken)"], "useStart": [577, 653], "useEnd": [593, 669], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TMSWhite/Dialogix2007/tree/master/Dialogix6/src/share/org/dianexus/triceps/TricepsEngine.java", "rawCode": "  /** Show name and step# of current state within schedule */\n  /*public*/ String getScheduleStatus() {\n    if (schedule == null || schedule == Schedule.NULL) {\n      return \" null\";\n    } else {\n      String token = null;\n      StringTokenizer st =\n          new StringTokenizer(\n              schedule.getReserved(Schedule.SCHEDULE_SOURCE), \"/\\\\:\"); // for *n*x, DOS, and Mac\n      int count = st.countTokens();\n      StringBuffer sb = new StringBuffer(\" \");\n\n      for (int i = 1; i <= count; ++i) {\n        token = st.nextToken();\n        if (i == (count - 3)) {\n          sb.append(token).append(\"/\");\n        }\n        if (i == count) {\n          sb.append(token);\n        }\n      }\n      sb.append(\"(\").append(schedule.getReserved(Schedule.STARTING_STEP)).append(\")\");\n      return sb.toString();\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9043, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [504], "initializationEnd": [529], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 303, "tryExpressionEnd": 307, "tryBlockStart": 303, "tryBlockEnd": 991, "catchExpressionStart": 838, "catchExpressionEnd": 860, "catchBlockStart": 838, "catchBlockEnd": 949, "exceptionHandlingCallStart": [872], "exceptionHandlingCallEnd": [919], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 568, "guardExpressionEnd": 594, "guardBlockStart": 568, "guardBlockEnd": 814, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 618, "focalAPIEnd": 632, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["nextToken.length()"], "useStart": [704], "useEnd": [717], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 950, "finallyExpressionEnd": 958, "finallyBlockStart": 950, "finallyBlockEnd": 991, "cleanUpCallStart": [970], "cleanUpCallEnd": [980], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop_src/hadoop-2.0.5-alpha-src/hadoop-mapreduce-project/hadoop-mapreduce-examples/src/test/java/org/apache/hadoop/examples/TestWordStats.java", "rawCode": "    public double read(String path) throws IOException {\n      FileSystem fs = FileSystem.get(new Configuration());\n      FileStatus[] files = fs.listStatus(new Path(path));\n\n      for (FileStatus fileStat : files) {\n        if (!fileStat.isFile()) continue;\n\n        BufferedReader br = null;\n\n        try {\n          br = new BufferedReader(new InputStreamReader(fs.open(fileStat.getPath())));\n\n          String line;\n          while ((line = br.readLine()) != null) {\n            StringTokenizer st = new StringTokenizer(line);\n            String word;\n            while (st.hasMoreTokens()) {\n              word = st.nextToken();\n              this.wordsRead++;\n              this.wordLengthsRead += word.length();\n              this.wordLengthsReadSquared += (long) Math.pow(word.length(), 2.0);\n            }\n          }\n\n        } catch (IOException e) {\n          System.out.println(\"Output could not be read!\");\n          throw e;\n        } finally {\n          br.close();\n        }\n      }\n\n      double mean = (((double) this.wordLengthsRead) / ((double) this.wordsRead));\n      mean = Math.pow(mean, 2.0);\n      double term = (((double) this.wordLengthsReadSquared / ((double) this.wordsRead)));\n      double stddev = Math.sqrt((term - mean));\n      return stddev;\n    }\n"}, {"dataset": "nextToken", "exampleID": 9044, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,*)"], "initializationStart": [957], "initializationEnd": [1012], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 1020, "guardExpressionEnd": 1055, "guardBlockStart": 1020, "guardBlockEnd": 1119, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1086, "focalAPIEnd": 1109, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(nextToken)", "stringTokenizer.nextToken()", "add(nextToken)", "stringTokenizer.nextToken()", "add(nextToken)", "stringTokenizer.nextToken()", "add(nextToken)"], "useStart": [1066, 1977, 1957, 2636, 2616, 3255, 3235], "useEnd": [1110, 2000, 2001, 2659, 2660, 3278, 3279], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/activemq/tree/master/activemq-console/src/main/java/org/apache/activemq/console/command/QueryCommand.java", "rawCode": "  /**\n   * Handle the -Q, -xQ, --objname, --xobjname, --view --invoke options.\n   *\n   * @param token - option token to handle\n   * @param tokens - succeeding command arguments\n   * @throws Exception\n   */\n  protected void handleOption(String token, List<String> tokens) throws Exception {\n    // If token is a additive predefined query define option\n    if (token.startsWith(\"-Q\")) {\n      String key = token.substring(2);\n      String value = \"\";\n      int pos = key.indexOf(\"=\");\n      if (pos >= 0) {\n        value = key.substring(pos + 1);\n        key = key.substring(0, pos);\n      }\n\n      // If additive query\n      String predefQuery = PREDEFINED_OBJNAME_QUERY.getProperty(key);\n      if (predefQuery == null) {\n        context.printException(new IllegalArgumentException(\"Unknown query object type: \" + key));\n        return;\n      }\n      String queryStr = JmxMBeansUtil.createQueryString(predefQuery, value);\n      StringTokenizer queryTokens = new StringTokenizer(queryStr, COMMAND_OPTION_DELIMETER);\n      while (queryTokens.hasMoreTokens()) {\n        queryAddObjects.add(queryTokens.nextToken());\n      }\n      normaliseObjectName(queryAddObjects);\n    } else if (token.startsWith(\"-xQ\")) {\n      // If token is a substractive predefined query define option\n      String key = token.substring(3);\n      String value = \"\";\n      int pos = key.indexOf(\"=\");\n      if (pos >= 0) {\n        value = key.substring(pos + 1);\n        key = key.substring(0, pos);\n      }\n\n      // If subtractive query\n      String predefQuery = PREDEFINED_OBJNAME_QUERY.getProperty(key);\n      if (predefQuery == null) {\n        context.printException(new IllegalArgumentException(\"Unknown query object type: \" + key));\n        return;\n      }\n      String queryStr = JmxMBeansUtil.createQueryString(predefQuery, value);\n      StringTokenizer queryTokens = new StringTokenizer(queryStr, COMMAND_OPTION_DELIMETER);\n      while (queryTokens.hasMoreTokens()) {\n        querySubObjects.add(queryTokens.nextToken());\n      }\n      normaliseObjectName(querySubObjects);\n    } else if (token.startsWith(\"--objname\")) {\n      // If token is an additive object name query option\n\n      // If no object name query is specified, or next token is a new\n      // option\n      if (tokens.isEmpty() || ((String) tokens.get(0)).startsWith(\"-\")) {\n        context.printException(new IllegalArgumentException(\"Object name query not specified\"));\n        return;\n      }\n\n      StringTokenizer queryTokens =\n          new StringTokenizer((String) tokens.remove(0), COMMAND_OPTION_DELIMETER);\n      while (queryTokens.hasMoreTokens()) {\n        queryAddObjects.add(queryTokens.nextToken());\n      }\n    } else if (token.startsWith(\"--xobjname\")) {\n      // If token is a substractive object name query option\n\n      // If no object name query is specified, or next token is a new\n      // option\n      if (tokens.isEmpty() || ((String) tokens.get(0)).startsWith(\"-\")) {\n        context.printException(new IllegalArgumentException(\"Object name query not specified\"));\n        return;\n      }\n\n      StringTokenizer queryTokens =\n          new StringTokenizer((String) tokens.remove(0), COMMAND_OPTION_DELIMETER);\n      while (queryTokens.hasMoreTokens()) {\n        querySubObjects.add(queryTokens.nextToken());\n      }\n    } else if (token.startsWith(\"--view\")) {\n      // If token is a view option\n\n      // If no view specified, or next token is a new option\n      if (tokens.isEmpty() || ((String) tokens.get(0)).startsWith(\"-\")) {\n        context.printException(new IllegalArgumentException(\"Attributes to view not specified\"));\n        return;\n      }\n\n      // Add the attributes to view\n      Enumeration viewTokens =\n          new StringTokenizer((String) tokens.remove(0), COMMAND_OPTION_DELIMETER);\n      while (viewTokens.hasMoreElements()) {\n        queryViews.add(viewTokens.nextElement());\n      }\n    } else if (token.startsWith(\"--invoke\")) {\n\n      if (tokens.isEmpty() || ((String) tokens.get(0)).startsWith(\"-\")) {\n        context.printException(\n            new IllegalArgumentException(\"operation to invoke is not specified\"));\n        return;\n      }\n\n      // add op and params\n      Enumeration viewTokens =\n          new StringTokenizer((String) tokens.remove(0), COMMAND_OPTION_DELIMETER);\n      while (viewTokens.hasMoreElements()) {\n        opAndParams.add((String) viewTokens.nextElement());\n      }\n\n    } else {\n      // Let super class handle unknown option\n      super.handleOption(token, tokens);\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9045, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [807], "initializationEnd": [844], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 850, "guardExpressionEnd": 884, "guardBlockStart": 850, "guardBlockEnd": 1347, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 917, "focalAPIEnd": 939, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new StringTokenizer(nextToken,String)"], "useStart": [980], "useEnd": [1020], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/statsbiblioteket/wowza-modules/tree/master/wowza-common/src/main/java/dk/statsbiblioteket/medieplatform/wowza/plugin/utilities/StringAndTextUtil.java", "rawCode": "  /**\n   * Given a query string, return the value for a given key. Throws exception if key is not set.\n   *\n   * @param key The key to look up in query string.\n   * @param queryString The query string to read key from.\n   * @return The value of the given key.\n   * @throws IllegallyFormattedQueryStringException If key is not set in query string, or if query\n   *     string has bad format.\n   */\n  public static String extractValueFromQueryStringAndKey(String key, String queryString)\n      throws IllegallyFormattedQueryStringException {\n    if (queryString == null) {\n      queryString = \"\";\n    }\n    // Some players add a / to the query string. Strip it\n    if (queryString.endsWith(\"/\")) {\n      queryString = queryString.substring(0, queryString.length() - 1);\n    }\n    StringTokenizer queryItems = new StringTokenizer(queryString, \"&\");\n    while (queryItems.hasMoreTokens()) {\n      String queryParameter = queryItems.nextToken();\n      StringTokenizer paramTokenizer = new StringTokenizer(queryParameter, \"=\");\n      if (paramTokenizer.countTokens() != 2) {\n        // parameters not of the form a=b are ignored\n        continue;\n      }\n      String currentKey = paramTokenizer.nextToken();\n      String currentValue = paramTokenizer.nextToken();\n      if (currentKey.equalsIgnoreCase(key)) {\n        return currentValue;\n      }\n    }\n    throw new IllegallyFormattedQueryStringException(\n        \"Expected key '\" + key + \"' not found in query string\" + queryString + \"'\");\n  }\n"}, {"dataset": "nextToken", "exampleID": 9046, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [135], "initializationEnd": [162], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 170, "guardExpressionEnd": 196, "guardBlockStart": 170, "guardBlockEnd": 483, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 222, "focalAPIEnd": 236, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["nextToken.indexOf(char)", "set(nextToken)", "nextToken.substring(int,int)", "nextToken.substring(*)"], "useStart": [258, 303, 356, 408], "useEnd": [276, 313, 381, 434], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/evgs/BombusLime/tree/master/src/org/xbill/DNS/Options.java", "rawCode": "  public static void refresh() {\n    String s = System.getProperty(\"dnsjava.options\");\n    if (s != null) {\n      StringTokenizer st = new StringTokenizer(s, \",\");\n      while (st.hasMoreTokens()) {\n        String token = st.nextToken();\n        int index = token.indexOf('=');\n        if (index == -1) set(token);\n        else {\n          String option = token.substring(0, index);\n          String value = token.substring(index + 1);\n          set(option, value);\n        }\n      }\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9047, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [421], "initializationEnd": [458], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 464, "guardExpressionEnd": 497, "guardBlockStart": 464, "guardBlockEnd": 578, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 527, "focalAPIEnd": 548, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ArrayList<String>.add(nextToken)"], "useStart": [556], "useEnd": [571], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/OSEHRA/Blue-Button-Document-Adapter/tree/master/integration/integration-regex/src/main/java/org/osehra/das/common/string/StringUtil.java", "rawCode": "  /**\n   * Returns an array parsed from inStr by the specified delimiter.\n   *\n   * @param inStr - The string to be parsed.\n   * @param delimeter - The delimeter to use for parsing.\n   * @return String[] - array from the parsed Strings\n   */\n  public static String[] makeArray(final String inStr, final String delimeter) {\n    final ArrayList<String> list = new ArrayList<String>();\n    final StringTokenizer tokenizer = new StringTokenizer(inStr, delimeter);\n    while (tokenizer.hasMoreTokens()) {\n      final String token = tokenizer.nextToken();\n      list.add(token);\n    }\n    final String[] result = new String[list.size()];\n    final Iterator<String> ci = list.iterator();\n    for (int i = 0; (i < result.length) && ci.hasNext(); i++) {\n      result[i] = ci.next();\n    }\n    return result;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9048, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [1198], "initializationEnd": [1226], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 1239, "guardExpressionEnd": 1265, "guardBlockStart": 1239, "guardBlockEnd": 1755, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1297, "focalAPIEnd": 1311, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()", "put(nextToken,*)"], "useStart": [1426, 1683], "useEnd": [1440, 1742], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1799, "finallyExpressionEnd": 1807, "finallyBlockStart": 1799, "finallyBlockEnd": 1873, "cleanUpCallStart": [1844], "cleanUpCallEnd": [1866], "url": "https://github.com/schmeedy/gmf/tree/master/org.eclipse.gmf.runtime/archive/org.eclipse.gmf.runtime.emf.core.compatibility/src/org/eclipse/gmf/runtime/emf/core/internal/domain/MSLEditingDomain.java", "rawCode": "  /**\n   * @see\n   *     org.eclipse.gmf.runtime.emf.core.edit.MEditingDomain#getSchemaToLocationMap(org.eclipse.emf.common.util.URI)\n   */\n  public Map getSchemaToLocationMap(InputStream inputStream) throws IOException {\n\n    Map requiredLocations = new HashMap();\n\n    // create a buffer reader using the stream we just created\n    BufferedReader bufferedReader = null;\n\n    try {\n\n      bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n\n      String line;\n      int indexOfSchemasLocations = -1;\n\n      // read the file line by line\n      while ((line = bufferedReader.readLine()) != null) {\n\n        // try to find the schema's location line\n        indexOfSchemasLocations =\n            line.indexOf(XMLResource.XSI_NS + \":\" + XMLResource.SCHEMA_LOCATION); // $NON-NLS-1$\n\n        if (indexOfSchemasLocations != -1) {\n\n          int schemaStart = line.indexOf(\"\\\"\", indexOfSchemasLocations + 1); // $NON-NLS-1$\n\n          int schemaEnd = line.indexOf(\"\\\"\", schemaStart + 1); // $NON-NLS-1$\n\n          String schemas = line.substring(schemaStart + 1, schemaEnd);\n\n          // trimming the white spaces\n          schemas = schemas.trim();\n          StringTokenizer st = new StringTokenizer(schemas);\n\n          while (st.hasMoreTokens()) {\n\n            String schema = st.nextToken();\n            String requiredLocation = \"\"; // $NON-NLS-1$\n\n            if (st.hasMoreTokens()) requiredLocation = st.nextToken();\n\n            int hashLocation = requiredLocation.indexOf(\"#\"); // $NON-NLS-1$\n\n            if (hashLocation != -1) requiredLocation = requiredLocation.substring(0, hashLocation);\n\n            if (requiredLocation.length() > 0)\n              requiredLocations.put(schema, URI.decode(requiredLocation));\n          }\n\n          break;\n        }\n      }\n\n    } finally {\n\n      if (bufferedReader != null) bufferedReader.close();\n    }\n\n    return requiredLocations;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9049, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [398], "initializationEnd": [429], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreElements()", "guardType": "LOOP {", "guardExpressionStart": 438, "guardExpressionEnd": 466, "guardBlockStart": 438, "guardBlockEnd": 546, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 492, "focalAPIEnd": 506, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Set<String>.add(nextToken)"], "useStart": [523], "useEnd": [537], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/prat0318/fop/tree/master/argouml/src/argouml-app/src/org/argouml/profile/init/ProfileLoader.java", "rawCode": "  /**\n   * Resolves the dependencies for a Profile.\n   *\n   * @param attr a group of attributes in the MANIFEST file for this JAR\n   * @return the set of defined profiles\n   */\n  private Set<String> loadManifestDependenciesForProfile(Attributes attr) {\n    Set<String> ret = new HashSet<String>();\n    String value = attr.getValue(\"Depends-on\");\n    if (value != null) {\n      StringTokenizer st = new StringTokenizer(value, \",\");\n\n      while (st.hasMoreElements()) {\n        String entry = st.nextToken().trim();\n        ret.add(entry);\n      }\n    }\n\n    return ret;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9050, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [89], "initializationEnd": [118], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 144, "guardExpressionEnd": 170, "guardBlockStart": 144, "guardBlockEnd": 238, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 189, "focalAPIEnd": 203, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ListBuffer<String>.append(nextToken)"], "useStart": [211], "useEnd": [231], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xymus/staticjni/tree/master/src/share/classes/com/sun/tools/javadoc/Start.java", "rawCode": "  private void addToList(ListBuffer<String> list, String str) {\n    StringTokenizer st = new StringTokenizer(str, \":\");\n    String current;\n    while (st.hasMoreTokens()) {\n      current = st.nextToken();\n      list.append(current);\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9051, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String,boolean)"], "initializationStart": [198], "initializationEnd": [240], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 313, "guardExpressionEnd": 338, "guardBlockStart": 313, "guardBlockEnd": 1655, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 362, "focalAPIEnd": 375, "followUpCheck": "nextToken.length() == 1", "checkType": "IF", "followUpCheckExpressionStart": 383, "followUpCheckExpressionEnd": 407, "followUpCheckBlockStart": 383, "followUpCheckBlockEnd": 1649, "use": ["nextToken.charAt(int)", "stringTokenizer.nextToken()", "process(nextToken)", "process(nextToken)"], "useStart": [427, 703, 1529, 1616], "useEnd": [442, 716, 1543, 1630], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/H2-Mirror/tree/master/h2/src/tools/org/h2/build/indexer/Indexer.java", "rawCode": "  private void readPage(File file) throws Exception {\n    byte[] data = IOUtils.readBytesAndClose(new FileInputStream(file), 0);\n    String text = new String(data, \"UTF-8\");\n    StringTokenizer t = new StringTokenizer(text, \"<> \\r\\n\", true);\n    boolean inTag = false;\n    title = false;\n    heading = false;\n    while (t.hasMoreTokens()) {\n      String token = t.nextToken();\n      if (token.length() == 1) {\n        char c = token.charAt(0);\n        switch (c) {\n          case '<':\n            {\n              if (inTag) {\n                process(\"???\");\n              }\n              inTag = true;\n              if (!t.hasMoreTokens()) {\n                break;\n              }\n              token = t.nextToken();\n              if (token.startsWith(\"/\")) {\n                title = false;\n                heading = false;\n              } else if (token.equalsIgnoreCase(\"title\")) {\n                title = true;\n              } else if (token.length() == 2\n                  && Character.toLowerCase(token.charAt(0)) == 'h'\n                  && Character.isDigit(token.charAt(1))) {\n                heading = true;\n              }\n              // TODO maybe skip script tags?\n              break;\n            }\n          case '>':\n            {\n              if (!inTag) {\n                process(\"???\");\n              }\n              inTag = false;\n              break;\n            }\n          case '\\r':\n          case '\\n':\n          case ' ':\n            break;\n          default:\n            if (!inTag) {\n              process(token);\n            }\n        }\n      } else {\n        if (!inTag) {\n          process(token);\n        }\n      }\n    }\n\n    if (page.title == null || page.title.trim().length() == 0) {\n      System.out.println(\"Error: not title found in \" + file.getName());\n      page.title = file.getName();\n    }\n    page.title = page.title.trim();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9052, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [157], "initializationEnd": [191], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 197, "guardExpressionEnd": 223, "guardBlockStart": 197, "guardBlockEnd": 269, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 247, "focalAPIEnd": 261, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(nextToken)"], "useStart": [232], "useEnd": [262], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stevenhwu/ABI/tree/master/beast-mcmc-srp/src/dr/inference/trace/CnCsPerSiteAnalysis.java", "rawCode": "  private static String[] parseVariableLengthStringArray(String inString) {\n\n    List<String> returnList = new ArrayList<String>();\n    StringTokenizer st = new StringTokenizer(inString, \",\");\n    while (st.hasMoreTokens()) {\n      returnList.add(st.nextToken());\n    }\n\n    if (returnList.size() > 0) {\n      String[] stringArray = new String[returnList.size()];\n      stringArray = returnList.toArray(stringArray);\n      return stringArray;\n    }\n    return null;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9053, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [650], "initializationEnd": [680], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 715, "focalAPIEnd": 733, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseFloat(nextToken)", "stringTokenizer.nextToken()", "parseFloat(nextToken)", "stringTokenizer.nextToken()", "parseFloat(nextToken)"], "useStart": [698, 769, 752, 1192, 1175], "useEnd": [734, 787, 788, 1210, 1211], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ProjetX/ProjetX/tree/master/slick/src/org/newdawn/slick/svg/inkscape/Util.java", "rawCode": "  /**\n   * Get a transform defined in the XML\n   *\n   * @param element The element from which the transform should be read\n   * @param attribute The name of the attribute holding the transform\n   * @return The transform to be applied\n   */\n  static Transform getTransform(Element element, String attribute) {\n    String str = element.getAttribute(attribute);\n    if (str == null) {\n      return new Transform();\n    }\n\n    if (str.equals(\"\")) {\n      return new Transform();\n    } else if (str.startsWith(\"translate\")) {\n      str = str.substring(0, str.length() - 1);\n      str = str.substring(\"translate(\".length());\n      StringTokenizer tokens = new StringTokenizer(str, \", \");\n      float x = Float.parseFloat(tokens.nextToken());\n      float y = Float.parseFloat(tokens.nextToken());\n\n      return Transform.createTranslateTransform(x, y);\n    } else if (str.startsWith(\"matrix\")) {\n      float[] pose = new float[6];\n      str = str.substring(0, str.length() - 1);\n      str = str.substring(\"matrix(\".length());\n      StringTokenizer tokens = new StringTokenizer(str, \", \");\n      float[] tr = new float[6];\n      for (int j = 0; j < tr.length; j++) {\n        tr[j] = Float.parseFloat(tokens.nextToken());\n      }\n\n      pose[0] = tr[0];\n      pose[1] = tr[2];\n      pose[2] = tr[4];\n      pose[3] = tr[1];\n      pose[4] = tr[3];\n      pose[5] = tr[5];\n\n      return new Transform(pose);\n    }\n\n    return new Transform();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9054, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*)"], "initializationStart": [163], "initializationEnd": [201], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "IF {", "guardExpressionStart": 207, "guardExpressionEnd": 237, "guardBlockStart": 207, "guardBlockEnd": 382, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 284, "focalAPIEnd": 305, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(nextToken)"], "useStart": [267], "useEnd": [306], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/voxeolabs/moho/tree/master/moho-presence/src/main/java/com/voxeo/moho/presence/sip/impl/Utils.java", "rawCode": "  public static int parseCSeqNumber(String cseqHeader) {\n    int cseq = -1;\n    if (cseqHeader == null) {\n      return cseq;\n    }\n    StringTokenizer cseqToken = new StringTokenizer(cseqHeader.trim());\n    if (cseqToken.hasMoreTokens()) {\n      try {\n        cseq = Integer.parseInt(cseqToken.nextToken());\n      } catch (NumberFormatException e) {\n        cseq = -1;\n      }\n    }\n    return cseq;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9055, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [219], "initializationEnd": [250], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 388, "guardExpressionEnd": 418, "guardBlockStart": 388, "guardBlockEnd": 723, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 441, "focalAPIEnd": 459, "followUpCheck": "nextToken.startsWith(\"@\") && !users.contains(nextToken)", "checkType": "IF", "followUpCheckExpressionStart": 568, "followUpCheckExpressionEnd": 618, "followUpCheckBlockStart": 568, "followUpCheckBlockEnd": 717, "use": ["new Values(TransactionAttempt,String,nextToken)", "HashSet<String>.add(nextToken)"], "useStart": [653, 693], "useEnd": [682, 708], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dougc333/storm/tree/master/storm-test4/src/main/java/test4/demo/bolts/UserSplitterBolt.java", "rawCode": "  @Override\n  public void execute(Tuple input, BasicOutputCollector collector) {\n    String tweet = input.getStringByField(\"tweet\");\n    String tweetId = input.getStringByField(\"tweet_id\");\n    StringTokenizer strTok = new StringTokenizer(tweet, \" \");\n    TransactionAttempt tx = (TransactionAttempt) input.getValueByField(\"txid\");\n    HashSet<String> users = new HashSet<String>();\n\n    while (strTok.hasMoreTokens()) {\n      String user = strTok.nextToken();\n\n      // Ensure that the current word is a user, and that it's not\n      // repeated in this tweet.\n      if (user.startsWith(\"@\") && !users.contains(user)) {\n        collector.emit(\"users\", new Values(tx, tweetId, user));\n        users.add(user);\n      }\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9056, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [463], "initializationEnd": [494], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreElements()", "guardType": "LOOP {", "guardExpressionStart": 500, "guardExpressionEnd": 535, "guardBlockStart": 500, "guardBlockEnd": 1034, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 572, "focalAPIEnd": 593, "followUpCheck": "nextToken.length() > 0", "checkType": "IF", "followUpCheckExpressionStart": 601, "followUpCheckExpressionEnd": 637, "followUpCheckBlockStart": 601, "followUpCheckBlockEnd": 1028, "use": ["nextToken.indexOf(char)", "parseEntry(nextToken,String)", "nextToken.substring(int,int)", "nextToken.substring(*)"], "useStart": [670, 806, 895, 959], "useEnd": [701, 840, 943, 1008], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/faux123/android_frameworks_base/tree/master/core/java/android/net/UrlQuerySanitizer.java", "rawCode": "  /**\n   * Parse a query. A query string is any number of parameter-value clauses separated by any\n   * non-zero number of ampersands. A parameter-value clause is a parameter followed by an equal\n   * sign, followed by a value. If the equal sign is missing, the value is assumed to be the empty\n   * string.\n   *\n   * @param query the query to parse.\n   */\n  public void parseQuery(String query) {\n    clear();\n    // Split by '&'\n    StringTokenizer tokenizer = new StringTokenizer(query, \"&\");\n    while (tokenizer.hasMoreElements()) {\n      String attributeValuePair = tokenizer.nextToken();\n      if (attributeValuePair.length() > 0) {\n        int assignmentIndex = attributeValuePair.indexOf('=');\n        if (assignmentIndex < 0) {\n          // No assignment found, treat as if empty value\n          parseEntry(attributeValuePair, \"\");\n        } else {\n          parseEntry(\n              attributeValuePair.substring(0, assignmentIndex),\n              attributeValuePair.substring(assignmentIndex + 1));\n        }\n      }\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9057, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [658], "initializationEnd": [689], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "IF {", "guardExpressionStart": 787, "guardExpressionEnd": 814, "guardBlockStart": 787, "guardBlockEnd": 852, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 825, "focalAPIEnd": 843, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()"], "useStart": [983], "useEnd": [1001], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/teropa/stem/tree/master/org.eclipse.stem.utility/src/org/eclipse/stem/utility/generators/STEMPolygon.java", "rawCode": "  /** Extract the lat, long data from the data buffer */\n  protected void extractLtLgData() {\n\n    /**\n     * This method creates the XML tags that deal with polygon data and includes the polygon data in\n     * it.\n     *\n     * @param id\n     * @param data\n     * @return\n     */\n    int offset = 0;\n    final int INVALID = -10000000;\n    double lt = INVALID;\n    double lg = INVALID;\n\n    switch (_level) {\n      case DataTypes.LEVEL_0:\n        offset = 2;\n        break;\n\n      case DataTypes.LEVEL_1:\n        offset = 3;\n        break;\n\n      case DataTypes.LEVEL_2:\n        offset = 4;\n        break;\n    }\n\n    // Tokenize\n    StringTokenizer tokens = new StringTokenizer(_data, \",\"); // $NON-NLS-1$\n\n    // Advance the first K-tokens.\n    for (int i = 0; i < offset; i++) {\n      if (tokens.hasMoreTokens()) {\n        tokens.nextToken();\n      }\n    }\n\n    // We are now located at the beginning of the polygon data.\n    while (tokens.hasMoreTokens()) {\n\n      String token = tokens.nextToken();\n\n      if (isNumeric(token) == false) {\n        continue; // Ignore, this is not a valid coordinate.\n      }\n\n      if (lt == INVALID) {\n        lt = getDouble(token);\n      } else if (lg == INVALID) {\n        lg = getDouble(token);\n      }\n\n      if (lt != INVALID && lg != INVALID) {\n        // PointData point = new PointData(toDegrees(lt),\n        // toDegrees(lg));\n        PointData point = new PointData(lt, lg);\n        if (init == null) {\n          init = point;\n        }\n        last = point;\n        // Eliminate repeated points : for every new point, add to list\n        // only if it is not duplicated\n        // if (checkDuplicatedPoints(point) == false) {\n        list.add(point);\n        // }\n        lt = INVALID;\n        lg = INVALID;\n      }\n    }\n  } // extractLtLgData\n"}, {"dataset": "nextToken", "exampleID": 9058, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [106], "initializationEnd": [153], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 215, "guardExpressionEnd": 241, "guardBlockStart": 215, "guardBlockEnd": 299, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 276, "focalAPIEnd": 290, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(nextToken)"], "useStart": [259], "useEnd": [291], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BrentDouglas/richfaces-3/tree/master/test-applications/seamApp/web/src/main/java/org/richfaces/helloworld/domain/calendar/CalendarBean.java", "rawCode": "  public Date getPrDateRangeBegin() {\n    Calendar cal = Calendar.getInstance();\n    StringTokenizer st = new StringTokenizer(preloadDateRangeBegin, \".\");\n    ArrayList<Integer> date = new ArrayList<Integer>();\n    while (st.hasMoreTokens()) {\n      date.add(Integer.parseInt(st.nextToken()));\n    }\n    cal.set(date.get(2), date.get(1) - 1, date.get(0), 12, 0, 0);\n    return cal.getTime();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9059, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [1171], "initializationEnd": [1223], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "IF {", "guardExpressionStart": 1229, "guardExpressionEnd": 1252, "guardBlockStart": 1229, "guardBlockEnd": 1311, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1290, "focalAPIEnd": 1304, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Map.get(nextToken)", "ProtocolEventDetailsForm.setCollectionProtocolEventkey(nextToken)"], "useStart": [1418, 2769], "useEnd": [1476, 2851], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jimmccusker/caTissue/tree/master/software/caTissue/modules/core/src/main/java/edu/wustl/catissuecore/action/ProtocolEventDetailsAction.java", "rawCode": "  /**\n   * Inits the specimenrequirement form.\n   *\n   * @param mapping ActionMapping\n   * @param protocolEventDetailsForm protocolEventDetails Form\n   * @param request HttpServletRequest\n   */\n  private void initSpecimenrequirementForm(\n      ActionMapping mapping,\n      ProtocolEventDetailsForm protocolEventDetailsForm,\n      HttpServletRequest request) {\n    final HttpSession session = request.getSession();\n    final Map collectionProtocolEventMap =\n        (Map) session.getAttribute(Constants.COLLECTION_PROTOCOL_EVENT_SESSION_MAP);\n\n    // If flow is from Specimen Requirement page save button.\n    String collectionProtocolEventKey = (String) request.getAttribute(Constants.EVENT_KEY);\n\n    if (collectionProtocolEventKey == null) {\n      // If flow is from Specimen Tree View if Event Node is clicked to\n      // open Event page in Edit mode.\n      collectionProtocolEventKey = request.getParameter(Constants.EVENT_KEY);\n    }\n    if (collectionProtocolEventKey == null) {\n      // If flow is when user Clicks Define Event button.\n      collectionProtocolEventKey = (String) session.getAttribute(Constants.NEW_EVENT_KEY);\n    }\n    final StringTokenizer st = new StringTokenizer(collectionProtocolEventKey, \"_\");\n    if (st.hasMoreTokens()) {\n      collectionProtocolEventKey = st.nextToken();\n    }\n    final CollectionProtocolEventBean collectionProtocolEventBean =\n        (CollectionProtocolEventBean) collectionProtocolEventMap.get(collectionProtocolEventKey);\n    if (collectionProtocolEventBean != null\n        && new Long(collectionProtocolEventBean.getId()) != null\n        && collectionProtocolEventBean.getId() > 0) {\n      request.setAttribute(\"isPersistent\", true);\n    }\n    protocolEventDetailsForm.setClinicalDiagnosis(\n        collectionProtocolEventBean.getClinicalDiagnosis());\n    protocolEventDetailsForm.setClinicalStatus(collectionProtocolEventBean.getClinicalStatus());\n    protocolEventDetailsForm.setCollectionPointLabel(\n        collectionProtocolEventBean.getCollectionPointLabel());\n    protocolEventDetailsForm.setStudyCalendarEventPoint(\n        collectionProtocolEventBean.getStudyCalenderEventPoint());\n\n    protocolEventDetailsForm.setCollectionEventComments(\n        collectionProtocolEventBean.getCollectedEventComments());\n    protocolEventDetailsForm.setCollectionEventContainer(\n        collectionProtocolEventBean.getCollectionContainer());\n    protocolEventDetailsForm.setReceivedEventComments(\n        collectionProtocolEventBean.getReceivedEventComments());\n    protocolEventDetailsForm.setReceivedEventReceivedQuality(\n        collectionProtocolEventBean.getReceivedQuality());\n    protocolEventDetailsForm.setCollectionEventCollectionProcedure(\n        collectionProtocolEventBean.getCollectionProcedure());\n    protocolEventDetailsForm.setCollectionProtocolEventkey(collectionProtocolEventKey);\n\n    protocolEventDetailsForm.setLabelFormat(collectionProtocolEventBean.getLabelFormat());\n    protocolEventDetailsForm.setSpecimenProcessingProcedure(\n        collectionProtocolEventBean.getSpecimenProcessingProcedure());\n\n    if (collectionProtocolEventBean != null) {\n      Collection<NameValueBean> sppBean = new LinkedHashSet<NameValueBean>();\n      Locale locale = CommonServiceLocator.getInstance().getDefaultLocale();\n\n      Object[] spp = collectionProtocolEventBean.getSpecimenProcessingProcedure();\n      if (spp != null) {\n        for (int i = 0; i < spp.length; i++) {\n          NameValueBean nvb = new NameValueBean(spp[i], spp[i]);\n\n          nvb.getName().toLowerCase(locale);\n\n          sppBean.add(nvb);\n        }\n      }\n      Collection<NameValueBean> sppBeans = new ArrayList<NameValueBean>();\n      sppBeans.addAll(sppBean);\n      request.setAttribute(Constants.SELECTED_SPP, sppBeans);\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9060, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [1623], "initializationEnd": [1667], "hasTryCatch": 1, "exceptionType": "URISyntaxException", "exceptionHandlingCall": ["new Status(*,*,String,*)", "log(*)"], "tryExpressionStart": 1783, "tryExpressionEnd": 1787, "tryBlockStart": 1783, "tryBlockEnd": 2176, "catchExpressionStart": 1899, "catchExpressionEnd": 1928, "catchBlockStart": 1899, "catchBlockEnd": 2176, "exceptionHandlingCallStart": [1969, 1940], "exceptionHandlingCallEnd": [2149, 2150], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 1690, "guardExpressionEnd": 1723, "guardBlockStart": 1690, "guardBlockEnd": 2184, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1814, "focalAPIEnd": 1835, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new URI(nextToken)"], "useStart": [1865], "useEnd": [1886], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/irbull/rt.eclipse.p2/tree/master/bundles/org.eclipse.equinox.p2.engine/src/org/eclipse/equinox/internal/p2/engine/ProfileMetadataRepository.java", "rawCode": "  private List<URI> findArtifactRepos() {\n    List<URI> artifactRepos = new ArrayList<URI>();\n    File p2Directory = findP2Directory();\n\n    // Add the profile registry's default agent artifact repository.\n    // Currently this is used by the Native Touchpoint to store artifacts however\n    // other touchpoints might use this as well.\n    File agentArtifactRepository = findAgentArtifactRepositoryDirectory(p2Directory);\n    if (agentArtifactRepository != null) artifactRepos.add(agentArtifactRepository.toURI());\n\n    // bundle pool\n    String bundlePool = profile.getProperty(IProfile.PROP_CACHE);\n    if (bundlePool != null) {\n      File bundlePoolFile = new File(bundlePool);\n      if (bundlePoolFile.exists()) artifactRepos.add(bundlePoolFile.toURI());\n      else if (Boolean.valueOf(profile.getProperty(IProfile.PROP_ROAMING)).booleanValue()) {\n        // the profile has not been used yet but is a roaming profile\n        // best effort to add \"just\" the default bundle pool\n        bundlePoolFile = findDefaultBundlePool(p2Directory);\n        if (bundlePoolFile != null) artifactRepos.add(bundlePoolFile.toURI());\n        return artifactRepos;\n      }\n    }\n\n    // shared bundle pool\n    String sharedBundlePool = profile.getProperty(IProfile.PROP_SHARED_CACHE);\n    if (sharedBundlePool != null) artifactRepos.add(new File(sharedBundlePool).toURI());\n\n    // cache extensions\n    // Currently set exclusively by dropins\n    String dropinRepositories =\n        profile.getProperty(\"org.eclipse.equinox.p2.cache.extensions\"); // $NON-NLS-1$\n    if (dropinRepositories != null) {\n      StringTokenizer tokenizer = new StringTokenizer(dropinRepositories, \"|\"); // $NON-NLS-1$\n      while (tokenizer.hasMoreTokens()) {\n        String repoLocation = \"\"; // $NON-NLS-1$\n        try {\n          repoLocation = tokenizer.nextToken();\n          artifactRepos.add(new URI(repoLocation));\n        } catch (URISyntaxException e) {\n          LogHelper.log(\n              new Status(\n                  IStatus.WARNING,\n                  EngineActivator.ID,\n                  \"invalid repo reference with location: \" + repoLocation,\n                  e)); // $NON-NLS-1$\n        }\n      }\n    }\n    return artifactRepos;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9061, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [265], "initializationEnd": [294], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 300, "guardExpressionEnd": 330, "guardBlockStart": 300, "guardBlockEnd": 653, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 354, "focalAPIEnd": 372, "followUpCheck": "!nextToken.equals(\"\")", "checkType": "IF", "followUpCheckExpressionStart": 387, "followUpCheckExpressionEnd": 409, "followUpCheckBlockStart": 387, "followUpCheckBlockEnd": 647, "use": ["new JID(nextToken)", "createJID(nextToken,*)"], "useStart": [525, 580], "useEnd": [539, 627], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Connectify/Openfire/tree/master/src/plugins/broadcast/src/java/org/jivesoftware/openfire/plugin/BroadcastPlugin.java", "rawCode": "  /**\n   * Returns a comma-delimitted list of strings into a Collection of Strings.\n   *\n   * @param str the String.\n   * @return a list.\n   */\n  private List<JID> stringToList(String str) {\n    List<JID> values = new ArrayList<JID>();\n    StringTokenizer tokens = new StringTokenizer(str, \",\");\n    while (tokens.hasMoreTokens()) {\n      String value = tokens.nextToken().trim();\n      if (!value.equals(\"\")) {\n        // See if this is a full JID or just a username.\n        if (value.contains(\"@\")) {\n          values.add(new JID(value));\n        } else {\n          values.add(XMPPServer.getInstance().createJID(value, null));\n        }\n      }\n    }\n    return values;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9062, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [427], "initializationEnd": [457], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 463, "guardExpressionEnd": 489, "guardBlockStart": 463, "guardBlockEnd": 655, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 513, "focalAPIEnd": 527, "followUpCheck": "(nextToken.length() == 0) || (nextToken.length() == 0)", "checkType": "IF", "followUpCheckExpressionStart": 535, "followUpCheckExpressionEnd": 586, "followUpCheckBlockStart": 535, "followUpCheckBlockEnd": 614, "use": ["ServiceConfig.getSubConfig(nextToken)"], "useStart": [626], "useEnd": [648], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aldaris/opensso/tree/master/products/amserver/source/com/iplanet/ums/ConfigManagerUMS.java", "rawCode": "  private Set getServiceComponents(String orgName, String path, boolean b)\n      throws SMSException, SSOException {\n    ServiceConfig sc =\n        (orgName.equals(_rootDN))\n            ? _smapi.getGlobalConfig(null)\n            : _smapi.getOrganizationConfig(orgName, null);\n    if (sc == null) {\n      return new HashSet();\n    }\n\n    // Parser the \"/\" seperated path to get the right service config\n    StringTokenizer st = new StringTokenizer(path, \"/\");\n    while (st.hasMoreTokens()) {\n      String token = st.nextToken();\n      if ((token.length() == 0) || (token.length() == 0)) {\n        continue;\n      }\n      sc = sc.getSubConfig(token);\n    }\n    Set answer = new HashSet();\n    Iterator comps = sc.getSubConfigNames().iterator();\n    while (comps.hasNext()) {\n      answer.add(path + \"/\" + comps.next());\n    }\n    return (answer);\n  }\n"}, {"dataset": "nextToken", "exampleID": 9063, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [154], "initializationEnd": [184], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": [], "tryExpressionStart": 330, "tryExpressionEnd": 334, "tryBlockStart": 330, "tryBlockEnd": 458, "catchExpressionStart": 396, "catchExpressionEnd": 428, "catchBlockStart": 396, "catchBlockEnd": 458, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["stringTokenizer.countTokens()"], "configurationStart": [202], "configurationEnd": [218], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 371, "focalAPIEnd": 385, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(nextToken)"], "useStart": [354], "useEnd": [386], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/smas036/ImageJ/tree/master/src/main/ij/plugin/ControlPanel.java", "rawCode": "  /** Breaks the specified string into an array of ints. Returns null if there is an error. */\n  public int[] s2ints(String s) {\n    StringTokenizer st = new StringTokenizer(s, \", \\t\");\n    int nInts = st.countTokens();\n    if (nInts == 0) return null;\n    int[] ints = new int[nInts];\n    for (int i = 0; i < nInts; i++) {\n      try {\n        ints[i] = Integer.parseInt(st.nextToken());\n      } catch (NumberFormatException e) {\n        return null;\n      }\n    }\n    return ints;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9064, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [438], "initializationEnd": [473], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 561, "guardExpressionEnd": 587, "guardBlockStart": 561, "guardBlockEnd": 688, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 615, "focalAPIEnd": 629, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PrioritizedLocale(nextToken)"], "useStart": [648], "useEnd": [676], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chuanghs/displaytag/tree/master/displaytag/src/test/java/com/meterware/servletunit/ServletUnitHttpRequest.java", "rawCode": "  /**\n   * Parses the accept-language header to obtain a vector of preferred locales\n   *\n   * @return the preferred locales, sorted by qvalue\n   */\n  private Vector<Locale> getPreferredLocales() {\n    if (_locales == null) {\n      _locales = new Vector<Locale>();\n      String languages = getHeader(\"accept-language\");\n      if (languages == null) {\n        _locales.add(Locale.getDefault());\n      } else {\n        StringTokenizer st = new StringTokenizer(languages, \",\");\n        ArrayList<PrioritizedLocale> al = new ArrayList<PrioritizedLocale>();\n        while (st.hasMoreTokens()) {\n          String token = st.nextToken();\n          al.add(new PrioritizedLocale(token));\n        }\n        Collections.sort(al);\n        for (Iterator<PrioritizedLocale> iterator = al.iterator(); iterator.hasNext(); ) {\n          _locales.add(iterator.next().getLocale());\n        }\n      }\n    }\n    return _locales;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9065, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [988], "initializationEnd": [1024], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 669, "tryExpressionEnd": 673, "tryBlockStart": 669, "tryBlockEnd": 2677, "catchExpressionStart": 2521, "catchExpressionEnd": 2542, "catchBlockStart": 2521, "catchBlockEnd": 2597, "exceptionHandlingCallStart": [2570], "exceptionHandlingCallEnd": [2590], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 1091, "guardExpressionEnd": 1130, "guardBlockStart": 1091, "guardBlockEnd": 1529, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1158, "focalAPIEnd": 1185, "followUpCheck": "\"reseller\".equalsIgnoreCase(nextToken)", "checkType": "IF", "followUpCheckExpressionStart": 1252, "followUpCheckExpressionEnd": 1291, "followUpCheckBlockStart": 1252, "followUpCheckBlockEnd": 1358, "use": ["stringTokenizer.nextToken()", "Map<String, Object>.put(nextToken,String)"], "useStart": [1213, 1486], "useEnd": [1240, 1518], "hasFinally": 1, "cleanUpCall": ["closeSession(Session)", "closeStreams(InputStream,OutputStream)"], "finallyExpressionStart": 2598, "finallyExpressionEnd": 2606, "finallyBlockStart": 2598, "finallyBlockEnd": 2677, "cleanUpCallStart": [2614, 2643], "cleanUpCallEnd": [2635, 2670], "url": "https://github.com/dimce011/campus201305/tree/master/mpayments-help/mpayments-help-repo-rest/src/main/java/org/infobip/mpayments/help/repo/rest/RestAPIService.java", "rawCode": "  @Override\n  public Response getParagraph(\n      @PathParam(\"docPath\") String docPath,\n      @PathParam(\"parID\") String parID,\n      @PathParam(\"fieldPars\") String fieldPars,\n      @Context UriInfo ui) {\n\n    Session session = null;\n    boolean error = false;\n    InputStream input = null;\n    OutputStream output = null;\n    String result = null;\n    StringTokenizer stringTokenizer = null;\n    Map<String, Object> mapParameters = new HashMap<String, Object>();\n    String reseller = null;\n    String language = null;\n    String noSuchID = \"No such ID!\";\n    StringBuffer returnResult = new StringBuffer();\n    System.out.println(\"POZVANA METODA getParagraph\");\n\n    try {\n      System.out.println(\"field par uri \" + fieldPars);\n\n      if (fieldPars == null) {\n        // error = true;\n        fieldPars = \"\";\n      }\n\n      if (fieldPars.startsWith(\"?\")) fieldPars = fieldPars.substring(1);\n\n      session = makeSession();\n\n      if (!fieldPars.equals(\"\")) {\n        stringTokenizer = new StringTokenizer(fieldPars, \"&=\");\n        System.out.println(\"FIELD PARAMS \" + fieldPars);\n        while (stringTokenizer.hasMoreTokens()) {\n          String first = stringTokenizer.nextToken();\n          String second = stringTokenizer.nextToken();\n          if (\"reseller\".equalsIgnoreCase(first)) {\n            reseller = second;\n            continue;\n          }\n          if (\"language\".equalsIgnoreCase(first)) {\n            language = second;\n            continue;\n          }\n          mapParameters.put(first, second);\n        }\n      }\n\n      if (language == null || \"null\".equals(language)) {\n        language = DEFAULTLANGUAGE;\n        // System.out.println(\"language je null \" + language);\n      }\n      if (reseller == null || \"null\".equals(reseller)) {\n        reseller = DEFAULTRESELLER;\n        // System.out.println(\"reseller je null \" + reseller);\n      }\n\n      if (language.equals(\"\")) {\n        language = DEFAULTLANGUAGE;\n      }\n\n      if (reseller.equals(\"\")) {\n        reseller = DEFAULTRESELLER;\n      }\n\n      System.out.println(\"ispis mape\");\n      for (Map.Entry<String, Object> entry : mapParameters.entrySet()) {\n        System.out.println(entry.getKey() + \" = \" + entry.getValue());\n      }\n\n      if (!docPath.startsWith(\"/\")) {\n        docPath = \"/\" + docPath;\n      }\n\n      result = getDocument(docPath, fieldPars, ui).getEntity().toString();\n\n      /* if (!mapParameters.isEmpty()) {\n      FreeMarker fm = new FreeMarker();\n      result = fm.process(mapParameters, result);\n      }*/\n\n    } catch (Exception ex) {\n      error = true;\n      ex.printStackTrace();\n    } finally {\n      closeSession(session);\n      closeStreams(input, output);\n    }\n\n    if (!error) {\n      Document doc = Jsoup.parse(result);\n      Elements divs = doc.getElementsByTag(\"div\");\n      for (Element elem : divs) {\n        if (elem.id().equals(parID)) {\n          // if (elem.className().equals(parID)) {\n          returnResult.append(elem.toString());\n        }\n      }\n      if (\"\".equals(returnResult.toString())) {\n        return Response.status(Response.Status.OK).entity(noSuchID).build();\n      } else {\n        return Response.status(Response.Status.OK).entity(returnResult.toString()).build();\n      }\n    } else {\n      return Response.status(Response.Status.NOT_FOUND).entity(\"error\").build();\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9066, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [352], "initializationEnd": [381], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 389, "guardExpressionEnd": 418, "guardBlockStart": 389, "guardBlockEnd": 851, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 440, "focalAPIEnd": 457, "followUpCheck": "StringUtils.isNotEmpty(nextToken)", "checkType": "IF", "followUpCheckExpressionStart": 467, "followUpCheckExpressionEnd": 497, "followUpCheckBlockStart": 467, "followUpCheckBlockEnd": 843, "use": ["valueOf(nextToken)"], "useStart": [554], "useEnd": [569], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jior/wechat/tree/master/src/main/java/com/glaf/wechat/web/springmvc/WxCoverController.java", "rawCode": "  @ResponseBody\n  @RequestMapping(\"/delete\")\n  public void delete(HttpServletRequest request, ModelMap modelMap) {\n    LoginContext loginContext = RequestUtils.getLoginContext(request);\n    Long id = RequestUtils.getLong(request, \"id\");\n    String ids = request.getParameter(\"ids\");\n    if (StringUtils.isNotEmpty(ids)) {\n      StringTokenizer token = new StringTokenizer(ids, \",\");\n      while (token.hasMoreTokens()) {\n        String x = token.nextToken();\n        if (StringUtils.isNotEmpty(x)) {\n          WxCover wxCover = wxCoverService.getWxCover(Long.valueOf(x));\n          /** 此处业务逻辑需自行调整 */\n          if (wxCover != null\n              && (StringUtils.equals(wxCover.getCreateBy(), loginContext.getActorId())\n                  || loginContext.isSystemAdministrator())) {\n            wxCoverService.save(wxCover);\n          }\n        }\n      }\n    } else if (id != null) {\n      WxCover wxCover = wxCoverService.getWxCover(Long.valueOf(id));\n      /** 此处业务逻辑需自行调整 */\n      if (wxCover != null\n          && (StringUtils.equals(wxCover.getCreateBy(), loginContext.getActorId())\n              || loginContext.isSystemAdministrator())) {\n        wxCoverService.save(wxCover);\n      }\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9067, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String,boolean)"], "initializationStart": [2572], "initializationEnd": [2607], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 2613, "guardExpressionEnd": 2639, "guardBlockStart": 2613, "guardBlockEnd": 4088, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 2659, "focalAPIEnd": 2673, "followUpCheck": "nextToken.startsWith(\"CO\")", "checkType": "IF", "followUpCheckExpressionStart": 2681, "followUpCheckExpressionEnd": 2704, "followUpCheckBlockStart": 2681, "followUpCheckBlockEnd": 4082, "use": ["nextToken.endsWith(String)", "nextToken.endsWith(String)", "nextToken.endsWith(String)", "nextToken.endsWith(String)", "nextToken.endsWith(String)", "nextToken.endsWith(String)", "nextToken.endsWith(String)", "nextToken.endsWith(String)"], "useStart": [3055, 3195, 3335, 3475, 3606, 3741, 3882, 4058], "useEnd": [3070, 3210, 3350, 3490, 3621, 3756, 3897, 4073], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/adempiere/adempiere/tree/master/zkwebui/WEB-INF/src/org/adempiere/webui/window/WLocationDialog.java", "rawCode": "  private void initLocation() {\n    if (mainPanel.getRows() != null) mainPanel.getRows().getChildren().clear();\n\n    MCountry country = m_location.getCountry();\n    log.fine(\n        country.getName()\n            + \", Region=\"\n            + country.isHasRegion()\n            + \" \"\n            + country.getCaptureSequence()\n            + \", C_Location_ID=\"\n            + m_location.getC_Location_ID());\n    // new Country\n    if (m_location.getC_Country_ID() != s_oldCountry_ID) {\n      lstRegion.getChildren().clear();\n      if (country.isHasRegion()) {\n        lstRegion.appendItem(\"\", null);\n        for (MRegion region : MRegion.getRegions(Env.getCtx(), country.getC_Country_ID())) {\n          lstRegion.appendItem(region.getName(), region);\n        }\n        if (m_location.getCountry().get_Translation(MCountry.COLUMNNAME_RegionName) != null\n            && m_location\n                    .getCountry()\n                    .get_Translation(MCountry.COLUMNNAME_RegionName)\n                    .trim()\n                    .length()\n                > 0)\n          lblRegion.setValue(\n              m_location.getCountry().get_Translation(MCountry.COLUMNNAME_RegionName));\n        else lblRegion.setValue(Msg.getMsg(Env.getCtx(), \"Region\"));\n      }\n      s_oldCountry_ID = m_location.getC_Country_ID();\n    }\n\n    if (m_location.getC_Region_ID() > 0\n        && m_location.getC_Region().getC_Country_ID() == country.getC_Country_ID()) {\n      setRegion();\n    } else {\n      lstRegion.setSelectedItem(null);\n      m_location.setC_Region_ID(0);\n    }\n\n    if (country.isHasRegion() && m_location.getC_Region_ID() > 0) {\n      Env.setContext(\n          Env.getCtx(),\n          m_WindowNo,\n          Env.TAB_INFO,\n          \"C_Region_ID\",\n          String.valueOf(m_location.getC_Region_ID()));\n    } else {\n      Env.setContext(Env.getCtx(), m_WindowNo, Env.TAB_INFO, \"C_Region_ID\", \"0\");\n    }\n    Env.setContext(\n        Env.getCtx(), m_WindowNo, Env.TAB_INFO, \"C_Country_ID\", String.valueOf(country.get_ID()));\n\n    txtCity.fillList();\n\n    // sequence of City Postal Region - @P@ @C@ - @C@, @R@ @P@\n    String ds = country.getCaptureSequence();\n    if (ds == null || ds.length() == 0) {\n      log.log(Level.SEVERE, \"CaptureSequence empty - \" + country);\n      ds = \"\"; // @C@, @P@\n    }\n    isCityMandatory = false;\n    isRegionMandatory = false;\n    isAddress1Mandatory = false;\n    isAddress2Mandatory = false;\n    isAddress3Mandatory = false;\n    isAddress4Mandatory = false;\n    isPostalMandatory = false;\n    isPostalAddMandatory = false;\n    StringTokenizer st = new StringTokenizer(ds, \"@\", false);\n    while (st.hasMoreTokens()) {\n      String s = st.nextToken();\n      if (s.startsWith(\"CO\")) {\n        // Country Last\n        addComponents((Row) lstCountry.getParent());\n        // TODO: Add Online\n        // if (m_location.getCountry().isPostcodeLookup()) {\n        // addLine(line++, lOnline, fOnline);\n        // }\n      } else if (s.startsWith(\"A1\")) {\n        addComponents((Row) txtAddress1.getParent());\n        isAddress1Mandatory = s.endsWith(\"!\");\n      } else if (s.startsWith(\"A2\")) {\n        addComponents((Row) txtAddress2.getParent());\n        isAddress2Mandatory = s.endsWith(\"!\");\n      } else if (s.startsWith(\"A3\")) {\n        addComponents((Row) txtAddress3.getParent());\n        isAddress3Mandatory = s.endsWith(\"!\");\n      } else if (s.startsWith(\"A4\")) {\n        addComponents((Row) txtAddress4.getParent());\n        isAddress4Mandatory = s.endsWith(\"!\");\n      } else if (s.startsWith(\"C\")) {\n        addComponents((Row) txtCity.getParent());\n        isCityMandatory = s.endsWith(\"!\");\n      } else if (s.startsWith(\"P\")) {\n        addComponents((Row) txtPostal.getParent());\n        isPostalMandatory = s.endsWith(\"!\");\n      } else if (s.startsWith(\"A\")) {\n        addComponents((Row) txtPostalAdd.getParent());\n        isPostalAddMandatory = s.endsWith(\"!\");\n      } else if (s.startsWith(\"R\") && m_location.getCountry().isHasRegion()) {\n        addComponents((Row) lstRegion.getParent());\n        isRegionMandatory = s.endsWith(\"!\");\n      }\n    }\n\n    // Fill it\n    if (m_location.getC_Location_ID() != 0) {\n      txtAddress1.setText(m_location.getAddress1());\n      txtAddress2.setText(m_location.getAddress2());\n      txtAddress3.setText(m_location.getAddress3());\n      txtAddress4.setText(m_location.getAddress4());\n      txtCity.setText(m_location.getCity());\n      txtPostal.setText(m_location.getPostal());\n      txtPostalAdd.setText(m_location.getPostal_Add());\n      if (m_location.getCountry().isHasRegion()) {\n        if (m_location.getCountry().get_Translation(MCountry.COLUMNNAME_RegionName) != null\n            && m_location\n                    .getCountry()\n                    .get_Translation(MCountry.COLUMNNAME_RegionName)\n                    .trim()\n                    .length()\n                > 0)\n          lblRegion.setValue(\n              m_location.getCountry().get_Translation(MCountry.COLUMNNAME_RegionName));\n        else lblRegion.setValue(Msg.getMsg(Env.getCtx(), \"Region\"));\n\n        setRegion();\n      }\n      setCountry();\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9068, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,*)"], "initializationStart": [116], "initializationEnd": [158], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 166, "guardExpressionEnd": 191, "guardBlockStart": 166, "guardBlockEnd": 247, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 224, "focalAPIEnd": 237, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addComponent(nextToken)"], "useStart": [211], "useEnd": [238], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jetty-project/jetty-plugin-support/tree/master/jetty-start/src/main/java/org/eclipse/jetty/start/Classpath.java", "rawCode": "  public boolean addClasspath(String s) {\n    boolean added = false;\n    if (s != null) {\n      StringTokenizer t = new StringTokenizer(s, File.pathSeparator);\n      while (t.hasMoreTokens()) {\n        added |= addComponent(t.nextToken());\n      }\n    }\n    return added;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9069, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [299], "initializationEnd": [327], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 368, "focalAPIEnd": 382, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()"], "useStart": [405], "useEnd": [419], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/LimitPointSystems/SheafSystem/tree/master/tools/common/util/LPSDebug.java", "rawCode": "  /** */\n  public static String getLocationInClass(Throwable e, int level) {\n    try {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n      PrintWriter pw = new PrintWriter(baos, true);\n      e.printStackTrace(pw);\n\n      String s = baos.toString();\n\n      StringTokenizer st = new StringTokenizer(s, \"\\n\");\n\n      for (int i = 0; i < level; i++) st.nextToken();\n\n      String line = st.nextToken();\n      int begin = line.indexOf(\"at \") + 3;\n      String result = line.substring(begin);\n\n      return result;\n\n    } catch (Exception ex) {\n      return \"Error getting location: \" + ex;\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9070, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*)"], "initializationStart": [104], "initializationEnd": [142], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 161, "focalAPIEnd": 182, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ftiasch/acm-icpc/tree/master/codeforces/434-codeforces-round-248/A/Main.java", "rawCode": "  private String next() throws IOException {\n    while (!tokenizer.hasMoreTokens()) {\n      tokenizer = new StringTokenizer(reader.readLine());\n    }\n    return tokenizer.nextToken();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9071, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [456], "initializationEnd": [496], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 547, "guardExpressionEnd": 576, "guardBlockStart": 547, "guardBlockEnd": 783, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 599, "focalAPIEnd": 616, "followUpCheck": "!dataRoot.hasNode(nextToken)", "checkType": "IF", "followUpCheckExpressionStart": 624, "followUpCheckExpressionEnd": 652, "followUpCheckBlockStart": 624, "followUpCheckBlockEnd": 777, "use": ["addNode(nextToken,*)", "Node.getNode(nextToken)"], "useStart": [674, 746], "useEnd": [710, 768], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.13/kernel-impl/src/test/java/org/sakaiproject/jcr/test/NodeTestData.java", "rawCode": "  /**\n   * Creates two nodes under {@link #TEST_DATA_PATH}: one of type nt:resource and a second node\n   * referencing the first.\n   */\n  public void testFillInTestData() throws RepositoryException, IOException {\n    if (superuser.getRootNode().hasNode(TEST_DATA_PATH)) {\n      // delete previous data\n      superuser.getRootNode().getNode(TEST_DATA_PATH).remove();\n      superuser.save();\n    }\n    // create nodes to testPath\n    StringTokenizer names = new StringTokenizer(TEST_DATA_PATH, \"/\");\n    Node dataRoot = superuser.getRootNode();\n    while (names.hasMoreTokens()) {\n      String name = names.nextToken();\n      if (!dataRoot.hasNode(name)) {\n        dataRoot = dataRoot.addNode(name, testNodeType);\n      } else {\n        dataRoot = dataRoot.getNode(name);\n      }\n    }\n\n    Node resource = dataRoot.addNode(\"myResource\", ntResource);\n    resource.setProperty(jcrEncoding, ENCODING);\n    resource.setProperty(jcrMimeType, \"text/plain\");\n    ByteArrayOutputStream data = new ByteArrayOutputStream();\n    OutputStreamWriter writer = new OutputStreamWriter(data, ENCODING);\n    writer.write(\"Hello w\\u00F6rld.\");\n    writer.close();\n    resource.setProperty(jcrData, new ByteArrayInputStream(data.toByteArray()));\n    resource.setProperty(jcrLastModified, Calendar.getInstance());\n    log.println(\"Adding node: \" + resource.getPath());\n\n    Node resReference = dataRoot.addNode(\"reference\");\n    resReference.setProperty(\"ref\", resource);\n    // make this node itself referenceable\n    resReference.addMixin(mixReferenceable);\n    log.println(\"Adding node: \" + resReference.getPath());\n\n    Node multiReference = dataRoot.addNode(\"multiReference\");\n    Value[] refs = new Value[2];\n    refs[0] = superuser.getValueFactory().createValue(resource);\n    refs[1] = superuser.getValueFactory().createValue(resReference);\n    multiReference.setProperty(\"ref\", refs);\n    log.println(\"Adding node: \" + multiReference.getPath());\n\n    superuser.save();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9072, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [128], "initializationEnd": [150], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["stringTokenizer.countTokens()"], "configurationStart": [171], "configurationEnd": [190], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 301, "focalAPIEnd": 318, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseDouble(nextToken)", "stringTokenizer.nextToken()", "parseDouble(nextToken)"], "useStart": [282, 348, 329], "useEnd": [319, 365, 366], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/GreenGroup/RMG-Java/tree/master/source/RMG/jing/chemParser/ChemParser.java", "rawCode": "  public static UnifacGAValue parseUnifacGAValue(String p_string) {\n    String s = p_string.trim();\n    StringTokenizer token = new StringTokenizer(s);\n    int data_num = token.countTokens();\n    if (data_num != 2) throw new InvalidThermoFormatException();\n    double R, Q;\n    R = Double.parseDouble(token.nextToken());\n    Q = Double.parseDouble(token.nextToken());\n    return new UnifacGAValue(R, Q);\n  }\n"}, {"dataset": "nextToken", "exampleID": 9073, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)", "StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [1658, 2177], "initializationEnd": [1692, 2211], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens() && !(stringTokenizer.countTokens()!=st2.countTokens())", "guardType": "IF {", "guardExpressionStart": 1773, "guardExpressionEnd": 1815, "guardBlockStart": 1773, "guardBlockEnd": 2017, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 2330, "focalAPIEnd": 2344, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["nextToken.replaceAll(String,String)", "parseInt(nextToken)", "parseInt(nextToken)", "parseInt(nextToken)", "parseInt(nextToken)"], "useStart": [2406, 2631, 2744, 2856, 2940], "useEnd": [2435, 2658, 2771, 2883, 2967], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pescuma/jfg/tree/master/calendarcombo-src/org/eclipse/nebula/widgets/calendarcombo/DateHelper.java", "rawCode": "  /**\n   * This method assumes the dateFormat has a separator char in it, and that we can use that to\n   * determine what the user entered by using that separator to split up the user entered date, and\n   * then do some logic on it. This is by no means a foolproof method and should not be relied upon\n   * returning 100% correct dates all the time.\n   *\n   * @param str String to parse\n   * @param dateFormat DateFormat to use\n   * @param separators Separator chars that can be encountered\n   * @param locale Locale\n   * @return Calendar\n   * @throws CalendarDateParseException If date could not be parsed\n   * @throws Exception If any step of the parsing failed\n   */\n  public static Calendar slashParse(\n      final String str, final String dateFormat, final char[] separators, final Locale locale)\n      throws CalendarDateParseException, Exception {\n    int start = -1;\n    String splitter = null;\n    String dateFormatToUse = dateFormat;\n    for (int i = 0; i < separators.length; i++) {\n      start = str.indexOf(separators[i]);\n      if (start != -1) {\n        splitter = String.valueOf(separators[i]);\n        break;\n      }\n    }\n    if (start == -1)\n      throw new CalendarDateParseException(\n          \"Failed to find splitter char\", CalendarDateParseException.TYPE_NO_SLPITTER_CHAR);\n\n    // replace dateFormat until we have same splitter\n    for (int i = 0; i < separators.length; i++) {\n      if (String.valueOf(separators[i]).equals(splitter)) continue;\n\n      dateFormatToUse = dateFormatToUse.replaceAll(\"\\\\\" + String.valueOf(separators[i]), splitter);\n    }\n\n    Calendar toReturn = Calendar.getInstance(locale);\n    StringTokenizer st = new StringTokenizer(str, splitter);\n    StringTokenizer st2 = new StringTokenizer(dateFormatToUse, splitter);\n\n    if (st.countTokens() != st2.countTokens())\n      throw new CalendarDateParseException(\n          \"Date format does not match date string in terms of splitter character numbers\",\n          CalendarDateParseException.TYPE_INSUFFICIENT_SPLITTERS);\n\n    // variables we'll be extracting\n    int monthToSet = -1;\n    int dayToSet = -1;\n    int yearToSet = -1;\n\n    // reset, skipping month this time\n    st = new StringTokenizer(str, splitter);\n    st2 = new StringTokenizer(dateFormatToUse, splitter);\n\n    while (st.hasMoreTokens()) {\n      String dateValue = st.nextToken();\n      String dateType = st2.nextToken();\n\n      dateValue = dateValue.replaceAll(\" \", \"\");\n      dateType = dateType.replaceAll(\" \", \"\");\n\n      int calType = getCalendarTypeForString(dateType);\n      // we already did month\n      if (calType == Calendar.MONTH) {\n        monthToSet = Integer.parseInt(dateValue);\n        continue;\n      }\n      if (calType == Calendar.YEAR) {\n        yearToSet = Integer.parseInt(dateValue);\n        continue;\n      }\n      if (calType == Calendar.DATE) {\n        dayToSet = Integer.parseInt(dateValue);\n        continue;\n      }\n\n      toReturn.set(calType, Integer.parseInt(dateValue));\n    }\n\n    // set all date parameters at the same time, or else we'll get month-skipping due to setting a\n    // value later (such as a date that is too high\n    // for the current month). (-1 for month as Calendar class is month-zero-based).\n    if (monthToSet != -1 && dayToSet != -1 && yearToSet != -1) {\n      toReturn.set(yearToSet, monthToSet - 1, dayToSet);\n    } else {\n      // set what we know\n      if (yearToSet != -1) {\n        toReturn.set(Calendar.YEAR, yearToSet);\n      }\n      if (monthToSet != -1) {\n        toReturn.set(Calendar.MONTH, monthToSet - 1);\n      }\n      if (dayToSet != -1) {\n        toReturn.set(Calendar.DATE, dayToSet);\n      }\n    }\n\n    if (toReturn.get(Calendar.YEAR) < 100)\n      toReturn.set(Calendar.YEAR, toReturn.get(Calendar.YEAR) + 1900);\n\n    toReturn.set(Calendar.HOUR_OF_DAY, 0);\n    toReturn.set(Calendar.MINUTE, 0);\n    toReturn.set(Calendar.SECOND, 0);\n    toReturn.set(Calendar.MILLISECOND, 0);\n\n    return toReturn;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9074, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [237], "initializationEnd": [273], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["stringTokenizer.countTokens()"], "configurationStart": [332], "configurationEnd": [355], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 362, "guardExpressionEnd": 395, "guardBlockStart": 362, "guardBlockEnd": 447, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 418, "focalAPIEnd": 439, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(nextToken)"], "useStart": [404], "useEnd": [440], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/raykroeker/thinkparity/tree/master/remote/model/src/main/java/com/thinkparity/ophelia/model/index/lucene/LuceneUtil.java", "rawCode": "  /**\n   * Tokenize the expression.\n   *\n   * @param expression An expression.\n   * @return A list of tokens within the expression.\n   */\n  List<String> tokenizeExpression(final String expression) {\n    final StringTokenizer tokenizer = new StringTokenizer(expression, \" \");\n    final List<String> tokenized = new ArrayList<String>(tokenizer.countTokens());\n    while (tokenizer.hasMoreTokens()) {\n      tokenized.add(tokenizer.nextToken());\n    }\n    return tokenized;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9075, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [221], "initializationEnd": [252], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 260, "guardExpressionEnd": 285, "guardBlockStart": 260, "guardBlockEnd": 342, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 312, "focalAPIEnd": 325, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(nextToken)"], "useStart": [303], "useEnd": [326], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MiniSEC/adito_reload/tree/master/adito/tags/release-0.9.1/adito/boot/src/com/adito/boot/Bootstrap.java", "rawCode": "  private void addDirPaths(String propertyName, List<URL> libs)\n      throws MalformedURLException, IOException {\n    String paths = classpath.getProperty(propertyName);\n    if (paths != null) {\n      StringTokenizer t = new StringTokenizer(paths, \",\");\n      while (t.hasMoreTokens()) {\n        addDir(new File(t.nextToken()), libs);\n      }\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9076, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*,String)"], "initializationStart": [781], "initializationEnd": [816], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["stringTokenizer.countTokens()"], "configurationStart": [931], "configurationEnd": [958], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1206, "focalAPIEnd": 1231, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(nextToken)"], "useStart": [1187], "useEnd": [1232], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta05/kernel-impl/src/main/java/org/sakaiproject/tool/impl/ActiveToolComponent.java", "rawCode": "      /**\n       * This method takes the given relative Sakai URL and uses the context path and path info to\n       * create the corresponding absolute URL.\n       *\n       * @param relativeUrl the relative URL to convert to an absolute URL\n       * @return the absolute URL\n       */\n      protected String createAbsoluteURL(String relativeUrl) {\n        // ensure this is a relative URL\n        if (!(relativeUrl.toLowerCase().startsWith(\"http\")) && !(relativeUrl.startsWith(\"/\"))) {\n          ActiveToolComponent.MyActiveTool.WrappedRequest wr = (WrappedRequest) this.m_req;\n\n          // need to obtain any extra path info from the path\n          StringBuilder pathBuilder = new StringBuilder(\"\");\n          if (wr.m_path != null) {\n            StringTokenizer pathTokenizer = new StringTokenizer(wr.m_path, \"/\");\n            // if the path has more than one segment (eg. \"/name1/name2\")\n            int numberOfPathElements = pathTokenizer.countTokens();\n            if (numberOfPathElements > 1) {\n              // copy over everything but the last segment\n              for (int i = 0; i < numberOfPathElements - 1; i++) {\n                pathBuilder.append(\"/\");\n                pathBuilder.append(pathTokenizer.nextToken());\n              }\n            }\n          }\n          if (!pathBuilder.toString().endsWith(\"/\")) {\n            pathBuilder.append(\"/\");\n          }\n\n          relativeUrl = wr.m_context + pathBuilder.toString() + relativeUrl;\n        }\n        return relativeUrl;\n      }\n"}, {"dataset": "nextToken", "exampleID": 9077, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [451], "initializationEnd": [478], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.countTokens()==2", "guardType": "IF {", "guardExpressionStart": 487, "guardExpressionEnd": 517, "guardBlockStart": 487, "guardBlockEnd": 2276, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 602, "focalAPIEnd": 620, "followUpCheck": "nextToken.isEmpty()", "checkType": "IF", "followUpCheckExpressionStart": 2283, "followUpCheckExpressionEnd": 2309, "followUpCheckBlockStart": 2283, "followUpCheckBlockEnd": 2340, "use": ["stringTokenizer.nextToken()", "createFromTwoStrings(nextToken,String)"], "useStart": [643, 2354], "useEnd": [661, 2399], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openGDA/gda-core/tree/master/uk.ac.gda.api/src/gda/util/QuantityFactory.java", "rawCode": "  /**\n   * Creates a Quantity from a single string specifying value and units. This should be useful, for\n   * example, in creating Quantities from scripts.\n   *\n   * @param string of the form '1.0 mm'\n   * @return the Quantity created (or null)\n   */\n  public static Amount<? extends Quantity> createFromString(String string) {\n    final String valueString;\n    final String unitString;\n    if (string != null) {\n      final StringTokenizer strtok = new StringTokenizer(string);\n\n      if (strtok.countTokens() == 2) {\n        // The string is assumed to be of the form \"1.0 mm\"\n        valueString = strtok.nextToken();\n        unitString = strtok.nextToken();\n      } else {\n        // The string is assumed to be of the form \"1.0mm\"\n        // and needs to be split at the boundary of the number and unit.\n\n        // It is easiest to search the string backwards because we\n        // can't use isLetter() to find the end of a number because it\n        // might contain an 'e' or an 'E'\n        final StringBuilder sb = new StringBuilder(string);\n        sb.reverse();\n\n        final StringBuilder unitStringBuffer = new StringBuilder();\n        final StringBuilder valueStringBuffer = new StringBuilder();\n\n        // Go through reversed string appending to the unitStringBuffer\n        // until we find a character (digit or '.') which must be part\n        // of the value. NB this was formerly a do {...} while loop but\n        // went wrong for strings such as \"1.0\". With the loop this way\n        // round \"1.0\" produces Quantity 1.0 Dimensionless.\n        int k = 0;\n        while (k < sb.length() && sb.charAt(k) != '.' && !Character.isDigit(sb.charAt(k))) {\n          unitStringBuffer.append(sb.charAt(k));\n          k++;\n        }\n\n        // Use the rest of the string as the value\n        for (; k < sb.length(); k++) {\n          valueStringBuffer.append(sb.charAt(k));\n        }\n\n        // Reverse the two StringBuffers and use them to create a\n        // quantity. NB If the string was not of the correct form\n        // then one or other of the two parts will not be correct\n        // and createFromTwoStrings will be null.\n        valueString = new String(valueStringBuffer.reverse());\n        unitString = new String(unitStringBuffer.reverse());\n      }\n      if (valueString.isEmpty()) {\n        return null;\n      }\n      return createFromTwoStrings(valueString, unitString);\n    }\n    return null;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9078, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [379], "initializationEnd": [410], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 416, "guardExpressionEnd": 442, "guardBlockStart": 416, "guardBlockEnd": 542, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 462, "focalAPIEnd": 476, "followUpCheck": "nextToken != null && nextToken.length() > 0", "checkType": "IF", "followUpCheckExpressionStart": 484, "followUpCheckExpressionEnd": 516, "followUpCheckBlockStart": 484, "followUpCheckBlockEnd": 536, "use": ["nextToken.trim()", "List<String>.toArray(nextToken)"], "useStart": [526, 590], "useEnd": [534, 605], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robstryker/eclipse-webtools-servertools/tree/master/plugins/org.eclipse.wst.server.ui/serverui/org/eclipse/wst/server/ui/internal/ServerUIPlugin.java", "rawCode": "  /**\n   * Utility method to tokenize a string into an array.\n   *\n   * @param str a string to be parsed\n   * @param delim the delimiters\n   * @return an array containing the tokenized string\n   */\n  public static String[] tokenize(String str, String delim) {\n    if (str == null) return new String[0];\n\n    List<String> list = new ArrayList<String>();\n\n    StringTokenizer st = new StringTokenizer(str, delim);\n    while (st.hasMoreTokens()) {\n      String s = st.nextToken();\n      if (s != null && s.length() > 0) list.add(s.trim());\n    }\n\n    String[] s = new String[list.size()];\n    list.toArray(s);\n    return s;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9079, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [478], "initializationEnd": [513], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 534, "guardExpressionEnd": 567, "guardBlockStart": 534, "guardBlockEnd": 1039, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 598, "focalAPIEnd": 619, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["lookup(*,*,nextToken)", "fill(String,nextToken,*)"], "useStart": [659, 883], "useEnd": [738, 1024], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wso2/tools/tree/master/poc/bps/org.eclipse.bpel.validator/src/org/eclipse/bpel/validator/rules/ValidateValidator.java", "rawCode": "  /** Make sure that the variables defined in the validate activity exist in the process. */\n  public void rule_CheckValidateVariables_15() {\n\n    IProblem problem;\n\n    if (isEmptyOrWhitespace(variables)) {\n      problem = createError();\n      problem.setAttribute(IProblem.CONTEXT, AT_VARIABLES);\n      problem.fill(\n          \"BPELC_VALIDATE__NO_VARIABLES_SPECIFIED\", // $NON-NLS-1$\n          toString(mNode.nodeName()));\n      return;\n    }\n\n    StringTokenizer tokenizer = new StringTokenizer(variables, \" \"); // $NON-NLS-1$\n    while (tokenizer.hasMoreTokens()) {\n\n      String nextVarName = tokenizer.nextToken();\n\n      INode variableNode =\n          mModelQuery.lookup(mNode, IModelQueryLookups.LOOKUP_NODE_VARIABLE, nextVarName);\n\n      if (isUndefined(variableNode)) {\n        problem = createError();\n        problem.setAttribute(IProblem.CONTEXT, AT_VARIABLES);\n        problem.fill(\n            \"BPELC_VALIDATE__NO_SUCH_VARIABLE\", // $NON-NLS-1$\n            nextVarName,\n            toString(mNode.nodeName()));\n      }\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9080, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [271], "initializationEnd": [307], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 245, "guardExpressionEnd": 330, "guardBlockStart": 245, "guardBlockEnd": 938, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 350, "focalAPIEnd": 364, "followUpCheck": "nextToken.startsWith(\"name:\")", "checkType": "IF", "followUpCheckExpressionStart": 491, "followUpCheckExpressionEnd": 517, "followUpCheckBlockStart": 491, "followUpCheckBlockEnd": 739, "use": ["nextToken.startsWith(String)", "nextToken.substring(int)", "nextToken.substring(int)", "nextToken.trim()"], "useStart": [395, 438, 542, 542], "useEnd": [415, 452, 556, 563], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/czakian/openmrs_gsoc/tree/master/api/src/main/java/org/openmrs/util/OpenmrsUtil.java", "rawCode": "  public static List<Concept> conceptListHelper(String descriptor) {\n    List<Concept> ret = new ArrayList<Concept>();\n    if (descriptor == null || descriptor.length() == 0) return ret;\n    ConceptService cs = Context.getConceptService();\n\n    for (StringTokenizer st = new StringTokenizer(descriptor, \"|\"); st.hasMoreTokens(); ) {\n      String s = st.nextToken().trim();\n      boolean isSet = s.startsWith(\"set:\");\n      if (isSet) s = s.substring(4).trim();\n      Concept c = null;\n      if (s.startsWith(\"name:\")) {\n        String name = s.substring(5).trim();\n        c = cs.getConceptByName(name);\n      } else {\n        try {\n          c = cs.getConcept(Integer.valueOf(s.trim()));\n        } catch (Exception ex) {\n        }\n      }\n      if (c != null) {\n        if (isSet) {\n          List<Concept> inSet = cs.getConceptsByConceptSet(c);\n          ret.addAll(inSet);\n        } else {\n          ret.add(c);\n        }\n      }\n    }\n    return ret;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9081, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [475], "initializationEnd": [505], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 554, "guardExpressionEnd": 580, "guardBlockStart": 554, "guardBlockEnd": 941, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 604, "focalAPIEnd": 618, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["compile(nextToken,*)"], "useStart": [703], "useEnd": [751], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta01/kernel-util/src/main/java/org/sakaiproject/util/RemoteHostFilter.java", "rawCode": "  /**\n   * Converts the given list of comma-delimited regex patterns to an array of Pattern objects\n   *\n   * @param list The comma-separated list of patterns\n   * @exception IllegalArgumentException if one of the patterns has invalid regular expression\n   *     syntax\n   */\n  protected Pattern[] getRegExPatterns(String list) {\n\n    if (list == null) return EMPTY_PATTERN;\n\n    list = list.trim();\n    if (list.length() < 1) return EMPTY_PATTERN;\n\n    StringTokenizer st = new StringTokenizer(list, \",\");\n\n    ArrayList patterns = new ArrayList();\n    while (st.hasMoreTokens()) {\n      String token = st.nextToken().trim();\n      try {\n        // Host names are case insensitive\n        patterns.add(Pattern.compile(token, Pattern.CASE_INSENSITIVE));\n      } catch (PatternSyntaxException e) {\n        throw new IllegalArgumentException(\n            \"Illegal Regular Expression Syntax: [\" + token + \"] - \" + e.getMessage());\n      }\n    }\n    return ((Pattern[]) patterns.toArray(EMPTY_PATTERN));\n  }\n"}, {"dataset": "nextToken", "exampleID": 9082, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String,boolean)"], "initializationStart": [563], "initializationEnd": [615], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 621, "guardExpressionEnd": 648, "guardBlockStart": 621, "guardBlockEnd": 862, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 675, "focalAPIEnd": 690, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new File(nextToken)"], "useStart": [710], "useEnd": [728], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sisbell/jxta/tree/master/j2se/apps/jxse-shell/src/main/java/net/jxta/impl/shell/ShellCmds.java", "rawCode": "  /**\n   * Static method to extract the list of paths out of a String. The format of the String is:\n   * <path1><PATH_SEPARATOR><path2>... Only correct paths are added to the later returned list.\n   *\n   * @param pathList the String the paths will be extracted from.\n   * @return an array of all valid paths. If the given parameter contains no path or none of the\n   *     given paths is valid then an empty list is returned.\n   */\n  public static URL[] parseClassPath(String pathList) {\n\n    List<URL> pathURLS = new ArrayList<URL>();\n\n    StringTokenizer tok = new StringTokenizer(pathList, PATH_SEPARATOR, false);\n    while (tok.hasMoreTokens()) {\n      String fileName = tok.nextToken();\n      File file = new File(fileName);\n      try {\n        pathURLS.add(file.toURI().toURL());\n      } catch (MalformedURLException bad) {\n        // ignored\n      }\n    }\n\n    return pathURLS.toArray(new URL[pathURLS.size()]);\n  }\n"}, {"dataset": "nextToken", "exampleID": 9083, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*,String)"], "initializationStart": [1425], "initializationEnd": [1458], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreElements()", "guardType": "IF {", "guardExpressionStart": 1526, "guardExpressionEnd": 1558, "guardBlockStart": 1526, "guardBlockEnd": 1593, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1571, "focalAPIEnd": 1592, "followUpCheck": "nextToken != null", "checkType": "IF", "followUpCheckExpressionStart": 1680, "followUpCheckExpressionEnd": 1715, "followUpCheckBlockStart": 1680, "followUpCheckBlockEnd": 1952, "use": ["stringTokenizer.nextToken()"], "useStart": [1643], "useEnd": [1664], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/andrewsbrown/aima-java/tree/master/aimax-osm/src/main/java/aimax/osm/data/impl/DefaultEntityFinder.java", "rawCode": "  /**\n   * Searches for entities which comply to the current search specification and stores them as\n   * results.\n   */\n  @Override\n  protected void find(boolean findMore) {\n    BestMatchFinder bmf = new BestMatchFinder(pattern);\n    List<MapEntity> results = getResults();\n    BoundingBox bb = new BoundingBox(position, nextRadius);\n    if (!results.isEmpty()) bmf.checkMatchQuality(results.get(0));\n    if (mode.equals(Mode.ENTITY) || mode.equals(Mode.NODE)) {\n      for (MapNode node : getStorage().getPois(bb)) {\n        int match = bmf.checkMatchQuality(node);\n        if (match >= 0) {\n          if (match > 0) {\n            results.clear();\n            bmf.useAsReference(node);\n          }\n          if (position.insertInAscendingDistanceOrder(results, node))\n            if (results.size() > 100) results.remove(99);\n        }\n      }\n    }\n    if (mode.equals(Mode.ENTITY) || mode.equals(Mode.WAY)) {\n      for (MapWay way : getStorage().getWays(bb)) {\n        int match = bmf.checkMatchQuality(way);\n        if (match >= 0) {\n          if (match > 0) {\n            results.clear();\n            bmf.useAsReference(way);\n          }\n          if (position.insertInAscendingDistanceOrder(results, way))\n            if (results.size() > 100) results.remove(99);\n        }\n      }\n    }\n\n    if (mode.equals(Mode.ADDRESS)) {\n      List<MapEntity> iResults = getIntermediateResults();\n      StringTokenizer tokenizer = new StringTokenizer(pattern, \",\");\n      String placeName = null;\n      String wayName = null;\n      if (tokenizer.hasMoreElements()) placeName = tokenizer.nextToken();\n      if (tokenizer.hasMoreElements()) wayName = tokenizer.nextToken().trim();\n\n      if (placeName != null && !findMore) {\n        for (MapNode place : getStorage().getPlaces(placeName)) {\n          position.insertInAscendingDistanceOrder(iResults, place);\n          if (iResults.size() > 100) iResults.remove(99);\n        }\n        nextRadius = -1;\n      }\n      if (iResults.size() == 1 && wayName != null) {\n        MapNode place = (MapNode) iResults.get(0);\n        findWay(wayName, new Position(place.getLat(), place.getLon()), null);\n      }\n\n    } else {\n      nextRadius *= 2;\n      if (results.isEmpty() && getIntermediateResults().isEmpty() && nextRadius <= getMaxRadius())\n        find(true);\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9084, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*,String)"], "initializationStart": [2084], "initializationEnd": [2204], "hasTryCatch": 1, "exceptionType": "IndexOutOfBoundsException", "exceptionHandlingCall": ["new CVSStatus(*,String)", "new CVSException(IStatus)"], "tryExpressionStart": 1332, "tryExpressionEnd": 1336, "tryBlockStart": 1332, "tryBlockEnd": 7440, "catchExpressionStart": 7014, "catchExpressionEnd": 7050, "catchBlockStart": 7014, "catchBlockEnd": 7241, "exceptionHandlingCallStart": [7154, 7210], "exceptionHandlingCallEnd": [7196, 7234], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 2216, "guardExpressionEnd": 2245, "guardBlockStart": 2216, "guardBlockEnd": 2324, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 2274, "focalAPIEnd": 2291, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()", "put(nextToken,*)"], "useStart": [2293, 2260], "useEnd": [2310, 2311], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/eclipse.platform.team/tree/master/bundles/org.eclipse.team.cvs.core/src/org/eclipse/team/internal/ccvs/core/connection/CVSRepositoryLocation.java", "rawCode": "  /**\n   * Parse a location string and return a CVSRepositoryLocation.\n   *\n   * <p>The valid format (from the cederqvist) is:\n   *\n   * <p>:method:[[user][:password]@]hostname[:[port]]/path/to/repository\n   *\n   * <p>However, this does not work with CVS on NT so we use the format\n   *\n   * <p>:method:[user[:password]@]hostname[#port]:/path/to/repository\n   *\n   * <p>Some differences to note: The : after the host/port is not optional because of NT naming\n   * including device e.g. :pserver:username:password@hostname#port:D:\\cvsroot\n   *\n   * <p>Also parse alternative format from WinCVS, which stores connection parameters such as\n   * username and hostname in method options:\n   *\n   * <p>:method[;option=arg...]:other_connection_data\n   *\n   * <p>e.g. :pserver;username=anonymous;hostname=localhost:/path/to/repository\n   *\n   * <p>If validateOnly is true, this method will always throw an exception. The status of the\n   * exception indicates success or failure. The status of the exception contains a specific message\n   * suitable for displaying to a user who has knowledge of the provided location string.\n   *\n   * @see CVSRepositoryLocation.fromString(String)\n   */\n  public static CVSRepositoryLocation fromString(String location, boolean validateOnly)\n      throws CVSException {\n    String errorMessage = null;\n    try {\n      // Get the connection method\n      errorMessage = CVSMessages.CVSRepositoryLocation_parsingMethod;\n      int start = location.indexOf(COLON);\n      String methodName;\n      int end;\n      // For parsing alternative location format\n      int optionStart = location.indexOf(SEMICOLON);\n      HashMap<String, String> hmOptions = new HashMap<>();\n\n      if (start == 0) {\n        end = location.indexOf(COLON, start + 1);\n\n        // Check for alternative location syntax\n        if (optionStart != -1) {\n          // errorMessage = CVSMessages.CVSRepositoryLocation_parsingMethodOptions;\n          methodName = location.substring(start + 1, optionStart);\n          // Save options in hash table\n          StringTokenizer stOpt =\n              new StringTokenizer(\n                  location.substring(optionStart + 1, end), \"=;\" // $NON-NLS-1$\n                  );\n          while (stOpt.hasMoreTokens()) {\n            hmOptions.put(stOpt.nextToken(), stOpt.nextToken());\n          }\n          start = end + 1;\n        } else {\n          methodName = location.substring(start + 1, end);\n          start = end + 1;\n        }\n      } else {\n        // this could be an alternate format for ext: username:password@host:path\n        methodName = \"ext\"; // $NON-NLS-1$\n        start = 0;\n      }\n\n      IConnectionMethod method = getPluggedInConnectionMethod(methodName);\n      if (method == null)\n        throw new CVSException(\n            new CVSStatus(\n                IStatus.ERROR,\n                NLS.bind(\n                    CVSMessages.CVSRepositoryLocation_methods,\n                    (new Object[] {getPluggedInConnectionMethodNames()})))); //\n\n      // Get the user name and password (if provided)\n      errorMessage = CVSMessages.CVSRepositoryLocation_parsingUser;\n      // Since there is a @ sign in the user name so use lastIndexOf to get to the host separator @\n      end = location.lastIndexOf(HOST_SEPARATOR, location.length());\n      String user = null;\n      String password = null;\n      // if end is -1 then there is no host separator meaning that the username is not present\n      // or set in options of alternative-style location string\n      if (end != -1) {\n        // Get the optional user and password\n        user = location.substring(start, end);\n        // Separate the user and password (if there is a password)\n        start = user.indexOf(COLON);\n        if (start != -1) {\n          errorMessage = CVSMessages.CVSRepositoryLocation_parsingPassword;\n          password = user.substring(start + 1);\n          user = user.substring(0, start);\n        }\n        // Set start to point after the host separator\n        start = end + 1;\n      } else if (optionStart != -1) {\n        // alternative location string data\n        // errorMessage = CVSMessages.CVSRepositoryLocation_parsingOptionsUsername;\n        if (hmOptions.containsKey(\"username\"))\n          user = hmOptions.get(\"username\").toString(); // $NON-NLS-1$ //$NON-NLS-2$\n        // errorMessage = CVSMessages.CVSRepositoryLocation_parsingOptionsPassword;\n        if (hmOptions.containsKey(\"password\"))\n          password = hmOptions.get(\"password\").toString(); // $NON-NLS-1$ //$NON-NLS-2$\n      }\n\n      // Get the host (and port)\n      errorMessage = CVSMessages.CVSRepositoryLocation_parsingHost;\n      end = location.indexOf(COLON, start);\n      int hostEnd = end;\n      if (end == -1) {\n        // The last colon is optional so look for the slash that starts the path\n        end = location.indexOf('/', start);\n        hostEnd = end;\n        // Decrement the end since the slash is part of the path\n        if (end != -1) end--;\n      }\n      String host =\n          (hmOptions.containsKey(\"hostname\"))\n              ? hmOptions.get(\"hostname\").toString()\n              : location.substring(start, hostEnd); // $NON-NLS-1$ //$NON-NLS-2$\n      int port = USE_DEFAULT_PORT;\n      boolean havePort = false;\n      if (hmOptions.containsKey(\"port\")) { // $NON-NLS-1$\n        port = Integer.parseInt(hmOptions.get(\"port\").toString()); // $NON-NLS-1$\n        havePort = true;\n      }\n      // Separate the port and host if there is a port\n      start = host.indexOf(PORT_SEPARATOR);\n      if (start != -1) {\n        try {\n          // Initially, we used a # between the host and port\n          errorMessage = CVSMessages.CVSRepositoryLocation_parsingPort;\n          port = Integer.parseInt(host.substring(start + 1));\n          host = host.substring(0, start);\n          havePort = true;\n        } catch (NumberFormatException e) {\n          // Ignore this as the #1234 port could be part of a proxy host string\n        }\n      }\n      if (!havePort) {\n        // In the correct CVS format, the port follows the COLON\n        errorMessage = CVSMessages.CVSRepositoryLocation_parsingPort;\n        int index = end;\n        char c = location.charAt(++index);\n        String portString = new String();\n        while (Character.isDigit(c)) {\n          portString += c;\n          c = location.charAt(++index);\n        }\n        if (portString.length() > 0) {\n          end = index - 1;\n          port = Integer.parseInt(portString);\n        }\n      }\n\n      // Get the repository path (translating backslashes to slashes)\n      errorMessage = CVSMessages.CVSRepositoryLocation_parsingRoot;\n      start = end + 1;\n      String root = location.substring(start);\n\n      if (validateOnly) throw new CVSException(new CVSStatus(IStatus.OK, CVSMessages.ok)); //\n      return new CVSRepositoryLocation(\n          method,\n          user,\n          password,\n          host,\n          port,\n          root,\n          null /* encoding */,\n          (user != null),\n          (password != null));\n    } catch (IndexOutOfBoundsException e) {\n      // We'll get here if anything funny happened while extracting substrings\n      IStatus status = new CVSStatus(IStatus.ERROR, errorMessage);\n      throw new CVSException(status);\n    } catch (NumberFormatException e) {\n      IStatus status = new CVSStatus(IStatus.ERROR, errorMessage);\n      // We'll get here if we couldn't parse a number\n      throw new CVSException(status);\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9085, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String)"], "initializationStart": [769], "initializationEnd": [794], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 826, "focalAPIEnd": 840, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()", "parseInt(nextToken)"], "useStart": [953, 1007], "useEnd": [967, 1035], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/timabell/FreeTTS/tree/master/src/com/sun/speech/freetts/en/us/PronounceableFSM.java", "rawCode": "  /**\n   * Loads the ASCII specification of this FSM from the given InputStream.\n   *\n   * @param is the input stream to load from\n   * @throws IOException if an error occurs on input.\n   */\n  private void loadText(InputStream is) throws IOException {\n    BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n    String line = null;\n    while ((line = reader.readLine()) != null) {\n      if (!line.startsWith(\"***\")) {\n        if (line.startsWith(VOCAB_SIZE)) {\n          vocabularySize = parseLastInt(line);\n        } else if (line.startsWith(NUM_OF_TRANSITIONS)) {\n          int transitionsSize = parseLastInt(line);\n          transitions = new int[transitionsSize];\n        } else if (line.startsWith(TRANSITIONS)) {\n          StringTokenizer st = new StringTokenizer(line);\n          String transition = st.nextToken();\n          int i = 0;\n          while (st.hasMoreTokens() && i < transitions.length) {\n            transition = st.nextToken().trim();\n            transitions[i++] = Integer.parseInt(transition);\n          }\n        }\n      }\n    }\n    reader.close();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9086, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String,boolean)"], "initializationStart": [3844], "initializationEnd": [3888], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 3894, "guardExpressionEnd": 3920, "guardBlockStart": 3894, "guardBlockEnd": 4244, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 3940, "focalAPIEnd": 3954, "followUpCheck": "nextToken.equals(\"this_\")", "checkType": "IF", "followUpCheckExpressionStart": 3962, "followUpCheckExpressionEnd": 3984, "followUpCheckBlockStart": 3962, "followUpCheckBlockEnd": 4238, "use": ["StringBuffer.append(nextToken)"], "useStart": [4213], "useEnd": [4229], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/common-security-module/tree/master/software/upt/webapp/src/gov/nih/nci/security/upt/util/HibernateHelper.java", "rawCode": "  private static String modifySQLForGroup(\n      FilterClause filterClause, String generatedSQL, Session session, String peiTableOrViewName) {\n    String targetClassName = null;\n    if (StringUtils.isBlank(filterClause.getTargetClassAlias()))\n      targetClassName =\n          filterClause\n              .getTargetClassName()\n              .substring(0, filterClause.getTargetClassName().indexOf(\" - \"));\n    else targetClassName = filterClause.getTargetClassAlias();\n    String targetClassAttributeName = null;\n    if (StringUtils.isBlank(filterClause.getTargetClassAttributeAlias()))\n      targetClassAttributeName = filterClause.getTargetClassAttributeName();\n    else targetClassAttributeName = filterClause.getTargetClassAttributeAlias();\n\n    String CSM_QUERY =\n        \"SELECT Distinct pe.attribute_value \"\n            + \"FROM CSM_PROTECTION_GROUP pg, \"\n            + \" CSM_PROTECTION_ELEMENT pe, \"\n            + \" CSM_PG_PE pgpe,\"\n            + \" CSM_USER_GROUP_ROLE_PG ugrpg, \"\n            + \" CSM_GROUP g, \"\n            + \" CSM_ROLE_PRIVILEGE rp, \"\n            + \" CSM_ROLE r, \"\n            + \" CSM_PRIVILEGE p \"\n            + \"WHERE ugrpg.role_id = r.role_id \"\n            + \"AND ugrpg.group_id = g.group_id \"\n            + \"AND ugrpg.protection_group_id = ANY \"\n            + \"( select pg1.protection_group_id from csm_protection_group pg1 \"\n            + \" where pg1.protection_group_id = pg.protection_group_id OR pg1.protection_group_id = \"\n            + \" (select pg2.parent_protection_group_id from csm_protection_group pg2 where pg2.protection_group_id = pg.protection_group_id)\"\n            + \" ) \"\n            + \"AND pg.protection_group_id = pgpe.protection_group_id \"\n            + \"AND pgpe.protection_element_id = pe.protection_element_id \"\n            + \"AND r.role_id = rp.role_id \"\n            + \"AND rp.privilege_id = p.privilege_id \"\n            + \"AND pe.object_id= '\"\n            + targetClassName\n            + \"' \"\n            + \"AND p.privilege_name='READ' \"\n            + \"AND g.group_name IN (:GROUP_NAMES ) \"\n            + \"AND pe.application_id=:APPLICATION_ID\";\n\n    String CSM_QUERY_2 =\n        \"select upei.attribute_value from \"\n            + peiTableOrViewName\n            + \" upei where \"\n            + \"upei.group_name IN (:GROUP_NAMES) and upei.application_id =:APPLICATION_ID and upei.privilege_name='READ'\";\n\n    /*String CSM_QUERY = \" select pe.attribute_value from \" +\n    \"csm_protection_group pg, \" +\n    \"csm_protection_element pe, \" +\n    \"csm_pg_pe pgpe, \" +\n    \"csm_user_group_role_pg ugrpg, \" +\n    \"csm_user u, \" +\n    \"csm_role_privilege rp, \" +\n    \"csm_role r, \" +\n    \"csm_privilege p \" +\n    \"where ugrpg.role_id = r.role_id \" +\n    \"and ugrpg.user_id = u.user_id and \" +\n    \"ugrpg.protection_group_id = ANY \" +\n    \"(select pg1.protection_group_id \" +\n    \"from csm_protection_group pg1 \" +\n    \"where pg1.protection_group_id = pg.protection_group_id \" +\n    \"or pg1.protection_group_id = \" +\n    \"(select pg2.parent_protection_group_id \" +\n    \"from csm_protection_group pg2 \" +\n    \"where pg2.protection_group_id = pg.protection_group_id)) \" +\n    \"and pg.protection_group_id = pgpe.protection_group_id \" +\n    \"and pgpe.protection_element_id = pe.protection_element_id \" +\n    \"and r.role_id = rp.role_id \" +\n    \"and rp.privilege_id = p.privilege_id \" +\n    \"and pe.object_id= '\" + targetClassName + \"' \" +\n    \"and pe.attribute='\" + targetClassAttributeName + \"' \" +\n    \"and p.privilege_name='READ' \" +\n    \"and u.login_name=:USER_NAME \" +\n    \"and pe.application_id=:APPLICATION_ID\" ; */\n\n    StringBuffer result = new StringBuffer();\n    String query = generatedSQL.substring(generatedSQL.indexOf('-') + 1, generatedSQL.length());\n    query = query.trim();\n    query = query.substring(0, query.indexOf('?'));\n    String delimiters = \"+-*/(),. \";\n    StringTokenizer st = new StringTokenizer(query, delimiters, true);\n    while (st.hasMoreTokens()) {\n      String w = st.nextToken();\n      if (w.equals(\"this_\")) {\n        result = result.append(\"table_name_csm_\");\n      } else if (w.equals(\"y0_\")) {\n        result = result.append(\"\");\n      } else if (w.equals(\"as\")) {\n        result = result.append(\"\");\n      } else {\n        result = result.append(w);\n      }\n    }\n    SessionFactory sessionFactory = session.getSessionFactory();\n    ClassMetadata classMetadata = sessionFactory.getClassMetadata(filterClause.getClassName());\n    String columnName = null;\n    if (classMetadata instanceof AbstractEntityPersister) {\n      AbstractEntityPersister abstractEntityPersister = (AbstractEntityPersister) classMetadata;\n      String Id = abstractEntityPersister.getIdentifierPropertyName();\n      String[] columns = abstractEntityPersister.getPropertyColumnNames(Id);\n      columnName = columns[0];\n    }\n    if (!StringUtils.isBlank(peiTableOrViewName)) {\n      query = columnName + \" in (\" + result.toString() + CSM_QUERY_2 + \"))\";\n    } else {\n      query = columnName + \" in (\" + result.toString() + CSM_QUERY + \"))\";\n    }\n\n    return query.toString();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9087, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [880], "initializationEnd": [913], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 946, "guardExpressionEnd": 976, "guardBlockStart": 946, "guardBlockEnd": 1295, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1032, "focalAPIEnd": 1050, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new StringTokenizer(nextToken,String)"], "useStart": [1012], "useEnd": [1056], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bryanjimenez/empanada/tree/master/hadoop/hadoop-1.2.1/src/test/org/apache/hadoop/mapred/TestKillSubProcesses.java", "rawCode": "  /**\n   * Check for presence of the process with the pid passed is alive or not currently.\n   *\n   * @param pid pid of the process\n   * @return if a process is alive or not.\n   */\n  private static boolean isAlive(String pid) throws IOException {\n    String commandString = \"ps -o pid,command -e\";\n    String args[] = new String[] {\"bash\", \"-c\", commandString};\n    ShellCommandExecutor shExec = new ShellCommandExecutor(args);\n    try {\n      shExec.execute();\n    } catch (ExitCodeException e) {\n      return false;\n    } catch (IOException e) {\n      LOG.warn(\n          \"IOExecption thrown while checking if process is alive\"\n              + StringUtils.stringifyException(e));\n      throw e;\n    }\n\n    String output = shExec.getOutput();\n\n    // Parse the command output and check for pid, ignore the commands\n    // which has ps or grep in it.\n    StringTokenizer strTok = new StringTokenizer(output, \"\\n\");\n    boolean found = false;\n    while (strTok.hasMoreTokens()) {\n      StringTokenizer pidToken = new StringTokenizer(strTok.nextToken(), \" \");\n      String pidStr = pidToken.nextToken();\n      String commandStr = pidToken.nextToken();\n      if (pid.equals(pidStr) && !(commandStr.contains(\"ps\") || commandStr.contains(\"grep\"))) {\n        found = true;\n        break;\n      }\n    }\n    return found;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9088, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*,String)"], "initializationStart": [281], "initializationEnd": [329], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 338, "guardExpressionEnd": 365, "guardBlockStart": 338, "guardBlockEnd": 700, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 392, "focalAPIEnd": 407, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["nextToken.indexOf(char)", "nextToken.substring(int,int)", "nextToken.substring(*)"], "useStart": [424, 494, 542], "useEnd": [442, 517, 566], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/alevy/comet/tree/master/vuze/com/aelitis/azureus/core/networkmanager/impl/http/HTTPNetworkManager.java", "rawCode": "  protected String getPingPage(String url) {\n    int pos = url.indexOf(' ');\n\n    if (pos != -1) {\n\n      url = url.substring(0, pos);\n    }\n\n    pos = url.indexOf('?');\n\n    Map response = new HashMap();\n\n    boolean ok = false;\n\n    if (pos != -1) {\n\n      StringTokenizer tok = new StringTokenizer(url.substring(pos + 1), \"&\");\n\n      while (tok.hasMoreTokens()) {\n\n        String token = tok.nextToken();\n\n        pos = token.indexOf('=');\n\n        if (pos != -1) {\n\n          String lhs = token.substring(0, pos);\n          String rhs = token.substring(pos + 1);\n\n          if (lhs.equals(\"check\")) {\n\n            response.put(\"check\", rhs);\n\n            ok = true;\n          }\n        }\n      }\n    }\n\n    if (ok) {\n\n      try {\n        byte[] bytes = BEncoder.encode(response);\n\n        byte[] length = new byte[4];\n\n        ByteBuffer.wrap(length).putInt(bytes.length);\n\n        return (\"HTTP/1.1 200 OK\"\n            + NL\n            + \"Connection: Close\"\n            + NL\n            + \"Content-Length: \"\n            + (bytes.length + 4)\n            + NL\n            + NL\n            + new String(length, \"ISO-8859-1\")\n            + new String(bytes, \"ISO-8859-1\"));\n\n      } catch (Throwable e) {\n      }\n    }\n\n    return (getNotFound());\n  }\n"}, {"dataset": "nextToken", "exampleID": 9089, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 294, "focalAPIEnd": 309, "followUpCheck": "nextToken.equals(\"\")", "checkType": "IF", "followUpCheckExpressionStart": 315, "followUpCheckExpressionEnd": 338, "followUpCheckBlockStart": 315, "followUpCheckBlockEnd": 436, "use": ["stringTokenizer.nextToken()", "stringTokenizer.nextToken()"], "useStart": [512, 608], "useEnd": [527, 623], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/imr/Electric-VLSI/tree/master/electric/electric-core/src/main/java/com/sun/electric/tool/generator/PadGenerator.java", "rawCode": "  /**\n   * Process the export keyword\n   *\n   * @return true on success, false on error.\n   */\n  private boolean processExport(StringTokenizer str) {\n    String keyWord;\n    PadExports pe = new PadExports();\n    pe.lineno = lineno;\n    pe.padname = null;\n    pe.corename = null;\n\n    keyWord = str.nextToken();\n    if (keyWord.equals(\"\")) {\n      System.out.println(\"Line \" + lineno + \": missing 'cell' name\");\n      return false;\n    }\n    pe.cellname = keyWord;\n\n    if (str.hasMoreTokens()) {\n      keyWord = str.nextToken();\n      pe.padname = keyWord;\n      if (str.hasMoreTokens()) {\n        keyWord = str.nextToken();\n        pe.corename = keyWord;\n      }\n    }\n    exports.put(pe.cellname, pe);\n    return true;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9090, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [1102], "initializationEnd": [1150], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 1173, "focalAPIEnd": 1187, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["put(nextToken,*)"], "useStart": [1158], "useEnd": [1214], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/concord-consortium/geogebra/tree/master/geogebra/org/neuroph/easyneurons/imgrec/ImagesLoader.java", "rawCode": "  /**\n   * Loads images from the specified dir, scales to specified resolution and creates RGB data for\n   * each image Puts RGB data in a Map using filenames as keys, and rerurns that amp\n   *\n   * @param imgDir\n   * @param samplingResolution\n   * @return\n   * @throws java.io.IOException\n   */\n  public static Map<String, FractionRgbData> getFractionRgbDataForDirectory(\n      File imgDir, Dimension samplingResolution) throws IOException {\n    if (!imgDir.isDirectory()) {\n      throw new IOException(\"The given file must be a directory. Argument is: \" + imgDir);\n    }\n\n    Map<String, FractionRgbData> rgbDataMap = new HashMap<String, FractionRgbData>();\n\n    ImagesIterator imagesIterator = new ImagesIterator(imgDir);\n    while (imagesIterator.hasNext()) {\n      BufferedImage img = imagesIterator.next();\n      img = ImageSampler.downSampleImage(samplingResolution, img);\n      String filenameOfCurrentImage = imagesIterator.getFilenameOfCurrentImage();\n      // System.out.println(filenameOfCurrentImage + \" is: \" + img.getWidth() + \"x\" +\n      // img.getHeight());\n      StringTokenizer st = new StringTokenizer(filenameOfCurrentImage, \".\");\n      rgbDataMap.put(st.nextToken(), new FractionRgbData(img));\n    }\n    return rgbDataMap;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9091, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*,String)"], "initializationStart": [340], "initializationEnd": [409], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 415, "guardExpressionEnd": 441, "guardBlockStart": 415, "guardBlockEnd": 511, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 466, "focalAPIEnd": 480, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["addVisibilities(nextToken,Set<EntityPortion>,Set<VisibilityModifier>)"], "useStart": [450], "useEnd": [504], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7930/src/net/sourceforge/plantuml/classdiagram/command/CommandHideShow3.java", "rawCode": "  @Override\n  protected CommandExecutionResult executeArg(Map<String, RegexPartialMatch> arg) {\n\n    final Set<EntityPortion> portion = getEntityPortion(arg.get(\"PORTION\").get(0));\n\n    final Set<VisibilityModifier> visibilities =\n        EnumSet.<VisibilityModifier>noneOf(VisibilityModifier.class);\n    final StringTokenizer st =\n        new StringTokenizer(arg.get(\"VISIBILITY\").get(0).toLowerCase(), \" ,\");\n    while (st.hasMoreTokens()) {\n      addVisibilities(st.nextToken(), portion, visibilities);\n    }\n\n    getSystem().hideOrShow(visibilities, arg.get(\"COMMAND\").get(0).equalsIgnoreCase(\"show\"));\n\n    return CommandExecutionResult.ok();\n  }\n"}, {"dataset": "nextToken", "exampleID": 9092, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [98], "initializationEnd": [128], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(stringTokenizer.countTokens()!=2)", "guardType": "IF {", "guardExpressionStart": 136, "guardExpressionEnd": 162, "guardBlockStart": 136, "guardBlockEnd": 241, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 276, "focalAPIEnd": 290, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(nextToken)", "stringTokenizer.nextToken()", "parseInt(nextToken)"], "useStart": [259, 325, 308], "useEnd": [291, 339, 340], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop/hadoop-1.1.2/src/test/org/apache/hadoop/io/file/tfile/TestTFileSeek.java", "rawCode": "    public static IntegerRange parse(String s) throws ParseException {\n      StringTokenizer st = new StringTokenizer(s, \" \\t,\");\n      if (st.countTokens() != 2) {\n        throw new ParseException(\"Bad integer specification: \" + s);\n      }\n      int from = Integer.parseInt(st.nextToken());\n      int to = Integer.parseInt(st.nextToken());\n      return new IntegerRange(from, to);\n    }\n"}, {"dataset": "nextToken", "exampleID": 9093, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*,String)"], "initializationStart": [254], "initializationEnd": [307], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 313, "guardExpressionEnd": 339, "guardBlockStart": 313, "guardBlockEnd": 380, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 358, "focalAPIEnd": 372, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(nextToken)"], "useStart": [348], "useEnd": [373], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop_src/hadoop-2.0.5-alpha-src/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/lib/MultipleOutputs.java", "rawCode": "  /**\n   * Returns list of channel names.\n   *\n   * @param conf job conf\n   * @return List of channel Names\n   */\n  public static List<String> getNamedOutputsList(JobConf conf) {\n    List<String> names = new ArrayList<String>();\n    StringTokenizer st = new StringTokenizer(conf.get(NAMED_OUTPUTS, \"\"), \" \");\n    while (st.hasMoreTokens()) {\n      names.add(st.nextToken());\n    }\n    return names;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9094, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [503], "initializationEnd": [534], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 540, "guardExpressionEnd": 600, "guardBlockStart": 540, "guardBlockEnd": 645, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 617, "focalAPIEnd": 638, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/OSEHRA/Blue-Button-Document-Adapter/tree/master/integration/integration-regex/src/main/java/org/osehra/das/common/string/StringUtil.java", "rawCode": "  /**\n   * Gets the token in a delimited string in the specified position.\n   *\n   * @param str - The string.\n   * @param pos - The position identifying the token.\n   * @param delim - The delimiter used to tokenize the string.\n   * @return String - the located String\n   * @deprecated - use substring(String,index,delimiter) instead.\n   */\n  @Deprecated\n  public static String getToken(final String str, final int pos, final String delim) {\n    String token = str;\n    final StringTokenizer tokenizer = new StringTokenizer(str, delim);\n    for (int i = 0; (i < pos) && tokenizer.hasMoreTokens(); i++) {\n      token = tokenizer.nextToken();\n    }\n    return token;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9095, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,*)"], "initializationStart": [149], "initializationEnd": [194], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 200, "guardExpressionEnd": 227, "guardBlockStart": 200, "guardBlockEnd": 340, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 243, "focalAPIEnd": 258, "followUpCheck": "findNativeLibrary(nextToken,libName)", "checkType": "IF", "followUpCheckExpressionStart": 266, "followUpCheckExpressionEnd": 303, "followUpCheckBlockStart": 266, "followUpCheckBlockEnd": 334, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hyperic/sigar/tree/master/bindings/java/hyperic_jni/src/org/hyperic/jni/ArchLoader.java", "rawCode": "  protected boolean findInJavaLibraryPath(String libName) {\n    String path = System.getProperty(\"java.library.path\", \"\");\n    StringTokenizer tok = new StringTokenizer(path, File.pathSeparator);\n    while (tok.hasMoreTokens()) {\n      path = tok.nextToken();\n      if (findNativeLibrary(path, libName)) {\n        return true;\n      }\n    }\n    return false;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9096, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [263], "initializationEnd": [327], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["stringTokenizer.countTokens()"], "configurationStart": [386], "configurationEnd": [409], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 420, "guardExpressionEnd": 453, "guardBlockStart": 420, "guardBlockEnd": 584, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 474, "focalAPIEnd": 495, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["stringTokenizer.nextToken()", "put(nextToken,*)", "stringTokenizer.countTokens()", "stringTokenizer.nextToken()", "stringTokenizer.nextToken()", "put(nextToken,*)"], "useStart": [555, 534, 855, 943, 1028, 1003], "useEnd": [576, 577, 878, 964, 1049, 1050], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/dltk.core/tree/master/core/plugins/org.eclipse.dltk.ui/src/org/eclipse/dltk/internal/ui/text/hover/EditorTextHoverDescriptor.java", "rawCode": "  private static void initializeFromPreferences(\n      EditorTextHoverDescriptor[] hovers, IPreferenceStore store) {\n    String compiledTextHoverModifiers =\n        store.getString(PreferenceConstants.EDITOR_TEXT_HOVER_MODIFIERS);\n    StringTokenizer tokenizer = new StringTokenizer(compiledTextHoverModifiers, VALUE_SEPARATOR);\n    HashMap<String, String> idToModifier = new HashMap<>(tokenizer.countTokens() / 2);\n    while (tokenizer.hasMoreTokens()) {\n      String id = tokenizer.nextToken();\n      if (tokenizer.hasMoreTokens()) idToModifier.put(id, tokenizer.nextToken());\n    }\n    String compiledTextHoverModifierMasks =\n        store.getString(PreferenceConstants.EDITOR_TEXT_HOVER_MODIFIER_MASKS);\n    tokenizer = new StringTokenizer(compiledTextHoverModifierMasks, VALUE_SEPARATOR);\n    HashMap<String, String> idToModifierMask = new HashMap<>(tokenizer.countTokens() / 2);\n    while (tokenizer.hasMoreTokens()) {\n      String id = tokenizer.nextToken();\n      if (tokenizer.hasMoreTokens()) idToModifierMask.put(id, tokenizer.nextToken());\n    }\n    for (int i = 0; i < hovers.length; i++) {\n      String modifierString = idToModifier.get(hovers[i].getId());\n      boolean enabled = true;\n      if (modifierString == null) modifierString = DISABLED_TAG;\n      if (modifierString.startsWith(DISABLED_TAG)) {\n        enabled = false;\n        modifierString = modifierString.substring(1);\n      }\n      if (modifierString.equals(NO_MODIFIER)) modifierString = \"\"; // $NON-NLS-1$\n      hovers[i].fModifierString = modifierString;\n      hovers[i].fIsEnabled = enabled;\n      hovers[i].fStateMask = computeStateMask(modifierString);\n      if (hovers[i].fStateMask == -1) {\n        // Fallback: use stored modifier masks\n        try {\n          hovers[i].fStateMask = Integer.parseInt(idToModifierMask.get(hovers[i].getId()));\n        } catch (NumberFormatException ex) {\n          hovers[i].fStateMask = -1;\n        }\n        // Fix modifier string\n        int stateMask = hovers[i].fStateMask;\n        if (stateMask == -1) hovers[i].fModifierString = \"\"; // $NON-NLS-1$\n        else hovers[i].fModifierString = EditorUtility.getModifierString(stateMask);\n      }\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9097, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*)"], "initializationStart": [506], "initializationEnd": [551], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreElements()", "guardType": "LOOP {", "guardExpressionStart": 559, "guardExpressionEnd": 587, "guardBlockStart": 559, "guardBlockEnd": 646, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 622, "focalAPIEnd": 636, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(nextToken)"], "useStart": [598], "useEnd": [637], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/florhaf/ravent/tree/master/service/lib/restlet-gae-2.0.10/src/org.restlet/org/restlet/engine/security/SslUtils.java", "rawCode": "  /**\n   * Returns the list of enabled cipher suites.\n   *\n   * @param helper The helper to use.\n   * @return The list of enabled cipher suites.\n   */\n  public static String[] getEnabledCipherSuites(RestletHelper<?> helper) {\n    List<String> enabledCipherSuites = new ArrayList<String>();\n    String[] enabledCipherSuitesParams =\n        helper.getHelpedParameters().getValuesArray(\"enabledCipherSuites\");\n    for (String enabledCipherSuitesParam : enabledCipherSuitesParams) {\n      StringTokenizer st = new StringTokenizer(enabledCipherSuitesParam);\n      while (st.hasMoreElements()) {\n        enabledCipherSuites.add(st.nextToken());\n      }\n    }\n    return enabledCipherSuites.size() > 0 ? enabledCipherSuites.toArray(new String[0]) : null;\n  }\n"}, {"dataset": "nextToken", "exampleID": 9098, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [466], "initializationEnd": [497], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "stringTokenizer.hasMoreTokens()", "guardType": "LOOP {", "guardExpressionStart": 653, "guardExpressionEnd": 683, "guardBlockStart": 653, "guardBlockEnd": 1162, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 702, "focalAPIEnd": 720, "followUpCheck": "nextToken.toUpperCase().compareTo(\"REQUEST=GETCAPABILITIES\") == 0", "checkType": "IF", "followUpCheckExpressionStart": 738, "followUpCheckExpressionEnd": 804, "followUpCheckBlockStart": 738, "followUpCheckBlockEnd": 814, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gvtools/gvtools-legacy/tree/master/libraries/libRemoteServices/src/org/gvsig/remoteClient/wcs/WCSProtocolHandler.java", "rawCode": "  /**\n   * Builds the GetCapabilitiesRequest according to the OGC WCS Specifications without a VERSION, to\n   * get the highest version than a WCS supports.\n   */\n  public static String buildCapabilitiesSuitableVersionRequest(String _host, String _version) {\n    int index = _host.indexOf('?');\n\n    if (index > -1) {\n      String host = _host.substring(0, index + 1);\n      String query = _host.substring(index + 1, _host.length());\n\n      StringTokenizer tokens = new StringTokenizer(query, \"&\");\n      String newQuery = \"\", token;\n\n      // If there is a field or a value with spaces, (and then it's on\n      // different tokens) -> unify them\n      while (tokens.hasMoreTokens()) {\n        token = tokens.nextToken().trim();\n\n        if (token.toUpperCase().compareTo(\"REQUEST=GETCAPABILITIES\") == 0) continue;\n\n        if (token.toUpperCase().compareTo(\"SERVICE=WCS\") == 0) continue;\n\n        if ((_version != null) && (_version.length() > 0)) {\n          if (token.toUpperCase().compareTo(\"VERSION=\" + _version) == 0) continue;\n        }\n\n        if (token.toUpperCase().compareTo(\"EXCEPTIONS=XML\") == 0) continue;\n\n        newQuery += token + \"&\";\n      }\n\n      _host = host + newQuery;\n    } else {\n      _host += \"?\";\n    }\n\n    if ((_version != null) && (_version.compareTo(\"\") != 0))\n      _host += \"REQUEST=GetCapabilities&SERVICE=WCS&VERSION=\" + _version + \"&EXCEPTIONS=XML\";\n    else _host += \"REQUEST=GetCapabilities&SERVICE=WCS&EXCEPTIONS=XML\";\n\n    return _host.replaceAll(\" \", \"%20\");\n  }\n"}, {"dataset": "nextToken", "exampleID": 9099, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(String,String)"], "initializationStart": [51], "initializationEnd": [78], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 109, "focalAPIEnd": 123, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseLong(nextToken)", "stringTokenizer.nextToken()", "parseLong(nextToken)"], "useStart": [94, 155, 140], "useEnd": [124, 169, 170], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/andrden/simple-agent/tree/master/src/reinforcement/worlds/MazeWorld.java", "rawCode": "  public void println() {\n    StringTokenizer st = new StringTokenizer(s, \"_\");\n    long sx = Long.parseLong(st.nextToken());\n    long sy = Long.parseLong(st.nextToken());\n    for (int y = 1; y <= 6; y++) {\n      for (int x = 1; x <= 9; x++) {\n        char c = '.';\n        if (x == 6 && y == 4) c = 'S';\n        if (x == 9 && y == 1) c = 'F';\n        if (x == sx && y == sy) c = '*';\n        System.out.print(c);\n      }\n      System.out.println();\n    }\n  }\n"}, {"dataset": "nextToken", "exampleID": 9100, "initialization": ["StringTokenizer stringTokenizer = new StringTokenizer(*)"], "initializationStart": [203], "initializationEnd": [245], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(String,*)", "getMessage()", "new CommandResponse(int,*)"], "tryExpressionStart": 389, "tryExpressionEnd": 393, "tryBlockStart": 389, "tryBlockEnd": 605, "catchExpressionStart": 497, "catchExpressionEnd": 517, "catchBlockStart": 497, "catchBlockEnd": 605, "exceptionHandlingCallStart": [525, 583, 558], "exceptionHandlingCallEnd": [543, 597, 598], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "nextToken = stringTokenizer.nextToken()", "focalAPIStart": 474, "focalAPIEnd": 488, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getUserByName(nextToken)"], "useStart": [410], "useEnd": [489], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tdsoul/drftpd/tree/master/src/plugins/org.drftpd.commands.usermanagement/src/org/drftpd/commands/usermanagement/UserManagementHandler.java", "rawCode": "  public CommandResponse doSITE_UNBAN(CommandRequest request) throws ImproperUsageException {\n\n    if (!request.hasArgument()) {\n      throw new ImproperUsageException();\n    }\n\n    StringTokenizer st = new StringTokenizer(request.getArgument());\n\n    if (!st.hasMoreTokens()) {\n      return StandardCommandManager.genericResponse(\"RESPONSE_501_SYNTAX_ERROR\");\n    }\n\n    User myUser;\n    try {\n      myUser = GlobalContext.getGlobalContext().getUserManager().getUserByName(st.nextToken());\n    } catch (Exception e) {\n      logger.warn(\"\", e);\n      return new CommandResponse(200, e.getMessage());\n    }\n\n    myUser.getKeyedMap().setObject(UserManagement.BAN_TIME, new Date());\n    myUser.getKeyedMap().setObject(UserManagement.BAN_REASON, \"\");\n\n    myUser.commit();\n\n    return StandardCommandManager.genericResponse(\"RESPONSE_200_COMMAND_OK\");\n  }\n"}]