[{"dataset": "parseDouble", "exampleID": 1601, "initialization": ["String s = __characters()"], "initializationStart": [435], "initializationEnd": [449], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 552, "focalAPIEnd": 585, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/samthiriot/genlab/tree/master/genlab.graphstream.corejar/src/org/graphstream/stream/file/FileSourceGPX.java", "rawCode": "    /**\n     *\n     *\n     * <pre>\n     * name : AGEOFDGPSDATA\n     * attributes :\n     * structure : double\n     * </pre>\n     *\n     * @throws IOException\n     * @throws XMLStreamException\n     */\n    private double __ageofdgpsdata() throws IOException, XMLStreamException {\n      String ageofdgpsdata;\n      XMLEvent e;\n\n      e = getNextEvent();\n      checkValid(e, XMLEvent.START_ELEMENT, \"ageofdgpsdata\");\n\n      ageofdgpsdata = __characters();\n\n      e = getNextEvent();\n      checkValid(e, XMLEvent.END_ELEMENT, \"ageofdgpsdata\");\n\n      return Double.parseDouble(ageofdgpsdata);\n    }\n"}, {"dataset": "parseDouble", "exampleID": 1602, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1575, "focalAPIEnd": 1604, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["pow(int,val)"], "useStart": [1562], "useEnd": [1605], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vipints/oqtans/tree/master/oqtans_tools/Trinity/r2013_08_14/Butterfly/src/src/IsoformExpressionLearning.java", "rawCode": "  /**\n   * given the reads to transcript mapping, and theta, calc E_Nt: (which basically calcs the\n   * posterior) $$E(N_t) = \\sum_i \\frac{ P(r_i | t)\\cdot \\theta_t} {\\sum_{t'} P(r_i | t')\\cdot\n   * \\theta_{t'}}$$\n   *\n   * @param string\n   * @param theta\n   * @return\n   */\n  private static Vector<Double> calcE_Nt(\n      String file,\n      Vector<Double> theta,\n      HashMap<String, Integer> transcriptIndices,\n      Vector<Double> likeTerm2)\n      throws IOException {\n    int numT = theta.size();\n    Vector<Double> E_Nt = new Vector<Double>();\n    initVecToZero(E_Nt, numT);\n    BufferedReader fileB = new BufferedReader(new FileReader(file));\n    String l, read, trans;\n    Double prob;\n\n    Vector<Double> tmpPerReadName = new Vector<Double>();\n    initVecToZero(tmpPerReadName, numT);\n    String prevRead = \"\";\n    while (fileB.ready()) {\n\n      l = fileB.readLine();\n      // 61G9EAAXX100520:5:100:10000:5699\n      // comp3190_c716_seq2_FPKM_all:11.742_FPKM_rel:2.677_len:2401_path:[40631,40349,40358,2726]\n      // 376-444 558-444 -0.0305\n      // 61G9EAAXX100520:5:100:10000:5699\n      // comp3190_c716_seq4_FPKM_all:13.841_FPKM_rel:6.304_len:2888_path:[0,40349,40358,2726]\n      // 863-931 1045-931 -0.0305\n      // 61G9EAAXX100520:5:100:10000:7578\n      // comp754_c304_seq1_FPKM_all:27.333_FPKM_rel:2.886_len:901_path:[28182,65285,65293,65295,517,535,538,1140,1147,1289] 417-485 535-485 -0.0111\n      // readName transName locRead2 locRead2 prob\n      String[] fields = l.split(\"\\t\");\n      read = fields[0];\n      trans = fields[1];\n      prob = Math.pow(10, Double.parseDouble(fields[4]));\n\n      int t_id = transcriptIndices.get(trans);\n\n      if (read.equals(prevRead)) {\n        // deal with this read\n        tmpPerReadName.set(t_id, tmpPerReadName.get(t_id) + prob);\n\n      } else {\n        // new read, close the prevRead\n        if (!prevRead.equals(\"\")) {\n          // tmpPerReadName holds now P(r_i | T)\n          likeTerm2.set(0, likeTerm2.get(0) + sumLogVector(tmpPerReadName));\n\n          dotMultiply(tmpPerReadName, theta);\n          normVector(tmpPerReadName);\n\n          addToVector(E_Nt, tmpPerReadName);\n\n          // prepare for the next read\n          initVecToZero(tmpPerReadName, numT);\n        }\n        // deal with this read\n        tmpPerReadName.set(t_id, tmpPerReadName.get(t_id) + prob);\n\n        prevRead = read;\n      }\n    }\n\n    // handle the last read\n    // tmpPerReadName holds now P(r_i | T)\n    likeTerm2.set(0, likeTerm2.get(0) + sumLogVector(tmpPerReadName));\n\n    dotMultiply(tmpPerReadName, theta);\n    normVector(tmpPerReadName);\n\n    addToVector(E_Nt, tmpPerReadName);\n\n    return E_Nt;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1603, "initialization": ["String s = StringTokenizer.nextToken()"], "initializationStart": [1292], "initializationEnd": [1309], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1326, "focalAPIEnd": 1363, "followUpCheck": "val < 0", "checkType": "IF", "followUpCheckExpressionStart": 1369, "followUpCheckExpressionEnd": 1379, "followUpCheckBlockStart": 1369, "followUpCheckBlockEnd": 1444, "use": ["valueOf(val)", "double.parseDouble(*)", "double.parseDouble(*)", "double.parseDouble(String)", "double.parseDouble(String)", "double.parseDouble(*)", "double.parseDouble(*)", "new UncertainDouble(val,double,String)"], "useStart": [1425, 1460, 1514, 1693, 1959, 2192, 2247, 2363], "useEnd": [1442, 1497, 1551, 1714, 1980, 2229, 2284, 2403], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/GreenGroup/RMG-Java/tree/master/source/RMG/jing/chemParser/ChemParser.java", "rawCode": "  /**\n   * This function is called when reading a kinetics Library.txt file, if the kinetics tag is\n   * Arrhenius. As of today, no rxn families in the RMG database are labeled Arrhenius. Instead of\n   * passing only the information after the node(s), i.e. Trange, A, n, Ea, etc., the entire data\n   * entry is passed. The string p_string contains the entire line of data (including the randomly\n   * assigned number and node(s)). The integer p_keyNum contains the number of nodes associated with\n   * this data entry (e.g. 1 for Beta_Scission, 2 for H_Abstraction, 3 for Diels_Alder_Addition,\n   * etc.). The output is of type ArrheniusKinetics. The \"source\" contains the set of nodes\n   * associated with this data, and the \"comments\" are the end-of-line comments, hopefully denoting\n   * where this data came from.\n   */\n  public static ArrheniusKinetics parseArrheniusKinetics(String p_string, int p_keyNum) {\n    StringTokenizer token = new StringTokenizer(p_string);\n    String dummyCounter = token.nextToken(); // This should be the #. associated with the data\n    // Set the source of this data as the set of nodes\n    String source = \"\";\n    for (int i = 0; i < p_keyNum - 1; i++) {\n      source += token.nextToken() + \" \";\n    }\n    source += token.nextToken();\n    String TRange = token.nextToken();\n    double A = Double.parseDouble(token.nextToken());\n    if (A < 0) throw new NegativeAException(\"Negative A:\" + String.valueOf(A));\n    double n = Double.parseDouble(token.nextToken());\n    double E = Double.parseDouble(token.nextToken());\n    double DA = 1;\n    String s = token.nextToken();\n    if (s.startsWith(\"*\")) {\n      s = s.substring(1, s.length());\n      DA = Math.abs(Double.parseDouble(s));\n      if (DA < 1)\n        throw new InvalidUncertaintyException(\n            \"Multiplier Uncertainty of A (<1): \" + String.valueOf(DA));\n    } else {\n      // if not multiplier uncertain, transfer it into multiplier for A\n      DA = Math.abs(Double.parseDouble(s));\n      if (DA == 0) DA = 1;\n      else if (DA > A)\n        throw new NegativeAException(\"lower bound of A(<0): \" + String.valueOf(A - DA));\n      else {\n        DA = A / (A - DA);\n      }\n    }\n    double Dn = Double.parseDouble(token.nextToken());\n    double DE = Double.parseDouble(token.nextToken());\n    int rank = Integer.parseInt(token.nextToken());\n    UncertainDouble ua = new UncertainDouble(A, DA, \"Multiplier\");\n    UncertainDouble un = new UncertainDouble(n, Dn, \"Adder\");\n    UncertainDouble ue = new UncertainDouble(E, DE, \"Adder\");\n    // Set the comments of this data to whatever (if anything) follows the rank\n    String comments = \"\";\n    while (token.hasMoreTokens()) comments += token.nextToken() + \" \";\n    ArrheniusKinetics k = new ArrheniusKinetics(ua, un, ue, TRange, rank, source, comments);\n    return k;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1604, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["floatParseException(*)"], "tryExpressionStart": 670, "tryExpressionEnd": 674, "tryBlockStart": 670, "tryBlockEnd": 865, "catchExpressionStart": 786, "catchExpressionEnd": 818, "catchBlockStart": 786, "catchBlockEnd": 865, "exceptionHandlingCallStart": [834], "exceptionHandlingCallEnd": [856], "configuration": ["s.startsWith(String)"], "configurationStart": [420], "configurationEnd": [448], "guardCondition": "!(s.equalsIgnoreCase(\"nan\",)) && !(DOUBLE_INFINITY.matcher(s,).matches())", "guardType": "IF {", "guardExpressionStart": 338, "guardExpressionEnd": 390, "guardBlockStart": 338, "guardBlockEnd": 557, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 700, "focalAPIEnd": 732, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/protostuff/tree/master/protostuff-benchmark/src/main/java/com/google/protobuf/JsonFormat.java", "rawCode": "    /**\n     * If the next token is a double, consume it and return its value. Otherwise, throw a {@link\n     * ParseException}.\n     */\n    public double consumeDouble() throws ParseException {\n      // We need to parse infinity and nan separately because\n      // Double.parseDouble() does not accept \"inf\", \"infinity\", or \"nan\".\n      if (DOUBLE_INFINITY.matcher(currentToken).matches()) {\n        boolean negative = currentToken.startsWith(\"-\");\n        nextToken();\n        return negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n      }\n      if (currentToken.equalsIgnoreCase(\"nan\")) {\n        nextToken();\n        return Double.NaN;\n      }\n      try {\n        double result = Double.parseDouble(currentToken);\n        nextToken();\n        return result;\n      } catch (NumberFormatException e) {\n        throw floatParseException(e);\n      }\n    }\n"}, {"dataset": "parseDouble", "exampleID": 1605, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 113, "focalAPIEnd": 138, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cytoscape/cytoscape-impl/tree/master/io-impl/impl/src/main/java/org/cytoscape/io/internal/read/xgmml/handler/XGMMLParseUtil.java", "rawCode": "  public static double parseDocumentVersion(String value) {\n    double version = 0.0;\n\n    try {\n      version = Double.parseDouble(value);\n    } catch (Exception nfe) {\n    }\n\n    return version;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1606, "initialization": ["String s = HttpServletRequest.getParameter(String)"], "initializationStart": [529], "initializationEnd": [560], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["Logger.severe(String)"], "tryExpressionStart": 494, "tryExpressionEnd": 498, "tryBlockStart": 494, "tryBlockEnd": 729, "catchExpressionStart": 646, "catchExpressionEnd": 678, "catchBlockStart": 646, "catchBlockEnd": 729, "exceptionHandlingCallStart": [686], "exceptionHandlingCallEnd": [722], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s!=null", "guardType": "IF {", "guardExpressionStart": 568, "guardExpressionEnd": 594, "guardBlockStart": 568, "guardBlockEnd": 639, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 605, "focalAPIEnd": 638, "followUpCheck": "val == 0", "checkType": "IF", "followUpCheckExpressionStart": 2023, "followUpCheckExpressionEnd": 2040, "followUpCheckBlockStart": 2023, "followUpCheckBlockEnd": 3112, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hellonoam/8cookies/tree/master/bfc backend google app engine/src/backend/ReceiveData.java", "rawCode": "  public void doGet(HttpServletRequest request, HttpServletResponse response)\n      throws IOException, ServletException {\n    logger.severe(\"inside do get\");\n    // reading the params in this request\n    // reading the cookies as json\n    String reqString = request.getParameter(\"dataFromClient\");\n    String username = request.getParameter(\"user\");\n    String password = request.getParameter(\"pass\");\n    double version = 0;\n    // reading version number and raising exception if missing\n    try {\n      String versionString = request.getParameter(\"version\");\n      if (versionString != null) version = Double.parseDouble(versionString);\n    } catch (NumberFormatException e) {\n      logger.severe(\"version was missing\");\n    }\n    // setting serial to be -1 or the serial received. if serial isn't received, an old version\n    // of the extension made this request. shouldn't happen\n    int serial = -1;\n    logger.severe(\"got request from: \" + username + \" version: \" + version);\n    try {\n      serial = Integer.parseInt(request.getParameter(\"serial\"));\n    } catch (NumberFormatException e) {\n      response.sendError(\n          HttpServletResponse.SC_CONFLICT,\n          \"serial conflict - serial missing\" + \" - update was rejected\");\n      return;\n    }\n\n    logger.fine(\"serial \" + serial);\n    // authenticates users\n    AuthenticationResponse auth = DatabaseInteraction.authenticate(username, password);\n    if (auth.getResponseType() == AuthenticationResponse.BLOCKED) {\n      response.sendError(\n          HttpServletResponse.SC_FORBIDDEN,\n          \"wrong passwrod too many times wait:\" + auth.getWaitTime());\n      logger.fine(\"wrong passwrod too many times\");\n      return;\n    }\n    if (auth.getResponseType() != AuthenticationResponse.VALID) {\n      response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"received incorrect credentials\");\n      logger.fine(\"received incorrect credentials\");\n      return;\n    }\n    // user has been authenticated\n    User u = DatabaseInteraction.getUser(username);\n    if (version == 0) u.setSerial(-1);\n    else if (u.getSerial() == -1) u.setSerial(serial);\n    else if (serial != u.getSerial()) { // CONFLICT!!\n      u.setSerial(serial);\n      // saves user to db after serial has been updated\n      boolean succ = DatabaseInteraction.updateOrSaveUser(u);\n      if (!succ) logger.severe(\"failed to update serial of user\");\n      String infoString = u.getInfo();\n      if (infoString != null && !infoString.equals(\"\")) {\n        JSONObject jsonResponse = DatabaseInteraction.newJSONInstance();\n        try {\n          // sends needed information to the server\n          jsonResponse.append(\"info\", u.getInfo());\n          jsonResponse.append(\"salt\", u.getSalt());\n          response.setContentType(\"text/html\");\n          PrintWriter out = response.getWriter();\n          // sends the users the updated browsing session\n          out.println(jsonResponse);\n          out.close();\n        } catch (JSONException e) {\n          e.printStackTrace();\n          logger.severe(\"failed to send info to client after conflict\");\n        }\n      }\n      return;\n    }\n    // no conflict\n    u.setInfo(reqString);\n    logger.fine(\"updated data of existing user\");\n    if (DatabaseInteraction.updateOrSaveUser(u)) {\n      response.setContentType(\"text/html\");\n      PrintWriter out = response.getWriter();\n      // sends message to client that the info has been received successfully\n      out.println(\"received\");\n      out.close();\n      logger.fine(\"data received successfully\");\n    } else {\n      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"faild to update/save user\");\n      logger.severe(\"ERROR: failed to update/save user\");\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1607, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 310, "focalAPIEnd": 344, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)"], "useStart": [366], "useEnd": [400], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/th365thli/SLogo/tree/master/src/behavior/TwoParameterCommand.java", "rawCode": "  @Override\n  public void initialize(String[] information, Model model) throws SyntaxException {\n    if (information.length != 2\n        || !myNumPattern.matcher(information[0]).matches()\n        || !myNumPattern.matcher(information[1]).matches()) {\n      throw new SyntaxException();\n    }\n    myFirstValue = Double.parseDouble(information[0]);\n    mySecondValue = Double.parseDouble(information[1]);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1608, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getAbsolutePath()", "new SimulationDataException(String,*)"], "tryExpressionStart": 171, "tryExpressionEnd": 175, "tryBlockStart": 171, "tryBlockEnd": 2009, "catchExpressionStart": 1687, "catchExpressionEnd": 1709, "catchBlockStart": 1687, "catchBlockEnd": 1829, "exceptionHandlingCallStart": [1792, 1723], "exceptionHandlingCallEnd": [1818, 1822], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s.startsWith(\"//\",))&&s.trim().length()>0 && (s)!=null&&s.length()>0", "guardType": "LOOP {", "guardExpressionStart": 528, "guardExpressionEnd": 599, "guardBlockStart": 528, "guardBlockEnd": 1199, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 705, "focalAPIEnd": 733, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pgleeson/TempRepo2/tree/master/src/ucl/physiol/neuroconstruct/simulation/SimulationData.java", "rawCode": "  private double[] readDataFileToArray(File dataFile, double scaleFactor)\n      throws SimulationDataException {\n    String nextLine = null;\n    double[] data = null;\n    try {\n      Reader in = new FileReader(dataFile);\n      LineNumberReader reader = new LineNumberReader(in);\n\n      /** @todo check if there's a quicker way to do this */\n\n      // ArrayList<Double> tempList = new ArrayList<Double>(suggestedInitCapData);\n      double[] tempArray = new double[suggestedInitCapData];\n\n      int numDataPointsAdded = 0;\n\n      while ((nextLine = reader.readLine()) != null && nextLine.length() > 0) {\n        if (!nextLine.startsWith(\"//\") && nextLine.trim().length() > 0) {\n          double nextEntry = Double.parseDouble(nextLine);\n          if (tempArray.length <= numDataPointsAdded) {\n            double[] tempArray2 = new double[numDataPointsAdded * 2];\n            logger.logComment(\"Rescaling array of data points to size: \" + tempArray2.length);\n            System.arraycopy(tempArray, 0, tempArray2, 0, numDataPointsAdded);\n            tempArray = tempArray2;\n          }\n          tempArray[numDataPointsAdded] = scaleFactor * nextEntry;\n          numDataPointsAdded++;\n        }\n      }\n\n      suggestedInitCapData = numDataPointsAdded; // for next time...\n\n      in.close();\n\n      if (tempArray.length == numDataPointsAdded) {\n        // logger.logComment(\"Quick return\", true);\n        return tempArray;\n      }\n\n      data = new double[numDataPointsAdded];\n      System.arraycopy(tempArray, 0, data, 0, numDataPointsAdded);\n      // System.out.println(\"Read in \"+data.length+\" values. First: \"+data[0]+\", last:\n      // \"+data[data.length-1] );\n      return data;\n    } catch (IOException e) {\n      throw new SimulationDataException(\n          \"Error reading from file: \" + dataFile.getAbsolutePath(), e);\n    } catch (NumberFormatException ne) {\n      throw new SimulationDataException(\n          \"Error reading line: (\" + nextLine + \") from file: \" + dataFile.getAbsolutePath(), ne);\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1609, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 47, "tryExpressionEnd": 51, "tryBlockStart": 47, "tryBlockEnd": 308, "catchExpressionStart": 235, "catchExpressionEnd": 255, "catchBlockStart": 235, "catchBlockEnd": 308, "exceptionHandlingCallStart": [263], "exceptionHandlingCallEnd": [301], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 109, "focalAPIEnd": 136, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["encrypt(String,val)"], "useStart": [164], "useEnd": [189], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/DanB91/USU-BUGCATCHER/tree/master/Problems/Encoder/src/Encoder_Oracle.java", "rawCode": "  public static void main(String[] args) {\n    try {\n      String toEncrypt = args[0];\n\n      double shift = Double.parseDouble(args[1]);\n\n      String encrypted = encrypt(toEncrypt, shift);\n      System.out.println(encrypted);\n\n    } catch (Exception e) {\n      System.out.println(\"Error: Bad Input\");\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1610, "initialization": ["String s = String.substring(int,int)"], "initializationStart": [907], "initializationEnd": [938], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 973, "focalAPIEnd": 1013, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/avh4/jfugue/tree/master/jfugue/src/org/jfugue/parsers/MusicStringParser.java", "rawCode": "  /**\n   * Returns the index with which to start parsing the next part of the string, once this method is\n   * done with its part\n   */\n  private int parseNumericDuration(String s, int slen, int index, NoteContext context) {\n    // The duration has come in as a number, like 0.25 for a quarter note.\n    // Advance pointer past the initial slash (/)\n    index++;\n\n    // Decimal duration is not required to be enclosed by brackets,\n    // but since most of the other numerical input to a MusicString\n    // is required to be in brackets, we should support it.\n    if ('[' == s.charAt(index)) {\n      int indexOfEndingBracket = s.indexOf(']', index);\n      context.decimalDuration +=\n          getDoubleFromDictionary(s.substring(index + 1, indexOfEndingBracket));\n      index = indexOfEndingBracket + 1;\n    } else {\n      int endingIndex = seekToEndOfDecimal(s, index);\n      String durationNumberString = s.substring(index, endingIndex);\n      context.decimalDuration += Double.parseDouble(durationNumberString);\n      index = endingIndex;\n    }\n\n    trace(\"Decimal duration is \" + context.decimalDuration);\n    return index;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1611, "initialization": ["String s = toString(*)"], "initializationStart": [140], "initializationEnd": [171], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 192, "focalAPIEnd": 216, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gissolutions/jsimpleutils/tree/master/src/main/java/org/gissolutions/jsimpleutils/io/FilenameUtility.java", "rawCode": "  public static double getFileSize(String filename, FileSizeFormat format) {\n    File tmpFile = new File(filename);\n    ;\n    String size = Long.toString(tmpFile.length());\n    double sized = Double.parseDouble(size);\n    double result = sized / format.multiplier;\n    return result;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1612, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s.equalsIgnoreCase(NULL_VALUE,))", "guardType": "IF {", "guardExpressionStart": 72, "guardExpressionEnd": 107, "guardBlockStart": 72, "guardBlockEnd": 120, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 393, "focalAPIEnd": 414, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/posttool/PSWebV1.0/tree/master/src/com/pagesociety/web/module/dump/ExcelDumpModule.java", "rawCode": "  private Object parse_simple_value(FieldDefinition f, String s) {\n\n    if (s.equalsIgnoreCase(NULL_VALUE)) return null;\n    switch (f.getBaseType()) {\n      case Types.TYPE_BOOLEAN:\n        return Boolean.parseBoolean(s);\n      case Types.TYPE_LONG:\n        return Long.parseLong(s);\n      case Types.TYPE_INT:\n        return Integer.parseInt(s);\n      case Types.TYPE_DOUBLE:\n        return Double.parseDouble(s);\n      case Types.TYPE_FLOAT:\n        return Float.parseFloat(s);\n      case Types.TYPE_STRING:\n      case Types.TYPE_TEXT:\n        return s;\n      case Types.TYPE_DATE:\n        try {\n          return spreadsheet_date_formatter.parse(s);\n        } catch (ParseException e1) {\n          e1.printStackTrace();\n          return null;\n        }\n      case Types.TYPE_BLOB:\n        return Byte.parseByte(s);\n      case Types.TYPE_REFERENCE:\n        Entity e = new Entity();\n        String[] type_id = s.split(\":\");\n        e.setType(type_id[0]);\n        e.setId(Long.parseLong(type_id[1]));\n        return e;\n      default:\n        return s;\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1613, "initialization": ["String s = substring(int,*)", "String s = substring(int,*)"], "initializationStart": [303, 390], "initializationEnd": [333, 420], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["s.length()", "s.substring(int,*)", "s.length()", "s.substring(int,*)"], "configurationStart": [219, 303, 318, 390], "configurationEnd": [229, 333, 328, 420], "guardCondition": "!(s==null||(s).length()==0)", "guardType": "IF {", "guardExpressionStart": 103, "guardExpressionEnd": 149, "guardBlockStart": 103, "guardBlockEnd": 201, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 447, "focalAPIEnd": 468, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/walware/statet/tree/master/de.walware.statet.r.ui/src/de/walware/statet/r/internal/ui/datafilterview/Text2NumConverter.java", "rawCode": "  @Override\n  public Object convert(final Object fromObject) {\n    String s = (String) fromObject;\n    if (s == null || (s = s.trim()).length() == 0) {\n      throw new IllegalArgumentException();\n    }\n    if (s.charAt(s.length() - 1) == 'f') {\n      if (s.endsWith(\"Inf\")) { // $NON-NLS-1$\n        s = s.substring(0, s.length() - 3) + \"Infinity\"; // $NON-NLS-1$\n      } else {\n        s = s.substring(0, s.length() - 1);\n      }\n    }\n    return Double.parseDouble(s);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1614, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["println(*)"], "tryExpressionStart": 1077, "tryExpressionEnd": 1081, "tryBlockStart": 1077, "tryBlockEnd": 1879, "catchExpressionStart": 1753, "catchExpressionEnd": 1787, "catchBlockStart": 1753, "catchBlockEnd": 1879, "exceptionHandlingCallStart": [1797], "exceptionHandlingCallEnd": [1851], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1272, "focalAPIEnd": 1296, "followUpCheck": "val < 0.0 || val > 1.0", "checkType": "IF", "followUpCheckExpressionStart": 1306, "followUpCheckExpressionEnd": 1329, "followUpCheckBlockStart": 1306, "followUpCheckBlockEnd": 1459, "use": ["double.parseDouble(*)", "ArrayList<Double>.add(val)"], "useStart": [1480, 1677], "useEnd": [1504, 1692], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/linpawslitap/mds_scaling/tree/master/hadoop/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/loadGenerator/LoadGenerator.java", "rawCode": "  /**\n   * Read a script file of the form: lines of text with duration in seconds, read probability and\n   * write probability, separated by white space.\n   *\n   * @param filename Script file\n   * @return 0 if successful, -1 if not\n   * @throws IOException if errors with file IO\n   */\n  private int loadScriptFile(String filename) throws IOException {\n    FileReader fr = new FileReader(new File(filename));\n    BufferedReader br = new BufferedReader(fr);\n    ArrayList<Long> duration = new ArrayList<Long>();\n    ArrayList<Double> readProb = new ArrayList<Double>();\n    ArrayList<Double> writeProb = new ArrayList<Double>();\n    int lineNum = 0;\n\n    String line;\n    // Read script, parse values, build array of duration, read and write probs\n    while ((line = br.readLine()) != null) {\n      lineNum++;\n      if (line.startsWith(\"#\") || line.isEmpty()) // skip comments and blanks\n      continue;\n\n      String[] a = line.split(\"\\\\s\");\n      if (a.length != 3) {\n        System.err.println(\"Line \" + lineNum + \": Incorrect number of parameters: \" + line);\n      }\n\n      try {\n        long d = Long.parseLong(a[0]);\n        if (d < 0) {\n          System.err.println(\"Line \" + lineNum + \": Invalid duration: \" + d);\n          return -1;\n        }\n\n        double r = Double.parseDouble(a[1]);\n        if (r < 0.0 || r > 1.0) {\n          System.err.println(\"Line \" + lineNum + \": The read probability must be [0, 1]: \" + r);\n          return -1;\n        }\n\n        double w = Double.parseDouble(a[2]);\n        if (w < 0.0 || w > 1.0) {\n          System.err.println(\"Line \" + lineNum + \": The read probability must be [0, 1]: \" + r);\n          return -1;\n        }\n\n        readProb.add(r);\n        duration.add(d);\n        writeProb.add(w);\n      } catch (NumberFormatException nfe) {\n        System.err.println(lineNum + \": Can't parse: \" + line);\n        return -1;\n      }\n    }\n\n    br.close();\n    fr.close();\n\n    // Copy vectors to arrays of values, to avoid autoboxing overhead later\n    durations = new long[duration.size()];\n    readProbs = new double[readProb.size()];\n    writeProbs = new double[writeProb.size()];\n\n    for (int i = 0; i < durations.length; i++) {\n      durations[i] = duration.get(i);\n      readProbs[i] = readProb.get(i);\n      writeProbs[i] = writeProb.get(i);\n    }\n\n    if (durations[0] == 0)\n      System.err.println(\"Initial duration set to 0. \" + \"Will loop until stopped manually.\");\n\n    return 0;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1615, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["handleException(String,*)"], "tryExpressionStart": 2639, "tryExpressionEnd": 2643, "tryBlockStart": 2639, "tryBlockEnd": 4772, "catchExpressionStart": 4704, "catchExpressionEnd": 4724, "catchBlockStart": 4704, "catchBlockEnd": 4772, "exceptionHandlingCallStart": [4738], "exceptionHandlingCallEnd": [4765], "configuration": ["s.equals(String)"], "configurationStart": [3506], "configurationEnd": [3526], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 3589, "focalAPIEnd": 3615, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new InitParams(long,String,String,val,boolean,*,int)"], "useStart": [4164], "useEnd": [4249], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.4.1/src/om/qengine/OmService.java", "rawCode": "  /**\n   * Creates a new question session for the given question.\n   *\n   * <p>API METHOD: This method signature must not be changed in future (after initial release)\n   * unless careful attention is paid to simultaneous changes of Test Navigator. In general, if\n   * additional parameters or return values are added, a new method should be defined.\n   *\n   * <h3>Obtaining question file</h3>\n   *\n   * If the question engine already has this question in its cache, it will use that (questions of\n   * the same version are guaranteed not to change). Otherwise it retrieves questions using the\n   * following URL:\n   *\n   * <p><i>questionBaseURL</i>/<i>questionID</i>.<i>questionversion</i>\n   *\n   * <p>For security reasons, the URL may be https: and the test navigator (which is likely to be\n   * the thing serving the URL) will operate an IP whitelist, only responding to requests from\n   * question engines it has already initiated connections to.\n   *\n   * <h3>Initial parameters</h3>\n   *\n   * initialParamNames and initialParamValues (which must be of equal length) include initial\n   * configuration parameters to be passed to the question.\n   *\n   * <table border=\"1\">\n   * <tr><th>Name</th><th>Value</th></tr>\n   * <tr><td>randomseed</td><td>Random number seed given to question, which\n   * should be based on the current user, the test, and the number of times\n   * they've started this question before. Parsed as decimal integer (up to\n   * 64 bit)</td></tr>\n   * </table>\n   *\n   * @param questionID Unique ID of question\n   * @param questionVersion Version identifier of question (should include only filename-space\n   *     characters, probably just digits and full stops). May be null, to indicate that the\n   *     question may not be cached (for preview usage only)\n   * @param questionBaseURL Base URL for questions (see above)\n   * @param initialParamNames Names of initial parameters\n   * @param initialParamValues Values of initial parameters\n   * @param cachedResources List of resources that the Test Navigator has cached\n   * @return Various data in order to provide the initial page of the question\n   * @throws OmException Whenever something goes wrong\n   */\n  public StartReturn start(\n      String questionID,\n      String questionVersion,\n      String questionBaseURL,\n      String[] initialParamNames,\n      String[] initialParamValues,\n      String[] cachedResources)\n      throws OmException {\n    if (initialParamNames == null) initialParamNames = new String[0];\n    if (initialParamValues == null) initialParamValues = new String[0];\n    if (cachedResources == null) cachedResources = new String[0];\n\n    try {\n      // Slurp values from parameters\n      if (initialParamNames.length != initialParamValues.length)\n        throw new OmException(\"Parameter name and value arrays of different length\");\n      long lRandomSeed = 0;\n      boolean bGotRandomSeed = false;\n      String sFixedFG = null, sFixedBG = null;\n      boolean bPlain = false;\n      double dZoom = 1.0;\n      int iFixedVariant = -1;\n\n      for (int i = 0; i < initialParamNames.length; i++) {\n        String sName = initialParamNames[i], sValue = initialParamValues[i];\n        if (sName.equals(\"randomseed\")) {\n          lRandomSeed = Long.parseLong(sValue);\n          bGotRandomSeed = true;\n        } else if (sName.equals(\"fixedfg\")) {\n          sFixedFG = sValue;\n        } else if (sName.equals(\"fixedbg\")) {\n          sFixedBG = sValue;\n        } else if (sName.equals(\"plain\")) {\n          bPlain = sValue.equals(\"yes\");\n        } else if (sName.equals(\"zoom\")) {\n          dZoom = Double.parseDouble(sValue);\n        } else if (sName.equals(\"fixedvariant\")) {\n          iFixedVariant = Integer.parseInt(sValue);\n        }\n      }\n      if (!bGotRandomSeed) throw new OmException(\"Required parameter missing: randomseed\");\n\n      // Get question into cache\n      QuestionCache.QuestionKey qk = new QuestionCache.QuestionKey(questionID, questionVersion);\n      obtainQuestion(questionBaseURL, qk);\n\n      // Create and initialise question\n      QuestionCache.QuestionInstance qi = qc.newQuestion(qk);\n      Question q = qi.q;\n      InitParams ip =\n          new InitParams(lRandomSeed, sFixedFG, sFixedBG, dZoom, bPlain, qi.ccl, iFixedVariant);\n      Rendering r = q.init(qc.getMetadata(qk), ip);\n\n      // Generate session details and store in map\n      QuestionSession qs = new QuestionSession();\n      qs.q = q;\n      qs.lLastUsedTime = System.currentTimeMillis();\n      String sSession;\n      synchronized (this) {\n        sSession = \"\" + (iNextSessionID++);\n        qs.sSession = sSession;\n        mQuestionSessions.put(sSession, qs);\n      }\n\n      return new StartReturn(sSession, r);\n    } catch (Throwable t) {\n      throw handleException(\"start\", t);\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1616, "initialization": ["String s = Object.toString()"], "initializationStart": [849], "initializationEnd": [866], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1391, "focalAPIEnd": 1414, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(String)", "setValue(int,val)"], "useStart": [1449, 1428], "useEnd": [1472, 1473], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johdah/Weka/tree/master/src/main/java/weka/gui/arffviewer/ArffTableModel.java", "rawCode": "  /**\n   * sets the value in the cell at columnIndex and rowIndex to aValue. but only the value and the\n   * value can be changed\n   *\n   * @param aValue the new value\n   * @param rowIndex the row index\n   * @param columnIndex the column index\n   * @param notify whether to notify the listeners\n   */\n  public void setValueAt(Object aValue, int rowIndex, int columnIndex, boolean notify) {\n    int type;\n    int index;\n    String tmp;\n    Instance inst;\n    Attribute att;\n    Object oldValue;\n\n    if (!m_IgnoreChanges) addUndoPoint();\n\n    oldValue = getValueAt(rowIndex, columnIndex);\n    type = getType(rowIndex, columnIndex);\n    index = columnIndex - 1;\n    inst = m_Data.instance(rowIndex);\n    att = inst.attribute(index);\n\n    // missing?\n    if (aValue == null) {\n      inst.setValue(index, Utils.missingValue());\n    } else {\n      tmp = aValue.toString();\n\n      switch (type) {\n        case Attribute.DATE:\n          try {\n            att.parseDate(tmp);\n            inst.setValue(index, att.parseDate(tmp));\n          } catch (Exception e) {\n            // ignore\n          }\n          break;\n\n        case Attribute.NOMINAL:\n          if (att.indexOfValue(tmp) > -1) inst.setValue(index, att.indexOfValue(tmp));\n          break;\n\n        case Attribute.STRING:\n          inst.setValue(index, tmp);\n          break;\n\n        case Attribute.NUMERIC:\n          try {\n            Double.parseDouble(tmp);\n            inst.setValue(index, Double.parseDouble(tmp));\n          } catch (Exception e) {\n            // ignore\n          }\n          break;\n\n        case Attribute.RELATIONAL:\n          try {\n            inst.setValue(index, inst.attribute(index).addRelation((Instances) aValue));\n          } catch (Exception e) {\n            // ignore\n          }\n          break;\n\n        default:\n          throw new IllegalArgumentException(\"Unsupported Attribute type: \" + type + \"!\");\n      }\n    }\n\n    // notify only if the value has changed!\n    if (notify && (!(\"\" + oldValue).equals(\"\" + aValue)))\n      notifyListener(new TableModelEvent(this, rowIndex, columnIndex));\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1617, "initialization": ["String s = Landmark.getYcoord()"], "initializationStart": [523], "initializationEnd": [543], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 795, "focalAPIEnd": 835, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "calculateDistance(double,val,double,double)"], "useStart": [864, 1041], "useEnd": [904, 1150], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/legendaryfox/bamft/tree/master/src/com/ksj/bamft/activity/ScheduleListActivity.java", "rawCode": "  /**\n   * Returns the distance between a user and a landmark.\n   *\n   * @param schedule\n   * @param db\n   * @param userLatDegrees\n   * @param userLonDegrees\n   * @return\n   */\n  private double getDistanceFromUser(\n      Schedule schedule, DatabaseHandler db, double userLatDegrees, double userLonDegrees) {\n\n    int landmarkId = schedule.getLandmarkId();\n    Landmark landmark = db.getLandmark(landmarkId);\n\n    // Get coordinates of landmark\n\n    String landmarkXCoord = landmark.getXcoord();\n    String landmarkYCoord = landmark.getYcoord();\n\n    double landmarkLatDegrees = 0.0;\n    double landmarkLonDegrees = 0.0;\n\n    if (landmarkXCoord != null\n        && landmarkXCoord.length() > 0\n        && landmarkYCoord != null\n        && landmarkYCoord.length() > 0) {\n\n      landmarkLatDegrees = Double.parseDouble(landmark.getYcoord());\n      landmarkLonDegrees = Double.parseDouble(landmark.getXcoord());\n    }\n\n    // If we don't have coordinates for this landmark, assume it's farthest away\n\n    else return Double.MAX_VALUE;\n\n    return MapHelpers.calculateDistance(\n        userLatDegrees, landmarkLatDegrees, userLonDegrees, landmarkLonDegrees);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1618, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1582, "focalAPIEnd": 1646, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/boundlessgeo/geotools-2.7.x/tree/master/modules/unsupported/coveragetools/src/main/java/org/geotools/utils/coveragetiler/CoverageTiler.java", "rawCode": "  public boolean parseArgs(String[] args) {\n    if (!super.parseArgs(args)) return false;\n\n    // ////////////////////////////////////////////////////////////////\n    //\n    // Parsing command line parameters and setting up\n    // Mosaic Index Builder options\n    //\n    // ////////////////////////////////////////////////////////////////\n    inputLocation = new File((String) getOptionValue(inputLocationOpt));\n\n    // output files' directory\n    if (hasOption(outputLocationOpt))\n      outputLocation = new File((String) getOptionValue(outputLocationOpt));\n    else outputLocation = new File(inputLocation.getParentFile(), \"tiled\");\n    // //\n    //\n    // tile dim\n    //\n    // //\n    final String tileDim = (String) getOptionValue(tileDimOpt);\n    String[] pairs = tileDim.split(\",\");\n    tileWidth = Integer.parseInt(pairs[0]);\n    tileHeight = Integer.parseInt(pairs[1]);\n\n    // //\n    //\n    // Internal Tile dim\n    //\n    // //\n    final String internalTileDim = (String) getOptionValue(internalTileDimOpt);\n    if (internalTileDim != null && internalTileDim.length() > 0) {\n      pairs = internalTileDim.split(\",\");\n      internalTileWidth = Integer.parseInt(pairs[0]);\n      internalTileHeight = Integer.parseInt(pairs[1]);\n    }\n\n    // //\n    //\n    // Compression params\n    //\n    // //\n    // index name\n    if (hasOption(compressionTypeOpt)) {\n      compressionScheme = (String) getOptionValue(compressionTypeOpt);\n      if (compressionScheme == \"\") compressionScheme = null;\n    }\n    if (hasOption(compressionRatioOpt)) {\n      try {\n        compressionRatio = Double.parseDouble((String) getOptionValue(compressionRatioOpt));\n      } catch (Exception e) {\n        compressionRatio = Double.NaN;\n      }\n    }\n\n    return true;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1619, "initialization": ["String s = C.readChildProperty(String)"], "initializationStart": [211], "initializationEnd": [244], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(StringUtils.isEmpty(s,))", "guardType": "IF {", "guardExpressionStart": 252, "guardExpressionEnd": 285, "guardBlockStart": 252, "guardBlockEnd": 391, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 355, "focalAPIEnd": 382, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/crux-framework/tree/master/tags/crux/5.2.0/crux-dev/src/main/java/org/cruxframework/crux/gwt/rebind/AbstractDockLayoutPanelFactory.java", "rawCode": "    @Override\n    public void processChildren(SourcePrinter out, C context) throws CruxGeneratorException {\n      context.direction = getDirection(context.readChildProperty(\"direction\"));\n      String sizeStr = context.readChildProperty(\"size\");\n      if (StringUtils.isEmpty(sizeStr)) {\n        context.size = -1.0;\n      } else {\n        context.size = Double.parseDouble(sizeStr);\n      }\n    }\n"}, {"dataset": "parseDouble", "exampleID": 1620, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 3118, "tryExpressionEnd": 3122, "tryBlockStart": 3118, "tryBlockEnd": 18097, "catchExpressionStart": 18037, "catchExpressionEnd": 18059, "catchBlockStart": 18037, "catchBlockEnd": 18097, "exceptionHandlingCallStart": [18069], "exceptionHandlingCallEnd": [18088], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 12938, "focalAPIEnd": 12967, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["reduce(val,List<String>)"], "useStart": [13017], "useEnd": [13045], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/teropa/stem/tree/master/org.eclipse.stem.utility/src/org/eclipse/stem/utility/generators/MultiPassDownSampler.java", "rawCode": "  /**\n   * Perform the second iteration of down sampling and beyond.\n   *\n   * <p>NOTE: We assume that SinglePassDownSampler has been run once already.\n   */\n  protected void process() {\n\n    // The initial pass : first pass already done by SinglePassDownSampler\n    final int INIT = 2;\n\n    // The current pass or iteration\n    int pass = INIT;\n\n    // The total number of iterations\n    int totalIterations = Integer.parseInt(iterations);\n\n    // A writer for the new file we are creating.\n    PrintWriter gmlFile = null;\n\n    // A writer for the reduced data file.\n    PrintWriter reducedFile = null;\n\n    // Object holding ISO3166-1 related data.\n    ISOCode1 isoCode = null;\n\n    // Name of the new properties file.\n    String fileName = null;\n\n    // A list for ISO 3166-2 objects\n    List iso2List = new ArrayList();\n\n    // Filenames for lex1 and lex2 files for a given country.\n    String lexAdmin1File = null;\n    String lexAdmin2File = null;\n\n    // Lists holding the lex1 and lex2 values.\n    // NOTE: lex values are the lexicographically sorted values for\n    // administration levels.\n    List<String> lex1DataSet = null;\n    List<String> lex2DataSet = null;\n\n    // Lists for holding lex1 and lex2 objects for a given country.\n    List<Lex1Obj> lex1List = null;\n    List<Lex2Obj> lex2List = null;\n\n    int size = targetList.size();\n\n    // Alpha 3 code for the next code to process...\n    String countryAlpha3 = null;\n\n    // Iterate for every country and create its GML data file.\n    int i = 0;\n\n    // Get the first country in list.\n    countryAlpha3 = ((String) targetList.get(i)).trim();\n\n    if (countryAlpha3 == null) {\n      System.out.println(\"\\t\\tError : alpha 3 country code is null.\"); // $NON-NLS-1$\n      System.exit(1);\n    }\n\n    while (i < size) {\n\n      // Is it time to process the next country ?\n      if (pass > totalIterations) {\n        // Yes , we are done with the iterations , go to next.\n        i++;\n        pass = INIT;\n        countryAlpha3 = (i < size) ? ((String) targetList.get(i)).trim() : \"DUMMY\"; // $NON-NLS-1$\n        continue;\n      }\n\n      // Keep with the same country until we are done with the total\n      // number of passes. Otherwise, get the next country in reduce list.\n\n      // An index for unknwon or n.a. entries\n      int unkCounter = 1;\n\n      // We use this list to keep track of duplicated polygons.\n      List<STEMPolygon> polygons = null;\n\n      // Data source\n      fileName =\n          inputDir\n              + countryAlpha3\n              + \"\\\\\"\n              + countryAlpha3 // $NON-NLS-1$\n              + \"_REDUCED_\"\n              + (pass - 1)\n              + \".txt\"; // $NON-NLS-1$ //$NON-NLS-2$\n\n      BufferedReader reader = GenUtils.openReader(fileName);\n      System.out.println(\n          \"\\t\\t<<<< MULTI PASS DOWN-SAMPLER -- Processing country : \"\n              + fileName\n              + \" >>>>\"); // $NON-NLS-1$ //$NON-NLS-2$\n\n      System.out.println(\n          \"\\t\\t<<<< Pass \"\n              + pass\n              + \" of \"\n              + totalIterations // $NON-NLS-1$ //$NON-NLS-2$\n              + \">>>>\"); // $NON-NLS-1$\n      try {\n\n        if (reader != null) {\n\n          String buffer = null;\n          // Describes level of data we\n          // are now processing : LEVEL0, LEVEL1, or LEVEL2.\n          int level = -1;\n\n          // Record the previous type.\n          int oldlevel = level - 1;\n\n          // Used to distinguish between a simple polygon and islands\n          // of polygons. Initialize string to the blank character.\n          String island = \" \"; // $NON-NLS-1$\n\n          while (GenUtils.EOF(buffer = reader.readLine()) != true) {\n\n            // The data we want to write to the new GML file.\n            String output = \" \"; // $NON-NLS-1$\n\n            // Make sure that we mark all unknown data.\n            buffer = buffer.replace(\",,\", \",UNKNOWN,\"); // $NON-NLS-1$ //$NON-NLS-2$\n\n            // We take a chunk of the data [BUFFER_MIN,BUFFER_MAX]\n            // to make processsing more\n            // efficient, we dont need all of it.\n            int BUFFER_MIN = 0;\n            int BUFFER_MAX = 125;\n\n            String[] items =\n                GenUtils.extract(\n                    buffer.length() < BUFFER_MAX\n                        ? buffer\n                        : buffer.substring(BUFFER_MIN, BUFFER_MAX));\n\n            // Get the country name\n            String country = items[ISOData.COUNTRY_NAME];\n\n            // Get the ISO3166-1 info for this country\n            if (isoCode == null) {\n              isoCode = GenUtils.getISOCode(country, codeList);\n            }\n\n            // Get the type of the data we are processing.\n            level = GenUtils.getLevel(items);\n\n            if (level != 0 && iso2List != null) {\n              // Load the ISO 3166-2 objects for this country\n              iso2List = GenUtils.loadISO2(iso3166_2);\n            }\n\n            // This variable indicates a transition in our data\n            // processing\n            boolean transition = (level != oldlevel) ? true : false;\n\n            // The current entity we are dealing with.\n            // Based on its admin level it can be a country, a\n            // county, etc;\n            String current = null;\n\n            // Descriptor for current entry.\n            String descriptor = null;\n\n            if (transition == true) {\n              // Use previous level to detect transitions.\n              oldlevel = level;\n\n              // Reset the previous entity\n              island = \" \"; // $NON-NLS-1$\n\n              // Reset counter of UNKNOWN and N.A. entries.\n              unkCounter = 1;\n              // Close the previous file\n              if (gmlFile != null) {\n                output = closePolygonIslandTags();\n                output += getClosingTags();\n                GenUtils.addData(gmlFile, output);\n                gmlFile.close();\n              }\n\n              // Clear the list of unique polygons\n              if (polygons != null) {\n                polygons.clear();\n              }\n\n              // Get a new, empty polygon list\n              polygons = new ArrayList<STEMPolygon>();\n\n              // If the directory does not exist for this country,\n              // create it using ISO alpha3 code.\n              File countryDir = new File(outputDir + isoCode.getAlpha3());\n\n              if (countryDir != null && countryDir.exists() == false) {\n                // Directory does not exist. Create it.\n                countryDir.mkdir();\n              }\n\n              // Open the writer for the reduced data file\n              if (reducedFile == null) {\n                // Create proper name for the reduced data file.\n                fileName =\n                    countryDir\n                        + \"\\\\\" // $NON-NLS-1$\n                        + isoCode.getAlpha3()\n                        + \"_REDUCED_\" // $NON-NLS-1$\n                        + pass\n                        + \".txt\"; // $NON-NLS-1$\n                reducedFile = GenUtils.openWriter(fileName);\n              }\n\n              // //Create the file name for the reduced GML file.\n              fileName =\n                  countryDir\n                      + \"\\\\\"\n                      + isoCode.getAlpha3() // $NON-NLS-1$\n                      + \"_\"\n                      + level\n                      + \"_REDUCED_MAP_\"\n                      + pass // $NON-NLS-1$ //$NON-NLS-2$\n                      + \".xml\"; // $NON-NLS-1$\n\n              // Create the file name for the reduced GML file.\n              // fileName = countryDir + \"\\\\\" +\n              // isoCode.getAlpha3() //$NON-NLS-1$\n              // + \"_\" + level + \"_MAP\" //$NON-NLS-1$\n              // //$NON-NLS-2$\n              // + \".xml\"; //$NON-NLS-1$\n\n              // Open the writer for the new GML file\n              gmlFile = GenUtils.openWriter(fileName);\n\n              // Add the header of the file\n              output = getOpeningTags(isoCode, level);\n\n              // Write data\n              GenUtils.addData(gmlFile, output.trim());\n            } // if( transition == true )\n\n            switch (level) {\n              case DataTypes.LEVEL_0:\n                current = isoCode.getAlpha3();\n                break;\n\n              case DataTypes.LEVEL_1:\n                current = items[ISOData.ADMIN1_NAME].toUpperCase();\n                break;\n\n              case DataTypes.LEVEL_2:\n                current = items[ISOData.ADMIN2_NAME].toUpperCase();\n                break;\n            } // switch\n\n            // Handle UNKNOWN and N.A. entries differently.\n            if (current.equals(\"UNKNOWN\") || current.equals(\"N.A.\")) { // $NON-NLS-1$ //$NON-NLS-2$\n\n              if (level == 1) {\n                current =\n                    isoCode.getAlpha2()\n                        + \"-UNK-\" // $NON-NLS-1$\n                        + String.valueOf(unkCounter++);\n\n              } else {\n                // Level 2 data.\n                current =\n                    isoCode.getAlpha3()\n                        + \".L2.\" // $NON-NLS-1$\n                        + String.valueOf(unkCounter++);\n              }\n            }\n\n            // We get the descriptor for administration entities\n            // differently based on its level.\n\n            if (level == 2) {\n\n              if (lex1DataSet == null && lex2DataSet == null) {\n\n                // Compose the file names for the lex files for\n                // this\n                // country.\n                lexAdmin1File =\n                    lexDir + isoCode.getAlpha3() + \"\\\\\" + isoCode.getAlpha3(); // $NON-NLS-1$\n                lexAdmin2File = lexAdmin1File;\n                lexAdmin1File += \"_ADMIN1_LEX.txt\"; // $NON-NLS-1$\n                lexAdmin2File += \"_ADMIN2_LEX.txt\"; // $NON-NLS-1$\n\n                // Load the lex1 and lex2 files for this\n                // country.\n                lex1DataSet = GenUtils.populateList(lexAdmin1File);\n                lex2DataSet = GenUtils.populateList(lexAdmin2File);\n\n                // Create a method to search for an item on a\n                // list of lex data objects.\n                lex1List = GenUtils.createLex1List(lex1DataSet);\n                lex2List = GenUtils.createLex2List(lex2DataSet);\n              }\n\n              // Compose the level2 descriptor using the lex data:\n\n              // STEP 1: Do a look up in the lex 2 lists.\n\n              // Get the lex 2 object for the current entry.\n              Lex2Obj lex2Current =\n                  GenUtils.lex2Lookup(lex2List, items[ISOData.ADMIN1_NAME], current);\n\n              // Get the lex1Object to which lex2Current belongs\n              Lex1Obj lex1Current = GenUtils.lex1Lookup(lex1List, lex2Current.getAdmin1());\n\n              if (lex1Current.getDescriptor().contains(\"US-\")) { // $NON-NLS-1$\n                // STEP 2: piece together the ID using the\n                // proper lex objects : the USA is a special\n                // case\n                descriptor =\n                    GenUtils.getUSADescriptor(\n                        lex2Current.getAdmin2(),\n                        GenUtils.extractAlpha2(lex1Current.getDescriptor()),\n                        usaDescriptorList);\n\n              } else {\n                // STEP 2: piece together the ID using the\n                // proper lex objects.\n                descriptor =\n                    lex1Current.getDescriptor()\n                        + \"-G\" // $NON-NLS-1$\n                        + lex1Current.getFormattedIndex()\n                        + lex2Current.getFormattedIndex();\n              }\n\n              if (current.contains(\".L2.\")) { // $NON-NLS-1$\n                current = descriptor;\n              }\n\n            } else {\n              // Compose descriptor for l 1 and l 0 data\n              // Get the descriptor for this entity.\n              descriptor = GenUtils.getISO2Descriptor(iso2List, current, isoCode.getAlpha2());\n\n              // If we cant find the descriptor, then look in the\n              // fix list.\n              if (descriptor.equals(current) == true) {\n                // Look for a descriptor in the fix file\n                descriptor = GenUtils.getFixCode(codefixList, current, items[ISOData.COUNTRY_NAME]);\n              }\n            }\n\n            // System.out.println(\"Descriptor is : \" + descriptor\n            // + \" at level : \" + level + \" for \" + current);\n\n            // Create a STEM polygon with this polygon data\n            STEMPolygon polygon = new STEMPolygon(buffer, level);\n\n            // Check that this is indeed a STEM polygon\n            if (isPolygon(polygon) != true) {\n              // Not a polygon, ignore.\n              continue;\n            }\n\n            // Compute a map of angle values.\n            List<String> pointDataList = computeInverseCosines(polygon);\n\n            // Now apply reduction : get rid of all points with\n            // angles less than or equal to alpha degrees\n            double alpha = Double.parseDouble(threshold);\n            List<String> reducedPointDataList = reduce(alpha, pointDataList);\n\n            // Update Global Stats\n            updateGlobalStats(pointDataList.size(), reducedPointDataList.size());\n\n            // Show some of the stats after each reduction.\n            // showStats(pointDataList, reducedPointDataList, pass);\n\n            // Put all the remaining points into a new buffer\n            String reducedPolygonDataBuffer = extractListIntoString(reducedPointDataList);\n\n            // Reconstruct a buffer with the reduced point-data.\n\n            // Extract all data from old buffer except the polygon\n            // data :\n            String nonPolygonDataBuffer =\n                extractNonPolygonData(\n                    buffer.length() < BUFFER_MAX\n                        ? buffer\n                        : buffer.substring(BUFFER_MIN, BUFFER_MAX),\n                    level);\n\n            // Now put together a new buffer which has been reduced\n            String reducedBuffer =\n                nonPolygonDataBuffer + reducedPolygonDataBuffer + \"\\n\"; // $NON-NLS-1$\n\n            // Write reduced data buffer into the reduced data file\n            GenUtils.addData(reducedFile, reducedBuffer);\n\n            // Delete the old polygon\n            polygon.clear();\n\n            // Create a new, reduced STEM polygon with the new data\n            // buffer\n            polygon = new STEMPolygon(reducedPolygonDataBuffer, level);\n\n            // We know it is a polygon, but now check that its not\n            // duplicated.\n            if (isPolygonDuplicated(polygons.iterator(), polygon) == true) {\n              // Yes, it is duplicated\n              continue;\n            }\n\n            // Add this polygon to our list of unique polygons so\n            // that we can check duplicates of this polygon later.\n            polygons.add(polygon);\n\n            // Check to see if this polygon is part of an island of\n            // polygons or a simple polygon\n            if (level == 0) {\n              // If we are at admin level 0 and island is not\n              // NULL, then we have an island.\n              if (island.equals(\" \")) { // $NON-NLS-1$\n                output = openPolygonIslandTags(descriptor);\n                island = \"Admin Level 0\"; // $NON-NLS-1$\n              }\n              output += addLinearRingTags(reducedBuffer, level);\n            } else {\n\n              if (island.equals(\" \") == true) { // $NON-NLS-1$\n                output = openPolygonIslandTags(descriptor);\n                output += addLinearRingTags(reducedBuffer, level);\n\n              } else {\n\n                if (current.equals(island) == false) {\n                  output = closePolygonIslandTags();\n                  output += openPolygonIslandTags(descriptor);\n                  output += addLinearRingTags(reducedBuffer, level);\n                } else {\n                  output = addLinearRingTags(reducedBuffer, level);\n                  GenUtils.addData(gmlFile, output.trim());\n                  continue;\n                }\n              }\n\n              switch (level) {\n                case DataTypes.LEVEL_1:\n                  island = items[ISOData.ADMIN1_NAME].toUpperCase();\n                  break;\n\n                case DataTypes.LEVEL_2:\n                  island = items[ISOData.ADMIN2_NAME].toUpperCase();\n                  break;\n              }\n            }\n\n            GenUtils.addData(gmlFile, output.trim());\n          } // while loop\n\n          // Reset all lex-related items\n\n          if (lex1DataSet != null) {\n            lex1DataSet.clear();\n            lex1DataSet = null;\n          }\n          if (lex2DataSet != null) {\n            lex2DataSet.clear();\n            lex2DataSet = null;\n          }\n          if (lex1List != null) {\n            lex1List.clear();\n            lex1List = null;\n          }\n          if (lex2List != null) {\n            lex2List.clear();\n            lex2List = null;\n          }\n\n          lexAdmin1File = null;\n          lexAdmin2File = null;\n\n          // We dont need the ISO code object for this country\n          // anymore, we are done processing it.\n          isoCode = null;\n\n          // Close all open resources.\n          reader.close();\n\n          if (gmlFile != null) {\n            // Write formatted output\n            GenUtils.addData(gmlFile, closePolygonIslandTags());\n            GenUtils.addData(gmlFile, getClosingTags());\n            gmlFile.close();\n            gmlFile = null;\n            System.out.println(\"\\t\\tGenerated : \" + fileName); // $NON-NLS-1$\n            fileName = null;\n          }\n\n          if (reducedFile != null) {\n            reducedFile.close();\n            reducedFile = null;\n          }\n\n          // Increase the pass counter.\n          pass++;\n\n          // Run garbage collection\n          // System.gc();\n\n        }\n\n        // Show global stats for this pass\n        showGlobalStats();\n\n        // Now clear them before next iteration\n        resetGlobalStats();\n\n        // Now clear the hash map\n        initHashMap(angleValueMap);\n\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1621, "initialization": ["String s = JSONObject.getString(String)"], "initializationStart": [590], "initializationEnd": [612], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 249, "tryExpressionEnd": 253, "tryBlockStart": 249, "tryBlockEnd": 1177, "catchExpressionStart": 1123, "catchExpressionEnd": 1143, "catchBlockStart": 1123, "catchBlockEnd": 1177, "exceptionHandlingCallStart": [1151], "exceptionHandlingCallEnd": [1170], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 629, "focalAPIEnd": 653, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/DanDragan/Voice-Tasker/tree/master/src/ncit/android/voicetasker/Activity_Load.java", "rawCode": "  private void init(ArrayList<ListItem> list) {\n\n    dir = getExternalFilesDir(null);\n    subdir = Activity_ListDir.getSubDirName();\n    fileName = Activity_Show.getFileName();\n\n    File myInput = new File(dir + \"/\" + subdir + \"/\" + fileName);\n\n    try {\n      FileReader in = new FileReader(myInput);\n\n      StringWriter sw = new StringWriter();\n\n      char[] b = new char[1024 * 64];\n      while (in.read(b) > 0) {\n        sw.write(b);\n      }\n\n      String s = sw.toString();\n      JSONArray jArray = new JSONArray(s);\n      JSONObject bud = jArray.getJSONObject(0);\n      String budg = bud.getString(\"price\");\n      budget = Double.parseDouble(budg);\n      tvBudget.setText(\"BUDGET : \" + budget);\n\n      for (int i = 1; i < jArray.length(); i++) {\n        JSONObject obj = jArray.getJSONObject(i);\n\n        boolean status = obj.getBoolean(\"status\");\n        String price = obj.getString(\"price\");\n        String name = obj.getString(\"name\");\n        list.add(new ListItem(name, price, status));\n      }\n\n      in.close();\n\n      tvTotal.setText(\"TOTAL : \" + String.valueOf(getTotal()));\n\n      calculateTotal();\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1622, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 138, "focalAPIEnd": 170, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/posttool/PSWebV1.0/tree/master/src/com/pagesociety/util/OBJECT.java", "rawCode": "  public Double F(String path) {\n    Object val = find(path);\n    if (val == null) return -1D;\n    else if (val instanceof String) return Double.parseDouble((String) val);\n    else return (Double) val;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1623, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 700, "tryExpressionEnd": 704, "tryBlockStart": 700, "tryBlockEnd": 3029, "catchExpressionStart": 2962, "catchExpressionEnd": 2982, "catchBlockStart": 2962, "catchBlockEnd": 3029, "exceptionHandlingCallStart": [2994], "exceptionHandlingCallEnd": [3018], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1113, "focalAPIEnd": 1141, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "double.parseDouble(*)", "new APOI(int,String,String,String,double,val,*,double,List<Category>,int)", "double.parseDouble(*)", "double.parseDouble(*)", "double.parseDouble(*)", "new APOI(int,String,String,String,double,val,*,double,List<Category>,int)"], "useStart": [1174, 1234, 1713, 2023, 2084, 2144, 2623], "useEnd": [1202, 1262, 1822, 2051, 2112, 2172, 2732], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kateyim/crawler/tree/master/src/main/java/mo/umac/db/H2DB.java", "rawCode": "  private void convertResultsFile(String folderPath, String h2Name) {\n    String resultsFile = folderPath + \"results\";\n    BufferedReader brResult = null;\n    try {\n      Connection conn = getConnection(dbNameSource);\n      brResult = new BufferedReader(new InputStreamReader(new FileInputStream(resultsFile)));\n      String data = null;\n      String[] split;\n      int position = 1;\n      PreparedStatement prepItem = conn.prepareStatement(sqlPrepInsertItem);\n      PreparedStatement prepCategory = conn.prepareStatement(sqlPrepInsertCategory);\n      PreparedStatement prepRelationship = conn.prepareStatement(sqlPrepInsertRelationship);\n      while ((data = brResult.readLine()) != null) {\n        try {\n          data = data.trim();\n          split = data.split(\";\");\n          int queryID = parseID(split[0]);\n          int itemID = Integer.parseInt(split[1]);\n          String title = split[2];\n          // for Dominos#39;s\n          if (title.equals(\"Dominos#39\")) {\n            title = \"Dominos#39;s\";\n            String city = split[4];\n            String state = split[5];\n            double latitude = Double.parseDouble(split[6]);\n            double longitude = Double.parseDouble(split[7]);\n            double distance = Double.parseDouble(split[8]);\n            List<Category> categories = new ArrayList<Category>();\n            for (int i = 9; i < split.length; i = i + 2) {\n              // prepare category\n              Category category = new Category(Integer.parseInt(split[i]), split[i + 1]);\n              categories.add(category);\n\n              setPrepCategory(itemID, category, prepCategory);\n              prepCategory.addBatch();\n            }\n            APOI result =\n                new APOI(\n                    itemID, title, city, state, longitude, latitude, null, distance, categories, 0);\n\n            setPrepItem(result, prepItem);\n            prepItem.addBatch();\n          } else {\n            String city = split[3];\n            String state = split[4];\n            double latitude = Double.parseDouble(split[5]);\n            double longitude = Double.parseDouble(split[6]);\n            double distance = Double.parseDouble(split[7]);\n            List<Category> categories = new ArrayList<Category>();\n            for (int i = 8; i < split.length; i = i + 2) {\n              // prepare category\n              Category category = new Category(Integer.parseInt(split[i]), split[i + 1]);\n              categories.add(category);\n\n              setPrepCategory(itemID, category, prepCategory);\n              prepCategory.addBatch();\n            }\n            APOI result =\n                new APOI(\n                    itemID, title, city, state, longitude, latitude, null, distance, categories, 0);\n            setPrepItem(result, prepItem);\n            prepItem.addBatch();\n          }\n          //\n          setPrepRelationship(itemID, queryID, position++, prepRelationship);\n          prepRelationship.addBatch();\n        } catch (Exception e) {\n          System.out.println(data);\n        }\n      }\n      // execute prepare statements...\n      prepCategory.executeBatch();\n      prepItem.executeBatch();\n      prepRelationship.executeBatch();\n\n      brResult.close();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    } catch (SQLException e1) {\n      e1.printStackTrace();\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1624, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["handleException(String,*)"], "tryExpressionStart": 2666, "tryExpressionEnd": 2670, "tryBlockStart": 2666, "tryBlockEnd": 4867, "catchExpressionStart": 4752, "catchExpressionEnd": 4772, "catchBlockStart": 4752, "catchBlockEnd": 4820, "exceptionHandlingCallStart": [4786], "exceptionHandlingCallEnd": [4813], "configuration": ["s.equals(String)"], "configurationStart": [3533], "configurationEnd": [3553], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 3616, "focalAPIEnd": 3642, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new InitParams(long,String,String,val,boolean,*,int,*)"], "useStart": [4191], "useEnd": [4297], "hasFinally": 1, "cleanUpCall": ["unsetServletForThread()"], "finallyExpressionStart": 4821, "finallyExpressionEnd": 4829, "finallyBlockStart": 4821, "finallyBlockEnd": 4867, "cleanUpCallStart": [4837], "cleanUpCallEnd": [4860], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/branches/1.6/src/om/qengine/OmService.java", "rawCode": "  /**\n   * Creates a new question session for the given question.\n   *\n   * <p>API METHOD: This method signature must not be changed in future (after initial release)\n   * unless careful attention is paid to simultaneous changes of Test Navigator. In general, if\n   * additional parameters or return values are added, a new method should be defined.\n   *\n   * <h3>Obtaining question file</h3>\n   *\n   * If the question engine already has this question in its cache, it will use that (questions of\n   * the same version are guaranteed not to change). Otherwise it retrieves questions using the\n   * following URL:\n   *\n   * <p><i>questionBaseURL</i>/<i>questionID</i>.<i>questionversion</i>\n   *\n   * <p>For security reasons, the URL may be https: and the test navigator (which is likely to be\n   * the thing serving the URL) will operate an IP whitelist, only responding to requests from\n   * question engines it has already initiated connections to.\n   *\n   * <h3>Initial parameters</h3>\n   *\n   * initialParamNames and initialParamValues (which must be of equal length) include initial\n   * configuration parameters to be passed to the question.\n   *\n   * <table border=\"1\">\n   * <tr><th>Name</th><th>Value</th></tr>\n   * <tr><td>randomseed</td><td>Random number seed given to question, which\n   * should be based on the current user, the test, and the number of times\n   * they've started this question before. Parsed as decimal integer (up to\n   * 64 bit)</td></tr>\n   * </table>\n   *\n   * @param questionID Unique ID of question\n   * @param questionVersion Version identifier of question (should include only filename-space\n   *     characters, probably just digits and full stops). May be null, to indicate that the\n   *     question may not be cached (for preview usage only)\n   * @param questionBaseURL Base URL for questions (see above)\n   * @param initialParamNames Names of initial parameters\n   * @param initialParamValues Values of initial parameters\n   * @param cachedResources List of resources that the Test Navigator has cached\n   * @return Various data in order to provide the initial page of the question\n   * @throws OmException Whenever something goes wrong\n   */\n  public StartReturn start(\n      String questionID,\n      String questionVersion,\n      String questionBaseURL,\n      String[] initialParamNames,\n      String[] initialParamValues,\n      String[] cachedResources)\n      throws OmException {\n    setServletForThread();\n    if (initialParamNames == null) initialParamNames = new String[0];\n    if (initialParamValues == null) initialParamValues = new String[0];\n    if (cachedResources == null) cachedResources = new String[0];\n\n    try {\n      // Slurp values from parameters\n      if (initialParamNames.length != initialParamValues.length)\n        throw new OmException(\"Parameter name and value arrays of different length\");\n      long lRandomSeed = 0;\n      boolean bGotRandomSeed = false;\n      String sFixedFG = null, sFixedBG = null;\n      boolean bPlain = false;\n      double dZoom = 1.0;\n      int iFixedVariant = -1;\n\n      for (int i = 0; i < initialParamNames.length; i++) {\n        String sName = initialParamNames[i], sValue = initialParamValues[i];\n        if (sName.equals(\"randomseed\")) {\n          lRandomSeed = Long.parseLong(sValue);\n          bGotRandomSeed = true;\n        } else if (sName.equals(\"fixedfg\")) {\n          sFixedFG = sValue;\n        } else if (sName.equals(\"fixedbg\")) {\n          sFixedBG = sValue;\n        } else if (sName.equals(\"plain\")) {\n          bPlain = sValue.equals(\"yes\");\n        } else if (sName.equals(\"zoom\")) {\n          dZoom = Double.parseDouble(sValue);\n        } else if (sName.equals(\"fixedvariant\")) {\n          iFixedVariant = Integer.parseInt(sValue);\n        }\n      }\n      if (!bGotRandomSeed) throw new OmException(\"Required parameter missing: randomseed\");\n\n      // Get question into cache\n      QuestionCache.QuestionKey qk = new QuestionCache.QuestionKey(questionID, questionVersion);\n      obtainQuestion(questionBaseURL, qk);\n\n      // Create and initialise question\n      QuestionCache.QuestionInstance qi = qc.newQuestion(qk);\n      Question q = qi.q;\n      InitParams ip =\n          new InitParams(\n              lRandomSeed, sFixedFG, sFixedBG, dZoom, bPlain, qi.ccl, iFixedVariant, this);\n      Rendering r = q.init(qc.getMetadata(qk), ip);\n\n      // Generate session details and store in map\n      QuestionSession qs = new QuestionSession();\n      qs.q = q;\n      qs.lLastUsedTime = System.currentTimeMillis();\n      String sSession;\n      synchronized (this) {\n        sSession = \"\" + (iNextSessionID++);\n        qs.sSession = sSession;\n        mQuestionSessions.put(sSession, qs);\n      }\n\n      return new StartReturn(sSession, r);\n    } catch (Throwable t) {\n      throw handleException(\"start\", t);\n    } finally {\n      unsetServletForThread();\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1625, "initialization": ["String s = get(String,*,SecurePreferencesContainer)"], "initializationStart": [191], "initializationEnd": [216], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s==null)", "guardType": "IF {", "guardExpressionStart": 222, "guardExpressionEnd": 240, "guardBlockStart": 222, "guardBlockEnd": 261, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 285, "focalAPIEnd": 310, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/rt.equinox.bundles/tree/master/bundles/org.eclipse.equinox.security/src/org/eclipse/equinox/internal/security/storage/SecurePreferences.java", "rawCode": "  public double getDouble(String key, double defaultValue, SecurePreferencesContainer container)\n      throws StorageException {\n    if (!hasKey(key)) return defaultValue;\n    String value = get(key, null, container);\n    if (value == null) return defaultValue;\n    try {\n      return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n      return defaultValue;\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1626, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 2455, "focalAPIEnd": 2481, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new VirtualEntityShell(int,long[],LinkedList<Integer>,HashMap<Integer,val,*,boolean)"], "useStart": [2378], "useEnd": [2494], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/XavierJoudiou/Stage_LIP6/tree/master/CacheCode/SolipsisPeersim/src/peersim/tracePlayer/TraceReader.java", "rawCode": "  private void readSyntheticTrace() throws IOException, InterruptedException {\n    String coord0;\n    String coord1;\n    String radius;\n    String id;\n    String neighborId;\n    String modulo;\n    int count;\n    char c;\n    int readValue;\n    boolean sw;\n    VirtualEntityShell entity;\n    LinkedList<Integer> neighbors;\n    HashMap<Integer, Integer> qualities;\n    boolean currentStep = true;\n    long[] coord, precCoord;\n    HashMap<Long, VirtualEntityInterface> distrib;\n    LinkedList<VirtualEntityInterface> neighborEntities;\n    int nId, idlong;\n    boolean stabilized = false;\n    VirtualWorldDistributionShell distribution = new VirtualWorldDistributionShell(this.mapSize);\n\n    while (currentStep) {\n      radius = \"\";\n      id = \"\";\n      coord0 = \"\";\n      coord1 = \"\";\n      neighborId = \"\";\n      modulo = \"\";\n      count = 0;\n      neighbors = new LinkedList<Integer>();\n      qualities = new HashMap<Integer, Integer>();\n      sw = false;\n      c = 'e';\n      while (c != '\\n') {\n        readValue = file.read();\n        if (readValue == -1) {\n          this.thirdThread.finish();\n          throw new IOException();\n        }\n        c = (char) readValue;\n        if (c == '*') {\n          currentStep = false;\n          break;\n        } else if (c == ':') {\n          count++;\n          if (count > 5) sw = true;\n        } else {\n          switch (count) {\n            case 0:\n              id += c;\n              break;\n            case 1:\n              radius += c;\n              break;\n            case 2:\n              coord0 += c;\n              break;\n            case 3:\n              coord1 += c;\n              break;\n            case 4:\n              stabilized = (c == '0') ? false : true;\n              break;\n            default:\n              if (sw == true) {\n                nId = Integer.parseInt(neighborId);\n                neighbors.add(nId);\n                qualities.put(nId, Integer.parseInt(\"\" + c));\n                file.read();\n                sw = false;\n                neighborId = \"\";\n              } else {\n                neighborId += c;\n              }\n              break;\n          }\n        }\n      }\n      if (currentStep) {\n        coord = new long[3];\n        coord[0] = Long.parseLong(coord0);\n        coord[1] = Long.parseLong(coord1);\n        idlong = Integer.parseInt(id);\n        VirtualEntityShell shell =\n            new VirtualEntityShell(\n                idlong, coord, neighbors, qualities, Double.parseDouble(radius), stabilized);\n        precCoord = distribution.getFormerLocation(idlong);\n        shell.setMovement(\n            precCoord == null || precCoord[0] != coord[0] || precCoord[1] != coord[1]);\n        distribution.addToDistribution(shell);\n      }\n    }\n    this.thirdThread.organize(distribution);\n    this.stepsRead++;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1627, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s.length()==0)", "guardType": "IF {", "guardExpressionStart": 153, "guardExpressionEnd": 183, "guardBlockStart": 153, "guardBlockEnd": 878, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 329, "focalAPIEnd": 360, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rwl/DSS/tree/master/dss/src/main/java/com/ncond/dss/parser/Parser.java", "rawCode": "  public double doubleValue() {\n    int[] code = new int[1];\n    double dbl = 0;\n\n    if (autoIncrement) getNextParam();\n\n    convertError = false;\n\n    if (tokenBuffer.length() == 0) {\n      dbl = 0.0;\n    } else {\n      if (isQuotedString) {\n        dbl = interpretRPNString(code);\n      } else {\n        try {\n          dbl = Double.parseDouble(tokenBuffer);\n          code[0] = 0;\n        } catch (NumberFormatException e) {\n          code[0] = 1; // index of the offending character\n        }\n      }\n\n      if (code[0] != 0) {\n        // not needed with throw ... result = 0.0;\n        convertError = true;\n        // throw new ParserProblem(\"Floating point number conversion error for string: \\\"\" +\n        // tokenBuffer + \"\\\"\");\n        DSS.forms.messageDlg(\n            \"Floating point number conversion error for string: \\\"\" + tokenBuffer + \"\\\"\", true);\n      }\n    }\n\n    return dbl;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1628, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["new ProtocolException(String,*,*)"], "tryExpressionStart": 325, "tryExpressionEnd": 329, "tryBlockStart": 325, "tryBlockEnd": 693, "catchExpressionStart": 587, "catchExpressionEnd": 619, "catchBlockStart": 587, "catchBlockEnd": 693, "exceptionHandlingCallStart": [633], "exceptionHandlingCallEnd": [686], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 397, "focalAPIEnd": 424, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["of(*,val)", "double.parseDouble(*)", "double.parseDouble(*)"], "useStart": [364, 472, 550], "useEnd": [425, 499, 577], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/syphr42/libmythtv-java/tree/master/control/src/main/java/org/syphr/mythtv/control/impl/Command0_24QueryLoad.java", "rawCode": "  @SuppressWarnings(\"unchecked\")\n  @Override\n  public Load send(SocketManager socketManager) throws IOException {\n    String response = socketManager.sendAndWait(getMessage());\n    String[] args = response.split(\"\\\\s+\");\n\n    if (args.length != 3) {\n      throw new ProtocolException(response, Direction.RECEIVE);\n    }\n\n    try {\n      return new Load(\n          Pair.of(LoadCategory.ONE_MINUTE, Double.parseDouble(args[0])),\n          Pair.of(LoadCategory.FIVE_MINUTES, Double.parseDouble(args[1])),\n          Pair.of(LoadCategory.FIFTEEN_MINUTES, Double.parseDouble(args[2])));\n    } catch (NumberFormatException e) {\n      throw new ProtocolException(response, Direction.RECEIVE, e);\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1629, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 44, "focalAPIEnd": 69, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/trunk/src/net/sourceforge/plantuml/jasic/Jasic.java", "rawCode": "    public double toNumber() {\n      return Double.parseDouble(value);\n    }\n"}, {"dataset": "parseDouble", "exampleID": 1630, "initialization": ["String s = Properties.getProperty(String,String)"], "initializationStart": [590], "initializationEnd": [624], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s.indexOf(\":\",)<0", "guardType": "IF {", "guardExpressionStart": 630, "guardExpressionEnd": 656, "guardBlockStart": 630, "guardBlockEnd": 703, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 672, "focalAPIEnd": 696, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ieure/lucene-solr-snapshot/tree/master/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java", "rawCode": "  /**\n   * Return a double property. If the property contain \":\", e.g. \"10:100:5\", it is interpreted as\n   * array of doubles. It is extracted once, on first call to get() it, and a by-round-value is\n   * returned.\n   *\n   * @param name name of property\n   * @param dflt default value\n   * @return a double property.\n   */\n  public double get(String name, double dflt) {\n    // use value by round if already parsed\n    double vals[] = (double[]) valByRound.get(name);\n    if (vals != null) {\n      return vals[roundNumber % vals.length];\n    }\n    // done if not by round\n    String sval = props.getProperty(name, \"\" + dflt);\n    if (sval.indexOf(\":\") < 0) {\n      return Double.parseDouble(sval);\n    }\n    // first time this prop is extracted by round\n    int k = sval.indexOf(\":\");\n    String colName = sval.substring(0, k);\n    sval = sval.substring(k + 1);\n    colForValByRound.put(name, colName);\n    vals = propToDoubleArray(sval);\n    valByRound.put(name, vals);\n    return vals[roundNumber % vals.length];\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1631, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 357, "focalAPIEnd": 387, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)"], "useStart": [530], "useEnd": [579], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/samthiriot/genlab/tree/master/genlab.graphstream.corejar/src/org/graphstream/graph/implementations/AbstractElement.java", "rawCode": "  /** @complexity O(log(n)) with n being the number of attributes of this element. */\n  public double getNumber(String key) {\n    if (attributes != null) {\n      Object o = attributes.get(key);\n\n      if (o != null) {\n        if (o instanceof Number) return ((Number) o).doubleValue();\n\n        if (o instanceof String) {\n          try {\n            return Double.parseDouble((String) o);\n          } catch (NumberFormatException e) {\n          }\n        } else if (o instanceof CharSequence) {\n          try {\n            return Double.parseDouble(((CharSequence) o).toString());\n          } catch (NumberFormatException e) {\n          }\n        }\n      }\n    }\n\n    if (nullAttributesAreErrors()) throw new NullAttributeException(key);\n\n    return Double.NaN;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1632, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["Logger.warn(String)"], "tryExpressionStart": 98, "tryExpressionEnd": 102, "tryBlockStart": 98, "tryBlockEnd": 247, "catchExpressionStart": 151, "catchExpressionEnd": 183, "catchBlockStart": 151, "catchBlockEnd": 247, "exceptionHandlingCallStart": [191], "exceptionHandlingCallEnd": [240], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 118, "focalAPIEnd": 142, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setMass(val)"], "useStart": [110], "useEnd": [143], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/acontes/programming/tree/master/src/Examples/org/objectweb/proactive/examples/nbody/common/PlanetDescription.java", "rawCode": "  /**\n   * Modifier\n   *\n   * @param mass new mass\n   */\n  public void setMass(String mass) {\n    try {\n      setMass(Double.parseDouble(mass));\n    } catch (NumberFormatException e) {\n      logger.warn(mass + \"is not a correct mass value\");\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1633, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["s.trim()"], "configurationStart": [85], "configurationEnd": [100], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 375, "focalAPIEnd": 403, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new EsPrimitiveNumberDouble(val)"], "useStart": [347], "useEnd": [404], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/craig-a-roach/geowx/tree/master/ebx/src/main/java/com/metservice/neon/EsPrimitiveString.java", "rawCode": "  public EsPrimitiveNumber toNumber(EsExecutionContext ecx) {\n    final String ztw = m_zValue.trim();\n    final int c = ztw.length();\n    if (c == 0) return EsPrimitiveNumberInteger.ZERO;\n\n    try {\n      return new EsPrimitiveNumberInteger(Integer.parseInt(m_zValue));\n    } catch (final NumberFormatException ex) {\n    }\n\n    try {\n      return new EsPrimitiveNumberDouble(Double.parseDouble(m_zValue));\n    } catch (final NumberFormatException ex) {\n    }\n\n    if (DateFactory.isWellFormedTX(m_zValue)) {\n      try {\n        return new EsPrimitiveNumberTime(DateFactory.newTsFromTX(m_zValue));\n      } catch (final ArgonFormatException ex) {\n      }\n    }\n\n    if (ElapsedFactory.isWellFormed(m_zValue)) {\n      try {\n        return new EsPrimitiveNumberElapsed(ElapsedFactory.ms(m_zValue));\n      } catch (final ArgonFormatException ex) {\n      }\n    }\n\n    if (Real.isWellFormed(m_zValue)) {\n      try {\n        return new EsPrimitiveNumberReal(Real.newInstance(m_zValue));\n      } catch (final ArgonFormatException ex) {\n      }\n    }\n    return EsPrimitiveNumberNot.Instance;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1634, "initialization": ["String s = getAttributeValue(String)", "String s = getText()"], "initializationStart": [731, 818], "initializationEnd": [765, 835], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 948, "focalAPIEnd": 973, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["put(*,val)", "format(String,val)"], "useStart": [1029, 1202], "useEnd": [1075, 1239], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/paoolo/stomp-contiki/tree/master/tools/cooja/apps/mrm/java/se/sics/mrm/ChannelModel.java", "rawCode": "  /**\n   * Sets the configuration depending on the given XML elements.\n   *\n   * @see #getConfigXML()\n   * @param configXML Config XML elements\n   * @return True if config was set successfully, false otherwise\n   */\n  public boolean setConfigXML(Collection<Element> configXML) {\n    for (Element element : configXML) {\n      if (element.getName().equals(\"obstacles\")) {\n        myObstacleWorld = new ObstacleWorld();\n        myObstacleWorld.setConfigXML(element.getChildren());\n      } else /* Parameter values */ {\n        String name = element.getName();\n        String value;\n        Parameter param = null;\n\n        if (name.equals(\"wavelength\")) {\n          /* Backwards compatability: ignored parameters */\n          value = element.getAttributeValue(\"value\");\n          if (value == null) {\n            value = element.getText();\n          }\n          // private static final double C = 299792458; /* m/s */\n          double frequency = C / Double.parseDouble(value);\n          frequency /= 1000000.0; /* mhz */\n          parameters.put(Parameter.frequency, frequency); /* mhz */\n\n          logger.warn(\n              \"MRM parameter converted from wavelength to frequency: \"\n                  + String.format(\"%1.1f MHz\", frequency));\n          continue;\n        } else if (name.equals(\"tx_antenna_gain\") || name.equals(\"rx_antenna_gain\")) {\n          logger.warn(\"MRM parameter \\\"\" + name + \"\\\" was removed\");\n          continue;\n        } else if (Parameter.fromString(name) != null) {\n          /* Backwards compatability: renamed parameters */\n          param = Parameter.fromString(name);\n        } else {\n          param = Parameter.valueOf(name);\n        }\n\n        value = element.getAttributeValue(\"value\");\n        if (value == null || value.isEmpty()) {\n          /* Backwards compatability: renamed parameters */\n          value = element.getText();\n        }\n\n        Class<?> paramClass = parameters.get(param).getClass();\n        if (paramClass == Double.class) {\n          parameters.put(param, new Double(Double.parseDouble(value)));\n        } else if (paramClass == Boolean.class) {\n          parameters.put(param, Boolean.parseBoolean(value));\n        } else if (paramClass == Integer.class) {\n          parameters.put(param, Integer.parseInt(value));\n        } else {\n          logger.fatal(\"Unsupported class type: \" + paramClass);\n        }\n      }\n    }\n    needToPrecalculateFSPL = true;\n    needToPrecalculateOutputPower = true;\n    settingsObservable.notifySettingsChanged();\n    return true;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1635, "initialization": ["String s = readLine(String)"], "initializationStart": [95], "initializationEnd": [111], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["getName()", "getLogger(*)", "log(*,*,*)"], "tryExpressionStart": 66, "tryExpressionEnd": 70, "tryBlockStart": 66, "tryBlockEnd": 316, "catchExpressionStart": 195, "catchExpressionEnd": 228, "catchBlockStart": 195, "catchBlockEnd": 316, "exceptionHandlingCallStart": [255, 238, 238], "exceptionHandlingCallEnd": [278, 279, 307], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 137, "focalAPIEnd": 162, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ajorgesantosp/EAPLI_PL_2DB/tree/master/eapli.util/src/eapli/util/Console.java", "rawCode": "  public static double readDouble(String prompt) {\n    do {\n      try {\n        String input = readLine(prompt);\n\n        double valor = Double.parseDouble(input);\n\n        return valor;\n      } catch (NumberFormatException ex) {\n        Logger.getLogger(Console.class.getName()).log(Level.SEVERE, null, ex);\n      }\n    } while (true);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1636, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["quote(String)", "new JSONException(String)"], "tryExpressionStart": 364, "tryExpressionEnd": 368, "tryBlockStart": 364, "tryBlockEnd": 616, "catchExpressionStart": 507, "catchExpressionEnd": 527, "catchBlockStart": 507, "catchBlockEnd": 616, "exceptionHandlingCallStart": [575, 541], "exceptionHandlingCallEnd": [585, 609], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 464, "focalAPIEnd": 499, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/leoncool/healthbook/tree/master/src/org/json/JSONObject.java", "rawCode": "  /**\n   * Get the double value associated with a key.\n   *\n   * @param key A key string.\n   * @return The numeric value.\n   * @throws JSONException if the key is not found or if the value is not a Number object and cannot\n   *     be converted to a number.\n   */\n  public double getDouble(String key) throws JSONException {\n    Object object = this.get(key);\n    try {\n      return object instanceof Number\n          ? ((Number) object).doubleValue()\n          : Double.parseDouble((String) object);\n    } catch (Exception e) {\n      throw new JSONException(\"JSONObject[\" + quote(key) + \"] is not a number.\");\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1637, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 542, "focalAPIEnd": 565, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(*,val)"], "useStart": [511], "useEnd": [566], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/test/java/libcore/sqlite/OldFunctionContextTest.java", "rawCode": "  public void testSet_resultDouble() throws Exception {\n    SinFunc testD = new SinFunc();\n    db.exec(\n        \"insert into \"\n            + DatabaseCreator.TEST_TABLE2\n            + \" (fdouble) values (\"\n            + testD.testDouble\n            + \")\",\n        null);\n    db.create_function(\"testDouble\", 1, testD);\n    TableResult res =\n        db.get_table(\"select testDouble(fdouble) from \" + DatabaseCreator.TEST_TABLE2);\n    String row[] = (String[]) res.rows.elementAt(0);\n    String val = row[0];\n\n    assertEquals(testD.testDouble, Double.parseDouble(val));\n\n    assertTrue(testD.functionCalled);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1638, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["compareToIgnoreCase(String)", "compareTo(String)"], "tryExpressionStart": 299, "tryExpressionEnd": 303, "tryBlockStart": 299, "tryBlockEnd": 530, "catchExpressionStart": 358, "catchExpressionEnd": 392, "catchBlockStart": 358, "catchBlockEnd": 530, "exceptionHandlingCallStart": [430, 488], "exceptionHandlingCallEnd": [475, 523], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 316, "focalAPIEnd": 350, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(String)", "double.compare(double,double)"], "useStart": [553, 595], "useEnd": [582, 617], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iwabuchiken/freemind/tree/master/freemind/freemind/controller/filter/condition/CompareConditionAdapter.java", "rawCode": "  protected int compareTo(String nodeValue) throws NumberFormatException {\n    try {\n      int i2 = Integer.parseInt(conditionValue);\n      int i1 = Integer.parseInt(nodeValue);\n      return i1 < i2 ? -1 : (i1 == i2 ? 0 : 1);\n    } catch (NumberFormatException fne) {\n    }\n    ;\n    double d2;\n    try {\n      d2 = Double.parseDouble(conditionValue);\n    } catch (NumberFormatException fne) {\n      return ignoreCase\n          ? nodeValue.compareToIgnoreCase(conditionValue)\n          : nodeValue.compareTo(conditionValue);\n    }\n    ;\n    double d1 = Double.parseDouble(nodeValue);\n    return Double.compare(d1, d2);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1639, "initialization": ["String s = getAttribute(Node,String)"], "initializationStart": [879], "initializationEnd": [907], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1977, "focalAPIEnd": 2002, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mauricio/jai-imageio/tree/master/src/share/classes/com/sun/media/imageio/plugins/tiff/TIFFField.java", "rawCode": "  private static void initData(Node node, int[] otype, int[] ocount, Object[] odata) {\n    int type;\n    int count;\n    Object data = null;\n\n    String typeName = node.getNodeName();\n    typeName = typeName.substring(4);\n    typeName = typeName.substring(0, typeName.length() - 1);\n    type = TIFFField.getTypeByName(typeName);\n    if (type == -1) {\n      throw new IllegalArgumentException(\"typeName = \" + typeName);\n    }\n\n    Node child = node.getFirstChild();\n\n    count = 0;\n    while (child != null) {\n      String childTypeName = child.getNodeName().substring(4);\n      if (!typeName.equals(childTypeName)) {\n        // warning\n      }\n\n      ++count;\n      child = child.getNextSibling();\n    }\n\n    if (count > 0) {\n      data = createArrayForType(type, count);\n      child = node.getFirstChild();\n      int idx = 0;\n      while (child != null) {\n        String value = getAttribute(child, \"value\");\n\n        String numerator, denominator;\n        int slashPos;\n\n        switch (type) {\n          case TIFFTag.TIFF_ASCII:\n            ((String[]) data)[idx] = value;\n            break;\n          case TIFFTag.TIFF_BYTE:\n          case TIFFTag.TIFF_SBYTE:\n            ((byte[]) data)[idx] = (byte) Integer.parseInt(value);\n            break;\n          case TIFFTag.TIFF_SHORT:\n            ((char[]) data)[idx] = (char) Integer.parseInt(value);\n            break;\n          case TIFFTag.TIFF_SSHORT:\n            ((short[]) data)[idx] = (short) Integer.parseInt(value);\n            break;\n          case TIFFTag.TIFF_SLONG:\n            ((int[]) data)[idx] = (int) Integer.parseInt(value);\n            break;\n          case TIFFTag.TIFF_LONG:\n          case TIFFTag.TIFF_IFD_POINTER:\n            ((long[]) data)[idx] = (long) Long.parseLong(value);\n            break;\n          case TIFFTag.TIFF_FLOAT:\n            ((float[]) data)[idx] = (float) Float.parseFloat(value);\n            break;\n          case TIFFTag.TIFF_DOUBLE:\n            ((double[]) data)[idx] = (double) Double.parseDouble(value);\n            break;\n          case TIFFTag.TIFF_SRATIONAL:\n            slashPos = value.indexOf(\"/\");\n            numerator = value.substring(0, slashPos);\n            denominator = value.substring(slashPos + 1);\n\n            ((int[][]) data)[idx] = new int[2];\n            ((int[][]) data)[idx][0] = Integer.parseInt(numerator);\n            ((int[][]) data)[idx][1] = Integer.parseInt(denominator);\n            break;\n          case TIFFTag.TIFF_RATIONAL:\n            slashPos = value.indexOf(\"/\");\n            numerator = value.substring(0, slashPos);\n            denominator = value.substring(slashPos + 1);\n\n            ((long[][]) data)[idx] = new long[2];\n            ((long[][]) data)[idx][0] = Long.parseLong(numerator);\n            ((long[][]) data)[idx][1] = Long.parseLong(denominator);\n            break;\n          default:\n            // error\n        }\n\n        idx++;\n        child = child.getNextSibling();\n      }\n    }\n\n    otype[0] = type;\n    ocount[0] = count;\n    odata[0] = data;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1640, "initialization": ["String s = getAttribute(*)"], "initializationStart": [748], "initializationEnd": [795], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["getNodeName()", "new InputConfigException(String)"], "tryExpressionStart": 854, "tryExpressionEnd": 858, "tryBlockStart": 854, "tryBlockEnd": 1107, "catchExpressionStart": 947, "catchExpressionEnd": 981, "catchBlockStart": 947, "catchBlockEnd": 1107, "exceptionHandlingCallStart": [1081, 997], "exceptionHandlingCallEnd": [1097, 1098], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s!=null&&s.length()>0", "guardType": "IF {", "guardExpressionStart": 801, "guardExpressionEnd": 845, "guardBlockStart": 801, "guardBlockEnd": 1113, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 882, "focalAPIEnd": 909, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setFrequency(val)"], "useStart": [919], "useEnd": [937], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brendanofallon/ACG/tree/master/src/newgui/gui/modelElements/DoubleModifierElement.java", "rawCode": "  public void readElement(Element el) throws InputConfigException {\n    String className = el.getAttribute(XMLLoader.CLASS_NAME_ATTR);\n    if (className == null) {\n      throw new InputConfigException(\"No class found for element with label : \" + el.getNodeName());\n    }\n\n    if ((!className.equals(SimpleModifier.class.getCanonicalName()))\n        && (!className.equals(ScaleModifier.class.getCanonicalName()))) {\n      throw new InputConfigException(\"Element is not of class Simple or Scale Modifier\");\n    }\n\n    setLabel(el.getNodeName());\n    if (className.equals(SimpleModifier.class.getCanonicalName())) setType(ModType.Simple);\n    if (className.equals(ScaleModifier.class.getCanonicalName())) setType(ModType.Scale);\n\n    String freqStr = el.getAttribute(AbstractModifier.XML_FREQUENCY);\n    if (freqStr != null && freqStr.length() > 0) {\n      try {\n        Double freq = Double.parseDouble(freqStr);\n        setFrequency(freq);\n      } catch (NumberFormatException nfe) {\n        throw new InputConfigException(\n            \"Could not parse frequency from element : \" + el.getNodeName());\n      }\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1641, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s.equals(NAN,))", "guardType": "IF {", "guardExpressionStart": 43, "guardExpressionEnd": 63, "guardBlockStart": 43, "guardBlockEnd": 147, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 117, "focalAPIEnd": 140, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/absperf/collectd/tree/master/bindings/java/org/collectd/api/DataSource.java", "rawCode": "  static double toDouble(String val) {\n    if (val.equals(NAN)) {\n      return Double.NaN;\n    } else {\n      return Double.parseDouble(val);\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1642, "initialization": ["String s = Scanner.next()", "String s = trim()"], "initializationStart": [409, 559], "initializationEnd": [418, 575], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["getMessage()", "println(String)"], "tryExpressionStart": 261, "tryExpressionEnd": 265, "tryBlockStart": 261, "tryBlockEnd": 1830, "catchExpressionStart": 1611, "catchExpressionEnd": 1643, "catchBlockStart": 1611, "catchBlockEnd": 1736, "exceptionHandlingCallStart": [1714, 1651], "exceptionHandlingCallEnd": [1728, 1729], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 804, "focalAPIEnd": 836, "followUpCheck": "val > 0", "checkType": "IF", "followUpCheckExpressionStart": 942, "followUpCheckExpressionEnd": 957, "followUpCheckBlockStart": 942, "followUpCheckBlockEnd": 1058, "use": ["Person.addArrtibuteWeight(val)"], "useStart": [1068], "useEnd": [1101], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ggppwx/heuristic-problem-solving-/tree/master/src/dating/DatingServer/src/server/ValidateP.java", "rawCode": "  public static void validatemain(int noOfAttributes, String fileName, Person person) {\n\n    Pattern pattern = Pattern.compile(\"^(-)?\\\\d{1}(\\\\.\\\\d{0,2})?$\");\n    double positiveAttrSum = 0.0;\n    double negativeAttrSum = 0.0;\n    int attributeCounter = 0;\n\n    try {\n      FileReader reader = new FileReader(fileName);\n      Scanner sc = new Scanner(reader);\n      while (sc.hasNext()) {\n        String str = sc.next();\n        if (str.contains(\"weights\")) break;\n      }\n      while (sc.hasNext()) {\n        attributeCounter++;\n        String weightString = sc.next().trim();\n\n        if (!pattern.matcher(weightString).matches()) {\n          throw new InputMismatchException(\n              \"Input file weight \" + weightString + \" do not match the required pattern.\");\n        }\n        Double weight = Double.parseDouble(weightString);\n\n        assert (weight <= 1 && weight >= -1) : \"Provided weighs do not lie in range [-1, 1]\";\n\n        if (weight > 0) positiveAttrSum = positiveAttrSum + weight;\n        else negativeAttrSum = negativeAttrSum + weight;\n\n        person.addArrtibuteWeight(weight);\n      }\n      assert (attributeCounter == noOfAttributes)\n          : \"Number of attribtes provided do not match the required number.\";\n\n      DecimalFormat twoDecimalFormat = new DecimalFormat(\"#.##\");\n\n      assert (Double.valueOf(twoDecimalFormat.format(positiveAttrSum)) == 1)\n          : \"Sum of positive weights is not 1 but \" + positiveAttrSum;\n      assert (Double.valueOf(twoDecimalFormat.format(negativeAttrSum)) == -1)\n          : \"Sum of negative weights is not -1 but \" + negativeAttrSum;\n    } catch (NumberFormatException e) {\n      System.out.println(\"Unable to parse the weights provided.\\n\" + e.getMessage());\n    } catch (FileNotFoundException e) {\n      System.out.println(\"File Not Found Exception\");\n    }\n\n    System.out.println(\"Input file validated!!!\");\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1643, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["format(String,String)", "new MarshalException(*,*)"], "tryExpressionStart": 213, "tryExpressionEnd": 217, "tryBlockStart": 213, "tryBlockEnd": 401, "catchExpressionStart": 263, "catchExpressionEnd": 296, "catchBlockStart": 263, "catchBlockEnd": 401, "exceptionHandlingCallStart": [331, 310], "exceptionHandlingCallEnd": [389, 394], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s.isEmpty())", "guardType": "IF {", "guardExpressionStart": 131, "guardExpressionEnd": 152, "guardBlockStart": 131, "guardBlockEnd": 193, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 229, "focalAPIEnd": 255, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["decompose(val)"], "useStart": [414], "useEnd": [426], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/godares79/CS848-Project/tree/master/apache-cassandra-1.1.6-src/src/java/org/apache/cassandra/db/marshal/DoubleType.java", "rawCode": "  public ByteBuffer fromString(String source) throws MarshalException {\n    // Return an empty ByteBuffer for an empty string.\n    if (source.isEmpty()) return ByteBufferUtil.EMPTY_BYTE_BUFFER;\n\n    Double d;\n    try {\n      d = Double.parseDouble(source);\n    } catch (NumberFormatException e1) {\n      throw new MarshalException(String.format(\"unable to coerce '%s' to a double\", source), e1);\n    }\n\n    return decompose(d);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1644, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 206, "focalAPIEnd": 243, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "double.parseDouble(String)"], "useStart": [266, 327], "useEnd": [303, 353], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gvtools/gvtools-legacy/tree/master/extensions/extWMS/src/com/iver/cit/gvsig/fmap/layers/DefaultDimension.java", "rawCode": "  public int valueCount() {\n    if (compiled) {\n      if (type == MULTIPLE_VALUE) {\n        return expression.split(\",\").length;\n      } else if (type == INTERVAL) {\n        int count;\n        double min = Double.parseDouble((String) minValue);\n        double max = Double.parseDouble((String) maxValue);\n        double step = Double.parseDouble(period);\n        double distance = max - min;\n        count = (int) (distance / step);\n        return count;\n      } else {\n        return 1;\n      }\n    }\n    return -1;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1645, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 364, "focalAPIEnd": 397, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "new GeolocationSearchItem(val,*)"], "useStart": [399, 317], "useEnd": [432, 433], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tastejs/PropertyCross/tree/master/mgwt/src/main/java/com/propertycross/mgwt/activity/PropertyCrossActivity.java", "rawCode": "        @Override\n        public void recentSearchSelected(Search search) {\n          if (search.searchText().startsWith(GeolocationSearchItem.SEARCH_PREFIX)) {\n            String latLon = search.searchText().substring(4);\n            String[] components = latLon.split(\",\");\n            searchItem =\n                new GeolocationSearchItem(\n                    Double.parseDouble(components[0]), Double.parseDouble(components[1]));\n          } else {\n            searchItem = new PlainTextSearchItem(search.displayText(), search.searchText());\n          }\n          view.setSearchText(searchItem.getDisplayText());\n          searchForProperties();\n        }\n"}, {"dataset": "parseDouble", "exampleID": 1646, "initialization": ["String s = String.substring(int)"], "initializationStart": [767], "initializationEnd": [781], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["s.substring(int)"], "configurationStart": [767], "configurationEnd": [781], "guardCondition": "s.startsWith(\"=+\",) && !(s.equals(\"=*\",)) && s.equals(\"null\",)", "guardType": "IF {", "guardExpressionStart": 95, "guardExpressionEnd": 116, "guardBlockStart": 95, "guardBlockEnd": 788, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1281, "focalAPIEnd": 1302, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["updateDouble(int,val)"], "useStart": [1252], "useEnd": [1303], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yudis/h2database/tree/master/h2/src/main/org/h2/server/web/WebApp.java", "rawCode": "  private void unescapeData(String x, ResultSet rs, int columnIndex) throws SQLException {\n    if (x.equals(\"null\")) {\n      rs.updateNull(columnIndex);\n      return;\n    } else if (x.startsWith(\"=+\")) {\n      // don't update\n      return;\n    } else if (x.equals(\"=*\")) {\n      // set an appropriate default value\n      int type = rs.getMetaData().getColumnType(columnIndex);\n      switch (type) {\n        case Types.TIME:\n          rs.updateString(columnIndex, \"12:00:00\");\n          break;\n        case Types.TIMESTAMP:\n        case Types.DATE:\n          rs.updateString(columnIndex, \"2001-01-01\");\n          break;\n        default:\n          rs.updateString(columnIndex, \"1\");\n          break;\n      }\n      return;\n    } else if (x.startsWith(\"= \")) {\n      x = x.substring(2);\n    }\n    ResultSetMetaData meta = rs.getMetaData();\n    int type = meta.getColumnType(columnIndex);\n    if (session.getContents().isH2) {\n      rs.updateString(columnIndex, x);\n      return;\n    }\n    switch (type) {\n      case Types.BIGINT:\n        rs.updateLong(columnIndex, Long.decode(x));\n        break;\n      case Types.DECIMAL:\n        rs.updateBigDecimal(columnIndex, new BigDecimal(x));\n        break;\n      case Types.DOUBLE:\n      case Types.FLOAT:\n        rs.updateDouble(columnIndex, Double.parseDouble(x));\n        break;\n      case Types.REAL:\n        rs.updateFloat(columnIndex, Float.parseFloat(x));\n        break;\n      case Types.INTEGER:\n        rs.updateInt(columnIndex, Integer.decode(x));\n        break;\n      case Types.TINYINT:\n        rs.updateShort(columnIndex, Short.decode(x));\n        break;\n      default:\n        rs.updateString(columnIndex, x);\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1647, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 55, "focalAPIEnd": 80, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mmastrac/nanojson/tree/master/src/main/java/com/grack/nanojson/JsonLazyNumber.java", "rawCode": "  @Override\n  public double doubleValue() {\n    return Double.parseDouble(value);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1648, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 187, "focalAPIEnd": 237, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(String)", "tileNumberOfR(val,double)", "tileNumberOfS(val,double)", "tileOfR(val,double)"], "useStart": [256, 385, 470, 557], "useEnd": [306, 408, 493, 574], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wjcquking/fuzzyJoin/tree/master/WordCount/src/org/macau/flickr/spatial/test/GridSpatialMapperTest.java", "rawCode": "  public static void main(String[] args) {\n    String value =\n        \"14136087281:26847:48.847292:2.336096:1258276450000:0;119;154;230;1361;2116;2642;2746;5703;42423\";\n\n    double lat = Double.parseDouble(value.toString().split(\":\")[2]);\n    double lon = Double.parseDouble(value.toString().split(\":\")[3]);\n\n    ArrayList<Integer> tileList = new ArrayList<Integer>();\n\n    tileList = tileNumberOfR(lat, lon);\n    System.out.println(tileList.toString());\n    tileList = tileNumberOfS(lat, lon);\n\n    System.out.println(tileList.toString());\n\n    tileList = tileOfR(lat, lon);\n    System.out.println(tileList.size());\n    System.out.println(tileList.toString());\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1649, "initialization": ["String s = unquote(String)"], "initializationStart": [296], "initializationEnd": [310], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 329, "focalAPIEnd": 354, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stormpath/stormpath-sdk-java/tree/master/impl/src/main/java/com/stormpath/sdk/impl/http/MediaType.java", "rawCode": "  private void checkParameters(String attribute, String value) {\n    Assert.hasLength(attribute, \"parameter attribute must not be empty\");\n    Assert.hasLength(value, \"parameter value must not be empty\");\n    checkToken(attribute);\n    if (PARAM_QUALITY_FACTOR.equals(attribute)) {\n      value = unquote(value);\n      double d = Double.parseDouble(value);\n      Assert.isTrue(\n          d >= 0D && d <= 1D,\n          \"Invalid quality value \\\"\" + value + \"\\\": should be between 0.0 and 1.0\");\n    } else if (PARAM_CHARSET.equals(attribute)) {\n      value = unquote(value);\n      Charset.forName(value);\n    } else if (!isQuotedString(value)) {\n      checkToken(value);\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1650, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 913, "focalAPIEnd": 942, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "double.parseDouble(*)", "double.parseDouble(*)", "double.parseDouble(*)"], "useStart": [962, 1011, 1060, 1109], "useEnd": [991, 1040, 1089, 1138], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chartsy/chartsy/tree/master/Chartsy/Main/src/org/chartsy/main/managers/CacheManager.java", "rawCode": "  public Dataset fetchVisibleDatasetFromCache(String fileName, int period, int end)\n      throws IOException {\n    String folder = FileUtils.cacheDatasetsFolder();\n    File file = FileUtils.hashedCacheFile(folder, fileName);\n\n    Properties properties = new Properties();\n    FileInputStream fileInputStream = new FileInputStream(file);\n    properties.load(fileInputStream);\n\n    List<DataItem> items = new ArrayList<DataItem>();\n    int size = properties.size();\n    for (int i = 0; i < period; i++) {\n      int j = end - period + i;\n      if (j < size && j >= 0) {\n        String key = Integer.toString(j);\n        String property = properties.getProperty(key);\n        if (property.equals(\"null\")) {\n          items.add(null);\n        } else {\n          String[] values = property.split(\",\");\n          DataItem item =\n              new DataItem(\n                  Long.parseLong(values[0]),\n                  Double.parseDouble(values[1]),\n                  Double.parseDouble(values[2]),\n                  Double.parseDouble(values[3]),\n                  Double.parseDouble(values[4]),\n                  Double.parseDouble(values[5]));\n          items.add(item);\n        }\n      }\n    }\n\n    fileInputStream.close();\n    Dataset dataset = new Dataset(items);\n    return dataset;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1651, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 274, "focalAPIEnd": 319, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(*,val)", "double.parseDouble(String)", "double.parseDouble(String)", "double.parseDouble(String)", "double.parseDouble(String)", "double.parseDouble(String)", "double.parseDouble(String)"], "useStart": [236, 364, 458, 555, 650, 742, 840], "useEnd": [320, 413, 510, 605, 697, 794, 886], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/libcore/java/lang/DoubleTest.java", "rawCode": "  /**\n   * This value has been known to cause javac and java to infinite loop.\n   * http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/\n   */\n  public void testParseLargestSubnormalDoublePrecision() {\n    assertEquals(2.2250738585072014E-308, Double.parseDouble(\"2.2250738585072012e-308\"));\n    assertEquals(2.2250738585072014E-308, Double.parseDouble(\"0.00022250738585072012e-304\"));\n    assertEquals(2.2250738585072014E-308, Double.parseDouble(\"00000002.2250738585072012e-308\"));\n    assertEquals(2.2250738585072014E-308, Double.parseDouble(\"2.225073858507201200000e-308\"));\n    assertEquals(2.2250738585072014E-308, Double.parseDouble(\"2.2250738585072012e-00308\"));\n    assertEquals(2.2250738585072014E-308, Double.parseDouble(\"2.22507385850720129978001e-308\"));\n    assertEquals(-2.2250738585072014E-308, Double.parseDouble(\"-2.2250738585072012e-308\"));\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1652, "initialization": ["String s = Element.getText()"], "initializationStart": [105], "initializationEnd": [119], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["InvCatalogFactory.appendErr(String)"], "tryExpressionStart": 125, "tryExpressionEnd": 129, "tryBlockStart": 125, "tryBlockEnd": 320, "catchExpressionStart": 176, "catchExpressionEnd": 208, "catchBlockStart": 176, "catchBlockEnd": 320, "exceptionHandlingCallStart": [216], "exceptionHandlingCallEnd": [288], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 144, "focalAPIEnd": 168, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Unidata/thredds/tree/master/cdm/src/main/java/thredds/catalog/parser/jdom/InvCatalogFactory10.java", "rawCode": "  protected double readDouble(Element elem) {\n    if (elem == null) return Double.NaN;\n    String text = elem.getText();\n    try {\n      return Double.parseDouble(text);\n    } catch (NumberFormatException e) {\n      factory.appendErr(\" ** Parse error: Bad double format = \" + text + \"\\n\");\n      return Double.NaN;\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1653, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 166, "focalAPIEnd": 191, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(String)", "double.parseDouble(String)", "new Publication(int,PropertyType,OperationType,String,String,val,int,*,*,*,List<PropertyServices>,String,boolean,boolean,List<Environment>)"], "useStart": [223, 260, 42], "useEnd": [250, 289, 427], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/amarseillan/paw/tree/master/zonaProp/src/main/java/zonaProp/web/command/PublicationForm.java", "rawCode": "  public Publication build() {\n    return new Publication(\n        publicationId,\n        propertyType,\n        operationType,\n        address,\n        city,\n        Double.parseDouble(price),\n        environments,\n        Double.parseDouble(covered),\n        Double.parseDouble(uncovered),\n        Integer.parseInt(age),\n        propertyServices,\n        description,\n        active,\n        reserved,\n        environmentList);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1654, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s.equals(\"-r\",)", "guardType": "IF {", "guardExpressionStart": 580, "guardExpressionEnd": 605, "guardBlockStart": 580, "guardBlockEnd": 1462, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 640, "focalAPIEnd": 667, "followUpCheck": "val > 1 || val < 0 || true || val + writeProp + updateProp != 1.0", "checkType": "IF", "followUpCheckExpressionStart": 1474, "followUpCheckExpressionEnd": 1669, "followUpCheckBlockStart": 1474, "followUpCheckBlockEnd": 1714, "use": ["double.parseDouble(*)", "double.parseDouble(*)", "new LoadSummary(val,double,double,int,int,String,int,String)"], "useStart": [743, 847, 2028], "useEnd": [770, 874, 2243], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lihaosky/shard/tree/master/simulator/client/ycsb/src/com/yahoo/ycsb/util/LoadGenerator.java", "rawCode": "  public static void main(String[] args)\n      throws FileNotFoundException, IOException, ClassNotFoundException {\n    double readProp = 0; // Read proportion\n    double writeProp = 0; // Write proportion\n    double updateProp = 0; // Update proportion\n    String distribution = \"zipfian\"; // Distribution: uniform, zipfian or latest\n    int operationCount = -1; // Number of opertions\n    int keyLength = 128; // Key length\n    int valueLength = 1024; // Value length\n    String outputFilePath = \"load.txt\"; // Output file path\n\n    for (int i = 0; i < args.length; i++) {\n      if (args[i].equals(\"-r\")) {\n        i++;\n        readProp = Double.parseDouble(args[i]);\n      } else if (args[i].equals(\"-w\")) {\n        i++;\n        writeProp = Double.parseDouble(args[i]);\n      } else if (args[i].equals(\"-u\")) {\n        i++;\n        updateProp = Double.parseDouble(args[i]);\n      } else if (args[i].equals(\"-d\")) {\n        i++;\n        distribution = args[i];\n      } else if (args[i].equals(\"-c\")) {\n        i++;\n        operationCount = Integer.parseInt(args[i]);\n      } else if (args[i].equals(\"-o\")) {\n        i++;\n        outputFilePath = args[i];\n      } else if (args[i].equals(\"-k\")) {\n        i++;\n        keyLength = Integer.parseInt(args[i]);\n      } else if (args[i].equals(\"-v\")) {\n        i++;\n        valueLength = Integer.parseInt(args[i]);\n      } else if (args[i].equals(\"-h\")) {\n        i++;\n        usage();\n        System.exit(0);\n      }\n    }\n\n    if (readProp > 1\n        || readProp < 0\n        || writeProp > 1\n        || writeProp < 0\n        || updateProp > 1\n        || updateProp < 0\n        || readProp + writeProp + updateProp != 1.0) {\n      usage();\n      System.exit(0);\n    }\n    if (operationCount <= 0 || keyLength <= 0 || valueLength <= 0) {\n      usage();\n      System.exit(0);\n    }\n    if (!(distribution.equals(\"zipfian\")\n        || distribution.equals(\"uniform\")\n        || distribution.equals(\"latest\"))) {\n      usage();\n      System.exit(0);\n    }\n\n    LoadSummary ls =\n        new LoadSummary(\n            readProp,\n            writeProp,\n            updateProp,\n            keyLength,\n            valueLength,\n            distribution,\n            operationCount,\n            outputFilePath);\n    ls.printSummary();\n    LoadWriter lw = new LoadWriter(ls);\n    lw.writeLoad();\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1655, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["s.charAt(int)"], "configurationStart": [875], "configurationEnd": [890], "guardCondition": "!(NULL_VALUE.equals(s.toLowerCase(),))", "guardType": "IF {", "guardExpressionStart": 112, "guardExpressionEnd": 155, "guardBlockStart": 112, "guardBlockEnd": 401, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 982, "focalAPIEnd": 1007, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Double(val)"], "useStart": [971], "useEnd": [1008], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ludovicc/testng-debian/tree/master/src/main/org/testng/internal/Parameters.java", "rawCode": "  public static Object convertType(Class type, String value, String paramName) {\n    Object result = null;\n\n    if (NULL_VALUE.equals(value.toLowerCase())) {\n      if (type.isPrimitive()) {\n        Utils.log(\n            \"Parameters\",\n            2,\n            \"Attempt to pass null value to primitive type parameter '\" + paramName + \"'\");\n      }\n\n      return null; // null value must be used\n    }\n\n    if (type == String.class) {\n      result = value;\n    } else if (type == int.class || type == Integer.class) {\n      result = new Integer(Integer.parseInt(value));\n    } else if (type == boolean.class || type == Boolean.class) {\n      result = Boolean.valueOf(value);\n    } else if (type == byte.class || type == Byte.class) {\n      result = new Byte(Byte.parseByte(value));\n    } else if (type == char.class || type == Character.class) {\n      result = new Character(value.charAt(0));\n    } else if (type == double.class || type == Double.class) {\n      result = new Double(Double.parseDouble(value));\n    } else if (type == float.class || type == Float.class) {\n      result = new Float(Float.parseFloat(value));\n    } else if (type == long.class || type == Long.class) {\n      result = new Long(Long.parseLong(value));\n    } else if (type == short.class || type == Short.class) {\n      result = new Short(Short.parseShort(value));\n    } else {\n      assert false : \"Unsupported type parameter : \" + type;\n    }\n\n    return result;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1656, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 180, "focalAPIEnd": 220, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aabrahamyan/CodeWars/tree/master/SkybotMobile/src/com/skybot/charts/AgentEventProcessedChart.java", "rawCode": "  public double[] getValue(ArrayList<HashMap<String, String>> data, String key) {\n\n    double[] y = {0, 0, 0, 0, 0, 0, 0};\n    for (int i = 0; i < data.size(); i++) {\n      y[i] = Double.parseDouble(data.get(i).get(key));\n      System.out.println(y[i]);\n    }\n\n    return y;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1657, "initialization": ["String s = String.replace(char,char)", "String s = String.substring(int,int)"], "initializationStart": [257, 322], "initializationEnd": [280, 347], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["parseAndSetCellValueToDateOrString(String,Cell)"], "tryExpressionStart": 403, "tryExpressionEnd": 407, "tryBlockStart": 403, "tryBlockEnd": 873, "catchExpressionStart": 780, "catchExpressionEnd": 813, "catchBlockStart": 780, "catchBlockEnd": 873, "exceptionHandlingCallStart": [821], "exceptionHandlingCallEnd": [866], "configuration": ["s.substring(int,int)", "s.substring(*)"], "configurationStart": [322, 356], "configurationEnd": [347, 382], "guardCondition": "!(s.substring(0,2,).contains(\"00\",)) && s.length()>1", "guardType": "IF {", "guardExpressionStart": 416, "guardExpressionEnd": 438, "guardBlockStart": 416, "guardBlockEnd": 772, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 595, "focalAPIEnd": 619, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Cell.setCellValue(val)", "double.parseDouble(String)", "Cell.setCellValue(val)"], "useStart": [631, 707, 741], "useEnd": [653, 731, 763], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/santiagoaisa/farmacia/tree/master/farmacia/src/org/zkoss/exporter/excel/imp/CellValueSetterImpl.java", "rawCode": "  private void parseAndSetCellValueToDoubleDateOrString(String txt, Cell cell) {\n\n    final char dot = '.';\n    final char comma = ',';\n    String txt0 = txt;\n    if (dot != '.' || comma != ',') {\n      final int dotPos = txt.lastIndexOf(dot);\n      txt0 = txt.replace(comma, ',');\n      if (dotPos >= 0) {\n        txt0 = txt0.substring(0, dotPos) + '.' + txt0.substring(dotPos + 1);\n      }\n    }\n\n    try {\n\n      if (txt0.length() > 1) {\n        if (txt0.substring(0, 2).contains(\"00\")) {\n          parseAndSetCellValueToDateOrString(txt, cell);\n        } else {\n          final Double val = Double.parseDouble(txt0);\n          cell.setCellValue(val);\n        }\n      } else {\n        final Double val = Double.parseDouble(txt0);\n        cell.setCellValue(val);\n      }\n\n    } catch (NumberFormatException ex) {\n      parseAndSetCellValueToDateOrString(txt, cell);\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1658, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 97, "focalAPIEnd": 132, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["println(val)"], "useStart": [66], "useEnd": [133], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Flipkart/loader/tree/master/loader-server/src/main/java/com/flipkart/perf/server/daemon/TimerComputationThread.java", "rawCode": "  public static void main(String[] args) throws IOException {\n    System.out.println(\"\" + (long) Double.parseDouble(\"2.636512277E9\"));\n    /*\n    TimerComputationThread t = new TimerComputationThread(null, 10000);\n    long startTime = Clock.nsTick();\n    t.crunchJobFileTimer(\"\", new File(\"/home/nitinka/git/loader2.0/loader-server/bug/data\"));\n    */\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1659, "initialization": ["String s = StringBuilder.toString()"], "initializationStart": [1546], "initializationEnd": [1563], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1687, "focalAPIEnd": 1708, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setDoubleValue(val)"], "useStart": [1669], "useEnd": [1709], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/verhas/jScriptBasic/tree/master/src/main/java/com/scriptbasic/lexer/elements/Decimal.java", "rawCode": "  /**\n   * Read a decimal number from the input. The next character following the number is left in the\n   * input stream to be available for the next {@code getReader().get()}.\n   *\n   * <p>A decimal number does NOT have {@code +} or {@code -} sign, because that would cause trouble\n   * parsing expressions. It contains digits, optionally decimal point and exponent part following\n   * 'e' or 'E'.\n   *\n   * <p>Some languages allow formats like {@code 1.} or {@code .12}. This parser does not allow such\n   * unreadable format. If there is a decimal point then there has to be a digit on each side.\n   *\n   * <p>The returned lexeme will be double if there is decimal point or exponent part or both, even\n   * if the resulting value could be presented as long. Thus {@code 1.12E2} is a double number and\n   * not a long containing {@code 112}.\n   *\n   * @return the lexical element containing the long or double value\n   */\n  @Override\n  public LexicalElement read() {\n\n    Integer ch = getReader().get();\n    getReader().unget(ch);\n    if (ch != null && Character.isDigit(ch)) {\n      final var le = BasicLexialElementFactory.create(getReader());\n      final var digits = new StringBuilder(DECIMAL_NUMBER_STRINGBUILDER_INITIAL_CAPACITY);\n      processDigits(digits);\n      ch = getReader().get();\n      final boolean floatFormat;\n      if (((Integer) (int) '.').equals(ch)) {\n        floatFormat = processFraction(digits);\n      } else {\n        getReader().unget(ch);\n        floatFormat = processExponent(digits);\n      }\n      final var s = digits.toString();\n      le.setLexeme(s);\n      if (floatFormat) {\n        le.setType(LexicalElement.TYPE_DOUBLE);\n        le.setDoubleValue(Double.parseDouble(s));\n      } else {\n        le.setType(LexicalElement.TYPE_LONG);\n        le.setLongValue(Long.parseLong(s));\n      }\n      return le;\n    } else {\n      return null;\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1660, "initialization": ["String s = WebRequest.getParameter(String)"], "initializationStart": [322], "initializationEnd": [351], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 403, "focalAPIEnd": 429, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kdeforche/jwt/tree/master/src/eu/webtoolkit/jwt/WEnvironment.java", "rawCode": "  void enableAjax(final WebRequest request) {\n    this.doesAjax_ = true;\n    this.session_.getController().newAjaxSession();\n    this.doesCookies_ = request.getHeaderValue(\"Cookie\") != null;\n    if (!(request.getParameter(\"htmlHistory\") != null)) {\n      this.internalPathUsingFragments_ = true;\n    }\n    String scaleE = request.getParameter(\"scale\");\n    try {\n      this.dpiScale_ = scaleE != null ? Double.parseDouble(scaleE) : 1;\n    } catch (final NumberFormatException e) {\n      this.dpiScale_ = 1;\n    }\n    String webGLE = request.getParameter(\"webGL\");\n    this.webGLsupported_ = webGLE != null ? webGLE.equals(\"true\") : false;\n    String tzE = request.getParameter(\"tz\");\n    try {\n      this.timeZoneOffset_ = tzE != null ? Integer.parseInt(tzE) : 0;\n    } catch (final NumberFormatException e) {\n    }\n    String tzSE = request.getParameter(\"tzS\");\n    this.timeZoneName_ = tzSE != null ? tzSE : \"\";\n    String hashE = request.getParameter(\"_\");\n    if (hashE != null) {\n      this.setInternalPath(hashE);\n    }\n    String deployPathE = request.getParameter(\"deployPath\");\n    if (deployPathE != null) {\n      this.publicDeploymentPath_ = deployPathE;\n      int s = this.publicDeploymentPath_.indexOf('/');\n      if (s != 0) {\n        this.publicDeploymentPath_ = \"\";\n      }\n    }\n    String scrWE = request.getParameter(\"scrW\");\n    if (scrWE != null) {\n      try {\n        this.screenWidth_ = Integer.parseInt(scrWE);\n      } catch (final NumberFormatException e) {\n      }\n    }\n    String scrHE = request.getParameter(\"scrH\");\n    if (scrHE != null) {\n      try {\n        this.screenHeight_ = Integer.parseInt(scrHE);\n      } catch (final NumberFormatException e) {\n      }\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1661, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s==null||s.isEmpty())", "guardType": "IF {", "guardExpressionStart": 126, "guardExpressionEnd": 159, "guardBlockStart": 126, "guardBlockEnd": 194, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 211, "focalAPIEnd": 234, "followUpCheck": "val > upperBound || val < lowerBound", "checkType": "IF", "followUpCheckExpressionStart": 240, "followUpCheckExpressionEnd": 277, "followUpCheckBlockStart": 240, "followUpCheckBlockEnd": 312, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SampleSizeShop/Sandbox/tree/master/PowerCalculatorGUI/src/edu/cudenver/bios/powercalculator/client/TextValidation.java", "rawCode": "  public static double parseDouble(String str, double lowerBound, double upperBound)\n      throws NumberFormatException {\n    if (str == null || str.isEmpty()) throw new NumberFormatException();\n\n    double n = Double.parseDouble(str);\n    if (n > upperBound || n < lowerBound) throw new NumberFormatException();\n\n    return n;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1662, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 250, "focalAPIEnd": 274, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["roundTwoDecimals(val)", "double.parseDouble(String)", "roundTwoDecimals(val)"], "useStart": [228, 543, 521], "useEnd": [275, 567, 568], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CrossGaming/CrossGaming-BukkitPlugins/tree/master/CCEBridge/src/com/crossge/ccebridge/Commands/CmdRankPrices.java", "rawCode": "  private String formL(String rank, String cost, String numb, String curRank) {\n    String price = \"\";\n    if (!numb.equalsIgnoreCase(\"10.\")) numb += \" \";\n    numb += \" \";\n    if (curRank.equals(\"CONSOLE\")) {\n      cost = \"$\" + form.roundTwoDecimals(Double.parseDouble(cost));\n      price =\n          ChatColor.GOLD\n              + numb\n              + ccearl.getMessages()\n              + rank\n              + \" can be bought for \"\n              + ccearl.getMoney()\n              + cost;\n    } else {\n      cost = \"$\" + form.roundTwoDecimals(Double.parseDouble(cost));\n      price =\n          ChatColor.GOLD\n              + numb\n              + ccearl.getMessages()\n              + rank\n              + \" can be bought for \"\n              + ccearl.getMoney()\n              + cost;\n      if (pr.hasRank(curRank, rank)) price += ccearl.getMessages() + \" Already Aquired.\";\n    }\n    return price;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1663, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 263, "focalAPIEnd": 292, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/muyun/dev.algorithms/tree/master/src/StdIn.java", "rawCode": "  /** Read all doubles until the end of input is reached, and return them. */\n  public static double[] readAllDoubles() {\n    String[] fields = readAllStrings();\n    double[] vals = new double[fields.length];\n    for (int i = 0; i < fields.length; i++) vals[i] = Double.parseDouble(fields[i]);\n    return vals;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1664, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 176, "focalAPIEnd": 197, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dhale/idh/tree/master/bench/src/fmm/NumberTextField.java", "rawCode": "    private boolean isPartOfNumber(String s) {\n      s = s + \"0\";\n      try {\n        if (_vint) {\n          int i = Integer.parseInt(s);\n        } else {\n          double d = Double.parseDouble(s);\n        }\n        return true;\n      } catch (NumberFormatException e) {\n        return false;\n      }\n    }\n"}, {"dataset": "parseDouble", "exampleID": 1665, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["new CSVProcessException(String)"], "tryExpressionStart": 309, "tryExpressionEnd": 313, "tryBlockStart": 309, "tryBlockEnd": 569, "catchExpressionStart": 455, "catchExpressionEnd": 489, "catchBlockStart": 455, "catchBlockEnd": 569, "exceptionHandlingCallStart": [503], "exceptionHandlingCallEnd": [562], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 398, "focalAPIEnd": 430, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/geosolutions-it/OpenSDI-Manager/tree/master/geobatch/csvingest/src/main/java/it/geosolutions/geobatch/opensdi/csvingest/utils/CSVIngestUtils.java", "rawCode": "  /**\n   * Obtain a double value of a string or null if it's null or empty\n   *\n   * @param doubleString\n   * @return Double value\n   * @throws CSVProcessException if <code>doubleString</code> it's not a double\n   */\n  public static Double getDoubleValue(String doubleString) throws CSVProcessException {\n    try {\n      return doubleString != null && StringUtils.hasText(doubleString)\n          ? Double.parseDouble(doubleString)\n          : null;\n    } catch (NumberFormatException nfe) {\n      throw new CSVProcessException(\"Incorrect double=\" + doubleString);\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1666, "initialization": ["String s = Double.get(int)"], "initializationStart": [1350], "initializationEnd": [1400], "hasTryCatch": 1, "exceptionType": "DataAccessException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 55, "tryExpressionEnd": 59, "tryBlockStart": 55, "tryBlockEnd": 1998, "catchExpressionStart": 1867, "catchExpressionEnd": 1897, "catchBlockStart": 1867, "catchBlockEnd": 1931, "exceptionHandlingCallStart": [1905], "exceptionHandlingCallEnd": [1924], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1652, "focalAPIEnd": 1685, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getSingleDay(*,int,int,val)"], "useStart": [1722], "useEnd": [1770], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/investovator/investovator-core/tree/master/src/main/java/org/investovator/core/commons/utils/testutils/TickerDataGenerator.java", "rawCode": "  private void createDataRows(CSVWriter writer) {\n\n    try {\n\n      CompanyStockTransactionsData historyData = new CompanyStockTransactionsDataImpl();\n\n      Date[] dates =\n          historyData.getDataDaysRange(CompanyStockTransactionsData.DataType.OHLC, stockID);\n      if (startDate == null) startDate = dates[0];\n      if (endDate == null) endDate = dates[1];\n\n      ArrayList<TradingDataAttribute> dataAttribs = new ArrayList<>();\n      dataAttribs.add(TradingDataAttribute.DAY);\n      dataAttribs.add(TradingDataAttribute.CLOSING_PRICE);\n      dataAttribs.add(TradingDataAttribute.TRADES);\n      dataAttribs.add(TradingDataAttribute.SHARES);\n\n      StockTradingData tradingData =\n          historyData.getTradingData(\n              CompanyStockTransactionsData.DataType.OHLC,\n              stockID,\n              startDate,\n              endDate,\n              Integer.MAX_VALUE,\n              dataAttribs);\n\n      HashMap<Date, HashMap<TradingDataAttribute, String>> allTradingData =\n          tradingData.getTradingData();\n\n      for (Date date : allTradingData.keySet()) {\n\n        HashMap<TradingDataAttribute, String> oneDayData = allTradingData.get(date);\n\n        String tradesString = oneDayData.get(TradingDataAttribute.TRADES);\n        String sharesString = oneDayData.get(TradingDataAttribute.SHARES);\n        String closingString = oneDayData.get(TradingDataAttribute.CLOSING_PRICE);\n\n        if (\"\".equals(tradesString) || \"\".equals(sharesString) || \"\".equals(closingString))\n          continue;\n\n        int trades = Integer.parseInt(tradesString);\n        int shares = Integer.parseInt(sharesString);\n        double closingPrice = Double.parseDouble(closingString);\n\n        ArrayList<String[]> day = getSingleDay(date, trades, shares, closingPrice);\n        for (String[] line : day) {\n          writer.writeNext(line);\n        }\n      }\n\n    } catch (DataAccessException e) {\n      e.printStackTrace();\n    } catch (DataNotFoundException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1667, "initialization": ["String s = get(int,int)"], "initializationStart": [115], "initializationEnd": [131], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["new InvalidElement(String)"], "tryExpressionStart": 92, "tryExpressionEnd": 96, "tryBlockStart": 92, "tryBlockEnd": 375, "catchExpressionStart": 204, "catchExpressionEnd": 236, "catchBlockStart": 204, "catchBlockEnd": 375, "exceptionHandlingCallStart": [250], "exceptionHandlingCallEnd": [368], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 175, "focalAPIEnd": 196, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/noe/sgf.importer/tree/master/src/sgfimporter/util/Table.java", "rawCode": "  public double getDouble(int column, int row) throws InvalidLocation, InvalidElement {\n    try {\n      String s = get(column, row);\n      if (s == null) s = \"\";\n      return Double.parseDouble(s);\n    } catch (NumberFormatException e) {\n      throw new InvalidElement(\n          \"Expected floating point number in \" + \"table (column=\" + column + \", row=\" + row + \")\");\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1668, "initialization": ["String s = String.trim()"], "initializationStart": [318], "initializationEnd": [330], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["new ConfigurationException(String)"], "tryExpressionStart": 469, "tryExpressionEnd": 473, "tryBlockStart": 469, "tryBlockEnd": 701, "catchExpressionStart": 538, "catchExpressionEnd": 571, "catchBlockStart": 538, "catchBlockEnd": 701, "exceptionHandlingCallStart": [589], "exceptionHandlingCallEnd": [690], "configuration": ["double.valueOf(double)", "double.valueOf(double)"], "configurationStart": [271, 416], "configurationEnd": [299, 444], "guardCondition": "!(s.length()<1)", "guardType": "IF {", "guardExpressionStart": 314, "guardExpressionEnd": 344, "guardBlockStart": 314, "guardBlockEnd": 709, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 494, "focalAPIEnd": 526, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["HashMap<String, Number>.put(String,val)", "val.doubleValue()"], "useStart": [716, 769], "useEnd": [749, 789], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stuartwdouglas/jacorb/tree/master/src/org/jacorb/config/JacORBConfiguration.java", "rawCode": "  public double getAttributeAsFloat(String key, double defaultValue) throws ConfigurationException {\n    Number result = numberAttributes.get(key);\n\n    if (result == null) {\n      String value = stringAttributes.remove(key);\n\n      if (value == null) {\n        result = Double.valueOf(defaultValue);\n      } else if (value.trim().length() < 1) {\n        // treat empty values as non-defined (null)\n        result = Double.valueOf(defaultValue);\n      } else {\n        try {\n          result = Double.parseDouble(value.trim());\n        } catch (NumberFormatException ex) {\n          throw new ConfigurationException(\n              \"value for attribute \" + key + \" is not numeric: \" + value);\n        }\n      }\n      numberAttributes.put(key, result);\n    }\n\n    return result.doubleValue();\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1669, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 163, "focalAPIEnd": 188, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setValue(val)"], "useStart": [148], "useEnd": [189], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aborg0/rapidminer-vega/tree/master/src/com/rapidminer/gui/plotter/settings/ListeningJSlider.java", "rawCode": "  @Override\n  public void settingChanged(String generalKey, String specificKey, String value) {\n    if (generalKey.equals(this.generalKey)) {\n      setValue((int) Double.parseDouble(value));\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1670, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 197, "focalAPIEnd": 221, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(String)", "new Coordinate(val,*)", "double.parseDouble(String)", "double.parseDouble(String)"], "useStart": [223, 182, 295, 321], "useEnd": [247, 248, 319, 345], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openplans/cebu-taxi/tree/master/cebu-server/app/controllers/Api.java", "rawCode": "  public static void path(String lat1, String lon1, String lat2, String lon2)\n      throws JsonGenerationException, JsonMappingException, IOException {\n    final Coordinate coord1 = new Coordinate(Double.parseDouble(lon1), Double.parseDouble(lat1));\n    final Coordinate coord2 = new Coordinate(Double.parseDouble(lon2), Double.parseDouble(lat2));\n\n    Path path = new Path();\n\n    List<Integer> edgeIds = Api.graph.getEdgesBetweenPoints(coord1, coord2);\n\n    Double total = 0.0;\n\n    for (Integer edgeId : edgeIds) {\n      TrafficEdge edge = Api.graph.getTrafficEdge(edgeId);\n      Geometry geom = edge.getGeometry();\n\n      path.distance += edge.geLength();\n\n      org.opentripplanner.util.model.EncodedPolylineBean polylineBean =\n          PolylineEncoder.createEncodings(geom);\n      total +=\n          Api.edgeVelocities.getStreetVelocity(BigInteger.valueOf(edgeId.longValue()))\n              * edge.geLength();\n\n      path.edgeGeoms.add(polylineBean.getPoints());\n    }\n\n    path.minSpeed = total / path.distance;\n    path.maxSpeed = total / path.distance;\n\n    renderJSON(path);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1671, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 262, "focalAPIEnd": 289, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "new PreDefinedNetwork(val,*,*)"], "useStart": [303, 227], "useEnd": [330, 391], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ykk/JSC/tree/master/simulation/networks/PreDefinedNetwork.java", "rawCode": "  /**\n   * Function to test network by drawing it.\n   *\n   * @param args 1st argument is density of network; 2nd argument is network size\n   */\n  public static void main(String[] args) {\n    PreDefinedNetwork testNet =\n        new PreDefinedNetwork(\n            Double.parseDouble(args[1]),\n            Double.parseDouble(args[0]),\n            new Node(new Coordinate(0, 0), new ZeroOne(1)));\n    testNet.generateNetwork();\n    testNet.draw(\"testNetworkImage.jpg\", ImageFile.JPEG_TYPE, 100, 20);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1672, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 207, "focalAPIEnd": 232, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/maandree/util-say/tree/master/src/se/kth/maandree/utilsay/Common.java", "rawCode": "  /**\n   * Parse double value\n   *\n   * @param value String representation\n   * @return Raw representation, -1 if not a number\n   */\n  public static double parseDouble(String value) {\n    try {\n      return Double.parseDouble(value);\n    } catch (Throwable err) {\n      return -1.0;\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1673, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["new GraphFormatException(String)"], "tryExpressionStart": 292, "tryExpressionEnd": 296, "tryBlockStart": 292, "tryBlockEnd": 837, "catchExpressionStart": 708, "catchExpressionEnd": 742, "catchBlockStart": 708, "catchBlockEnd": 837, "exceptionHandlingCallStart": [756], "exceptionHandlingCallEnd": [830], "configuration": ["s.indexOf(String)"], "configurationStart": [317], "configurationEnd": [336], "guardCondition": "!(s.length()==0)", "guardType": "IF {", "guardExpressionStart": 344, "guardExpressionEnd": 369, "guardBlockStart": 344, "guardBlockEnd": 701, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 481, "focalAPIEnd": 507, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "double.parseDouble(*)"], "useStart": [573, 644], "useEnd": [620, 692], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.4.0/src/om/graph/AxisItemBase.java", "rawCode": "  /**\n   * Sets the tick spacing.\n   *\n   * @param sTicks Tick specification: \"1.0\" = major ticks every 1, \"1.0,0.5\" = major ticks and\n   *     minor ticks. \"\" or \"0.0\" = no ticks\n   * @throws GraphFormatException\n   */\n  public void setTicks(String sTicks) throws GraphFormatException {\n    try {\n      int iComma = sTicks.indexOf(\",\");\n      if (sTicks.length() == 0) {\n        dMajorTicks = 0.0;\n        dMinorTicks = 0.0;\n      } else if (iComma == -1) {\n        dMajorTicks = Double.parseDouble(sTicks);\n        dMinorTicks = 0.0;\n      } else {\n        dMajorTicks = Double.parseDouble(sTicks.substring(0, iComma));\n        dMinorTicks = Double.parseDouble(sTicks.substring(iComma + 1));\n      }\n    } catch (NumberFormatException nfe) {\n      throw new GraphFormatException(\"<*axis>: Invalid tick specification: \" + sTicks);\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1674, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 184, "focalAPIEnd": 218, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "double.parseDouble(*)", "double.parseDouble(*)", "new CoordinateBounds(val,*,*,*)"], "useStart": [220, 270, 306, 148], "useEnd": [254, 304, 340, 341], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/camsys/onebusaway-nyc/tree/master/onebusaway-nyc-webapp/src/main/java/org/onebusaway/nyc/webapp/actions/api/StopsWithinBoundsAction.java", "rawCode": "  public void setBounds(String bounds) {\n    String[] coordinates = bounds.split(\",\");\n    if (coordinates.length == 4) {\n      _bounds =\n          new CoordinateBounds(\n              Double.parseDouble(coordinates[0]), Double.parseDouble(coordinates[1]),\n              Double.parseDouble(coordinates[2]), Double.parseDouble(coordinates[3]));\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1675, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 823, "focalAPIEnd": 859, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/societies/SOCIETIES-Platform/tree/master/context-management/UserContextRefinement/src/main/java/org/societies/context/user/refinement/impl/tools/NetworkConverter.java", "rawCode": "  /**\n   * <br>\n   * Changes from {@link String} of numbers, separated by a pattern, to an array of {@link double}\n   * <br>\n   * <br>\n   * original object: \"1 0 0.7 0.3 ...\"<br>\n   * example pattern: \" \"<br>\n   * final object: {1, 0, 0.7, 0.3 ...}<br>\n   *\n   * @param nodeStringProb {@link String} of numbers separated by a pattern\n   * @return numbers in an array of {@link double}\n   */\n  private static double[] stringNumberToDouble(String nodeStringProb, String pattern) {\n    double[] result = null;\n\n    Pattern stringPattern = Pattern.compile(pattern); // I define the\n    // pattern to\n    // recognize between\n    // to numbers\n    String[] nodeProbArray = stringPattern.split(nodeStringProb);\n    result = new double[nodeProbArray.length];\n    for (int k = 0; k < nodeProbArray.length; k++) {\n      result[k] = Double.parseDouble(nodeProbArray[k]);\n    }\n\n    return result;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1676, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 58, "focalAPIEnd": 81, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["withdraw(val)"], "useStart": [87], "useEnd": [103], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Johnmalc/Homeworks2/tree/master/Aufgabe13/src/notOurs/CashMachine.java", "rawCode": "  public void withdraw(String bob) {\n\n    double nummer = Double.parseDouble(bob);\n    withdraw(nummer);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1677, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["new GraphFormatException(String)"], "tryExpressionStart": 469, "tryExpressionEnd": 473, "tryBlockStart": 469, "tryBlockEnd": 1010, "catchExpressionStart": 877, "catchExpressionEnd": 911, "catchBlockStart": 877, "catchBlockEnd": 1010, "exceptionHandlingCallStart": [925], "exceptionHandlingCallEnd": [1003], "configuration": ["s.indexOf(String)"], "configurationStart": [494], "configurationEnd": [515], "guardCondition": "!(s.length()==0)", "guardType": "IF {", "guardExpressionStart": 523, "guardExpressionEnd": 550, "guardBlockStart": 523, "guardBlockEnd": 870, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 653, "focalAPIEnd": 681, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)"], "useStart": [741], "useEnd": [790], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/branches/DEV_v1_8/src/om/graph/GridItem.java", "rawCode": "  /**\n   * Converts spacing from a string in format \"\" (=0.0,0.0) \"0.3\" (=0.3,0.0) or \"0.3,0.1\"\n   * (=0.3,0.1).\n   *\n   * @param sSpacing String defining major/minor spacing\n   * @return Object containing information as doubles. If a value was unspecified it is set to 0.0\n   * @throws GraphFormatException If string format is invalid\n   */\n  private MajorMinor convertMajorMinor(String sSpacing) throws GraphFormatException {\n    MajorMinor s = new MajorMinor();\n    try {\n      int iComma = sSpacing.indexOf(\",\");\n      if (sSpacing.length() == 0) {\n        s.dMajor = 0.0;\n        s.dMinor = 0.0;\n      } else if (iComma == -1) {\n        s.dMajor = Double.parseDouble(sSpacing);\n        s.dMinor = 0.0;\n      } else {\n        s.dMajor = Double.parseDouble(sSpacing.substring(0, iComma));\n        s.dMinor = Double.parseDouble(sSpacing.substring(iComma + 1));\n      }\n    } catch (NumberFormatException nfe) {\n      throw new GraphFormatException(\"<grid>: Invalid spacing specification: \" + sSpacing);\n    }\n    return s;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1678, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["printStackTrace()", "println(String)"], "tryExpressionStart": 929, "tryExpressionEnd": 933, "tryBlockStart": 929, "tryBlockEnd": 1415, "catchExpressionStart": 1295, "catchExpressionEnd": 1329, "catchBlockStart": 1295, "catchBlockEnd": 1415, "exceptionHandlingCallStart": [1343, 1378], "exceptionHandlingCallEnd": [1364, 1402], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 960, "focalAPIEnd": 981, "followUpCheck": "val != nullValue", "checkType": "IF", "followUpCheckExpressionStart": 995, "followUpCheckExpressionEnd": 1016, "followUpCheckBlockStart": 995, "followUpCheckBlockEnd": 1282, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/deriggi/wilderness-sar/tree/master/src/main/java/raster/AsciiParser2.java", "rawCode": "  @Deprecated\n  private void handleLine(String line, double xmin, double ymin, int lineNumber) {\n    String[] lineParts = line.split(\"\\\\s+\");\n    if (lineParts[0].trim().length() > 0) {\n      log.log(\n          Level.FINE,\n          \"{0} first:{1} last: {2}\",\n          new Object[] {lineParts.length, lineParts[0], lineParts[lineParts.length - 1]});\n    }\n\n    int colNumber = 0;\n    log.log(Level.FINE, \"col width: {0}\", lineParts.length);\n    final String INF = \"Inf\";\n    for (String s : lineParts) {\n\n      // make column count and line count global\n      // increment line number only after column count reached\n\n      if (s.trim().length() > 0) {\n        double rowOffset = (numRows - (lineNumber - STANDARD_HEADER_SIZE)) * cellSize;\n        double y = ymin + rowOffset - cellSize;\n\n        double colOffset = (colNumber) * cellSize;\n        double x = xmin + colOffset;\n\n        if (!s.equalsIgnoreCase(INF)) {\n          try {\n            double val = Double.parseDouble(s);\n            if (val != nullValue) {\n              // this.action.handleNonNullData(y, x, val);\n              log.log(\n                  Level.FINE,\n                  \"row: {0} col: {1} x: {2} y:{3}\",\n                  new Object[] {lineNumber - STANDARD_HEADER_SIZE, colNumber, x, y});\n            }\n          } catch (NumberFormatException nfe) {\n            nfe.printStackTrace();\n            System.out.println(line);\n          }\n        }\n        colNumber++;\n      }\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1679, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IndexOutOfBoundsException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 68, "tryExpressionEnd": 72, "tryBlockStart": 68, "tryBlockEnd": 992, "catchExpressionStart": 647, "catchExpressionEnd": 683, "catchBlockStart": 647, "catchBlockEnd": 717, "exceptionHandlingCallStart": [691], "exceptionHandlingCallEnd": [710], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 405, "focalAPIEnd": 431, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["doCellValue(XSheetCellCursor,int,int,val)"], "useStart": [361], "useEnd": [432], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bomm/thera-pi/tree/master/Reha/src/urlaubBeteiligung/Beteiligung.java", "rawCode": "  private void doKeineZuordnung(String name, boolean history) {\n    try {\n      OOTools.doCellColor(cellCursor, 0, calcrow, 0xff0000);\n      OOTools.doCellValue(cellCursor, 0, calcrow, name.replace(copyright, \"\"));\n      if (name.contains(\"erfaßt\")) {\n        OOTools.doCellFontBold(cellCursor, 0, calcrow);\n      }\n      for (int i = 8; i < 13; i++) {\n        OOTools.doCellValue(cellCursor, i, calcrow, Double.parseDouble(\"0.00\"));\n      }\n      OOTools.doCellFormula(\n          cellCursor,\n          14,\n          calcrow,\n          \"=sum(I\" + Integer.toString(calcrow + 1) + \":N\" + Integer.toString(calcrow + 1) + \")\");\n      calcrow++;\n    } catch (IndexOutOfBoundsException e) {\n      e.printStackTrace();\n    } catch (UnknownPropertyException e) {\n      e.printStackTrace();\n    } catch (PropertyVetoException e) {\n      e.printStackTrace();\n    } catch (IllegalArgumentException e) {\n      e.printStackTrace();\n    } catch (WrappedTargetException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1680, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 74, "focalAPIEnd": 97, "followUpCheck": "val != expected", "checkType": "IF", "followUpCheckExpressionStart": 103, "followUpCheckExpressionEnd": 121, "followUpCheckBlockStart": 103, "followUpCheckBlockEnd": 216, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/java/lang/Double/ParseDouble.java", "rawCode": "  private static void check(String val, double expected) {\n    double n = Double.parseDouble(val);\n    if (n != expected)\n      throw new RuntimeException(\"Double.parseDouble failed. String:\" + val + \" Result:\" + n);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1681, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": [], "tryExpressionStart": 594, "tryExpressionEnd": 598, "tryBlockStart": 594, "tryBlockEnd": 830, "catchExpressionStart": 762, "catchExpressionEnd": 800, "catchBlockStart": 762, "catchBlockEnd": 830, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 639, "focalAPIEnd": 667, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "double.parseDouble(*)", "new Vector(val,*,*)"], "useStart": [681, 723, 615], "useEnd": [709, 751, 752], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Ribesg/NPlugins/tree/master/NCuboid/src/main/java/fr/ribesg/bukkit/ncuboid/commands/subexecutors/AttributeSubcmdExecutor.java", "rawCode": "  private Vector parseVector(final CommandSender sender, final String input) {\n    if (\"set\".equalsIgnoreCase(input)) {\n      if (sender instanceof Player) {\n        return ((Player) sender).getLocation().getDirection();\n      } else {\n        return null;\n      }\n    } else {\n      final String splitChar;\n      if (input.contains(\";\")) {\n        splitChar = \";\";\n      } else if (input.contains(\",\")) {\n        splitChar = \",\";\n      } else {\n        return null;\n      }\n      final String[] parts = input.split(splitChar);\n      if (parts.length != 3) {\n        return null;\n      }\n      try {\n        return new Vector(\n            Double.parseDouble(parts[0]),\n            Double.parseDouble(parts[1]),\n            Double.parseDouble(parts[2]));\n      } catch (final NumberFormatException e) {\n        return null;\n      }\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1682, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 214, "tryExpressionEnd": 218, "tryBlockStart": 214, "tryBlockEnd": 354, "catchExpressionStart": 280, "catchExpressionEnd": 312, "catchBlockStart": 280, "catchBlockEnd": 354, "exceptionHandlingCallStart": [324], "exceptionHandlingCallEnd": [343], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 239, "focalAPIEnd": 268, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/etamponi/game/tree/master/gamelib/src/game/plugins/datasetbuilders/CSVDatasetBuilder.java", "rawCode": "  private Object getData(String[] tokens, DataTemplate template) {\n    if (template instanceof VectorTemplate) {\n      double[] ret = new double[tokens.length];\n      for (int i = 0; i < ret.length; i++) {\n        try {\n          ret[i] = Double.parseDouble(tokens[i]);\n        } catch (NumberFormatException e) {\n          e.printStackTrace();\n        }\n      }\n      return new ArrayRealVector(ret);\n    }\n    if (template instanceof LabelTemplate) {\n      if (((LabelTemplate) template).labels.contains(tokens[0])) return tokens[0];\n      else return null;\n    }\n    return null;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1683, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["getMessage(String)", "logger()", "severe(String)"], "tryExpressionStart": 192, "tryExpressionEnd": 196, "tryBlockStart": 192, "tryBlockEnd": 729, "catchExpressionStart": 568, "catchExpressionEnd": 600, "catchBlockStart": 568, "catchBlockEnd": 729, "exceptionHandlingCallStart": [625, 675, 675], "exceptionHandlingCallEnd": [667, 691, 707], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 238, "focalAPIEnd": 262, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nasa/World-Wind-Java/tree/master/WorldWind/src/gov/nasa/worldwind/wms/BoundingBox.java", "rawCode": "  public static BoundingBox createFromStrings(\n      String crs, String minx, String maxx, String miny, String maxy, String resx, String resy) {\n    BoundingBox bbox = new BoundingBox();\n\n    try {\n      bbox.crs = crs;\n      bbox.minx = Double.parseDouble(minx);\n      bbox.maxx = Double.parseDouble(maxx);\n      bbox.miny = Double.parseDouble(miny);\n      bbox.maxy = Double.parseDouble(maxy);\n      bbox.resx = resx != null && !resx.equals(\"\") ? Double.parseDouble(resx) : 0;\n      bbox.resy = resy != null && !resy.equals(\"\") ? Double.parseDouble(resy) : 0;\n    } catch (NumberFormatException e) {\n      String message = Logging.getMessage(\"XML.ImproperDataType\");\n      Logging.logger().severe(message);\n      throw e;\n    }\n\n    return bbox;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1684, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 620, "focalAPIEnd": 646, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "double.parseDouble(*)", "double.parseDouble(*)", "double.parseDouble(*)"], "useStart": [807, 854, 1115, 1179], "useEnd": [834, 881, 1142, 1206], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/egonw/cdk-taverna-2/tree/master/cdk-taverna-2-activity-ui/src/main/java/org/openscience/cdk/applications/taverna/ui/weka/panels/regression/SupportVectorMachinesFrame.java", "rawCode": "  @Override\n  public void setOptions(String[] options) {\n    Integer lowC = null;\n    Integer highC = null;\n    Integer stepSizeC = null;\n    Double lowG = null;\n    Double highG = null;\n    Double stepSizeG = null;\n    Integer svmType = null;\n    Integer kernelType = null;\n    Integer degree = null;\n    Double coef = null;\n    boolean firstDif = false;\n    for (int i = 0; i < options.length; i++) {\n      String[] opt = options[i].split(\" \");\n      if (i == 0) {\n        svmType = Integer.parseInt(opt[1]) - 3;\n        kernelType = Integer.parseInt(opt[3]);\n        degree = Integer.parseInt(opt[5]);\n        coef = Double.parseDouble(opt[7]);\n        lowC = Integer.parseInt(opt[11]);\n        highC = Integer.parseInt(opt[11]);\n        if (opt.length > 12 && !opt[13].equals(\"1/k\")) {\n          lowG = Double.parseDouble(opt[13]);\n          highG = Double.parseDouble(opt[13]);\n        }\n      } else {\n        lowC = Math.min(lowC, Integer.parseInt(opt[11]));\n        highC = Math.max(highC, Integer.parseInt(opt[11]));\n        if (opt.length > 12 && !opt[13].equals(\"1/k\")) {\n          lowG = Math.min(lowG, Double.parseDouble(opt[13]));\n          highG = Math.max(highG, Double.parseDouble(opt[13]));\n        }\n      }\n      if (i == 1) {\n        stepSizeC = highC - lowC;\n      }\n      if (!firstDif && opt.length > 12 && !opt[13].equals(\"1/k\")) {\n        if (!highG.equals(lowG)) {\n          stepSizeG = highG - lowG;\n          firstDif = true;\n        }\n      }\n    }\n    this.svmTypeComboBox.setSelectedIndex(svmType);\n    this.kernelComboBox.setSelectedIndex(kernelType);\n    this.degreeLowTextField.setText(\"\" + degree);\n    this.coefTextField.setText(\"\" + coef);\n    this.startTextField.setText(\"\" + lowC);\n    if (highC != null && stepSizeC != null) {\n      this.endTextField.setText(\"\" + highC);\n      this.stepSizeTextField.setText(\"\" + stepSizeC);\n    } else {\n      this.endTextField.setText(\"\");\n      this.stepSizeTextField.setText(\"\");\n    }\n    if (lowG == null) {\n      this.gammaLowTextField.setText(\"1/k\");\n    } else {\n      this.gammaLowTextField.setText(\"\" + lowG);\n    }\n    if (highG != null && stepSizeG != null) {\n      this.gammaHighTextField.setText(\"\" + highG);\n      this.gammaStepsizeTextField.setText(\"\" + stepSizeG);\n    } else {\n      this.gammaHighTextField.setText(\"\");\n      this.gammaStepsizeTextField.setText(\"\");\n    }\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1685, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 326, "focalAPIEnd": 360, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)"], "useStart": [487], "useEnd": [540], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/graphstream/gs-core/tree/master/src/org/graphstream/ui/graphicGraph/GraphicNode.java", "rawCode": "  /**\n   * Try to convert the object to a double.\n   *\n   * @param value The object to convert.\n   * @return The value.\n   */\n  protected double numberAttribute(Object value) {\n    if (value instanceof Number) {\n      return ((Number) value).doubleValue();\n    } else if (value instanceof String) {\n      try {\n        return Double.parseDouble((String) value);\n      } catch (NumberFormatException e) {\n      }\n    } else if (value instanceof CharSequence) {\n      try {\n        return Double.parseDouble(((CharSequence) value).toString());\n      } catch (NumberFormatException e) {\n      }\n    }\n\n    return 0;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1686, "initialization": ["String s = getPolygonArea(String,String,List,int)"], "initializationStart": [513], "initializationEnd": [587], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(double.parseDouble(s,)<=0)", "guardType": "IF {", "guardExpressionStart": 665, "guardExpressionEnd": 712, "guardBlockStart": 665, "guardBlockEnd": 742, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 669, "focalAPIEnd": 706, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(String)"], "useStart": [811], "useEnd": [857], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/teropa/stem/tree/master/org.eclipse.stem.utility/src/org/eclipse/stem/utility/generators/AreaGenerator.java", "rawCode": "  /**\n   * Find the approximate area value for a known location.\n   *\n   * @param level1Container\n   * @param level0Container\n   * @param aggreateLevel1PolygonArea\n   * @param level1AreaSqKm\n   * @return the approximate area value\n   */\n  protected String getApproximateL1Area(\n      String level1Container,\n      String level0Container,\n      String aggregateLevel1PolygonArea,\n      String level0AreaSqKm) {\n\n    // Find the area in polygon units of the level 1 container\n    String level1PolygonArea =\n        getPolygonArea(level1Container, level0Container, level1PolygonAreaList, 1);\n\n    // Compute the approximate area, but check division by zero first.\n    if (Double.parseDouble(level1PolygonArea) <= 0) {\n      return DEFAULT;\n    }\n\n    double ratio =\n        Double.parseDouble(level1PolygonArea) / Double.parseDouble(aggregateLevel1PolygonArea);\n\n    String area = String.valueOf(ratio * Double.parseDouble(level0AreaSqKm));\n\n    return area;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1687, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 133, "focalAPIEnd": 158, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RomRaider/original.flat/tree/master/tags/0.4.0/src/enginuity/maps/DataCell.java", "rawCode": "  public void setCompareRealValue(String input) {\n    double result =\n        JEPUtil.evaluate(table.getScale().getByteExpression(), Double.parseDouble(input));\n    this.setCompareValue((int) Math.round(result));\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1688, "initialization": ["String s = Matcher.group(int)"], "initializationStart": [252], "initializationEnd": [262], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 287, "focalAPIEnd": 320, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)", "double.parseDouble(*)"], "useStart": [808, 919], "useEnd": [838, 949], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/duckweed/fitnesse-verify/tree/master/src/fit/FitMatcher.java", "rawCode": "  public boolean matches() throws Exception {\n    Pattern p = Pattern.compile(\"\\\\s*_?\\\\s*(<|>|<=|>=)\\\\s*([-+]?[\\\\d]*\\\\.?[\\\\d]+)\");\n    Matcher m = p.matcher(expression);\n    if (m.matches()) {\n      String op = m.group(1);\n      String operandString = m.group(2);\n      double operand = Double.parseDouble(operandString);\n      double n = ((Number) parameter).doubleValue();\n      if (op.equals(\"<\")) return (n < operand);\n      if (op.equals(\">\")) return (n > operand);\n      if (op.equals(\"<=\")) return (n <= operand);\n      if (op.equals(\">=\")) return (n >= operand);\n      return false;\n    }\n\n    p =\n        Pattern.compile(\n            \"\\\\s*([-+]?[\\\\d]*\\\\.?[\\\\d]+)\\\\s*(<|>|<=|>=)\\\\s*_\\\\s*(<|>|<=|>=)\\\\s*([-+]?[\\\\d]*\\\\.?[\\\\d]+)\");\n    m = p.matcher(expression);\n    if (m.matches()) {\n      double a = Double.parseDouble(m.group(1));\n      String aop = m.group(2);\n      String bop = m.group(3);\n      double b = Double.parseDouble(m.group(4));\n      double n = ((Number) parameter).doubleValue();\n\n      boolean an = false;\n      if (aop.equals(\"<\")) an = a < n;\n      if (aop.equals(\"<=\")) an = a <= n;\n      if (aop.equals(\">\")) an = a > n;\n      if (aop.equals(\">=\")) an = a >= n;\n\n      boolean nb = false;\n      if (bop.equals(\"<\")) nb = n < b;\n      if (bop.equals(\"<=\")) nb = n <= b;\n      if (bop.equals(\">\")) nb = n > b;\n      if (bop.equals(\">=\")) nb = n >= b;\n\n      return an && nb;\n    }\n    throw new FitMatcherException(\"Invalid FitMatcher Expression\");\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1689, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 529, "focalAPIEnd": 552, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["round(val)"], "useStart": [631], "useEnd": [651], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TaintDroid/android_platform_libcore/tree/master/luni/src/test/java/libcore/sqlite/OldDatabaseTest.java", "rawCode": "  public void testCreate_function() throws Exception {\n    double input = 1.0;\n    db.exec(\"create table TEST (res double)\", null);\n    db.exec(\"insert into TEST values (\" + Double.toString(input) + \")\", null);\n    TableResult res = new TableResult();\n    Function sinFunc = (Function) new SinFunc();\n    db.create_function(\"sin\", 1, sinFunc);\n    db.exec(\"select sin(res) from TEST WHERE res = \" + Double.toString(input), res);\n    String row[] = (String[]) res.rows.elementAt(0);\n    String val = row[0];\n    double sinusVal = Double.parseDouble(val);\n    double funcVal = Math.sin(input);\n\n    assertTrue(Math.round(funcVal) == Math.round(sinusVal));\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1690, "initialization": ["String s = getText()"], "initializationStart": [1058], "initializationEnd": [1079], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1301, "focalAPIEnd": 1342, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jevinskie/contiki/tree/master/tools/cooja/java/se/sics/cooja/radiomediums/DirectedGraphMedium.java", "rawCode": "  public void simulationFinishedLoading() {\n    if (delayedConfiguration == null) {\n      return;\n    }\n\n    boolean oldConfig = false;\n    for (Element element : delayedConfiguration) {\n      if (element.getName().equals(\"edge\")) {\n        Collection<Element> edgeConfig = element.getChildren();\n        Radio source = null;\n        DestinationRadio dest = null;\n        for (Element edgeElement : edgeConfig) {\n          if (edgeElement.getName().equals(\"src\")) {\n            oldConfig = true;\n\n            /* Old config: lookup source mote */\n            for (Mote m : simulation.getMotes()) {\n              if (m.toString().equals(edgeElement.getText())) {\n                logger.info(\n                    \"Old config: mapping '\" + edgeElement.getText() + \"' to node \" + m.getID());\n                source = m.getInterfaces().getRadio();\n                break;\n              }\n            }\n          } else if (edgeElement.getName().equals(\"source\")) {\n            source =\n                simulation\n                    .getMoteWithID(Integer.parseInt(edgeElement.getText()))\n                    .getInterfaces()\n                    .getRadio();\n          } else if (oldConfig && edgeElement.getName().equals(\"ratio\")) {\n            /* Old config: parse link ratio */\n            double ratio = Double.parseDouble(edgeElement.getText());\n            ((DGRMDestinationRadio) dest).ratio = ratio;\n          } else if (edgeElement.getName().equals(\"dest\")) {\n            if (oldConfig) {\n              /* Old config: create simple destination link */\n              Radio destRadio = null;\n              for (Mote m : simulation.getMotes()) {\n                if (m.toString().equals(edgeElement.getText())) {\n                  logger.info(\n                      \"Old config: mapping '\" + edgeElement.getText() + \"' to node \" + m.getID());\n                  destRadio = m.getInterfaces().getRadio();\n                  break;\n                }\n              }\n              dest = new DGRMDestinationRadio(destRadio);\n            } else {\n              String destClassName = edgeElement.getText().trim();\n              if (destClassName == null || destClassName.isEmpty()) {\n                continue;\n              }\n              Class<? extends DestinationRadio> destClass =\n                  simulation.getGUI().tryLoadClass(this, DestinationRadio.class, destClassName);\n              if (destClass == null) {\n                throw new RuntimeException(\"Could not load class: \" + destClassName);\n              }\n              try {\n                dest = destClass.newInstance();\n                dest.setConfigXML(edgeElement.getChildren(), simulation);\n              } catch (Exception e) {\n                throw (RuntimeException)\n                    new RuntimeException(\"Unknown class: \" + destClassName).initCause(e);\n              }\n            }\n          }\n        }\n        if (source == null || dest == null) {\n          logger.fatal(\"Failed loading DGRM links, aborting\");\n          return;\n        } else {\n          addEdge(new Edge(source, dest));\n        }\n      }\n    }\n    requestEdgeAnalysis();\n    delayedConfiguration = null;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1691, "initialization": ["String s = Matcher.group(int)"], "initializationStart": [869], "initializationEnd": [879], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s!=null", "guardType": "IF {", "guardExpressionStart": 891, "guardExpressionEnd": 918, "guardBlockStart": 891, "guardBlockEnd": 1010, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 962, "focalAPIEnd": 996, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mozilla-b2g/android-sdk/tree/master/ddms/libs/ddmuilib/src/com/android/ddmuilib/location/GpxParser.java", "rawCode": "    /**\n     * Converts the string description of the time into milliseconds since epoch.\n     *\n     * @param timeString the string data.\n     * @return date in milliseconds.\n     */\n    private long computeTime(String timeString) {\n      // Time looks like: 2008-04-05T19:24:50Z\n      Matcher m = ISO8601_TIME.matcher(timeString);\n      if (m.matches()) {\n        // get the various elements and reconstruct time as a long.\n        try {\n          int year = Integer.parseInt(m.group(1));\n          int month = Integer.parseInt(m.group(2));\n          int date = Integer.parseInt(m.group(3));\n          int hourOfDay = Integer.parseInt(m.group(4));\n          int minute = Integer.parseInt(m.group(5));\n          int second = Integer.parseInt(m.group(6));\n\n          // handle the optional parameters.\n          int milliseconds = 0;\n\n          String subSecondGroup = m.group(7);\n          if (subSecondGroup != null) {\n            milliseconds = (int) (1000 * Double.parseDouble(subSecondGroup));\n          }\n\n          boolean utcTime = m.group(8) != null;\n\n          // now we convert into milliseconds since epoch.\n          Calendar c;\n          if (utcTime) {\n            c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\")); // $NON-NLS-1$\n          } else {\n            c = Calendar.getInstance();\n          }\n\n          c.set(year, month, date, hourOfDay, minute, second);\n\n          return c.getTimeInMillis() + milliseconds;\n        } catch (NumberFormatException e) {\n          // format is invalid, we'll return -1 below.\n        }\n      }\n\n      // invalid time!\n      return -1;\n    }\n"}, {"dataset": "parseDouble", "exampleID": 1692, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 447, "focalAPIEnd": 476, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/uw-loci/visbio/tree/master/src/main/java/loci/visbio/ext/MatlabFunction.java", "rawCode": "  /**\n   * Predicts the width, height and number of output planes, given the width, height and number of\n   * input planes, and parameter values.\n   *\n   * @return An int[3] array representing output width, height and num values.\n   */\n  @Override\n  public int[] predict(final int width, final int height, final int num, final String[] params) {\n    final double[] p = new double[params.length];\n    for (int i = 0; i < params.length; i++) p[i] = Double.parseDouble(params[i]);\n    final int[] mdims = MatlabUtil.getDimensions(function, height, width, num, p);\n    return new int[] {mdims[1], mdims[0], mdims[2]};\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1693, "initialization": ["String s = WidgetChildProcessorContext<W>.getAttribute(String)"], "initializationStart": [354], "initializationEnd": [382], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 466, "focalAPIEnd": 493, "followUpCheck": "val == -1", "checkType": "IF", "followUpCheckExpressionStart": 510, "followUpCheckExpressionEnd": 564, "followUpCheckBlockStart": 510, "followUpCheckBlockEnd": 696, "use": ["processAnimatedChild(WidgetChildProcessorContext<W>,Widget,Direction,val)", "processChild(WidgetChildProcessorContext<W>,Widget,Direction,val)"], "useStart": [832, 916], "useEnd": [891, 967], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/crux-framework/tree/master/branches/crux/3.3.0-GWT-2.2/CruxGWTWidgets/src/br/com/sysmap/crux/gwt/client/AbstractDockLayoutPanelFactory.java", "rawCode": "    @Override\n    public void processChildren(WidgetChildProcessorContext<W> context)\n        throws InterfaceConfigException {\n      Widget childWidget =\n          createChildWidget(context.getChildElement(), context.getChildElement().getId());\n\n      Direction direction = (Direction) context.getAttribute(\"direction\");\n      String sizeStr = (String) context.getAttribute(\"size\");\n      double size = -1;\n      if (!StringUtils.isEmpty(sizeStr)) {\n        size = Double.parseDouble(sizeStr);\n      }\n\n      if (!direction.equals(Direction.CENTER) && size == -1) {\n        throw new InterfaceConfigException(\n            messages.dockLayoutPanelRequiredSize(context.getRootWidgetId()));\n      }\n\n      Integer animationDuration = (Integer) context.getAttribute(\"animationDuration\");\n      if (animationDuration != null) {\n        processAnimatedChild(context, childWidget, direction, size);\n      } else {\n        processChild(context, childWidget, direction, size);\n      }\n    }\n"}, {"dataset": "parseDouble", "exampleID": 1694, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 1090, "focalAPIEnd": 1121, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yeyue910107/MR-Packer/tree/master/src/testquery2.java", "rawCode": "    public void reduce(IntWritable key, Iterable<Text> v, Context context)\n        throws IOException, InterruptedException {\n      Iterator values = v.iterator();\n      ArrayList[] tmp_output = new ArrayList[3];\n      for (int i = 0; i < 3; i++) {\n        tmp_output[i] = new ArrayList();\n      }\n      String tmp = \"\";\n      Double[] result_0 = new Double[1];\n      ArrayList[] d_count_buf_0 = new ArrayList[1];\n      int al_line_0 = 0;\n      for (int i = 0; i < 1; i++) {\n        result_0[i] = 0.0;\n        d_count_buf_0[i] = new ArrayList();\n      }\n\n      ArrayList al_left_1 = new ArrayList();\n      ArrayList al_right_1 = new ArrayList();\n      ArrayList al_left_2 = new ArrayList();\n      ArrayList al_right_2 = new ArrayList();\n      while (values.hasNext()) {\n        String line = values.next().toString();\n        String dispatch = line.split(\"\\\\|\")[1];\n        tmp = line.substring(2 + dispatch.length() + 1);\n        String[] line_buf = tmp.split(\"\\\\|\");\n        if (line.charAt(0) == '2' && (dispatch.length() == 0 || dispatch.indexOf('0') == -1)) {\n          result_0[0] += Double.parseDouble(line_buf[1]);\n          al_line_0++;\n        }\n        if (line.charAt(0) == '2' && (dispatch.length() == 0 || dispatch.indexOf(\"1\") == -1))\n          al_left_1.add(tmp);\n        if (line.charAt(0) == '1' && (dispatch.length() == 0 || dispatch.indexOf(\"1\") == -1))\n          al_right_1.add(tmp);\n      }\n      String[] line_buf = tmp.split(\"\\\\|\");\n      result_0[0] = result_0[0] / al_line_0;\n      tmp_output[0].add(Integer.parseInt(line_buf[0]) + \"|\" + (0.2 * (result_0[0])) + \"|\");\n      for (int i = 0; i < al_left_1.size(); i++) {\n        String[] left_buf_1 = ((String) al_left_1.get(i)).split(\"\\\\|\");\n        for (int j = 0; j < al_right_1.size(); j++) {\n          String[] right_buf_1 = ((String) al_right_1.get(j)).split(\"\\\\|\");\n          tmp_output[1].add(\n              Integer.parseInt(left_buf_1[0])\n                  + \"|\"\n                  + Double.parseDouble(left_buf_1[1])\n                  + \"|\"\n                  + Double.parseDouble(left_buf_1[2])\n                  + \"|\");\n        }\n      }\n      for (int i = 0; i < tmp_output[1].size(); i++) {\n        String[] left_buf_2 = ((String) tmp_output[1].get(i)).split(\"\\\\|\");\n        for (int j = 0; j < tmp_output[0].size(); j++) {\n          String[] right_buf_2 = ((String) tmp_output[0].get(j)).split(\"\\\\|\");\n          if (Double.parseDouble(left_buf_2[1]) < Double.parseDouble(right_buf_2[1])) {\n            tmp_output[2].add(1 + \"|\" + Double.parseDouble(left_buf_2[2]) + \"|\");\n          }\n        }\n      }\n      NullWritable key_op = NullWritable.get();\n      for (int i = 0; i < tmp_output[2].size(); i++) {\n        String result = (String) tmp_output[2].get(i);\n        context.write(key_op, new Text(result));\n      }\n    }\n"}, {"dataset": "parseDouble", "exampleID": 1695, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 57, "focalAPIEnd": 84, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["double.parseDouble(*)"], "useStart": [224], "useEnd": [251], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wubs/485-Project/tree/master/pa6/pagerank/Pagerank.java", "rawCode": "  public void getArguments(String[] args) {\n    dvalue = Double.parseDouble(args[0]);\n    if (args[1].equalsIgnoreCase(\"-k\")) {\n      itenum = Integer.parseInt(args[2]);\n      useIteOrMax = 0;\n    } else {\n      maxchange = Double.parseDouble(args[2]);\n      useIteOrMax = 1;\n    }\n    inputFileName = args[3];\n    outputFileName = args[4];\n\n    PRMap = new HashMap<Integer, PRNode>();\n\n    BuildMap();\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1696, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 89, "focalAPIEnd": 110, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/crux-framework/tree/master/tags/crux/5.1.3/crux-dev/src/main/java/org/cruxframework/crux/core/client/converter/TypeConverters.java", "rawCode": "    @Override\n    public Double from(String b) {\n      return (!StringUtils.isEmpty(b) ? Double.parseDouble(b) : null);\n    }\n"}, {"dataset": "parseDouble", "exampleID": 1697, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 118, "focalAPIEnd": 143, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tbroyer/gwt-sandbox/tree/master/user/gwt-user/src/main/java/com/google/gwt/uibinder/attributeparsers/DoubleAttributeParser.java", "rawCode": "  @Override\n  public String parse(XMLElement source, String value) throws UnableToCompleteException {\n    try {\n      Double.parseDouble(value);\n      // Happy double\n      return value;\n    } catch (NumberFormatException e) {\n      // Not a double, maybe super sees a field ref\n    }\n    String fieldMaybe = super.parse(source, value);\n    if (\"\".equals(fieldMaybe)) {\n      return \"\";\n    }\n    return \"(double)\" + fieldMaybe;\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1698, "initialization": ["String s = get(String)"], "initializationStart": [698], "initializationEnd": [746], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s!=null", "guardType": "IF {", "guardExpressionStart": 754, "guardExpressionEnd": 770, "guardBlockStart": 754, "guardBlockEnd": 1185, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 954, "focalAPIEnd": 977, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Double(val)"], "useStart": [943], "useEnd": [978], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RomRaider/original.flat/tree/master/trunk/installer/IzPack/src/lib/com/izforge/izpack/installer/LayoutHelper.java", "rawCode": "  private static Object getModifierValue(\n      Object currentVal, Object defaultVal, Object readLimit, String key) {\n    if (defaultVal instanceof Integer)\n      if (((Integer) currentVal).intValue() >= ((Integer) readLimit).intValue())\n        return (currentVal);\n    if (defaultVal instanceof Double) {\n      if (((Double) currentVal).doubleValue() >= ((Double) readLimit).doubleValue())\n        return (currentVal);\n    }\n    Object retval = defaultVal;\n    AutomatedInstallData idata = AutomatedInstallData.getInstance();\n    if (!(idata instanceof InstallData)) return (retval);\n    String var = null;\n    if (((InstallData) idata).guiPrefs.modifier.containsKey(key)) {\n      var = (String) ((InstallData) idata).guiPrefs.modifier.get(key);\n      if (var != null) {\n        try {\n          if (defaultVal instanceof Integer) return (new Integer(Integer.parseInt(var)));\n          if (defaultVal instanceof Double) {\n            return (new Double(Double.parseDouble(var)));\n          }\n          return (var);\n        } catch (NumberFormatException nfe) {\n          // Do nothing else use the default value.\n          // Need to set it again at this position??\n        }\n      }\n    }\n    return (retval);\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1699, "initialization": ["String s = getValue()"], "initializationStart": [117], "initializationEnd": [127], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 160, "focalAPIEnd": 190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eduardodaluz/xfire/tree/master/xfire-aegis/src/main/org/codehaus/xfire/aegis/AbstractMessageReader.java", "rawCode": "  /** @see org.codehaus.xfire.aegis.MessageReader#getValueAsDouble() */\n  public double getValueAsDouble() {\n    if (getValue() == null) return 0d;\n\n    return Double.parseDouble(getValue());\n  }\n"}, {"dataset": "parseDouble", "exampleID": 1700, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["quote(String)", "new JSONException(String)"], "tryExpressionStart": 364, "tryExpressionEnd": 368, "tryBlockStart": 364, "tryBlockEnd": 616, "catchExpressionStart": 507, "catchExpressionEnd": 527, "catchBlockStart": 507, "catchBlockEnd": 616, "exceptionHandlingCallStart": [575, 541], "exceptionHandlingCallEnd": [585, 609], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = double.parseDouble(s)", "focalAPIStart": 464, "focalAPIEnd": 499, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mantic0/elocator/tree/master/elocatorWeb/src/org/json/JSONObject.java", "rawCode": "  /**\n   * Get the double value associated with a key.\n   *\n   * @param key A key string.\n   * @return The numeric value.\n   * @throws JSONException if the key is not found or if the value is not a Number object and cannot\n   *     be converted to a number.\n   */\n  public double getDouble(String key) throws JSONException {\n    Object object = this.get(key);\n    try {\n      return object instanceof Number\n          ? ((Number) object).doubleValue()\n          : Double.parseDouble((String) object);\n    } catch (Exception e) {\n      throw new JSONException(\"JSONObject[\" + quote(key) + \"] is not a number.\");\n    }\n  }\n"}]