[{"dataset": "setString", "exampleID": 6201, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1138, "focalAPIEnd": 1182, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.sql.PreparedStatement.setString(int,String)", "preparedStatement.sql.PreparedStatement.execute()"], "useStart": [1188, 1238], "useEnd": [1232, 1267], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/idega/com.idega.developer/tree/master/src/java/com/idega/development/presentation/UserTransformer.java", "rawCode": "  /**\n   * @param updateGroupMetadata\n   * @param updateGroupProtocol\n   * @param updateGroupNetwork\n   * @param updateGroupAddress\n   * @param updateGroupEmail\n   * @param updateGroupPhone\n   * @param updateGroupPermission\n   * @param updateGroupPermission2\n   * @param updateGroupRelations\n   * @param updateICUserPrimaryGroupPG\n   * @param userID\n   * @param newGroupPK\n   * @param oldGroupPK\n   * @throws SQLException\n   */\n  private void updateGroupRelations(\n      java.sql.PreparedStatement updateGroupMetadata,\n      java.sql.PreparedStatement updateGroupProtocol,\n      java.sql.PreparedStatement updateGroupNetwork,\n      java.sql.PreparedStatement updateGroupAddress,\n      java.sql.PreparedStatement updateGroupEmail,\n      java.sql.PreparedStatement updateGroupPhone,\n      java.sql.PreparedStatement updateGroupPermission,\n      java.sql.PreparedStatement updateGroupPermission2,\n      java.sql.PreparedStatement updateGroupRelations,\n      java.sql.PreparedStatement updateICUserPrimaryGroupPG,\n      String userID,\n      String newGroupPK,\n      String oldGroupPK,\n      boolean travelFix)\n      throws SQLException {\n    updateGroupMetadata.setString(1, newGroupPK);\n    updateGroupMetadata.setString(2, oldGroupPK);\n    updateGroupMetadata.execute();\n\n    updateGroupProtocol.setString(1, newGroupPK);\n    updateGroupProtocol.setString(2, oldGroupPK);\n    updateGroupProtocol.execute();\n\n    updateGroupNetwork.setString(1, newGroupPK);\n    updateGroupNetwork.setString(2, oldGroupPK);\n    updateGroupNetwork.execute();\n\n    updateGroupAddress.setString(1, newGroupPK);\n    updateGroupAddress.setString(2, oldGroupPK);\n    updateGroupAddress.execute();\n\n    updateGroupEmail.setString(1, newGroupPK);\n    updateGroupEmail.setString(2, oldGroupPK);\n    updateGroupEmail.execute();\n\n    updateGroupPhone.setString(1, newGroupPK);\n    updateGroupPhone.setString(2, oldGroupPK);\n    updateGroupPhone.execute();\n\n    updateGroupPermission.setString(1, newGroupPK);\n    updateGroupPermission.setString(2, oldGroupPK);\n    updateGroupPermission.execute();\n\n    updateGroupPermission2.setString(1, newGroupPK);\n    updateGroupPermission2.setString(2, oldGroupPK);\n    updateGroupPermission2.execute();\n\n    updateICUserPrimaryGroupPG.setString(1, newGroupPK);\n    updateICUserPrimaryGroupPG.setString(2, oldGroupPK);\n    updateICUserPrimaryGroupPG.execute();\n\n    updateGroupRelations.setString(1, newGroupPK);\n    updateGroupRelations.setString(2, oldGroupPK);\n    // updateGroupRelations.setString(3, userID);\n    updateGroupRelations.execute();\n\n    // updateGroupRelations2.setString(1, newGroupPK);\n    // updateGroupRelations2.setString(2, oldGroupPK);\n    // updateGroupRelations2.execute();\n\n    if (travelFix) {\n      try {\n        SimpleQuerier.execute(\n            \"update sr_supplier set ic_group_id = \"\n                + newGroupPK\n                + \" where ic_group_id = \"\n                + oldGroupPK);\n        SimpleQuerier.execute(\n            \"update sr_reseller set ic_group_id = \"\n                + newGroupPK\n                + \" where ic_group_id = \"\n                + oldGroupPK);\n        SimpleQuerier.execute(\n            \"update TB_SERVICE_SEARCH_ENGINE set group_id = \"\n                + newGroupPK\n                + \" where group_id = \"\n                + oldGroupPK);\n      } catch (Exception e) {\n        throw new SQLException(e.getMessage());\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6202, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [1344], "initializationEnd": [1412], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["preparedStatement.setTimestamp(int,Timestamp)"], "configurationStart": [1422], "configurationEnd": [1494], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1504, "focalAPIEnd": 1536, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setClob(int,Clob)", "preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [1546, 1670, 1701, 1749], "useEnd": [1581, 1691, 1721, 1761], "hasFinally": 1, "cleanUpCall": ["PreparedStatement.close()"], "finallyExpressionStart": 1731, "finallyExpressionEnd": 1739, "finallyBlockStart": 1731, "finallyBlockEnd": 1770, "cleanUpCallStart": [1749], "cleanUpCallEnd": [1761], "url": "https://github.com/socialsoftware/fenix-framework-temp/tree/master/fenix-framework-core/src/main/java/pt/ist/fenixframework/pstm/DBChanges.java", "rawCode": "  void makePersistent(PersistenceBroker pb, int txNumber) throws SQLException, LookupException {\n    // store new objects\n    if (newObjs != null) {\n      for (Object obj : newObjs) {\n        pb.store(obj, ObjectModificationDefaultImpl.INSERT);\n      }\n    }\n\n    boolean foundOptimisticException = false;\n\n    // update objects\n    if (objsToStore != null) {\n      for (Object obj : objsToStore) {\n        try {\n          pb.store(obj, ObjectModificationDefaultImpl.UPDATE);\n        } catch (OptimisticLockException ole) {\n          pb.removeFromCache(obj);\n          foundOptimisticException = true;\n        }\n      }\n    }\n\n    if (foundOptimisticException) {\n      throw new jvstm.CommitException();\n    }\n\n    // delete objects\n    if (objsToDelete != null) {\n      for (Object obj : objsToDelete) {\n        pb.delete(obj);\n      }\n    }\n\n    // write m-to-n tuples\n    if (mToNTuples != null) {\n      for (RelationTupleInfo info : mToNTuples.values()) {\n        updateMtoNRelation(pb, info);\n      }\n    }\n\n    // write change logs\n    Connection conn = pb.serviceConnectionManager().getConnection();\n    writeAttrChangeLogs(conn, txNumber);\n\n    // write ServiceInfo\n    ServiceInfo info = ServiceInfo.getCurrentServiceInfo();\n    if ((info != null) && info.shouldLog()) {\n      PreparedStatement stmt = null;\n      try {\n        stmt = conn.prepareStatement(\"INSERT INTO FF$SERVICE_LOG VALUES (?,?,?,?)\");\n        stmt.setTimestamp(1, new java.sql.Timestamp(System.currentTimeMillis()));\n        stmt.setString(2, info.username);\n        stmt.setString(3, info.serviceName);\n        Clob clob = new SerialClob(info.getArgumentsAsString().toCharArray());\n        stmt.setClob(4, clob);\n        stmt.executeUpdate();\n      } finally {\n        stmt.close();\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6203, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [181], "initializationEnd": [291], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 147, "tryExpressionEnd": 151, "tryBlockStart": 147, "tryBlockEnd": 650, "catchExpressionStart": 593, "catchExpressionEnd": 616, "catchBlockStart": 593, "catchBlockEnd": 650, "exceptionHandlingCallStart": [624], "exceptionHandlingCallEnd": [643], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 299, "focalAPIEnd": 331, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.executeQuery()"], "useStart": [339, 439], "useEnd": [371, 463], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lycantrophe/fp/tree/master/src/FP/Query.java", "rawCode": "  public boolean authorize(String username, String password) {\n\n    System.out.println(\"Starting authorize\");\n    PreparedStatement statement;\n    try {\n      statement =\n          con.prepareStatement(\n              \"SELECT COUNT(*) AS Valid FROM Users WHERE Username = ? AND Password = ?\");\n      statement.setString(1, username);\n      statement.setString(2, password);\n      System.out.println(\"Executing query\");\n      ResultSet rs = statement.executeQuery();\n      rs.first();\n      System.out.println(\"Got result: \" + rs.getInt(1));\n      return rs.getInt(1) == 1 ? true : false;\n    } catch (SQLException e) {\n      e.printStackTrace();\n    }\n    return false;\n  }\n"}, {"dataset": "setString", "exampleID": 6204, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String)"], "initializationStart": [581], "initializationEnd": [609], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["getMessage()", "fail(String)"], "tryExpressionStart": 644, "tryExpressionEnd": 648, "tryBlockStart": 644, "tryBlockEnd": 1090, "catchExpressionStart": 896, "catchExpressionEnd": 922, "catchBlockStart": 896, "catchBlockEnd": 993, "exceptionHandlingCallStart": [966, 932], "exceptionHandlingCallEnd": [983, 984], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 658, "focalAPIEnd": 678, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.execute()", "preparedStatement.setString(int,String)", "preparedStatement.execute()", "preparedStatement.setString(int,String)", "preparedStatement.execute()", "preparedStatement.setString(int,String)", "preparedStatement.execute()", "preparedStatement.close()", "preparedStatement.setString(int,String)", "preparedStatement.close()"], "useStart": [688, 1112, 1141, 1554, 1584, 1998, 2029, 2156, 2189, 2453], "useEnd": [700, 1131, 1153, 1574, 1596, 2019, 2041, 2166, 2217, 2463], "hasFinally": 1, "cleanUpCall": ["Statement.close()"], "finallyExpressionStart": 994, "finallyExpressionEnd": 1002, "finallyBlockStart": 994, "finallyBlockEnd": 1090, "cleanUpCallStart": [1028], "cleanUpCallEnd": [1038], "url": "https://github.com/arjunroy/cinder_dalvik/tree/master/libcore/sql/src/test/java/tests/sql/PreparedStatementTest.java", "rawCode": "  /** @test java.sql.PreparedStatement#setString(int parameterIndex, String x) */\n  @TestTargetNew(\n    level = TestLevel.COMPLETE,\n    notes = \"\",\n    method = \"setString\",\n    args = {int.class, java.lang.String.class}\n  )\n  public void testSetString_mediumTextField() {\n\n    PreparedStatement ps = null;\n    try {\n      String str =\n          \"test^text$test%test(text)test@text5test~test^text$test%test(text)test@text5test/test^text$test%test(text)test@text5test~test^text$test%test(text)test@text5test\";\n      String query = \"insert into type (MText) values (?);\";\n      ps = conn.prepareStatement(query);\n      Statement st = null;\n      try {\n        ps.setString(1, str);\n        ps.execute();\n        st = conn.createStatement();\n        st.execute(\"select * from type where MText='\" + str + \"'\");\n        ResultSet rs = st.getResultSet();\n        assertEquals(1, getCount(rs));\n      } catch (SQLException sqle) {\n        fail(\"SQLException is thrown: \" + sqle.getMessage());\n      } finally {\n        try {\n          st.close();\n        } catch (Exception ee) {\n        }\n      }\n\n      try {\n        ps.setString(1, \"\");\n        ps.execute();\n        st = conn.createStatement();\n        st.execute(\"select * from type where MText=''\");\n        ResultSet rs = st.getResultSet();\n        assertEquals(1, getCount(rs));\n      } catch (SQLException sqle) {\n        fail(\"SQLException is thrown: \" + sqle.getMessage());\n      } finally {\n        try {\n          st.close();\n        } catch (Exception ee) {\n        }\n      }\n\n      try {\n        ps.setString(1, \" \");\n        ps.execute();\n        st = conn.createStatement();\n        st.execute(\"select * from type where MText=' '\");\n        ResultSet rs = st.getResultSet();\n        assertEquals(1, getCount(rs));\n      } catch (SQLException sqle) {\n        fail(\"SQLException is thrown: \" + sqle.getMessage());\n      } finally {\n        try {\n          st.close();\n        } catch (Exception ee) {\n        }\n      }\n\n      try {\n        ps.setString(1, null);\n        ps.execute();\n      } catch (SQLException sqle) {\n        fail(\"SQLException is thrown: \" + sqle.getMessage());\n      }\n\n      ps.close();\n\n      try {\n        ps.setString(2, \"test text\");\n        fail(\"SQLException is not thrown\");\n      } catch (SQLException sqle) {\n        // expected\n      }\n\n    } catch (SQLException e) {\n      fail(\"SQLException is thrown: \" + e.getMessage());\n    } finally {\n      try {\n\n        ps.close();\n      } catch (Exception ee) {\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6205, "initialization": ["String x = getFileName(String)", "PreparedStatement preparedStatement = prepare(String)"], "initializationStart": [278, 370], "initializationEnd": [298, 415], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["rollback()", "convert(*)"], "tryExpressionStart": 73, "tryExpressionEnd": 77, "tryBlockStart": 73, "tryBlockEnd": 594, "catchExpressionStart": 522, "catchExpressionEnd": 545, "catchBlockStart": 522, "catchBlockEnd": 594, "exceptionHandlingCallStart": [553, 577], "exceptionHandlingCallEnd": [563, 587], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 423, "focalAPIEnd": 449, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setLong(int,long)", "preparedStatement.execute()"], "useStart": [457, 484], "useEnd": [476, 498], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/angusmacdonald/h2o/tree/master/src/main/org/h2/store/fs/FileSystemDatabase.java", "rawCode": "  public synchronized void rename(String oldName, String newName) {\n\n    try {\n      long parentOld = getId(oldName, true);\n      long parentNew = getId(newName, true);\n      if (parentOld != parentNew) {\n        throw Message.getUnsupportedException();\n      }\n      newName = getFileName(newName);\n      long id = getId(oldName, false);\n      PreparedStatement prep = prepare(\"UPDATE FILES SET NAME=? WHERE ID=?\");\n      prep.setString(1, newName);\n      prep.setLong(2, id);\n      prep.execute();\n      commit();\n    } catch (SQLException e) {\n      rollback();\n      throw convert(e);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6206, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [262], "initializationEnd": [327], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 335, "focalAPIEnd": 357, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [370, 630], "useEnd": [388, 642], "hasFinally": 1, "cleanUpCall": ["Connection.close()"], "finallyExpressionStart": 586, "finallyExpressionEnd": 594, "finallyBlockStart": 586, "finallyBlockEnd": 763, "cleanUpCallStart": [630], "cleanUpCallEnd": [642], "url": "https://github.com/daxzel/NetCracker-ProGroupShop/tree/master/ProjectShop/ProjectShop-war/src/java/DBManager/DBManager.java", "rawCode": "  public static Catalog findCatalogByName(String name)\n      throws SQLException, NamingException, CatalogException {\n    Connection conn = getConnection();\n    Catalog ctg = null;\n    PreparedStatement pst = null;\n    ResultSet rs = null;\n    try {\n      pst = conn.prepareStatement(\"SELECT * FROM \\\"CATALOG\\\" WHERE NAME = ?\");\n      pst.setString(1, name);\n      rs = pst.executeQuery();\n      if (rs.next()) {\n        ctg = new Catalog(rs.getInt(1), rs.getInt(2), rs.getString(3));\n      } else {\n        throw new CatalogException(\"Каталог с таким именем не найден\");\n      }\n    } finally {\n      if (conn != null) {\n        conn.close();\n      }\n      if (pst != null) {\n        pst.close();\n      }\n      if (rs != null) {\n        rs.close();\n      }\n    }\n    return ctg;\n  }\n"}, {"dataset": "setString", "exampleID": 6207, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [1191], "initializationEnd": [1222], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()", "Connection.close()"], "tryExpressionStart": 712, "tryExpressionEnd": 716, "tryBlockStart": 712, "tryBlockEnd": 4759, "catchExpressionStart": 4589, "catchExpressionEnd": 4609, "catchBlockStart": 4589, "catchBlockEnd": 4759, "exceptionHandlingCallStart": [4617, 4687], "exceptionHandlingCallEnd": [4636, 4698], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1230, "focalAPIEnd": 1258, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()", "preparedStatement.close()", "preparedStatement.execute()", "preparedStatement.close()", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()", "preparedStatement.close()", "preparedStatement.execute()", "preparedStatement.close()", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()", "preparedStatement.close()", "preparedStatement.execute()", "preparedStatement.close()", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()", "preparedStatement.close()", "preparedStatement.execute()", "preparedStatement.close()", "preparedStatement.execute()", "preparedStatement.close()", "preparedStatement.execute()", "preparedStatement.close()"], "useStart": [1266, 1300, 1333, 1362, 1432, 1465, 1491, 1675, 1695, 1934, 1970, 2003, 2029, 2213, 2233, 2496, 2532, 2565, 2591, 2775, 2795, 3042, 3078, 3111, 3137, 3321, 3341, 3950, 3976, 4475, 4501], "useEnd": [1292, 1325, 1354, 1424, 1457, 1483, 1501, 1687, 1705, 1962, 1995, 2021, 2039, 2225, 2243, 2524, 2557, 2583, 2601, 2787, 2805, 3070, 3103, 3129, 3147, 3333, 3351, 3962, 3986, 4487, 4511], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eea/eea.eunis/tree/master/web/src/main/java/ro/finsiel/eunis/search/users/UsersUtility.java", "rawCode": "  /**\n   * Edit a user.\n   *\n   * @param manager who made this change\n   * @param username user name\n   * @param firstName user first name\n   * @param lastName user last name\n   * @param mail user mail\n   * @param loginDate Login date.\n   * @param newUserName new user name\n   * @param request request\n   * @return true if operation was made with success\n   */\n  public static boolean editUser(\n      String manager,\n      String username,\n      String firstName,\n      String lastName,\n      String mail,\n      String loginDate,\n      String newUserName,\n      HttpServletRequest request) {\n    boolean result = false;\n    String updateSQL = \"\";\n    Connection con = null;\n    PreparedStatement ps = null;\n\n    try {\n      con = ro.finsiel.eunis.utilities.TheOneConnectionPool.getConnection();\n      // System.out.println(\"2----------loginDate=\"+loginDate+\"+\");\n      updateSQL = \"\";\n      updateSQL += \" UPDATE eunis_users SET\";\n      updateSQL += \" USERNAME=?,\";\n      updateSQL += \" FIRST_NAME=?,\";\n      updateSQL += \" LAST_NAME=?,\";\n      updateSQL += \" EMAIL=?,\";\n      updateSQL += \" LOGIN_DATE=str_to_date(?,'%d %b %Y %H:%i:%s')\";\n      updateSQL += \" WHERE USERNAME=?\";\n      ps = con.prepareStatement(updateSQL);\n      ps.setString(1, newUserName);\n      ps.setString(2, firstName);\n      ps.setString(3, lastName);\n      ps.setString(4, mail);\n      ps.setString(5, (loginDate == null ? null : loginDate.trim()));\n      ps.setString(6, username);\n      ps.executeUpdate();\n      ps.close();\n      // Not sure if it's needed, but strange things happen when doing fast some operation on user\n      // from web page.\n      ps = con.prepareStatement(\"COMMIT\");\n      ps.execute();\n      ps.close();\n\n      // UPDATE USERS_ROLES\n      updateSQL = \"\";\n      updateSQL += \" UPDATE eunis_users_roles SET\";\n      updateSQL += \" USERNAME=?\";\n      updateSQL += \" WHERE USERNAME=?\";\n      ps = con.prepareStatement(updateSQL);\n      ps.setString(1, newUserName);\n      ps.setString(2, username);\n      ps.executeUpdate();\n      ps.close();\n      // Not sure if it's needed, but strange things happen when doing fast some operation on user\n      // from web page.\n      ps = con.prepareStatement(\"COMMIT\");\n      ps.execute();\n      ps.close();\n\n      // UPDATE eunis_save_advanced_search\n      updateSQL = \"\";\n      updateSQL += \" UPDATE eunis_save_advanced_search SET\";\n      updateSQL += \" USERNAME=?\";\n      updateSQL += \" WHERE USERNAME=?\";\n      ps = con.prepareStatement(updateSQL);\n      ps.setString(1, newUserName);\n      ps.setString(2, username);\n      ps.executeUpdate();\n      ps.close();\n      // Not sure if it's needed, but strange things happen when doing fast some operation on user\n      // from web page.\n      ps = con.prepareStatement(\"COMMIT\");\n      ps.execute();\n      ps.close();\n\n      // UPDATE eunis_group_search\n      updateSQL = \"\";\n      updateSQL += \" UPDATE eunis_group_search SET\";\n      updateSQL += \" USERNAME=?\";\n      updateSQL += \" WHERE USERNAME=?\";\n      ps = con.prepareStatement(updateSQL);\n      ps.setString(1, newUserName);\n      ps.setString(2, username);\n      ps.executeUpdate();\n      ps.close();\n      // Not sure if it's needed, but strange things happen when doing fast some operation on user\n      // from web page.\n      ps = con.prepareStatement(\"COMMIT\");\n      ps.execute();\n      ps.close();\n\n      Vector newRoles = extractRoles(request);\n      Vector oldRoles = getUsersRoles(newUserName);\n\n      if (newRoles != null && oldRoles != null && oldRoles.size() > 0) {\n        for (int i = 0; i < oldRoles.size(); i++) {\n          if (!ObjectIsInVector(newRoles, (String) oldRoles.get(i))) {\n            updateSQL =\n                \"DELETE FROM eunis_users_roles WHERE USERNAME='\"\n                    + newUserName\n                    + \"' AND ROLENAME='\"\n                    + (String) oldRoles.get(i)\n                    + \"'\";\n            ps = con.prepareStatement(updateSQL);\n            ps.execute();\n            ps.close();\n          }\n        }\n      }\n      if (newRoles != null && oldRoles != null && newRoles.size() > 0) {\n        for (int i = 0; i < newRoles.size(); i++) {\n          if (!ObjectIsInVector(oldRoles, (String) newRoles.get(i))) {\n            updateSQL = \"INSERT INTO eunis_users_roles(USERNAME,ROLENAME) VALUES(\";\n            updateSQL += \"'\" + newUserName + \"',\";\n            updateSQL += \"'\" + (String) newRoles.get(i) + \"')\";\n            ps = con.prepareStatement(updateSQL);\n            ps.execute();\n            ps.close();\n          }\n        }\n      }\n      result = true;\n      con.close();\n    } catch (Exception e) {\n      e.printStackTrace();\n      if (null != con) {\n        try {\n          con.close();\n        } catch (SQLException ex) {\n        }\n      }\n    }\n    return result;\n  }\n"}, {"dataset": "setString", "exampleID": 6208, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String)"], "initializationStart": [132], "initializationEnd": [213], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 231, "focalAPIEnd": 254, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [262, 319, 461], "useEnd": [287, 337, 471], "hasFinally": 1, "cleanUpCall": ["PreparedStatement.close()"], "finallyExpressionStart": 445, "finallyExpressionEnd": 453, "finallyBlockStart": 445, "finallyBlockEnd": 478, "cleanUpCallStart": [461], "cleanUpCallEnd": [471], "url": "https://github.com/haku/Lookfar/tree/master/src/main/java/com/vaguehope/lookfar/model/DataStore.java", "rawCode": "  public void upsertNode(final String nodeName, final String hashpw) throws SQLException {\n    final PreparedStatement st =\n        this.conn.prepareStatement(\"UPDATE nodes SET pass=?, updated=now() WHERE node=?\");\n    try {\n      st.setString(1, hashpw);\n      st.setString(2, nodeName);\n      final int rowsUpdates = st.executeUpdate();\n      if (rowsUpdates < 1) { // FIXME race condition.\n        insertNode(nodeName, hashpw);\n      }\n    } finally {\n      st.close();\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6209, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 615, "tryExpressionEnd": 619, "tryBlockStart": 615, "tryBlockEnd": 1434, "catchExpressionStart": 1354, "catchExpressionEnd": 1374, "catchBlockStart": 1354, "catchBlockEnd": 1434, "exceptionHandlingCallStart": [1382], "exceptionHandlingCallEnd": [1427], "configuration": ["preparedStatement.setBinaryStream(int,InputStream,int)"], "configurationStart": [1047], "configurationEnd": [1101], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1157, "focalAPIEnd": 1186, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta03/kernel-impl/src/main/java/org/sakaiproject/content/impl/serialize/impl/conversion/Type1BlobCollectionConversionHandler.java", "rawCode": "  public boolean convertSource(String id, Object source, PreparedStatement updateRecord)\n      throws SQLException {\n\n    String xml = (String) source;\n\n    SAXSerializableCollectionAccess sax = new SAXSerializableCollectionAccess();\n    SAXSerializableCollectionAccess sax2 = new SAXSerializableCollectionAccess();\n    try {\n      sax.parse(xml);\n    } catch (Exception e1) {\n      log.warn(\"Failed to parse \" + id + \"[\" + xml + \"]\", e1);\n      return false;\n    }\n\n    Type1BaseContentCollectionSerializer t1b = new Type1BaseContentCollectionSerializer();\n    t1b.setTimeService(new ConversionTimeService());\n    try {\n      byte[] result = t1b.serialize(sax);\n      t1b.parse(sax2, result);\n      sax.check(sax2);\n\n      if (result == null) {\n        System.out.println(\"convertSource(\" + id + \") result is NULL\");\n        ;\n      } else {\n        // System.out.println(\"convertSource(\" + id + \") result.length == \" + result.length + \"\\n\" +\n        // new String(result));\n        InputStream stream = new ByteArrayInputStream(result);\n        updateRecord.setBinaryStream(1, stream, result.length);\n        // updateRecord.setBytes(1, result);\n\n        updateRecord.setString(2, id);\n        // System.out.println(\"\\n\\nconvertSource(\" + id + \") result.length == \" + result.length + \"\n        // returning true\");\n\n        return true;\n      }\n\n    } catch (Exception e) {\n      log.warn(\"Failed to process record \" + id, e);\n    }\n    return false;\n  }\n"}, {"dataset": "setString", "exampleID": 6210, "initialization": ["String x = getTypeForInt(int)", "PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [721, 1473], "initializationEnd": [754, 1508], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["logErrorCode(String,*,*)", "new KOAException(*,*)"], "tryExpressionStart": 1276, "tryExpressionEnd": 1280, "tryBlockStart": 1276, "tryBlockEnd": 2184, "catchExpressionStart": 1840, "catchExpressionEnd": 1866, "catchBlockStart": 1840, "catchBlockEnd": 2056, "exceptionHandlingCallStart": [1874, 1994], "exceptionHandlingCallEnd": [1980, 2049], "configuration": ["preparedStatement.setTimestamp(int,Timestamp)"], "configurationStart": [1516], "configurationEnd": [1549], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1557, "focalAPIEnd": 1581, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()", "DBUtils.closePreparedStatement(preparedStatement)"], "useStart": [1589, 1623, 1660, 1693, 1762, 2102], "useEnd": [1615, 1652, 1685, 1720, 1782, 2139], "hasFinally": 1, "cleanUpCall": ["DBUtils.closePreparedStatement(PreparedStatement)", "DBUtils.closeConnection(Connection)"], "finallyExpressionStart": 2057, "finallyExpressionEnd": 2065, "finallyBlockStart": 2057, "finallyBlockEnd": 2184, "cleanUpCallStart": [2102, 2147], "cleanUpCallEnd": [2139, 2177], "url": "https://github.com/kiniry/KOA/tree/master/tags/koa2.0.0/infrastructure/source/WebVotingSystem/src/ie/ucd/srg/koa/db/LoggingDB.java", "rawCode": "  /**\n   * Insert an audit message in the database\n   *\n   * @param iType int Int representation of the type\n   * @param sAction The action that started the logging\n   * @param sComponent The component in which the message is logged\n   * @param sActor The initiator of the logging (person)\n   * @param sMessage The message to log\n   * @throws KOAException if something goes wrong during insertion of the audit message\n   */\n  public void insertAuditRecord(\n      int iType, String sAction, String sComponent, String sActor, String sMessage)\n      throws KOAException {\n    KOALogHelper.log(\n        KOALogHelper.TRACE,\n        \"[LoggingDB.insertAuditRecord] start inserting audit record in database\");\n    String sType = KOALogHelper.getTypeForInt(iType);\n    if (sAction == null) {\n      sAction = \"Unknown\";\n    }\n    if (sMessage == null) {\n      KOALogHelper.log(\n          KOALogHelper.WARNING,\n          \"[LoggingDB.insertAuditRecord] Could not log record, no message to log\");\n      throw new KOAException(ErrorConstants.AUDIT_LOG_INSERT);\n    }\n    /* init the DBUtils class */\n    DBUtils xDBUtils = new DBUtils(JNDIProperties.getProperty(JNDIProperties.DATASOURCE_KOA));\n    /* execute the query */\n    Connection conn = null;\n    PreparedStatement xPre = null;\n    try {\n      /* get the connection */\n      conn = xDBUtils.getConnection();\n      Timestamp tsTimestamp = new Timestamp(new Date().getTime());\n      /* setup the prepared statement */\n      xPre = conn.prepareStatement(INSERT_AUDIT);\n      xPre.setTimestamp(1, tsTimestamp);\n      xPre.setString(2, sType);\n      xPre.setString(3, sAction);\n      xPre.setString(4, sComponent);\n      xPre.setString(5, sActor);\n      xPre.setString(6, sMessage);\n      /* execute the statement */\n      xPre.executeUpdate();\n    }\n    /* catch all the errors concerning SQL */\n    catch (SQLException sqle) {\n      KOALogHelper.logErrorCode(\n          \"LoggingDB.insertAuditRecord\", ErrorConstants.ERR_AUDIT_INSERT, sqle);\n      throw new KOAException(ErrorConstants.AUDIT_LOG_INSERT, sqle);\n    } finally {\n      /* close everything */\n      xDBUtils.closePreparedStatement(xPre);\n      xDBUtils.closeConnection(conn);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6211, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [207], "initializationEnd": [234], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 190, "tryExpressionEnd": 194, "tryBlockStart": 190, "tryBlockEnd": 804, "catchExpressionStart": 630, "catchExpressionEnd": 650, "catchBlockStart": 630, "catchBlockEnd": 684, "exceptionHandlingCallStart": [658], "exceptionHandlingCallEnd": [677], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 242, "focalAPIEnd": 267, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [280, 727], "useEnd": [297, 737], "hasFinally": 1, "cleanUpCall": ["PreparedStatement.close()"], "finallyExpressionStart": 685, "finallyExpressionEnd": 693, "finallyBlockStart": 685, "finallyBlockEnd": 804, "cleanUpCallStart": [727], "cleanUpCallEnd": [737], "url": "https://github.com/eea/eea.eunis/tree/master/web/src/main/java/eionet/eunis/dao/impl/SitesDaoImpl.java", "rawCode": "  private String getReportTypeIds(String objectId, Connection con, String query) throws Exception {\n\n    String result = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n\n    try {\n      ps = con.prepareStatement(query);\n      ps.setString(1, objectId);\n      rs = ps.executeQuery();\n\n      while (rs.next()) {\n        String id = rs.getString(\"ID_REPORT_TYPE\");\n\n        if (id != null && !id.equals(\"-1\") && id.length() > 0) {\n          if (result != null && result.length() > 0) {\n            result += \",\";\n          } else {\n            result = \"\";\n          }\n          result += id;\n        }\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      if (ps != null) {\n        ps.close();\n      }\n      if (rs != null) {\n        rs.close();\n      }\n    }\n\n    return result;\n  }\n"}, {"dataset": "setString", "exampleID": 6212, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String)"], "initializationStart": [280], "initializationEnd": [362], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 368, "focalAPIEnd": 390, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()"], "useStart": [411], "useEnd": [430], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bbcf/bbcfutils/tree/master/JAVA/src/ch/epfl/bbcf/bbcfutils/sqlite/SQLiteAccess.java", "rawCode": "  /**\n   * {MANIPULATION} get the length of a chromosome in the database specified\n   *\n   * @param chr - the chromosome\n   * @return an int\n   * @throws SQLException\n   */\n  public int getLengthForChromosome(String chr) throws SQLException {\n    PreparedStatement stat =\n        connection.prepareStatement(\"SELECT length FROM chrNames where name = ? limit 1;\");\n    stat.setString(1, chr);\n    ResultSet rs = stat.executeQuery();\n    while (rs.next()) {\n      int result = rs.getInt(1);\n      rs.close();\n      return result;\n    }\n    rs.close();\n    return -1;\n  }\n"}, {"dataset": "setString", "exampleID": 6213, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String)"], "initializationStart": [1010], "initializationEnd": [1037], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1043, "focalAPIEnd": 1069, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeQuery()"], "useStart": [1075, 1105, 1155], "useEnd": [1099, 1130, 1174], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gantu/u-ims/tree/master/src/main/java/kg/cloud/uims/dao/DbStudLess.java", "rawCode": "  public void execSQL_Subject(String subj_id, String yearID, String semID) throws SQLException {\n\n    String sql =\n        \"select t0.id,t1.id,t1.name,t1.surname,t6.name,t2.name,t2.id,\"\n            + \"t2.code,t2.stdyear,t2.hours,t2.credit,t3.id,\"\n            + \"t3.name,t4.year,t5.semester,t0.status,t7.name, t1.dept_id from less_stud as t0 \"\n            + \"left join student as t1 on t0.student_id=t1.id \"\n            + \"left join department as t6 on t1.dept_id=t6.id \"\n            + \"left join subjects as t2 on t0.subject_id=t2.id \"\n            + \"left join sinif as t3 on t1.group_id=t3.id \"\n            + \"left join year as t4 on t0.year_id=t4.id \"\n            + \"left join semester as t5 on t0.sem_id=t5.id \"\n            + \"left join faculty as t7 on t6.faculty_id=t7.id \"\n            + \"where t2.id=? and t5.id =? and t4.id=? and t0.status > 0 and t0.status < 3 \"\n            + \"and t1.edu_status_id=1 order by t1.name,t1.surname asc;\";\n\n    q = new ArrayList<StudLess>();\n\n    PreparedStatement stat = dbCon.prepareStatement(sql);\n    stat.setString(1, subj_id);\n    stat.setString(2, semID);\n    stat.setString(3, yearID);\n    ResultSet result = stat.executeQuery();\n    while (result.next()) {\n      q.add(\n          new StudLess(\n              result.getInt(\"t0.id\"),\n              result.getInt(\"t1.id\"),\n              result.getInt(\"t2.id\"),\n              result.getInt(\"t3.id\"),\n              result.getInt(\"t0.status\"),\n              result.getString(\"t1.name\"),\n              result.getString(\"t1.surname\"),\n              result.getString(\"t6.name\"),\n              result.getString(\"t2.name\"),\n              result.getString(\"t2.code\"),\n              result.getString(\"t3.name\"),\n              result.getString(\"t4.year\"),\n              result.getString(\"t2.stdyear\"),\n              result.getString(\"t5.semester\"),\n              result.getString(\"t2.hours\"),\n              result.getString(\"t2.credit\"),\n              result.getString(\"t7.name\"),\n              result.getInt(\"t1.dept_id\")));\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6214, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["preparedStatement.setNull(int,int)"], "configurationStart": [285], "configurationEnd": [306], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 404, "focalAPIEnd": 474, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setLong(int,long)", "preparedStatement.setDouble(int,double)", "preparedStatement.setTimestamp(int,Timestamp,Calendar)", "preparedStatement.setString(int,String)", "preparedStatement.setTimestamp(int,java.sql.Timestamp,java.util.Calendar)", "preparedStatement.setBoolean(int,boolean)"], "useStart": [525, 620, 929, 1061, 1581, 1673], "useEnd": [571, 679, 1013, 1131, 1612, 1709], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/shirui/trunk/tree/master/ruby/RubyWar/WEB-INF/gems/gems/activerecord-jdbc-adapter-0.8.2/src/java/jdbc_adapter/JdbcAdapterInternalService.java", "rawCode": "  private static void setValue(\n      PreparedStatement ps,\n      int index,\n      Ruby runtime,\n      ThreadContext context,\n      IRubyObject value,\n      IRubyObject type)\n      throws SQLException {\n    final int tp = getTypeValueFor(runtime, type);\n    if (value.isNil()) {\n      ps.setNull(index, tp);\n      return;\n    }\n\n    switch (tp) {\n      case Types.VARCHAR:\n      case Types.CLOB:\n        ps.setString(index, RubyString.objAsString(context, value).toString());\n        break;\n      case Types.INTEGER:\n        ps.setLong(index, RubyNumeric.fix2long(value));\n        break;\n      case Types.FLOAT:\n        ps.setDouble(index, ((RubyNumeric) value).getDoubleValue());\n        break;\n      case Types.TIMESTAMP:\n      case Types.TIME:\n      case Types.DATE:\n        if (!(value instanceof RubyTime)) {\n          try {\n            Date dd = FORMAT.parse(RubyString.objAsString(context, value).toString());\n            ps.setTimestamp(index, new java.sql.Timestamp(dd.getTime()), Calendar.getInstance());\n          } catch (Exception e) {\n            ps.setString(index, RubyString.objAsString(context, value).toString());\n          }\n        } else {\n          RubyTime rubyTime = (RubyTime) value;\n          java.util.Date date = rubyTime.getJavaDate();\n          long millis = date.getTime();\n          long micros = rubyTime.microseconds() - millis / 1000;\n          java.sql.Timestamp ts = new java.sql.Timestamp(millis);\n          java.util.Calendar cal = Calendar.getInstance();\n          cal.setTime(date);\n          ts.setNanos((int) (micros * 1000));\n          ps.setTimestamp(index, ts, cal);\n        }\n        break;\n      case Types.BOOLEAN:\n        ps.setBoolean(index, value.isTrue());\n        break;\n      default:\n        throw new RuntimeException(\"type \" + type + \" not supported in _bind yet\");\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6215, "initialization": ["PreparedStatement preparedStatement = prepareStatement(*)"], "initializationStart": [1095], "initializationEnd": [1130], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["Connection.rollback()"], "tryExpressionStart": 381, "tryExpressionEnd": 385, "tryBlockStart": 381, "tryBlockEnd": 1818, "catchExpressionStart": 1640, "catchExpressionEnd": 1660, "catchBlockStart": 1640, "catchBlockEnd": 1742, "exceptionHandlingCallStart": [1714], "exceptionHandlingCallEnd": [1727], "configuration": ["preparedStatement.setInt(int,int)"], "configurationStart": [1161], "configurationEnd": [1180], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1253, "focalAPIEnd": 1281, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setInt(preparedStatement,*,int)", "preparedStatement.setBoolean(int,boolean)", "preparedStatement.setInt(int,int)", "preparedStatement.setTimestamp(int,Timestamp)", "preparedStatement.execute()", "preparedStatement.close()"], "useStart": [1289, 1335, 1371, 1432, 1478, 1499], "useEnd": [1327, 1363, 1393, 1462, 1491, 1510], "hasFinally": 1, "cleanUpCall": ["Connection.setAutoCommit(boolean)"], "finallyExpressionStart": 1743, "finallyExpressionEnd": 1751, "finallyBlockStart": 1743, "finallyBlockEnd": 1818, "cleanUpCallStart": [1781], "cleanUpCallEnd": [1803], "url": "https://github.com/yukoff/concourse-connect/tree/master/src/main/java/com/concursive/connect/web/modules/badges/dao/BadgeCategory.java", "rawCode": "  /**\n   * Description of the Method\n   *\n   * @param db Description of the Parameter\n   * @return Description of the Return Value\n   * @throws SQLException Description of the Exception\n   */\n  public boolean insert(Connection db) throws SQLException {\n    if (!isValid()) {\n      return false;\n    }\n    Exception errorMessage = null;\n    boolean commit = db.getAutoCommit();\n    try {\n      if (commit) {\n        db.setAutoCommit(false);\n      }\n      StringBuffer sql = new StringBuffer();\n      sql.append(\n          \"INSERT INTO badge_category \"\n              + \"(\"\n              + (id > -1 ? \"code, \" : \"\")\n              + \"project_category_id, \"\n              + \"item_name, \"\n              + \"logo_id, \"\n              + \"enabled, \"\n              + \"level \");\n      if (entered != null) {\n        sql.append(\", entered \");\n      }\n      sql.append(\") VALUES (\");\n      if (id > -1) {\n        sql.append(\"?, \");\n      }\n      sql.append(\"?, ?, ?, ?, ? \");\n      if (entered != null) {\n        sql.append(\",? \");\n      }\n      sql.append(\")\");\n      int i = 0;\n      PreparedStatement pst = db.prepareStatement(sql.toString());\n      if (id > -1) {\n        pst.setInt(++i, id);\n      }\n      DatabaseUtils.setInt(pst, ++i, projectCategoryId);\n      pst.setString(++i, itemName);\n      DatabaseUtils.setInt(pst, ++i, logoId);\n      pst.setBoolean(++i, enabled);\n      pst.setInt(++i, level);\n      if (entered != null) {\n        pst.setTimestamp(++i, entered);\n      }\n      pst.execute();\n      pst.close();\n      id = DatabaseUtils.getCurrVal(db, \"badge_category_code_seq\", id);\n\n      if (commit) {\n        db.commit();\n      }\n    } catch (Exception e) {\n      errorMessage = e;\n      if (commit) {\n        db.rollback();\n      }\n    } finally {\n      if (commit) {\n        db.setAutoCommit(true);\n      }\n    }\n    if (errorMessage != null) {\n      throw new SQLException(errorMessage.getMessage());\n    }\n    return true;\n  }\n"}, {"dataset": "setString", "exampleID": 6216, "initialization": ["String x = getUsersOrg(List<AttributeType>)", "PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [3178, 3929], "initializationEnd": [3216, 4038], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["getMessage()", "error(*)", "handleFailure(PrintWriter,String,String)", "Connection.close()"], "tryExpressionStart": 3765, "tryExpressionEnd": 3769, "tryBlockStart": 3765, "tryBlockEnd": 4753, "catchExpressionStart": 4418, "catchExpressionEnd": 4441, "catchBlockStart": 4418, "catchBlockEnd": 4753, "exceptionHandlingCallStart": [4464, 4449, 4487, 4594], "exceptionHandlingCallEnd": [4478, 4479, 4554, 4606], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 4163, "focalAPIEnd": 4198, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()"], "useStart": [4224], "useEnd": [4247], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hsr/oscars/tree/master/ion-war/src/main/java/edu/internet2/ion/ionui/servlets/IONUserList.java", "rawCode": "  public void doGet(HttpServletRequest request, HttpServletResponse response)\n      throws IOException, ServletException {\n\n    String methodName = \"IONUserList\";\n    PrintWriter out = response.getWriter();\n\n    // authenticate the reservation\n    /* //porting comment\n    UserSession userSession = new UserSession();\n    String userName = userSession.checkSession(out, request, methodName);\n    if (userName == null) {\n    return;\n    }\n    */\n    // new addition for porting\n    String transId = PathTools.getLocalDomainId() + \"-IONUI-\" + UUID.randomUUID().toString();\n    OSCARSNetLogger netLogger = new OSCARSNetLogger();\n    netLogger.init(ServiceNames.SVC_IONUI, transId);\n    OSCARSNetLogger.setTlogger(netLogger);\n    this.log.info(netLogger.start(methodName));\n\n    ServletCore core = (ServletCore) getServletContext().getAttribute(ServletCore.CORE);\n    if (core == null) {\n      ServletUtils.fatalError(out, methodName);\n    }\n    CoordClient coordClient = core.getCoordClient();\n    // get authZ client\n    AuthZClient authZClient = core.getAuthZClient();\n    // AuthNclient\n    AuthNPolicyClient authNPolicyClient = core.getAuthNPolicyClient();\n\n    CheckSessionReply sessionReply = IONUIUtils.getUserSession(request, methodName, out, core);\n    String userName = sessionReply.getUserName();\n    this.log.debug(\"userName from sessionReply=\" + userName);\n    if (userName == null) {\n      this.log.warn(\n          netLogger.error(methodName, ErrSev.MINOR, \"No user session: cookies invalid, user null\"));\n      return;\n    }\n    // end new addition\n\n    response.setContentType(\"application/json\");\n\n    /*\n    AaaRmiInterface rmiClient = userSession.getAaaInterface();\n\n    //verify is admin\n    String organization = \"\";\n    boolean isAdmin = false;\n    try {\n    HashMap<String, Object> attrQueryParams = new HashMap<String, Object>();\n    attrQueryParams.put(\"objectType\", ModelObject.ATTRIBUTE);\n    attrQueryParams.put(\"operation\", ModelOperation.LIST);\n    attrQueryParams.put(\"listBy\", \"username\");\n    attrQueryParams.put(\"username\", userName);\n    HashMap<String, Object> attrQueryResponse =\n    rmiClient.manageAaaObjects(attrQueryParams);\n    List<Attribute> attrs = (List<Attribute>) attrQueryResponse.get(\"attributes\");\n    for(Attribute attr : attrs){\n    if(IONAuthenticateAdmin.ION_ADMIN_ATTR_NAME.equals(attr.getName())){\n    isAdmin = true;\n    break;\n    }\n    }\n    if(!isAdmin){\n    throw new Exception(\"You do not have administrator privileges\");\n    }\n\n    //get user institution\n    organization = rmiClient.getInstitution(userName);\n    } catch (Exception e) {\n    ServletUtils.handleFailure(out, log, e, methodName);\n    return;\n    }\n    */\n    // comment above for porting. Replaced by below block\n    // verify is admin\n    String organization = \"\";\n    boolean isAdmin = false;\n    try {\n      List<AttributeType> userAttributes = sessionReply.getAttributes();\n      isAdmin = IONUIUtils.isAdminUser(userAttributes);\n      if (!isAdmin) {\n        throw new Exception(\"You do not have administrator privileges\");\n      }\n\n      // get user institution\n      // get user institution from SessionReply object itself?\n      organization = IONUIUtils.getUsersOrg(userAttributes);\n      /*Object[] soapReq = new Object[]{userName};\n      Object[] resp = authNPolicyClient.invoke(\"listInsts\", soapReq);\n      ListInstsReply reply = (ListInstsReply) resp[0];\n      List<String> institutions = reply.getName();\n      log.error (\"obtained institutions list:\"+ institutions);\n      */\n    } catch (Exception e) {\n      ServletUtils.handleFailure(out, log, e, methodName);\n      return;\n    }\n\n    // query derby for allowed users\n    HashMap<String, Boolean> userMap = new HashMap<String, Boolean>();\n    Connection conn = null;\n    try {\n      // Connection conn = DriverManager.getConnection(\"jdbc:derby:ion\");\n      conn = DBUtil.getDBConnection();\n      PreparedStatement userStmt =\n          conn.prepareStatement(\n              \"SELECT username \" + \"FROM adminOrganizationUsers WHERE organization=?\");\n\n      this.log.debug(\n          \"SELECT username FROM adminOrganizationUsers WHERE organization=\" + organization);\n\n      userStmt.setString(1, organization);\n      ResultSet users = userStmt.executeQuery();\n      while (users.next()) {\n        userMap.put(users.getString(1), true);\n        this.log.debug(\"Got user: \" + users.getString(1));\n      }\n      conn.close();\n    } catch (SQLException e) {\n      this.log.error(e.getMessage());\n      ServletUtils.handleFailure(out, \"Unable to load users\", methodName);\n      try {\n        if (conn != null) conn.close();\n      } catch (SQLException sqlEx) {\n        ServletUtils.handleFailure(out, \"Unable to close DB Conn\", methodName);\n      }\n\n      return;\n    }\n\n    // query rmi for users\n    // commenting below block to replace for porting\n    /*\n    List<User> rmiUserList = null;\n    try{\n    HashMap<String, Object> userListRequest = new HashMap<String, Object>();\n    userListRequest.put(\"objectType\", ModelObject.USER);\n    userListRequest.put(\"operation\", ModelOperation.LIST);\n    userListRequest.put(\"listType\", \"plain\");\n    HashMap<String, Object> userListRmiResp = rmiClient.manageAaaObjects(userListRequest);\n    rmiUserList = (List<User>) userListRmiResp.get(\"users\");\n    }catch(Exception e){\n    this.log.error(e.getMessage());\n    ServletUtils.handleFailure(out, \"Unable to load users\", methodName);\n    return;\n    }\n    */\n    List<UserDetails> allUsers = null;\n    try {\n      ListUsersParams req = new ListUsersParams();\n      // TBD do we need any atributes?\n      // req.setAttribute(attributeName);\n      Object[] soapReq = new Object[] {req};\n      Object[] resp = authNPolicyClient.invoke(\"listUsers\", soapReq);\n      ListUsersReply reply = (ListUsersReply) resp[0];\n      allUsers = reply.getUserDetails();\n    } catch (OSCARSServiceException osEx) {\n      log.error(\"Exception while getting all users: \" + osEx.toString());\n      osEx.printStackTrace();\n      ServletUtils.handleFailure(out, log, osEx, methodName);\n      return;\n    }\n\n    // add all the users in our institution to the allowed user list\n    /*\n    for(User user : rmiUserList){\n    if (user.getInstitution().getName().equals(organization)) {\n    userMap.put(user.getLogin(), true);\n    }\n    }\n    */\n    // comment above to replace with below for porting\n    for (UserDetails user : allUsers) {\n      if (user.getInstitution().equals(organization)) {\n        userMap.put(user.getLogin(), true);\n        // TBD change to debug\n        log.debug(\"-Adding user \" + user.getLogin() + \" to the list\");\n      }\n    }\n\n    // combine user lists\n    Map<String, Object> outputMap = new HashMap<String, Object>();\n    ArrayList<HashMap<String, String>> userList = new ArrayList<HashMap<String, String>>();\n    String sortField = \"login\";\n    boolean sortAsc = true;\n    if (request.getParameter(\"sortBy\") != null) {\n      String[] sortParts = request.getParameter(\"sortBy\").split(\" \");\n      if (sortParts.length >= 1) {\n        sortField = sortParts[0];\n      }\n      if (sortParts.length == 2) {\n        sortAsc = \"asc\".equals(sortParts[1]);\n      }\n    }\n\n    // commented 2 lines below for porting\n    /*\n    User[] sortedUsers = new User[rmiUserList.size()];\n    rmiUserList.toArray(sortedUsers);\n    */\n    UserDetails[] sortedUsers = new UserDetails[allUsers.size()];\n    allUsers.toArray(sortedUsers);\n\n    int page = 0;\n    try {\n      page = Integer.parseInt(request.getParameter(\"page\"));\n    } catch (Exception e) {\n    }\n    int resultsPerPage = 10;\n    try {\n      resultsPerPage = Integer.parseInt(request.getParameter(\"resultsPerPage\"));\n    } catch (Exception e) {\n    }\n\n    int start = page * resultsPerPage;\n    int num_seen = 0;\n    boolean hasNextPage = false;\n\n    // commented below line for porting and replaced\n    // Arrays.sort(sortedUsers, new UserComparator<User>(sortField, sortAsc));\n    Arrays.sort(sortedUsers, new UserComparator<UserDetails>(sortField, sortAsc));\n    for (int i = 0; i < sortedUsers.length; i++) {\n      // this.log.debug(\"Got user from RMI \"+sortedUsers[i].getLogin());\n      this.log.debug(\"Got user from SQL-DB \" + sortedUsers[i].getLogin());\n      if (!userMap.containsKey(sortedUsers[i].getLogin())) {\n        this.log.debug(\"User \" + sortedUsers[i].getLogin() + \" not found\");\n        continue;\n      }\n\n      num_seen++;\n      if (num_seen < start) {\n        continue;\n      }\n\n      if (num_seen > start + resultsPerPage) {\n        hasNextPage = true;\n        break;\n      }\n\n      HashMap<String, String> userDataMap = new HashMap<String, String>();\n      userDataMap.put(\"login\", sortedUsers[i].getLogin());\n      userDataMap.put(\"lastName\", sortedUsers[i].getLastName());\n      userDataMap.put(\"firstName\", sortedUsers[i].getFirstName());\n      // userDataMap.put(\"organization\", sortedUsers[i].getInstitution().getName());\n      // commented above to replace with below for porting\n      userDataMap.put(\"organization\", sortedUsers[i].getInstitution());\n      userDataMap.put(\"phone\", sortedUsers[i].getPhonePrimary());\n      userDataMap.put(\"email\", sortedUsers[i].getEmailPrimary());\n      userList.add(userDataMap);\n    }\n    outputMap.put(\"page\", new Integer(page));\n    outputMap.put(\"hasNextPage\", new Boolean(hasNextPage));\n    outputMap.put(\"userData\", userList);\n    JSONObject jsonObject = JSONObject.fromObject(outputMap);\n\n    out.println(\"{}&&\" + jsonObject);\n    this.log.debug(methodName + \".finish\");\n  }\n"}, {"dataset": "setString", "exampleID": 6217, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [182], "initializationEnd": [262], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["getMessage()", "error(*,*)", "new CouldNotDeleteGroup()"], "tryExpressionStart": 136, "tryExpressionEnd": 140, "tryBlockStart": 136, "tryBlockEnd": 497, "catchExpressionStart": 350, "catchExpressionEnd": 373, "catchBlockStart": 350, "catchBlockEnd": 455, "exceptionHandlingCallStart": [391, 381, 423], "exceptionHandlingCallEnd": [405, 409, 448], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 270, "focalAPIEnd": 294, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.execute()"], "useStart": [302], "useEnd": [314], "hasFinally": 1, "cleanUpCall": ["Connection.close()"], "finallyExpressionStart": 456, "finallyExpressionEnd": 464, "finallyBlockStart": 456, "finallyBlockEnd": 497, "cleanUpCallStart": [472], "cleanUpCallEnd": [490], "url": "https://github.com/tubav/fiteagle/tree/master/core/src/main/java/org/fiteagle/core/groupmanagement/SQLiteGroupDatabase.java", "rawCode": "  private void deleteAllResourcesFromSingleGroup(String groupId) throws SQLException {\n    Connection connection = getConnection();\n    try {\n\n      PreparedStatement ps =\n          connection.prepareStatement(\"DELETE FROM Resources WHERE Resources.groupId = ?\");\n      ps.setString(1, groupId);\n      ps.execute();\n      connection.commit();\n\n    } catch (SQLException e) {\n      log.error(e.getMessage(), e);\n      throw new CouldNotDeleteGroup();\n    } finally {\n      connection.close();\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6218, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [947], "initializationEnd": [984], "hasTryCatch": 1, "exceptionType": "KOAException", "exceptionHandlingCall": ["logError(String,String,*)"], "tryExpressionStart": 806, "tryExpressionEnd": 810, "tryBlockStart": 806, "tryBlockEnd": 2285, "catchExpressionStart": 1668, "catchExpressionEnd": 1694, "catchBlockStart": 1668, "catchBlockEnd": 1811, "exceptionHandlingCallStart": [1702], "exceptionHandlingCallEnd": [1786], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 992, "focalAPIEnd": 1020, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.setString(int,String)", "preparedStatement.executeQuery()", "DBUtils.closePreparedStatement(preparedStatement)"], "useStart": [1073, 1338, 1419, 2203], "useEnd": [1092, 1366, 1438, 2240], "hasFinally": 1, "cleanUpCall": ["DBUtils.closeResultSet(ResultSet)", "DBUtils.closePreparedStatement(PreparedStatement)", "DBUtils.closeConnection(Connection)"], "finallyExpressionStart": 2117, "finallyExpressionEnd": 2125, "finallyBlockStart": 2117, "finallyBlockEnd": 2285, "cleanUpCallStart": [2162, 2203, 2248], "cleanUpCallEnd": [2195, 2240, 2278], "url": "https://github.com/kiniry/KOA/tree/master/trunk/infrastructure/source/WebVotingSystem/src/ie/ucd/srg/koa/db/ControllerDB.java", "rawCode": "  /**\n   * OR 22.3.602 Gebruik pincode voor statuswijziging Check if the pincodes exist\n   *\n   * @param sPincode1 the first pincode to be checked.\n   * @param sPincode2 the second pincode to be checked.\n   * @return boolean the result of the check\n   * @throws KOAException Execption when something goes wrong during fetching\n   */\n  public boolean checkPinCode(String sPincode1, String sPincode2) throws KOAException {\n    KOALogHelper.log(KOALogHelper.TRACE, \"[ControllerDB.checkPinCode] start checking pincodes...\");\n    boolean bCheckPin = false;\n    /* init the DBUtils class */\n    DBUtils xDBUtils = new DBUtils(JNDIProperties.getProperty(JNDIProperties.DATASOURCE_KOA));\n    /* execute the query */\n    Connection conn = null;\n    PreparedStatement xPre = null;\n    ResultSet rsResult = null;\n    try {\n      /* get connection */\n      conn = xDBUtils.getConnection();\n      /* setup the prepared statement voor sPincode1 */\n      xPre = conn.prepareStatement(SELECT_PINCODE);\n      xPre.setString(1, sPincode1);\n      /* execute the statement */\n      rsResult = xPre.executeQuery();\n      /* get the result */\n      if (rsResult != null && rsResult.next()) {\n        /* getting counter value */\n        bCheckPin = true;\n      } else {\n        return false;\n      }\n      /* setup the preparedstatement voor sPincode2 */\n      xPre.setString(1, sPincode2);\n      /* execute the statement */\n      rsResult = xPre.executeQuery();\n      /* get the result */\n      if (rsResult != null && rsResult.next()) {\n        /* getting counter value */\n        bCheckPin = true;\n      } else {\n        return false;\n      }\n    }\n    /* catch all KOA exceptions */\n    catch (KOAException koae) {\n      KOALogHelper.logError(\"ControllerDB.checkPinCode\", \"Problems getting pincode\", koae);\n      throw koae;\n    }\n    /* catch all the errors concerning SQL */\n    catch (SQLException sqle) {\n      String[] params = {\"Get pincode\"};\n      KOALogHelper.logErrorCode(\"ControllerDB.checkPinCode\", ErrorConstants.ERR_SQL, params, sqle);\n      throw new KOADBException(ErrorConstants.CONTROLLER_DB_GET_PINCODE, sqle);\n    } finally {\n      /* close everything */\n      xDBUtils.closeResultSet(rsResult);\n      xDBUtils.closePreparedStatement(xPre);\n      xDBUtils.closeConnection(conn);\n    }\n    KOALogHelper.log(KOALogHelper.TRACE, \"[ControllerDB.checkPinCode] pincode exists:\" + bCheckPin);\n    /* return the value of the counter */\n    return bCheckPin;\n  }\n"}, {"dataset": "setString", "exampleID": 6219, "initialization": ["PreparedStatement preparedStatement = getPreparedStatement(String)"], "initializationStart": [179], "initializationEnd": [207], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "getStackTrace(*)", "fail(*)"], "tryExpressionStart": 48, "tryExpressionEnd": 52, "tryBlockStart": 48, "tryBlockEnd": 2015, "catchExpressionStart": 1920, "catchExpressionEnd": 1940, "catchBlockStart": 1920, "catchBlockEnd": 2015, "exceptionHandlingCallStart": [1953, 1991, 1948], "exceptionHandlingCallEnd": [1967, 2007, 2008], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 215, "focalAPIEnd": 242, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.executeUpdate()", "preparedStatement.close()", "preparedStatement.setInt(int,int)", "preparedStatement.close()", "preparedStatement.setString(int,String)", "preparedStatement.setInt(int,int)", "preparedStatement.addBatch()", "preparedStatement.setString(int,String)", "preparedStatement.setInt(int,int)", "preparedStatement.addBatch()", "preparedStatement.setString(int,String)", "preparedStatement.setInt(int,int)", "preparedStatement.addBatch()", "preparedStatement.executeBatch()", "preparedStatement.close()", "preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [250, 275, 843, 968, 1001, 1150, 1184, 1209, 1232, 1267, 1292, 1315, 1349, 1374, 1397, 1663, 1800, 1900], "useEnd": [267, 295, 855, 985, 1013, 1176, 1201, 1224, 1259, 1284, 1307, 1341, 1366, 1389, 1416, 1675, 1819, 1912], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/p6spy/p6spy/tree/master/src/test/java/com/p6spy/engine/spy/P6TestPreparedStatement.java", "rawCode": "  @Test\n  public void testExecuteUpdate() {\n    try {\n      // test a basic insert\n      String update = \"insert into prepstmt_test values (?, ?)\";\n      PreparedStatement prep = getPreparedStatement(update);\n      prep.setString(1, \"miller\");\n      prep.setInt(2, 1);\n      prep.executeUpdate();\n      assertTrue(super.getLastLogEntry().contains(update));\n      assertTrue(super.getLastLogEntry().contains(\"miller\"));\n      assertTrue(super.getLastLogEntry().contains(\"1\"));\n\n      // test dynamic allocation of P6_MAX_FIELDS\n      int MaxFields = 10;\n      StringBuffer bigSelect = new StringBuffer(MaxFields);\n      bigSelect.append(\"select count(*) from prepstmt_test where\");\n      for (int i = 0; i < MaxFields; i++) {\n        if (i > 0) {\n          bigSelect.append(\" or \");\n        }\n        bigSelect.append(\" col2=?\");\n      }\n      prep.close();\n\n      prep = getPreparedStatement(bigSelect.toString());\n      for (int i = 1; i <= MaxFields; i++) {\n        prep.setInt(i, i);\n      }\n      prep.close();\n\n      // test batch inserts\n      update = \"insert into prepstmt_test values (?,?)\";\n      prep = getPreparedStatement(update);\n      prep.setString(1, \"danny\");\n      prep.setInt(2, 2);\n      prep.addBatch();\n      prep.setString(1, \"denver\");\n      prep.setInt(2, 3);\n      prep.addBatch();\n      prep.setString(1, \"aspen\");\n      prep.setInt(2, 4);\n      prep.addBatch();\n      prep.executeBatch();\n      assertTrue(super.getLastLogEntry().contains(update));\n      assertTrue(super.getLastLogEntry().contains(\"aspen\"));\n      assertTrue(super.getLastLogEntry().contains(\"4\"));\n      assertTrue(super.getLastLogEntry().contains(\"batch\"));\n      prep.close();\n\n      String query = \"select count(*) from prepstmt_test\";\n      prep = getPreparedStatement(query);\n      ResultSet rs = prep.executeQuery();\n      rs.next();\n      assertEquals(4, rs.getInt(1));\n\n      rs.close();\n      prep.close();\n    } catch (Exception e) {\n      fail(e.getMessage() + \" due to error:\\n\" + getStackTrace(e));\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6220, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 138, "focalAPIEnd": 167, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.setDate(int,Date)", "preparedStatement.setBytes(int,byte[])"], "useStart": [216, 302, 406], "useEnd": [256, 358, 434], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/europeana/contrib/tree/master/repox2/repoxCore/branches/repoxCore_12_03_2013/src/main/java/pt/utl/ist/util/sql/SqlUtil.java", "rawCode": "  public static void setParameter(PreparedStatement ps, int idx, Object val) throws SQLException {\n    if (val instanceof String) {\n      ps.setString(1, (String) val);\n    } else if (val instanceof Integer) {\n      ps.setInt(1, ((Integer) val).intValue());\n    } else if (val instanceof Date) {\n      ps.setDate(1, new java.sql.Date(((Date) val).getTime()));\n    } else if (val instanceof byte[]) {\n      ps.setBytes(1, (byte[]) val);\n    } else {\n      throw new RuntimeException(\"Index type not implemented\");\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6221, "initialization": ["PreparedStatement preparedStatement = getConnection()"], "initializationStart": [418], "initializationEnd": [438], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(*)"], "tryExpressionStart": 397, "tryExpressionEnd": 401, "tryBlockStart": 397, "tryBlockEnd": 1208, "catchExpressionStart": 1150, "catchExpressionEnd": 1171, "catchBlockStart": 1150, "catchBlockEnd": 1208, "exceptionHandlingCallStart": [1179], "exceptionHandlingCallEnd": [1201], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 497, "focalAPIEnd": 526, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setBoolean(int,boolean)", "preparedStatement.executeUpdate()", "preparedStatement.setString(int,String)", "preparedStatement.executeQuery()"], "useStart": [546, 708, 747, 786, 823, 946, 997], "useEnd": [567, 737, 776, 813, 845, 975, 1018], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mseiwert/RoM/tree/master/playground/src/dataLayer/DataLayer.java", "rawCode": "  /**\n   * addUser - method This method takes a username and a password. It inserts it in the users-table.\n   * Before this it checks if the user already exists. If so it returns false, if the user is\n   * succefully added it returns true.\n   *\n   * @param username\n   * @param password\n   * @return\n   */\n  public boolean addUser(String username, String password) {\n    boolean ret = false;\n\n    try {\n      presql = this.getConnection().prepareStatement(SqlStatements.SQL_IF_USER_EXISTS);\n      presql.setString(1, username);\n      resultset = presql.executeQuery();\n\n      if (resultset.getBoolean(1) == false) {\n        presql = this.getConnection().prepareStatement(SqlStatements.SQL_ADD_USER);\n        presql.setString(1, username);\n        presql.setString(2, password);\n        presql.setBoolean(3, false);\n        presql.executeUpdate();\n\n        presql = this.getConnection().prepareStatement(SqlStatements.SQL_IF_USER_EXISTS);\n        presql.setString(1, username);\n        resultset = presql.executeQuery();\n\n        if (resultset.getBoolean(1) == true) {\n          ret = true;\n        }\n      }\n      this.getConnection().close();\n    } catch (Exception ex) {\n      System.out.println(ex);\n    }\n\n    return ret;\n  }\n"}, {"dataset": "setString", "exampleID": 6222, "initialization": ["PreparedStatement preparedStatement = prepareStatement(*)"], "initializationStart": [255], "initializationEnd": [310], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["lanzaExcepcion(*)"], "tryExpressionStart": 191, "tryExpressionEnd": 195, "tryBlockStart": 191, "tryBlockEnd": 626, "catchExpressionStart": 466, "catchExpressionEnd": 489, "catchBlockStart": 466, "catchBlockEnd": 521, "exceptionHandlingCallStart": [497], "exceptionHandlingCallEnd": [514], "configuration": ["preparedStatement.setLong(int,Long)"], "configurationStart": [318], "configurationEnd": [340], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 348, "focalAPIEnd": 378, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setLong(int,long)", "preparedStatement.executeUpdate()", "cerrar(preparedStatement)"], "useStart": [386, 418, 591], "useEnd": [410, 436, 601], "hasFinally": 1, "cleanUpCall": ["cerrar(PreparedStatement)", "cerrar(Connection)"], "finallyExpressionStart": 575, "finallyExpressionEnd": 583, "finallyBlockStart": 575, "finallyBlockEnd": 626, "cleanUpCallStart": [591, 609], "cleanUpCallEnd": [601, 619], "url": "https://github.com/cidc/siciud/tree/master/WEB-INF/src/cidc/proyectos/db/ProyectosDB.java", "rawCode": "  public boolean insertaObservacion(Long idPro, String observacion, long usuario) {\n    Connection cn = null;\n    PreparedStatement ps = null;\n    boolean retorno = false;\n    int i = 1;\n    try {\n      cn = cursor.getConnection(super.perfil);\n      ps = cn.prepareStatement(rb.getString(\"insertaObservacion\"));\n      ps.setLong(i++, idPro);\n      ps.setString(i++, observacion);\n      ps.setLong(i++, usuario);\n      ps.executeUpdate();\n      retorno = true;\n    } catch (SQLException e) {\n      lanzaExcepcion(e);\n    } catch (Exception e) {\n      lanzaExcepcion(e);\n    } finally {\n      cerrar(ps);\n      cerrar(cn);\n    }\n    return retorno;\n  }\n"}, {"dataset": "setString", "exampleID": 6223, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 207, "tryExpressionEnd": 211, "tryBlockStart": 207, "tryBlockEnd": 372, "catchExpressionStart": 301, "catchExpressionEnd": 324, "catchBlockStart": 301, "catchBlockEnd": 372, "exceptionHandlingCallStart": [340], "exceptionHandlingCallEnd": [363], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 221, "focalAPIEnd": 255, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.execute()"], "useStart": [265], "useEnd": [291], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sanjayshukla/tempo/tree/master/wds-service/src/main/java/org/intalio/tempo/workflow/wds/core/JdbcItemDaoConnection.java", "rawCode": "  public void deleteItem(String uri) throws UnavailableItemException {\n    if (!itemExists(uri)) {\n      throw new UnavailableItemException(\"Item with URI '\" + uri + \"' does not exist.\");\n    } else {\n      try {\n        _deleteStatement.setString(1, uri);\n        _deleteStatement.execute();\n      } catch (SQLException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6224, "initialization": ["PreparedStatement preparedStatement = getCon()"], "initializationStart": [121], "initializationEnd": [129], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["preparedStatement.setLong(int,long)"], "configurationStart": [256], "configurationEnd": [273], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 279, "focalAPIEnd": 301, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setLong(int,long)", "preparedStatement.setLong(int,long)", "preparedStatement.executeUpdate()"], "useStart": [307, 334, 359, 392], "useEnd": [328, 353, 379, 410], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sefirot/androidStuff/tree/master/BerichtsheftApp/src/com/applang/components/NotePicker.java", "rawCode": "  public int insert(long id, String note, String title, long time) throws Exception {\n    PreparedStatement ps =\n        getCon()\n            .prepareStatement(\n                \"INSERT INTO notes (_id,title,note,created,modified) VALUES (?,?,?,?,?)\");\n    ps.setLong(1, id);\n    ps.setString(2, title);\n    ps.setString(3, note);\n    ps.setLong(4, time);\n    ps.setLong(5, now());\n    return ps.executeUpdate();\n  }\n"}, {"dataset": "setString", "exampleID": 6225, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [188], "initializationEnd": [275], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 141, "tryExpressionEnd": 145, "tryBlockStart": 141, "tryBlockEnd": 527, "catchExpressionStart": 468, "catchExpressionEnd": 492, "catchBlockStart": 468, "catchBlockEnd": 527, "exceptionHandlingCallStart": [500], "exceptionHandlingCallEnd": [520], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 283, "focalAPIEnd": 306, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.toString()", "preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [314, 376, 404, 430], "useEnd": [330, 389, 422, 440], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iConomy/iCoLand/tree/master/src/me/slaps/iCoLand/LandDBH2.java", "rawCode": "  public boolean updateLandAddons(int id, String addons) {\n    int ret = 0;\n    Connection conn = null;\n    PreparedStatement ps = null;\n    try {\n      conn = getConnection();\n      ps = conn.prepareStatement(\"UPDATE \" + Config.sqlTableName + \" SET addons = ? WHERE id = ?\");\n      ps.setString(1, addons);\n      ps.setInt(2, id);\n      if (Config.debugModeSQL) iCoLand.info(ps.toString());\n      ret = ps.executeUpdate();\n      ps.close();\n      conn.close();\n    } catch (SQLException ex) {\n      ex.printStackTrace();\n    }\n\n    return (ret > 0);\n  }\n"}, {"dataset": "setString", "exampleID": 6226, "initialization": ["String x = Matcher.group(int)"], "initializationStart": [915], "initializationEnd": [938], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 603, "tryExpressionEnd": 607, "tryBlockStart": 603, "tryBlockEnd": 1391, "catchExpressionStart": 1311, "catchExpressionEnd": 1331, "catchBlockStart": 1311, "catchBlockEnd": 1391, "exceptionHandlingCallStart": [1339], "exceptionHandlingCallEnd": [1384], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1038, "focalAPIEnd": 1072, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setLong(int,long)", "preparedStatement.setBytes(int,byte[])", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)"], "useStart": [1080, 1147, 1187, 1255], "useEnd": [1139, 1179, 1247, 1284], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0-rc01/kernel-impl/src/main/java/org/sakaiproject/content/impl/serialize/impl/conversion/Type1BlobResourcesConversionHandler.java", "rawCode": "  public boolean convertSource(String id, Object source, PreparedStatement updateRecord)\n      throws SQLException {\n\n    String xml = (String) source;\n\n    SAXSerializableResourceAccess sax = new SAXSerializableResourceAccess();\n    SAXSerializableResourceAccess sax2 = new SAXSerializableResourceAccess();\n    try {\n      sax.parse(xml);\n    } catch (Exception e1) {\n      log.warn(\"Failed to parse \" + id + \"[\" + xml + \"]\", e1);\n      return false;\n    }\n\n    Type1BaseContentResourceSerializer t1b = new Type1BaseContentResourceSerializer();\n    t1b.setTimeService(new ConversionTimeService());\n    try {\n      byte[] result = t1b.serialize(sax);\n      t1b.parse(sax2, result);\n      sax.check(sax2);\n\n      Matcher contextMatcher = contextPattern.matcher(sax.getSerializableId());\n      String context = null;\n      if (contextMatcher.find()) {\n        String root = contextMatcher.group(1);\n        context = contextMatcher.group(2);\n        if (!root.equals(\"group/\")) {\n          context = \"~\" + context;\n        }\n      }\n\n      updateRecord.setString(1, context);\n      updateRecord.setLong(2, sax.getSerializableContentLength());\n      updateRecord.setBytes(3, result);\n      updateRecord.setString(4, sax.getSerializableResourceType());\n      updateRecord.setString(5, id);\n      return true;\n    } catch (Exception e) {\n      log.warn(\"Failed to process record \" + id, e);\n    }\n    return false;\n  }\n"}, {"dataset": "setString", "exampleID": 6227, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["error(String,*)"], "tryExpressionStart": 54, "tryExpressionEnd": 58, "tryBlockStart": 54, "tryBlockEnd": 262, "catchExpressionStart": 172, "catchExpressionEnd": 195, "catchBlockStart": 172, "catchBlockEnd": 262, "exceptionHandlingCallStart": [203], "exceptionHandlingCallEnd": [255], "configuration": ["preparedStatement.setInt(int,int)"], "configurationStart": [66], "configurationEnd": [92], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 100, "focalAPIEnd": 129, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()"], "useStart": [137], "useEnd": [164], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/VoraciousSoftworks/Here-There-Be-Dragons/tree/master/src/com/voracious/dragons/server/DBHandler.java", "rawCode": "  public void insertWinner(int GID, String PID) {\n    try {\n      storeWinner.setInt(1, GID);\n      storeWinner.setString(2, PID);\n      storeWinner.executeUpdate();\n    } catch (SQLException e) {\n      logger.error(\"Could not add to the winner table\", e);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6228, "initialization": ["PreparedStatement preparedStatement = getPreparedStatement(String)"], "initializationStart": [439], "initializationEnd": [481], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["preparedStatement.setNull(int,int)"], "configurationStart": [599], "configurationEnd": [639], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 664, "focalAPIEnd": 712, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "returnPreparedStatement(preparedStatement)"], "useStart": [740, 946], "useEnd": [760, 976], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 882, "finallyExpressionEnd": 890, "finallyBlockStart": 882, "finallyBlockEnd": 983, "cleanUpCallStart": [921], "cleanUpCallEnd": [938], "url": "https://github.com/kiniry/KOA/tree/master/branches/split-projects/koa/src/main/ie/ucd/srg/koa/kr/beans/EJSJDBCPersisterCMPTransactioncodeBean.java", "rawCode": "  /**\n   * load\n   *\n   * @generated\n   */\n  public void load(EntityBean eb, Object pKey, boolean forUpdate) throws Exception {\n    Object objectTemp = null;\n    TransactioncodeBean b = (TransactioncodeBean) eb;\n    ie.ucd.srg.koa.kr.beans.TransactioncodeKey _primaryKey =\n        (ie.ucd.srg.koa.kr.beans.TransactioncodeKey) pKey;\n    PreparedStatement pstmt;\n    ResultSet resultSet = null;\n    pstmt =\n        (forUpdate)\n            ? getPreparedStatement(_loadForUpdateString)\n            : getPreparedStatement(_loadString);\n    try {\n      if (_primaryKey.transactienummer == null) {\n        pstmt.setNull(1, java.sql.Types.VARCHAR);\n      } else {\n        pstmt.setString(1, _primaryKey.transactienummer);\n      }\n      resultSet = pstmt.executeQuery();\n      if (!(resultSet.next())) throw new javax.ejb.ObjectNotFoundException();\n      hydrate(eb, resultSet, pKey);\n    } finally {\n      if (resultSet != null) resultSet.close();\n      returnPreparedStatement(pstmt);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6229, "initialization": ["PreparedStatement preparedStatement = Database.getConnection()"], "initializationStart": [256], "initializationEnd": [274], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 172, "tryExpressionEnd": 176, "tryBlockStart": 172, "tryBlockEnd": 801, "catchExpressionStart": 436, "catchExpressionEnd": 459, "catchBlockStart": 436, "catchBlockEnd": 493, "exceptionHandlingCallStart": [467], "exceptionHandlingCallEnd": [486], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 304, "focalAPIEnd": 331, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [345, 554], "useEnd": [364, 566], "hasFinally": 1, "cleanUpCall": ["PreparedStatement.close()"], "finallyExpressionStart": 494, "finallyExpressionEnd": 502, "finallyBlockStart": 494, "finallyBlockEnd": 801, "cleanUpCallStart": [554], "cleanUpCallEnd": [566], "url": "https://github.com/zaphinath/vmqueue/tree/master/src/server/database/TestCaseDB.java", "rawCode": "  /**\n   * @param testCase\n   * @return\n   */\n  public int getTestCaseId(String testCase) {\n    PreparedStatement stmt = null;\n    ResultSet rs = null;\n    int id = 0;\n    try {\n      String sql = \"SELECT id FROM vm_testcases WHERE name = ?\";\n      stmt = db.getConnection().prepareStatement(sql);\n      stmt.setString(1, testCase);\n\n      rs = stmt.executeQuery();\n      while (rs.next()) {\n        id = rs.getInt(\"id\");\n      }\n    } catch (SQLException e) {\n      e.printStackTrace();\n    } finally {\n      if (stmt != null) {\n        try {\n          stmt.close();\n        } catch (SQLException e) {\n          e.printStackTrace();\n        }\n      }\n      if (rs != null) {\n        try {\n          rs.close();\n        } catch (SQLException e) {\n          e.printStackTrace();\n        }\n      }\n    }\n    return id;\n  }\n"}, {"dataset": "setString", "exampleID": 6230, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String)"], "initializationStart": [685], "initializationEnd": [734], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["new DAOException(String,*)"], "tryExpressionStart": 658, "tryExpressionEnd": 662, "tryBlockStart": 658, "tryBlockEnd": 1153, "catchExpressionStart": 906, "catchExpressionEnd": 929, "catchBlockStart": 906, "catchBlockEnd": 973, "exceptionHandlingCallStart": [943], "exceptionHandlingCallEnd": [966], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 742, "focalAPIEnd": 775, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [798, 1042], "useEnd": [825, 1062], "hasFinally": 1, "cleanUpCall": ["PreparedStatement.close()"], "finallyExpressionStart": 974, "finallyExpressionEnd": 982, "finallyBlockStart": 974, "finallyBlockEnd": 1153, "cleanUpCallStart": [1042], "cleanUpCallEnd": [1062], "url": "https://github.com/SERG-Delft/spicy-stonehenge/tree/master/common-library/src/main/java/nl/tudelft/stocktrader/derby/DerbyOrderDAO.java", "rawCode": "  public Order createOrder(\n      String userID, String symbol, String orderType, double quantity, int holdingID)\n      throws DAOException {\n    int orderID = 0;\n    Calendar minCalender = Calendar.getInstance();\n    minCalender.setTimeInMillis(0);\n    Order order =\n        new Order(\n            orderID,\n            orderType,\n            StockTraderUtility.ORDER_STATUS_OPEN,\n            Calendar.getInstance(),\n            minCalender,\n            quantity,\n            BigDecimal.valueOf(1),\n            StockTraderUtility.getOrderFee(orderType),\n            symbol);\n    order.setHoldingId(holdingID);\n\n    PreparedStatement getAccountId = null;\n    try {\n      getAccountId = sqlConnection.prepareStatement(SQL_GET_ACCOUNTID);\n      getAccountId.setString(1, userID);\n      ResultSet rs = getAccountId.executeQuery();\n      if (rs.next()) {\n        order.setAccountId(rs.getInt(1));\n      }\n    } catch (SQLException e) {\n      throw new DAOException(\"\", e);\n    } finally {\n      if (getAccountId != null) {\n        try {\n          getAccountId.close();\n        } catch (SQLException e) {\n          logger.debug(\"\", e);\n        }\n      }\n    }\n\n    PreparedStatement insertOrder = null;\n    PreparedStatement selectOrderID = null;\n    try {\n      insertOrder = sqlConnection.prepareStatement(SQL_INSERT_ORDER);\n      insertOrder.setBigDecimal(1, order.getOrderFee());\n      insertOrder.setBigDecimal(2, order.getPrice());\n      insertOrder.setString(3, order.getSymbol());\n      // FIXED: metro used Double rather than double\n      // insertOrder.setFloat(4, (float) order.getQuantity());\n      insertOrder.setFloat(4, order.getQuantity().floatValue());\n      insertOrder.setString(5, order.getOrderType());\n      insertOrder.setInt(6, order.getAccountId());\n      insertOrder.setInt(7, order.getHoldingId());\n      insertOrder.executeUpdate();\n\n      selectOrderID = sqlConnection.prepareStatement(SQL_SELECT_ORDER_ID);\n      // ORDERFEE = ? AND PRICE = ? AND QUOTE_SYMBOL = ? AND QUANTITY = ?\n      // ORDERTYPE = ? ORDERSTATUS = ? AND ACCOUNT_ACCOUNTID = ?\n      // HOLDING_HOLDINGID = ?\"\n      selectOrderID.setBigDecimal(1, order.getOrderFee());\n      selectOrderID.setBigDecimal(2, order.getPrice());\n      selectOrderID.setString(3, order.getSymbol());\n      selectOrderID.setDouble(4, order.getQuantity());\n      selectOrderID.setString(5, order.getOrderType());\n      selectOrderID.setString(6, \"open\");\n      selectOrderID.setInt(7, order.getAccountId());\n      selectOrderID.setInt(8, order.getHoldingId());\n      ResultSet rs = selectOrderID.executeQuery();\n      if (rs.next()) {\n        try {\n          order.setOrderID(rs.getInt(1));\n        } finally {\n          try {\n            rs.close();\n          } catch (SQLException e) {\n            logger.debug(\"\", e);\n          }\n        }\n      }\n    } catch (SQLException e) {\n      throw new DAOException(\"\", e);\n    } finally {\n      if (insertOrder != null) {\n        try {\n          insertOrder.close();\n        } catch (SQLException e) {\n          logger.debug(\"\", e);\n        }\n      }\n      if (selectOrderID != null) {\n        try {\n          selectOrderID.close();\n        } catch (SQLException e) {\n          logger.debug(\"\", e);\n        }\n      }\n    }\n    return order;\n  }\n"}, {"dataset": "setString", "exampleID": 6231, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [100], "initializationEnd": [159], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 165, "focalAPIEnd": 190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()"], "useStart": [203], "useEnd": [226], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/umangm/Database-Project/tree/master/NetBeans-source/ReTailor/src/java/database/DatabaseConnection.java", "rawCode": "  public ResultSet getUserDetails(String id) throws SQLException {\n    PreparedStatement prepStmt = con.prepareStatement(\"select * from customer where id = ?\");\n    prepStmt.setString(1, id);\n    return prepStmt.executeQuery();\n  }\n"}, {"dataset": "setString", "exampleID": 6232, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [390], "initializationEnd": [421], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "error(*,*)"], "tryExpressionStart": 368, "tryExpressionEnd": 372, "tryBlockStart": 368, "tryBlockEnd": 709, "catchExpressionStart": 564, "catchExpressionEnd": 585, "catchBlockStart": 564, "catchBlockEnd": 634, "exceptionHandlingCallStart": [605, 595], "exceptionHandlingCallEnd": [620, 625], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 494, "focalAPIEnd": 523, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()", "closeConnection(preparedStatement,Connection)"], "useStart": [533, 653], "useEnd": [554, 700], "hasFinally": 1, "cleanUpCall": ["closeConnection(PreparedStatement,Connection)"], "finallyExpressionStart": 635, "finallyExpressionEnd": 643, "finallyBlockStart": 635, "finallyBlockEnd": 709, "cleanUpCallStart": [653], "cleanUpCallEnd": [700], "url": "https://github.com/Flowdalic/openfire/tree/master/src/plugins/fastpath/src/java/org/jivesoftware/openfire/fastpath/providers/ChatNotes.java", "rawCode": "  /**\n   * Updates a note within Live Assistant Database (jlaSession table)\n   *\n   * @param sessionID the chat sessionID associated with this note.\n   * @param note the note itself.\n   */\n  public void appendNote(String sessionID, String note) {\n    Connection con;\n    PreparedStatement pstmt = null;\n    try {\n      con = DbConnectionManager.getConnection();\n      try {\n        pstmt = con.prepareStatement(SET_NOTES);\n        DbConnectionManager.setLargeTextField(pstmt, 1, note);\n        pstmt.setString(2, sessionID);\n        pstmt.executeUpdate();\n      } catch (Exception ex) {\n        Log.error(ex.getMessage(), ex);\n      } finally {\n        DbConnectionManager.closeConnection(pstmt, con);\n      }\n    } catch (Exception ex) {\n      Log.error(ex.getMessage(), ex);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6233, "initialization": ["PreparedStatement preparedStatement = java.sql.Connection.prepareStatement(String)"], "initializationStart": [115], "initializationEnd": [220], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["getMessage()", "println(String)", "java.sql.Connection.rollback()"], "tryExpressionStart": 88, "tryExpressionEnd": 92, "tryBlockStart": 88, "tryBlockEnd": 603, "catchExpressionStart": 350, "catchExpressionEnd": 374, "catchBlockStart": 350, "catchBlockEnd": 603, "exceptionHandlingCallStart": [415, 382, 454], "exceptionHandlingCallEnd": [430, 431, 468], "configuration": ["preparedStatement.setInt(int,int)"], "configurationStart": [228], "configurationEnd": [248], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 256, "focalAPIEnd": 277, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [285, 332], "useEnd": [303, 342], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yolandaw/CS304/tree/master/CS 304 Project/src/hasAuthor.java", "rawCode": "  public void deleteHasAuthor(int callNo, String name) {\n    PreparedStatement ps;\n\n    try {\n      ps =\n          con.prepareStatement(\n              \"DELETE FROM hasAuthor WHERE book_callNo = ? AND hasAuthor_name = ?\");\n      ps.setInt(1, callNo);\n      ps.setString(2, name);\n      ps.executeUpdate();\n\n      con.commit();\n      ps.close();\n    } catch (SQLException ex) {\n      System.out.println(\"Message: \" + ex.getMessage());\n\n      try {\n        con.rollback();\n      } catch (SQLException ex2) {\n        System.out.println(\"Message: \" + ex2.getMessage());\n        System.exit(-1);\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6234, "initialization": ["PreparedStatement preparedStatement = AbsSqlServerProvider.getConnection()"], "initializationStart": [350], "initializationEnd": [369], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 430, "focalAPIEnd": 458, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()", "preparedStatement.getGeneratedKeys()", "preparedStatement.getConnection()"], "useStart": [464, 496, 530, 572, 602], "useEnd": [490, 524, 551, 596, 623], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mayrock/keg-operator-data/tree/master/platform_management/src/edu/thu/keg/mdap/management/impl/favorite/FavoriteManagerImpl.java", "rawCode": "  @Override\n  public boolean setFavid(String userid, String oldfavid, String newfavid)\n      throws SQLException, IllegalFavManageException {\n    String sql = \"update [Favorite] set favid = ? \" + \"where (userid=? and favid=?)\";\n    AbsSqlServerProvider ssp = null;\n    ssp = SqlServerProviderImpl.getInstance();\n    PreparedStatement pstmt =\n        ssp.getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\n    pstmt.setString(1, newfavid);\n    pstmt.setString(2, userid);\n    pstmt.setString(3, oldfavid);\n    pstmt.executeUpdate();\n    ResultSet rs = pstmt.getGeneratedKeys();\n    pstmt.getConnection().close();\n    return true;\n  }\n"}, {"dataset": "setString", "exampleID": 6235, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["Log.warn(String)"], "tryExpressionStart": 157, "tryExpressionEnd": 161, "tryBlockStart": 157, "tryBlockEnd": 634, "catchExpressionStart": 369, "catchExpressionEnd": 392, "catchBlockStart": 369, "catchBlockEnd": 634, "exceptionHandlingCallStart": [402], "exceptionHandlingCallEnd": [625], "configuration": ["preparedStatement.clearParameters()"], "configurationStart": [171], "configurationEnd": [200], "guardCondition": "preparedStatement!=null", "guardType": "IF {", "guardExpressionStart": 124, "guardExpressionEnd": 148, "guardBlockStart": 124, "guardBlockEnd": 640, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 210, "focalAPIEnd": 238, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.execute()"], "useStart": [248, 291, 338], "useEnd": [281, 328, 359], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/KNL-1000/kernel-storage-util/src/main/java/org/sakaiproject/util/conversion/SchemaConversionController.java", "rawCode": "  private void insertErrorReport(\n      PreparedStatement reportError, String id, String handler, String description) {\n    if (reportError != null) {\n      try {\n        reportError.clearParameters();\n        reportError.setString(1, id);\n        reportError.setString(2, handler);\n        reportError.setString(3, description);\n        reportError.execute();\n      } catch (SQLException e) {\n        log.warn(\n            \"Unable to insert error report [\"\n                + id\n                + \" \"\n                + handler\n                + \" \\\"\"\n                + description\n                + \"\\\" \"\n                + e);\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6236, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String)", "PreparedStatement preparedStatement = prepareStatement(String)"], "initializationStart": [217, 391], "initializationEnd": [276, 496], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 195, "tryExpressionEnd": 199, "tryBlockStart": 195, "tryBlockEnd": 776, "catchExpressionStart": 690, "catchExpressionEnd": 713, "catchBlockStart": 690, "catchBlockEnd": 776, "exceptionHandlingCallStart": [723], "exceptionHandlingCallEnd": [742], "configuration": ["preparedStatement.executeUpdate()"], "configurationStart": [286], "configurationEnd": [307], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 508, "focalAPIEnd": 552, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setBoolean(int,boolean)", "preparedStatement.executeUpdate()"], "useStart": [564, 623], "useEnd": [611, 644], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BlackJoker/MMS_new/tree/master/src/de/team55/mms/server/db/sql.java", "rawCode": "  /** Default felder werden gespeichert */\n  public int setDefaultFelder(ArrayList<Feld> felder) {\n    int status = FAILED;\n    PreparedStatement state = null;\n    if (connect() == true) {\n      try {\n        state = this.con.prepareStatement(\"TRUNCATE TABLE default_felder;\");\n        state.executeUpdate();\n        for (int i = 0; i < felder.size(); i++) {\n          state =\n              this.con.prepareStatement(\n                  \"INSERT INTO default_felder(label,dezernat) VALUES (?, ?);\");\n          state.setString(1, felder.get(i).getLabel());\n          state.setBoolean(2, felder.get(i).isDezernat());\n          state.executeUpdate();\n        }\n        status = SUCCESS;\n      } catch (SQLException e) {\n        e.printStackTrace();\n        status = FAILED;\n      }\n      disconnect();\n    }\n    return status;\n  }\n"}, {"dataset": "setString", "exampleID": 6237, "initialization": ["PreparedStatement preparedStatement = prepareStatement(*)"], "initializationStart": [437], "initializationEnd": [479], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["print(String)"], "tryExpressionStart": 204, "tryExpressionEnd": 208, "tryBlockStart": 204, "tryBlockEnd": 826, "catchExpressionStart": 633, "catchExpressionEnd": 657, "catchBlockStart": 633, "catchBlockEnd": 725, "exceptionHandlingCallStart": [665], "exceptionHandlingCallEnd": [718], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 487, "focalAPIEnd": 516, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "closeStatement(preparedStatement)"], "useStart": [530, 782], "useEnd": [555, 819], "hasFinally": 1, "cleanUpCall": ["closeConnection(Connection)", "closeStatement(PreparedStatement)"], "finallyExpressionStart": 726, "finallyExpressionEnd": 734, "finallyBlockStart": 726, "finallyBlockEnd": 826, "cleanUpCallStart": [742, 782], "cleanUpCallEnd": [774, 819], "url": "https://github.com/LastRide/netCracker-maven/tree/master/WayToNetCracker-ejb/src/main/java/netcracker/dao/StudentDAOImpl.java", "rawCode": "  @Override\n  public boolean emailExists(String email) {\n    PreparedStatement stmtInsert = null;\n    Connection conn = DAOFactory.createConnection();\n    ResultSet res = null;\n    int rowsCount = 0;\n    try {\n      StringBuffer sbInsert = new StringBuffer();\n      sbInsert.append(\"SELECT count(id_student) FROM \");\n      sbInsert.append(DAOConstants.StudentsTableName);\n      sbInsert.append(\" WHERE email like ?\");\n      stmtInsert = conn.prepareStatement(sbInsert.toString());\n      stmtInsert.setString(1, null);\n      res = stmtInsert.executeQuery();\n      while (res.next()) {\n        rowsCount = res.getInt(1);\n      }\n    } catch (SQLException ex) {\n      System.out.print(\"\\nSQL exception in createEmployee\");\n    } finally {\n      DAOFactory.closeConnection(conn);\n      DAOFactory.closeStatement(stmtInsert);\n    }\n    if (rowsCount > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6238, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [222], "initializationEnd": [250], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["processDaoException(*,String,String)"], "tryExpressionStart": 168, "tryExpressionEnd": 172, "tryBlockStart": 168, "tryBlockEnd": 538, "catchExpressionStart": 388, "catchExpressionEnd": 408, "catchBlockStart": 388, "catchBlockEnd": 480, "exceptionHandlingCallStart": [416], "exceptionHandlingCallEnd": [473], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 258, "focalAPIEnd": 282, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "closeDaoResources(ResultSet,preparedStatement,Connection)"], "useStart": [296, 497], "useEnd": [315, 531], "hasFinally": 1, "cleanUpCall": ["closeDaoResources(ResultSet,PreparedStatement,Connection)"], "finallyExpressionStart": 481, "finallyExpressionEnd": 489, "finallyBlockStart": 481, "finallyBlockEnd": 538, "cleanUpCallStart": [497], "cleanUpCallEnd": [531], "url": "https://github.com/entando/entando-plugins-parent/tree/master/entando-plugin-jptokenapi/src/main/java/org/entando/entando/plugins/jptokenapi/aps/system/token/ApiTokenDAO.java", "rawCode": "  private String get(String field, String query) {\n    Connection conn = null;\n    PreparedStatement stat = null;\n    ResultSet res = null;\n    String data = null;\n    try {\n      conn = this.getConnection();\n      stat = conn.prepareStatement(query);\n      stat.setString(1, field);\n      res = stat.executeQuery();\n      if (res.next()) {\n        data = res.getString(1);\n      }\n    } catch (Throwable t) {\n      processDaoException(t, \"Error while loading data\", \"get\");\n    } finally {\n      closeDaoResources(res, stat, conn);\n    }\n    return data;\n  }\n"}, {"dataset": "setString", "exampleID": 6239, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["Log.warn(String)"], "tryExpressionStart": 157, "tryExpressionEnd": 161, "tryBlockStart": 157, "tryBlockEnd": 634, "catchExpressionStart": 369, "catchExpressionEnd": 392, "catchBlockStart": 369, "catchBlockEnd": 634, "exceptionHandlingCallStart": [402], "exceptionHandlingCallEnd": [625], "configuration": ["preparedStatement.clearParameters()"], "configurationStart": [171], "configurationEnd": [200], "guardCondition": "preparedStatement!=null", "guardType": "IF {", "guardExpressionStart": 124, "guardExpressionEnd": 148, "guardBlockStart": 124, "guardBlockEnd": 640, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 210, "focalAPIEnd": 238, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.execute()"], "useStart": [248, 291, 338], "useEnd": [281, 328, 359], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/SAK-8908/kernel-util/src/main/java/org/sakaiproject/util/conversion/SchemaConversionController.java", "rawCode": "  private void insertErrorReport(\n      PreparedStatement reportError, String id, String handler, String description) {\n    if (reportError != null) {\n      try {\n        reportError.clearParameters();\n        reportError.setString(1, id);\n        reportError.setString(2, handler);\n        reportError.setString(3, description);\n        reportError.execute();\n      } catch (SQLException e) {\n        log.warn(\n            \"Unable to insert error report [\"\n                + id\n                + \" \"\n                + handler\n                + \" \\\"\"\n                + description\n                + \"\\\" \"\n                + e);\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6240, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [740], "initializationEnd": [824], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 830, "focalAPIEnd": 861, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()"], "useStart": [867], "useEnd": [888], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CNN/CarRental/tree/master/mysql-connector-java-5.1.18/src/testsuite/regression/StringRegressionTest.java", "rawCode": "  private void testConversionForString(String charsetName, Connection convConn, String charsToTest)\n      throws Exception {\n    PreparedStatement pStmt = null;\n\n    this.stmt = convConn.createStatement();\n    createTable(\"charConvTest\", \"(field1 varchar(255))\");\n    this.stmt.executeUpdate(\"INSERT INTO charConvTest VALUES ('\" + charsToTest + \"')\");\n\n    if (!versionMeetsMinimum(4, 1)) {\n      createTable(\"CREATE TABLE charConvTest_\" + charsetName, \"(field1 CHAR(50))\");\n    } else {\n      createTable(\n          \"charConvTest_\" + charsetName, \"(field1 CHAR(50) CHARACTER SET \" + charsetName + \")\");\n    }\n\n    this.stmt.executeUpdate(\n        \"INSERT INTO charConvTest_\" + charsetName + \" VALUES ('\" + charsToTest + \"')\");\n    pStmt = convConn.prepareStatement(\"INSERT INTO charConvTest_\" + charsetName + \" VALUES (?)\");\n    pStmt.setString(1, charsToTest);\n    pStmt.executeUpdate();\n    this.rs = this.stmt.executeQuery(\"SELECT * FROM charConvTest_\" + charsetName);\n\n    assertTrue(this.rs.next());\n\n    String testValue = this.rs.getString(1);\n    System.out.println(testValue);\n    assertTrue(testValue.equals(charsToTest));\n  }\n"}, {"dataset": "setString", "exampleID": 6241, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [249], "initializationEnd": [283], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 294, "focalAPIEnd": 317, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [333, 723], "useEnd": [352, 735], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 617, "finallyExpressionEnd": 625, "finallyBlockStart": 617, "finallyBlockEnd": 816, "cleanUpCallStart": [663], "cleanUpCallEnd": [673], "url": "https://github.com/maleadt/stockplay/tree/master/src/backend/src/java/com/kapti/data/persistence/oracle/QuoteDAO.java", "rawCode": "  public List<Timestamp> getRange(String isin) throws StockPlayException {\n    Connection conn = null;\n    PreparedStatement stmt = null;\n    ResultSet rs = null;\n    try {\n      try {\n        conn = OracleConnection.getConnection();\n        stmt = conn.prepareStatement(QUOTE_RANGE);\n\n        stmt.setString(1, isin);\n\n        rs = stmt.executeQuery();\n        if (rs.next()) {\n          List<Timestamp> tRange = new ArrayList<Timestamp>();\n          tRange.add(rs.getTimestamp(\"min\"));\n          tRange.add(rs.getTimestamp(\"max\"));\n          return tRange;\n        } else {\n          return null;\n        }\n      } finally {\n        if (rs != null) {\n          rs.close();\n        }\n        if (stmt != null) {\n          stmt.close();\n        }\n        if (conn != null) {\n          conn.close();\n        }\n      }\n    } catch (SQLException ex) {\n      throw new SubsystemException(SubsystemException.Type.DATABASE_FAILURE, ex.getCause());\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6242, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [1090], "initializationEnd": [1171], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": [], "tryExpressionStart": 1055, "tryExpressionEnd": 1059, "tryBlockStart": 1055, "tryBlockEnd": 3247, "catchExpressionStart": 2971, "catchExpressionEnd": 2992, "catchBlockStart": 2971, "catchBlockEnd": 3002, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["preparedStatement.clearParameters()"], "configurationStart": [1179], "configurationEnd": [1207], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1215, "focalAPIEnd": 1250, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()", "preparedStatement.clearParameters()", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [1258, 1434, 1469, 1546, 1903], "useEnd": [1284, 1461, 1503, 1571, 1913], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 2921, "finallyExpressionEnd": 2929, "finallyBlockStart": 2921, "finallyBlockEnd": 3247, "cleanUpCallStart": [1903], "cleanUpCallEnd": [1913], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.11/kernel-impl/src/main/java/org/sakaiproject/content/impl/DbContentService.java", "rawCode": "  public void testUTF8Transport(Connection connection) throws Exception {\n    /*\n     * byte[] b = new byte[102400]; byte[] b2 = new byte[102400]; byte[] b3 =\n     * new byte[102400]; char[] cin = new char[102400]; Random r = new\n     * Random(); r.nextBytes(b);\n     */\n    byte[] bin = new byte[1024];\n    char[] cin = new char[1024];\n    byte[] bout = new byte[1024];\n\n    {\n      int i = 0;\n      for (int bx = 0; i < bin.length; bx++) {\n        bin[i++] = (byte) bx;\n      }\n    }\n    ByteStorageConversion.toChar(bin, 0, cin, 0, cin.length);\n    String sin = new String(cin);\n\n    char[] cout = sin.toCharArray();\n    ByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n    for (int i = 0; i < bin.length; i++) {\n      if (bin[i] != bout[i]) {\n        throw new Exception(\n            \"Internal Byte conversion failed at \" + bin[i] + \"=>\" + (int) cin[i] + \"=>\" + bout[i]);\n      }\n    }\n\n    PreparedStatement statement = null;\n    PreparedStatement statement2 = null;\n    PreparedStatement statement3 = null;\n    ResultSet rs = null;\n    try {\n      statement3 =\n          connection.prepareStatement(\"delete from CONTENT_RESOURCE where RESOURCE_ID = ?\");\n      statement3.clearParameters();\n      statement3.setString(1, UTF8TESTID);\n      statement3.executeUpdate();\n\n      statement =\n          connection.prepareStatement(\n              \"insert into CONTENT_RESOURCE ( RESOURCE_ID, XML ) values ( ?, ? )\");\n      statement.clearParameters();\n      statement.setString(1, UTF8TESTID);\n      statement.setString(2, sin);\n      statement.executeUpdate();\n\n      statement2 =\n          connection.prepareStatement(\"select XML from CONTENT_RESOURCE where RESOURCE_ID = ? \");\n      statement2.clearParameters();\n      statement2.setString(1, UTF8TESTID);\n      rs = statement2.executeQuery();\n      String sout = null;\n      if (rs.next()) {\n        sout = rs.getString(1);\n      }\n      rs.close();\n\n      statement3.clearParameters();\n      statement3.setString(1, UTF8TESTID);\n      statement3.executeUpdate();\n\n      if (sout != null) {\n        cout = sout.toCharArray();\n      }\n      ByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n      if (sout != null) {\n        if (sin.length() != sout.length()) {\n          throw new Exception(\n              \"UTF-8 Data was lost communicating with the database, please \"\n                  + \"check connection string and default table types (Truncation/Expansion)\");\n        }\n      }\n\n      for (int i = 0; i < bin.length; i++) {\n        if (bin[i] != bout[i]) {\n          throw new Exception(\n              \"UTF-8 Data was corrupted communicating with the database, \"\n                  + \"please check connectionstring and default table types (Conversion)\"\n                  + \"\"\n                  + bin[i]\n                  + \"=>\"\n                  + (int) cin[i]\n                  + \"=>\"\n                  + bout[i]);\n        }\n      }\n\n    } finally {\n      try {\n        rs.close();\n      } catch (Exception ex) {\n\n      }\n      try {\n        statement3.close();\n      } catch (Exception ex) {\n\n      }\n      try {\n        statement2.close();\n      } catch (Exception ex) {\n\n      }\n      try {\n        statement.close();\n      } catch (Exception ex) {\n\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6243, "initialization": ["String x = new String(char[])", "PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [571, 1044], "initializationEnd": [586, 1124], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": [], "tryExpressionStart": 1020, "tryExpressionEnd": 1024, "tryBlockStart": 1020, "tryBlockEnd": 2739, "catchExpressionStart": 2543, "catchExpressionEnd": 2564, "catchBlockStart": 2543, "catchBlockEnd": 2574, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["x.toCharArray()", "preparedStatement.clearParameters()", "preparedStatement.setInt(int,int)"], "configurationStart": [607, 1132, 1167], "configurationEnd": [624, 1159, 1190], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1198, "focalAPIEnd": 1225, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [1233, 2523], "useEnd": [1258, 2533], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 2493, "finallyExpressionEnd": 2501, "finallyBlockStart": 2493, "finallyBlockEnd": 2739, "cleanUpCallStart": [2523], "cleanUpCallEnd": [2533], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.3.0-b06/kernel-storage-util/src/main/java/org/sakaiproject/util/conversion/CheckConnection.java", "rawCode": "  public void testUTF8Transport(Connection connection) throws Exception {\n    /*\n     * byte[] b = new byte[102400]; byte[] b2 = new byte[102400]; byte[] b3 =\n     * new byte[102400]; char[] cin = new char[102400]; Random r = new\n     * Random(); r.nextBytes(b);\n     */\n    byte[] bin = new byte[102400];\n    char[] cin = new char[102400];\n    byte[] bout = new byte[102400];\n\n    {\n      int i = 0;\n      for (int bx = 0; i < bin.length; bx++) {\n        bin[i++] = (byte) bx;\n      }\n    }\n    ByteStorageConversion.toChar(bin, 0, cin, 0, cin.length);\n    String sin = new String(cin);\n\n    char[] cout = sin.toCharArray();\n    ByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n    for (int i = 0; i < bin.length; i++) {\n      if (bin[i] != bout[i]) {\n        throw new Exception(\n            \"Internal Byte conversion failed at \" + bin[i] + \"=>\" + (int) cin[i] + \"=>\" + bout[i]);\n      }\n    }\n\n    PreparedStatement statement = null;\n    PreparedStatement statement2 = null;\n    ResultSet rs = null;\n    try {\n      statement = connection.prepareStatement(\"insert into blobtest ( id, bval ) values ( ?, ? )\");\n      statement.clearParameters();\n      statement.setInt(1, 20);\n      statement.setString(2, sin);\n      statement.executeUpdate();\n\n      statement2 = connection.prepareStatement(\"select bval from blobtest where id = ? \");\n      statement2.clearParameters();\n      statement2.setInt(1, 20);\n      rs = statement2.executeQuery();\n      String sout = null;\n      if (rs.next()) {\n        sout = rs.getString(1);\n      }\n\n      if (sout == null) throw new IllegalStateException(\"String sout == null!\");\n      cout = sout.toCharArray();\n      ByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n      if (sin.length() != sout.length()) {\n        throw new Exception(\n            \"UTF-8 Data was lost communicating with the database, please \"\n                + \"check connection string and default table types (Truncation/Expansion)\");\n      }\n\n      for (int i = 0; i < bin.length; i++) {\n        if (bin[i] != bout[i]) {\n          throw new Exception(\n              \"UTF-8 Data was corrupted communicating with the database, \"\n                  + \"please check connectionstring and default table types (Conversion)\"\n                  + \"\"\n                  + bin[i]\n                  + \"=>\"\n                  + (int) cin[i]\n                  + \"=>\"\n                  + bout[i]);\n        }\n      }\n\n      log.info(\"DB Connection passes UTF-8 tests\");\n\n    } finally {\n      try {\n        rs.close();\n      } catch (Exception ex) {\n\n      }\n      try {\n        statement2.close();\n      } catch (Exception ex) {\n\n      }\n      try {\n        statement.close();\n      } catch (Exception ex) {\n\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6244, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [238], "initializationEnd": [269], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["getMessage()", "log(*,*,*)"], "tryExpressionStart": 182, "tryExpressionEnd": 186, "tryBlockStart": 182, "tryBlockEnd": 668, "catchExpressionStart": 514, "catchExpressionEnd": 537, "catchBlockStart": 514, "catchBlockEnd": 598, "exceptionHandlingCallStart": [576, 545], "exceptionHandlingCallEnd": [590, 591], "configuration": ["preparedStatement.setInt(int,int)"], "configurationStart": [277], "configurationEnd": [296], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 304, "focalAPIEnd": 330, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["close(preparedStatement)"], "useStart": [633], "useEnd": [642], "hasFinally": 1, "cleanUpCall": ["close(ResultSet)", "close(PreparedStatement)", "close(Connection)"], "finallyExpressionStart": 599, "finallyExpressionEnd": 607, "finallyBlockStart": 599, "finallyBlockEnd": 668, "cleanUpCallStart": [615, 633, 650], "cleanUpCallEnd": [625, 642, 661], "url": "https://github.com/OPENNETWORKINGLAB/flowvisor/tree/master/src/org/flowvisor/config/SliceImpl.java", "rawCode": "  @Override\n  public void setMaxFlowMods(String sliceName, int limit) throws ConfigError {\n    Connection conn = null;\n    PreparedStatement ps = null;\n    ResultSet set = null;\n    try {\n      conn = settings.getConnection();\n      ps = conn.prepareStatement(SFMLIMIT);\n      ps.setInt(1, limit);\n      ps.setString(2, sliceName);\n      if (ps.executeUpdate() == 0)\n        throw new ConfigError(\"Global limit for slice \" + sliceName + \" was not set to \" + limit);\n      notify(sliceName, FFMLIMIT, limit);\n    } catch (SQLException e) {\n      FVLog.log(LogLevel.WARN, null, e.getMessage());\n    } finally {\n      close(set);\n      close(ps);\n      close(conn);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6245, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["Log.warn(String)"], "tryExpressionStart": 157, "tryExpressionEnd": 161, "tryBlockStart": 157, "tryBlockEnd": 634, "catchExpressionStart": 369, "catchExpressionEnd": 392, "catchBlockStart": 369, "catchBlockEnd": 634, "exceptionHandlingCallStart": [402], "exceptionHandlingCallEnd": [625], "configuration": ["preparedStatement.clearParameters()"], "configurationStart": [171], "configurationEnd": [200], "guardCondition": "preparedStatement!=null", "guardType": "IF {", "guardExpressionStart": 124, "guardExpressionEnd": 148, "guardBlockStart": 124, "guardBlockEnd": 640, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 210, "focalAPIEnd": 238, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.execute()"], "useStart": [248, 291, 338], "useEnd": [281, 328, 359], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.20/kernel-util/src/main/java/org/sakaiproject/util/conversion/SchemaConversionController.java", "rawCode": "  private void insertErrorReport(\n      PreparedStatement reportError, String id, String handler, String description) {\n    if (reportError != null) {\n      try {\n        reportError.clearParameters();\n        reportError.setString(1, id);\n        reportError.setString(2, handler);\n        reportError.setString(3, description);\n        reportError.execute();\n      } catch (SQLException e) {\n        log.warn(\n            \"Unable to insert error report [\"\n                + id\n                + \" \"\n                + handler\n                + \" \\\"\"\n                + description\n                + \"\\\" \"\n                + e);\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6246, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [367], "initializationEnd": [418], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["new UserManagerException(String,*)"], "tryExpressionStart": 317, "tryExpressionEnd": 321, "tryBlockStart": 317, "tryBlockEnd": 754, "catchExpressionStart": 674, "catchExpressionEnd": 697, "catchBlockStart": 674, "catchBlockEnd": 754, "exceptionHandlingCallStart": [711], "exceptionHandlingCallEnd": [747], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 426, "focalAPIEnd": 468, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [491, 608], "useEnd": [523, 633], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wso2/commons/tree/master/usermanager/modules/verification/src/main/java/org/wso2/usermanager/verification/email/EmailVerifier.java", "rawCode": "  /**\n   * Returns the user name for matching config string. This can be used to get the user name at the\n   * time where user is confirmed by the email.\n   *\n   * @param confString\n   * @return\n   * @throws UserManagerException\n   */\n  public String getUserName(String confString) throws UserManagerException {\n\n    try {\n      PreparedStatement getUserByConfStmt = dbConnection.prepareStatement(GET_USER_BY_CONF_SQL);\n      getUserByConfStmt.setString(1, confString);\n      ResultSet rs = getUserByConfStmt.executeQuery();\n      if (rs.next()) {\n        String username = rs.getString(\"username\");\n        getUserByConfStmt.close();\n        return username;\n      }\n    } catch (SQLException e) {\n      throw new UserManagerException(\"error\", e);\n    }\n\n    return null;\n  }\n"}, {"dataset": "setString", "exampleID": 6247, "initialization": ["PreparedStatement preparedStatement = prepareStatement(*)"], "initializationStart": [824], "initializationEnd": [879], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 887, "focalAPIEnd": 912, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setLong(int,long)", "preparedStatement.setLong(int,long)", "preparedStatement.executeQuery()", "closeAll(Connection,preparedStatement,ResultSet)"], "useStart": [920, 950, 984, 1109], "useEnd": [942, 970, 1003, 1132], "hasFinally": 1, "cleanUpCall": ["closeAll(Connection,PreparedStatement,ResultSet)"], "finallyExpressionStart": 1093, "finallyExpressionEnd": 1101, "finallyBlockStart": 1093, "finallyBlockEnd": 1139, "cleanUpCallStart": [1109], "cleanUpCallEnd": [1132], "url": "https://github.com/alkacon/alkacon-oamp/tree/master/com.alkacon.opencms.formgenerator/src/com/alkacon/opencms/formgenerator/database/CmsFormDataAccess.java", "rawCode": "  /**\n   * Read a <code>List&lt;{@link String}&gt;</code> with all distinct form field names submitted\n   * with the given form in the given time range.\n   *\n   * <p>\n   *\n   * @param formId to find the form data in the database\n   * @param start the start time to find data\n   * @param end the end time to find data\n   * @return a <code>List&lt;{@link String}&gt;</code> with all distinct form field names submitted\n   *     with the given form in the given time range\n   * @throws SQLException if sth goes wrong\n   */\n  public List<String> readFormFieldNames(final String formId, long start, long end)\n      throws SQLException {\n\n    Connection con = null;\n    PreparedStatement stmt = null;\n    ResultSet rs = null;\n\n    List<String> result = new ArrayList<String>();\n    try {\n      con = getConnection();\n      stmt = con.prepareStatement(getQuery(\"READ_FORM_FIELD_NAMES\"));\n      stmt.setString(1, formId);\n      stmt.setLong(2, start);\n      stmt.setLong(3, end);\n\n      rs = stmt.executeQuery();\n      while (rs.next()) {\n        result.add(rs.getString(DB_FIELDNAME));\n      }\n    } finally {\n      closeAll(con, stmt, rs);\n    }\n    return result;\n  }\n"}, {"dataset": "setString", "exampleID": 6248, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["preparedStatement.setObject(int,Object,int)", "preparedStatement.setObject(int,Object,int)"], "configurationStart": [64, 135], "configurationEnd": [129, 200], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 206, "focalAPIEnd": 247, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setObject(int,Object,int)", "preparedStatement.executeUpdate()", "preparedStatement.getWarnings()", "preparedStatement.close()", "setReturnValue(preparedStatement)"], "useStart": [253, 367, 481, 578, 712], "useEnd": [316, 404, 516, 607, 764], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdbc-bare/spring-jdbc-bare/tree/master/org.springframework.jdbc/src/test/java/org/springframework/jdbc/object/SqlUpdateTests.java", "rawCode": "  public void testUpdateConstructor() throws SQLException {\n    mockPreparedStatement.setObject(1, new Integer(1), Types.NUMERIC);\n    mockPreparedStatement.setObject(2, new Integer(1), Types.NUMERIC);\n    mockPreparedStatement.setString(3, \"rod\");\n    mockPreparedStatement.setObject(4, Boolean.TRUE, Types.BOOLEAN);\n    ctrlPreparedStatement.setVoidCallable();\n    mockPreparedStatement.executeUpdate();\n    ctrlPreparedStatement.setReturnValue(1);\n    if (debugEnabled) {\n      mockPreparedStatement.getWarnings();\n      ctrlPreparedStatement.setReturnValue(null);\n    }\n    mockPreparedStatement.close();\n    ctrlPreparedStatement.setVoidCallable();\n\n    mockConnection.prepareStatement(UPDATE_OBJECTS);\n    ctrlConnection.setReturnValue(mockPreparedStatement);\n\n    replay();\n\n    ConstructorUpdater pc = new ConstructorUpdater();\n    int rowsAffected = pc.run(1, 1, \"rod\", true);\n    assertEquals(1, rowsAffected);\n  }\n"}, {"dataset": "setString", "exampleID": 6249, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 140, "focalAPIEnd": 204, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anagri/SmartPool/tree/master/src/smartpool/data/typeHandler/LocalDateTypeHandler.java", "rawCode": "  @Override\n  public void setParameter(PreparedStatement ps, int i, LocalDate parameter, JdbcType jdbcType)\n      throws SQLException {\n    ps.setString(i, parameter == null ? null : parameter.toString());\n  }\n"}, {"dataset": "setString", "exampleID": 6250, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [140], "initializationEnd": [204], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["printErrors(*)"], "tryExpressionStart": 123, "tryExpressionEnd": 127, "tryBlockStart": 123, "tryBlockEnd": 353, "catchExpressionStart": 299, "catchExpressionEnd": 323, "catchBlockStart": 299, "catchBlockEnd": 353, "exceptionHandlingCallStart": [331], "exceptionHandlingCallEnd": [346], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 212, "focalAPIEnd": 237, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()"], "useStart": [250], "useEnd": [267], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/omarowns/feisbun/tree/master/feisbun/src/java/mysql/MySqlConn.java", "rawCode": "  public void getRequestsFrom(String username) {\n    PreparedStatement ps = null;\n    rs = null;\n    initConnection();\n    try {\n      ps = conn.prepareStatement(\"SELECT * FROM requests WHERE username=?\");\n      ps.setString(1, username);\n      rs = ps.executeQuery();\n      rs.beforeFirst();\n    } catch (SQLException ex) {\n      printErrors(ex);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6251, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String)"], "initializationStart": [619], "initializationEnd": [647], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["getMessage()", "fail(String)"], "tryExpressionStart": 682, "tryExpressionEnd": 686, "tryBlockStart": 682, "tryBlockEnd": 1128, "catchExpressionStart": 934, "catchExpressionEnd": 960, "catchBlockStart": 934, "catchBlockEnd": 1031, "exceptionHandlingCallStart": [1004, 970], "exceptionHandlingCallEnd": [1021, 1022], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 696, "focalAPIEnd": 716, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.execute()", "preparedStatement.setString(int,String)", "preparedStatement.execute()", "preparedStatement.setString(int,String)", "preparedStatement.execute()", "preparedStatement.setString(int,String)", "preparedStatement.execute()", "preparedStatement.close()", "preparedStatement.setString(int,String)", "preparedStatement.close()"], "useStart": [726, 1150, 1179, 1592, 1622, 2036, 2067, 2194, 2227, 2491], "useEnd": [738, 1169, 1191, 1612, 1634, 2057, 2079, 2204, 2255, 2501], "hasFinally": 1, "cleanUpCall": ["Statement.close()"], "finallyExpressionStart": 1032, "finallyExpressionEnd": 1040, "finallyBlockStart": 1032, "finallyBlockEnd": 1128, "cleanUpCallStart": [1066], "cleanUpCallEnd": [1076], "url": "https://github.com/arjunroy/cinder_dalvik/tree/master/libcore/sql/src/test/java/tests/sql/PreparedStatementTest.java", "rawCode": "  /** @test java.sql.PreparedStatement#setString(int parameterIndex, String x) */\n  @TestTargetNew(\n    level = TestLevel.COMPLETE,\n    notes = \"\",\n    method = \"setString\",\n    args = {int.class, java.lang.String.class}\n  )\n  @KnownFailure(\"exception test fails\")\n  public void testSetString_longTextField() {\n\n    PreparedStatement ps = null;\n    try {\n      String str =\n          \"test^text$test%test(text)test@text5test~test^text$test%test(text)test@text5test/test^text$test%test(text)test@text5test~test^text$test%test(text)test@text5test\";\n      String query = \"insert into type (LText) values (?);\";\n      ps = conn.prepareStatement(query);\n      Statement st = null;\n      try {\n        ps.setString(1, str);\n        ps.execute();\n        st = conn.createStatement();\n        st.execute(\"select * from type where LText='\" + str + \"'\");\n        ResultSet rs = st.getResultSet();\n        assertEquals(1, getCount(rs));\n      } catch (SQLException sqle) {\n        fail(\"SQLException is thrown: \" + sqle.getMessage());\n      } finally {\n        try {\n          st.close();\n        } catch (Exception ee) {\n        }\n      }\n\n      try {\n        ps.setString(1, \"\");\n        ps.execute();\n        st = conn.createStatement();\n        st.execute(\"select * from type where LText=''\");\n        ResultSet rs = st.getResultSet();\n        assertEquals(1, getCount(rs));\n      } catch (SQLException sqle) {\n        fail(\"SQLException is thrown: \" + sqle.getMessage());\n      } finally {\n        try {\n          st.close();\n        } catch (Exception ee) {\n        }\n      }\n\n      try {\n        ps.setString(1, \" \");\n        ps.execute();\n        st = conn.createStatement();\n        st.execute(\"select * from type where LText=' '\");\n        ResultSet rs = st.getResultSet();\n        assertEquals(1, getCount(rs));\n      } catch (SQLException sqle) {\n        fail(\"SQLException is thrown: \" + sqle.getMessage());\n      } finally {\n        try {\n          st.close();\n        } catch (Exception ee) {\n        }\n      }\n\n      try {\n        ps.setString(1, null);\n        ps.execute();\n      } catch (SQLException sqle) {\n        fail(\"SQLException is thrown: \" + sqle.getMessage());\n      }\n\n      ps.close();\n\n      try {\n        ps.setString(1, \"test text\");\n        fail(\"SQLException is not thrown\");\n      } catch (SQLException sqle) {\n        // expected\n      }\n\n    } catch (SQLException e) {\n      fail(\"SQLException is thrown: \" + e.getMessage());\n    } finally {\n      try {\n\n        ps.close();\n      } catch (Exception ee) {\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6252, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [1119], "initializationEnd": [1148], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["throwDatabaseException(*)"], "tryExpressionStart": 666, "tryExpressionEnd": 670, "tryBlockStart": 666, "tryBlockEnd": 1527, "catchExpressionStart": 1302, "catchExpressionEnd": 1325, "catchBlockStart": 1302, "catchBlockEnd": 1370, "exceptionHandlingCallStart": [1333], "exceptionHandlingCallEnd": [1363], "configuration": ["preparedStatement.setBytes(int,byte[])"], "configurationStart": [1156], "configurationEnd": [1188], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1196, "focalAPIEnd": 1225, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [1234, 1423], "useEnd": [1258, 1439], "hasFinally": 1, "cleanUpCall": ["PreparedStatement.close()"], "finallyExpressionStart": 1371, "finallyExpressionEnd": 1379, "finallyBlockStart": 1371, "finallyBlockEnd": 1527, "cleanUpCallStart": [1423], "cleanUpCallEnd": [1439], "url": "https://github.com/terraframe/Runway-SDK/tree/master/runwaysdk-server/src/main/java/com/runwaysdk/dataaccess/database/general/PostgreSQL.java", "rawCode": "  /**\n   * This is a special method used to update the baseClass attribute of MdType and it is used only\n   * within the TransactionManagement aspect, hence it takes a JDBC connection object as a\n   * parameter.\n   *\n   * @param mdTypeId\n   * @param table\n   * @param classColumnName\n   * @param classBytes\n   * @param sourceColumnName\n   * @param source\n   * @param conn\n   */\n  @Override\n  public int updateClassAndSource(\n      String mdTypeId,\n      String table,\n      String classColumnName,\n      byte[] classBytes,\n      String sourceColumnName,\n      String source,\n      Connection conn) {\n    PreparedStatement prepared = null;\n\n    int written = 0;\n\n    try {\n      // clear the blob\n      this.truncateBlob(table, classColumnName, mdTypeId, 0, conn);\n\n      // get the blob\n      String update =\n          \"UPDATE \"\n              + table\n              + \" SET \"\n              + classColumnName\n              + \" = ?, \"\n              + sourceColumnName\n              + \" = ? WHERE \"\n              + EntityDAOIF.ID_COLUMN\n              + \" = '\"\n              + mdTypeId\n              + \"'\";\n      prepared = conn.prepareStatement(update);\n      prepared.setBytes(1, classBytes);\n      prepared.setString(2, source);\n\n      prepared.executeUpdate();\n\n      written = classBytes.length;\n    } catch (SQLException e) {\n      this.throwDatabaseException(e);\n    } finally {\n      try {\n        if (prepared != null) prepared.close();\n      } catch (SQLException e) {\n        this.throwDatabaseException(e);\n      }\n    }\n    return written;\n  }\n"}, {"dataset": "setString", "exampleID": 6253, "initialization": ["PreparedStatement preparedStatement = getConnection()", "PreparedStatement preparedStatement = getConnection()"], "initializationStart": [256, 416], "initializationEnd": [276, 436], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 471, "focalAPIEnd": 506, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()"], "useStart": [538], "useEnd": [557], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/miriankapanadze/oop/tree/master/OopProject/src/Model/User.java", "rawCode": "  public static List<User> allUsers(String name) {\n    List<User> users = new ArrayList<User>();\n    String select;\n    PreparedStatement stat;\n    try {\n      if (name == null) {\n        select = \"SELECT USER_ID FROM USER WHERE ROLE = 0;\";\n        stat = MyDB.getConnection().prepareStatement(select);\n      } else {\n        select = \"SELECT USER_ID FROM USER WHERE ROLE = 0 AND USER_NAME like ? ;\";\n        stat = MyDB.getConnection().prepareStatement(select);\n        stat.setString(1, \"%\" + name + \"%\");\n      }\n      ResultSet res = stat.executeQuery();\n      while (res.next()) {\n        int user_id = res.getInt(\"USER_ID\");\n        User us = User.getUserById(user_id);\n        users.add(us);\n      }\n    } catch (SQLException e) {\n\n    }\n    return users;\n  }\n"}, {"dataset": "setString", "exampleID": 6254, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String,*)"], "initializationStart": [139], "initializationEnd": [209], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 248, "focalAPIEnd": 282, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [290, 336, 385], "useEnd": [328, 361, 402], "hasFinally": 1, "cleanUpCall": ["PreparedStatement.close()"], "finallyExpressionStart": 369, "finallyExpressionEnd": 377, "finallyBlockStart": 369, "finallyBlockEnd": 409, "cleanUpCallStart": [385], "cleanUpCallEnd": [402], "url": "https://github.com/akosicki/org.eclipse.dltk.core/tree/master/core/plugins/org.eclipse.dltk.core.index.sql.h2/src/org/eclipse/dltk/internal/core/index/sql/h2/H2FileDao.java", "rawCode": "  public void delete(Connection connection, String path, int containerId) throws SQLException {\n\n    PreparedStatement statement =\n        connection.prepareStatement(Q_DELETE, Statement.RETURN_GENERATED_KEYS);\n    try {\n      int param = 0;\n      statement.setString(++param, path);\n      statement.setInt(++param, containerId);\n      statement.executeUpdate();\n    } finally {\n      statement.close();\n    }\n\n    H2Cache.deleteFileByContainerIdAndPath(containerId, path);\n  }\n"}, {"dataset": "setString", "exampleID": 6255, "initialization": ["String x = new String(char[])", "PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [410, 986], "initializationEnd": [425, 1066], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["x.toCharArray()", "preparedStatement.clearParameters()", "preparedStatement.setInt(int,int)"], "configurationStart": [448, 1076, 1113], "configurationEnd": [465, 1103, 1135], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1145, "focalAPIEnd": 1172, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [1182, 2159], "useEnd": [1207, 2169], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 2125, "finallyExpressionEnd": 2133, "finallyBlockStart": 2125, "finallyBlockEnd": 2485, "cleanUpCallStart": [2159], "cleanUpCallEnd": [2169], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/SAK-8391/kernel-impl/src/test/java/org/sakaiproject/content/impl/serialize/impl/test/MySQLByteStorage.java", "rawCode": "  public void testBlobData() throws SQLException {\n    // run the test 10 times to make really certain there is no problem\n    for (int k = 0; k < 10; k++) {\n      byte[] bin = new byte[102400];\n      char[] cin = new char[102400];\n\n      byte[] bout = new byte[102400];\n      Random r = new Random();\n      r.nextBytes(bin);\n\n      ByteStorageConversion.toChar(bin, 0, cin, 0, cin.length);\n      String sin = new String(cin);\n\n      char[] cout = sin.toCharArray();\n      ByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n      for (int i = 0; i < bin.length; i++) {\n        assertEquals(\n            \"Internal Byte conversion failed at \" + bin[i] + \"=>\" + (int) cin[i] + \"=>\" + bout[i],\n            bin[i],\n            bout[i]);\n      }\n\n      Connection connection = null;\n      PreparedStatement statement = null;\n      PreparedStatement statement2 = null;\n      ResultSet rs = null;\n      try {\n        connection = tds.getConnection();\n        statement =\n            connection.prepareStatement(\"insert into blobtest ( id, bval ) values ( ?, ? )\");\n        statement.clearParameters();\n        statement.setInt(1, k);\n        statement.setString(2, sin);\n        statement.executeUpdate();\n\n        statement2 = connection.prepareStatement(\"select bval from blobtest where id = ? \");\n        statement2.clearParameters();\n        statement2.setInt(1, k);\n        rs = statement2.executeQuery();\n        String sout = null;\n        if (rs.next()) {\n          sout = rs.getString(1);\n        }\n\n        // ensure no NPE, but maybe this is not ok because cout current value may be invalid\n        if (sout != null) {\n          cout = sout.toCharArray();\n        }\n        ByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n        if (sout != null) {\n          assertEquals(\"Input and Output Lenghts are not the same \", sin.length(), sout.length());\n        }\n\n        for (int i = 0; i < bin.length; i++) {\n          assertEquals(\n              \"Database Byte conversion failed at \" + bin[i] + \"=>\" + (int) cin[i] + \"=>\" + bout[i],\n              bin[i],\n              bout[i]);\n        }\n\n      } finally {\n        try {\n          rs.close();\n        } catch (Exception ex) {\n\n        }\n        try {\n          statement2.close();\n        } catch (Exception ex) {\n\n        }\n        try {\n          statement.close();\n        } catch (Exception ex) {\n\n        }\n        try {\n          connection.close();\n        } catch (Exception ex) {\n\n        }\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6256, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [185], "initializationEnd": [419], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "error(*,*)", "new GroupException(String,*)"], "tryExpressionStart": 111, "tryExpressionEnd": 115, "tryBlockStart": 111, "tryBlockEnd": 896, "catchExpressionStart": 686, "catchExpressionEnd": 706, "catchBlockStart": 686, "catchBlockEnd": 849, "exceptionHandlingCallStart": [724, 714, 773], "exceptionHandlingCallEnd": [738, 742, 823], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 427, "focalAPIEnd": 447, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [470, 633], "useEnd": [486, 643], "hasFinally": 1, "cleanUpCall": ["Database.releaseConnection(Connection)"], "finallyExpressionStart": 850, "finallyExpressionEnd": 858, "finallyBlockStart": 850, "finallyBlockEnd": 896, "cleanUpCallStart": [866], "cleanUpCallEnd": [889], "url": "https://github.com/NCIP/cagrid-core/tree/master/caGrid/projects/service-tools/src/org/cagrid/tools/groups/GroupManager.java", "rawCode": "  public Group getGroup(String name) throws GroupException {\n    buildDatabase();\n    Connection c = null;\n    try {\n      c = db.getConnection();\n      PreparedStatement s =\n          c.prepareStatement(\n              \"select \"\n                  + GROUP_ID_FIELD\n                  + \" from \"\n                  + GROUPS_TABLE\n                  + \" where \"\n                  + GROUP_NAME_FIELD\n                  + \"= ?\");\n      s.setString(1, name);\n      ResultSet rs = s.executeQuery();\n      Group grp = null;\n      if (rs.next()) {\n        grp = new Group(db, rs.getLong(GROUP_ID_FIELD));\n        grp.setName(name);\n      }\n      rs.close();\n      s.close();\n      return grp;\n    } catch (Exception e) {\n      log.error(e.getMessage(), e);\n      GroupException fault = new GroupException(\"Unexpected Database Error\", e);\n      throw fault;\n    } finally {\n      db.releaseConnection(c);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6257, "initialization": ["PreparedStatement preparedStatement = prepareStatement(*)"], "initializationStart": [824], "initializationEnd": [879], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 887, "focalAPIEnd": 912, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setLong(int,long)", "preparedStatement.setLong(int,long)", "preparedStatement.executeQuery()", "closeAll(Connection,preparedStatement,ResultSet)"], "useStart": [920, 950, 984, 1109], "useEnd": [942, 970, 1003, 1132], "hasFinally": 1, "cleanUpCall": ["closeAll(Connection,PreparedStatement,ResultSet)"], "finallyExpressionStart": 1093, "finallyExpressionEnd": 1101, "finallyBlockStart": 1093, "finallyBlockEnd": 1139, "cleanUpCallStart": [1109], "cleanUpCallEnd": [1132], "url": "https://github.com/alkacon/alkacon-oamp/tree/master/com.alkacon.opencms.v8.formgenerator/src/com/alkacon/opencms/v8/formgenerator/database/CmsFormDataAccess.java", "rawCode": "  /**\n   * Read a <code>List&lt;{@link String}&gt;</code> with all distinct form field names submitted\n   * with the given form in the given time range.\n   *\n   * <p>\n   *\n   * @param formId to find the form data in the database\n   * @param start the start time to find data\n   * @param end the end time to find data\n   * @return a <code>List&lt;{@link String}&gt;</code> with all distinct form field names submitted\n   *     with the given form in the given time range\n   * @throws SQLException if sth goes wrong\n   */\n  public List<String> readFormFieldNames(final String formId, long start, long end)\n      throws SQLException {\n\n    Connection con = null;\n    PreparedStatement stmt = null;\n    ResultSet rs = null;\n\n    List<String> result = new ArrayList<String>();\n    try {\n      con = getConnection();\n      stmt = con.prepareStatement(getQuery(\"READ_FORM_FIELD_NAMES\"));\n      stmt.setString(1, formId);\n      stmt.setLong(2, start);\n      stmt.setLong(3, end);\n\n      rs = stmt.executeQuery();\n      while (rs.next()) {\n        result.add(rs.getString(DB_FIELDNAME));\n      }\n    } finally {\n      closeAll(con, stmt, rs);\n    }\n    return result;\n  }\n"}, {"dataset": "setString", "exampleID": 6258, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [4564], "initializationEnd": [4623], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["printSQLException(*)"], "tryExpressionStart": 2140, "tryExpressionEnd": 2144, "tryBlockStart": 2140, "tryBlockEnd": 10201, "catchExpressionStart": 8641, "catchExpressionEnd": 8665, "catchBlockStart": 8641, "catchBlockEnd": 9259, "exceptionHandlingCallStart": [9308], "exceptionHandlingCallEnd": [9331], "configuration": ["preparedStatement.setInt(int,int)"], "configurationStart": [4664], "configurationEnd": [4688], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 4696, "focalAPIEnd": 4732, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()", "preparedStatement.setInt(int,int)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()"], "useStart": [4740, 4824, 4856, 4898], "useEnd": [4764, 4848, 4890, 4922], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 9339, "finallyExpressionEnd": 9347, "finallyBlockStart": 9339, "finallyBlockEnd": 10201, "cleanUpCallStart": [9487], "cleanUpCallEnd": [9497], "url": "https://github.com/daball/Cooking-to-Goal/tree/master/lib/db-derby-10.7.1.1-bin/demo/programs/simple/SimpleApp.java", "rawCode": "  /**\n   * Starts the actual demo activities. This includes loading the correct JDBC driver, creating a\n   * database by making a connection to Derby, creating a table in the database, and inserting,\n   * updating and retrieving some data. Some of the retrieved data is then verified (compared)\n   * against the expected results. Finally, the table is deleted and, if the embedded framework is\n   * used, the database is shut down.\n   *\n   * <p>Generally, when using a client/server framework, other clients may be (or want to be)\n   * connected to the database, so you should be careful about doing shutdown unless you know that\n   * no one else needs to access the database until it is rebooted. That is why this demo will not\n   * shut down the database unless it is running Derby embedded.\n   *\n   * @param args - Optional argument specifying which framework or JDBC driver to use to connect to\n   *     Derby. Default is the embedded framework, see the <code>main()</code> method for details.\n   * @see #main(String[])\n   */\n  void go(String[] args) {\n    /* parse the arguments to determine which framework is desired*/\n    parseArguments(args);\n\n    System.out.println(\"SimpleApp starting in \" + framework + \" mode\");\n\n    /* load the desired JDBC driver */\n    loadDriver();\n\n    /* We will be using Statement and PreparedStatement objects for\n     * executing SQL. These objects, as well as Connections and ResultSets,\n     * are resources that should be released explicitly after use, hence\n     * the try-catch-finally pattern used below.\n     * We are storing the Statement and Prepared statement object references\n     * in an array list for convenience.\n     */\n    Connection conn = null;\n    /* This ArrayList usage may cause a warning when compiling this class\n     * with a compiler for J2SE 5.0 or newer. We are not using generics\n     * because we want the source to support J2SE 1.4.2 environments. */\n    ArrayList statements = new ArrayList(); // list of Statements, PreparedStatements\n    PreparedStatement psInsert = null;\n    PreparedStatement psUpdate = null;\n    Statement s = null;\n    ResultSet rs = null;\n    try {\n      Properties props = new Properties(); // connection properties\n      // providing a user name and password is optional in the embedded\n      // and derbyclient frameworks\n      props.put(\"user\", \"user1\");\n      props.put(\"password\", \"user1\");\n\n      /* By default, the schema APP will be used when no username is\n       * provided.\n       * Otherwise, the schema name is the same as the user name (in this\n       * case \"user1\" or USER1.)\n       *\n       * Note that user authentication is off by default, meaning that any\n       * user can connect to your database using any password. To enable\n       * authentication, see the Derby Developer's Guide.\n       */\n\n      String dbName = \"derbyDB\"; // the name of the database\n\n      /*\n       * This connection specifies create=true in the connection URL to\n       * cause the database to be created when connecting for the first\n       * time. To remove the database, remove the directory derbyDB (the\n       * same as the database name) and its contents.\n       *\n       * The directory derbyDB will be created under the directory that\n       * the system property derby.system.home points to, or the current\n       * directory (user.dir) if derby.system.home is not set.\n       */\n      conn = DriverManager.getConnection(protocol + dbName + \";create=true\", props);\n\n      System.out.println(\"Connected to and created database \" + dbName);\n\n      // We want to control transactions manually. Autocommit is on by\n      // default in JDBC.\n      conn.setAutoCommit(false);\n\n      /* Creating a statement object that we can use for running various\n       * SQL statements commands against the database.*/\n      s = conn.createStatement();\n      statements.add(s);\n\n      // We create a table...\n      s.execute(\"create table location(num int, addr varchar(40))\");\n      System.out.println(\"Created table location\");\n\n      // and add a few rows...\n\n      /* It is recommended to use PreparedStatements when you are\n       * repeating execution of an SQL statement. PreparedStatements also\n       * allows you to parameterize variables. By using PreparedStatements\n       * you may increase performance (because the Derby engine does not\n       * have to recompile the SQL statement each time it is executed) and\n       * improve security (because of Java type checking).\n       */\n      // parameter 1 is num (int), parameter 2 is addr (varchar)\n      psInsert = conn.prepareStatement(\"insert into location values (?, ?)\");\n      statements.add(psInsert);\n\n      psInsert.setInt(1, 1956);\n      psInsert.setString(2, \"Webster St.\");\n      psInsert.executeUpdate();\n      System.out.println(\"Inserted 1956 Webster\");\n\n      psInsert.setInt(1, 1910);\n      psInsert.setString(2, \"Union St.\");\n      psInsert.executeUpdate();\n      System.out.println(\"Inserted 1910 Union\");\n\n      // Let's update some rows as well...\n\n      // parameter 1 and 3 are num (int), parameter 2 is addr (varchar)\n      psUpdate = conn.prepareStatement(\"update location set num=?, addr=? where num=?\");\n      statements.add(psUpdate);\n\n      psUpdate.setInt(1, 180);\n      psUpdate.setString(2, \"Grand Ave.\");\n      psUpdate.setInt(3, 1956);\n      psUpdate.executeUpdate();\n      System.out.println(\"Updated 1956 Webster to 180 Grand\");\n\n      psUpdate.setInt(1, 300);\n      psUpdate.setString(2, \"Lakeshore Ave.\");\n      psUpdate.setInt(3, 180);\n      psUpdate.executeUpdate();\n      System.out.println(\"Updated 180 Grand to 300 Lakeshore\");\n\n      /*\n      We select the rows and verify the results.\n      */\n      rs = s.executeQuery(\"SELECT num, addr FROM location ORDER BY num\");\n\n      /* we expect the first returned column to be an integer (num),\n       * and second to be a String (addr). Rows are sorted by street\n       * number (num).\n       *\n       * Normally, it is best to use a pattern of\n       * while(rs.next()) {\n       * // do something with the result set\n       * }\n       * to process all returned rows, but we are only expecting two rows\n       * this time, and want the verification code to be easy to\n       * comprehend, so we use a different pattern.\n       */\n\n      int number; // street number retrieved from the database\n      boolean failure = false;\n      if (!rs.next()) {\n        failure = true;\n        reportFailure(\"No rows in ResultSet\");\n      }\n\n      if ((number = rs.getInt(1)) != 300) {\n        failure = true;\n        reportFailure(\"Wrong row returned, expected num=300, got \" + number);\n      }\n\n      if (!rs.next()) {\n        failure = true;\n        reportFailure(\"Too few rows\");\n      }\n\n      if ((number = rs.getInt(1)) != 1910) {\n        failure = true;\n        reportFailure(\"Wrong row returned, expected num=1910, got \" + number);\n      }\n\n      if (rs.next()) {\n        failure = true;\n        reportFailure(\"Too many rows\");\n      }\n\n      if (!failure) {\n        System.out.println(\"Verified the rows\");\n      }\n\n      // delete the table\n      s.execute(\"drop table location\");\n      System.out.println(\"Dropped table location\");\n\n      /*\n      We commit the transaction. Any changes will be persisted to\n      the database now.\n      */\n      conn.commit();\n      System.out.println(\"Committed the transaction\");\n\n      /*\n       * In embedded mode, an application should shut down the database.\n       * If the application fails to shut down the database,\n       * Derby will not perform a checkpoint when the JVM shuts down.\n       * This means that it will take longer to boot (connect to) the\n       * database the next time, because Derby needs to perform a recovery\n       * operation.\n       *\n       * It is also possible to shut down the Derby system/engine, which\n       * automatically shuts down all booted databases.\n       *\n       * Explicitly shutting down the database or the Derby engine with\n       * the connection URL is preferred. This style of shutdown will\n       * always throw an SQLException.\n       *\n       * Not shutting down when in a client environment, see method\n       * Javadoc.\n       */\n\n      if (framework.equals(\"embedded\")) {\n        try {\n          // the shutdown=true attribute shuts down Derby\n          DriverManager.getConnection(\"jdbc:derby:;shutdown=true\");\n\n          // To shut down a specific database only, but keep the\n          // engine running (for example for connecting to other\n          // databases), specify a database in the connection URL:\n          // DriverManager.getConnection(\"jdbc:derby:\" + dbName + \";shutdown=true\");\n        } catch (SQLException se) {\n          if (((se.getErrorCode() == 50000) && (\"XJ015\".equals(se.getSQLState())))) {\n            // we got the expected exception\n            System.out.println(\"Derby shut down normally\");\n            // Note that for single database shutdown, the expected\n            // SQL state is \"08006\", and the error code is 45000.\n          } else {\n            // if the error code or SQLState is different, we have\n            // an unexpected exception (shutdown failed)\n            System.err.println(\"Derby did not shut down normally\");\n            printSQLException(se);\n          }\n        }\n      }\n    } catch (SQLException sqle) {\n      printSQLException(sqle);\n    } finally {\n      // release all open resources to avoid unnecessary memory usage\n\n      // ResultSet\n      try {\n        if (rs != null) {\n          rs.close();\n          rs = null;\n        }\n      } catch (SQLException sqle) {\n        printSQLException(sqle);\n      }\n\n      // Statements and PreparedStatements\n      int i = 0;\n      while (!statements.isEmpty()) {\n        // PreparedStatement extend Statement\n        Statement st = (Statement) statements.remove(i);\n        try {\n          if (st != null) {\n            st.close();\n            st = null;\n          }\n        } catch (SQLException sqle) {\n          printSQLException(sqle);\n        }\n      }\n\n      // Connection\n      try {\n        if (conn != null) {\n          conn.close();\n          conn = null;\n        }\n      } catch (SQLException sqle) {\n        printSQLException(sqle);\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6259, "initialization": ["String x = Matcher.group(int)"], "initializationStart": [740], "initializationEnd": [763], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 525, "tryExpressionEnd": 529, "tryBlockStart": 525, "tryBlockEnd": 1176, "catchExpressionStart": 1096, "catchExpressionEnd": 1116, "catchBlockStart": 1096, "catchBlockEnd": 1176, "exceptionHandlingCallStart": [1124], "exceptionHandlingCallEnd": [1169], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 863, "focalAPIEnd": 897, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setLong(int,long)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)"], "useStart": [905, 972, 1040], "useEnd": [964, 1032, 1069], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.3.3/kernel-impl/src/main/java/org/sakaiproject/content/impl/serialize/impl/conversion/FileSizeResourcesConversionHandler.java", "rawCode": "  public boolean convertSource(String id, Object source, PreparedStatement updateRecord)\n      throws SQLException {\n\n    String xml = (String) source;\n\n    SAXSerializableResourceAccess sax = new SAXSerializableResourceAccess();\n    try {\n      sax.parse(xml);\n    } catch (Exception e1) {\n      log.warn(\"Failed to parse \" + id + \"[\" + xml + \"]\", e1);\n      return false;\n    }\n\n    Type1BaseContentResourceSerializer t1b = new Type1BaseContentResourceSerializer();\n    t1b.setTimeService(new ConversionTimeService());\n    try {\n      String context = null;\n      Matcher contextMatcher = contextPattern.matcher(sax.getSerializableId());\n      if (contextMatcher.find()) {\n        String root = contextMatcher.group(1);\n        context = contextMatcher.group(2);\n        if (!root.equals(\"group/\")) {\n          context = \"~\" + context;\n        }\n      }\n\n      updateRecord.setString(1, context);\n      updateRecord.setLong(2, sax.getSerializableContentLength());\n      updateRecord.setString(3, sax.getSerializableResourceType());\n      updateRecord.setString(4, id);\n      return true;\n    } catch (Exception e) {\n      log.warn(\"Failed to process record \" + id, e);\n    }\n    return false;\n  }\n"}, {"dataset": "setString", "exampleID": 6260, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [487], "initializationEnd": [514], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["new StringBuilder()", "append(String)", "append(*)", "toString()", "println(*)"], "tryExpressionStart": 84, "tryExpressionEnd": 88, "tryBlockStart": 84, "tryBlockEnd": 1004, "catchExpressionStart": 833, "catchExpressionEnd": 856, "catchBlockStart": 833, "catchBlockEnd": 1004, "exceptionHandlingCallStart": [895, 894, 894, 894, 864], "exceptionHandlingCallEnd": [914, 959, 969, 980, 981], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 522, "focalAPIEnd": 540, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.setInt(int,int)", "preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [573, 610, 673, 780], "useEnd": [600, 641, 690, 790], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wmchris/KrimSale/tree/master/src/de/bdh/ks/KSHelper.java", "rawCode": "  public int getOfferAmountFromPlayer(String p, ItemStack i) {\n    int ret = 0;\n    try {\n      Connection conn = Main.Database.getConnection();\n      PreparedStatement ps;\n      StringBuilder b =\n          (new StringBuilder())\n              .append(\"SELECT COUNT(*) as c FROM \")\n              .append(configManager.SQLTable)\n              .append(\"_offer WHERE player = ?\");\n      if (i != null) b.append(\" AND type = ? AND subtype = ?\");\n\n      String strg = b.toString();\n      ps = conn.prepareStatement(strg);\n      ps.setString(1, p);\n      if (i != null) {\n        ps.setInt(2, i.getTypeId());\n        ps.setInt(3, i.getDurability());\n      }\n\n      ResultSet rs = ps.executeQuery();\n\n      while (rs.next()) {\n        ret = rs.getInt(\"c\");\n      }\n\n      if (ps != null) ps.close();\n      if (rs != null) rs.close();\n\n    } catch (SQLException e) {\n      System.out.println(\n          (new StringBuilder()).append(\"[KS] unable to get offer amount: \").append(e).toString());\n      ret = -1;\n    }\n\n    return ret;\n  }\n"}, {"dataset": "setString", "exampleID": 6261, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String,*,*)"], "initializationStart": [241], "initializationEnd": [347], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["error(String)", "endQuery(boolean)"], "tryExpressionStart": 106, "tryExpressionEnd": 110, "tryBlockStart": 106, "tryBlockEnd": 627, "catchExpressionStart": 521, "catchExpressionEnd": 544, "catchBlockStart": 521, "catchBlockEnd": 627, "exceptionHandlingCallStart": [554, 598], "exceptionHandlingCallEnd": [588, 618], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 357, "focalAPIEnd": 389, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "executeUpdate(preparedStatement)"], "useStart": [399, 432], "useEnd": [422, 461], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bbcf/gdv/tree/master/src/main/java/ch/epfl/bbcf/gdv/access/database/dao/TrackDAO.java", "rawCode": "  public boolean resetParams(int id) {\n    if (this.databaseConnected()) {\n      this.startQuery();\n      try {\n        String query = \"update tracks set paramaters = ? \" + \"where id = ? ;\";\n        PreparedStatement statement =\n            this.prepareStatement(\n                query, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\n        statement.setString(1, \"params\");\n        statement.setInt(2, id);\n        this.executeUpdate(statement);\n        this.endQuery(true);\n        return true;\n      } catch (SQLException e) {\n        logger.error(\"renameTrack : \" + e);\n        this.endQuery(false);\n      }\n    }\n    return false;\n  }\n"}, {"dataset": "setString", "exampleID": 6262, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String,*,*)"], "initializationStart": [596], "initializationEnd": [708], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getClass()", "getName()", "WebSession.setMessage(String)", "printStackTrace()"], "tryExpressionStart": 239, "tryExpressionEnd": 243, "tryBlockStart": 239, "tryBlockEnd": 2035, "catchExpressionStart": 1912, "catchExpressionEnd": 1932, "catchBlockStart": 1912, "catchBlockEnd": 2035, "exceptionHandlingCallStart": [844, 844, 1940, 2009], "exceptionHandlingCallEnd": [859, 869, 2001, 2028], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 716, "focalAPIEnd": 774, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.setString(int,String)", "preparedStatement.executeQuery()"], "useStart": [782, 821, 898], "useEnd": [813, 870, 922], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/OWASP/WebGoat/tree/master/webgoat/src/main/java/org/owasp/webgoat/lessons/CSRF.java", "rawCode": "  /**\n   * Description of the Method\n   *\n   * @param s Description of the Parameter\n   * @return Description of the Return Value\n   */\n  protected Element makeCurrent(WebSession s) {\n    ElementContainer ec = new ElementContainer();\n\n    try {\n      int messageNum = s.getParser().getIntParameter(NUMBER, 0);\n\n      Connection connection =\n          DatabaseUtilities.getConnection(getNameroot(s.getUserName()), s.getWebgoatContext());\n\n      String query =\n          \"SELECT * FROM messages WHERE user_name LIKE ? and num = ? and lesson_type = ?\";\n      PreparedStatement statement =\n          connection.prepareStatement(\n              query, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\n      statement.setString(1, getNameroot(s.getUserName()) + \"%\");\n      statement.setInt(2, messageNum);\n      statement.setString(3, this.getClass().getName());\n      ResultSet results = statement.executeQuery();\n\n      if ((results != null) && results.first()) {\n        ec.addElement(new H1(\"Message Contents For: \" + results.getString(TITLE_COL)));\n        Table t = new Table(0).setCellSpacing(0).setCellPadding(0).setBorder(0);\n        TR row1 = new TR(new TD(new B(new StringElement(\"Title:\"))));\n        row1.addElement(new TD(new StringElement(results.getString(TITLE_COL))));\n        t.addElement(row1);\n\n        String messageData = results.getString(MESSAGE_COL);\n        TR row2 = new TR(new TD(new B(new StringElement(\"Message:\"))));\n        row2.addElement(new TD(new StringElement(messageData)));\n        t.addElement(row2);\n\n        TR row3 = new TR(new TD(new StringElement(\"Posted By:\")));\n        row3.addElement(new TD(new StringElement(results.getString(USER_COL))));\n        t.addElement(row3);\n\n        ec.addElement(t);\n\n      } else {\n        if (messageNum != 0) {\n          ec.addElement(new P().addElement(\"Could not find message \" + messageNum));\n        }\n      }\n\n    } catch (Exception e) {\n      s.setMessage(\"Error generating \" + this.getClass().getName());\n      e.printStackTrace();\n    }\n\n    return (ec);\n  }\n"}, {"dataset": "setString", "exampleID": 6263, "initialization": ["PreparedStatement preparedStatement = createMock(*)"], "initializationStart": [334], "initializationEnd": [377], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 537, "focalAPIEnd": 569, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [611, 769], "useEnd": [634, 785], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ddumontatibm/Landos-App/tree/master/src/test/java/com/ibm/opensocial/landos/RunServletTest.java", "rawCode": "  @Test\n  public void testDeleteRun() throws SQLException, IOException {\n    String testadmin = \"user:test\";\n    String pathInfo = \"/\" + expectedId;\n    req = TestControlUtils.mockRequest(control, attributes, source, pathInfo);\n    expect(req.getHeader(\"OPENSOCIAL-ID\")).andReturn(testadmin).once();\n\n    PreparedStatement authstmt = control.createMock(PreparedStatement.class);\n    ResultSet authres = control.createMock(ResultSet.class);\n    expect(connection.prepareStatement(anyObject(String.class))).andReturn(authstmt).once();\n    authstmt.setString(1, testadmin);\n    expectLastCall().once();\n    expect(authstmt.executeQuery()).andReturn(authres).once();\n    expect(authres.first()).andReturn(true).once();\n    authres.close();\n    expectLastCall().once();\n    authstmt.close();\n    expectLastCall().once();\n\n    PreparedStatement stmt = control.createMock(PreparedStatement.class);\n    expect(connection.prepareStatement(anyObject(String.class))).andReturn(stmt).once();\n    stmt.setInt(1, expectedId);\n    expectLastCall().once();\n    expect(stmt.executeUpdate()).andReturn(1).once();\n\n    control.replay();\n    servlet.doDelete(req, res);\n    control.verify();\n\n    assertEquals(\"Verify servlet output\", \"{\\\"id\\\":\" + expectedId + \"}\", output.toString());\n  }\n"}, {"dataset": "setString", "exampleID": 6264, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [354], "initializationEnd": [436], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 337, "tryExpressionEnd": 341, "tryBlockStart": 337, "tryBlockEnd": 739, "catchExpressionStart": 582, "catchExpressionEnd": 602, "catchBlockStart": 582, "catchBlockEnd": 636, "exceptionHandlingCallStart": [610], "exceptionHandlingCallEnd": [629], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 444, "focalAPIEnd": 477, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [485, 555, 683], "useEnd": [506, 573, 693], "hasFinally": 1, "cleanUpCall": ["PreparedStatement.close()"], "finallyExpressionStart": 637, "finallyExpressionEnd": 645, "finallyBlockStart": 637, "finallyBlockEnd": 739, "cleanUpCallStart": [683], "cleanUpCallEnd": [693], "url": "https://github.com/EsigelecPing41/Ping41/tree/master/src/dao/BonLivraisonDAO.java", "rawCode": "  /**\n   * Permet de modifier la designation\n   *\n   * @param id bon et designation à modifier\n   * @return nombre de lignes modifiées dans la table BonLivraison\n   */\n  public int modifierDesignation(int BLiv_ID, String BLiv_Designation) {\n    PreparedStatement ps = null;\n    int retour = 0;\n\n    // connexion a la base de données\n    try {\n      ps = con.prepareStatement(\"UPDATE BonLivraison SET BLiv_Designation=? WHERE BLiv_ID=?\");\n      ps.setString(1, BLiv_Designation);\n      ps.setInt(2, BLiv_ID);\n\n      // on execute la requete\n      retour = ps.executeUpdate();\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      try {\n        if (ps != null) ps.close();\n      } catch (Exception t) {\n\n      }\n    }\n    return retour;\n  }\n"}, {"dataset": "setString", "exampleID": 6265, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [282], "initializationEnd": [309], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "println(String)", "println(String)"], "tryExpressionStart": 230, "tryExpressionEnd": 234, "tryBlockStart": 230, "tryBlockEnd": 1119, "catchExpressionStart": 661, "catchExpressionEnd": 681, "catchBlockStart": 661, "catchBlockEnd": 1000, "exceptionHandlingCallStart": [727, 689, 793], "exceptionHandlingCallEnd": [741, 742, 846], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 317, "focalAPIEnd": 340, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.setString(int,String)", "preparedStatement.setDouble(int,double)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()"], "useStart": [348, 397, 473, 528, 580, 611], "useEnd": [389, 465, 520, 572, 603, 632], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RguezMario/src/tree/master/SQL/GuardarSQL.java", "rawCode": "  public boolean Guardar_fuente_sodas_rh(Obj_fuente_sodas_rh fuentesodasrh) {\n    String query = \"exec sp_insert_fuent_soda_rh ?,?,?,?,?,?\";\n    Connection con = new Connexion().conexion();\n    PreparedStatement pstmt = null;\n    try {\n      con.setAutoCommit(false);\n      pstmt = con.prepareStatement(query);\n      pstmt.setString(1, \"0\");\n      pstmt.setInt(2, fuentesodasrh.getFolio());\n      pstmt.setString(3, fuentesodasrh.getNombre_Completo().toUpperCase());\n      pstmt.setDouble(4, fuentesodasrh.getCantidad());\n      pstmt.setString(5, fuentesodasrh.getFecha());\n      pstmt.setString(6, \"1\");\n      pstmt.executeUpdate();\n      con.commit();\n\n    } catch (Exception e) {\n      System.out.println(\"SQLException: \" + e.getMessage());\n      if (con != null) {\n        try {\n          System.out.println(\"La transacción ha sido abortada\");\n          con.rollback();\n        } catch (SQLException ex) {\n          System.out.println(ex.getMessage());\n        }\n      }\n      return false;\n    } finally {\n      try {\n        con.close();\n      } catch (SQLException e) {\n        e.printStackTrace();\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "setString", "exampleID": 6266, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["Log.warn(String)"], "tryExpressionStart": 157, "tryExpressionEnd": 161, "tryBlockStart": 157, "tryBlockEnd": 634, "catchExpressionStart": 369, "catchExpressionEnd": 392, "catchBlockStart": 369, "catchBlockEnd": 634, "exceptionHandlingCallStart": [402], "exceptionHandlingCallEnd": [625], "configuration": ["preparedStatement.clearParameters()"], "configurationStart": [171], "configurationEnd": [200], "guardCondition": "preparedStatement!=null", "guardType": "IF {", "guardExpressionStart": 124, "guardExpressionEnd": 148, "guardBlockStart": 124, "guardBlockEnd": 640, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 210, "focalAPIEnd": 238, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.execute()"], "useStart": [248, 291, 338], "useEnd": [281, 328, 359], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.3.0-b03/kernel-storage-util/src/main/java/org/sakaiproject/util/conversion/SchemaConversionController.java", "rawCode": "  private void insertErrorReport(\n      PreparedStatement reportError, String id, String handler, String description) {\n    if (reportError != null) {\n      try {\n        reportError.clearParameters();\n        reportError.setString(1, id);\n        reportError.setString(2, handler);\n        reportError.setString(3, description);\n        reportError.execute();\n      } catch (SQLException e) {\n        log.warn(\n            \"Unable to insert error report [\"\n                + id\n                + \" \"\n                + handler\n                + \" \\\"\"\n                + description\n                + \"\\\" \"\n                + e);\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6267, "initialization": ["PreparedStatement preparedStatement = getPreparedStatement(String)"], "initializationStart": [237], "initializationEnd": [265], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "getStackTrace(*)", "fail(*)"], "tryExpressionStart": 85, "tryExpressionEnd": 89, "tryBlockStart": 85, "tryBlockEnd": 2979, "catchExpressionStart": 2884, "catchExpressionEnd": 2904, "catchBlockStart": 2884, "catchBlockEnd": 2979, "exceptionHandlingCallStart": [2917, 2955, 2912], "exceptionHandlingCallEnd": [2931, 2971, 2972], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 275, "focalAPIEnd": 314, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.executeUpdate()", "preparedStatement.close()", "preparedStatement.setString(int,String)", "preparedStatement.setInt(int,int)", "preparedStatement.executeUpdate()", "preparedStatement.close()", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [324, 351, 381, 562, 611, 638, 668, 1239, 1286, 1354, 2403], "useEnd": [341, 371, 393, 601, 628, 658, 680, 1278, 1325, 1373, 2415], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/p6spy/p6spy/tree/master/src/test/java/com/p6spy/engine/spy/P6TestPreparedStatement.java", "rawCode": "  @Test\n  public void testSameColumnNameInMultipleTables() throws SQLException {\n    try {\n      // insert test data\n      {\n        final String update = \"insert into prepstmt_test values (?, ?)\";\n        final PreparedStatement prep = getPreparedStatement(update);\n        prep.setString(1, \"prepstmt_test_col1\");\n        prep.setInt(2, 1);\n        prep.executeUpdate();\n        prep.close();\n      }\n      {\n        final String update = \"insert into prepstmt_test2 values (?, ?)\";\n        final PreparedStatement prep = getPreparedStatement(update);\n        prep.setString(1, \"prepstmt_test_col2\");\n        prep.setInt(2, 1);\n        prep.executeUpdate();\n        prep.close();\n      }\n\n      super.clearLogEntries();\n\n      // let's check that returned data are reported correctly\n      // => don't filter 'result' and 'resultset'\n      P6LogOptions.getActiveInstance().setExcludecategories(\"\");\n\n      final String query =\n          \"select prepstmt_test.col1, prepstmt_test2.col1, prepstmt_test.col2, prepstmt_test2.col2 from prepstmt_test, prepstmt_test2 where prepstmt_test.col2 = prepstmt_test2.col2 and prepstmt_test.col1 = ? and prepstmt_test2.col1 = ?\";\n      final PreparedStatement prep = getPreparedStatement(query);\n      prep.setString(1, \"prepstmt_test_col1\");\n      prep.setString(2, \"prepstmt_test_col2\");\n      final ResultSet rs = prep.executeQuery();\n\n      // check \"statement\" logged properly\n      assertNotNull(super.getLastLogEntry());\n      assertTrue(\n          \"prepared statement not logged properly\", super.getLastLogEntry().contains(\"statement\"));\n      assertTrue(\"prepared statement not logged properly\", super.getLastLogEntry().contains(query));\n      assertTrue(\n          \"prepared statement not logged properly\",\n          super.getLastLogEntry()\n              .contains(\n                  query\n                      .replaceFirst(\"\\\\?\", \"\\'prepstmt_test_col1\\'\")\n                      .replaceFirst(\"\\\\?\", \"\\'prepstmt_test_col2\\'\")));\n\n      // check returned (real) data not messed up\n      while (rs.next()) {\n        assertEquals(\"returned values messed up\", \"prepstmt_test_col1\", rs.getString(1));\n        assertEquals(\"returned values messed up\", \"prepstmt_test_col2\", rs.getString(2));\n        assertEquals(\"returned values messed up\", 1, rs.getInt(3));\n        assertEquals(\"returned values messed up\", 1, rs.getInt(4));\n      }\n      rs.close();\n      prep.close();\n\n      // check \"resultset\" logged properly\n      assertNotNull(super.getLastLogEntry());\n      assertTrue(\"resultset not logged\", super.getLastLogEntry().contains(\"resultset\"));\n      assertTrue(\n          \"logged resultset holds incorrect values\",\n          super.getLastLogEntry()\n              .endsWith(\"1 = 'prepstmt_test_col1', 2 = 'prepstmt_test_col2', 3 = 1, 4 = 1\"));\n\n      P6LogOptions.getActiveInstance().setExcludecategories(\"result,resultset\");\n\n    } catch (Exception e) {\n      fail(e.getMessage() + \" due to error:\\n\" + getStackTrace(e));\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6268, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [425], "initializationEnd": [469], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 517, "focalAPIEnd": 549, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setLong(int,long)", "preparedStatement.addBatch()"], "useStart": [557, 597], "useEnd": [589, 617], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dCache/dcache/tree/master/modules/srm-server/src/main/java/org/dcache/srm/request/sql/PutRequestStorage.java", "rawCode": "  @Override\n  public PreparedStatement getBatchCreateStatement(Connection connection, Job job)\n      throws SQLException {\n    if (job == null || !(job instanceof PutRequest)) {\n      throw new IllegalArgumentException(\"Request is not PutRequest\");\n    }\n    PutRequest pr = (PutRequest) job;\n    String[] protocols = pr.getProtocols();\n    if (protocols == null) {\n      return null;\n    }\n    PreparedStatement statement = connection.prepareStatement(insertProtocols);\n    for (String protocol : protocols) {\n      statement.setString(1, protocol);\n      statement.setLong(2, pr.getId());\n      statement.addBatch();\n    }\n    return statement;\n  }\n"}, {"dataset": "setString", "exampleID": 6269, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [322], "initializationEnd": [349], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "println(String)", "println(String)"], "tryExpressionStart": 270, "tryExpressionEnd": 274, "tryBlockStart": 270, "tryBlockEnd": 1031, "catchExpressionStart": 573, "catchExpressionEnd": 593, "catchBlockStart": 573, "catchBlockEnd": 912, "exceptionHandlingCallStart": [639, 601, 705], "exceptionHandlingCallEnd": [653, 654, 758], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 357, "focalAPIEnd": 410, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setFloat(int,float)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()"], "useStart": [418, 463, 524], "useEnd": [455, 516, 545], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RguezMario/src/tree/master/SQL/GuardarSQL.java", "rawCode": "  public boolean Guardar_Divisas(Obj_Divisa_Y_TipoDeCambio divisas) {\n    String query =\n        \"insert into tb_divisas_tipo_de_cambio(nombre_divisas,valor,status) values(?,?,?)\";\n    Connection con = new Connexion().conexion();\n    PreparedStatement pstmt = null;\n    try {\n      con.setAutoCommit(false);\n      pstmt = con.prepareStatement(query);\n      pstmt.setString(1, divisas.getNombre().toUpperCase());\n      pstmt.setFloat(2, divisas.getValor());\n      pstmt.setString(3, (divisas.getStatus()) ? \"1\" : \"0\");\n      pstmt.executeUpdate();\n      con.commit();\n    } catch (Exception e) {\n      System.out.println(\"SQLException: \" + e.getMessage());\n      if (con != null) {\n        try {\n          System.out.println(\"La transacción ha sido abortada\");\n          con.rollback();\n        } catch (SQLException ex) {\n          System.out.println(ex.getMessage());\n        }\n      }\n      return false;\n    } finally {\n      try {\n        con.close();\n      } catch (SQLException e) {\n        e.printStackTrace();\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "setString", "exampleID": 6270, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["error(String,*)"], "tryExpressionStart": 104, "tryExpressionEnd": 108, "tryBlockStart": 104, "tryBlockEnd": 383, "catchExpressionStart": 279, "catchExpressionEnd": 302, "catchBlockStart": 279, "catchBlockEnd": 383, "exceptionHandlingCallStart": [310], "exceptionHandlingCallEnd": [376], "configuration": ["preparedStatement.clearParameters()"], "configurationStart": [116], "configurationEnd": [161], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 169, "focalAPIEnd": 220, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()"], "useStart": [228], "useEnd": [271], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/kernel-1.0.x/kernel-impl-experimental/content/migration/sakai-content-jcr-migration-impl/src/main/java/org/sakaiproject/content/migration/CHStoJCRMigratorImpl.java", "rawCode": "  private void markContentItemFinished(String contentId) {\n    if (!jcrService.isEnabled()) return;\n    try {\n      finishItemPreparedStatement.clearParameters();\n      finishItemPreparedStatement.setString(1, contentId);\n      finishItemPreparedStatement.executeUpdate();\n    } catch (SQLException e) {\n      log.error(\"Error marking the migration content item finished.\", e);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6271, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [494], "initializationEnd": [535], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 541, "focalAPIEnd": 569, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [575, 602], "useEnd": [596, 615], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CompendiumNG/CompendiumNG/tree/master/src/main/java/com/compendium/core/db/DBMovies.java", "rawCode": "  /**\n   * Delete a Movies record (and its associated MovieProperty Records - CASCADE DELETE)\n   *\n   * @param dbcon the DBConnection object to access the database with.\n   * @param sMovieID the id of the record to delete.\n   * @throws java.sql.SQLException\n   */\n  public static void delete(DBConnection dbcon, String sMovieID) throws SQLException {\n\n    Connection con = dbcon.getConnection();\n    if (con == null) throw new SQLException(\"Connection is null\");\n\n    PreparedStatement pstmt = con.prepareStatement(DELETE_MOVIES_QUERY);\n    pstmt.setString(1, sMovieID);\n    pstmt.executeUpdate();\n    pstmt.close();\n  }\n"}, {"dataset": "setString", "exampleID": 6272, "initialization": ["PreparedStatement preparedStatement = prepareStatement(*)"], "initializationStart": [661], "initializationEnd": [703], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["print(String)"], "tryExpressionStart": 160, "tryExpressionEnd": 164, "tryBlockStart": 160, "tryBlockEnd": 1890, "catchExpressionStart": 1697, "catchExpressionEnd": 1721, "catchBlockStart": 1697, "catchBlockEnd": 1789, "exceptionHandlingCallStart": [1729], "exceptionHandlingCallEnd": [1782], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 711, "focalAPIEnd": 740, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setInt(int,int)", "preparedStatement.setDate(int,Date)", "preparedStatement.setInt(int,int)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.setDate(int,Date)", "preparedStatement.setBlob(int,Blob)", "preparedStatement.executeUpdate()", "closeStatement(preparedStatement)"], "useStart": [748, 803, 857, 913, 962, 1018, 1070, 1122, 1174, 1227, 1287, 1337, 1394, 1446, 1498, 1560, 1846], "useEnd": [795, 849, 905, 954, 1010, 1062, 1114, 1166, 1219, 1279, 1329, 1386, 1438, 1490, 1540, 1586, 1883], "hasFinally": 1, "cleanUpCall": ["closeConnection(Connection)", "closeStatement(PreparedStatement)"], "finallyExpressionStart": 1790, "finallyExpressionEnd": 1798, "finallyBlockStart": 1790, "finallyBlockEnd": 1890, "cleanUpCallStart": [1806, 1846], "cleanUpCallEnd": [1838, 1883], "url": "https://github.com/LastRide/netCracker-maven/tree/master/WayToNetCracker-ejb/src/main/java/netcracker/dao/StudentDAOImpl.java", "rawCode": "  @Override\n  public boolean createStudent(Student student) {\n    PreparedStatement stmtInsert = null;\n    Connection conn = DAOFactory.createConnection();\n    try {\n      StringBuffer sbInsert = new StringBuffer();\n      sbInsert.append(\"INSERT INTO \");\n      sbInsert.append(DAOConstants.StudentsTableName);\n      sbInsert.append(\n          \" (id_student, first_name, last_name, middle_name, course, study_end_year, id_faculty, \"\n              + \"email1, email2, phone1, extra_contacts, why, experience, extra, reg_day, photo)\");\n      sbInsert.append(\" VALUES (\");\n      sbInsert.append(\"?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n      stmtInsert = conn.prepareStatement(sbInsert.toString());\n      stmtInsert.setString(1, null);\n      stmtInsert.setString(2, student.getFirstName());\n      stmtInsert.setString(3, student.getLastName());\n      stmtInsert.setString(4, student.getMiddleName());\n      stmtInsert.setInt(5, student.getCourse());\n      stmtInsert.setDate(6, student.getStudyEndYear());\n      stmtInsert.setInt(7, student.getIdFaculty());\n      stmtInsert.setString(8, student.getEmail1());\n      stmtInsert.setString(9, student.getEmail2());\n      stmtInsert.setString(10, student.getPhone1());\n      stmtInsert.setString(11, student.getExtraContacts());\n      stmtInsert.setString(12, student.getWhy());\n      stmtInsert.setString(13, student.getExperience());\n      stmtInsert.setString(14, student.getExtra());\n      stmtInsert.setDate(15, student.getRegDate());\n      stmtInsert.setBlob(16, student.getPhoto());\n\n      int rows = stmtInsert.executeUpdate();\n      if (rows != 1) {\n        throw new SQLException(\"executeUpdate return value: \" + rows);\n      }\n\n    } catch (SQLException ex) {\n      System.out.print(\"\\nSQL exception in create student\");\n    } finally {\n      DAOFactory.closeConnection(conn);\n      DAOFactory.closeStatement(stmtInsert);\n    }\n    return true;\n  }\n"}, {"dataset": "setString", "exampleID": 6273, "initialization": ["String x = String.toUpperCase()", "String x = trim()", "PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [194, 333, 596], "initializationEnd": [212, 358, 628], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["new FxCreateException(Log,*,String,String)"], "tryExpressionStart": 538, "tryExpressionEnd": 542, "tryBlockStart": 538, "tryBlockEnd": 1074, "catchExpressionStart": 878, "catchExpressionEnd": 903, "catchBlockStart": 878, "catchBlockEnd": 991, "exceptionHandlingCallStart": [917], "exceptionHandlingCallEnd": [984], "configuration": ["x.toUpperCase()", "preparedStatement.setLong(int,long)"], "configurationStart": [333, 636], "configurationEnd": [351, 662], "guardCondition": "!(sequencerExists(x,)) && !(StringUtils.isEmpty(x,)||x.toUpperCase().trim().startsWith(\"SYS_\",))", "guardType": "IF {", "guardExpressionStart": 161, "guardExpressionEnd": 239, "guardBlockStart": 161, "guardBlockEnd": 321, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 670, "focalAPIEnd": 691, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setBoolean(int,boolean)", "preparedStatement.executeUpdate()", "closeObjects(*,Connection,preparedStatement)"], "useStart": [699, 738, 1008], "useEnd": [730, 756, 1067], "hasFinally": 1, "cleanUpCall": ["closeObjects(*,Connection,PreparedStatement)"], "finallyExpressionStart": 992, "finallyExpressionEnd": 1000, "finallyBlockStart": 992, "finallyBlockEnd": 1074, "cleanUpCallStart": [1008], "cleanUpCallEnd": [1067], "url": "https://github.com/svn2github/fleXive/tree/master/src/framework/storages/MySQL/java/com/flexive/core/storage/MySQL/MySQLSequencerStorage.java", "rawCode": "  /** {@inheritDoc} */\n  @Override\n  public void createSequencer(String name, boolean allowRollover, long startNumber)\n      throws FxApplicationException {\n    if (StringUtils.isEmpty(name) || name.toUpperCase().trim().startsWith(\"SYS_\"))\n      throw new FxCreateException(LOG, \"ex.sequencer.create.invalid.name\", name);\n    name = name.toUpperCase().trim();\n    if (sequencerExists(name))\n      throw new FxCreateException(LOG, \"ex.sequencer.create.invalid.name\", name);\n\n    Connection con = null;\n    PreparedStatement ps = null;\n    try {\n      con = Database.getDbConnection();\n\n      ps = con.prepareStatement(SQL_CREATE);\n      ps.setLong(1, startNumber);\n      ps.setString(2, name);\n      ps.setBoolean(3, allowRollover);\n      ps.executeUpdate();\n      if (ps.getUpdateCount() == 0)\n        throw new FxCreateException(LOG, \"ex.sequencer.create.failed\", name);\n    } catch (SQLException exc) {\n      throw new FxCreateException(LOG, exc, \"ex.sequencer.create.failed\", name);\n    } finally {\n      Database.closeObjects(MySQLSequencerStorage.class, con, ps);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6274, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [151], "initializationEnd": [172], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "Logger.error(String)"], "tryExpressionStart": 61, "tryExpressionEnd": 65, "tryBlockStart": 61, "tryBlockEnd": 476, "catchExpressionStart": 358, "catchExpressionEnd": 378, "catchBlockStart": 358, "catchBlockEnd": 476, "exceptionHandlingCallStart": [434, 386], "exceptionHandlingCallEnd": [448, 449], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 180, "focalAPIEnd": 199, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()"], "useStart": [207, 245], "useEnd": [227, 262], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/VirginiaFIRST/frc2013score/tree/master/src/main/java/FRC_Score_Sys/SqlDB.java", "rawCode": "  public boolean UpdateOption(String Name, String Val) {\n    try {\n      String q = \"UPDATE OPTIONS SET VAL=? WHERE ID=?\";\n      PreparedStatement s = c.prepareStatement(q);\n      s.setString(1, Val);\n      s.setString(2, Name);\n      int cre = s.executeUpdate();\n      if (cre != 1) {\n        return false;\n      } else {\n        return true;\n      }\n    } catch (Exception e) {\n      logger.error(\"Update Option threw exception \" + e.getMessage());\n      return false;\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6275, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [967], "initializationEnd": [1046], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1052, "focalAPIEnd": 1074, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.execute()", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.execute()", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.execute()", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.execute()"], "useStart": [1080, 1108, 1136, 1555, 1583, 1612, 2496, 2524, 2552, 3167, 3195, 3223], "useEnd": [1102, 1130, 1150, 1577, 1606, 1626, 2518, 2546, 2566, 3189, 3217, 3237], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/forcedotcom/phoenix/tree/master/phoenix-core/src/test/java/com/salesforce/phoenix/end2end/index/MutableIndexTest.java", "rawCode": "  @Test\n  public void testCoveredColumns() throws Exception {\n    String query;\n    ResultSet rs;\n\n    Properties props = new Properties(TEST_PROPERTIES);\n    Connection conn = DriverManager.getConnection(getUrl(), props);\n    conn.setAutoCommit(false);\n    conn.createStatement()\n        .execute(\n            \"CREATE TABLE \"\n                + DATA_TABLE_FULL_NAME\n                + \" (k VARCHAR NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\");\n    query = \"SELECT * FROM \" + DATA_TABLE_FULL_NAME;\n    rs = conn.createStatement().executeQuery(query);\n    assertFalse(rs.next());\n\n    conn.createStatement()\n        .execute(\n            \"CREATE INDEX \"\n                + INDEX_TABLE_NAME\n                + \" ON \"\n                + DATA_TABLE_FULL_NAME\n                + \" (v1) INCLUDE (v2)\");\n    query = \"SELECT * FROM \" + INDEX_TABLE_FULL_NAME;\n    rs = conn.createStatement().executeQuery(query);\n    assertFalse(rs.next());\n\n    PreparedStatement stmt =\n        conn.prepareStatement(\"UPSERT INTO \" + DATA_TABLE_FULL_NAME + \" VALUES(?,?,?)\");\n    stmt.setString(1, \"a\");\n    stmt.setString(2, \"x\");\n    stmt.setString(3, \"1\");\n    stmt.execute();\n    conn.commit();\n\n    query = \"SELECT * FROM \" + INDEX_TABLE_FULL_NAME;\n    rs = conn.createStatement().executeQuery(query);\n    assertTrue(rs.next());\n    assertEquals(\"x\", rs.getString(1));\n    assertEquals(\"a\", rs.getString(2));\n    assertEquals(\"1\", rs.getString(3));\n    assertFalse(rs.next());\n\n    stmt = conn.prepareStatement(\"UPSERT INTO \" + DATA_TABLE_FULL_NAME + \"(k,v2) VALUES(?,?)\");\n    stmt.setString(1, \"a\");\n    stmt.setString(2, null);\n    stmt.execute();\n    conn.commit();\n\n    query = \"SELECT * FROM \" + INDEX_TABLE_FULL_NAME;\n    rs = conn.createStatement().executeQuery(query);\n    assertTrue(rs.next());\n    assertEquals(\"x\", rs.getString(1));\n    assertEquals(\"a\", rs.getString(2));\n    assertNull(rs.getString(3));\n    assertFalse(rs.next());\n\n    query = \"SELECT * FROM \" + DATA_TABLE_FULL_NAME;\n    rs = conn.createStatement().executeQuery(\"EXPLAIN \" + query);\n    assertEquals(\n        \"CLIENT PARALLEL 1-WAY FULL SCAN OVER \" + INDEX_TABLE_FULL_NAME,\n        QueryUtil.getExplainPlan(rs));\n\n    rs = conn.createStatement().executeQuery(query);\n    assertTrue(rs.next());\n    assertEquals(\"a\", rs.getString(1));\n    assertEquals(\"x\", rs.getString(2));\n    assertNull(rs.getString(3));\n    assertFalse(rs.next());\n\n    stmt = conn.prepareStatement(\"UPSERT INTO \" + DATA_TABLE_FULL_NAME + \"(k,v2) VALUES(?,?)\");\n    stmt.setString(1, \"a\");\n    stmt.setString(2, \"3\");\n    stmt.execute();\n    conn.commit();\n\n    query = \"SELECT * FROM \" + DATA_TABLE_FULL_NAME;\n    rs = conn.createStatement().executeQuery(\"EXPLAIN \" + query);\n    assertEquals(\n        \"CLIENT PARALLEL 1-WAY FULL SCAN OVER \" + INDEX_TABLE_FULL_NAME,\n        QueryUtil.getExplainPlan(rs));\n\n    rs = conn.createStatement().executeQuery(query);\n    assertTrue(rs.next());\n    assertEquals(\"a\", rs.getString(1));\n    assertEquals(\"x\", rs.getString(2));\n    assertEquals(\"3\", rs.getString(3));\n    assertFalse(rs.next());\n\n    stmt = conn.prepareStatement(\"UPSERT INTO \" + DATA_TABLE_FULL_NAME + \"(k,v2) VALUES(?,?)\");\n    stmt.setString(1, \"a\");\n    stmt.setString(2, \"4\");\n    stmt.execute();\n    conn.commit();\n\n    query = \"SELECT * FROM \" + DATA_TABLE_FULL_NAME;\n    rs = conn.createStatement().executeQuery(\"EXPLAIN \" + query);\n    assertEquals(\n        \"CLIENT PARALLEL 1-WAY FULL SCAN OVER \" + INDEX_TABLE_FULL_NAME,\n        QueryUtil.getExplainPlan(rs));\n\n    rs = conn.createStatement().executeQuery(query);\n    assertTrue(rs.next());\n    assertEquals(\"a\", rs.getString(1));\n    assertEquals(\"x\", rs.getString(2));\n    assertEquals(\"4\", rs.getString(3));\n    assertFalse(rs.next());\n  }\n"}, {"dataset": "setString", "exampleID": 6276, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String)"], "initializationStart": [470], "initializationEnd": [539], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 547, "focalAPIEnd": 587, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.setInt(int,int)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()"], "useStart": [595, 647, 707, 751], "useEnd": [639, 699, 743, 774], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Yann-Pravo/UVSP/tree/master/src/persistance/CoursDAO.java", "rawCode": "  /**\n   * MŽthode qui exŽcute une requte d'ajout d'une nouvelle matire dans la base de donnŽes. Cette\n   * mŽthode redŽfinit la mŽthode create(T obj) de la superclasse DAO.\n   *\n   * @exception SQLException\n   * @param c Objet Cours qui doit tre mappŽ dans la base\n   * @return Boolean - Vrai si l'insertion s'est dŽroulŽe correctement, Faux sinon\n   */\n  public boolean create(Cours c) {\n    boolean ok = true;\n    try {\n      PreparedStatement prepare =\n          this.connect.prepareStatement(\"INSERT INTO COURS VALUES(?, ?, ?, ?)\");\n      prepare.setString(1, \"seqCours.nextval\");\n      prepare.setInt(2, c.getMatiere().getIdMat());\n      prepare.setInt(3, c.getTypeCours().getIdTypeCours());\n      prepare.setString(4, c.getLibelle());\n      prepare.executeUpdate();\n    } catch (SQLException e) {\n      ok = false;\n    }\n    return ok;\n  }\n"}, {"dataset": "setString", "exampleID": 6277, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [399], "initializationEnd": [438], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 338, "tryExpressionEnd": 342, "tryBlockStart": 338, "tryBlockEnd": 889, "catchExpressionStart": 608, "catchExpressionEnd": 631, "catchBlockStart": 608, "catchBlockEnd": 665, "exceptionHandlingCallStart": [639], "exceptionHandlingCallEnd": [658], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 446, "focalAPIEnd": 470, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [478, 520, 716], "useEnd": [503, 540, 730], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 666, "finallyExpressionEnd": 674, "finallyBlockStart": 666, "finallyBlockEnd": 889, "cleanUpCallStart": [716], "cleanUpCallEnd": [730], "url": "https://github.com/sonyfe25cp/EventsMachine/tree/master/gossip/src/main/java/gossip/dao/UserDAO.java", "rawCode": "  /**\n   * 验证用户属性的存在性\n   *\n   * @param name 需要验证的属性，格式如：USERDAO.EMAIL\n   * @param userPropertyValue 需要在数据库内验证是否存在的属性值\n   * @return 用户属性是否存在\n   */\n  public Boolean verifyExistance(String type, String value) {\n    Boolean resultState = false;\n    Connection conn = null;\n    PreparedStatement pstmt = null;\n    ResultSet result = null;\n    try {\n      conn = dataSource.getConnection();\n      pstmt = conn.prepareStatement(SQL_verifyString);\n      pstmt.setString(1, type);\n      pstmt.setString(2, value);\n      result = pstmt.executeQuery();\n      resultState = (result.getInt(0) == 0 ? true : false);\n    } catch (SQLException e) {\n      e.printStackTrace();\n    } finally {\n      try {\n        if (result != null) result.close();\n        if (pstmt != null) pstmt.close();\n        if (conn != null) conn.close();\n      } catch (SQLException e) {\n        e.printStackTrace();\n      }\n    }\n    return resultState;\n  }\n"}, {"dataset": "setString", "exampleID": 6278, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [480], "initializationEnd": [505], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 443, "tryExpressionEnd": 447, "tryBlockStart": 443, "tryBlockEnd": 1377, "catchExpressionStart": 1318, "catchExpressionEnd": 1342, "catchBlockStart": 1318, "catchBlockEnd": 1377, "exceptionHandlingCallStart": [1350], "exceptionHandlingCallEnd": [1370], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 514, "focalAPIEnd": 554, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()"], "useStart": [578], "useEnd": [597], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rangelvarnier/2RSYSTEM/tree/master/2RSYSTEMRestaurante/src/RESTAURANTE/DAO/IMPL/ProdutoDAOIMPL.java", "rawCode": "  @Override\n  public List<Produto> buscarPorDescricao(String descricao) {\n    List<Produto> produtos = new ArrayList<Produto>();\n    UnidadeMedidaDAO unidadeMedidaDao = new UnidadeMedidaDAOIMPL();\n    SubGrupoItemDAO subGrupoItemDao = new SubGrupoItensDAOIMPL();\n    FornecedorDAO fornecedorDao = new FornecedorDAOIMPL();\n    Connection con = new Conexao().criarConexao();\n\n    String sql = \"select * from produto where descricao like ?\";\n    try {\n      PreparedStatement stmt = con.prepareStatement(sql);\n\n      stmt.setString(1, \"%\" + descricao + \"%\");\n\n      ResultSet rs = stmt.executeQuery();\n\n      while (rs.next()) {\n        Produto produto = new Produto();\n        produto.setCodigo(rs.getInt(\"codigo\"));\n        produto.setDescricao(rs.getString(\"descricao\"));\n        produto.setPrecoVenda(rs.getFloat(\"precoVenda\"));\n        produto.setPrecoCompra(rs.getFloat(\"precoCompra\"));\n        produto.setSaldoEstoque(rs.getFloat(\"saldoEstoque\"));\n        produto.setUnidadeMedida(\n            unidadeMedidaDao.buscarPorCodigo(rs.getInt(\"unidadeMedida_codigo\")));\n        produto.setSubGrupoItens(\n            subGrupoItemDao.buscarPorCodigo(rs.getInt(\"subGrupoItens_codigo\")));\n        produto.setFornecedor(fornecedorDao.buscaPorId(rs.getInt(\"fornecedor_codigo\")));\n        produtos.add(produto);\n      }\n\n    } catch (SQLException ex) {\n      ex.printStackTrace();\n    }\n    return produtos;\n  }\n"}, {"dataset": "setString", "exampleID": 6279, "initialization": ["String x = ResultSet.getString(String)", "String x = String.equals(String)", "PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [381, 735, 836], "initializationEnd": [407, 754, 913], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 982, "focalAPIEnd": 1008, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [1040, 1272], "useEnd": [1057, 1282], "hasFinally": 1, "cleanUpCall": ["PreparedStatement.close()"], "finallyExpressionStart": 1179, "finallyExpressionEnd": 1187, "finallyBlockStart": 1179, "finallyBlockEnd": 1233, "cleanUpCallStart": [1272], "cleanUpCallEnd": [1282], "url": "https://github.com/MiniSEC/adito_reload/tree/master/adito/branches/openvpn-als/openvpnals/tools/upgrader/src/com/openvpnals/upgrade/NetworkPlacesUpgrade.java", "rawCode": "  public void doUpgrade(Upgrader upgrader, Connection oldConx, Connection newConx)\n      throws Exception {\n    // // Auth Schemes\n    upgrader.info(\"Migrating all network places\");\n    Statement stmt = oldConx.createStatement();\n    try {\n      ResultSet rs = stmt.executeQuery(\"SELECT * FROM NETWORK_PLACES\");\n      try {\n        while (rs.next()) {\n          String shortName = rs.getString(\"SHORT_NAME\");\n          String username = rs.getString(\"username\");\n          String uri = rs.getString(\"uri\");\n          if (uri.equals(\"/fs/cifs\") || uri.equals(\"/fs/cifs/\")) {\n            upgrader.warn(\" Skipping network neighbourhood network place, no longer supported.\");\n          } else {\n            shortName = shortName + \" (\" + (username.equals(\"\") ? \"System\" : username) + \")\";\n            PreparedStatement ps =\n                newConx.prepareStatement(\"SELECT * FROM NETWORK_PLACES WHERE SHORT_NAME = ?\");\n            boolean found = false;\n            try {\n              ps.setString(1, shortName);\n              ResultSet rs2 = ps.executeQuery();\n              try {\n                if (rs2.next()) {\n                  found = true;\n                }\n              } finally {\n                rs2.close();\n              }\n            } finally {\n              ps.close();\n            }\n\n            if (found) {\n              upgrader.warn(\" Network place '\" + shortName + \"' already exists, skipping\");\n            } else {\n              insertNetworkPlace(upgrader, newConx, uri, shortName);\n            }\n          }\n        }\n      } finally {\n        rs.close();\n      }\n    } finally {\n      stmt.close();\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6280, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["Log.warn(String)"], "tryExpressionStart": 157, "tryExpressionEnd": 161, "tryBlockStart": 157, "tryBlockEnd": 634, "catchExpressionStart": 369, "catchExpressionEnd": 392, "catchBlockStart": 369, "catchBlockEnd": 634, "exceptionHandlingCallStart": [402], "exceptionHandlingCallEnd": [625], "configuration": ["preparedStatement.clearParameters()"], "configurationStart": [171], "configurationEnd": [200], "guardCondition": "preparedStatement!=null", "guardType": "IF {", "guardExpressionStart": 124, "guardExpressionEnd": 148, "guardBlockStart": 124, "guardBlockEnd": 640, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 210, "focalAPIEnd": 238, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.execute()"], "useStart": [248, 291, 338], "useEnd": [281, 328, 359], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.13/kernel-util/src/main/java/org/sakaiproject/util/conversion/SchemaConversionController.java", "rawCode": "  private void insertErrorReport(\n      PreparedStatement reportError, String id, String handler, String description) {\n    if (reportError != null) {\n      try {\n        reportError.clearParameters();\n        reportError.setString(1, id);\n        reportError.setString(2, handler);\n        reportError.setString(3, description);\n        reportError.execute();\n      } catch (SQLException e) {\n        log.warn(\n            \"Unable to insert error report [\"\n                + id\n                + \" \"\n                + handler\n                + \" \\\"\"\n                + description\n                + \"\\\" \"\n                + e);\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6281, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [304], "initializationEnd": [331], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "println(String)", "println(String)"], "tryExpressionStart": 252, "tryExpressionEnd": 256, "tryBlockStart": 252, "tryBlockEnd": 1008, "catchExpressionStart": 550, "catchExpressionEnd": 570, "catchBlockStart": 550, "catchBlockEnd": 889, "exceptionHandlingCallStart": [616, 578, 682], "exceptionHandlingCallEnd": [630, 631, 735], "configuration": ["preparedStatement.setFloat(int,float)"], "configurationStart": [339], "configurationEnd": [372], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 380, "focalAPIEnd": 435, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()"], "useStart": [443, 501], "useEnd": [493, 522], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RguezMario/src/tree/master/SQL/ActualizarSQL.java", "rawCode": "  public boolean Bono(Obj_Bono_Complemento_Sueldo bono, int folio) {\n    String query = \"update tb_bono set bono=?, abreviatura=?, status=? where folio=\" + folio;\n    Connection con = new Connexion().conexion();\n    PreparedStatement pstmt = null;\n    try {\n      con.setAutoCommit(false);\n      pstmt = con.prepareStatement(query);\n      pstmt.setFloat(1, bono.getBono());\n      pstmt.setString(2, bono.getAbreviatura().toUpperCase());\n      pstmt.setString(3, (bono.getStatus()) ? \"1\" : \"0\");\n      pstmt.executeUpdate();\n      con.commit();\n    } catch (Exception e) {\n      System.out.println(\"SQLException: \" + e.getMessage());\n      if (con != null) {\n        try {\n          System.out.println(\"La transacción ha sido abortada\");\n          con.rollback();\n        } catch (SQLException ex) {\n          System.out.println(ex.getMessage());\n        }\n      }\n      return false;\n    } finally {\n      try {\n        con.close();\n      } catch (SQLException e) {\n        e.printStackTrace();\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "setString", "exampleID": 6282, "initialization": ["String x = new String(char[])", "PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [571, 1044], "initializationEnd": [586, 1124], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": [], "tryExpressionStart": 1020, "tryExpressionEnd": 1024, "tryBlockStart": 1020, "tryBlockEnd": 2739, "catchExpressionStart": 2543, "catchExpressionEnd": 2564, "catchBlockStart": 2543, "catchBlockEnd": 2574, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["x.toCharArray()", "preparedStatement.clearParameters()", "preparedStatement.setInt(int,int)"], "configurationStart": [607, 1132, 1167], "configurationEnd": [624, 1159, 1190], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 1198, "focalAPIEnd": 1225, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [1233, 2523], "useEnd": [1258, 2533], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 2493, "finallyExpressionEnd": 2501, "finallyBlockStart": 2493, "finallyBlockEnd": 2739, "cleanUpCallStart": [2523], "cleanUpCallEnd": [2533], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.3/kernel-util/src/main/java/org/sakaiproject/util/conversion/CheckConnection.java", "rawCode": "  public void testUTF8Transport(Connection connection) throws Exception {\n    /*\n     * byte[] b = new byte[102400]; byte[] b2 = new byte[102400]; byte[] b3 =\n     * new byte[102400]; char[] cin = new char[102400]; Random r = new\n     * Random(); r.nextBytes(b);\n     */\n    byte[] bin = new byte[102400];\n    char[] cin = new char[102400];\n    byte[] bout = new byte[102400];\n\n    {\n      int i = 0;\n      for (int bx = 0; i < bin.length; bx++) {\n        bin[i++] = (byte) bx;\n      }\n    }\n    ByteStorageConversion.toChar(bin, 0, cin, 0, cin.length);\n    String sin = new String(cin);\n\n    char[] cout = sin.toCharArray();\n    ByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n    for (int i = 0; i < bin.length; i++) {\n      if (bin[i] != bout[i]) {\n        throw new Exception(\n            \"Internal Byte conversion failed at \" + bin[i] + \"=>\" + (int) cin[i] + \"=>\" + bout[i]);\n      }\n    }\n\n    PreparedStatement statement = null;\n    PreparedStatement statement2 = null;\n    ResultSet rs = null;\n    try {\n      statement = connection.prepareStatement(\"insert into blobtest ( id, bval ) values ( ?, ? )\");\n      statement.clearParameters();\n      statement.setInt(1, 20);\n      statement.setString(2, sin);\n      statement.executeUpdate();\n\n      statement2 = connection.prepareStatement(\"select bval from blobtest where id = ? \");\n      statement2.clearParameters();\n      statement2.setInt(1, 20);\n      rs = statement2.executeQuery();\n      String sout = null;\n      if (rs.next()) {\n        sout = rs.getString(1);\n      }\n\n      if (sout == null) throw new IllegalStateException(\"String sout == null!\");\n      cout = sout.toCharArray();\n      ByteStorageConversion.toByte(cout, 0, bout, 0, cout.length);\n\n      if (sin.length() != sout.length()) {\n        throw new Exception(\n            \"UTF-8 Data was lost communicating with the database, please \"\n                + \"check connection string and default table types (Truncation/Expansion)\");\n      }\n\n      for (int i = 0; i < bin.length; i++) {\n        if (bin[i] != bout[i]) {\n          throw new Exception(\n              \"UTF-8 Data was corrupted communicating with the database, \"\n                  + \"please check connectionstring and default table types (Conversion)\"\n                  + \"\"\n                  + bin[i]\n                  + \"=>\"\n                  + (int) cin[i]\n                  + \"=>\"\n                  + bout[i]);\n        }\n      }\n\n      log.info(\"DB Connection passes UTF-8 tests\");\n\n    } finally {\n      try {\n        rs.close();\n      } catch (Exception ex) {\n\n      }\n      try {\n        statement2.close();\n      } catch (Exception ex) {\n\n      }\n      try {\n        statement.close();\n      } catch (Exception ex) {\n\n      }\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6283, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [588], "initializationEnd": [930], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["rollback(javax.ejb.SessionContext)", "getMessage()", "new FxDbException(Log,*,String,*)", "asRuntimeException()"], "tryExpressionStart": 419, "tryExpressionEnd": 423, "tryBlockStart": 419, "tryBlockEnd": 3379, "catchExpressionStart": 3141, "catchExpressionEnd": 3166, "catchBlockStart": 3141, "catchBlockEnd": 3301, "exceptionHandlingCallStart": [3174, 3256, 3210, 3210], "exceptionHandlingCallEnd": [3196, 3272, 3273, 3294], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 940, "focalAPIEnd": 978, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setLong(int,long)", "preparedStatement.setInt(int,int)", "preparedStatement.setString(int,String)", "preparedStatement.setLong(int,long)", "preparedStatement.setLong(int,long)", "preparedStatement.setLong(int,long)", "preparedStatement.setInt(int,int)", "preparedStatement.setInt(int,int)", "preparedStatement.executeQuery()", "closeObjects(*,Connection,preparedStatement)"], "useStart": [988, 1025, 1706, 1754, 1791, 1828, 1865, 1897, 1951, 3318], "useEnd": [1015, 1047, 1744, 1781, 1818, 1855, 1887, 1919, 1968, 3372], "hasFinally": 1, "cleanUpCall": ["closeObjects(*,Connection,PreparedStatement)"], "finallyExpressionStart": 3302, "finallyExpressionEnd": 3310, "finallyBlockStart": 3302, "finallyBlockEnd": 3379, "cleanUpCallStart": [3318], "cleanUpCallEnd": [3372], "url": "https://github.com/svn2github/fleXive/tree/master/src/framework/java/com/flexive/ejb/beans/PhraseEngineBean.java", "rawCode": "  /** {@inheritDoc} */\n  @Override\n  @TransactionAttribute(TransactionAttributeType.SUPPORTS)\n  public List<FxPhrase> loadPhrases(int category, String phraseKeyPrefix, long... _mandators) {\n    Connection con = null;\n    PreparedStatement ps = null;\n    checkPhraseKey(phraseKeyPrefix);\n    long[] mandators = checkMandatorFiltering(_mandators);\n\n    List<FxPhrase> result = Lists.newArrayListWithExpectedSize(50);\n    try {\n      // Obtain a database connection\n      con = Database.getDbConnection();\n      if (mandators.length == 1) {\n        // 1 2 3 4 5 6 7\n        ps =\n            con.prepareStatement(\n                \"SELECT r.ID, r.PKEY, r.MANDATOR, v.LANG, v.PVAL, v.TAG, r.HID FROM \"\n                    + TBL_PHRASE_VALUES\n                    + \" v, \"\n                    + TBL_PHRASE\n                    + \" r WHERE r.PKEY LIKE ? AND r.MANDATOR=? AND r.CAT=? AND v.ID=r.ID AND v.MANDATOR=r.MANDATOR ORDER BY r.PKEY\");\n        ps.setString(1, phraseKeyPrefix + \"%\");\n        ps.setLong(2, mandators[0]);\n        ps.setInt(3, category);\n      } else {\n        // 1 2 3 4 5 6 7\n        ps =\n            con.prepareStatement(\n                \"SELECT r.ID, r.PKEY, r.MANDATOR, v.LANG, v.PVAL, v.TAG, r.HID FROM \"\n                    + TBL_PHRASE_VALUES\n                    + \" v, \"\n                    + TBL_PHRASE\n                    +\n                    // 1 2 3 4 5\n                    \" r WHERE r.PKEY LIKE ? AND (r.MANDATOR=? OR(r.MANDATOR=? AND NOT EXISTS(SELECT r2.ID FROM FX_PHRASE r2 WHERE r2.PKEY=r.PKEY AND r2.MANDATOR=? AND r2.CAT=?)))\"\n                    +\n                    // 6\n                    \"AND r.CAT=? AND v.ID=r.ID AND v.MANDATOR=r.MANDATOR ORDER BY r.PKEY\");\n        ps.setString(1, phraseKeyPrefix + \"%\");\n        ps.setLong(2, mandators[0]);\n        ps.setLong(3, mandators[1]);\n        ps.setLong(4, mandators[0]);\n        ps.setInt(5, category);\n        ps.setInt(6, category);\n      }\n\n      ResultSet rs = ps.executeQuery();\n\n      long currId = -1L;\n      long currMandator;\n      String currKey;\n      FxPhrase currPhrase = null;\n\n      boolean ml;\n      FxString val = null;\n      Boolean hasTag = null;\n      FxString fxTag = null;\n\n      while (rs != null && rs.next()) {\n        final long lang = rs.getLong(4);\n        if (currId != rs.getLong(1)) {\n          if (currPhrase != null) result.add(currPhrase);\n          currId = rs.getLong(1);\n          currKey = rs.getString(2);\n          currMandator = rs.getLong(3);\n          ml = lang != FxLanguage.SYSTEM_ID;\n          final String tag = rs.getString(6);\n          hasTag = rs.wasNull();\n          fxTag = hasTag ? new FxString(ml, lang, tag) : new FxString(FxString.EMPTY).setEmpty();\n          val = new FxString(ml, lang, rs.getString(5));\n          currPhrase =\n              new FxPhrase(currMandator, currKey, val, fxTag)\n                  .flagCategory(category)\n                  .flagHidden(rs.getBoolean(7));\n        } else {\n          val.setTranslation(lang, rs.getString(5));\n          if (hasTag) fxTag.setTranslation(lang, rs.getString(6));\n        }\n      }\n      if (currPhrase != null) result.add(currPhrase);\n    } catch (SQLException exc) {\n      EJBUtils.rollback(ctx);\n      throw new FxDbException(LOG, exc, \"ex.db.sqlError\", exc.getMessage()).asRuntimeException();\n    } finally {\n      Database.closeObjects(PhraseEngineBean.class, con, ps);\n    }\n    return result;\n  }\n"}, {"dataset": "setString", "exampleID": 6284, "initialization": ["String x = getSpecifiedDayBefore(String)", "PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [78, 484], "initializationEnd": [105, 509], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()", "new RuntimeException(*)"], "tryExpressionStart": 311, "tryExpressionEnd": 315, "tryBlockStart": 311, "tryBlockEnd": 1684, "catchExpressionStart": 1335, "catchExpressionEnd": 1355, "catchBlockStart": 1335, "catchBlockEnd": 1426, "exceptionHandlingCallStart": [1363, 1396], "exceptionHandlingCallEnd": [1382, 1419], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 517, "focalAPIEnd": 542, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.executeQuery()", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeQuery()", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [550, 584, 841, 874, 908, 1165, 1198, 1232, 1485], "useEnd": [571, 601, 866, 895, 925, 1190, 1219, 1249, 1495], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 1427, "finallyExpressionEnd": 1435, "finallyBlockStart": 1427, "finallyBlockEnd": 1684, "cleanUpCallStart": [1485], "cleanUpCallEnd": [1495], "url": "https://github.com/ulewo/mycode/tree/master/ulewo/src/com/lhl/dao/ArticleDao.java", "rawCode": "  public Map<String, String> queryCount(String time) {\n\n    String beforDay = getSpecifiedDayBefore(time);\n    Map<String, String> map = new HashMap<String, String>();\n    ConnManage conManager = ConnManage.getInstance();\n    Connection con = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    try {\n      String sql =\n          \"select count(id) count from article where source_from = 'Q' and post_time between ? and ?\";\n      con = conManager.getConn();\n      ps = con.prepareStatement(sql);\n      ps.setString(1, beforDay);\n      ps.setString(2, time);\n      rs = ps.executeQuery();\n      if (rs.next()) {\n        map.put(\"Q\", rs.getInt(\"count\") + \"\");\n      }\n\n      sql =\n          \"select count(id) count from article where source_from = 'P' and post_time between ? and ?\";\n      ps = con.prepareStatement(sql);\n      ps.setString(1, beforDay);\n      ps.setString(2, time);\n      rs = ps.executeQuery();\n      if (rs.next()) {\n        map.put(\"P\", rs.getInt(\"count\") + \"\");\n      }\n\n      sql =\n          \"select count(id) count from article where source_from = 'H' and post_time between ? and ?\";\n      ps = con.prepareStatement(sql);\n      ps.setString(1, beforDay);\n      ps.setString(2, time);\n      rs = ps.executeQuery();\n      if (rs.next()) {\n        map.put(\"H\", rs.getInt(\"count\") + \"\");\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e);\n    } finally {\n      try {\n        if (rs != null) {\n          rs.close();\n        }\n        if (ps != null) {\n          ps.close();\n        }\n        conManager.releaseConn(con);\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return map;\n  }\n"}, {"dataset": "setString", "exampleID": 6285, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [102], "initializationEnd": [181], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 189, "focalAPIEnd": 222, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()", "preparedStatement.close()"], "useStart": [249, 354, 444], "useEnd": [268, 366, 456], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tulskiy/musique/tree/master/dependencies/last.fm-bindings/src/main/java/de/umass/lastfm/cache/DatabaseCache.java", "rawCode": "  public InputStream load(String cacheEntryName) {\n    try {\n      PreparedStatement stmt =\n          conn.prepareStatement(\"SELECT response FROM \" + TABLE_NAME + \" WHERE key = ?;\");\n      stmt.setString(1, cacheEntryName);\n      ResultSet result = stmt.executeQuery();\n      if (result.next()) {\n        String s = result.getString(\"response\");\n        stmt.close();\n        return new ByteArrayInputStream(s.getBytes(\"UTF-8\"));\n      }\n      stmt.close();\n    } catch (SQLException e) {\n      // ignore\n    } catch (UnsupportedEncodingException e) {\n      // won't happen\n    }\n    return null;\n  }\n"}, {"dataset": "setString", "exampleID": 6286, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [582], "initializationEnd": [624], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["getMessage()", "error(*,*)"], "tryExpressionStart": 513, "tryExpressionEnd": 517, "tryBlockStart": 513, "tryBlockEnd": 964, "catchExpressionStart": 818, "catchExpressionEnd": 844, "catchBlockStart": 818, "catchBlockEnd": 893, "exceptionHandlingCallStart": [862, 852], "exceptionHandlingCallEnd": [879, 886], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 632, "focalAPIEnd": 722, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.executeUpdate()", "closeConnection(preparedStatement,Connection)"], "useStart": [730, 789, 910], "useEnd": [781, 810, 957], "hasFinally": 1, "cleanUpCall": ["closeConnection(PreparedStatement,Connection)"], "finallyExpressionStart": 894, "finallyExpressionEnd": 902, "finallyBlockStart": 894, "finallyBlockEnd": 964, "cleanUpCallStart": [910], "cleanUpCallEnd": [957], "url": "https://github.com/vyloy/lnvc/tree/master/lvmc/openfire_src/src/java/org/jivesoftware/openfire/component/ExternalComponentManager.java", "rawCode": "  /**\n   * Removes any existing defined permission and configuration for the specified external component\n   * from the database.\n   *\n   * @param configuration the external component configuration to delete.\n   */\n  private static void deleteConfigurationFromDB(ExternalComponentConfiguration configuration) {\n    if (configuration == null) {\n      // Do nothing\n      return;\n    }\n    // Remove the permission for the entity from the database\n    Connection con = null;\n    PreparedStatement pstmt = null;\n    try {\n      con = DbConnectionManager.getConnection();\n      pstmt = con.prepareStatement(DELETE_CONFIGURATION);\n      pstmt.setString(1, configuration.getSubdomain() + (configuration.isWildcard() ? \"%\" : \"\"));\n      pstmt.setInt(2, configuration.isWildcard() ? 1 : 0);\n      pstmt.executeUpdate();\n    } catch (SQLException sqle) {\n      Log.error(sqle.getMessage(), sqle);\n    } finally {\n      DbConnectionManager.closeConnection(pstmt, con);\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6287, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [165], "initializationEnd": [357], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["preparedStatement.setInt(int,int)", "preparedStatement.setInt(int,int)", "preparedStatement.setInt(int,int)"], "configurationStart": [363, 399, 434], "configurationEnd": [393, 428, 464], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 470, "focalAPIEnd": 505, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [539, 580, 611], "useEnd": [574, 605, 628], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vorburger/mifos-head/tree/master/application/src/main/java/org/mifos/accounts/business/AddAccountStateFlag.java", "rawCode": "  private void addFlag(Connection connection, int newFlagId, String description, int lookupId)\n      throws SQLException {\n    PreparedStatement statement =\n        connection.prepareStatement(\n            \"insert into account_state_flag(\"\n                + \" flag_id,lookup_id,status_id,flag_description,retain_flag)\"\n                + \"values(?,?,?,?,?)\");\n    statement.setInt(1, newFlagId);\n    statement.setInt(2, lookupId);\n    statement.setInt(3, STATUS_10);\n    statement.setString(4, description);\n    boolean retain = false;\n    statement.setInt(5, retain ? 1 : 0);\n    statement.executeUpdate();\n    statement.close();\n  }\n"}, {"dataset": "setString", "exampleID": 6288, "initialization": ["PreparedStatement preparedStatement = prepareStatement(String)"], "initializationStart": [112], "initializationEnd": [182], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 188, "focalAPIEnd": 217, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setInt(int,int)", "preparedStatement.executeUpdate()"], "useStart": [223, 253], "useEnd": [247, 279], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anycook/anycook-api/tree/master/src/main/java/de/anycook/db/mysql/DBUser.java", "rawCode": "  public void changePlace(int id, String data) throws SQLException {\n    PreparedStatement pStatement =\n        connection.prepareStatement(\"UPDATE users SET place = ? WHERE id = ?\");\n    pStatement.setString(1, data);\n    pStatement.setInt(2, id);\n    pStatement.executeUpdate();\n  }\n"}, {"dataset": "setString", "exampleID": 6289, "initialization": ["PreparedStatement preparedStatement = DbConnector.getConn()", "String x = getAlarmName()"], "initializationStart": [457, 569], "initializationEnd": [469, 588], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getClass()", "getName()", "println(String)", "getClass()", "getName()", "println(*)", "getClass()", "getName()", "println(*)"], "tryExpressionStart": 435, "tryExpressionEnd": 439, "tryBlockStart": 435, "tryBlockEnd": 3437, "catchExpressionStart": 3171, "catchExpressionEnd": 3191, "catchBlockStart": 3171, "catchBlockEnd": 3437, "exceptionHandlingCallStart": [677, 677, 3199, 3309, 3309, 3290, 3377, 3377, 3358], "exceptionHandlingCallEnd": [687, 697, 3282, 3319, 3329, 3350, 3387, 3397, 3408], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 597, "focalAPIEnd": 638, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.setInt(int,int)", "preparedStatement.setInt(int,int)", "preparedStatement.setTimestamp(int,Timestamp)", "preparedStatement.setTimestamp(int,Timestamp)", "preparedStatement.setInt(int,int)", "preparedStatement.setInt(int,int)", "preparedStatement.setInt(int,int)", "preparedStatement.setInt(int,int)", "preparedStatement.setInt(int,int)", "preparedStatement.setTimestamp(int,Timestamp)", "preparedStatement.setString(int,String)", "preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()", "preparedStatement.getGeneratedKeys()", "preparedStatement.close()"], "useStart": [768, 940, 1148, 1325, 1541, 1764, 1992, 2227, 2461, 2626, 2791, 2943, 3089, 3140, 3509, 3941], "useEnd": [816, 982, 1197, 1375, 1596, 1814, 2047, 2283, 2517, 2667, 2840, 2984, 3131, 3163, 3535, 3956], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/PerfModDash/PerfModDash/tree/master/OldDashboard/exda/src/main/java/gov/bnl/racf/exda/Alarm.java", "rawCode": "  private boolean insertAlarm() {\n    boolean result = true;\n    String query =\n        \"INSERT INTO Alarms (name,description,CheckInterval,NotificationInterval,LastFailureTime,LastNotificationTime,status,NumberOfChannelsForWarning,NumberOfChannelsForCritical,NumberOfChannelsForUnknown,statusLevel,LastCheckTime,AlarmUrl,AlarmText,sendAlertAfter) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,NOW())\";\n    PreparedStatement queryPS = null;\n    try {\n      queryPS = db.getConn().prepareStatement(query);\n      System.out.println(getClass().getName() + \" this.getAlarmName()=\" + this.getAlarmName());\n      queryPS.setString(1, this.getAlarmName());\n\n      System.out.println(\n          getClass().getName() + \" this.getAlarmDescription()=\" + this.getAlarmDescription());\n      queryPS.setString(2, this.getAlarmDescription());\n\n      System.out.println(\n          getClass().getName() + \" this.getCheckInterval()=\" + this.getCheckInterval());\n      queryPS.setInt(3, this.getCheckInterval());\n\n      System.out.println(\n          getClass().getName()\n              + \" this.getNotificationInterval()=\"\n              + this.getNotificationInterval());\n      queryPS.setInt(4, this.getNotificationInterval());\n\n      System.out.println(\n          getClass().getName() + \" this.getLastFailureTime()=\" + this.getLastFailureTime());\n      queryPS.setTimestamp(5, this.getLastFailureTime());\n\n      System.out.println(\n          getClass().getName()\n              + \" this.getLastNotificationTime()=\"\n              + this.getLastNotificationTime());\n      queryPS.setTimestamp(6, this.getLastNotificationTime());\n\n      System.out.println(\n          getClass().getName()\n              + \" this.getStatus().getStatusInt()=\"\n              + this.getStatus().getStatusInt());\n      queryPS.setInt(7, this.getStatus().getStatusInt());\n\n      System.out.println(\n          getClass().getName()\n              + \" this.getNumberOfChannelsForWarning()=\"\n              + this.getNumberOfChannelsForWarning());\n      queryPS.setInt(8, this.getNumberOfChannelsForWarning());\n\n      System.out.println(\n          getClass().getName()\n              + \" this.getNumberOfChannelsForCritical()=\"\n              + this.getNumberOfChannelsForCritical());\n      queryPS.setInt(9, this.getNumberOfChannelsForCritical());\n\n      System.out.println(\n          getClass().getName()\n              + \" this.getNumberOfChannelsForUnknown()=\"\n              + this.getNumberOfChannelsForUnknown());\n      queryPS.setInt(10, this.getNumberOfChannelsForUnknown());\n\n      System.out.println(getClass().getName() + \" this.getStatusLevel()=\" + this.getStatusLevel());\n      queryPS.setInt(11, this.getStatusLevel());\n\n      System.out.println(\n          getClass().getName() + \" this.getLastCheckTime()=\" + this.getLastCheckTime());\n      queryPS.setTimestamp(12, this.getLastCheckTime());\n\n      System.out.println(getClass().getName() + \" this.getAlarmUrl()=\" + this.getAlarmUrl());\n      queryPS.setString(13, this.getAlarmUrl());\n\n      System.out.println(getClass().getName() + \" this.getAlarmText()=\" + this.getAlarmText());\n      queryPS.setString(14, this.getAlarmText());\n\n      queryPS.executeUpdate();\n    } catch (Exception e) {\n      System.out.println(getClass().getName() + \" failed to execute insert for an alarm\");\n      System.out.println(getClass().getName() + \" query=\" + query);\n      System.out.println(getClass().getName() + \" \" + e);\n      result = false;\n    }\n    // get the Id of the inserted alarm\n    try {\n      ResultSet rs = queryPS.getGeneratedKeys();\n      while (rs.next()) {\n        this.setAlarmId(rs.getInt(1));\n      }\n      rs.close();\n    } catch (Exception e) {\n      System.out.println(getClass().getName() + \" could not obtain key of newly inserted alarm\");\n      System.out.println(getClass().getName() + \" \" + e);\n      result = false;\n    }\n    // since we have the key, we can create AlarmUrl\n\n    // finally close the query\n    try {\n      queryPS.close();\n    } catch (Exception e) {\n      System.out.println(\n          getClass().getName() + \" failed to close prepared statement in insertAlarm\");\n      System.out.println(getClass().getName() + \" \" + query);\n      System.out.println(getClass().getName() + \" \" + e);\n    }\n\n    this.setAlarmUrl(this.makeDefaultAlarmUrl());\n\n    String query2 = \"UPDATE Alarms SET AlarmUrl=? WHERE alarmId=?\";\n    PreparedStatement queryPS2 = null;\n    try {\n      queryPS2 = db.getConn().prepareStatement(query2);\n      queryPS2.setString(1, this.getAlarmUrl());\n      queryPS2.setInt(2, this.getAlarmId());\n      queryPS2.executeUpdate();\n    } catch (Exception e) {\n      System.out.println(getClass().getName() + \" failed to insertAlarmId()\");\n      System.out.println(getClass().getName() + \" \" + query2);\n      System.out.println(getClass().getName() + \" getAlarmId()=\" + this.getAlarmId());\n      System.out.println(getClass().getName() + \" \" + e);\n    }\n    // finally close the query\n    try {\n      queryPS2.close();\n    } catch (Exception e) {\n      System.out.println(\n          getClass().getName() + \" failed to close prepared statement in insertAlarm\");\n      System.out.println(getClass().getName() + \" \" + query2);\n      System.out.println(getClass().getName() + \" \" + e);\n    }\n\n    return result;\n  }\n"}, {"dataset": "setString", "exampleID": 6290, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [221], "initializationEnd": [287], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["toString()", "error(*,*)"], "tryExpressionStart": 161, "tryExpressionEnd": 165, "tryBlockStart": 161, "tryBlockEnd": 1380, "catchExpressionStart": 1210, "catchExpressionEnd": 1234, "catchBlockStart": 1210, "catchBlockEnd": 1316, "exceptionHandlingCallStart": [712, 1242], "exceptionHandlingCallEnd": [725, 1308], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 295, "focalAPIEnd": 316, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "DBMgr.closeResources(Connection,preparedStatement,ResultSet)"], "useStart": [329, 1333], "useEnd": [346, 1373], "hasFinally": 1, "cleanUpCall": ["DBMgr.closeResources(Connection,PreparedStatement,ResultSet)"], "finallyExpressionStart": 1317, "finallyExpressionEnd": 1325, "finallyBlockStart": 1317, "finallyBlockEnd": 1380, "cleanUpCallStart": [1333], "cleanUpCallEnd": [1373], "url": "https://github.com/bisanthe/twitstreet/tree/master/src/com/twitstreet/market/StockMgrImpl.java", "rawCode": "  public Stock getStock(String name) {\n    Connection connection = null;\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    Stock stockDO = null;\n    try {\n      connection = dbMgr.getConnection();\n\n      ps = connection.prepareStatement(SELECT_FROM_STOCK + \" where name = ?\");\n      ps.setString(1, name);\n      rs = ps.executeQuery();\n      if (rs.next()) {\n        stockDO = new Stock();\n        stockDO.getDataFromResultSet(rs);\n\n        if (stockDO.isUpdateRequired()) {\n          if (updateStockData(stockDO.getId())) {\n            stockDO = getStockById(stockDO.getId());\n          } else {\n            return null;\n          }\n        }\n        logger.debug(DBConstants.QUERY_EXECUTION_SUCC + ps.toString());\n\n      } else {\n\n        twitter4j.User twUser = getTwitterProxy().getTwUser(name);\n\n        if (twUser != null) {\n          stockDO = new Stock(twUser);\n          saveStock(stockDO);\n          // stockdo shall not require an update due to the update\n          // above\n          // so getStockById should go with the else block this time\n          stockDO = getStockById(stockDO.getId());\n\n        } else {\n\n          logger.error(\"Invalid name: \" + name);\n        }\n      }\n    } catch (SQLException ex) {\n      logger.error(DBConstants.QUERY_EXECUTION_FAIL + ps.toString(), ex);\n\n    } finally {\n      dbMgr.closeResources(connection, ps, rs);\n    }\n    return stockDO;\n  }\n"}, {"dataset": "setString", "exampleID": 6291, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["preparedStatement.setBoolean(int,boolean)", "preparedStatement.setDouble(int,double)"], "configurationStart": [490, 687], "configurationEnd": [535, 730], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 772, "focalAPIEnd": 825, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setBytes(preparedStatement,Column,int,*)", "preparedStatement.setFloat(int,float)", "preparedStatement.setInt(int,int)", "preparedStatement.setLong(int,long)", "setField(preparedStatement,Column,Schema,int,Object)", "preparedStatement.setString(int,String)"], "useStart": [868, 978, 1060, 1143, 1258, 1352], "useEnd": [935, 1019, 1101, 1182, 1308, 1406], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/enis/gora/tree/master/gora-sql/src/main/java/org/gora/sql/store/SqlStore.java", "rawCode": "  /** Sets the object to the preparedStatement by it's schema */\n  public void setObject(\n      PreparedStatement statement, int index, Object object, Schema schema, Column column)\n      throws SQLException, IOException {\n\n    Type type = schema.getType();\n\n    switch (type) {\n      case MAP:\n        setField(statement, column, schema, index, object);\n        break;\n      case ARRAY:\n        setField(statement, column, schema, index, object);\n        break;\n      case BOOLEAN:\n        statement.setBoolean(index, (Boolean) object);\n        break;\n      case BYTES:\n        setBytes(statement, column, index, ((ByteBuffer) object).array());\n        break;\n      case DOUBLE:\n        statement.setDouble(index, (Double) object);\n        break;\n      case ENUM:\n        statement.setString(index, ((Enum<?>) object).name());\n        break;\n      case FIXED:\n        setBytes(statement, column, index, ((GenericFixed) object).bytes());\n        break;\n      case FLOAT:\n        statement.setFloat(index, (Float) object);\n        break;\n      case INT:\n        statement.setInt(index, (Integer) object);\n        break;\n      case LONG:\n        statement.setLong(index, (Long) object);\n        break;\n      case NULL:\n        break;\n      case RECORD:\n        setField(statement, column, schema, index, object);\n        break;\n      case STRING:\n        statement.setString(index, ((Utf8) object).toString());\n        break;\n      case UNION:\n        throw new IOException(\"Union is not supported yet\");\n    }\n  }\n"}, {"dataset": "setString", "exampleID": 6292, "initialization": ["PreparedStatement preparedStatement = ISession.getSQLConnection()", "String x = IDatabaseObjectInfo.getSimpleName()"], "initializationStart": [276, 400], "initializationEnd": [302, 419], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 432, "focalAPIEnd": 471, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/maiklos/squirrel-sql/tree/master/sql12/plugins/firebird/src/main/java/org/firebirdsql/squirrel/tab/DomainDetailsTab.java", "rawCode": "  protected PreparedStatement createStatement() throws SQLException {\n    ISession session = getSession();\n    IDatabaseObjectInfo doi = getDatabaseObjectInfo();\n    if (s_log.isDebugEnabled()) {\n      s_log.debug(\"Preparing SQL: \" + SQL);\n    }\n    PreparedStatement pstmt = session.getSQLConnection().prepareStatement(SQL);\n    if (s_log.isDebugEnabled()) {\n      s_log.debug(\"setString param: \" + doi.getSimpleName());\n    }\n    pstmt.setString(1, doi.getSimpleName());\n    return pstmt;\n  }\n"}, {"dataset": "setString", "exampleID": 6293, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [870], "initializationEnd": [910], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["getMessage()", "error(*,*)"], "tryExpressionStart": 740, "tryExpressionEnd": 744, "tryBlockStart": 740, "tryBlockEnd": 1334, "catchExpressionStart": 1184, "catchExpressionEnd": 1210, "catchBlockStart": 1184, "catchBlockEnd": 1259, "exceptionHandlingCallStart": [1228, 1218], "exceptionHandlingCallEnd": [1245, 1252], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 918, "focalAPIEnd": 947, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "closeConnection(ResultSet,preparedStatement,Connection)", "preparedStatement.setString(int,String)", "preparedStatement.executeQuery()", "closeConnection(ResultSet,preparedStatement,Connection)"], "useStart": [960, 1276, 1664, 1708, 2041], "useEnd": [980, 1327, 1693, 1728, 2092], "hasFinally": 1, "cleanUpCall": ["closeConnection(ResultSet,PreparedStatement,Connection)"], "finallyExpressionStart": 1260, "finallyExpressionEnd": 1268, "finallyBlockStart": 1260, "finallyBlockEnd": 1334, "cleanUpCallStart": [1276], "cleanUpCallEnd": [1327], "url": "https://github.com/Flowdalic/openfire/tree/master/src/java/org/jivesoftware/openfire/component/ExternalComponentManager.java", "rawCode": "  /**\n   * Returns the configuration for an external component. A query for the exact requested subdomain\n   * will be made. If nothing was found and using wildcards is requested then another query will be\n   * made but this time using wildcards.\n   *\n   * @param subdomain the subdomain of the external component.\n   * @param useWildcard true if an attempt to find a subdomain with wildcards should be attempted.\n   * @return the configuration for an external component.\n   */\n  private static ExternalComponentConfiguration getConfiguration(\n      String subdomain, boolean useWildcard) {\n    ExternalComponentConfiguration configuration = null;\n    Connection con = null;\n    PreparedStatement pstmt = null;\n    ResultSet rs = null;\n    try {\n      // Check if there is a configuration for the subdomain\n      con = DbConnectionManager.getConnection();\n      pstmt = con.prepareStatement(LOAD_CONFIGURATION);\n      pstmt.setString(1, subdomain);\n      rs = pstmt.executeQuery();\n\n      while (rs.next()) {\n        configuration =\n            new ExternalComponentConfiguration(\n                subdomain, false, Permission.valueOf(rs.getString(2)), rs.getString(1));\n      }\n    } catch (SQLException sqle) {\n      Log.error(sqle.getMessage(), sqle);\n    } finally {\n      DbConnectionManager.closeConnection(rs, pstmt, con);\n    }\n\n    if (configuration == null && useWildcard) {\n      // Check if there is a configuration that is using wildcards for domains\n      try {\n        // Check if there is a configuration for the subdomain\n        con = DbConnectionManager.getConnection();\n        pstmt = con.prepareStatement(LOAD_WILDCARD_CONFIGURATION);\n        pstmt.setString(1, subdomain);\n        rs = pstmt.executeQuery();\n\n        while (rs.next()) {\n          configuration =\n              new ExternalComponentConfiguration(\n                  subdomain, true, Permission.valueOf(rs.getString(2)), rs.getString(1));\n        }\n      } catch (SQLException sqle) {\n        Log.error(sqle.getMessage(), sqle);\n      } finally {\n        DbConnectionManager.closeConnection(rs, pstmt, con);\n      }\n    }\n    return configuration;\n  }\n"}, {"dataset": "setString", "exampleID": 6294, "initialization": ["PreparedStatement preparedStatement = prepareStatement(*)"], "initializationStart": [348], "initializationEnd": [403], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["getMessage()", "buildErrorJson(String)"], "tryExpressionStart": 295, "tryExpressionEnd": 299, "tryBlockStart": 295, "tryBlockEnd": 1638, "catchExpressionStart": 1182, "catchExpressionEnd": 1205, "catchBlockStart": 1182, "catchBlockEnd": 1355, "exceptionHandlingCallStart": [1332, 1262], "exceptionHandlingCallEnd": [1346, 1347], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 412, "focalAPIEnd": 439, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "closeConnections(DbConnection,preparedStatement,ResultSet)", "closeConnections(DbConnection,preparedStatement,ResultSet)"], "useStart": [452, 945, 1540], "useEnd": [471, 979, 1574], "hasFinally": 1, "cleanUpCall": ["closeConnections(DbConnection,PreparedStatement,ResultSet)"], "finallyExpressionStart": 1523, "finallyExpressionEnd": 1531, "finallyBlockStart": 1523, "finallyBlockEnd": 1638, "cleanUpCallStart": [945], "cleanUpCallEnd": [979], "url": "https://github.com/medcafe/medCafe/tree/master/src/org/mitre/medcafe/model/Patient.java", "rawCode": "  public static JSONObject getRecentPatients(String userName) {\n    DbConnection dbConn = null;\n    log.finer(\"Patient: getRecentPatients : got connection \");\n    boolean rtnResults = false;\n    JSONObject ret = new JSONObject();\n\n    PreparedStatement prep = null;\n    ResultSet rs = null;\n    try {\n\n      dbConn = setConnection();\n\n      prep = dbConn.prepareStatement(Patient.SEARCH_RECENT_PATIENTS);\n\n      prep.setString(1, userName);\n      rs = prep.executeQuery();\n      while (rs.next()) {\n        // convert to JSON\n        rtnResults = true;\n\n        JSONObject o = new JSONObject();\n        String fName = rs.getString(\"first_name\");\n        String lName = rs.getString(\"last_name\");\n        int patient_id = rs.getInt(\"patient_id\");\n        o.put(Patient.ID, patient_id);\n        o.put(Patient.FIRST_NAME, fName);\n        o.put(Patient.LAST_NAME, lName);\n        ret.append(\"patients\", o);\n      }\n\n      if (!rtnResults) {\n        closeConnections(dbConn, prep, rs);\n        dbConn = null;\n        prep = null;\n        rs = null;\n\n        return WebUtils.buildErrorJson(\n            \"There are no recent patients currently listed for user \" + userName);\n      }\n    } catch (SQLException e) {\n\n      // TODO Auto-generated catch block\n      return WebUtils.buildErrorJson(\"Problem on selecting data from database .\" + e.getMessage());\n\n    } catch (JSONException e) {\n\n      // TODO Auto-generated catch block\n      return WebUtils.buildErrorJson(\"Problem on generating JSON error.\" + e.getMessage());\n\n    } finally {\n\n      closeConnections(dbConn, prep, rs);\n      dbConn = null;\n      prep = null;\n      rs = null;\n    }\n    return ret;\n  }\n"}, {"dataset": "setString", "exampleID": 6295, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [236], "initializationEnd": [264], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 270, "focalAPIEnd": 301, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.executeUpdate()", "preparedStatement.close()"], "useStart": [307, 340, 367], "useEnd": [334, 361, 380], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/segasai/SAI-CAS/tree/master/src/sai_cas/db/DBInterface.java", "rawCode": "  public void setCatalogDescription(String catalog, String description) throws SQLException {\n    String query =\n        \"UPDATE catalog_list SET description = ? WHERE \" + \" id = cas_get_catalog_id ( ? )\";\n    PreparedStatement pstmt = conn.prepareStatement(query);\n    pstmt.setString(1, description);\n    pstmt.setString(2, catalog);\n    pstmt.executeUpdate();\n    pstmt.close();\n  }\n"}, {"dataset": "setString", "exampleID": 6296, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [602], "initializationEnd": [629], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 540, "tryExpressionEnd": 544, "tryBlockStart": 540, "tryBlockEnd": 1129, "catchExpressionStart": 1006, "catchExpressionEnd": 1026, "catchBlockStart": 1006, "catchBlockEnd": 1060, "exceptionHandlingCallStart": [1034], "exceptionHandlingCallEnd": [1053], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 763, "focalAPIEnd": 818, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.executeQuery()"], "useStart": [828, 904], "useEnd": [883, 936], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eea/eea.eunis/tree/master/web/src/main/java/eionet/eunis/dao/impl/ReferencesDaoImpl.java", "rawCode": "  /**\n   * @param like\n   * @return number of references\n   */\n  private int getReferencesCnt(String like) {\n    int ret = 0;\n    String trimmedLike = like == null ? StringUtils.EMPTY : like.trim();\n    String query = \"SELECT COUNT(*) FROM dc_index\";\n    if (trimmedLike.length() > 0\n        && !trimmedLike.equalsIgnoreCase(ReferencesActionBean.DEFAULT_FILTER_VALUE)) {\n      query += \" WHERE (TITLE LIKE ? OR SOURCE LIKE ?) \";\n    }\n    Connection con = null;\n    PreparedStatement preparedStatement = null;\n    ResultSet rs = null;\n\n    try {\n\n      con = getConnection();\n      preparedStatement = con.prepareStatement(query);\n      if (trimmedLike.length() > 0\n          && !trimmedLike.equalsIgnoreCase(ReferencesActionBean.DEFAULT_FILTER_VALUE)) {\n        preparedStatement.setString(1, \"%\" + trimmedLike + \"%\");\n        preparedStatement.setString(2, \"%\" + trimmedLike + \"%\");\n      }\n      rs = preparedStatement.executeQuery();\n      while (rs.next()) {\n        ret = rs.getInt(1);\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    } finally {\n      closeAllResources(con, preparedStatement, rs);\n    }\n\n    return ret;\n  }\n"}, {"dataset": "setString", "exampleID": 6297, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [654], "initializationEnd": [696], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 702, "focalAPIEnd": 729, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [751, 1568], "useEnd": [771, 1581], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CompendiumNG/CompendiumNG/tree/master/src/main/java/com/compendium/core/db/DBViewProperty.java", "rawCode": "  /**\n   * Returns a Vector of all the View Properties for the given user id\n   *\n   * @param DBConnection dbcon com.compendium.core.db.management.DBConnection, the DBConnection\n   *     object to access the database with.\n   * @param String sUserID, the id of the user whose ViewProperty record to return.\n   * @return Vector, a list of all the <code>ViewProperty</code> objects for the given user id.\n   * @throws java.sql.SQLException\n   */\n  public static Vector getAllViewProperty(DBConnection dbcon, String sUserID) throws SQLException {\n\n    Connection con = dbcon.getConnection();\n    if (con == null) return null;\n\n    PreparedStatement pstmt = con.prepareStatement(GET_ALL_VIEWPROPERTY);\n    pstmt.setString(1, sUserID);\n\n    ResultSet rs = pstmt.executeQuery();\n\n    Vector data = new Vector(8);\n    if (rs != null) {\n      while (rs.next()) {\n        ViewProperty view = new ViewProperty();\n        view.setViewID(rs.getString(1));\n        view.setUserID(sUserID);\n        view.setHorizontalScrollBarPosition(rs.getInt(2));\n        view.setVerticalScrollBarPosition(rs.getInt(3));\n        view.setWidth(rs.getInt(4));\n        view.setHeight(rs.getInt(5));\n        view.setXPosition(rs.getInt(6));\n        view.setYPosition(rs.getInt(7));\n\n        String isIcon = rs.getString(8);\n        if (isIcon.equals(\"Y\")) view.setIsIcon(true);\n        else view.setIsIcon(false);\n\n        String isMax = rs.getString(9);\n        if (isMax.equals(\"Y\")) view.setIsMaximum(true);\n        else view.setIsMaximum(false);\n\n        data.addElement(view);\n      }\n    }\n    pstmt.close();\n    return data;\n  }\n"}, {"dataset": "setString", "exampleID": 6298, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["preparedStatement.setInt(int,int)"], "configurationStart": [146], "configurationEnd": [165], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 171, "focalAPIEnd": 226, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.executeUpdate()"], "useStart": [232], "useEnd": [250], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ImmobilienScout24/yum-repo-server/tree/master/src/main/java/de/is24/infrastructure/gridfs/http/metadata/generation/FileListsGenerator.java", "rawCode": "  private void writePackageTable(\n      final PreparedStatement ps, final int index, final YumPackage yumPackage)\n      throws SQLException {\n    ps.setInt(1, index);\n    ps.setString(2, yumPackage.getChecksum().getChecksum());\n    ps.executeUpdate();\n  }\n"}, {"dataset": "setString", "exampleID": 6299, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 125, "focalAPIEnd": 160, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chenillekit/chenillekit/tree/master/chenillekit-hibernate/src/main/java/org/chenillekit/hibernate/types/RTrimStringType.java", "rawCode": "  public void nullSafeSet(PreparedStatement st, Object value, int index)\n      throws HibernateException, SQLException {\n    st.setString(index, (String) value);\n  }\n"}, {"dataset": "setString", "exampleID": 6300, "initialization": ["PreparedStatement preparedStatement = Connection.prepareStatement(String)"], "initializationStart": [146], "initializationEnd": [265], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = preparedStatement.setString(parameterIndex,x)", "focalAPIStart": 271, "focalAPIEnd": 298, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["preparedStatement.setString(int,String)", "preparedStatement.executeQuery()", "preparedStatement.close()"], "useStart": [304, 377, 450], "useEnd": [328, 394, 460], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdeolive/geotools-old/tree/master/modules/plugin/jdbc/jdbc-db2/src/test/java/org/geotools/data/db2/DB2TestUtil.java", "rawCode": "  static boolean existsSequence(String schemaName, String seqName, Connection con)\n      throws SQLException {\n    PreparedStatement ps =\n        con.prepareStatement(\n            \"select seqschema,seqname from syscat.sequences where seqschema = ? and seqname = ?\");\n    ps.setString(1, schemaName);\n    ps.setString(2, seqName);\n    boolean retval = false;\n    ResultSet rs = ps.executeQuery();\n    if (rs.next()) retval = true;\n    rs.close();\n    ps.close();\n    return retval;\n  }\n"}]