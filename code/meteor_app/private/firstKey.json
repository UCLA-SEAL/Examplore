[{"dataset": "firstKey", "exampleID": 8001, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 251, "focalAPIEnd": 263, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AllBinary/phoneme-components-cdc/tree/master/src/share/classes/java/util/TreeSet.java", "rawCode": "  /**\n   * Returns the first (lowest) element currently in this sorted set.\n   *\n   * @return the first (lowest) element currently in this sorted set.\n   * @throws NoSuchElementException sorted set is empty.\n   */\n  public Object first() {\n    return m.firstKey();\n  }\n"}, {"dataset": "firstKey", "exampleID": 8002, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["sortedMap.isEmpty()"], "configurationStart": [110], "configurationEnd": [124], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 160, "focalAPIEnd": 175, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["keyIterator(firstKey,*)"], "useStart": [140], "useEnd": [192], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/and146/SPLAT-ARI/tree/master/ttools/src/main/uk/ac/starlink/ttools/plot/MapBinnedData.java", "rawCode": "  public Iterator getBinIterator(boolean includeEmpty) {\n    final Iterator keyIt =\n        (includeEmpty && !map_.isEmpty())\n            ? mapper_.keyIterator(map_.firstKey(), map_.lastKey())\n            : map_.keySet().iterator();\n    return new Iterator() {\n      final double[] EMPTY_SUMS = new double[nset_];\n\n      public boolean hasNext() {\n        return keyIt.hasNext();\n      }\n\n      public Object next() {\n        Object key = keyIt.next();\n        final double[] sums = map_.containsKey(key) ? (double[]) map_.get(key) : EMPTY_SUMS;\n        final double[] bounds = mapper_.getBounds(key);\n        return new Bin() {\n          public double getLowBound() {\n            return bounds[0];\n          }\n\n          public double getHighBound() {\n            return bounds[1];\n          }\n\n          public double getWeightedCount(int iset) {\n            return sums[iset];\n          }\n        };\n      }\n\n      public void remove() {\n        keyIt.remove();\n      }\n    };\n  }\n"}, {"dataset": "firstKey", "exampleID": 8003, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NoSuchElementException", "exceptionHandlingCall": ["Scheduler.setDelay(int)"], "tryExpressionStart": 832, "tryExpressionEnd": 836, "tryBlockStart": 832, "tryBlockEnd": 1119, "catchExpressionStart": 1008, "catchExpressionEnd": 1042, "catchBlockStart": 1008, "catchBlockEnd": 1119, "exceptionHandlingCallStart": [1084], "exceptionHandlingCallEnd": [1106], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 867, "focalAPIEnd": 886, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["firstKey.getTime()"], "useStart": [913], "useEnd": [930], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aldaris/opensso/tree/master/products/shared/source/com/sun/identity/common/TimerPool.java", "rawCode": "  /** Runs the next timeout task in the sorted container. */\n  private void runNext() {\n    WorkerThread t = null;\n    HeadTaskRunnable task = null;\n    synchronized (this) {\n      if (shutdownThePool) {\n        return;\n      } else {\n        while (busyThreadCount == poolSize) {\n          try {\n            wait();\n            if (shutdownThePool) {\n              return;\n            }\n          } catch (Exception ex) {\n            if (debug != null) {\n              debug.error(\"TimerPool:runNext() \" + name, ex);\n            }\n          }\n        }\n        if (nextRun != null) {\n          long now = System.currentTimeMillis();\n          if (nextRun.getTime() <= now) {\n            if ((task = (HeadTaskRunnable) taskList.remove(nextRun)) != null) {\n              t = getAvailableThread();\n            }\n          }\n          try {\n            nextRun = (Date) taskList.firstKey();\n            long delay = nextRun.getTime() - now;\n            scheduler.setDelay((delay >= 0 ? delay : 0));\n          } catch (NoSuchElementException ex) {\n            nextRun = null;\n            scheduler.setDelay(-1);\n          }\n        }\n      }\n    }\n    if ((t != null) && (task != null)) {\n      t.runTask(task);\n    }\n  }\n"}, {"dataset": "firstKey", "exampleID": 8004, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["sortedMap.isEmpty()"], "configurationStart": [318], "configurationEnd": [335], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 415, "focalAPIEnd": 433, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["SortedMap.get(firstKey)", "sortedMap.wait(long)", "sortedMap.entrySet()"], "useStart": [403, 574, 854], "useEnd": [434, 593, 872], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mbtaylor/jsamp/tree/master/src/java/org/astrogrid/samp/client/HubConnector.java", "rawCode": "    /** Runs in a daemon thread to watch out for timeouts that might have occurred. */\n    private void watchTimeouts() {\n      while (!Thread.currentThread().isInterrupted()) {\n        synchronized (tagMap_) {\n\n          // Wait until the next scheduled timeout is expected.\n          long nextFinish =\n              tagMap_.isEmpty()\n                  ? Long.MAX_VALUE\n                  : ((CallItem) tagMap_.get(tagMap_.firstKey())).finish_;\n          final long delay = nextFinish - System.currentTimeMillis();\n          if (delay > 0) {\n            try {\n              tagMap_.wait(delay);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }\n          }\n\n          // Then process any timeouts that are pending.\n          long now = System.currentTimeMillis();\n          for (Iterator it = tagMap_.entrySet().iterator(); it.hasNext(); ) {\n            Map.Entry entry = (Map.Entry) it.next();\n            CallItem item = (CallItem) entry.getValue();\n            if (now >= item.finish_) {\n              item.handler_.done();\n              it.remove();\n            }\n          }\n        }\n      }\n    }\n"}, {"dataset": "firstKey", "exampleID": 8005, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 152, "focalAPIEnd": 168, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.freePastry/src/main/java/rice/p2p/glacier/FragmentKeySet.java", "rawCode": "  /**\n   * return the smallest member id\n   *\n   * @return the smallest id in the set\n   */\n  public FragmentKey minMember() {\n    return (FragmentKey) idSet.firstKey();\n  }\n"}, {"dataset": "firstKey", "exampleID": 8006, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 1471, "focalAPIEnd": 1489, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["SortedMap.remove(firstKey)"], "useStart": [1624], "useEnd": [1648], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/and146/SPLAT-ARI/tree/master/ttools/src/main/uk/ac/starlink/ttools/filter/SortHeadFilter.java", "rawCode": "    public StarTable wrap(StarTable baseTable) throws IOException {\n\n      /* Compile expressions for the specified sort keys. */\n      SequentialJELRowReader rseq = new SequentialJELRowReader(baseTable);\n      Library lib = JELUtils.getLibrary(rseq);\n      int nkey = keys_.length;\n      CompiledExpression[] compExs = new CompiledExpression[nkey];\n      try {\n        for (int i = 0; i < nkey; i++) {\n          compExs[i] = JELUtils.compile(lib, baseTable, keys_[i]);\n        }\n      } catch (CompilationException e) {\n        throw (IOException) new IOException(\"Bad sort key(s)\").initCause(e);\n      }\n\n      /* Prepare a SortedMap which will keep the top nrows rows.\n       * The map keys are the Object arrays of sort key values, and the\n       * map values are the full row Object arrays. */\n      SortedMap headMap = new TreeMap();\n\n      /* Iterate over rows in the input table. */\n      while (rseq.next()) {\n\n        /* Get the key values for this row. */\n        SortKey sortKey = new SortKey(rseq, compExs);\n\n        /* If there are not enough rows in the retention map yet,\n         * insert this one unconditionally. */\n        if (headMap.size() < nrows_) {\n          headMap.put(sortKey, rseq.getRow());\n        }\n\n        /* Otherwise, if this row sorts nearer the top/bottom\n         * than the current most marginal item, replace that\n         * with this one. */\n        else {\n          SortKey marginal = (SortKey) (keepHead_ ? headMap.lastKey() : headMap.firstKey());\n          if ((marginal.compareTo(sortKey) * (keepHead_ ? +1 : -1)) > 0) {\n            assert headMap.size() == nrows_;\n            headMap.remove(marginal);\n            headMap.put(sortKey, rseq.getRow());\n            assert headMap.size() == nrows_;\n          }\n        }\n      }\n\n      /* Prepare and return a new table containing the rows from\n       * the retention map in order. */\n      RowListStarTable outTable = new RowListStarTable(baseTable);\n      for (Iterator it = headMap.entrySet().iterator(); it.hasNext(); ) {\n        Map.Entry entry = (Map.Entry) it.next();\n        outTable.addRow((Object[]) entry.getValue());\n        it.remove();\n      }\n      return outTable;\n    }\n"}, {"dataset": "firstKey", "exampleID": 8007, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 40, "focalAPIEnd": 54, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joliebig/featurehouse_fstcomp_examples/tree/master/Java/BerkeleyDB/LookAHEADCache/com/sleepycat/je/cleaner/LookAheadCache.java", "rawCode": "  Long nextOffset() {\n    return (Long) map.firstKey();\n  }\n"}, {"dataset": "firstKey", "exampleID": 8008, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 1498, "focalAPIEnd": 1516, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["SortedMap.remove(firstKey)"], "useStart": [1650], "useEnd": [1674], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Starlink/starjava/tree/master/ttools/src/main/uk/ac/starlink/ttools/filter/SortHeadFilter.java", "rawCode": "    public StarTable wrap(StarTable baseTable) throws IOException {\n\n      /* Compile expressions for the specified sort keys. */\n      SequentialJELRowReader rseq = new SequentialJELRowReader(baseTable);\n      Library lib = JELUtils.getLibrary(rseq);\n      int nkey = keys_.length;\n      CompiledExpression[] compExs = new CompiledExpression[nkey];\n      try {\n        for (int i = 0; i < nkey; i++) {\n          compExs[i] = JELUtils.compile(lib, baseTable, keys_[i]);\n        }\n      } catch (CompilationException e) {\n        throw (IOException) new IOException(\"Bad sort key(s)\").initCause(e);\n      }\n\n      /* Prepare a SortedMap which will keep the top nrows rows.\n       * The map keys are the Object arrays of sort key values, and the\n       * map values are the full row Object arrays. */\n      SortedMap<SortKey, Object[]> headMap = new TreeMap<SortKey, Object[]>();\n\n      /* Iterate over rows in the input table. */\n      while (rseq.next()) {\n\n        /* Get the key values for this row. */\n        SortKey sortKey = new SortKey(rseq, compExs);\n\n        /* If there are not enough rows in the retention map yet,\n         * insert this one unconditionally. */\n        if (headMap.size() < nrows_) {\n          headMap.put(sortKey, rseq.getRow());\n        }\n\n        /* Otherwise, if this row sorts nearer the top/bottom\n         * than the current most marginal item, replace that\n         * with this one. */\n        else {\n          SortKey marginal = keepHead_ ? headMap.lastKey() : headMap.firstKey();\n          if ((marginal.compareTo(sortKey) * (keepHead_ ? +1 : -1)) > 0) {\n            assert headMap.size() == nrows_;\n            headMap.remove(marginal);\n            headMap.put(sortKey, rseq.getRow());\n            assert headMap.size() == nrows_;\n          }\n        }\n      }\n\n      /* Prepare and return a new table containing the rows from\n       * the retention map in order. */\n      RowListStarTable outTable = new RowListStarTable(baseTable);\n      for (Iterator<Map.Entry<SortKey, Object[]>> it = headMap.entrySet().iterator();\n          it.hasNext(); ) {\n        outTable.addRow(it.next().getValue());\n        it.remove();\n      }\n      return outTable;\n    }\n"}, {"dataset": "firstKey", "exampleID": 8009, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(sortedMap==null||sortedMap.isEmpty())", "guardType": "IF {", "guardExpressionStart": 66, "guardExpressionEnd": 117, "guardBlockStart": 66, "guardBlockEnd": 147, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 168, "focalAPIEnd": 191, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["awtUnlock()"], "finallyExpressionStart": 199, "finallyExpressionEnd": 207, "finallyBlockStart": 199, "finallyBlockEnd": 233, "cleanUpCallStart": [215], "cleanUpCallEnd": [226], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/src/solaris/classes/sun/awt/X11/XToolkit.java", "rawCode": "  private long getNextTaskTime() {\n    awtLock();\n    try {\n      if (timeoutTasks == null || timeoutTasks.isEmpty()) {\n        return -1L;\n      }\n      return (Long) timeoutTasks.firstKey();\n    } finally {\n      awtUnlock();\n    }\n  }\n"}, {"dataset": "firstKey", "exampleID": 8010, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "sortedMap.size()>0", "guardType": "LOOP {", "guardExpressionStart": 699, "guardExpressionEnd": 726, "guardBlockStart": 699, "guardBlockEnd": 1368, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 768, "focalAPIEnd": 787, "followUpCheck": "firstKey.intValue() == highestFlushLevel", "checkType": "IF", "followUpCheckExpressionStart": 1288, "followUpCheckExpressionEnd": 1337, "followUpCheckBlockStart": 1288, "followUpCheckBlockEnd": 1362, "use": ["firstKey.intValue()", "sortedMap.get(Integer)", "hook546(SortedMap,boolean,long,firstKey,boolean,CheckpointReference)", "sortedMap.remove(Integer)"], "useStart": [823, 896, 1104, 1251], "useEnd": [846, 922, 1212, 1280], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joliebig/featurehouse_fstcomp_examples/tree/master/Java/BerkeleyDB/base/com/sleepycat/je/recovery/Checkpointer.java", "rawCode": "  /**\n   * Flush the nodes in order, from the lowest level to highest level. As a flush dirties its\n   * parent, add it to the dirty map, thereby cascading the writes up the tree. If flushAll wasn't\n   * specified, we need only cascade up to the highest level set at the start of checkpointing. Note\n   * that all but the top level INs and the BINDeltas are logged provisionally. That's because we\n   * don't need to process lower INs because the higher INs will end up pointing at them.\n   */\n  private void flushDirtyNodes(\n      SortedMap dirtyMap,\n      boolean flushAll,\n      boolean allowDeltas,\n      boolean flushExtraLevel,\n      long checkpointStart)\n      throws DatabaseException {\n    while (dirtyMap.size() > 0) {\n      Integer currentLevel = (Integer) dirtyMap.firstKey();\n      boolean logProvisionally = (currentLevel.intValue() != highestFlushLevel);\n      Set nodeSet = (Set) dirtyMap.get(currentLevel);\n      Iterator iter = nodeSet.iterator();\n      while (iter.hasNext()) {\n        CheckpointReference targetRef = (CheckpointReference) iter.next();\n        this.hook520();\n        this.hook546(\n            dirtyMap, allowDeltas, checkpointStart, currentLevel, logProvisionally, targetRef);\n        iter.remove();\n      }\n      dirtyMap.remove(currentLevel);\n      if (currentLevel.intValue() == highestFlushLevel) {\n        break;\n      }\n    }\n  }\n"}, {"dataset": "firstKey", "exampleID": 8011, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 44, "focalAPIEnd": 57, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AllBinary/phoneme-components-cdc/tree/master/src/share/classes/java/util/Collections.java", "rawCode": "    public Object firstKey() {\n      return sm.firstKey();\n    }\n"}, {"dataset": "firstKey", "exampleID": 8012, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 633, "focalAPIEnd": 655, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["sortedMap.firstKey()"], "useStart": [744], "useEnd": [766], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/buglabs/bug-osgi/tree/master/com.buglabs.bug.legacy/com/buglabs/util/ServiceFilterGenerator.java", "rawCode": "  /**\n   * servicesMap is SortedMap<String, Map<String, String>> where the key is the service name and the\n   * map is a map of service properties\n   *\n   * <p>(| (& (objectClass=com.buglabs.bug.module.bugbee.pub.IBUGBeeControl) (&\n   * (Provider=com.buglabs.bug.module.bugbee.BUGBeeModlet)(Slot=2))) (| (&\n   * (objectClass=com.buglabs.module.IModuleControl)) (&\n   * (objectClass=org.osgi.service.http.HttpService)(port=8082))))\n   */\n  public static String generateServiceFilter(SortedMap servicesMap) {\n    if (servicesMap.size() == 1) {\n      return \"(&(\"\n          + Constants.OBJECTCLASS\n          + \"=\"\n          + ((String) servicesMap.firstKey())\n          + \")\"\n          + generatePropertiesFilter(new TreeMap((Map) servicesMap.get(servicesMap.firstKey())))\n          + \")\";\n    } else if (servicesMap.size() > 1) {\n      return \"(|\"\n          + generateServiceFilter(\n              servicesMap.subMap(servicesMap.firstKey(), servicesMap.firstKey() + \"\\0\"))\n          + generateServiceFilter(servicesMap.tailMap(servicesMap.firstKey() + \"\\0\"))\n          + \")\";\n    }\n    return \"\";\n  }\n"}, {"dataset": "firstKey", "exampleID": 8013, "initialization": ["SortedMap sortedMap = Map.Entry.getValue()"], "initializationStart": [282], "initializationEnd": [304], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 357, "focalAPIEnd": 374, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["sortedMap.remove(Long)"], "useStart": [343], "useEnd": [375], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kiniry-teaching/UCD/tree/master/COMP30050-2008/users/lorcancoyle/week7assignment/construct/construct/src/org/construct_infrastructure/component/gossiping/buffer/BufferManagerImpl.java", "rawCode": "  /** Remove a message to make room in the buffer. */\n  private void removeAMessage() {\n    final int sourceIndex = my_rng.nextInt(my_buffer.size());\n    final Map.Entry sourceEntry = (Map.Entry) my_buffer.entrySet().toArray()[sourceIndex];\n    final SortedMap source = (SortedMap) sourceEntry.getValue();\n    final Message lowest = (Message) source.remove(source.firstKey());\n    final MessageID messageID = lowest.getMessageID();\n    my_bufferMetadata.remove(messageID);\n    if (source.size() == 0) {\n      my_buffer.remove(sourceEntry.getKey());\n    }\n    my_sourceMetadata.put(messageID.getSourceID(), new Integer(messageID.getSequenceNumber()));\n    my_bufferSize--;\n  }\n"}, {"dataset": "firstKey", "exampleID": 8014, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 150, "focalAPIEnd": 166, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.freePastry/src/main/java/rice/p2p/glacier/VersionKeySet.java", "rawCode": "  /**\n   * return the smallest member id\n   *\n   * @return the smallest id in the set\n   */\n  public VersionKey minMember() {\n    return (VersionKey) idSet.firstKey();\n  }\n"}, {"dataset": "firstKey", "exampleID": 8015, "initialization": ["SortedMap sortedMap = Map.Entry.getValue()"], "initializationStart": [282], "initializationEnd": [304], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 357, "focalAPIEnd": 374, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["sortedMap.remove(Long)"], "useStart": [343], "useEnd": [375], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kiniry-teaching/UCD/tree/master/COMP30050-2008/users/lorcancoyle/week7assignment/construct/src/org/construct_infrastructure/component/gossiping/buffer/BufferManagerImpl.java", "rawCode": "  /** Remove a message to make room in the buffer. */\n  private void removeAMessage() {\n    final int sourceIndex = my_rng.nextInt(my_buffer.size());\n    final Map.Entry sourceEntry = (Map.Entry) my_buffer.entrySet().toArray()[sourceIndex];\n    final SortedMap source = (SortedMap) sourceEntry.getValue();\n    final Message lowest = (Message) source.remove(source.firstKey());\n    final MessageID messageID = lowest.getMessageID();\n    my_bufferMetadata.remove(messageID);\n    if (source.size() == 0) {\n      my_buffer.remove(sourceEntry.getKey());\n    }\n    my_sourceMetadata.put(messageID.getSourceID(), new Integer(messageID.getSequenceNumber()));\n    my_bufferSize--;\n  }\n"}, {"dataset": "firstKey", "exampleID": 8016, "initialization": ["SortedMap sortedMap = Map.Entry.getValue()"], "initializationStart": [282], "initializationEnd": [304], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 357, "focalAPIEnd": 374, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["sortedMap.remove(Long)"], "useStart": [343], "useEnd": [375], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kiniry-teaching/UCD/tree/master/COMP30050-2008/users/BHarty/construct/src/org/construct_infrastructure/component/gossiping/buffer/BufferManagerImpl.java", "rawCode": "  /** Remove a message to make room in the buffer. */\n  private void removeAMessage() {\n    final int sourceIndex = my_rng.nextInt(my_buffer.size());\n    final Map.Entry sourceEntry = (Map.Entry) my_buffer.entrySet().toArray()[sourceIndex];\n    final SortedMap source = (SortedMap) sourceEntry.getValue();\n    final Message lowest = (Message) source.remove(source.firstKey());\n    final MessageID messageID = lowest.getMessageID();\n    my_bufferMetadata.remove(messageID);\n    if (source.size() == 0) {\n      my_buffer.remove(sourceEntry.getKey());\n    }\n    my_sourceMetadata.put(messageID.getSourceID(), new Integer(messageID.getSequenceNumber()));\n    my_bufferSize--;\n  }\n"}, {"dataset": "firstKey", "exampleID": 8017, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 71, "focalAPIEnd": 89, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["term(firstKey)"], "useStart": [55], "useEnd": [90], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/serso/jscl/tree/master/src/main/java/jscl/math/polynomial/TreePolynomial.java", "rawCode": "  public Term tail() {\n    return content.size() > 0 ? term((Monomial) content.firstKey()) : null;\n  }\n"}, {"dataset": "firstKey", "exampleID": 8018, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 134, "focalAPIEnd": 150, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.freePastry/src/main/java/rice/pastry/IdSet.java", "rawCode": "  /**\n   * return the smallest member id\n   *\n   * @return the smallest id in the set\n   */\n  public Id minMember() {\n    return (Id) idSet.firstKey();\n  }\n"}, {"dataset": "firstKey", "exampleID": 8019, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(sortedMap==null||sortedMap.isEmpty())", "guardType": "IF {", "guardExpressionStart": 383, "guardExpressionEnd": 434, "guardBlockStart": 383, "guardBlockEnd": 456, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 546, "focalAPIEnd": 569, "followUpCheck": "firstKey.compareTo(currentTime) <= 0", "checkType": "LOOP {", "followUpCheckExpressionStart": 576, "followUpCheckExpressionEnd": 616, "followUpCheckBlockStart": 576, "followUpCheckBlockEnd": 1338, "use": ["sortedMap.remove(Long)", "sortedMap.firstKey()"], "useStart": [665, 1308], "useEnd": [690, 1331], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/src/solaris/classes/sun/awt/X11/XToolkit.java", "rawCode": "  /** Executes mature timeout tasks registered with schedule(). Called from run() under awtLock. */\n  private static void callTimeoutTasks() {\n    if (timeoutTaskLog.isLoggable(PlatformLogger.FINER)) {\n      timeoutTaskLog.finer(\n          \"XToolkit.callTimeoutTasks(): current time={0}\" + \"; tasks={1}\",\n          Long.valueOf(System.currentTimeMillis()), timeoutTasks);\n    }\n\n    if (timeoutTasks == null || timeoutTasks.isEmpty()) {\n      return;\n    }\n\n    Long currentTime = Long.valueOf(System.currentTimeMillis());\n    Long time = (Long) timeoutTasks.firstKey();\n\n    while (time.compareTo(currentTime) <= 0) {\n      java.util.List tasks = (java.util.List) timeoutTasks.remove(time);\n\n      for (Iterator iter = tasks.iterator(); iter.hasNext(); ) {\n        Runnable task = (Runnable) iter.next();\n\n        if (timeoutTaskLog.isLoggable(PlatformLogger.FINER)) {\n          timeoutTaskLog.finer(\n              \"XToolkit.callTimeoutTasks(): current time={0}\" + \"; about to run task={1}\",\n              Long.valueOf(currentTime), task);\n        }\n\n        try {\n          task.run();\n        } catch (ThreadDeath td) {\n          throw td;\n        } catch (Throwable thr) {\n          processException(thr);\n        }\n      }\n\n      if (timeoutTasks.isEmpty()) {\n        break;\n      }\n      time = (Long) timeoutTasks.firstKey();\n    }\n  }\n"}, {"dataset": "firstKey", "exampleID": 8020, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 45, "focalAPIEnd": 59, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["sortedMap.firstKey()"], "useStart": [87], "useEnd": [101], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.freePastry/src/main/java/rice/p2p/multiring/MultiringIdFactory.java", "rawCode": "    public Object firstKey() {\n      return (map.firstKey() == null ? null : ((RingId) map.firstKey()).getId());\n    }\n"}, {"dataset": "firstKey", "exampleID": 8021, "initialization": ["SortedMap sortedMap = Map.Entry.getValue()"], "initializationStart": [282], "initializationEnd": [304], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 357, "focalAPIEnd": 374, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["sortedMap.remove(Long)"], "useStart": [343], "useEnd": [375], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kiniry-teaching/UCD/tree/master/COMP30050-2008/users/BHarty/construct/construct/src/org/construct_infrastructure/component/gossiping/buffer/BufferManagerImpl.java", "rawCode": "  /** Remove a message to make room in the buffer. */\n  private void removeAMessage() {\n    final int sourceIndex = my_rng.nextInt(my_buffer.size());\n    final Map.Entry sourceEntry = (Map.Entry) my_buffer.entrySet().toArray()[sourceIndex];\n    final SortedMap source = (SortedMap) sourceEntry.getValue();\n    final Message lowest = (Message) source.remove(source.firstKey());\n    final MessageID messageID = lowest.getMessageID();\n    my_bufferMetadata.remove(messageID);\n    if (source.size() == 0) {\n      my_buffer.remove(sourceEntry.getKey());\n    }\n    my_sourceMetadata.put(messageID.getSourceID(), new Integer(messageID.getSequenceNumber()));\n    my_bufferSize--;\n  }\n"}, {"dataset": "firstKey", "exampleID": 8022, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 44, "focalAPIEnd": 57, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AllBinary/phoneme-components-cdc/tree/master/src/share/classes/java/util/Collections.java", "rawCode": "    public Object firstKey() {\n      return sm.firstKey();\n    }\n"}, {"dataset": "firstKey", "exampleID": 8023, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["sortedMap.isEmpty()"], "configurationStart": [118], "configurationEnd": [132], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 168, "focalAPIEnd": 183, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["keyIterator(firstKey,*)"], "useStart": [148], "useEnd": [200], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Starlink/starjava/tree/master/ttools/src/main/uk/ac/starlink/ttools/plot/MapBinnedData.java", "rawCode": "  public Iterator<Bin> getBinIterator(boolean includeEmpty) {\n    final Iterator<K> keyIt =\n        (includeEmpty && !map_.isEmpty())\n            ? mapper_.keyIterator(map_.firstKey(), map_.lastKey())\n            : map_.keySet().iterator();\n    return new Iterator<Bin>() {\n      final double[] EMPTY_SUMS = new double[nset_];\n\n      public boolean hasNext() {\n        return keyIt.hasNext();\n      }\n\n      public Bin next() {\n        K key = keyIt.next();\n        final double[] sums = map_.containsKey(key) ? map_.get(key) : EMPTY_SUMS;\n        final double[] bounds = mapper_.getBounds(key);\n        return new Bin() {\n          public double getLowBound() {\n            return bounds[0];\n          }\n\n          public double getHighBound() {\n            return bounds[1];\n          }\n\n          public double getWeightedCount(int iset) {\n            return sums[iset];\n          }\n        };\n      }\n\n      public void remove() {\n        keyIt.remove();\n      }\n    };\n  }\n"}, {"dataset": "firstKey", "exampleID": 8024, "initialization": ["SortedMap sortedMap = SortedMap.subMap(String,String)"], "initializationStart": [241], "initializationEnd": [281], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 325, "focalAPIEnd": 338, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["sortedMap.lastKey()"], "useStart": [487], "useEnd": [499], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/java/util/TreeMap/SubMap.java", "rawCode": "  public static void main(String args[]) throws Exception {\n    SortedMap m = new TreeMap();\n    m.put(new Integer(1), new Integer(1));\n    m.put(new Integer(2), new Integer(2));\n    m.put(new Integer(3), new Integer(3));\n    SortedMap m2 = m.subMap(new Integer(2), new Integer(2));\n\n    boolean exc = false;\n    try {\n      m2.firstKey();\n    } catch (NoSuchElementException e) {\n      exc = true;\n    }\n    if (!exc) throw new Exception(\"first key\");\n\n    exc = false;\n    try {\n      m2.lastKey();\n    } catch (NoSuchElementException e) {\n      exc = true;\n    }\n    if (!exc) throw new Exception(\"last key\");\n\n    SortedMap m3 = m.subMap(new Integer(2), new Integer(3));\n    if (!m3.firstKey().equals(new Integer(2))) throw new Exception(\"first key wrong\");\n    if (!m3.lastKey().equals(new Integer(2))) throw new Exception(\"last key wrong\");\n\n    SortedSet s = new TreeSet();\n    s.add(new Integer(1));\n    s.add(new Integer(2));\n    s.add(new Integer(3));\n    SortedSet s2 = s.subSet(new Integer(2), new Integer(2));\n\n    exc = false;\n    try {\n      s2.first();\n    } catch (NoSuchElementException e) {\n      exc = true;\n    }\n    if (!exc) throw new Exception(\"first element\");\n\n    exc = false;\n    try {\n      s2.last();\n    } catch (NoSuchElementException e) {\n      exc = true;\n    }\n    if (!exc) throw new Exception(\"last element\");\n\n    SortedSet s3 = s.subSet(new Integer(2), new Integer(3));\n    if (!s3.first().equals(new Integer(2))) throw new Exception(\"first element wrong\");\n    if (!s3.last().equals(new Integer(2))) throw new Exception(\"last element wrong\");\n  }\n"}, {"dataset": "firstKey", "exampleID": 8025, "initialization": ["SortedMap sortedMap = SortedMap.tailMap(String)"], "initializationStart": [108], "initializationEnd": [139], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(sortedMap.size()==0)", "guardType": "IF {", "guardExpressionStart": 145, "guardExpressionEnd": 176, "guardBlockStart": 145, "guardBlockEnd": 189, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 207, "focalAPIEnd": 232, "followUpCheck": "firstKey == null", "checkType": "IF", "followUpCheckExpressionStart": 238, "followUpCheckExpressionEnd": 254, "followUpCheckBlockStart": 238, "followUpCheckBlockEnd": 267, "use": ["SortedMap.get(firstKey)"], "useStart": [296], "useEnd": [310], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mcarlson/openlaszlo/tree/master/WEB-INF/lps/server/src/org/openlaszlo/sc/TranslationUnit.java", "rawCode": "  public SourceFileLine originalLineNumber(int num) {\n    num -= lineOffset;\n    SortedMap nextLineNumber = lnums.tailMap(new Integer(num));\n    if (nextLineNumber.size() == 0) return null;\n    Object key = nextLineNumber.firstKey();\n    if (key == null) return null;\n    return (SourceFileLine) lnums.get(key);\n  }\n"}, {"dataset": "firstKey", "exampleID": 8026, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "firstKey = sortedMap.firstKey()", "focalAPIStart": 249, "focalAPIEnd": 273, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["sortedMap.firstKey()"], "useStart": [330], "useEnd": [354], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/buglabs/bug-osgi/tree/master/com.buglabs.bug.legacy/com/buglabs/util/ServiceFilterGenerator.java", "rawCode": "  /**\n   * (& (prop1=value1) (& (prop2=value1)))\n   *\n   * @param propertiesMap\n   * @return\n   */\n  public static String generatePropertiesFilter(SortedMap propertiesMap) {\n    if (propertiesMap.size() == 1) {\n      return \"(\"\n          + (String) propertiesMap.firstKey()\n          + \"=\"\n          + ((String) propertiesMap.get(propertiesMap.firstKey()))\n          + \")\";\n    } else if (propertiesMap.size() > 1) {\n      return \"(&\"\n          + generatePropertiesFilter(\n              propertiesMap.subMap(propertiesMap.firstKey(), propertiesMap.firstKey() + \"\\0\"))\n          + generatePropertiesFilter(propertiesMap.tailMap(propertiesMap.firstKey() + \"\\0\"))\n          + \")\";\n    }\n    return \"\";\n  }\n"}]