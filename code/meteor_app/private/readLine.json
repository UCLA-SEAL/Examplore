[{"dataset": "readLine", "exampleID": 501, "initialization": ["BufferedReader bufferedReader = new BufferedReader(InputStreamReader)"], "initializationStart": [1080], "initializationEnd": [1109], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1165, "focalAPIEnd": 1182, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["PrintWriter.println(line)"], "useStart": [1190], "useEnd": [1215], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nloreti/ProtoProxyHTTP/tree/master/IlMarseProxy/src/main/java/filterManager/FilterManager.java", "rawCode": "  public static void main(String[] args) throws IOException {\n\n    // args\n    if (args.length != 2) // Test for correct # of\n    throw new IllegalArgumentException(\"Parameter(s): <Server> [<Port>]\");\n\n    // Server name or IP address\n    String server = args[0];\n\n    // Convert argument String to bytes using the default character encoding\n    int servPort = Integer.parseInt(args[1]);\n\n    // Create socket that is connected to server on specified port\n    Socket socket = new Socket(InetAddress.getByName(server), servPort);\n    System.out.println(\"Connected to server...\");\n\n    // InputStream in = socket.getInputStream();\n    // OutputStream out = socket.getOutputStream();\n    BufferedReader fromServer = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n    PrintWriter toServer = new PrintWriter(socket.getOutputStream(), true);\n    String curLine = \"\"; // Line read from standard in\n    System.out.println(\"Enter a line of text (type 'quit' to exit): \");\n    InputStreamReader converter = new InputStreamReader(System.in);\n    BufferedReader termIn = new BufferedReader(converter);\n    while (!curLine.equals(\"EXIT\")) {\n      curLine = termIn.readLine();\n      toServer.println(curLine);\n      // // Send the encoded string to the server\n      // out.write(curLine.getBytes(\"UTF-16LE\"));\n      //\n      // // Receive the response from the server\n      // byte[] data = new byte[50];\n      // // Bytes received in last read\n      // System.out.println(\"readin\");\n      // if (in.read(data) == -1)\n      // throw new SocketException(\"Connection closed prematurely\");\n      System.out.print(fromServer.readLine().replace('\\64', '\\n'));\n      System.out.println();\n    }\n    // Close the socket and its streams\n    socket.close();\n  }\n"}, {"dataset": "readLine", "exampleID": 502, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [126], "initializationEnd": [173], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 232, "focalAPIEnd": 245, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(line)", "bufferedReader.close()"], "useStart": [215, 292], "useEnd": [246, 302], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/domdorn/Jailer/tree/master/src/main/net/sf/jailer/ui/ExtractionModelFrame.java", "rawCode": "  /** Initializes the \"step time\" menu items. */\n  private void initAnimationSteptime() {\n    try {\n      BufferedReader in = new BufferedReader(new FileReader(\".steptime\"));\n      try {\n        animationStepTime = Integer.parseInt(in.readLine());\n      } catch (Exception e) {\n      }\n      in.close();\n    } catch (FileNotFoundException e) {\n    } catch (IOException e) {\n    }\n    switch (animationStepTime) {\n      case 0:\n        steptime0.setSelected(true);\n        break;\n      case 10:\n        steptime10.setSelected(true);\n        break;\n      case 20:\n        steptime20.setSelected(true);\n        break;\n      case 30:\n        steptime30.setSelected(true);\n        break;\n      case 50:\n        steptime50.setSelected(true);\n        break;\n      case 75:\n        steptime75.setSelected(true);\n        break;\n      case 100:\n        steptime100.setSelected(true);\n        break;\n      case 200:\n        steptime200.setSelected(true);\n        break;\n      case 500:\n        steptime500.setSelected(true);\n        break;\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 503, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [489], "initializationEnd": [548], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 570, "focalAPIEnd": 583, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.close()", "line.contains(*)"], "useStart": [589, 617], "useEnd": [599, 669], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/razie/razpub/tree/master/src/test/scala/com/razie/pub/lightsoa/test/LightServerSoaAssetsTest.java", "rawCode": "  /**\n   * test the SOA simple echo via the proper URL reader (check implementation as a proper http\n   * server)\n   */\n  public void testSoaEchoUrl() throws IOException, InterruptedException {\n    // send echo command\n    URL url =\n        new URL(\n            \"http://localhost:\"\n                + PORT\n                + \"/lightsoa/asset/\"\n                + PK\n                + \"/play?movie=\"\n                + LocalSoaAssetsTest.MOVIEKEY.toUrlEncodedString());\n    BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n    String result = in.readLine();\n    in.close();\n\n    assertTrue(result.contains(LocalSoaAssetsTest.MOVIEKEY.getId()));\n  }\n"}, {"dataset": "readLine", "exampleID": 504, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 286, "tryExpressionEnd": 290, "tryBlockStart": 286, "tryBlockEnd": 1392, "catchExpressionStart": 1320, "catchExpressionEnd": 1341, "catchBlockStart": 1320, "catchBlockEnd": 1392, "exceptionHandlingCallStart": [1351], "exceptionHandlingCallEnd": [1383], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 929, "focalAPIEnd": 942, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MitchJust/Kabouter/tree/master/kabouter-server/src/main/java/com/unicornlabs/kabouter/devices/test/TestDevice.java", "rawCode": "  public static void handleCommand(String command) {\n    if (command.equals(\"quit\")) {\n      try {\n        mySocket.close();\n        System.exit(0);\n      } catch (IOException ex) {\n        System.out.println(\"ex = \" + ex);\n      }\n    } else if (command.startsWith(\"connect\")) {\n      try {\n\n        String[] split = command.split(\" \");\n\n        if (split.length == 3) {\n\n          mySocket = new Socket(InetAddress.getByName(split[1]), Integer.parseInt(split[2]));\n        } else {\n          mySocket = new Socket(InetAddress.getLocalHost(), 4555);\n        }\n\n        System.out.println(\"Connection Established\");\n\n        socketin = new BufferedReader(new InputStreamReader(mySocket.getInputStream()));\n        socketout = new PrintWriter(new OutputStreamWriter(mySocket.getOutputStream()));\n\n        DeviceServerMessage newMessage = new DeviceServerMessage();\n\n        System.out.print(\"Device Id: \");\n        String devId = br.readLine();\n\n        newMessage.messageType = DeviceServerMessage.DEVICE_CONFIG;\n        newMessage.data = devId + \":KABOUTER_TEST_DEVICE\";\n\n        String jsonString = JSONUtils.ToJSON(newMessage);\n\n        System.out.println(\"Sending Config Message\");\n\n        System.out.println(\"jsonString = \" + jsonString);\n\n        mySocket.getOutputStream().write(jsonString.getBytes());\n\n      } catch (Exception ex) {\n        System.out.println(\"ex = \" + ex);\n      }\n    } else if (command.startsWith(\"changeio\")) {\n      try {\n        String[] split = command.split(\" \");\n        int newValue = Integer.parseInt(split[1]);\n\n        Integer[] newIo = new Integer[] {newValue, newValue};\n\n        DeviceServerMessage newMessage = new DeviceServerMessage();\n        newMessage.data = JSONUtils.ToJSON(newIo);\n        newMessage.messageType = DeviceServerMessage.IO_STATE_UPDATE;\n\n        String jsonString = JSONUtils.ToJSON(newMessage);\n\n        System.out.println(\"Sending IO Change Message\");\n\n        mySocket.getOutputStream().write(jsonString.getBytes());\n\n        String newIOMessage = socketin.readLine();\n\n        System.out.println(\"newIOMessage = \" + newIOMessage);\n        ServerDeviceMessage FromJSON = JSONUtils.FromJSON(newIOMessage, ServerDeviceMessage.class);\n        Integer[] newIOStates = JSONUtils.FromJSON(FromJSON.data, Integer[].class);\n\n        System.out.println(\"newIOStates = \" + newIOStates[0] + \", \" + newIOStates[1]);\n\n      } catch (IOException ex) {\n        System.out.println(\"ex = \" + ex);\n      } catch (com.google.gson.JsonSyntaxException jex) {\n        System.out.println(\"Exception: \" + jex);\n      }\n    } else if (command.startsWith(\"generatepower\")) {\n\n      String[] split = command.split(\" \");\n      int newValue = Integer.parseInt(split[1]);\n\n      myPowerGenerator = new PowerGenerator(newValue, mySocket);\n      myPowerGenerator.start();\n\n    } else if (command.startsWith(\"setbase\")) {\n\n      String[] split = command.split(\" \");\n      int newValue = Integer.parseInt(split[1]);\n\n      myPowerGenerator.setBaseLevel(newValue);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 505, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [592], "initializationEnd": [653], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["toLongString()", "new BuildException(String)"], "tryExpressionStart": 782, "tryExpressionEnd": 786, "tryBlockStart": 782, "tryBlockEnd": 1301, "catchExpressionStart": 999, "catchExpressionEnd": 1023, "catchBlockStart": 999, "catchBlockEnd": 1100, "exceptionHandlingCallStart": [1076, 1037], "exceptionHandlingCallEnd": [1092, 1093], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 804, "focalAPIEnd": 817, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 826, "followUpCheckExpressionEnd": 849, "followUpCheckBlockStart": 826, "followUpCheckBlockEnd": 971, "use": ["bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [949, 1159], "useEnd": [962, 1169], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1101, "finallyExpressionEnd": 1109, "finallyBlockStart": 1101, "finallyBlockEnd": 1301, "cleanUpCallStart": [1159], "cleanUpCallEnd": [1169], "url": "https://github.com/and146/SPLAT-ARI/tree/master/ant/src/main/org/apache/tools/ant/types/selectors/ContainsRegexpSelector.java", "rawCode": "  /**\n   * Tests a regular expression against each line of text in a Resource.\n   *\n   * @param r the Resource to check.\n   * @return whether the Resource is selected or not\n   */\n  public boolean isSelected(Resource r) {\n    String teststr = null;\n    BufferedReader in = null;\n\n    // throw BuildException on error\n\n    validate();\n\n    if (r.isDirectory()) {\n      return true;\n    }\n\n    if (myRegExp == null) {\n      myRegExp = new RegularExpression();\n      myRegExp.setPattern(userProvidedExpression);\n      myExpression = myRegExp.getRegexp(getProject());\n    }\n\n    try {\n      in = new BufferedReader(new InputStreamReader(r.getInputStream()));\n    } catch (Exception e) {\n      throw new BuildException(\"Could not get InputStream from \" + r.toLongString(), e);\n    }\n    try {\n      teststr = in.readLine();\n\n      while (teststr != null) {\n\n        if (myExpression.matches(teststr)) {\n          return true;\n        }\n        teststr = in.readLine();\n      }\n\n      return false;\n    } catch (IOException ioe) {\n      throw new BuildException(\"Could not read \" + r.toLongString());\n    } finally {\n      if (in != null) {\n        try {\n          in.close();\n        } catch (Exception e) {\n          throw new BuildException(\"Could not close \" + r.toLongString());\n        }\n      }\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 506, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 176, "focalAPIEnd": 190, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 198, "followUpCheckExpressionEnd": 212, "followUpCheckBlockStart": 198, "followUpCheckBlockEnd": 220, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/halset/openmap/tree/master/src/main/java/com/bbn/openmap/layer/e00/E00Parser.java", "rawCode": "  /**\n   * read PRJ records (in fact does nothing)\n   *\n   * @exception IOException\n   * @since\n   */\n  void readPRJ() throws IOException {\n    while (true) {\n      String S = isr.readLine();\n      if (S == null) return;\n      if (S.startsWith(\"EOP\")) return;\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 507, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [770], "initializationEnd": [824], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 871, "focalAPIEnd": 884, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(String,line)", "bufferedReader.readLine()", "assertEquals(String,line)", "bufferedReader.readLine()", "assertEquals(*,line)", "bufferedReader.close()", "bufferedReader.readLine()", "assertEquals(String,line)", "bufferedReader.readLine()", "assertEquals(String,line)", "bufferedReader.readLine()", "assertEquals(*,line)", "bufferedReader.close()"], "useStart": [832, 933, 893, 974, 955, 996, 1123, 1083, 1186, 1145, 1227, 1208, 1249], "useEnd": [885, 946, 947, 987, 988, 1006, 1136, 1137, 1199, 1200, 1240, 1241, 1259], "hasFinally": 1, "cleanUpCall": ["File.delete()", "File.delete()"], "finallyExpressionStart": 2222, "finallyExpressionEnd": 2230, "finallyBlockStart": 2222, "finallyBlockEnd": 2308, "cleanUpCallStart": [2238, 2273], "cleanUpCallEnd": [2265, 2301], "url": "https://github.com/nourlcn/yarn-comment/tree/master/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/loadGenerator/TestLoadGenerator.java", "rawCode": "  /** Test if the structure generator works fine */\n  @Test\n  public void testStructureGenerator() throws Exception {\n    StructureGenerator sg = new StructureGenerator();\n    String[] args =\n        new String[] {\n          \"-maxDepth\",\n          \"2\",\n          \"-minWidth\",\n          \"1\",\n          \"-maxWidth\",\n          \"2\",\n          \"-numOfFiles\",\n          \"2\",\n          \"-avgFileSize\",\n          \"1\",\n          \"-outDir\",\n          OUT_DIR,\n          \"-seed\",\n          \"1\"\n        };\n\n    final int MAX_DEPTH = 1;\n    final int MIN_WIDTH = 3;\n    final int MAX_WIDTH = 5;\n    final int NUM_OF_FILES = 7;\n    final int AVG_FILE_SIZE = 9;\n    final int SEED = 13;\n    try {\n      // successful case\n      assertEquals(0, sg.run(args));\n      BufferedReader in = new BufferedReader(new FileReader(DIR_STRUCTURE_FILE));\n      assertEquals(DIR_STRUCTURE_FIRST_LINE, in.readLine());\n      assertEquals(DIR_STRUCTURE_SECOND_LINE, in.readLine());\n      assertEquals(null, in.readLine());\n      in.close();\n\n      in = new BufferedReader(new FileReader(FILE_STRUCTURE_FILE));\n      assertEquals(FILE_STRUCTURE_FIRST_LINE, in.readLine());\n      assertEquals(FILE_STRUCTURE_SECOND_LINE, in.readLine());\n      assertEquals(null, in.readLine());\n      in.close();\n\n      String oldArg = args[MAX_DEPTH];\n      args[MAX_DEPTH] = \"0\";\n      assertEquals(-1, sg.run(args));\n      args[MAX_DEPTH] = oldArg;\n\n      oldArg = args[MIN_WIDTH];\n      args[MIN_WIDTH] = \"-1\";\n      assertEquals(-1, sg.run(args));\n      args[MIN_WIDTH] = oldArg;\n\n      oldArg = args[MAX_WIDTH];\n      args[MAX_WIDTH] = \"-1\";\n      assertEquals(-1, sg.run(args));\n      args[MAX_WIDTH] = oldArg;\n\n      oldArg = args[NUM_OF_FILES];\n      args[NUM_OF_FILES] = \"-1\";\n      assertEquals(-1, sg.run(args));\n      args[NUM_OF_FILES] = oldArg;\n\n      oldArg = args[NUM_OF_FILES];\n      args[NUM_OF_FILES] = \"-1\";\n      assertEquals(-1, sg.run(args));\n      args[NUM_OF_FILES] = oldArg;\n\n      oldArg = args[AVG_FILE_SIZE];\n      args[AVG_FILE_SIZE] = \"-1\";\n      assertEquals(-1, sg.run(args));\n      args[AVG_FILE_SIZE] = oldArg;\n\n      oldArg = args[SEED];\n      args[SEED] = \"34.d4\";\n      assertEquals(-1, sg.run(args));\n      args[SEED] = oldArg;\n    } finally {\n      DIR_STRUCTURE_FILE.delete();\n      FILE_STRUCTURE_FILE.delete();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 508, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [1843], "initializationEnd": [1895], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 1811, "tryExpressionEnd": 1815, "tryBlockStart": 1811, "tryBlockEnd": 2600, "catchExpressionStart": 2544, "catchExpressionEnd": 2566, "catchBlockStart": 2544, "catchBlockEnd": 2600, "exceptionHandlingCallStart": [2574], "exceptionHandlingCallEnd": [2593], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 2031, "focalAPIEnd": 2044, "followUpCheck": "line.trim().equals(\"\")", "checkType": "IF", "followUpCheckExpressionStart": 2126, "followUpCheckExpressionEnd": 2185, "followUpCheckBlockStart": 2126, "followUpCheckBlockEnd": 2228, "use": ["valueOf(line)"], "useStart": [2277], "useEnd": [2299], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jponge/izpack-full-svn-history-copy/tree/master/izpack-src/tags/4.3.2/src/lib/com/izforge/izpack/panels/UserInputPanelConsoleHelper.java", "rawCode": "  boolean processComboRadioField(\n      Input input,\n      AutomatedInstallData idata) { // TODO protection if selection not valid and no set value\n    String variable = input.strVariableName;\n    if ((variable == null) || (variable.length() == 0)) {\n      return false;\n    }\n    String currentvariablevalue = idata.getVariable(variable);\n    boolean userinput = false;\n\n    // display the description for this combo or radio field\n    if (input.strText != null) {\n      System.out.println(input.strText);\n    }\n\n    List<Choice> lisChoices = input.listChoices;\n    if (lisChoices.size() == 0) {\n      Debug.trace(\"Error: no spec element defined in file field\");\n      return false;\n    }\n    if (currentvariablevalue != null) {\n      userinput = true;\n    }\n    for (int i = 0; i < lisChoices.size(); i++) {\n      Choice choice = lisChoices.get(i);\n      String value = choice.strValue;\n      // if the choice value is provided via a property to the process, then\n      // set it as the selected choice, rather than defaulting to what the\n      // spec defines.\n      if (userinput) {\n        if ((value != null) && (value.length() > 0) && (currentvariablevalue.equals(value))) {\n          input.iSelectedChoice = i;\n        }\n      } else {\n        String set = choice.strSet;\n        if (set != null) {\n          if (set != null && !\"\".equals(set)) {\n            VariableSubstitutor vs = new VariableSubstitutor(idata.getVariables());\n            set = vs.substitute(set, null);\n          }\n          if (set.equals(TRUE)) {\n            input.iSelectedChoice = i;\n          }\n        }\n      }\n      System.out.println(\n          i\n              + \" [\"\n              + (input.iSelectedChoice == i ? \"x\" : \" \")\n              + \"] \"\n              + (choice.strText != null ? choice.strText : \"\"));\n    }\n\n    try {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n      boolean bKeepAsking = true;\n\n      while (bKeepAsking) {\n        System.out.println(\"input selection:\");\n        String strIn = br.readLine();\n        // take default value if default value exists and no user input\n        if (strIn.trim().equals(\"\") && input.iSelectedChoice != -1) {\n          bKeepAsking = false;\n        }\n        int j = -1;\n        try {\n          j = Integer.valueOf(strIn).intValue();\n        } catch (Exception ex) {\n        }\n        // take user input if user input is valid\n        if (j >= 0 && j < lisChoices.size()) {\n          input.iSelectedChoice = j;\n          bKeepAsking = false;\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    idata.setVariable(variable, input.listChoices.get(input.iSelectedChoice).strValue);\n    return true;\n  }\n"}, {"dataset": "readLine", "exampleID": 509, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()", "exit(int)"], "tryExpressionStart": 241, "tryExpressionEnd": 245, "tryBlockStart": 241, "tryBlockEnd": 862, "catchExpressionStart": 719, "catchExpressionEnd": 739, "catchBlockStart": 719, "catchBlockEnd": 862, "exceptionHandlingCallStart": [814, 841], "exceptionHandlingCallEnd": [833, 855], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 283, "focalAPIEnd": 297, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [549, 700], "useEnd": [563, 711], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bitsteller/crypto-praktikum/tree/master/04_ElGamal/src/task4/ElGamalCipher.java", "rawCode": "  /**\n   * Liest den Schlüssel mit dem Reader <code>key</code>.\n   *\n   * @param key Der Reader, der aus der Schlüsseldatei liest.\n   * @see #makeKey makeKey\n   * @see #writeKey writeKey\n   */\n  public void readKey(BufferedReader key) {\n    try {\n\n      {\n        String in_public = key.readLine();\n        BufferedReader in = new BufferedReader(new FileReader(in_public));\n\n        q = new BigInteger(in.readLine());\n        g = new BigInteger(in.readLine());\n        y = new BigInteger(in.readLine());\n      }\n\n      {\n        String in_private = key.readLine();\n        BufferedReader in = new BufferedReader(new FileReader(in_private));\n\n        x = new BigInteger(in.readLine());\n      }\n\n      key.close();\n    } catch (Exception e) {\n      // let's try to exit graceffuuuuOHSHIKILLITWITHFIREOMGOMGOMG\n      e.printStackTrace();\n      System.exit(1);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 510, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [84], "initializationEnd": [136], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 157, "focalAPIEnd": 170, "followUpCheck": "!line.trim().equals(\"#\")", "checkType": "LOOP {", "followUpCheckExpressionStart": 229, "followUpCheckExpressionEnd": 262, "followUpCheckBlockStart": 229, "followUpCheckBlockEnd": 389, "use": ["line.toCharArray()", "bufferedReader.readLine()", "bufferedReader.readLine()", "bufferedReader.readLine()"], "useStart": [282, 369, 402, 813], "useEnd": [301, 382, 415, 826], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pierreetienne/gnu-maraton/tree/master/VamosAhoraSi/src/Uva895.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    String linea = in.readLine();\n    ArrayList<String> dic = new ArrayList<String>();\n    while (!linea.trim().equals(\"#\")) {\n      char[] x = linea.toCharArray();\n      Arrays.sort(x);\n      dic.add(new String(x));\n      linea = in.readLine();\n    }\n    linea = in.readLine();\n    while (!linea.trim().equals(\"#\")) {\n      char[] l = new char[(linea.length() / 2) + 1];\n      for (int i = 0, j = 0; i < linea.length(); i += 2, j++) l[j] = linea.charAt(i);\n      Arrays.sort(l);\n      String pal = new String(l);\n      char[] aux = new String(l).toCharArray();\n      int cont = 0;\n      for (int i = 0; i < dic.size(); ++i) {}\n\n      System.out.println(cont);\n      linea = in.readLine();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 511, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new ExecutionError(String)"], "tryExpressionStart": 71, "tryExpressionEnd": 75, "tryBlockStart": 71, "tryBlockEnd": 190, "catchExpressionStart": 112, "catchExpressionEnd": 134, "catchBlockStart": 112, "catchBlockEnd": 190, "exceptionHandlingCallStart": [148], "exceptionHandlingCallEnd": [183], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 87, "focalAPIEnd": 104, "followUpCheck": "line.equals(\"no\")", "checkType": "IF", "followUpCheckExpressionStart": 195, "followUpCheckExpressionEnd": 214, "followUpCheckBlockStart": 195, "followUpCheckBlockEnd": 362, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pfirpfel/iml-compiler/tree/master/src/ch/fhnw/lederer/virtualmachineHS2010/VirtualMachine.java", "rawCode": "  public boolean readYesNo() throws ExecutionError {\n    String s;\n    try {\n      s = reader.readLine();\n    } catch (IOException e) {\n      throw new ExecutionError(\"Input failed.\");\n    }\n    if (s.equals(\"no\")) {\n      return false;\n    } else if (s.equals(\"yes\")) {\n      return true;\n    } else {\n      throw new ExecutionError(\"Not 'yes' or 'no'.\");\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 512, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [141], "initializationEnd": [187], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 273, "focalAPIEnd": 286, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 292, "followUpCheckExpressionEnd": 311, "followUpCheckBlockStart": 292, "followUpCheckBlockEnd": 499, "use": ["Map<String, Integer>.get(line)", "Map<String, Integer>.put(line,int)", "put(line,*)", "bufferedReader.readLine()"], "useStart": [336, 388, 431, 479], "useEnd": [351, 406, 457, 492], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/javajigi/slipp-java/tree/master/java-api/test/net/slipp/thread/SynchronizedResultTest.java", "rawCode": "  public void testResult() throws Exception {\n    FileInputStream fis = new FileInputStream(\"resources/result.txt\");\n    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n\n    Map<String, Integer> result = new HashMap<String, Integer>();\n    String key = br.readLine();\n    while (key != null) {\n      Integer value = result.get(key);\n      if (value == null) {\n        result.put(key, 1);\n      } else {\n        result.put(key, value + 1);\n      }\n      key = br.readLine();\n    }\n\n    Set<String> keys = result.keySet();\n    for (String each : keys) {\n      Integer value = result.get(each);\n      if (value > 1) {\n        System.out.println(\"index : \" + each + \" count : \" + value);\n      }\n    }\n\n    fis.close();\n  }\n"}, {"dataset": "readLine", "exampleID": 513, "initialization": ["BufferedReader bufferedReader = bufferStream(*)"], "initializationStart": [1409], "initializationEnd": [1458], "hasTryCatch": 1, "exceptionType": "TasteException", "exceptionHandlingCall": [], "tryExpressionStart": 1472, "tryExpressionEnd": 1476, "tryBlockStart": 1472, "tryBlockEnd": 1607, "catchExpressionStart": 1999, "catchExpressionEnd": 2025, "catchBlockStart": 1999, "catchBlockEnd": 2145, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1520, "focalAPIEnd": 1537, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseFloat(line)", "bufferedReader.close()"], "useStart": [1499, 1578], "useEnd": [1538, 1592], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1554, "finallyExpressionEnd": 1562, "finallyBlockStart": 1554, "finallyBlockEnd": 1607, "cleanUpCallStart": [1578], "cleanUpCallEnd": [1592], "url": "https://github.com/myrrix/myrrix-recommender/tree/master/client/src/net/myrrix/client/ClientRecommender.java", "rawCode": "  public float estimateForAnonymous(\n      long toItemID, long[] itemIDs, float[] values, Long contextUserID) throws TasteException {\n    Preconditions.checkArgument(\n        values == null || values.length == itemIDs.length,\n        \"Number of values doesn't match number of items\");\n    StringBuilder urlPath = new StringBuilder(32);\n    urlPath.append(\"/estimateForAnonymous/\");\n    urlPath.append(toItemID);\n    for (int i = 0; i < itemIDs.length; i++) {\n      urlPath.append('/').append(itemIDs[i]);\n      if (values != null) {\n        urlPath.append('=').append(values[i]);\n      }\n    }\n\n    // Requests are typically partitioned by user, but this request does not directly depend on a\n    // user.\n    // If a user ID is supplied anyway, use it for partitioning since it will follow routing for\n    // other\n    // requests related to that user. Otherwise just partition on the \"to\" item ID, which is at\n    // least\n    // deterministic.\n    long idToPartitionOn = contextUserID == null ? toItemID : contextUserID;\n\n    TasteException savedException = null;\n    for (HostAndPort replica : choosePartitionAndReplicas(idToPartitionOn)) {\n      HttpURLConnection connection = null;\n      try {\n        connection = buildConnectionToReplica(replica, urlPath.toString(), \"GET\");\n        switch (connection.getResponseCode()) {\n          case HttpURLConnection.HTTP_OK:\n            BufferedReader reader = IOUtils.bufferStream(connection.getInputStream());\n            try {\n              return LangUtils.parseFloat(reader.readLine());\n            } finally {\n              reader.close();\n            }\n          case HttpURLConnection.HTTP_NOT_FOUND:\n            throw new NoSuchItemException(Arrays.toString(itemIDs) + ' ' + toItemID);\n          case HttpURLConnection.HTTP_UNAVAILABLE:\n            throw new NotReadyException();\n          default:\n            throw new TasteException(\n                connection.getResponseCode() + \" \" + connection.getResponseMessage());\n        }\n      } catch (TasteException te) {\n        log.info(\"Can't access {} at {}: ({})\", urlPath, replica, te.toString());\n        savedException = te;\n      } catch (IOException ioe) {\n        log.info(\"Can't access {} at {}: ({})\", urlPath, replica, ioe.toString());\n        savedException = new TasteException(ioe);\n      } finally {\n        if (connection != null) {\n          connection.disconnect();\n        }\n      }\n    }\n    throw savedException;\n  }\n"}, {"dataset": "readLine", "exampleID": 514, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [825], "initializationEnd": [884], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 913, "focalAPIEnd": 926, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["createProviderInstance(line,ClassLoader)", "bufferedReader.close()", "createProviderInstance(line,ClassLoader)", "createProviderInstance(line,ClassLoader)", "setProperty(*,line)"], "useStart": [949, 1194, 1752, 2061, 2545], "useEnd": [999, 1204, 1802, 2111, 2602], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1124, "finallyExpressionEnd": 1132, "finallyBlockStart": 1124, "finallyBlockEnd": 1279, "cleanUpCallStart": [1194], "cleanUpCallEnd": [1204], "url": "https://github.com/eclipse/virgo.eclipse-mirror/tree/master/hotfix/source/openejb-core_4.5.2/src/main/java/org/apache/openejb/core/webservices/ProviderWrapper.java", "rawCode": "  private static Provider findProvider() {\n    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n    if (classLoader == null) classLoader = ClassLoader.getSystemClassLoader();\n\n    // 0. System.getProperty(\"openejb.javax.xml.ws.spi.Provider\")\n    // This is so those using old axis rules still work as expected\n    String providerClass = System.getProperty(\"openejb.\" + JAXWSPROVIDER_PROPERTY);\n    Provider provider = createProviderInstance(providerClass, classLoader);\n    if (provider != null) {\n      return provider;\n    }\n\n    // 1. META-INF/services/javax.xml.ws.spi.Provider\n    try {\n      for (final URL url :\n          Collections.list(\n              classLoader.getResources(\"META-INF/services/\" + JAXWSPROVIDER_PROPERTY))) {\n        BufferedReader in = null;\n        try {\n          in = new BufferedReader(new InputStreamReader(url.openStream()));\n\n          providerClass = in.readLine();\n          provider = createProviderInstance(providerClass, classLoader);\n          if (provider != null) {\n            return provider;\n          }\n        } catch (Exception ignored) {\n        } finally {\n          if (in != null) {\n            try {\n              in.close();\n            } catch (IOException e) {\n            }\n          }\n        }\n      }\n    } catch (Exception ingored) {\n    }\n\n    // 2. $java.home/lib/jaxws.properties\n    final String javaHome = System.getProperty(\"java.home\");\n    final File jaxrpcPropertiesFile = new File(new File(javaHome, \"lib\"), \"jaxrpc.properties\");\n    if (jaxrpcPropertiesFile.exists()) {\n      try {\n        final Properties properties = IO.readProperties(jaxrpcPropertiesFile);\n\n        providerClass = properties.getProperty(JAXWSPROVIDER_PROPERTY);\n        provider = createProviderInstance(providerClass, classLoader);\n        if (provider != null) {\n          return provider;\n        }\n      } catch (Exception ignored) {\n      }\n    }\n\n    // 3. System.getProperty(\"javax.xml.ws.spi.Provider\")\n    providerClass = System.getProperty(JAXWSPROVIDER_PROPERTY);\n    provider = createProviderInstance(providerClass, classLoader);\n    if (provider != null) {\n      return provider;\n    }\n\n    // 4. Use javax.xml.ws.spi.Provider default\n    try {\n      System.getProperties().remove(JAXWSPROVIDER_PROPERTY);\n      provider = Provider.provider();\n      if (provider != null\n          && !provider.getClass().getName().equals(ProviderWrapper.class.getName())) {\n        return provider;\n      }\n    } finally {\n      // restore original jax provider property\n      System.setProperty(JAXWSPROVIDER_PROPERTY, providerClass);\n    }\n\n    throw new WebServiceException(\"No \" + JAXWSPROVIDER_PROPERTY + \" implementation found\");\n  }\n"}, {"dataset": "readLine", "exampleID": 515, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [897], "initializationEnd": [960], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "log(*,String,*)"], "tryExpressionStart": 248, "tryExpressionEnd": 252, "tryBlockStart": 248, "tryBlockEnd": 1797, "catchExpressionStart": 1709, "catchExpressionEnd": 1730, "catchBlockStart": 1709, "catchBlockEnd": 1797, "exceptionHandlingCallStart": [1770, 1738], "exceptionHandlingCallEnd": [1785, 1790], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1056, "focalAPIEnd": 1073, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 1085, "followUpCheckExpressionEnd": 1102, "followUpCheckBlockStart": 1085, "followUpCheckBlockEnd": 1135, "use": ["StringBuffer.append(line)", "bufferedReader.close()"], "useStart": [1146, 1182], "useEnd": [1161, 1196], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/visage-lang/netbeans-plugin/tree/master/installer/servicetag-src/org/netbeans/modules/reglib/NbConnectionSupport.java", "rawCode": "  /**\n   * Query web service if given product by instance_urn is registered. Returns true only when we\n   * have 'REGISTERED' response from server. Otherwise return false.\n   */\n  public static boolean isRegistered2(String host, String uuid) {\n    try {\n      URL url = new URL(host + \"/ProductRegistrationService/status/\" + uuid);\n      LOG.log(Level.FINE, \"Query URL: \" + url);\n      // HttpURLConnection con = (HttpURLConnection) (url.openConnection());\n      HttpsURLConnection con = (HttpsURLConnection) (url.openConnection());\n\n      con.setRequestMethod(\"GET\");\n      con.setDoOutput(true);\n      con.setDoInput(true);\n      con.setAllowUserInteraction(false);\n      con.setUseCaches(false);\n\n      con.connect();\n      int responseCode = con.getResponseCode();\n\n      LOG.log(Level.FINE, \"Response code = \" + responseCode);\n      if (responseCode == 200) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n\n        while (true) {\n          String line = reader.readLine();\n          if (line == null) {\n            break;\n          }\n          sb.append(line);\n        }\n\n        reader.close();\n        String response = sb.toString();\n\n        LOG.log(Level.FINE, \"Response: \" + response);\n\n        // the response should be equal to 'REGISTERED' or 'NOT REGISTERED'\n        if (response.equals(\"REGISTERED\")) {\n          return true;\n        } else {\n          return false;\n        }\n      } else if (responseCode == 404) {\n        // response code of 404 is not found, which means not registered\n        return false;\n      } else {\n        // unknown response code\n        return false;\n      }\n    } catch (Exception ex) {\n      LOG.log(Level.FINE, \"Error: \" + ex.getMessage(), ex);\n    }\n    return false;\n  }\n"}, {"dataset": "readLine", "exampleID": 516, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace(*)"], "tryExpressionStart": 29, "tryExpressionEnd": 33, "tryBlockStart": 29, "tryBlockEnd": 132, "catchExpressionStart": 62, "catchExpressionEnd": 86, "catchBlockStart": 62, "catchBlockEnd": 132, "exceptionHandlingCallStart": [94], "exceptionHandlingCallEnd": [125], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 41, "focalAPIEnd": 54, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stumoodie/PathwayEditor/tree/master/libs/antlr-3.4/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventSocketProxy.java", "rawCode": "  protected void ack() {\n    try {\n      in.readLine();\n    } catch (IOException ioe) {\n      ioe.printStackTrace(System.err);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 517, "initialization": ["BufferedReader bufferedReader = new BufferedReader(FileReader)"], "initializationStart": [135], "initializationEnd": [165], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 189, "focalAPIEnd": 206, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.readLine()", "new Row(line,String,String)", "bufferedReader.close()"], "useStart": [228, 332, 378], "useEnd": [245, 365, 392], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/REKURDennis/REKUR/tree/master/REKUR/src/org/glowa/danube/deepactors/util/io/InitFile.java", "rawCode": "  private void parseFile(File file) throws IOException {\n    FileReader fileReader = new FileReader(file);\n    BufferedReader reader = new BufferedReader(fileReader);\n    String firstRow = reader.readLine();\n    String secRow = reader.readLine();\n    String curRow;\n    while ((curRow = reader.readLine()) != null) {\n      rows.add(new Row(firstRow, secRow, curRow));\n    }\n    reader.close();\n    fileReader.close();\n  }\n"}, {"dataset": "readLine", "exampleID": 518, "initialization": ["BufferedReader bufferedReader = new BufferedReader(InputStreamReader)"], "initializationStart": [3851], "initializationEnd": [3883], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 3900, "focalAPIEnd": 3917, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 3928, "followUpCheckExpressionEnd": 3948, "followUpCheckBlockStart": 3928, "followUpCheckBlockEnd": 4091, "use": ["line.trim()", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [3968, 4063, 4213], "useEnd": [3979, 4080, 4227], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 4159, "finallyExpressionEnd": 4167, "finallyBlockStart": 4159, "finallyBlockEnd": 4286, "cleanUpCallStart": [4213], "cleanUpCallEnd": [4227], "url": "https://github.com/jponge/izpack-full-svn-history-copy/tree/master/izpack-src/tags/milestone-3-8-0-M1/src/lib/com/izforge/izpack/util/TargetFactory.java", "rawCode": "  /**\n   * Returns the system dependent default install path. This is typically used to suggest an istall\n   * path to the end user, when performing an installation. The default install path is assembled\n   * form the OS specific path fragment specified in <code>INSTALL_PATH_FRAGMENT</code>, possibly a\n   * drive letter and the application name. The user the option to define resources that define\n   * default paths which differ from the path fragments defined here. The following resource names\n   * will be recognized by this method: <br>\n   * <br>\n   *\n   * <ul>\n   *   <li><code>TargetPanel.dir.windows</code>\n   *   <li><code>TargetPanel.dir.macosx</code>\n   *   <li><code>TargetPanel.dir.unix</code>\n   *   <li><code>TargetPanel.dir</code> plus the all lower case version of <code>\n   *       System.getProperty (\"os.name\")</code>, with all spaces replaced by an underscore ('_').\n   *   <li><code>TargetPanel.dir</code>\n   * </ul>\n   *\n   * @param appName the name of the application to install. If no specific resource has been set,\n   *     then this name will be appended to the OS specific default path fragment.\n   * @return the default install path for the target system\n   */\n  /*--------------------------------------------------------------------------*/\n  /*\n   * $ @design\n   *\n   * First try to read a path string from a resource file. This approach allows the user to\n   * customize the default install path that is suggested to the end user by IzPack. There are a\n   * number of choices for the naming of this resource, so we need to go through a few steps in\n   * order to exhaust the different possibilities. If this was not successful we use the default\n   * install path that is defined for the operating system we are running on. This path should be\n   * expanded by the application name to form the full path that to returne.\n   * --------------------------------------------------------------------------\n   */\n  public String getDefaultInstallPath(String appName) {\n    String path = null;\n    InputStream input;\n    String keyFragment = \"/res/\" + INSTALL_PATH_RESOURCE_KEY[GENERIC][STANDARD];\n\n    // ----------------------------------------------------\n    // attempt to get an input stream through a resource\n    // based on a key which is specific to the target OS\n    // ----------------------------------------------------\n    input = getClass().getResourceAsStream(\"/res/\" + INSTALL_PATH_RESOURCE_KEY[os][osFlavor]);\n\n    // ----------------------------------------------------\n    // attempt to get an input stream through a resource\n    // based on a key which is made specific to the target\n    // OS by using the string returned by\n    // System.getProperty (\"os.name\").toLowerCase ()\n    // ----------------------------------------------------\n    if (input == null) {\n      String key = OsVersion.OS_NAME.toLowerCase().replace(' ', '_'); // avoid\n      // spaces\n      // in\n      // file\n      // names\n      key = keyFragment + key.toLowerCase(); // for consistency among\n      // TargetPanel res files\n      input = TargetFactory.class.getResourceAsStream(key);\n    }\n\n    // ----------------------------------------------------\n    // attempt to get an input stream through a resource\n    // based on a key which is not specific to any target OS\n    // ----------------------------------------------------\n    if (input == null) {\n      input = TargetFactory.class.getResourceAsStream(keyFragment);\n    }\n\n    // ----------------------------------------------------\n    // If we got an input stream try to read the path\n    // from the file\n    // ----------------------------------------------------\n    if (input != null) {\n      InputStreamReader streamReader;\n      BufferedReader reader = null;\n      String line;\n\n      try {\n        streamReader = new InputStreamReader(input);\n        reader = new BufferedReader(streamReader);\n        line = reader.readLine();\n\n        while (line != null) {\n          line = line.trim();\n          if (!line.equals(\"\")) {\n            break;\n          }\n          line = reader.readLine();\n        }\n        path = line;\n      } catch (Throwable exception) {\n      } finally {\n        try {\n          if (reader != null) reader.close();\n        } catch (Throwable exception) {\n        }\n      }\n    }\n\n    // ----------------------------------------------------\n    // if we were unable to obtain a path from a resource,\n    // use the default for the traget operating system.\n    // ----------------------------------------------------\n    if (path == null || path.equals(\"\")) {\n      path = \"\";\n\n      // --------------------------------------------------\n      // if we run on windows, we need a valid drive letter\n      // to put in front of the path. The drive that\n      // contains the user's home directory is usually the\n      // drive that also contains the install directory,\n      // so this seems the best choice here.\n      // --------------------------------------------------\n      if (os == WINDOWS) {\n        String home = System.getProperty(\"user.home\");\n        // take everything up to and including the first '\\'\n        path = home.substring(0, home.indexOf(File.separatorChar) + 1);\n      }\n\n      path = path + INSTALL_PATH_FRAGMENT[os] + appName;\n    }\n\n    return path;\n  }\n"}, {"dataset": "readLine", "exampleID": 519, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [256], "initializationEnd": [303], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 349, "focalAPIEnd": 366, "followUpCheck": "line.contains(KEY)", "checkType": "IF", "followUpCheckExpressionStart": 389, "followUpCheckExpressionEnd": 412, "followUpCheckBlockStart": 389, "followUpCheckBlockEnd": 654, "use": ["line.indexOf(String)", "line.indexOf(String)", "line.substring(int,int)", "bufferedReader.close()"], "useStart": [477, 545, 596, 673], "useEnd": [500, 566, 622, 687], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rdpfeffer/IMAT/tree/master/cli/Ginsu/src/main/java/com/intuit/tools/imat/system/SystemReflectionService.java", "rawCode": "  public String getSystemInstrumentsVersion() {\n    String versionString = \"\";\n    File versionFile = new File(DEFAULT_INSTRUMENTS_LOCATION + File.separator + VERSION_PLIST_PATH);\n    if (versionFile.exists()) {\n      try {\n        BufferedReader reader = new BufferedReader(new FileReader(versionFile));\n        String line;\n        while ((line = reader.readLine()) != null) {\n          if (line.contains(KEY)) {\n            line = reader.readLine();\n            int start = line.indexOf(START_TAG) + START_TAG.length();\n            int end = line.indexOf(END_TAG);\n            versionString = line.substring(start, end);\n            break;\n          }\n        }\n        reader.close();\n      } catch (FileNotFoundException e) {\n        // ignore the error.\n      } catch (IOException e) {\n        // ignore the error.\n      }\n    }\n    // TODO Else use the PropertyConfigurationService to get the path to\n    // Instruments that we would like to use.\n    return versionString;\n  }\n"}, {"dataset": "readLine", "exampleID": 520, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 194, "focalAPIEnd": 219, "followUpCheck": "line != null", "checkType": "IF", "followUpCheckExpressionStart": 361, "followUpCheckExpressionEnd": 380, "followUpCheckBlockStart": 361, "followUpCheckBlockEnd": 404, "use": ["line.trim()"], "useStart": [390], "useEnd": [403], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SiteView/NEWECC9.2/tree/master/com.siteview.kernel.core/src/COM/dragonflow/StandardMonitor/FTPMonitor.java", "rawCode": "  private static String readLine(\n      BufferedReader bufferedreader, Socket socket, long l, PrintWriter printwriter)\n      throws IOException {\n    setTimedOut(socket, l);\n    String string = bufferedreader.readLine();\n    if (debug) System.out.println(\"Debug: FTP IN =\" + string);\n    if (printwriter != null) printwriter.println(\"Received: \" + string);\n    if (string != null) string = string.trim();\n    return string;\n  }\n"}, {"dataset": "readLine", "exampleID": 521, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["close()", "toString()", "new IllegalStateException(*)"], "tryExpressionStart": 446, "tryExpressionEnd": 450, "tryBlockStart": 446, "tryBlockEnd": 846, "catchExpressionStart": 739, "catchExpressionEnd": 763, "catchBlockStart": 739, "catchBlockEnd": 846, "exceptionHandlingCallStart": [773, 822, 796], "exceptionHandlingCallEnd": [780, 836, 837], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 499, "focalAPIEnd": 524, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 536, "followUpCheckExpressionEnd": 553, "followUpCheckBlockStart": 536, "followUpCheckBlockEnd": 720, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tmobile/themes-platform-packages-apps-Email/tree/master/src/org/apache/commons/io/LineIterator.java", "rawCode": "  /**\n   * Indicates whether the <code>Reader</code> has more lines. If there is an <code>IOException\n   * </code> then {@link #close()} will be called on this instance.\n   *\n   * @return <code>true</code> if the Reader has more lines\n   * @throws IllegalStateException if an IO exception occurs\n   */\n  public boolean hasNext() {\n    if (cachedLine != null) {\n      return true;\n    } else if (finished) {\n      return false;\n    } else {\n      try {\n        while (true) {\n          String line = bufferedReader.readLine();\n          if (line == null) {\n            finished = true;\n            return false;\n          } else if (isValidLine(line)) {\n            cachedLine = line;\n            return true;\n          }\n        }\n      } catch (IOException ioe) {\n        close();\n        throw new IllegalStateException(ioe.toString());\n      }\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 522, "initialization": ["BufferedReader bufferedReader = new BufferedReader(FileReader)"], "initializationStart": [426], "initializationEnd": [453], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["Log.warn(String)"], "tryExpressionStart": 462, "tryExpressionEnd": 466, "tryBlockStart": 462, "tryBlockEnd": 1295, "catchExpressionStart": 855, "catchExpressionEnd": 878, "catchBlockStart": 855, "catchBlockEnd": 960, "exceptionHandlingCallStart": [888], "exceptionHandlingCallEnd": [930], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 482, "focalAPIEnd": 495, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 522, "followUpCheckExpressionEnd": 538, "followUpCheckBlockStart": 522, "followUpCheckBlockEnd": 846, "use": ["line.replace(char,char)", "bufferedReader.close()"], "useStart": [597, 1024], "useEnd": [619, 1039], "hasFinally": 1, "cleanUpCall": ["FileReader.close()"], "finallyExpressionStart": 961, "finallyExpressionEnd": 969, "finallyBlockStart": 961, "finallyBlockEnd": 1295, "cleanUpCallStart": [1024], "cleanUpCallEnd": [1039], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/util/ProcfsBasedProcessTree.java", "rawCode": "    public String getCmdLine(String procfsDir) {\n      String ret = \"N/A\";\n      if (pid == null) {\n        return ret;\n      }\n      BufferedReader in = null;\n      FileReader fReader = null;\n      try {\n        fReader = new FileReader(new File(new File(procfsDir, pid), PROCFS_CMDLINE_FILE));\n      } catch (FileNotFoundException f) {\n        // The process vanished in the interim!\n        return ret;\n      }\n\n      in = new BufferedReader(fReader);\n\n      try {\n        ret = in.readLine(); // only one line\n        if (ret == null) {\n          ret = \"N/A\";\n        } else {\n          ret = ret.replace('\\0', ' '); // Replace each null char with a space\n          if (ret.equals(\"\")) {\n            // The cmdline might be empty because the process is swapped out or\n            // is a zombie.\n            ret = \"N/A\";\n          }\n        }\n      } catch (IOException io) {\n        LOG.warn(\"Error reading the stream \" + io);\n        ret = \"N/A\";\n      } finally {\n        // Close the streams\n        try {\n          fReader.close();\n          try {\n            in.close();\n          } catch (IOException i) {\n            LOG.warn(\"Error closing the stream \" + in);\n          }\n        } catch (IOException i) {\n          LOG.warn(\"Error closing the stream \" + fReader);\n        }\n      }\n\n      return ret;\n    }\n"}, {"dataset": "readLine", "exampleID": 523, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*,int)"], "initializationStart": [124], "initializationEnd": [170], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 199, "focalAPIEnd": 212, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.close()"], "useStart": [240], "useEnd": [250], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 222, "finallyExpressionEnd": 230, "finallyBlockStart": 222, "finallyBlockEnd": 259, "cleanUpCallStart": [240], "cleanUpCallEnd": [250], "url": "https://github.com/iceandfire/android_packages_apps_Settings/tree/master/src/com/android/settings/Utils.java", "rawCode": "  public static String fileReadOneLine(String fname) {\n    BufferedReader br;\n    String line = null;\n\n    try {\n      br = new BufferedReader(new FileReader(fname), 512);\n      try {\n        line = br.readLine();\n      } finally {\n        br.close();\n      }\n    } catch (Exception e) {\n      Log.e(TAG, \"IO Exception when reading /sys/ file\", e);\n    }\n    return line;\n  }\n"}, {"dataset": "readLine", "exampleID": 524, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [491], "initializationEnd": [552], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 580, "focalAPIEnd": 592, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(String,line)", "bufferedReader.readLine()", "assertEquals(String,line)", "bufferedReader.readLine()", "assertEquals(String,line)", "bufferedReader.readLine()", "assertEquals(*,line)"], "useStart": [558, 616, 599, 654, 635, 692, 673], "useEnd": [593, 628, 629, 666, 667, 704, 705], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pdinc-oss/jgit/tree/master/org.eclipse.jgit.http.test/tst/org/eclipse/jgit/http/test/RegexPipelineTest.java", "rawCode": "  @Test\n  public void testServeOrdering() throws Exception {\n    MetaServlet s = new MetaServlet();\n    s.serveRegex(\"^(/a)$\").with(new Servlet(\"test1\"));\n    s.serveRegex(\"^(/a+)$\").with(new Servlet(\"test2\"));\n    ctx.addServlet(new ServletHolder(s), \"/*\");\n    server.setUp();\n\n    final URI uri = server.getURI();\n    HttpURLConnection c;\n    BufferedReader r;\n\n    c = ((HttpURLConnection) uri.resolve(\"/a\").toURL().openConnection());\n    assertEquals(200, c.getResponseCode());\n    r = new BufferedReader(new InputStreamReader(c.getInputStream()));\n    assertEquals(\"test1\", r.readLine());\n    assertEquals(\"\", r.readLine());\n    assertEquals(\"/a\", r.readLine());\n    assertEquals(null, r.readLine());\n  }\n"}, {"dataset": "readLine", "exampleID": 525, "initialization": ["BufferedReader bufferedReader = toBufferedReader(InputStream)", "BufferedReader bufferedReader = toBufferedReader(*)"], "initializationStart": [185, 765], "initializationEnd": [205, 804], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["bufferedReader.close()"], "configurationStart": [305], "configurationEnd": [315], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 852, "focalAPIEnd": 865, "followUpCheck": "line != null && line.startsWith(RefDirectory.SYMREF)", "checkType": "IF", "followUpCheckExpressionStart": 881, "followUpCheckExpressionEnd": 938, "followUpCheckBlockStart": 881, "followUpCheckBlockEnd": 1531, "use": ["line.substring(*)", "fromString(line)", "bufferedReader.close()"], "useStart": [973, 1446, 1570], "useEnd": [1017, 1471, 1580], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1546, "finallyExpressionEnd": 1554, "finallyBlockStart": 1546, "finallyBlockEnd": 1595, "cleanUpCallStart": [1570], "cleanUpCallEnd": [1580], "url": "https://github.com/pdinc-oss/jgit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/transport/TransportHttp.java", "rawCode": "  private FetchConnection newDumbConnection(InputStream in)\n      throws IOException, PackProtocolException {\n    HttpObjectDB d = new HttpObjectDB(objectsUrl);\n    BufferedReader br = toBufferedReader(in);\n    Map<String, Ref> refs;\n    try {\n      refs = d.readAdvertisedImpl(br);\n    } finally {\n      br.close();\n    }\n\n    if (!refs.containsKey(Constants.HEAD)) {\n      // If HEAD was not published in the info/refs file (it usually\n      // is not there) download HEAD by itself as a loose file and do\n      // the resolution by hand.\n      //\n      HttpURLConnection conn = httpOpen(new URL(baseUrl, Constants.HEAD));\n      int status = HttpSupport.response(conn);\n      switch (status) {\n        case HttpURLConnection.HTTP_OK:\n          {\n            br = toBufferedReader(openInputStream(conn));\n            try {\n              String line = br.readLine();\n              if (line != null && line.startsWith(RefDirectory.SYMREF)) {\n                String target = line.substring(RefDirectory.SYMREF.length());\n                Ref r = refs.get(target);\n                if (r == null) r = new ObjectIdRef.Unpeeled(Ref.Storage.NEW, target, null);\n                r = new SymbolicRef(Constants.HEAD, r);\n                refs.put(r.getName(), r);\n              } else if (line != null && ObjectId.isId(line)) {\n                Ref r =\n                    new ObjectIdRef.Unpeeled(\n                        Ref.Storage.NETWORK, Constants.HEAD, ObjectId.fromString(line));\n                refs.put(r.getName(), r);\n              }\n            } finally {\n              br.close();\n            }\n            break;\n          }\n\n        case HttpURLConnection.HTTP_NOT_FOUND:\n          break;\n\n        default:\n          throw new TransportException(\n              uri,\n              MessageFormat.format(\n                  JGitText.get().cannotReadHEAD,\n                  Integer.valueOf(status),\n                  conn.getResponseMessage()));\n      }\n    }\n\n    WalkFetchConnection wfc = new WalkFetchConnection(this, d);\n    wfc.available(refs);\n    return wfc;\n  }\n"}, {"dataset": "readLine", "exampleID": 526, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [230], "initializationEnd": [273], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 283, "focalAPIEnd": 295, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 302, "followUpCheckExpressionEnd": 319, "followUpCheckBlockStart": 302, "followUpCheckBlockEnd": 373, "use": ["BasicIO.addLines(line)", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [328, 354, 379], "useEnd": [342, 366, 388], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rasmusjensen/lightscript/tree/master/.attic2/external/languages/fscriptME-0.7/FSTest.java", "rawCode": "  public static final void main(String args[]) throws FSException, IOException {\n\n    BasicIO fs = new BasicIO();\n    String s;\n\n    // also FscriptME has no load method, so we have to load individual lines\n    BufferedReader f = new BufferedReader(new FileReader(args[0]));\n    s = f.readLine();\n\n    while (s != null) {\n      fs.addLines(s);\n      s = f.readLine();\n    }\n\n    f.close();\n\n    Object o = fs.runCode();\n\n    System.out.println(\"Code returned: \" + o);\n  }\n"}, {"dataset": "readLine", "exampleID": 527, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 117, "focalAPIEnd": 180, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AKSW/AutoSPARQL/tree/master/commons/src/main/java/org/aksw/autosparql/commons/nlp/pling/D.java", "rawCode": "  /** Reads a line from the keyboard */\n  public static String r() {\n    String s = \"\";\n    i();\n    try {\n      s = new BufferedReader(new InputStreamReader(System.in)).readLine();\n    } catch (Exception whocares) {\n    }\n    return (s);\n  }\n"}, {"dataset": "readLine", "exampleID": 528, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [84], "initializationEnd": [136], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 164, "focalAPIEnd": 177, "followUpCheck": "a.charAt(i) != line.charAt(i)", "checkType": "IF", "followUpCheckExpressionStart": 366, "followUpCheckExpressionEnd": 397, "followUpCheckBlockStart": 366, "followUpCheckBlockEnd": 444, "use": ["line.length()"], "useStart": [261], "useEnd": [271], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pierreetienne/gnu-maraton/tree/master/VamosAhoraSi/src/CF61A.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    for (String ln; (ln = in.readLine()) != null; ) {\n      String a = ln;\n      String b = in.readLine();\n      int max = b.length();\n      StringBuilder sol = new StringBuilder();\n      for (int i = 0; i < max; ++i) {\n        if (a.charAt(i) != b.charAt(i)) sol.append(\"1\");\n        else sol.append(\"0\");\n      }\n      System.out.println(new String(sol));\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 529, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 1642, "tryExpressionEnd": 1646, "tryBlockStart": 1642, "tryBlockEnd": 2192, "catchExpressionStart": 2134, "catchExpressionEnd": 2154, "catchBlockStart": 2134, "catchBlockEnd": 2192, "exceptionHandlingCallStart": [2164], "exceptionHandlingCallEnd": [2183], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1724, "focalAPIEnd": 1737, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mattloidolt/CS414/tree/master/A4/src/core/KitchenDisplay.java", "rawCode": "  /**\n   * Create the GUI and show it. For thread safety, this method should be invoked from the\n   * event-dispatching thread.\n   */\n  private static void createAndShowGUI(final String[] args) {\n    final Dimension size = Toolkit.getDefaultToolkit().getScreenSize();\n    Color background = new Color(0, 0, 0);\n\n    // Create and set up the window.\n    JFrame frame = new JFrame(\"PIZZA_STORE_NAME\");\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    JDesktopPane desktop = new JDesktopPane();\n    frame.setContentPane(desktop);\n    desktop.setBackground(background);\n    frame.setMinimumSize(size);\n    desktop.setLayout(new GridBagLayout()); // this is the framing structure\n    GridBagConstraints gBC = new GridBagConstraints();\n    gBC.fill = GridBagConstraints.HORIZONTAL;\n    gBC.weightx = .75;\n    gBC.gridx = 0;\n    gBC.gridy = 0;\n    JLabel heading1 = new JLabel(\"<html><h1>ORDER</h1><hr></html>\");\n    JLabel heading2 = new JLabel(\"<html><h1>COMPLETE?</h1><hr></html>\");\n    heading1.setForeground(Color.white);\n    heading2.setForeground(Color.white);\n\n    desktop.add(heading1, gBC);\n    gBC.gridx = 1;\n    gBC.weightx = .25;\n    desktop.add(heading2, gBC);\n    gBC.gridx = 0;\n    gBC.weightx = .75;\n\n    //////// adding all the orders to the screen /////////\n    DirectoryScanner scanner = new DirectoryScanner();\n    scanner.setIncludes(new String[] {\"**/*.POS\"});\n    scanner.setBasedir(\".\");\n    scanner.setCaseSensitive(false);\n    scanner.scan();\n    final String[] files = scanner.getIncludedFiles();\n    for (int i = 0; i < files.length; i++) {\n      BufferedReader in;\n      String order = \"<html><h2>\";\n      try {\n        in = new BufferedReader(new FileReader(files[i]));\n        order += in.readLine() + \"</h2><table>\";\n        String line = in.readLine();\n        int lineNum = 1;\n        while (line != null) {\n          if (lineNum != 1) {\n            order += \"<tr>\";\n            if (lineNum == 2) order += \"Phone: \";\n            order += line + \"</tr>\";\n          }\n          lineNum++;\n          line = in.readLine();\n        }\n        order += \"</table></html>\";\n        in.close();\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n      JLabel o = new JLabel(order);\n      o.setForeground(Color.white);\n      gBC.gridy++;\n      desktop.add(o, gBC);\n    }\n    /////////////////////////////////////////////////////////\n\n    ///// adding buttons for marking orders as complete ////\n    gBC.gridy = 0;\n    gBC.gridx = 1;\n    gBC.weightx = .25;\n    for (int i = 0; i < files.length; i++) {\n      JButton done = new JButton(\"Done\");\n      done.setPreferredSize(new Dimension(100, 75));\n      final int k = i;\n      done.addActionListener(\n          new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n              // on button press...\n              File f = new File(files[k]);\n              boolean success = f.delete();\n              if (!success) throw new IllegalArgumentException(\"Delete: deletion failed\");\n              else restartProgram(args);\n            }\n          });\n\n      gBC.gridy++;\n      desktop.add(done, gBC);\n    }\n    ////////////////////////////////////////////////////////\n\n    // Display the window.\n    frame.pack();\n    frame.setVisible(true);\n  }\n"}, {"dataset": "readLine", "exampleID": 530, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)", "BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [1082, 1204], "initializationEnd": [1136, 1249], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1441, "focalAPIEnd": 1454, "followUpCheck": "line != null && !\"\".equals(line)", "checkType": "IF", "followUpCheckExpressionStart": 1561, "followUpCheckExpressionEnd": 1622, "followUpCheckBlockStart": 1561, "followUpCheckBlockEnd": 2019, "use": ["bufferedReader.close()", "newInstance(line,ClassLoader,boolean,boolean)"], "useStart": [1462, 1956], "useEnd": [1472, 2012], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fanhongtao/JDK/tree/master/src/javax/xml/parsers/FactoryFinder.java", "rawCode": "  private static Object findJarServiceProvider(String factoryId) throws ConfigurationError {\n    String serviceId = \"META-INF/services/\" + factoryId;\n    InputStream is = null;\n\n    // First try the Context ClassLoader\n    ClassLoader cl = ss.getContextClassLoader();\n    boolean useBSClsLoader = false;\n    if (cl != null) {\n      is = ss.getResourceAsStream(cl, serviceId);\n\n      // If no provider found then try the current ClassLoader\n      if (is == null) {\n        cl = FactoryFinder.class.getClassLoader();\n        is = ss.getResourceAsStream(cl, serviceId);\n        useBSClsLoader = true;\n      }\n    } else {\n      // No Context ClassLoader, try the current ClassLoader\n      cl = FactoryFinder.class.getClassLoader();\n      is = ss.getResourceAsStream(cl, serviceId);\n      useBSClsLoader = true;\n    }\n\n    if (is == null) {\n      // No provider found\n      return null;\n    }\n\n    if (debug) { // Extra check to avoid computing cl strings\n      dPrint(\"found jar resource=\" + serviceId + \" using ClassLoader: \" + cl);\n    }\n\n    BufferedReader rd;\n    try {\n      rd = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n    } catch (java.io.UnsupportedEncodingException e) {\n      rd = new BufferedReader(new InputStreamReader(is));\n    }\n\n    String factoryClassName = null;\n    try {\n      // XXX Does not handle all possible input as specified by the\n      // Jar Service Provider specification\n      factoryClassName = rd.readLine();\n      rd.close();\n    } catch (IOException x) {\n      // No provider found\n      return null;\n    }\n\n    if (factoryClassName != null && !\"\".equals(factoryClassName)) {\n      dPrint(\"found in resource, value=\" + factoryClassName);\n\n      // Note: here we do not want to fall back to the current\n      // ClassLoader because we want to avoid the case where the\n      // resource file was found using one ClassLoader and the\n      // provider class was instantiated using a different one.\n      return newInstance(factoryClassName, cl, false, useBSClsLoader);\n    }\n\n    // No provider found\n    return null;\n  }\n"}, {"dataset": "readLine", "exampleID": 531, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "java.io.IOException", "exceptionHandlingCall": ["getMessage()", "println(*)", "println(String)"], "tryExpressionStart": 322, "tryExpressionEnd": 326, "tryBlockStart": 322, "tryBlockEnd": 962, "catchExpressionStart": 833, "catchExpressionEnd": 863, "catchBlockStart": 833, "catchBlockEnd": 962, "exceptionHandlingCallStart": [890, 871, 913], "exceptionHandlingCallEnd": [904, 905, 955], "configuration": ["bufferedReader.reset()", "bufferedReader.mark(int)"], "configurationStart": [686, 741], "configurationEnd": [703, 765], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 783, "focalAPIEnd": 803, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/biojava/biojava-legacy/tree/master/blast/src/main/java/org/biojava/bio/program/sax/HitSectionSAXParser.java", "rawCode": "  public void parse(BufferedReader poContents, String poLine, ArrayList<String> poEndSignals)\n      throws SAXException {\n    oLine = null;\n    oContents = poContents;\n    setGlobalEndSignal(poEndSignals);\n    // return immediately if this is not the start\n    // of a hit...\n    if (!poLine.startsWith(\">\")) return;\n\n    try {\n\n      oLine = poLine;\n      while ((oLine != null) && (!this.matchesGlobalEndSignal(oLine)) && (!(iState == DONE))) {\n        // interpret line and send messages accordingly\n        this.interpret(oLine);\n        // check for End again cos stream read elsewhere\n\n        if (this.matchesGlobalEndSignal(oLine)) {\n          this.changeState(DONE);\n          oContents.reset();\n          break;\n        }\n\n        oContents.mark(10000000);\n        oLine = oContents.readLine();\n      } // end while\n\n    } catch (java.io.IOException x) {\n      System.out.println(x.getMessage());\n      System.out.println(\"File read interupted\");\n    } // end try/catch\n  }\n"}, {"dataset": "readLine", "exampleID": 532, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [808], "initializationEnd": [848], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 765, "tryExpressionEnd": 769, "tryBlockStart": 765, "tryBlockEnd": 2891, "catchExpressionStart": 2454, "catchExpressionEnd": 2476, "catchBlockStart": 2454, "catchBlockEnd": 2493, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1090, "focalAPIEnd": 1112, "followUpCheck": "!newStrTemp.equals(line)", "checkType": "IF", "followUpCheckExpressionStart": 1188, "followUpCheckExpressionEnd": 1223, "followUpCheckBlockStart": 1188, "followUpCheckBlockEnd": 1258, "use": ["bufferedReader.close()"], "useStart": [1277], "useEnd": [1296], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/SpagoBI-V4x/tree/master/SpagoBabel/src/it/eng/spagobabel/bin/DiffAllFile.java", "rawCode": "  public static void diffFile(String subPath, String fileName, String newPath) throws IOException {\n    String home = \"/home/spinelli/Scrivania\";\n\n    // Path della cartella che contiene la vecchia versione dei progetti\n    String oldPath = \"/home/spinelli/Scrivania/OldprogettiSpago\";\n\n    /*Cartella che conterrà i file presenti nella gerarchia\n     * prodotta da ExtractAllFile, ma non presenti nella versione vecchia\n     * dei programmi (oldPath)\n     */\n    String master = \"/home/spinelli/Scrivania/ToTranslate\";\n    (new File(master)).mkdir();\n\n    String path = oldPath + subPath + \"/\" + fileName;\n    int count = 0;\n    File dir = new File(path);\n    if (dir.exists()) {\n      // Controllo se i file (vecchia versione e nuova versione) sono diversi\n      try {\n        BufferedReader oldfileTemp = new BufferedReader(new FileReader(path));\n        BufferedReader newfileTemp = new BufferedReader(new FileReader(newPath + \"/\" + fileName));\n        String oldStrTemp;\n        String newStrTemp;\n        while ((newStrTemp = newfileTemp.readLine()) != null) {\n          oldStrTemp = oldfileTemp.readLine();\n\n          // Se sono diversi incremento la variabile contatore\n          if (!newStrTemp.equals(oldStrTemp)) {\n            count++;\n          }\n        }\n        oldfileTemp.close();\n        newfileTemp.close();\n\n        /*Se sono sicura che sono diversi creo il percorso nella cartella master e\n         *creo il file che contiene la differenza rispetto il file della nuova versione\n         */\n        if (count != 0) {\n          String name = CreateDir.getName(fileName);\n          String diff = master + subPath;\n          File f1 = new File(diff);\n          f1.mkdirs();\n          File fileFirst = new File(master + subPath + \"/\" + name);\n          fileFirst.createNewFile();\n\n          BufferedReader oldfile = new BufferedReader(new FileReader(path));\n          BufferedReader newfile = new BufferedReader(new FileReader(newPath + \"/\" + fileName));\n          BufferedWriter outfile =\n              new BufferedWriter(new FileWriter(master + subPath + \"/\" + name));\n          String oldStr;\n          String newStr;\n          while ((newStr = newfile.readLine()) != null) {\n            oldStr = oldfile.readLine();\n            if (!newStr.equals(oldStr)) {\n              count++;\n              try {\n                // Scrivo il nuovo file\n                outfile.write(newStr);\n                outfile.write(\"\\n\");\n\n              } catch (IOException e) {\n              }\n            }\n          }\n          oldfile.close();\n          newfile.close();\n          outfile.close();\n\n          if (count == 0) {\n            File file = new File(master + subPath + \"/\" + name);\n            file.delete();\n          }\n        }\n\n        File allDir = new File(master + subPath);\n        allDir.delete();\n\n      } catch (IOException e) {\n        // Exceptions ignored.\n      }\n      File MastDir = new File(master);\n      String[] lista = MastDir.list();\n      for (int j = 0; j < lista.length; j++) {\n        File temp = new File(master + \"/\" + lista[j]);\n        temp.delete();\n      }\n    } else {\n      // Viene eseguito nel caso in cui il file è presente solo nella nuova versione\n      String diff = master + subPath;\n      File f1 = new File(diff);\n      f1.mkdirs();\n      File inputFile = new File(home + subPath + \"/\" + fileName);\n      File outputFile = new File(diff + \"/\" + fileName);\n      InputStream finput;\n      finput = new BufferedInputStream(new FileInputStream(inputFile));\n      OutputStream foutput;\n      foutput = new BufferedOutputStream(new FileOutputStream(outputFile));\n      byte[] buffer = new byte[1024 * 500];\n      int bytes_letti = 0;\n      while ((bytes_letti = finput.read(buffer)) > 0) foutput.write(buffer, 0, bytes_letti);\n      finput.close();\n      foutput.close();\n    }\n    File allDir = new File(master + subPath);\n    allDir.delete();\n  }\n"}, {"dataset": "readLine", "exampleID": 533, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [384], "initializationEnd": [450], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 260, "tryExpressionEnd": 264, "tryBlockStart": 260, "tryBlockEnd": 1417, "catchExpressionStart": 1237, "catchExpressionEnd": 1259, "catchBlockStart": 1237, "catchBlockEnd": 1289, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 548, "focalAPIEnd": 561, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["println(line)", "bufferedReader.readLine()", "println(line)", "bufferedReader.readLine()", "println(line)", "bufferedReader.readLine()", "println(line)", "bufferedReader.close()"], "useStart": [571, 827, 850, 979, 1002, 1095, 1116, 1322], "useEnd": [599, 840, 878, 992, 1030, 1108, 1144, 1332], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1290, "finallyExpressionEnd": 1298, "finallyBlockStart": 1290, "finallyBlockEnd": 1417, "cleanUpCallStart": [1322], "cleanUpCallEnd": [1332], "url": "https://github.com/chenopodium/IGV/tree/master/launcher/src/org/broad/igv/Launcher.java", "rawCode": "  private static boolean loadDirectly(\n      int port, String file, String name, String locus, String genome, String merge)\n      throws IOException {\n    boolean success;\n    Socket socket = null;\n    PrintWriter out = null;\n    BufferedReader in = null;\n    try {\n      socket = new Socket(\"127.0.0.1\", port);\n      out = new PrintWriter(socket.getOutputStream(), true);\n      in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n      if (genome != null) {\n        out.println(\"genome \" + genome);\n        String response = in.readLine();\n        System.out.println(response);\n      }\n      if (file != null) {\n        String cmd = \"load \" + file;\n        if (name != null) cmd += \" name=\" + name;\n        if (merge != null) cmd += \" merge=\" + merge;\n        out.println(cmd);\n        String response = in.readLine();\n        System.out.println(response);\n      }\n      if (locus != null) {\n        out.println(\"goto \" + locus);\n        String response = in.readLine();\n        System.out.println(response);\n      }\n\n      out.println(\"tofront\");\n      String response = in.readLine();\n      System.out.println(response);\n      success = true;\n\n    } catch (UnknownHostException e) {\n      success = false;\n    } catch (IOException e) {\n      success = false;\n    } finally {\n      if (in != null) in.close();\n      if (out != null) out.close();\n      if (socket != null) socket.close();\n    }\n    return success;\n  }\n"}, {"dataset": "readLine", "exampleID": 534, "initialization": ["BufferedReader bufferedReader = new BufferedReader(FileReader)"], "initializationStart": [160], "initializationEnd": [186], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 192, "tryExpressionEnd": 196, "tryBlockStart": 192, "tryBlockEnd": 331, "catchExpressionStart": 288, "catchExpressionEnd": 316, "catchBlockStart": 288, "catchBlockEnd": 325, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 211, "focalAPIEnd": 227, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.close()"], "useStart": [265], "useEnd": [278], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 235, "finallyExpressionEnd": 243, "finallyBlockStart": 235, "finallyBlockEnd": 331, "cleanUpCallStart": [265], "cleanUpCallEnd": [278], "url": "https://github.com/brl/netifera/tree/master/platform/com.netifera.platform.ui/com.netifera.platform.ui.application/src/com/netifera/platform/ui/application/workspaces/WorkspaceChooser.java", "rawCode": "  private String readWorkspaceName(File nameFile) throws IOException {\n    final FileReader reader = new FileReader(nameFile);\n    final BufferedReader input = new BufferedReader(reader);\n    try {\n      return input.readLine();\n    } finally {\n      try {\n        input.close();\n      } catch (IOException ignored) {\n      }\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 535, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 92, "focalAPIEnd": 105, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Tumas/labs/tree/master/III_semester/dbms/src/db2lab23/ConsoleMenu.java", "rawCode": "  public String getString(String msg) throws IOException {\n    printString(msg);\n    return in.readLine();\n  }\n"}, {"dataset": "readLine", "exampleID": 536, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [620], "initializationEnd": [665], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 673, "tryExpressionEnd": 677, "tryBlockStart": 673, "tryBlockEnd": 988, "catchExpressionStart": 907, "catchExpressionEnd": 930, "catchBlockStart": 907, "catchBlockEnd": 969, "exceptionHandlingCallStart": [940], "exceptionHandlingCallEnd": [960], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 747, "focalAPIEnd": 760, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dvn/dvn-svn-import-test4/tree/master/tags/release-2.1/src/DVN-EJB/src/java/edu/harvard/iq/dvn/ingest/dsb/impl/DvnNewJavaFieldCutter.java", "rawCode": "  /**\n   * @param\n   * @return\n   */\n  public void cutColumns(\n      File fl, int noCardsPerCase, int caseLength, String delimitor, String tabFileName)\n      throws FileNotFoundException {\n\n    if (delimitor == null) {\n      delimitor = defaultDelimitor;\n    }\n\n    int[] lineLength = new int[noCardsPerCase];\n    InputStream in = null;\n    String line = null;\n\n    // caseLength info is not available\n    // check all lines have the same length\n    int columnCounter = 0;\n    in = new FileInputStream(fl);\n    Set<Integer> lengthSet = new LinkedHashSet<Integer>();\n\n    if (caseLength == 0) {\n      BufferedReader rd = new BufferedReader(new InputStreamReader(in));\n      try {\n        for (int l = 0; l < noCardsPerCase; l++) {\n          line = rd.readLine();\n          lengthSet.add(line.length());\n          lineLength[l] = line.length();\n          dbgLog.fine(l + \"th line=\" + line);\n        }\n      } catch (IOException ex) {\n        ex.printStackTrace();\n      } finally {\n\n      }\n\n      if (lengthSet.size() == 1) {\n        // all lines have the same length\n        columnCounter = lineLength[0];\n      } else {\n        // TODO\n        // temporary solution\n        columnCounter = lineLength[0];\n      }\n      dbgLog.fine(\"final columnCounter=\" + columnCounter);\n    }\n    // close in\n    try {\n      in.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n\n    REC_LEN = columnCounter;\n    REC_LEN++;\n    dbgLog.fine(\"REC_LEN=\" + REC_LEN);\n    OUT_LEN = colwidth; // calculated by parseList\n    dbgLog.fine(\"out_len=\" + OUT_LEN);\n\n    Boolean dottednotation = false;\n    Boolean foundData = false;\n\n    // cutting a data file\n\n    InputStream inx = new FileInputStream(fl);\n    ReadableByteChannel rbc = Channels.newChannel(inx);\n    // input byte-buffer size = row-length + 1(=> new line char)\n    ByteBuffer inbuffer = ByteBuffer.allocate(REC_LEN);\n\n    OutputStream outs = new FileOutputStream(tabFileName);\n    WritableByteChannel outc = Channels.newChannel(outs);\n    ByteBuffer outbuffer = null;\n\n    int pos = 0;\n    int offset = 0;\n    int outoffset = 0;\n\n    int begin = 0;\n    int end = 0;\n    int blankoffset = 0;\n    int blanktail = 0;\n    int k;\n\n    try {\n      // lc: line counter\n      int lc = 0;\n      while (rbc.read(inbuffer) != -1) {\n        // calculate i-th card number\n        lc++;\n        k = lc % noCardsPerCase;\n        if (k == 0) {\n          k = noCardsPerCase;\n        }\n        // out.println(\"***** \" +lc+ \"-th line, recod k=\" + k + \" *****\");\n        byte[] line_read = new byte[OUT_LEN];\n        byte[] junk = new byte[REC_LEN];\n        byte[] line_final = new byte[OUT_LEN];\n\n        // out.println(\"READ: \" + offset);\n        inbuffer.rewind();\n\n        offset = 0;\n        outoffset = 0;\n\n        // how many variables are cut from this k-th card\n        int noColumns = cargSet.get(Long.valueOf(k)).size();\n\n        // out.println(\"noColumns=\" + noColumns);\n        // out.println(\"cargSet k =\" + cargSet.get(Long.valueOf(k)));\n\n        for (int i = 0; i < noColumns; i++) {\n          // out.println(\"**** \" + i +\"-th col ****\");\n          begin = cargSet.get(Long.valueOf(k)).get(i).get(0); // bounds[2 * i];\n          end = cargSet.get(Long.valueOf(k)).get(i).get(1); // bounds[2 * i + 1];\n\n          // out.println(\"i: begin: \" + begin + \"\\ti: end:\" + end);\n\n          try {\n            // throw away offect bytes\n            if (begin - offset - 1 > 0) {\n              inbuffer.get(junk, 0, (begin - offset - 1));\n            }\n            // get requested bytes\n            inbuffer.get(line_read, outoffset, (end - begin + 1));\n            // set outbound data\n            outbounds[2 * i] = outoffset;\n            outbounds[2 * i + 1] = outoffset + (end - begin);\n            // current position moved to outoffset\n            pos = outoffset;\n\n            dottednotation = false;\n            foundData = false;\n\n            blankoffset = 0;\n            blanktail = 0;\n\n            // as position increases\n            while (pos <= (outoffset + (end - begin))) {\n\n              // out.println(\"pos=\" + pos + \"\\tline_read[pos]=\" +\n              // new String(line_read).replace(\"\\000\", \"\\052\"));\n\n              // decimal octal\n              // 48 =>0 60\n              // 46 => . 56\n              // 32 = space 40\n\n              // dot:\n              if (line_read[pos] == '\\056') {\n                dottednotation = true;\n              }\n\n              // space:\n              if (line_read[pos] == '\\040') {\n                if (foundData) {\n                  blanktail = blanktail > 0 ? blanktail : pos - 1;\n                } else {\n                  blankoffset = pos + 1;\n                }\n              } else {\n                foundData = true;\n                blanktail = 0;\n              }\n\n              pos++;\n            }\n            // increase the outoffset by width\n            outoffset += (end - begin + 1);\n            // dot false\n            if (!dottednotation) {\n              if (blankoffset > 0) {\n                // set outbound value to blankoffset\n                outbounds[2 * i] = blankoffset;\n              }\n              if (blanktail > 0) {\n                outbounds[2 * i + 1] = blanktail;\n              }\n            }\n\n          } catch (BufferUnderflowException bufe) {\n            bufe.printStackTrace();\n          }\n          // set offset to the value of end-position\n          offset = end;\n        }\n\n        outoffset = 0;\n        // for each var\n        for (int i = 0; i < noColumns; i++) {\n          begin = outbounds[2 * i];\n          end = outbounds[2 * i + 1];\n          // out.println(\"begin=\" + begin + \"\\t end=\" + end);\n          for (int j = begin; j <= end; j++) {\n            line_final[outoffset++] = line_read[j];\n          }\n\n          if (i < (noColumns - 1)) {\n            line_final[outoffset++] = '\\011'; // tab x09\n          } else {\n            if (k == cargSet.size()) {\n              line_final[outoffset++] = '\\012'; // LF x0A\n            } else {\n              line_final[outoffset++] = '\\011'; // tab x09\n            }\n          }\n        }\n        // out.println(\"line_final=\" +\n        // new String(line_final).replace(\"\\000\", \"\\052\"));\n        outbuffer = ByteBuffer.wrap(line_final, 0, outoffset);\n        outc.write(outbuffer);\n        inbuffer.clear();\n      } // while loop\n    } catch (IOException ex) {\n      ex.printStackTrace();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 537, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["create(String,*)"], "tryExpressionStart": 365, "tryExpressionEnd": 369, "tryBlockStart": 365, "tryBlockEnd": 536, "catchExpressionStart": 413, "catchExpressionEnd": 435, "catchBlockStart": 413, "catchBlockEnd": 536, "exceptionHandlingCallStart": [451], "exceptionHandlingCallEnd": [527], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 386, "focalAPIEnd": 403, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 543, "followUpCheckExpressionEnd": 560, "followUpCheckBlockStart": 543, "followUpCheckBlockEnd": 585, "use": ["line.split(String,int)"], "useStart": [912], "useEnd": [931], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kushpatel/MetroSub/tree/master/src/com/j256/ormlite/field/DatabaseFieldConfigLoader.java", "rawCode": "  /**\n   * Load a configuration in from a text file.\n   *\n   * @return A config if any of the fields were set otherwise null on EOF.\n   */\n  public static DatabaseFieldConfig fromReader(BufferedReader reader) throws SQLException {\n    DatabaseFieldConfig config = new DatabaseFieldConfig();\n    boolean anything = false;\n    while (true) {\n      String line;\n      try {\n        line = reader.readLine();\n      } catch (IOException e) {\n        throw SqlExceptionUtil.create(\"Could not read DatabaseFieldConfig from stream\", e);\n      }\n      if (line == null) {\n        break;\n      }\n      // we do this so we can support multiple class configs per file\n      if (line.equals(CONFIG_FILE_END_MARKER)) {\n        break;\n      }\n      // skip empty lines or comments\n      if (line.length() == 0 || line.startsWith(\"#\") || line.equals(CONFIG_FILE_START_MARKER)) {\n        continue;\n      }\n      String[] parts = line.split(\"=\", -2);\n      if (parts.length != 2) {\n        throw new SQLException(\n            \"DatabaseFieldConfig reading from stream cannot parse line: \" + line);\n      }\n      readField(config, parts[0], parts[1]);\n      anything = true;\n    }\n    // if we got any config lines then we return the config\n    if (anything) {\n      return config;\n    } else {\n      // otherwise we return null for none\n      return null;\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 538, "initialization": ["BufferedReader bufferedReader = new BufferedReader(InputStreamReader)"], "initializationStart": [466], "initializationEnd": [494], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 555, "focalAPIEnd": 572, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.readLine()", "bufferedReader.readLine()"], "useStart": [611, 703], "useEnd": [628, 720], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jponge/izpack-full-svn-history-copy/tree/master/izpack-src/tags/4.3.0/src/lib/com/izforge/izpack/uninstaller/Destroyer.java", "rawCode": "  /**\n   * Returns an ArrayList of the files to delete.\n   *\n   * @return The files list.\n   * @throws Exception Description of the Exception\n   */\n  private ArrayList<File> getFilesList() throws Exception {\n    // Initialisations\n    TreeSet<File> files = new TreeSet<File>(Collections.reverseOrder());\n    InputStream in = Destroyer.class.getResourceAsStream(\"/install.log\");\n    InputStreamReader inReader = new InputStreamReader(in);\n    BufferedReader reader = new BufferedReader(inReader);\n\n    // We skip the first line (the installation path)\n    reader.readLine();\n\n    // We read it\n    String read = reader.readLine();\n    while (read != null) {\n      files.add(new File(read));\n      read = reader.readLine();\n    }\n\n    // We return it\n    return new ArrayList<File>(files);\n  }\n"}, {"dataset": "readLine", "exampleID": 539, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [956], "initializationEnd": [1031], "hasTryCatch": 1, "exceptionType": "UnsupportedEncodingException", "exceptionHandlingCall": ["getInetAddress()", "getMessage()", "Log.error(String)", "new VirusScanIncompleteException(String,*)"], "tryExpressionStart": 846, "tryExpressionEnd": 850, "tryBlockStart": 846, "tryBlockEnd": 3876, "catchExpressionStart": 2721, "catchExpressionEnd": 2760, "catchBlockStart": 2721, "catchBlockEnd": 2956, "exceptionHandlingCallStart": [1498, 2864, 2768, 2893], "exceptionHandlingCallEnd": [1521, 2878, 2879, 2949], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1371, "focalAPIEnd": 1388, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getStreamPortFromAnswer(line)", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [1347, 1953, 3489], "useEnd": [1389, 1970, 3503], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 3426, "finallyExpressionEnd": 3434, "finallyBlockStart": 3426, "finallyBlockEnd": 3876, "cleanUpCallStart": [3489], "cleanUpCallEnd": [3503], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/KNL-1011/kernel-impl/src/main/java/org/sakaiproject/antivirus/impl/ClamAVScanner.java", "rawCode": "  protected void doScan(InputStream in) throws VirusScanIncompleteException, VirusFoundException {\n    logger.debug(\"doingScan!\");\n    Socket socket = null;\n    String virus = null;\n    long start = System.currentTimeMillis();\n    // this could be a null or zero lenght stream\n    if (in == null) {\n      return;\n    }\n\n    try {\n      socket = getClamdSocket();\n    } catch (UnknownHostException e) {\n      logger.error(\"could not connect to host for virus check: \" + e);\n      throw new VirusScanIncompleteException(SCAN_INCOMPLETE_MSG);\n    }\n    if (socket == null || !socket.isConnected()) {\n      logger.warn(\"scan is inclomplete!\");\n      throw new VirusScanIncompleteException(SCAN_INCOMPLETE_MSG);\n    }\n    BufferedReader reader = null;\n    PrintWriter writer = null;\n    Socket streamSocket = null;\n    boolean virusFound = false;\n    try {\n\n      // prepare the reader and writer for the commands\n      boolean autoFlush = true;\n      reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"ASCII\"));\n      writer =\n          new PrintWriter(\n              new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())), autoFlush);\n      // write a request for a port to use for streaming out the data to scan\n      writer.println(\"STREAM\");\n\n      // parse and get the \"stream\" port#\n      int streamPort = getStreamPortFromAnswer(reader.readLine());\n\n      // get the \"stream\" socket and the related (buffered) output stream\n      streamSocket = new Socket(socket.getInetAddress(), streamPort);\n      OutputStream os = streamSocket.getOutputStream();\n\n      // stream out the message to the scanner\n      int data;\n      // -1 signals the end of the data stream\n      while ((data = in.read()) > -1) {\n        os.write(data);\n      }\n      os.flush();\n      os.close();\n      streamSocket.close();\n\n      String logMessage = \"\";\n      String answer = null;\n      for (int i = 0; i < 100; ++i) {\n        answer = reader.readLine();\n        if (answer != null) {\n          answer = answer.trim();\n\n          // if a virus is found the answer will be '... FOUND'\n          if (answer.substring(answer.length() - FOUND_STRING.length()).equals(FOUND_STRING)) {\n            virusFound = true;\n            logMessage = answer + \" (by virus scanner)\";\n            // virus = answer.substring(answer.indexOf(\":\" + 1));\n            virus = answer.substring(0, answer.indexOf(FOUND_STRING)).trim();\n            logger.debug(logMessage);\n          } else {\n            logger.debug(\"no virus found: \" + answer);\n          }\n        } else {\n          break;\n        }\n      }\n      long finish = System.currentTimeMillis();\n      logger.debug(\"Content scanned in \" + (finish - start));\n    } catch (UnsupportedEncodingException e) {\n      logger.error(\n          \"Exception caught calling CLAMD on \" + socket.getInetAddress() + \": \" + e.getMessage());\n      throw new VirusScanIncompleteException(SCAN_INCOMPLETE_MSG, e);\n    } catch (IOException e) {\n      // we expect a connection reset if we tried to send too much data to clamd\n      if (\"Connection reset\".equals(e.getMessage())) {\n        logger.warn(\"Clamd reset the connection maybe due to the file being too large\");\n        return;\n      }\n      logger.error(\n          \"Exception caught calling CLAMD on \" + socket.getInetAddress() + \": \" + e.getMessage());\n      throw new VirusScanIncompleteException(SCAN_INCOMPLETE_MSG, e);\n\n    } finally {\n\n      if (reader != null) {\n        try {\n          reader.close();\n        } catch (IOException e) {\n        }\n      }\n      if (writer != null) {\n        writer.close();\n      }\n      if (streamSocket != null) {\n        try {\n          streamSocket.close();\n        } catch (IOException e) {\n\n        }\n      }\n      if (socket != null) {\n        try {\n          socket.close();\n        } catch (IOException e) {\n\n        }\n      }\n    }\n    if (virusFound) {\n      logger.info(\"Virus detected!: \" + virus);\n      throw new VirusFoundException(virus);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 540, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 186, "focalAPIEnd": 199, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["log(line)"], "useStart": [172], "useEnd": [200], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CSEMike/OneSwarm/tree/master/az_src/jsocks/net/sourceforge/jsocks/test/TestClient.java", "rawCode": "  void testEcho() throws IOException {\n    log(\"Testing echo.\");\n    for (int i = 0; i < 5; ++i) {\n      out.write(\"String number \" + i + \"\\r\\n\");\n      out.flush();\n      log(\"Echo:\" + in.readLine());\n      ;\n    }\n    log(\"Echo finished\");\n  }\n"}, {"dataset": "readLine", "exampleID": 541, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [312], "initializationEnd": [382], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 397, "focalAPIEnd": 414, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/abeifuss/simgui/tree/master/src/framework/core/util/Util.java", "rawCode": "  public static String readLine(long offset, String filePointer) throws IOException {\n    String result;\n    RandomAccessFile raf = new RandomAccessFile(filePointer, \"r\");\n    raf.seek(offset);\n    // use BufferedReader to read line instead of raf.readLine() for performance reasons:\n    BufferedReader reader = new BufferedReader(Channels.newReader(raf.getChannel(), \"ISO-8859-1\"));\n    result = reader.readLine();\n    raf.close();\n    return result;\n  }\n"}, {"dataset": "readLine", "exampleID": 542, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [114], "initializationEnd": [166], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 183, "focalAPIEnd": 197, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 203, "followUpCheckExpressionEnd": 220, "followUpCheckBlockStart": 203, "followUpCheckBlockEnd": 273, "use": ["StringWriter.write(line)", "bufferedReader.readLine()"], "useStart": [229, 252], "useEnd": [240, 266], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/soluvas/karaf/tree/master/shell/console/src/test/java/org/apache/karaf/shell/commands/TestCommands.java", "rawCode": "  public String capture() throws IOException {\n    StringWriter sw = new StringWriter();\n    BufferedReader rdr = new BufferedReader(new InputStreamReader(System.in));\n    String s = rdr.readLine();\n    while (s != null) {\n      sw.write(s);\n      s = rdr.readLine();\n    }\n    return sw.toString();\n  }\n"}, {"dataset": "readLine", "exampleID": 543, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [598], "initializationEnd": [638], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 672, "focalAPIEnd": 684, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 745, "followUpCheckExpressionEnd": 762, "followUpCheckBlockStart": 745, "followUpCheckBlockEnd": 769, "use": ["line.trim()", "line.split(String)", "println(line)", "println(line)", "bufferedReader.close()"], "useStart": [783, 933, 1064, 1350, 2000], "useEnd": [794, 950, 1088, 1374, 2009], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/helioliu/vooga/tree/master/src/levelEditor_delta/GraphicsBank.java", "rawCode": "  /**\n   * Load tileset from file. This will combine the tilesets if one has already been loaded. The most\n   * recently loaded tileset file becomes the \"loadedFrom\" tileset.\n   */\n  public void loadTileset(File from) throws FileNotFoundException, IOException {\n    BufferedReader r;\n    String line;\n    String tokens[];\n    int id;\n    int lineCount;\n    File tileFile;\n\n    if (tiles.size() > 0) {\n      isUnsaved = true;\n    } else {\n      isUnsaved = false;\n    }\n\n    System.out.println(from);\n    baseDirectory = from.getParentFile();\n    this.loadedFrom = from;\n\n    lineCount = 0;\n    r = new BufferedReader(new FileReader(from));\n    while (true) {\n      line = r.readLine();\n      lineCount++;\n\n      // stop when no more lines\n      if (line == null) break;\n      line = line.trim();\n      if (line.length() == 0 || line.charAt(0) == COMMENT) {\n        continue; // skip comments and empty lines.\n      }\n\n      tokens = line.split(DELIM);\n      if (tokens.length < 4) {\n        System.err.println(\"Could not parse line \" + lineCount + \". :\");\n        System.err.println(line);\n        System.err.println(\"(There are not enough tokens)\");\n        continue;\n      }\n      try {\n        id = Integer.parseInt(tokens[ID].trim());\n      } catch (Exception e) {\n        System.err.println(\"Could not parse line \" + lineCount + \". :\");\n        System.err.println(line);\n        System.err.println(\"(The tile id is not a valid number)\");\n        continue;\n      }\n\n      // get file for image\n      tokens[PATH] = tokens[PATH].trim();\n      tokens[NAME] = tokens[NAME].trim();\n      tokens[TYPE] = tokens[TYPE].trim();\n\n      tileFile = new File(baseDirectory, tokens[PATH]);\n      // System.out.println(\"load tile image: \"+tileFile);\n      if (!tileFile.exists()) {\n        tileFile = new File(tokens[PATH]);\n        if (tileFile.exists()) {\n          System.err.println(\n              \"WARNING: file \" + tokens[PATH] + \" not within the tilemaps working directory\");\n        } else {\n          r.close();\n          throw new FileNotFoundException(\n              \"File \"\n                  + tokens[PATH]\n                  + \" referenced on line \"\n                  + lineCount\n                  + \" of \"\n                  + from\n                  + \" could not be found\");\n        }\n      }\n\n      // System.out.println(\"New tile: \"+id+\", name = \"+tokens[NAME]);\n\n      Tile t = null;\n\n      if (tokens.length > EXTRA) {\n        t =\n            new Tile(\n                id,\n                tileFile.toString(),\n                tokens[NAME].trim(),\n                tokens[TYPE].trim(),\n                tokens[EXTRA].trim());\n      } else {\n        t = new Tile(id, tileFile.toString(), tokens[NAME], tokens[TYPE]);\n      }\n      tiles.add(t);\n    }\n  } // end loadTileset\n"}, {"dataset": "readLine", "exampleID": 544, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 241, "tryExpressionEnd": 245, "tryBlockStart": 241, "tryBlockEnd": 440, "catchExpressionStart": 384, "catchExpressionEnd": 406, "catchBlockStart": 384, "catchBlockEnd": 440, "exceptionHandlingCallStart": [414], "exceptionHandlingCallEnd": [433], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 270, "focalAPIEnd": 284, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.readLine()", "ElGamalKeys.readKeys(line,String)"], "useStart": [308, 331], "useEnd": [322, 375], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hbasold/Krypto-Prakt/tree/master/04_ElGamal/src/task4/ElGamalCipher.java", "rawCode": "  /**\n   * Liest den Schlüssel mit dem Reader <code>key</code>.\n   *\n   * @param key Der Reader, der aus der Schlüsseldatei liest.\n   * @see #makeKey makeKey\n   * @see #writeKey writeKey\n   */\n  public void readKey(BufferedReader key) {\n    try {\n      privateKeyFile = key.readLine();\n      publicKeyFile = key.readLine();\n\n      keys.readKeys(privateKeyFile, publicKeyFile);\n\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 545, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [885], "initializationEnd": [937], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 963, "focalAPIEnd": 976, "followUpCheck": "!line.equals(\"Y\") && !line.equals(\"y\")", "checkType": "IF", "followUpCheckExpressionStart": 984, "followUpCheckExpressionEnd": 1035, "followUpCheckBlockStart": 984, "followUpCheckBlockEnd": 1119, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/derekqian/coDoc/tree/master/edu.pdx.svl.coDoc.cdc/src/edu/pdx/svl/coDoc/cdc/FileCopy.java", "rawCode": "  public static void copy(String fromFileName, String toFileName) throws IOException {\n    File fromFile = new File(fromFileName);\n    File toFile = new File(toFileName);\n\n    if (!fromFile.exists())\n      throw new IOException(\"FileCopy: \" + \"no such source file: \" + fromFileName);\n    if (!fromFile.isFile())\n      throw new IOException(\"FileCopy: \" + \"can't copy directory: \" + fromFileName);\n    if (!fromFile.canRead())\n      throw new IOException(\"FileCopy: \" + \"source file is unreadable: \" + fromFileName);\n\n    if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n\n    if (toFile.exists()) {\n      if (!toFile.canWrite())\n        throw new IOException(\"FileCopy: \" + \"destination file is unwriteable: \" + toFileName);\n      System.out.print(\"Overwrite existing file \" + toFile.getName() + \"? (Y/N): \");\n      System.out.flush();\n      BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n      String response = in.readLine();\n      if (!response.equals(\"Y\") && !response.equals(\"y\"))\n        throw new IOException(\"FileCopy: \" + \"existing file was not overwritten.\");\n    } else {\n      String parent = toFile.getParent();\n      if (parent == null) parent = System.getProperty(\"user.dir\");\n      File dir = new File(parent);\n      if (!dir.exists())\n        throw new IOException(\"FileCopy: \" + \"destination directory doesn't exist: \" + parent);\n      if (dir.isFile())\n        throw new IOException(\"FileCopy: \" + \"destination is not a directory: \" + parent);\n      if (!dir.canWrite())\n        throw new IOException(\"FileCopy: \" + \"destination directory is unwriteable: \" + parent);\n    }\n\n    FileInputStream from = null;\n    FileOutputStream to = null;\n    try {\n      from = new FileInputStream(fromFile);\n      to = new FileOutputStream(toFile);\n      byte[] buffer = new byte[4096];\n      int bytesRead;\n\n      while ((bytesRead = from.read(buffer)) != -1) to.write(buffer, 0, bytesRead); // write\n    } finally {\n      if (from != null)\n        try {\n          from.close();\n        } catch (IOException e) {;\n        }\n      if (to != null)\n        try {\n          to.close();\n        } catch (IOException e) {;\n        }\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 546, "initialization": ["BufferedReader bufferedReader = new BufferedReader(InputStreamReader,int)"], "initializationStart": [576], "initializationEnd": [602], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)", "printStackTrace(*)"], "tryExpressionStart": 264, "tryExpressionEnd": 268, "tryBlockStart": 264, "tryBlockEnd": 2156, "catchExpressionStart": 1871, "catchExpressionEnd": 1893, "catchBlockStart": 1871, "catchBlockEnd": 2037, "exceptionHandlingCallStart": [1901, 1993], "exceptionHandlingCallEnd": [1964, 2022], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 624, "focalAPIEnd": 641, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 649, "followUpCheckExpressionEnd": 669, "followUpCheckBlockStart": 649, "followUpCheckBlockEnd": 1609, "use": ["line.indexOf(char)", "line.substring(int,int)", "line.substring(int)", "line.indexOf(char)", "line.substring(int,int)", "line.substring(int)", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [689, 789, 944, 1107, 1215, 1352, 1583, 1616], "useEnd": [706, 810, 962, 1124, 1236, 1370, 1600, 1630], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/plugins/email/ext/src/inetlib-1.1.1/source/gnu/inet/nntp/FileNewsrc.java", "rawCode": "  /** Load the file. */\n  void load() {\n    long fs = file.length();\n    long max = (long) Integer.MAX_VALUE;\n    int bs = (int) (fs > max ? max : fs);\n\n    groups = new LinkedList();\n    lines = new HashMap(bs / 20);\n    subs = new LinkedList();\n\n    // Load\n    try {\n      long t1 = System.currentTimeMillis();\n      if (debug) {\n        System.err.println(\"DEBUG: nntp: newsrc loading \" + file.getPath());\n      }\n\n      FileInputStream fr = new FileInputStream(file);\n      InputStreamReader ir = new InputStreamReader(fr, NEWSRC_ENCODING);\n      BufferedReader reader = new BufferedReader(ir, bs);\n      String line = reader.readLine();\n      while (line != null) {\n        int cp = line.indexOf(':');\n        if (cp > -1) {\n          // Subscribed newsgroup\n          String name = line.substring(0, cp);\n          groups.add(name);\n          subs.add(name);\n          cp++;\n          if (cp < line.length()) {\n            String tail = line.substring(cp).trim();\n            if (tail.length() > 0) {\n              lines.put(name, tail);\n            }\n          }\n        } else {\n          int pp = line.indexOf('!');\n          if (pp > -1) {\n            // Unsubscribed newsgroup\n            String name = line.substring(0, pp);\n            groups.add(name);\n            pp++;\n            if (pp < line.length()) {\n              String tail = line.substring(pp).trim();\n              if (tail.length() > 0) {\n                lines.put(name, tail);\n              }\n            }\n          }\n          // else ignore - comments etc will not be saved!\n        }\n        line = reader.readLine();\n      }\n      reader.close();\n      long t2 = System.currentTimeMillis();\n      if (debug) {\n        System.err.println(\n            \"DEBUG: nntp: newsrc load: \" + groups.size() + \" groups in \" + (t2 - t1) + \"ms\");\n      }\n    } catch (FileNotFoundException e) {\n    } catch (IOException e) {\n      System.err.println(\"WARNING: nntp: unable to read newsrc file\");\n      if (debug) {\n        e.printStackTrace(System.err);\n      }\n    } catch (SecurityException e) {\n      System.err.println(\"WARNING: nntp: \" + \"no read permission on newsrc file\");\n    }\n    dirty = false;\n  }\n"}, {"dataset": "readLine", "exampleID": 547, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [601], "initializationEnd": [646], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["w(String,String)", "getStackTraceString(*)", "w(String,*)"], "tryExpressionStart": 453, "tryExpressionEnd": 457, "tryBlockStart": 453, "tryBlockEnd": 1326, "catchExpressionStart": 983, "catchExpressionEnd": 1003, "catchBlockStart": 983, "catchBlockEnd": 1096, "exceptionHandlingCallStart": [1011, 1062, 1051], "exceptionHandlingCallEnd": [1043, 1088, 1089], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 688, "focalAPIEnd": 705, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 715, "followUpCheckExpressionEnd": 729, "followUpCheckBlockStart": 715, "followUpCheckBlockEnd": 758, "use": ["line.substring(int)", "bufferedReader.close()"], "useStart": [811, 1159], "useEnd": [825, 1173], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1097, "finallyExpressionEnd": 1105, "finallyBlockStart": 1097, "finallyBlockEnd": 1326, "cleanUpCallStart": [1159], "cleanUpCallEnd": [1173], "url": "https://github.com/zamiang/Atomate/tree/master/listomate/listomate-Android/src/com/listomate/etc/Util.java", "rawCode": "  /**\n   * Returns a debug url, or null. To set the url, create a file {@code\n   * assets/debugging_prefs.properties} with a line of the form 'url=http:/<ip address>:<port>'. A\n   * numeric IP address may be required in situations where the device or emulator will not be able\n   * to resolve the hostname for the dev mode server.\n   */\n  private static String getDebugUrl(Context context) {\n    BufferedReader reader = null;\n    String url = null;\n    try {\n      AssetManager assetManager = context.getAssets();\n      InputStream is = assetManager.open(\"debugging_prefs.properties\");\n      reader = new BufferedReader(new InputStreamReader(is));\n      while (true) {\n        String s = reader.readLine();\n        if (s == null) {\n          break;\n        }\n        if (s.startsWith(\"url=\")) {\n          url = s.substring(4).trim();\n          break;\n        }\n      }\n    } catch (FileNotFoundException e) {\n      // O.K., we will use the production server\n      return null;\n    } catch (Exception e) {\n      Log.w(TAG, \"Got exception \" + e);\n      Log.w(TAG, Log.getStackTraceString(e));\n    } finally {\n      if (reader != null) {\n        try {\n          reader.close();\n        } catch (IOException e) {\n          Log.w(TAG, \"Got exception \" + e);\n          Log.w(TAG, Log.getStackTraceString(e));\n        }\n      }\n    }\n\n    return url;\n  }\n"}, {"dataset": "readLine", "exampleID": 548, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [437], "initializationEnd": [496], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 521, "focalAPIEnd": 534, "followUpCheck": "!line.equals(null)", "checkType": "IF", "followUpCheckExpressionStart": 542, "followUpCheckExpressionEnd": 567, "followUpCheckBlockStart": 542, "followUpCheckBlockEnd": 622, "use": ["parseInt(line)"], "useStart": [575], "useEnd": [599], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JPII/NavalBattle/tree/master/src/com/roketgamer/util/PlayerUtils.java", "rawCode": "  /**\n   * Convert username to user ID. Returns -1 if not found or if operation fails.\n   *\n   * @param username\n   * @return\n   */\n  public static int toId(String username) {\n    try {\n      URL url =\n          new URL(\n              RoketGamer.SERVER_LOCATION\n                  + \"/api/\"\n                  + RoketGamer.VERSION\n                  + \"/public/getuserid.php?user=\"\n                  + username);\n\n      BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n\n      String result = in.readLine();\n      if (!result.equals(null)) return Integer.parseInt(result);\n      else return -1;\n    } catch (Exception e) {\n      return -1;\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 549, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [163], "initializationEnd": [203], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 244, "focalAPIEnd": 258, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 266, "followUpCheckExpressionEnd": 283, "followUpCheckBlockStart": 266, "followUpCheckBlockEnd": 308, "use": ["new File(File,line)"], "useStart": [330], "useEnd": [349], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/paoolo/stomp-contiki/tree/master/tools/z80/java/src/org/markn/contiki/z80/linker/Linker.java", "rawCode": "  private void loadLibfile(String filename) throws IOException {\n    File file = new File(filename);\n    File dir = file.getParentFile();\n    BufferedReader isr = new BufferedReader(new FileReader(file));\n    while (true) {\n      String line = isr.readLine();\n      if (line == null) {\n        break;\n      }\n      File objfile = new File(dir, line);\n      Objfile object = new Objfile(this, objfile);\n      _objfiles.put(objfile, object);\n      object.analyze();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 550, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [267], "initializationEnd": [321], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 367, "focalAPIEnd": 380, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 390, "followUpCheckExpressionEnd": 407, "followUpCheckBlockStart": 390, "followUpCheckBlockEnd": 414, "use": ["line.trim()", "ensureClose(bufferedReader)"], "useStart": [438, 540], "useEnd": [449, 555], "hasFinally": 1, "cleanUpCall": ["ensureClose(BufferedReader)", "ensureClose(FileInputStream)"], "finallyExpressionStart": 524, "finallyExpressionEnd": 532, "finallyBlockStart": 524, "finallyBlockEnd": 585, "cleanUpCallStart": [540, 563], "cleanUpCallEnd": [555, 578], "url": "https://github.com/araqne/logdb/tree/master/araqne-logstorage/src/main/java/org/araqne/logstorage/repair/LogFileRepairerRegistryImpl.java", "rawCode": "  @Validate\n  public void start() throws IOException {\n    File f = getRepairerListFile();\n    if (!f.exists()) return;\n\n    // load file engine list\n    FileInputStream is = null;\n    BufferedReader br = null;\n    try {\n      is = new FileInputStream(f);\n      br = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n\n      while (true) {\n        String line = br.readLine();\n        if (line == null) break;\n\n        String type = line.trim();\n        availableRepairers.put(type, new WaitEvent(type));\n      }\n    } finally {\n      ensureClose(br);\n      ensureClose(is);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 551, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [1188], "initializationEnd": [1258], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1277, "focalAPIEnd": 1294, "followUpCheck": "line == null || line.startsWith(\"ERR\")", "checkType": "IF", "followUpCheckExpressionStart": 1327, "followUpCheckExpressionEnd": 1378, "followUpCheckBlockStart": 1327, "followUpCheckBlockEnd": 1448, "use": ["bufferedReader.close()", "new IOException(line)"], "useStart": [1306, 1393], "useEnd": [1320, 1418], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SpigotMC/BungeeCord/tree/master/proxy/src/main/java/net/md_5/bungee/Metrics.java", "rawCode": "  /** Generic method that posts a plugin to the metrics website */\n  private void postPlugin(boolean isPing) throws IOException {\n    // Construct the post data\n    final StringBuilder data = new StringBuilder();\n    data.append(encode(\"guid\"))\n        .append('=')\n        .append(encode(BungeeCord.getInstance().config.getUuid()));\n    encodeDataPair(data, \"version\", ProxyServer.getInstance().getVersion());\n    encodeDataPair(data, \"server\", \"0\");\n    encodeDataPair(data, \"players\", Integer.toString(ProxyServer.getInstance().getOnlineCount()));\n    encodeDataPair(data, \"revision\", String.valueOf(REVISION));\n\n    // If we're pinging, append it\n    if (isPing) {\n      encodeDataPair(data, \"ping\", \"true\");\n    }\n\n    // Create the url\n    URL url = new URL(BASE_URL + String.format(REPORT_URL, encode(\"BungeeCord\")));\n\n    // Connect to the website\n    URLConnection connection;\n\n    connection = url.openConnection();\n\n    connection.setDoOutput(true);\n    final BufferedReader reader;\n    final String response;\n    try (OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream())) {\n      writer.write(data.toString());\n      writer.flush();\n      reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n      response = reader.readLine();\n    }\n    reader.close();\n\n    if (response == null || response.startsWith(\"ERR\")) {\n      throw new IOException(response); // Throw the exception\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 552, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 150, "focalAPIEnd": 167, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["line.indexOf(char)", "line.substring(*)"], "useStart": [185, 292], "useEnd": [202, 317], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iuval/furry-octo-avenger/tree/master/CrystalClash/CrystalClash/src/com/crystalclash/util/UnitStatsPrefReader.java", "rawCode": "  /** Returns the number of tuple values read (2). */\n  private static String readValue(BufferedReader reader) throws IOException {\n    String line = reader.readLine();\n    int colon = line.indexOf(':');\n    if (colon == -1) throw new GdxRuntimeException(\"Invalid line: \" + line);\n    return line.substring(colon + 1).trim();\n  }\n"}, {"dataset": "readLine", "exampleID": 553, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new IllegalStateException(*)"], "tryExpressionStart": 103, "tryExpressionEnd": 107, "tryBlockStart": 103, "tryBlockEnd": 520, "catchExpressionStart": 449, "catchExpressionEnd": 471, "catchBlockStart": 449, "catchBlockEnd": 520, "exceptionHandlingCallStart": [485], "exceptionHandlingCallEnd": [513], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 172, "focalAPIEnd": 189, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 199, "followUpCheckExpressionEnd": 216, "followUpCheckBlockStart": 199, "followUpCheckBlockEnd": 434, "use": ["bufferedReader.close()"], "useStart": [251], "useEnd": [265], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fcrepo/fcrepo-before33/tree/master/fcrepo-client/fcrepo-client-admin/src/main/java/fedora/client/utility/validate/process/PidfileIterator.java", "rawCode": "  /** Scan through the file until we get an EOF or a good line. */\n  private void fillNextLine() {\n    try {\n      while (nextLine == null && !eof) {\n        String line = reader.readLine();\n        if (line == null) {\n          eof = true;\n          reader.close();\n        } else if (isBlank(line)) {\n          continue;\n        } else if (isComment(line)) {\n          continue;\n        } else {\n          nextLine = line;\n        }\n      }\n    } catch (IOException e) {\n      throw new IllegalStateException(e);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 554, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [633], "initializationEnd": [673], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 788, "focalAPIEnd": 801, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string_to_object(line)", "bufferedReader.close()"], "useStart": [767, 809], "useEnd": [802, 819], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/metaswirl/middleware/tree/master/3/jacorb-3.2/demo/ssl/src/demo/ssl/Client.java", "rawCode": "  public static void main(String args[]) throws Exception {\n    if (args.length != 1) {\n      System.out.println(\"Usage: java demo.ssl.Client <ior_file>\");\n      System.exit(1);\n    }\n\n    File file = new File(args[0]);\n\n    // check if file exists\n    if (!file.exists()) {\n      System.out.println(\"File \" + args[0] + \" does not exist.\");\n\n      System.exit(-1);\n    }\n\n    // check if args[0] points to a directory\n    if (file.isDirectory()) {\n      System.out.println(\"File \" + args[0] + \" is a directory.\");\n\n      System.exit(-1);\n    }\n\n    // initialize the ORB.\n    ORB orb = ORB.init(args, null);\n\n    BufferedReader br = new BufferedReader(new FileReader(file));\n\n    // get object reference from command-line argument file\n    org.omg.CORBA.Object obj = orb.string_to_object(br.readLine());\n\n    br.close();\n\n    // narrow to right type\n    SSLDemo demo = SSLDemoHelper.narrow(obj);\n\n    System.out.println(\"[Client] about to invoke printCert()\");\n\n    try {\n      // call single operation\n      demo.printCert();\n\n      System.out.println(\"[Client] Call to server succeeded\");\n    } catch (Exception e) {\n      System.out.println(\"[Client] failed to invoke: \" + e.getMessage());\n      System.exit(1);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 555, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [4635], "initializationEnd": [4705], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 4729, "focalAPIEnd": 4746, "followUpCheck": "line == null || line.startsWith(\"ERR\") || line.startsWith(\"7\")", "checkType": "IF", "followUpCheckExpressionStart": 4813, "followUpCheckExpressionEnd": 4892, "followUpCheckBlockStart": 4813, "followUpCheckBlockEnd": 5581, "use": ["bufferedReader.close()", "line.startsWith(String)", "line.substring(*)", "new IOException(line)"], "useStart": [4792, 4867, 5016, 5092], "useEnd": [4806, 4891, 5069, 5117], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Hidendra/Plugin-Metrics/tree/master/mods/canary/metrics/src/main/java/org/mcstats/Metrics.java", "rawCode": "  /** Generic method that posts a plugin to the metrics website */\n  private void postPlugin(final boolean isPing) throws IOException {\n    // Server software specific section\n    PluginDescriptor description = plugin.getDescriptor();\n    String pluginName = description.getName();\n    boolean onlineMode =\n        Configuration.getServerConfig().isOnlineMode(); // TRUE if online mode is enabled\n    String pluginVersion = description.getVersion();\n    String serverVersion =\n        String.format(\n            \"%s %s (MC: %s)\",\n            Canary.getSpecificationTitle(),\n            Canary.getSpecificationVersion(),\n            Canary.getServer().getServerVersion());\n    int playersOnline = Canary.getServer().getNumPlayersOnline();\n\n    // END server software specific section -- all code below does not use any code outside of this\n    // class / Java\n\n    // Construct the post data\n    StringBuilder json = new StringBuilder(1024);\n    json.append('{');\n\n    // The plugin's description file containg all of the plugin data such as name, version, author,\n    // etc\n    appendJSONPair(json, \"guid\", guid);\n    appendJSONPair(json, \"plugin_version\", pluginVersion);\n    appendJSONPair(json, \"server_version\", serverVersion);\n    appendJSONPair(json, \"players_online\", Integer.toString(playersOnline));\n\n    // New data as of R6\n    String osname = System.getProperty(\"os.name\");\n    String osarch = System.getProperty(\"os.arch\");\n    String osversion = System.getProperty(\"os.version\");\n    String java_version = System.getProperty(\"java.version\");\n    int coreCount = Runtime.getRuntime().availableProcessors();\n\n    // normalize os arch .. amd64 -> x86_64\n    if (osarch.equals(\"amd64\")) {\n      osarch = \"x86_64\";\n    }\n\n    appendJSONPair(json, \"osname\", osname);\n    appendJSONPair(json, \"osarch\", osarch);\n    appendJSONPair(json, \"osversion\", osversion);\n    appendJSONPair(json, \"cores\", Integer.toString(coreCount));\n    appendJSONPair(json, \"auth_mode\", onlineMode ? \"1\" : \"0\");\n    appendJSONPair(json, \"java_version\", java_version);\n\n    // If we're pinging, append it\n    if (isPing) {\n      appendJSONPair(json, \"ping\", \"1\");\n    }\n\n    if (graphs.size() > 0) {\n      synchronized (graphs) {\n        json.append(',');\n        json.append('\"');\n        json.append(\"graphs\");\n        json.append('\"');\n        json.append(':');\n        json.append('{');\n\n        boolean firstGraph = true;\n\n        final Iterator<Graph> iter = graphs.iterator();\n\n        while (iter.hasNext()) {\n          Graph graph = iter.next();\n\n          StringBuilder graphJson = new StringBuilder();\n          graphJson.append('{');\n\n          for (Plotter plotter : graph.getPlotters()) {\n            appendJSONPair(\n                graphJson, plotter.getColumnName(), Integer.toString(plotter.getValue()));\n          }\n\n          graphJson.append('}');\n\n          if (!firstGraph) {\n            json.append(',');\n          }\n\n          json.append(escapeJSON(graph.getName()));\n          json.append(':');\n          json.append(graphJson);\n\n          firstGraph = false;\n        }\n\n        json.append('}');\n      }\n    }\n\n    // close json\n    json.append('}');\n\n    // Create the url\n    URL url = new URL(BASE_URL + String.format(REPORT_URL, urlEncode(pluginName)));\n\n    // Connect to the website\n    URLConnection connection;\n\n    // Mineshafter creates a socks proxy, so we can safely bypass it\n    // It does not reroute POST requests so we need to go around it\n    if (isMineshafterPresent()) {\n      connection = url.openConnection(Proxy.NO_PROXY);\n    } else {\n      connection = url.openConnection();\n    }\n\n    byte[] uncompressed = json.toString().getBytes();\n    byte[] compressed = gzip(json.toString());\n\n    // Headers\n    connection.addRequestProperty(\"User-Agent\", \"MCStats/\" + REVISION);\n    connection.addRequestProperty(\"Content-Type\", \"application/json\");\n    connection.addRequestProperty(\"Content-Encoding\", \"gzip\");\n    connection.addRequestProperty(\"Content-Length\", Integer.toString(compressed.length));\n    connection.addRequestProperty(\"Accept\", \"application/json\");\n    connection.addRequestProperty(\"Connection\", \"close\");\n\n    connection.setDoOutput(true);\n\n    if (debug) {\n      System.out.println(\n          \"[Metrics] Prepared request for \"\n              + pluginName\n              + \" uncompressed=\"\n              + uncompressed.length\n              + \" compressed=\"\n              + compressed.length);\n    }\n\n    // Write the data\n    OutputStream os = connection.getOutputStream();\n    os.write(compressed);\n    os.flush();\n\n    // Now read the response\n    final BufferedReader reader =\n        new BufferedReader(new InputStreamReader(connection.getInputStream()));\n    String response = reader.readLine();\n\n    // close resources\n    os.close();\n    reader.close();\n\n    if (response == null || response.startsWith(\"ERR\") || response.startsWith(\"7\")) {\n      if (response == null) {\n        response = \"null\";\n      } else if (response.startsWith(\"7\")) {\n        response = response.substring(response.startsWith(\"7,\") ? 2 : 1);\n      }\n\n      throw new IOException(response);\n    } else {\n      // Is this the first update this hour?\n      if (response.equals(\"1\") || response.contains(\"This is your first update this hour\")) {\n        synchronized (graphs) {\n          final Iterator<Graph> iter = graphs.iterator();\n\n          while (iter.hasNext()) {\n            final Graph graph = iter.next();\n\n            for (Plotter plotter : graph.getPlotters()) {\n              plotter.reset();\n            }\n          }\n        }\n      }\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 556, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [1820], "initializationEnd": [1895], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1915, "focalAPIEnd": 1932, "followUpCheck": "(line) != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 2027, "followUpCheckExpressionEnd": 2069, "followUpCheckBlockStart": 2027, "followUpCheckBlockEnd": 2121, "use": ["assertNotNull(line)", "line.startsWith(String)"], "useStart": [1938, 1988], "useEnd": [1964, 2020], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jetty-project/jetty-plugin-support/tree/master/jetty-client/src/test/java/org/eclipse/jetty/client/SslBytesServerTest.java", "rawCode": "  @Test\n  public void testRequestWithContentWithSplitBoundary() throws Exception {\n    final SSLSocket client = newClient();\n\n    SimpleProxy.AutomaticFlow automaticProxyFlow = proxy.startAutomaticFlow();\n    client.startHandshake();\n    Assert.assertTrue(automaticProxyFlow.stop(5, TimeUnit.SECONDS));\n\n    final String content = \"0123456789ABCDEF\";\n\n    Future<Object> request =\n        threadPool.submit(\n            new Callable<Object>() {\n              public Object call() throws Exception {\n                OutputStream clientOutput = client.getOutputStream();\n                clientOutput.write(\n                    (\"\"\n                            + \"POST / HTTP/1.1\\r\\n\"\n                            + \"Host: localhost\\r\\n\"\n                            + \"Content-Type: text/plain\\r\\n\"\n                            + \"Content-Length: \"\n                            + content.length()\n                            + \"\\r\\n\"\n                            + \"\\r\\n\"\n                            + content)\n                        .getBytes(\"UTF-8\"));\n                clientOutput.flush();\n                return null;\n              }\n            });\n\n    // Application data\n    TLSRecord record = proxy.readFromClient();\n    Assert.assertNull(request.get(5, TimeUnit.SECONDS));\n    byte[] chunk1 = new byte[2 * record.getBytes().length / 3];\n    System.arraycopy(record.getBytes(), 0, chunk1, 0, chunk1.length);\n    proxy.flushToServer(100, chunk1);\n\n    byte[] chunk2 = new byte[record.getBytes().length - chunk1.length];\n    System.arraycopy(record.getBytes(), chunk1.length, chunk2, 0, chunk2.length);\n    proxy.flushToServer(100, chunk2);\n\n    record = proxy.readFromServer();\n    Assert.assertEquals(TLSRecord.Type.APPLICATION, record.getType());\n    proxy.flushToClient(record);\n\n    BufferedReader reader =\n        new BufferedReader(new InputStreamReader(client.getInputStream(), \"UTF-8\"));\n    String line = reader.readLine();\n    Assert.assertNotNull(line);\n    Assert.assertTrue(line.startsWith(\"HTTP/1.1 200 \"));\n    while ((line = reader.readLine()) != null) {\n      if (line.trim().length() == 0) break;\n    }\n\n    // Check that we did not spin\n    TimeUnit.MILLISECONDS.sleep(500);\n    Assert.assertThat(sslHandles.get(), lessThan(20));\n    Assert.assertThat(sslFlushes.get(), lessThan(20));\n    Assert.assertThat(httpParses.get(), lessThan(50));\n\n    closeClient(client);\n  }\n"}, {"dataset": "readLine", "exampleID": 557, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1133, "focalAPIEnd": 1145, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["print(line)"], "useStart": [1107], "useEnd": [1146], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/unsupported/wfs/src/test/java/org/geotools/data/wfs/v1_0_0/demo/PostDemo.java", "rawCode": "  public static void main(String[] args) throws IOException {\n    String s =\n        \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n            + \"<DescribeFeatureType xmlns=\\\"http://www.opengis.net/wfs\\\" \"\n            + \"xmlns:gml=\\\"http://www.opengis.net/gml\\\" \"\n            + \"xmlns:ogc=\\\"http://www.opengis.net/ogc\\\" version=\\\"1.0.0\\\" \"\n            + \"service=\\\"WFS\\\" outputFormat=\\\"XMLSCHEMA\\\">\"\n            + \"<TypeName>envirodat</TypeName></DescribeFeatureType>\";\n\n    System.out.println(s + \"\\n\\n\\n\");\n    URL url = new URL(\"http://map.ns.ec.gc.ca/envdat/map.aspx?\");\n\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    connection.setRequestMethod(\"POST\");\n    connection.setDoOutput(true);\n    connection.setDoInput(true);\n    connection.setRequestProperty(\"Content-type\", \"application/xml\");\n\n    url.openConnection().connect();\n    Writer w = new OutputStreamWriter(connection.getOutputStream());\n    w.write(s);\n    w.flush();\n    w.close();\n    BufferedReader r = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n    while (r.ready()) {\n      System.out.print((String) r.readLine());\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 558, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 56, "tryExpressionEnd": 60, "tryBlockStart": 56, "tryBlockEnd": 196, "catchExpressionStart": 107, "catchExpressionEnd": 127, "catchBlockStart": 107, "catchBlockEnd": 196, "exceptionHandlingCallStart": [135], "exceptionHandlingCallEnd": [172], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 83, "focalAPIEnd": 99, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wox2/migrace_databaze/tree/master/skola/Fel_bc/1.semestr/Algoritmizace/Java/Programy1250/Kap05/02/MojeIO.java", "rawCode": "  public static String inStr() throws IOException {\n    try {\n      return radek = stdin.readLine();\n    } catch (Exception e) {\n      System.err.println(\"chyba v retezci\");\n      return \"\";\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 559, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*,int)"], "initializationStart": [286], "initializationEnd": [335], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 360, "focalAPIEnd": 377, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.close()"], "useStart": [401], "useEnd": [415], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 385, "finallyExpressionEnd": 393, "finallyBlockStart": 385, "finallyBlockEnd": 422, "cleanUpCallStart": [401], "cleanUpCallEnd": [415], "url": "https://github.com/teamgummy/packages_apps_Settings/tree/master/src/com/android/settings/DeviceInfoSettings.java", "rawCode": "  /**\n   * Reads a line from the specified file.\n   *\n   * @param filename the file to read from\n   * @return the first line, if any.\n   * @throws IOException if the file couldn't be read\n   */\n  private String readLine(String filename) throws IOException {\n    BufferedReader reader = new BufferedReader(new FileReader(filename), 256);\n    try {\n      return reader.readLine();\n    } finally {\n      reader.close();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 560, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [310], "initializationEnd": [353], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 546, "tryExpressionEnd": 550, "tryBlockStart": 546, "tryBlockEnd": 1359, "catchExpressionStart": 1303, "catchExpressionEnd": 1325, "catchBlockStart": 1303, "catchBlockEnd": 1359, "exceptionHandlingCallStart": [1333], "exceptionHandlingCallEnd": [1352], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 618, "focalAPIEnd": 631, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.readLine()", "bufferedReader.readLine()", "bufferedReader.readLine()", "bufferedReader.close()", "writeIndexHTML(ArrayList,ArrayList,line,String)", "writeOneHTML(String,*,*,*,line,String)", "writeOneHTML(*,*,String,*,line,String)", "writeOneHTML(*,*,*,*,line,String)"], "useStart": [649, 757, 975, 1285, 1410, 1799, 2124, 2429], "useEnd": [662, 770, 988, 1295, 1465, 2001, 2326, 2655], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/timcheadle/cs-projects/tree/master/swe432/hw7/src/H7_tcheadle.java", "rawCode": "  public static void main(String[] argv) throws IOException {\n    ArrayList images = new ArrayList();\n    ArrayList titles = new ArrayList();\n    int numFiles = 0;\n\n    // Read the list of file names from the file \"H7-tcheadle-data.txt\"\n    // Try to open the file.\n    BufferedReader in;\n    try {\n      in = new BufferedReader(new FileReader(JPGFILE));\n    } catch (FileNotFoundException e) {\n      System.out.println(\"Need a file called \\\"\" + JPGFILE + \"\\\".\");\n      return;\n    }\n\n    String collectionName = \"\";\n    String bgColor = \"\";\n    try {\n      // Read the repeating string (title)\n      collectionName = in.readLine();\n      bgColor = in.readLine();\n\n      // Read the names from the input file\n      String inString;\n      while ((inString = in.readLine()) != null) {\n        // If the image name isn't a valid URL, print an error and ignore it\n        if (!inString.matches(URLREGEX)) {\n          // Make sure to ignore the following title line too\n          in.readLine();\n          System.err.println(\"Not a valid image URL\" + inString);\n        } else {\n          // If the URL was valid, add it and its description line to the proper arrays\n          images.add(inString);\n          inString = in.readLine();\n          titles.add(inString);\n        }\n      }\n      in.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n\n    try {\n      if (images.size() > 0) {\n        writeIndexHTML(images, titles, collectionName, bgColor);\n      }\n    } catch (IOException e) {\n      System.err.println(\"Could not write index.html: \" + e.getMessage());\n    }\n\n    // If we actually found some images, print them out\n    for (int i = 0; i < images.size(); i++) {\n      try {\n        // If we're at the first image, ignore the previous image\n        if (i == 0) {\n          writeOneHTML(\n              \"\",\n              (String) images.get(i),\n              (String) images.get(i + 1),\n              (String) titles.get(i),\n              collectionName,\n              bgColor);\n        }\n        // If we at the last image, ignore the next image\n        else if (i == images.size() - 1) {\n          writeOneHTML(\n              (String) images.get(i - 1),\n              (String) images.get(i),\n              \"\",\n              (String) titles.get(i),\n              collectionName,\n              bgColor);\n        }\n        // Otherwise, select the previous, current and next image\n        else {\n          writeOneHTML(\n              (String) images.get(i - 1),\n              (String) images.get(i),\n              (String) images.get(i + 1),\n              (String) titles.get(i),\n              collectionName,\n              bgColor);\n        }\n      } catch (IOException e) {\n        System.err.println(\n            \"Could not write file for image '\" + (String) images.get(i) + \"': \" + e.getMessage());\n      }\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 561, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 124, "focalAPIEnd": 141, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new StringTokenizer(line)"], "useStart": [104], "useEnd": [142], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ftiasch/acm-icpc/tree/master/codeforces/434-codeforces-round-248/A/Main.java", "rawCode": "  private String next() throws IOException {\n    while (!tokenizer.hasMoreTokens()) {\n      tokenizer = new StringTokenizer(reader.readLine());\n    }\n    return tokenizer.nextToken();\n  }\n"}, {"dataset": "readLine", "exampleID": 562, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [322], "initializationEnd": [375], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 395, "focalAPIEnd": 412, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 473, "followUpCheckExpressionEnd": 493, "followUpCheckBlockStart": 473, "followUpCheckBlockEnd": 1564, "use": ["bufferedReader.readLine()", "line.split(String)", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [545, 645, 1540, 1570], "useEnd": [562, 662, 1557, 1584], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ARUP-NGS/Pipeline/tree/master/src/main/java/buffer/BEDFile.java", "rawCode": "  /**\n   * Construct/initialize a map which allows us to easily look up which sites are in the intervals\n   * described by this BED file. If arg is true, strip chr from all contig labels\n   *\n   * @throws IOException\n   */\n  public void buildIntervalsMap(boolean stripChr) throws IOException {\n    BufferedReader reader = new BufferedReader(new FileReader(getAbsolutePath()));\n    String line = reader.readLine();\n    intervals = new HashMap<String, List<Interval>>();\n    while (line != null) {\n      if (line.startsWith(\"#\")) {\n        line = reader.readLine();\n        continue;\n      }\n      if (line.length() > 0) {\n        String[] toks = line.split(\"\\\\s\");\n        String contig = toks[0];\n        if (stripChr) contig = contig.replace(\"chr\", \"\");\n        toks[1] = toks[1].trim();\n        toks[2] = toks[2].trim();\n        try {\n          Integer begin = Integer.parseInt(toks[1]) + 1;\n          Integer end = Integer.parseInt(toks[2]) + 1;\n          Interval interval = new Interval(begin, end);\n\n          List<Interval> contigIntervals = intervals.get(contig);\n          if (contigIntervals == null) {\n            contigIntervals = new ArrayList<Interval>(1024);\n            intervals.put(contig, contigIntervals);\n            // System.out.println(\"BED file adding contig: \" + contig);\n          }\n          contigIntervals.add(interval);\n        } catch (Exception ex) {\n          Logger.getLogger(Pipeline.primaryLoggerName)\n              .warning(\"Skipping invalid line in bed file: \" + line);\n        }\n      }\n      line = reader.readLine();\n    }\n\n    reader.close();\n    sortAllContigs();\n  }\n"}, {"dataset": "readLine", "exampleID": 563, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [1143], "initializationEnd": [1187], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()", "exit(int)"], "tryExpressionStart": 1109, "tryExpressionEnd": 1113, "tryBlockStart": 1109, "tryBlockEnd": 1704, "catchExpressionStart": 1619, "catchExpressionEnd": 1641, "catchBlockStart": 1619, "catchBlockEnd": 1704, "exceptionHandlingCallStart": [1651, 1680], "exceptionHandlingCallEnd": [1670, 1695], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1197, "focalAPIEnd": 1210, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.close()", "bufferedReader.close()"], "useStart": [1599, 3993], "useEnd": [1609, 4003], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/conceptstailored/NCSU-GBS-Pipeline/tree/master/TASSEL_20121011/maizegenetics/src/net/maizegenetics/gwas/NAMgwas/Utilities.java", "rawCode": "  public static void countTermsByAnnotation() {\n\n    class PositionInfo {\n      ArrayList<String> annotations = new ArrayList<String>();\n      int count = 0;\n\n      @Override\n      public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(count);\n        for (String anno : annotations) sb.append(\"\\t\").append(anno);\n        return sb.toString();\n      }\n    }\n\n    Pattern tab = Pattern.compile(\"\\t\");\n    ArrayList<HashMap<Integer, PositionInfo>> chromosomeMaps =\n        new ArrayList<HashMap<Integer, PositionInfo>>();\n    // Object[] is count (Integer), ArrayList<String> to hold annotations\n    String trait = \"angle\";\n\n    System.out.println(\"Reading step terms...\");\n    for (int chr = 1; chr <= 10; chr++) {\n      String filename =\n          \"C:/Projects/NAM/hapmap/results/minor/\"\n              + trait\n              + \"/\"\n              + trait\n              + \".bootstrap.random.steps.chr\"\n              + chr\n              + \".v4.txt\";\n      HashMap<Integer, PositionInfo> thisMap = new HashMap<Integer, PositionInfo>();\n      chromosomeMaps.add(thisMap);\n      try {\n        BufferedReader br = new BufferedReader(new FileReader(filename));\n        br.readLine();\n        String input;\n        while ((input = br.readLine()) != null) {\n          String[] data = tab.split(input);\n          Integer pos = Integer.decode(data[1]);\n          PositionInfo posInfo = thisMap.get(pos);\n          if (posInfo == null) {\n            posInfo = new PositionInfo();\n            thisMap.put(pos, posInfo);\n          }\n          posInfo.count++;\n        }\n        br.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n        System.exit(-1);\n      }\n    }\n\n    // output counts here\n    try {\n      String filename = \"C:/Projects/NAM/hapmap/results/minor/RFR_term_counts.txt\";\n      BufferedWriter bw = new BufferedWriter(new FileWriter(filename));\n      bw.write(\"chromosome\\tpos\\tcount\");\n      bw.newLine();\n      for (int c = 0; c < 10; c++) {\n        String chr = Integer.toString(c + 1);\n        HashMap<Integer, PositionInfo> thisMap = chromosomeMaps.get(c);\n        TreeSet<Integer> posSet = new TreeSet<Integer>(thisMap.keySet());\n        for (Integer pos : posSet) {\n          PositionInfo pi = thisMap.get(pos);\n          bw.write(chr + \"\\t\" + pos + \"\\t\" + pi.count);\n          bw.newLine();\n        }\n      }\n      bw.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    String filename = \"C:/Projects/NAM/hapmap/snpinfo/BGI-CSHLALL-UNION.HP1.snp_effects.txt\";\n    int curr_chr = 0;\n    String input = \"beginning\";\n    HashMap<String, Integer> annotationCount = new HashMap<String, Integer>();\n    // record annotations for model terms\n    try {\n      BufferedReader br = new BufferedReader(new FileReader(filename));\n      int count = -1;\n      while ((input = br.readLine()) != null) {\n        String[] data = tab.split(input);\n        Integer pos = Integer.decode(data[1]);\n        int chr = Integer.parseInt(data[0].substring(3));\n        if (chr != curr_chr) {\n          TreeSet<String> names = new TreeSet(annotationCount.keySet());\n          for (String anno : names) {\n            System.out.println(\"chr\" + curr_chr + \"\\t\" + anno + \"\\t\" + annotationCount.get(anno));\n          }\n          curr_chr = chr;\n          annotationCount.clear();\n        }\n        Integer cnt = annotationCount.get(data[6]);\n        if (cnt == null) cnt = annotationCount.put(data[6], new Integer(1));\n        else annotationCount.put(data[6], ++cnt);\n        HashMap<Integer, PositionInfo> thisMap = chromosomeMaps.get(chr - 1);\n        PositionInfo posInfo = thisMap.get(pos);\n        if (posInfo != null) {\n          posInfo.annotations.add(data[6]);\n        }\n      }\n      TreeSet<String> names = new TreeSet<String>(annotationCount.keySet());\n      for (String anno : names) {\n        System.out.println(\"chr\" + curr_chr + \"\\t\" + anno + \"\\t\" + annotationCount.get(anno));\n      }\n\n      br.close();\n    } catch (IOException e) {\n      System.err.println(\"failed at: \" + input);\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    System.out.println(\"Printing annotation summary...\");\n\n    // get set of annotations\n    TreeSet<String> annotationSet = new TreeSet<String>();\n    for (HashMap<Integer, PositionInfo> map : chromosomeMaps) {\n      for (PositionInfo pi : map.values()) {\n        annotationSet.addAll(pi.annotations);\n      }\n    }\n\n    // count annotations by chromosome\n    int nAnno = annotationSet.size();\n    ArrayList<String> annotationList = new ArrayList<String>(annotationSet);\n    int[][] counts = new int[nAnno][10];\n    for (int chr = 0; chr < 10; chr++) {\n      for (PositionInfo pi : chromosomeMaps.get(chr).values()) {\n        for (String anno : pi.annotations) {\n          int n = annotationList.indexOf(anno);\n          counts[n][chr]++;\n        }\n      }\n    }\n\n    try {\n      BufferedWriter bw =\n          new BufferedWriter(\n              new FileWriter(\"C:/Projects/NAM/hapmap/snpinfo/hp2_annotation_summary.txt\"));\n      bw.write(\"annotation\\tchr1\\tchr2\\tchr3\\tchr4\\tchr5\\tchr6\\tchr7\\tchr8\\tchr9\\tchr10\");\n      bw.newLine();\n      for (int i = 0; i < nAnno; i++) {\n        bw.write(annotationList.get(i));\n        for (int j = 0; j < 10; j++) {\n          bw.write(\"\\t\");\n          bw.write(Integer.toString(counts[i][j]));\n        }\n        bw.newLine();\n      }\n\n      bw.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    // also output annotations for each term\n    try {\n      BufferedWriter bw =\n          new BufferedWriter(\n              new FileWriter(\"C:/Projects/NAM/hapmap/snpinfo/hp2_model_annotations.txt\"));\n      bw.write(\"chr\\tposition\\tcount\\tannotations\");\n      bw.newLine();\n\n      for (int c = 0; c < 10; c++) {\n        String chr = Integer.toString(c + 1);\n        HashMap<Integer, PositionInfo> thisMap = chromosomeMaps.get(c);\n        TreeSet<Integer> positions = new TreeSet<Integer>(thisMap.keySet());\n        for (Integer pos : positions) {\n          PositionInfo pi = thisMap.get(pos);\n          bw.write(chr + \"\\t\" + pos + \"\\t\" + pi);\n          bw.newLine();\n        }\n      }\n      bw.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n      System.exit(-1);\n    }\n\n    System.out.println(\"Finished\");\n  }\n"}, {"dataset": "readLine", "exampleID": 564, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [206], "initializationEnd": [258], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 974, "focalAPIEnd": 988, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["TiffSaver.overwriteComment(RandomAccessInputStream,line)"], "useStart": [1188], "useEnd": [1219], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mhl/libbio-formats-java/tree/master/components/bio-formats/utils/EditTiffComment.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    if (args.length == 0) {\n      System.out.println(\"Usage: java EditTiffComment file1 file2 ...\");\n      return;\n    }\n    BufferedReader cin = new BufferedReader(new InputStreamReader(System.in));\n    for (int i = 0; i < args.length; i++) {\n      String f = args[i];\n      // read comment\n      System.out.println(\"Reading \" + f + \" \");\n      String comment = new TiffParser(f).getComment();\n      // or if you already have the file open for random access, you can use:\n      // RandomAccessInputStream fin = new RandomAccessInputStream(f);\n      // TiffParser tiffParser = new TiffParser(fin);\n      // String comment = tiffParser.getComment();\n      // fin.close();\n      System.out.println(\"[done]\");\n      // display comment, and prompt for changes\n      System.out.println(\"Comment =\");\n      System.out.println(comment);\n      System.out.println(\"Enter new comment (no line breaks):\");\n      String xml = cin.readLine();\n      System.out.print(\"Saving \" + f);\n      // save results back to the TIFF file\n      TiffSaver saver = new TiffSaver(f);\n      RandomAccessInputStream in = new RandomAccessInputStream(f);\n      saver.overwriteComment(in, xml);\n      in.close();\n      System.out.println(\" [done]\");\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 565, "initialization": ["BufferedReader bufferedReader = new BufferedReader(InputStreamReader)"], "initializationStart": [222], "initializationEnd": [245], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(*)"], "tryExpressionStart": 275, "tryExpressionEnd": 279, "tryBlockStart": 275, "tryBlockEnd": 582, "catchExpressionStart": 524, "catchExpressionEnd": 546, "catchBlockStart": 524, "catchBlockEnd": 582, "exceptionHandlingCallStart": [554], "exceptionHandlingCallEnd": [575], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 294, "focalAPIEnd": 311, "followUpCheck": "!\"quit\".equals(line)", "checkType": "LOOP {", "followUpCheckExpressionStart": 319, "followUpCheckExpressionEnd": 347, "followUpCheckBlockStart": 319, "followUpCheckBlockEnd": 517, "use": ["TextDataMessage.setText(line)", "bufferedReader.readLine()"], "useStart": [415, 491], "useEnd": [436, 508], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iotcloud/IoTCloud/tree/master/modules/core/src/test/java/cgl/iotcloud/core/ChatSensor.java", "rawCode": "  public void runSensor() {\n    TextSensor sensor = new TextSensor(Constants.SENSOR_TYPE_BLOCK, \"chat-sensor\");\n    sensor.init();\n\n    InputStreamReader cin = new InputStreamReader(System.in);\n    BufferedReader reader = new BufferedReader(cin);\n    String chat = null;\n    try {\n      chat = reader.readLine();\n      while (!\"quit\".equals(chat)) {\n        TextDataMessage message = new TextDataMessage();\n        message.setText(chat);\n        sensor.sendMessage(message);\n\n        chat = reader.readLine();\n      }\n    } catch (IOException e) {\n      System.out.println(e);\n    }\n\n    sensor.destroy();\n  }\n"}, {"dataset": "readLine", "exampleID": 566, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [180], "initializationEnd": [261], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 293, "focalAPIEnd": 306, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 314, "followUpCheckExpressionEnd": 334, "followUpCheckBlockStart": 314, "followUpCheckBlockEnd": 630, "use": ["line.indexOf(char)", "line.substring(int,*)", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [384, 366, 608, 673], "useEnd": [401, 402, 621, 683], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 657, "finallyExpressionEnd": 665, "finallyBlockStart": 657, "finallyBlockEnd": 690, "cleanUpCallStart": [673], "cleanUpCallEnd": [683], "url": "https://github.com/iLuxo/jgit-clone/tree/master/org.eclipse.jgit.test/tst/org/eclipse/jgit/api/RebaseCommandTest.java", "rawCode": "  private int countPicks() throws IOException {\n    int count = 0;\n    File todoFile = new File(db.getDirectory(), \"rebase-merge/git-rebase-todo\");\n    BufferedReader br =\n        new BufferedReader(new InputStreamReader(new FileInputStream(todoFile), \"UTF-8\"));\n    try {\n      String line = br.readLine();\n      while (line != null) {\n        String actionToken = line.substring(0, line.indexOf(' '));\n        Action action = null;\n        try {\n          action = Action.parse(actionToken);\n        } catch (Exception e) {\n          // ignore\n        }\n        if (action != null) count++;\n        line = br.readLine();\n      }\n      return count;\n    } finally {\n      br.close();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 567, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [157], "initializationEnd": [205], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 310, "focalAPIEnd": 323, "followUpCheck": "(line) != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 329, "followUpCheckExpressionEnd": 371, "followUpCheckBlockStart": 329, "followUpCheckBlockEnd": 1530, "use": ["line.split(String)"], "useStart": [422], "useEnd": [441], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pcoriente/LaAnita/tree/master/LaAnita/src/java/pedidos/LeerTextuales/LeerTextuales.java", "rawCode": "  public ArrayList<Imss> leerArchivoImss(File archivoTexto) throws IOException {\n    ArrayList<Imss> lstIms = new ArrayList<Imss>();\n    BufferedReader in = new BufferedReader(new FileReader(archivoTexto));\n    String registro;\n    String anio;\n    String mes;\n    String dia;\n    String fecha;\n    registro = in.readLine();\n    while ((registro = in.readLine()) != null) {\n      String[] pedidoArray;\n      pedidoArray = registro.split(\",\");\n      Imss ims = new Imss();\n      ims.setOrdenCompra(pedidoArray[0]);\n      anio = pedidoArray[1].substring(6);\n      mes = pedidoArray[1].substring(3, 5);\n      dia = pedidoArray[1].substring(0, 2);\n      fecha = anio + \"-\" + mes + \"-\" + dia;\n      ims.setFechaElaboracion(Date.valueOf(fecha));\n      ims.setFechaEmbarque(Date.valueOf(fecha));\n      anio = pedidoArray[2].substring(6);\n      mes = pedidoArray[2].substring(3, 5);\n      dia = pedidoArray[2].substring(0, 2);\n      fecha = anio + \"-\" + mes + \"-\" + dia;\n      ims.setFechaCancelacion(Date.valueOf(fecha));\n      ims.setCodigoTienda(Integer.parseInt(pedidoArray[3]));\n      ims.setDescripcion(pedidoArray[12]);\n      ims.setSku(pedidoArray[10]);\n      ims.setUpc(pedidoArray[11]);\n      ims.setCantidad(\n          (Float.parseFloat(pedidoArray[14].substring(0, 2)))\n              * (Float.parseFloat(pedidoArray[16])));\n      ims.setEmpaque(Float.parseFloat(pedidoArray[14].substring(0, 2)));\n      ims.setCosto(Float.parseFloat(pedidoArray[17]));\n      ims.setNumeroProveedor(pedidoArray[5]);\n      lstIms.add(ims);\n    }\n    return lstIms;\n  }\n"}, {"dataset": "readLine", "exampleID": 568, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [612], "initializationEnd": [674], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getResponseCode()", "error(*,*)"], "tryExpressionStart": 710, "tryExpressionEnd": 714, "tryBlockStart": 710, "tryBlockEnd": 792, "catchExpressionStart": 758, "catchExpressionEnd": 781, "catchBlockStart": 758, "catchBlockEnd": 792, "exceptionHandlingCallStart": [811, 801], "exceptionHandlingCallEnd": [830, 848], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 733, "focalAPIEnd": 746, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NewMediaCenter/MobileWeb/tree/master/sakai/impl/src/main/java/org/kuali/mobility/sakai/service/SakaiForumServiceImpl.java", "rawCode": "  @Override\n  public ResponseEntity<String> markMessageRead(String siteId, String messageId, String userId) {\n    try {\n      String url =\n          configParamService.findValueByName(\"Sakai.Url.Base\")\n              + \"forum_message/markread/\"\n              + messageId\n              + \"/site/\"\n              + siteId;\n      ResponseEntity<InputStream> response =\n          oncourseOAuthService.oAuthPostRequest(userId, url, \"text/html\", \"\");\n      return new ResponseEntity<String>(response.getStatusCode());\n    } catch (OAuthException e) {\n      if (e.getResponseBody() != null) {\n        BufferedReader br = new BufferedReader(new InputStreamReader(e.getResponseBody()));\n        String body = \"\";\n        try {\n          body = br.readLine();\n        } catch (IOException e1) {\n        }\n        LOG.error(e.getResponseCode() + \", \" + body, e);\n      } else {\n        LOG.error(e.getMessage(), e);\n      }\n      return new ResponseEntity<String>(HttpStatus.valueOf(e.getResponseCode()));\n    } catch (Exception e) {\n      LOG.error(e.getMessage(), e);\n      return new ResponseEntity<String>(HttpStatus.METHOD_FAILURE);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 569, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [123], "initializationEnd": [180], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 358, "focalAPIEnd": 375, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 383, "followUpCheckExpressionEnd": 400, "followUpCheckBlockStart": 383, "followUpCheckBlockEnd": 407, "use": ["line.trim()", "StringBuilder.append(line)", "EOSQLExpressionFactory.expressionForString(line)"], "useStart": [421, 569, 736], "useEnd": [432, 585, 773], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/baywind/reusables/tree/master/Sources/net/rujel/reusables/DataBaseUtility.java", "rawCode": "  public static void executeScript(EOAdaptorChannel ac, InputStream script) throws Exception {\n    BufferedReader update = new BufferedReader(new InputStreamReader(script, \"utf8\"));\n    StringBuilder buf = new StringBuilder();\n    EOSQLExpressionFactory exprFactory = ac.adaptorContext().adaptor().expressionFactory();\n    while (true) {\n      String line = update.readLine();\n      if (line == null) break;\n      line = line.trim();\n      if (line.length() == 0) continue;\n      if (line.startsWith(\"--\")) continue;\n      if (buf.length() > 0) buf.append('\\n');\n      buf.append(line);\n      if (line.charAt(line.length() - 1) == ';') {\n        line = buf.toString();\n        buf.delete(0, buf.length());\n        ac.evaluateExpression(exprFactory.expressionForString(line));\n        if (ac.isFetchInProgress()) ac.cancelFetch();\n      }\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 570, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 310, "focalAPIEnd": 323, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 331, "followUpCheckExpressionEnd": 351, "followUpCheckBlockStart": 331, "followUpCheckBlockEnd": 704, "use": ["Pattern.matcher(line)", "HtmlWriter.text(line)", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [374, 527, 682, 757], "useEnd": [401, 541, 695, 767], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 741, "finallyExpressionEnd": 749, "finallyBlockStart": 741, "finallyBlockEnd": 774, "cleanUpCallStart": [757], "cleanUpCallEnd": [767], "url": "https://github.com/vaadin/gwt/tree/master/dev/codeserver/java/com/google/gwt/dev/codeserver/WebServer.java", "rawCode": "  /**\n   * Copies in to out line by line, escaping each line for html characters and highlighting error\n   * lines. Closes <code>in</code> when done.\n   */\n  private static void sendLogAsHtml(BufferedReader in, HtmlWriter out) throws IOException {\n    try {\n      out.startTag(\"pre\").nl();\n      String line = in.readLine();\n      while (line != null) {\n        Matcher m = ERROR_PATTERN.matcher(line);\n        boolean error = m.find();\n        if (error) {\n          out.startTag(\"span\", \"class=\", \"error\");\n        }\n        out.text(line);\n        if (error) {\n          out.endTag(\"span\");\n        }\n        out.nl(); // the readLine doesn't include the newline.\n        line = in.readLine();\n      }\n      out.endTag(\"pre\").nl();\n    } finally {\n      in.close();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 571, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 170, "focalAPIEnd": 183, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["println(line)", "bufferedReader.readLine()", "println(line)", "bufferedReader.readLine()", "println(line)", "bufferedReader.readLine()", "println(line)", "bufferedReader.readLine()", "println(line)", "bufferedReader.readLine()", "println(line)", "bufferedReader.readLine()", "println(line)"], "useStart": [189, 289, 308, 386, 405, 547, 566, 678, 697, 772, 791, 866, 885], "useEnd": [217, 302, 336, 399, 433, 560, 594, 691, 725, 785, 819, 879, 913], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chenopodium/IGV/tree/master/src/org/broad/igv/batch/TestClient.java", "rawCode": "  private static void doCommands(PrintWriter out, BufferedReader in) throws IOException {\n\n    out.println(\"load /Users/jrobinso/igv_session.xml\");\n    String response = in.readLine();\n    System.out.println(response);\n\n    out.println(\"snapshotDirectory /Users/jrobinso\");\n    response = in.readLine();\n    System.out.println(response);\n\n    out.println(\"genome hg18\");\n    response = in.readLine();\n    System.out.println(response);\n\n    out.println(\"goto chr7:41,790,257-68,534,649\");\n    // out.println(\"goto chr1:65,839,697\");\n    response = in.readLine();\n    System.out.println(response);\n\n    out.println(\"sort amplification chr7:55,096,094-55,200,563\");\n    response = in.readLine();\n    System.out.println(response);\n\n    out.println(\"collapse\");\n    response = in.readLine();\n    System.out.println(response);\n\n    out.println(\"snapshot\");\n    response = in.readLine();\n    System.out.println(response);\n  }\n"}, {"dataset": "readLine", "exampleID": 572, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [178], "initializationEnd": [241], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 324, "focalAPIEnd": 341, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 349, "followUpCheckExpressionEnd": 369, "followUpCheckBlockStart": 349, "followUpCheckBlockEnd": 473, "use": ["StringBuilder.append(line)", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [380, 447, 529], "useEnd": [400, 464, 543], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 513, "finallyExpressionEnd": 521, "finallyBlockStart": 513, "finallyBlockEnd": 550, "cleanUpCallStart": [529], "cleanUpCallEnd": [543], "url": "https://github.com/eclipsesource/jshint-eclipse/tree/master/bundles/com.eclipsesource.jshint/src/com/eclipsesource/jshint/internal/JSHintRunner.java", "rawCode": "  private String readFileContents(File file) throws FileNotFoundException, IOException {\n    FileInputStream inputStream = new FileInputStream(file);\n    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset));\n    try {\n      StringBuilder builder = new StringBuilder();\n      String line = reader.readLine();\n      while (line != null) {\n        builder.append(line);\n        builder.append('\\n');\n        line = reader.readLine();\n      }\n      return builder.toString();\n    } finally {\n      reader.close();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 573, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()", "Logger.severe(String)", "exit(int)"], "tryExpressionStart": 61, "tryExpressionEnd": 65, "tryBlockStart": 61, "tryBlockEnd": 263, "catchExpressionStart": 132, "catchExpressionEnd": 154, "catchBlockStart": 132, "catchBlockEnd": 263, "exceptionHandlingCallStart": [162, 189, 241], "exceptionHandlingCallEnd": [181, 233, 256], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 87, "focalAPIEnd": 105, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brendano/ark-tweet-nlp/tree/master/src/cmu/arktweetnlp/util/BasicFileIO.java", "rawCode": "  public static String getLine(BufferedReader bReader) {\n    try {\n      String line = bReader.readLine();\n      return line;\n    } catch (IOException e) {\n      e.printStackTrace();\n      log.severe(\"Could not read line from file.\");\n      System.exit(-1);\n    }\n    return null;\n  }\n"}, {"dataset": "readLine", "exampleID": 574, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 995, "tryExpressionEnd": 999, "tryBlockStart": 995, "tryBlockEnd": 1381, "catchExpressionStart": 1290, "catchExpressionEnd": 1310, "catchBlockStart": 1290, "catchBlockEnd": 1381, "exceptionHandlingCallStart": [1318], "exceptionHandlingCallEnd": [1374], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 1170, "focalAPIEnd": 1196, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["line.trim()"], "useStart": [1170], "useEnd": [1203], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/conceptstailored/NCSU-GBS-Pipeline/tree/master/TASSEL_20121011/maizegenetics/src/net/maizegenetics/gbs/tagdist/TagsByTaxaCBSUAdapter.java", "rawCode": "  /**\n   * @param inFile Name of a tag map file in the format supplied by Harpreet.\n   * @param taxonNameFile Name of a file which lists biological line names present in infile, one\n   *     per line.\n   * @param outFile Name of a file in which to write new tag map.\n   */\n  public void convertCBSUFile(File inFile, File taxonNameFile, File outFile) {\n    System.out.println(\"Reading tag alignment from:\" + inFile.toString());\n    String[] inputLine = {\"Not\", \"Started\"};\n    int numTaxonNames = 0; // Number of distinct taxon names from taxonNameFile\n    int currLine = 0;\n\n    try {\n      BufferedReader taxonNameCounter = new BufferedReader(new FileReader(taxonNameFile), 65536);\n      while (taxonNameCounter.readLine() != null) {\n        numTaxonNames++;\n      } // 1st pass through file counts lines\n      taxonNameCounter.close();\n    } catch (Exception e) {\n      System.out.println(\"Catch in counting taxon names: \" + e);\n    }\n\n    String[] taxonNames = new String[numTaxonNames];\n    try {\n      BufferedReader taxonNameReader = new BufferedReader(new FileReader(taxonNameFile), 65536);\n      for (int i = 0; i < numTaxonNames; i++) {\n        taxonNames[i] = taxonNameReader.readLine().trim();\n      } // Trim each line name and add to array\n      taxonNameReader.close();\n    } catch (Exception e) {\n      System.out.println(\"Catch in reading taxon names: \" + e);\n    }\n    System.out.println(\"Taxa names read. TaxaNumber:\" + numTaxonNames);\n    try {\n      BufferedReader br = new BufferedReader(new FileReader(inFile), 65536);\n      BufferedReader tagCounter = new BufferedReader(new FileReader(inFile), 65536);\n      DataOutputStream fw =\n          new DataOutputStream(new BufferedOutputStream(new FileOutputStream(outFile), 65536));\n      int tagNum = 0;\n      int tagLengthInLong = 2;\n      ReadBarcodeResult tagProcessingResults = null;\n      byte tagLength;\n      String tagSequence;\n      long[] binaryTagSequence = new long[tagLengthInLong];\n      System.out.print(\"Tag counting....\");\n      while (tagCounter.readLine() != null) {\n        tagNum++;\n      }\n      tagCounter.close(); // Loop through tag map file, count #tags (i.e. #lines) and then close\n      System.out.println(\" TagNumber:\" + tagNum);\n      try {\n        fw.writeInt(tagNum);\n        fw.writeInt(tagLengthInLong);\n        fw.writeInt(numTaxonNames);\n        for (int t = 0; t < numTaxonNames; t++) {\n          fw.writeUTF(taxonNames[t]);\n        }\n        for (int row = 0; row < tagNum; row++) { // Fill byte arrays\n          if (row % 100000 == 0) System.out.println(\"Processed Row:\" + row);\n          inputLine = br.readLine().split(\"\\t\");\n          String corrSeq = inputLine[5];\n\n          if (!corrSeq.startsWith(\"CAGC\")\n              && !corrSeq.startsWith(\"CTGC\")\n              && !corrSeq.endsWith(\"CGTC\")\n              && !corrSeq.endsWith(\"CGAC\")) {\n            continue;\n          }\n\n          if (cleanCutSites) {\n            if (ParseBarcodeRead.getInitialCutSiteRemnant() == null) {\n              ParseBarcodeRead.chooseEnzyme(\"ApeKI\");\n            }\n            tagProcessingResults =\n                ParseBarcodeRead.removeSeqAfterSecondCutSite(\n                    corrSeq, (byte) (tagLengthInLong * 32));\n          } // Process tag sequence to find cut sites\n          if (tagProcessingResults.processedSequence != null) {\n            tagLength =\n                tagProcessingResults\n                    .getLength(); // If cut site was found, write length of processed tag...\n            tagSequence = tagProcessingResults.paddedSequence; // And sequence of processed tag...\n          } else {\n            tagLength = (byte) corrSeq.length(); // ...otherwise write length of unprocessed tag.\n            tagSequence = corrSeq; // ...and sequence of unprocessed tag.\n          }\n\n          binaryTagSequence =\n              BaseEncoder.getLongArrayFromSeq(\n                  tagSequence); // Convert sequence from string to long[]\n\n          for (int j = 0; j < tagLengthInLong; j++) {\n            fw.writeLong(binaryTagSequence[j]); // Write long[] array of sequence to disk\n          }\n          fw.writeByte(tagLength);\n\n          OpenBitSet obs =\n              new OpenBitSet(numTaxonNames); // New binary object to store presence/absence data\n          for (int t = 0; t < numTaxonNames; t++) { // Create a marker presence/absence bitmap\n            // if(inputLine[9].substring(t, t+1).matches(\"1\")){\n            // obs.set(t);\n            // }\n            if (inputLine[9].charAt(t) == '1') {\n              obs.set(t);\n            }\n          }\n\n          long[] obsInLong = obs.getBits();\n          for (int t = 0; t < obsInLong.length; t++) {\n            fw.writeLong(obsInLong[t]); // Write presence/absence bitmap to file\n          }\n        }\n        fw.close();\n        br.close();\n      } catch (Exception e) {\n        System.out.println(\"Catch in writing output file: \" + e);\n        e.printStackTrace();\n      }\n    } catch (Exception e) {\n      System.out.println(\"Catch in reading tag map file: \" + e);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 575, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [87], "initializationEnd": [128], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 55, "tryExpressionEnd": 59, "tryBlockStart": 55, "tryBlockEnd": 1579, "catchExpressionStart": 1525, "catchExpressionEnd": 1545, "catchBlockStart": 1525, "catchBlockEnd": 1579, "exceptionHandlingCallStart": [1553], "exceptionHandlingCallEnd": [1572], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 147, "focalAPIEnd": 160, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 195, "followUpCheckExpressionEnd": 212, "followUpCheckBlockStart": 195, "followUpCheckBlockEnd": 1518, "use": ["line.indexOf(String,int)", "line.substring(int,int)", "line.indexOf(String,int)", "line.indexOf(String,int)", "bufferedReader.readLine()"], "useStart": [391, 541, 633, 1054, 1496], "useEnd": [409, 566, 659, 1079, 1509], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olanto/MYCAT/tree/master/prog/util/src/org/olanto/wordnet/WrapAdj.java", "rawCode": "  private static void readNativeWN(String fname) {\n    try {\n      BufferedReader in = new BufferedReader(new FileReader(fname));\n      String w = in.readLine();\n      // msg(\"read:\" + w);\n      while (w != null) {\n        // String id = \"WSD\" + w.substring(0, 8) + \"-\" + w.substring(12, 13);\n        String id = \"WSD\" + w.substring(0, 8) + \"-a\"; // force toujours -a\n        int lastchar = w.indexOf(\" \", 17);\n        String form = \"\";\n        if (lastchar == -1) {\n          msg(\"no forms term in:\" + w);\n        } else {\n          form = w.substring(17, lastchar);\n        }\n        String hyper = \"NHT\";\n        int firsthyper = w.indexOf(\"\\\\ \", lastchar);\n        if (firsthyper == -1) {\n          // msg(\"no synonym term in:\" + w);\n        } else {\n          hyper =\n              \"WSD\"\n                  + w.substring(firsthyper + 2, firsthyper + 10)\n                  + \"-\"\n                  + w.substring(firsthyper + 11, firsthyper + 12);\n        }\n        if (hyper.equals(\"NHT\")) { // essaye une autre forme de synonym\n          firsthyper = w.indexOf(\"& \", lastchar);\n          if (firsthyper == -1) {\n            // msg(\"no synonym term in:\" + w);\n          } else {\n            hyper =\n                \"WSD\"\n                    + w.substring(firsthyper + 2, firsthyper + 10)\n                    + \"-\"\n                    + w.substring(firsthyper + 11, firsthyper + 12);\n          }\n        }\n\n        write(id, form, hyper);\n        msg(id + \" \" + form + \" \" + hyper);\n        w = in.readLine();\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 576, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 182, "focalAPIEnd": 196, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 204, "followUpCheckExpressionEnd": 218, "followUpCheckBlockStart": 204, "followUpCheckBlockEnd": 226, "use": ["line.substring(int)", "bufferedReader.readLine()", "bufferedReader.readLine()", "line.substring(int)", "bufferedReader.readLine()", "parseString(line,int[],int)"], "useStart": [288, 411, 497, 561, 624, 682], "useEnd": [303, 425, 511, 576, 638, 703], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/halset/openmap/tree/master/src/main/java/com/bbn/openmap/layer/e00/E00Parser.java", "rawCode": "  /**\n   * read PAT records\n   *\n   * @exception IOException\n   * @since\n   */\n  void readPAT() throws IOException {\n    String S;\n    String C = prefix + \".PAT\";\n    do {\n      S = isr.readLine();\n      if (S == null) return;\n    } while (!S.startsWith(C));\n    int n = Integer.parseInt(S.substring(46).trim());\n    Debug.message(\"e00\", \"E00: read \" + C + \" \" + n + \" points\");\n    for (int i = 0; i < 7; i++) isr.readLine();\n    int[] I = new int[1];\n    for (int i = 0; i < n; i++) {\n      S = isr.readLine();\n      if (S == null) break;\n      String name = S.substring(50);\n      // System.out.print(i+\" \"+S);\n      S = isr.readLine();\n      // System.out.println(\" \"+S);\n      parseString(S, I, 14);\n      BasicLocation bl = (BasicLocation) labs.getOMGraphicAt(i);\n      if (S.length() > 0) bl.setName(name);\n      else bl.setLabel(null);\n      setLocationColor(bl, I[0]);\n      bl.setShowLocation(true);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 577, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 207, "focalAPIEnd": 221, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 229, "followUpCheckExpressionEnd": 243, "followUpCheckBlockStart": 229, "followUpCheckBlockEnd": 250, "use": ["parseString(line,int[],int)", "bufferedReader.readLine()"], "useStart": [257, 373], "useEnd": [283, 387], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/halset/openmap/tree/master/src/main/java/com/bbn/openmap/layer/e00/E00Parser.java", "rawCode": "  /**\n   * read PAL records (in fact does nothing)\n   *\n   * @exception IOException\n   * @since\n   */\n  void readPAL() throws IOException {\n    int[] header = new int[1];\n    while (true) {\n      String S = isr.readLine();\n      if (S == null) break;\n      parseString(S, header, 10);\n      int n = header[0];\n      if (n == -1) break;\n      for (int i = 0; i < n; i += 2) isr.readLine();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 578, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 343, "tryExpressionEnd": 347, "tryBlockStart": 343, "tryBlockEnd": 3027, "catchExpressionStart": 2973, "catchExpressionEnd": 2993, "catchBlockStart": 2973, "catchBlockEnd": 3027, "exceptionHandlingCallStart": [3001], "exceptionHandlingCallEnd": [3020], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 371, "focalAPIEnd": 384, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new StringTokenizer(line)", "bufferedReader.readLine()", "new StringTokenizer(line)", "bufferedReader.readLine()", "bufferedReader.readLine()"], "useStart": [476, 848, 900, 1868, 2801], "useEnd": [501, 861, 925, 1881, 2814], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jeromerobert/jCAE/tree/master/amibe/src/org/jcae/mesh/amibe/util/UNVReader.java", "rawCode": "  private static TIntObjectHashMap<Triangle> readFace(\n      BufferedReader rd, Mesh mesh, Triangle beamPlaceHolder, TIntObjectHashMap<Vertex> nodesmap) {\n    logger.fine(\"Reading triangles\");\n    TIntObjectHashMap<Triangle> facesmap = new TIntObjectHashMap<Triangle>();\n    String line = \"\";\n    boolean quad = false;\n    int beams = 0;\n\n    try {\n      while (!(line = rd.readLine().trim()).equals(\"-1\")) {\n        // first line: type of object\n        StringTokenizer st = new StringTokenizer(line);\n        String index = st.nextToken();\n        String type = st.nextToken();\n        int ind = Integer.valueOf(index).intValue();\n        if (type.equals(\"41\")\n            || type.equals(\"51\")\n            || type.equals(\"61\")\n            || type.equals(\"74\")\n            || type.equals(\"91\")\n            || type.equals(\"92\")) {\n          line = rd.readLine();\n          // triangle\n          st = new StringTokenizer(line);\n          boolean parabolic = type.equals(\"92\");\n          int p1 = Integer.valueOf(st.nextToken()).intValue();\n          if (parabolic) st.nextToken();\n          int p2 = Integer.valueOf(st.nextToken()).intValue();\n          if (parabolic) st.nextToken();\n          int p3 = Integer.valueOf(st.nextToken()).intValue();\n          if (parabolic) st.nextToken();\n          Vertex n1 = nodesmap.get(p1);\n          assert n1 != null : p1;\n          Vertex n2 = nodesmap.get(p2);\n          assert n2 != null : p2;\n          Vertex n3 = nodesmap.get(p3);\n          assert n3 != null : p3;\n          Triangle f = mesh.createTriangle(n1, n2, n3);\n          mesh.add(f);\n          // fill the map of faces\n          facesmap.put(ind, f);\n        } else if (type.equals(\"44\")\n            || type.equals(\"54\")\n            || type.equals(\"64\")\n            || type.equals(\"71\")\n            || type.equals(\"94\")) {\n          quad = true;\n          line = rd.readLine();\n          // quadrangle\n          st = new StringTokenizer(line);\n          int p1 = Integer.valueOf(st.nextToken()).intValue();\n          int p2 = Integer.valueOf(st.nextToken()).intValue();\n          int p3 = Integer.valueOf(st.nextToken()).intValue();\n          int p4 = Integer.valueOf(st.nextToken()).intValue();\n          Vertex n1 = nodesmap.get(p1);\n          assert n1 != null : p1;\n          Vertex n2 = nodesmap.get(p2);\n          assert n2 != null : p2;\n          Vertex n3 = nodesmap.get(p3);\n          assert n3 != null : p3;\n          Vertex n4 = nodesmap.get(p4);\n          assert n4 != null : p4;\n          Triangle f = mesh.createTriangle(n1, n2, n3);\n          mesh.add(f);\n          facesmap.put(ind, f);\n          f = mesh.createTriangle(n1, n3, n4);\n          mesh.add(f);\n          facesmap.put(-ind, f);\n        } else if (type.equals(\"11\") || type.equals(\"21\")) {\n          beams++;\n          rd.readLine();\n          rd.readLine();\n          facesmap.put(ind, beamPlaceHolder);\n        } else throw new RuntimeException(\"Type \" + type + \" unknown\");\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n    logger.fine(\"Found \" + facesmap.size() + \" triangles\");\n    if (quad)\n      logger.severe(\n          \"Quadrangles have been detected and converted into triangles. If errors occur, convert this UNV file to only use triangles!\");\n    if (beams > 0) {\n      if (facesmap.size() == beams)\n        logger.severe(\n            \"Beams have been found but are discarded, and this mesh does not contain any triangle!\");\n      else logger.severe(\"Beams have been found but are discarded, only triangles are read.\");\n    }\n    return facesmap;\n  }\n"}, {"dataset": "readLine", "exampleID": 579, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 455, "focalAPIEnd": 468, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 481, "followUpCheckExpressionEnd": 497, "followUpCheckBlockStart": 481, "followUpCheckBlockEnd": 519, "use": ["new ProcessBuilder(String,String,String,line,String)", "new ProcessBuilder(String,String,line)"], "useStart": [614, 898], "useEnd": [669, 935], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/UniversalMediaServer/UniversalMediaServer/tree/master/src/main/java/net/pms/PMS.java", "rawCode": "  private static void killProc() throws AccessControlException, IOException {\n    ProcessBuilder pb = null;\n    String pid;\n    String pidFile = pidFile();\n    if (!FileUtil.getFilePermissions(pidFile).isReadable()) {\n      throw new AccessControlException(\"Cannot read \" + pidFile);\n    }\n\n    try (BufferedReader in =\n        new BufferedReader(\n            new InputStreamReader(new FileInputStream(pidFile), StandardCharsets.US_ASCII))) {\n      pid = in.readLine();\n    }\n\n    if (pid == null) {\n      return;\n    }\n\n    if (Platform.isWindows()) {\n      try {\n        if (verifyPidName(pid)) {\n          pb = new ProcessBuilder(\"taskkill\", \"/F\", \"/PID\", pid, \"/T\");\n        }\n      } catch (IllegalAccessException e) {\n        // Impossible\n      }\n    } else if (Platform.isFreeBSD()\n        || Platform.isLinux()\n        || Platform.isOpenBSD()\n        || Platform.isSolaris()) {\n      pb = new ProcessBuilder(\"kill\", \"-9\", pid);\n    }\n\n    if (pb == null) {\n      return;\n    }\n\n    try {\n      Process p = pb.start();\n      p.waitFor();\n    } catch (InterruptedException e) {\n      LOGGER.trace(\"Got interrupted while trying to kill process by PID \" + e);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 580, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*,int)"], "initializationStart": [318], "initializationEnd": [365], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 394, "focalAPIEnd": 411, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 470, "followUpCheckExpressionEnd": 487, "followUpCheckBlockStart": 470, "followUpCheckBlockEnd": 509, "use": ["bufferedReader.close()"], "useStart": [439], "useEnd": [453], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 421, "finallyExpressionEnd": 429, "finallyBlockStart": 421, "finallyBlockEnd": 462, "cleanUpCallStart": [439], "cleanUpCallEnd": [453], "url": "https://github.com/Blechd0se/android_packages_apps_AeroControl/tree/master/AeroControl/src/com/aero/control/helpers/shellHelper.java", "rawCode": "  /**\n   * Gets information from the filesystem with a given path\n   *\n   * @param s => path (with filename)\n   * @return String\n   */\n  public final String getInfo(String s) {\n\n    String info = NO_DATA_FOUND;\n\n    if (s == null || !(new File(s).exists())) return info;\n\n    try {\n      final BufferedReader reader = new BufferedReader(new FileReader(s), BUFF_LEN);\n      try {\n        info = reader.readLine();\n      } finally {\n        reader.close();\n      }\n\n      if (info == null) info = NO_DATA_FOUND;\n\n      return info;\n    } catch (IOException e) {\n\n      String tmp = null;\n\n      // Make sure that the shell is open;\n      openShell();\n\n      addCommand(\"ls -l \" + s);\n      tmp = getRootResult();\n\n      // At least try to read it via root, but check for permissions;\n      if (tmp != null && tmp.length() > 10) {\n        if (!(tmp.substring(0, 10).equals(\"--w-------\"))) {\n          // info = getLegacyRootInfo(\"cat\", s);\n          addCommand(\"cat \" + s);\n          info = getRootResult();\n        }\n      }\n\n      if (info.equals(NO_DATA_FOUND))\n        Log.e(LOG_TAG, \"IO Exception when trying to get information.\", e);\n\n      return info;\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 581, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [263], "initializationEnd": [322], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 361, "focalAPIEnd": 378, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(line)", "bufferedReader.close()"], "useStart": [344, 431], "useEnd": [379, 445], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 413, "finallyExpressionEnd": 421, "finallyBlockStart": 413, "finallyBlockEnd": 454, "cleanUpCallStart": [431], "cleanUpCallEnd": [445], "url": "https://github.com/ansell/openrdf-sesame/tree/master/core/http/workbench/src/main/java/org/openrdf/workbench/proxy/ServerValidator.java", "rawCode": "  /** Assumption: server won't require credentials to access the protocol path. */\n  private boolean canConnect(final String server) {\n    boolean success = false;\n    try {\n      final URL url = new URL(server + \"/protocol\");\n      final BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n      try {\n        Integer.parseInt(reader.readLine());\n        success = true;\n      } finally {\n        reader.close();\n      }\n    } catch (MalformedURLException e) {\n      LOGGER.warn(e.toString(), e);\n    } catch (IOException e) {\n      LOGGER.warn(e.toString(), e);\n    }\n    return success;\n  }\n"}, {"dataset": "readLine", "exampleID": 582, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [286], "initializationEnd": [334], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 359, "focalAPIEnd": 376, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["bufferedReader.close()"], "useStart": [400], "useEnd": [414], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 384, "finallyExpressionEnd": 392, "finallyBlockStart": 384, "finallyBlockEnd": 421, "cleanUpCallStart": [400], "cleanUpCallEnd": [414], "url": "https://github.com/embest-tech/rowboat-frameworks-base/tree/master/tests/CoreTests/android/core/URLTest.java", "rawCode": "  /** Does a request to the given URL, reads and returns the result. */\n  private String request(URL url) throws Exception {\n    URLConnection connection = url.openConnection();\n    connection.connect();\n\n    InputStream input = connection.getInputStream();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n    try {\n      return reader.readLine();\n    } finally {\n      reader.close();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 583, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [228], "initializationEnd": [277], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getClass()", "getName()", "getMessage()", "fail(String)"], "tryExpressionStart": 50, "tryExpressionEnd": 54, "tryBlockStart": 50, "tryBlockEnd": 558, "catchExpressionStart": 454, "catchExpressionEnd": 474, "catchBlockStart": 454, "catchBlockEnd": 558, "exceptionHandlingCallStart": [505, 505, 536, 482], "exceptionHandlingCallEnd": [517, 527, 550, 551], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 325, "focalAPIEnd": 338, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(String,line)"], "useStart": [285], "useEnd": [339], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gesellix/dotplot/tree/master/org.dotplot.plugin/tests/org/dotplot/core/plugins/tests/PluginJarFileTest.java", "rawCode": "  public void testGetPluginXMLInputStream() {\n    try {\n      PluginJarFile jar = new PluginJarFile(this.with, this.context.getPluginSchema());\n      InputStream stream = jar.getPluginXMLInputStream();\n      BufferedReader in = new BufferedReader(new InputStreamReader(stream));\n      assertEquals(\"<?xml version=\\\"1.0\\\"?>\", in.readLine());\n      assertNotNull(jar.getPluginDependencys());\n      assertEquals(1, jar.getPluginDependencys().size());\n    } catch (Exception e) {\n      fail(\"no exception:\" + e.getClass().getName() + \":\" + e.getMessage());\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 584, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [3163], "initializationEnd": [3231], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 3248, "focalAPIEnd": 3264, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["println(line)", "bufferedReader.readLine()", "assertEquals(String,line)"], "useStart": [3274, 3316, 3383], "useEnd": [3298, 3332, 3421], "hasFinally": 1, "cleanUpCall": ["MiniDFSCluster.shutdown()"], "finallyExpressionStart": 3477, "finallyExpressionEnd": 3485, "finallyBlockStart": 3477, "finallyBlockEnd": 3604, "cleanUpCallStart": [3520], "cleanUpCallEnd": [3534], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop_src/hadoop-2.0.5-alpha-src/hadoop-tools/hadoop-streaming/src/test/java/org/apache/hadoop/streaming/TestMultipleCachefiles.java", "rawCode": "  @Test\n  public void testMultipleCachefiles() throws Exception {\n    boolean mayExit = false;\n    MiniMRCluster mr = null;\n    MiniDFSCluster dfs = null;\n    try {\n      Configuration conf = new Configuration();\n      dfs = new MiniDFSCluster(conf, 1, true, null);\n      FileSystem fileSys = dfs.getFileSystem();\n      String namenode = fileSys.getUri().toString();\n\n      mr = new MiniMRCluster(1, namenode, 3);\n\n      List<String> args = new ArrayList<String>();\n      for (Map.Entry<String, String> entry : mr.createJobConf()) {\n        args.add(\"-jobconf\");\n        args.add(entry.getKey() + \"=\" + entry.getValue());\n      }\n\n      String argv[] =\n          new String[] {\n            \"-input\",\n            INPUT_FILE,\n            \"-output\",\n            OUTPUT_DIR,\n            \"-mapper\",\n            map,\n            \"-reducer\",\n            reduce,\n            \"-jobconf\",\n            \"stream.tmpdir=\" + System.getProperty(\"test.build.data\", \"/tmp\"),\n            \"-jobconf\",\n            JobConf.MAPRED_MAP_TASK_JAVA_OPTS\n                + \"=\"\n                + \"-Dcontrib.name=\"\n                + System.getProperty(\"contrib.name\")\n                + \" \"\n                + \"-Dbuild.test=\"\n                + System.getProperty(\"build.test\")\n                + \" \"\n                + conf.get(\n                    JobConf.MAPRED_MAP_TASK_JAVA_OPTS, conf.get(JobConf.MAPRED_TASK_JAVA_OPTS, \"\")),\n            \"-jobconf\",\n            JobConf.MAPRED_REDUCE_TASK_JAVA_OPTS\n                + \"=\"\n                + \"-Dcontrib.name=\"\n                + System.getProperty(\"contrib.name\")\n                + \" \"\n                + \"-Dbuild.test=\"\n                + System.getProperty(\"build.test\")\n                + \" \"\n                + conf.get(\n                    JobConf.MAPRED_REDUCE_TASK_JAVA_OPTS,\n                    conf.get(JobConf.MAPRED_TASK_JAVA_OPTS, \"\")),\n            \"-cacheFile\",\n            fileSys.getUri() + CACHE_FILE + \"#\" + mapString,\n            \"-cacheFile\",\n            fileSys.getUri() + CACHE_FILE_2 + \"#\" + mapString2,\n            \"-jobconf\",\n            \"mapred.jar=\" + TestStreaming.STREAMING_JAR,\n          };\n\n      for (String arg : argv) {\n        args.add(arg);\n      }\n      argv = args.toArray(new String[args.size()]);\n\n      fileSys.delete(new Path(OUTPUT_DIR), true);\n\n      DataOutputStream file = fileSys.create(new Path(INPUT_FILE));\n      file.writeBytes(mapString + \"\\n\");\n      file.writeBytes(mapString2 + \"\\n\");\n      file.close();\n      file = fileSys.create(new Path(CACHE_FILE));\n      file.writeBytes(cacheString + \"\\n\");\n      file.close();\n      file = fileSys.create(new Path(CACHE_FILE_2));\n      file.writeBytes(cacheString2 + \"\\n\");\n      file.close();\n\n      job = new StreamJob(argv, mayExit);\n      job.go();\n\n      fileSys = dfs.getFileSystem();\n      String line = null;\n      String line2 = null;\n      Path[] fileList =\n          FileUtil.stat2Paths(\n              fileSys.listStatus(\n                  new Path(OUTPUT_DIR), new Utils.OutputFileUtils.OutputFilesFilter()));\n      for (int i = 0; i < fileList.length; i++) {\n        System.out.println(fileList[i].toString());\n        BufferedReader bread = new BufferedReader(new InputStreamReader(fileSys.open(fileList[i])));\n        line = bread.readLine();\n        System.out.println(line);\n        line2 = bread.readLine();\n        System.out.println(line2);\n      }\n      assertEquals(cacheString + \"\\t\", line);\n      assertEquals(cacheString2 + \"\\t\", line2);\n    } finally {\n      if (dfs != null) {\n        dfs.shutdown();\n      }\n      if (mr != null) {\n        mr.shutdown();\n      }\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 585, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [170], "initializationEnd": [222], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(*)"], "tryExpressionStart": 374, "tryExpressionEnd": 378, "tryBlockStart": 374, "tryBlockEnd": 484, "catchExpressionStart": 424, "catchExpressionEnd": 444, "catchBlockStart": 424, "catchBlockEnd": 484, "exceptionHandlingCallStart": [454], "exceptionHandlingCallEnd": [475], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 398, "focalAPIEnd": 414, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInput(line,Environment)"], "useStart": [498], "useEnd": [522], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.freePastry/src/main/java/rice/pastry/testing/DirectPastryPingTest.java", "rawCode": "  public static void main(String args[]) throws IOException {\n    boolean quit = false;\n    Environment env = Environment.directEnvironment();\n    BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n    String command = null;\n\n    System.out.println(\"Usage: s - run standalone test\");\n    System.out.println(\" q - quit\");\n\n    while (!quit) {\n      try {\n        command = input.readLine();\n      } catch (Exception e) {\n        System.out.println(e);\n      }\n      quit = parseInput(command, env);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 586, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": [], "tryExpressionStart": 86, "tryExpressionEnd": 90, "tryBlockStart": 86, "tryBlockEnd": 832, "catchExpressionStart": 697, "catchExpressionEnd": 717, "catchBlockStart": 697, "catchBlockEnd": 760, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 137, "focalAPIEnd": 150, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 162, "followUpCheckExpressionEnd": 179, "followUpCheckBlockStart": 162, "followUpCheckBlockEnd": 186, "use": ["bufferedReader.readLine()", "bufferedReader.readLine()", "List<String>.add(line)", "bufferedReader.close()"], "useStart": [361, 400, 504, 813], "useEnd": [374, 413, 522, 823], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 779, "finallyExpressionEnd": 787, "finallyBlockStart": 779, "finallyBlockEnd": 832, "cleanUpCallStart": [813], "cleanUpCallEnd": [823], "url": "https://github.com/utgenome/utgb/tree/master/utgb-core/src/main/java/org/utgenome/format/axt/AXTLens.java", "rawCode": "  public void convert(ObjectStreamHandler handler) throws Exception {\n    try {\n      try {\n        for (; ; ) {\n          String line = in.readLine();\n          if (line == null) break;\n\n          if (StringUtil.isWhiteSpace(line)) continue;\n\n          List<String> axtBlock = new ArrayList<String>(3);\n\n          String header = line;\n          String seq1 = in.readLine();\n          String seq2 = in.readLine();\n\n          if (seq1 == null || seq2 == null) {\n            break;\n          }\n\n          axtBlock.add(line);\n          axtBlock.add(seq1);\n          axtBlock.add(seq2);\n\n          try {\n            AXTAlignment aln = lens(axtBlock);\n            handler.add(\"axt\", aln);\n          } catch (Exception e) {\n            _logger.error(e);\n          }\n        }\n      } finally {\n        if (in != null) in.close();\n      }\n    } catch (Exception e) {\n      throw UTGBException.convert(e);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 587, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [73], "initializationEnd": [125], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 338, "focalAPIEnd": 351, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(line)", "bufferedReader.readLine()", "parseInt(line)"], "useStart": [423, 740, 837], "useEnd": [447, 753, 861], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sethdaugherty/CSCI443Project1/tree/master/Scheduler/src/edu/mines/Schedule/Scheduler.java", "rawCode": "  private void addStudent() throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    System.out.println(\"Enter the number of a student:\");\n    int x = 0;\n    for (Student student : studentList) {\n      System.out.println(x + \" \" + student.toString());\n      x += 1;\n    }\n    String choice = br.readLine().trim();\n    Student student;\n    try {\n      student = studentList.get(Integer.parseInt(choice));\n    } catch (IndexOutOfBoundsException e) {\n      System.out.println(\"Invalid student number\");\n      printMenu();\n      return;\n    }\n\n    x = 0;\n    for (CourseMeeting meeting : courseMeetingList) {\n      System.out.println(x + \" \" + meeting.toString());\n      x += 1;\n    }\n    choice = br.readLine().trim();\n    CourseMeeting meeting;\n    try {\n      meeting = courseMeetingList.get(Integer.parseInt(choice));\n    } catch (IndexOutOfBoundsException e) {\n      System.out.println(\"Invalid course number\");\n      printMenu();\n      return;\n    }\n\n    Enrollment enrollment = new Enrollment(student, meeting);\n    enrollmentManager.addEnrollment(enrollment);\n    System.out.println(\"Added student to course\");\n    printMenu();\n  }\n"}, {"dataset": "readLine", "exampleID": 588, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IndexOutOfBoundsException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 307, "tryExpressionEnd": 311, "tryBlockStart": 307, "tryBlockEnd": 2617, "catchExpressionStart": 2369, "catchExpressionEnd": 2405, "catchBlockStart": 2369, "catchBlockEnd": 2439, "exceptionHandlingCallStart": [2413], "exceptionHandlingCallEnd": [2432], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 395, "focalAPIEnd": 412, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 422, "followUpCheckExpressionEnd": 439, "followUpCheckBlockStart": 422, "followUpCheckBlockEnd": 446, "use": ["split(String,line,String[])", "bufferedReader.close()"], "useStart": [502, 2527], "useEnd": [537, 2541], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 2497, "finallyExpressionEnd": 2505, "finallyBlockStart": 2497, "finallyBlockEnd": 2617, "cleanUpCallStart": [2527], "cleanUpCallEnd": [2541], "url": "https://github.com/gaeeyo/Tuboroidon/tree/master/Tuboroid/src/info/narazaki/android/tuboroid/agent/ThreadEntryListTask.java", "rawCode": "  private void processThreadEntryListCache(\n      final ThreadData thread_data,\n      final BufferedReader reader,\n      final boolean reload,\n      final ThreadEntryListFetchedCallback callback) {\n    List<ThreadEntryData> data_list = new LinkedList<ThreadEntryData>();\n\n    long thread_cur_count = 0;\n    try {\n      String[] tokens = new String[9];\n      while (true) {\n        String line = reader.readLine();\n        if (line == null) break;\n\n        thread_cur_count++;\n        int token_count = ListUtils.split(\"<>\", line, tokens);\n\n        ThreadEntryData data;\n        if (token_count >= 8) {\n          String author_name = tokens[0];\n          String author_mail = tokens[1];\n          String entry_body = tokens[2];\n          String author_id = tokens[3];\n          String author_be = tokens[4];\n          String entry_time = tokens[5];\n          String entry_is_aa = tokens[6];\n          String forward_anchor_list_str = tokens[7];\n\n          if (thread_cur_count == 1 && token_count >= 9 && tokens[8].length() > 0) {\n            thread_data.thread_name_ = tokens[8];\n          }\n\n          entry_body = HtmlUtils.unescapeHtml(entry_body.replace(\"<br>\", \"\\n\"));\n          data =\n              new ThreadEntryData(\n                  true,\n                  thread_cur_count,\n                  author_name,\n                  author_mail,\n                  entry_body,\n                  author_id,\n                  author_be,\n                  entry_time,\n                  entry_is_aa,\n                  forward_anchor_list_str);\n        } else {\n          Log.e(TAG, \"Broken Cache : NUM=\" + thread_cur_count);\n          data = new ThreadEntryData(true, thread_cur_count, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\");\n        }\n\n        data_list.add(data);\n      }\n      if (thread_data.working_cache_count_ == thread_cur_count) {\n        // DB上の数とファイルの内容が一致した時のみ通知(外部ストレージに変なデータが来た時のため)\n        applyIgnoreList(data_list);\n        callback.onThreadEntryListFetchedByCache(data_list);\n      } else {\n        Log.e(\n            TAG,\n            \"Broken Cache : Data Clear : working_cache_count_=\"\n                + thread_data.working_cache_count_\n                + \" but NUM=\"\n                + thread_cur_count);\n        clearThreadEntryListCache(thread_data, null);\n        data_list.clear();\n        callback.onThreadEntryListFetchedByCache(data_list);\n      }\n    } catch (IndexOutOfBoundsException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    } finally {\n      try {\n        reader.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n\n    if (reload) {\n      reloadOnlineThreadEntryList(thread_data, null, callback);\n    } else {\n      callback.onThreadEntryListFetchedCompleted(thread_data);\n      popFetchTask();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 589, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [223], "initializationEnd": [265], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 409, "focalAPIEnd": 422, "followUpCheck": "line != null", "checkType": "IF", "followUpCheckExpressionStart": 432, "followUpCheckExpressionEnd": 449, "followUpCheckBlockStart": 432, "followUpCheckBlockEnd": 522, "use": ["BufferedWriter.write(line)", "close(bufferedReader)"], "useStart": [462, 620], "useEnd": [477, 636], "hasFinally": 1, "cleanUpCall": ["close(BufferedWriter)", "close(BufferedReader)"], "finallyExpressionStart": 579, "finallyExpressionEnd": 587, "finallyBlockStart": 579, "finallyBlockEnd": 643, "cleanUpCallStart": [595, 620], "cleanUpCallEnd": [612, 636], "url": "https://github.com/OpenNMS/maven-plugins/tree/master/tgz-maven-plugin/src/main/java/org/opennms/maven/plugins/tgz/AbstractAssemblyMojo.java", "rawCode": "  private void copyReplacingLineEndings(File source, File dest, String lineEndings)\n      throws IOException {\n    getLog().debug(\"Copying while replacing line endings: \" + source + \" to \" + dest);\n\n    BufferedReader in = new BufferedReader(new FileReader(source));\n    BufferedWriter out = null;\n    try {\n      out = new BufferedWriter(new FileWriter(dest));\n\n      String line;\n\n      do {\n        line = in.readLine();\n        if (line != null) {\n          out.write(line);\n          out.write(lineEndings);\n        }\n      } while (line != null);\n\n      out.flush();\n    } finally {\n      IOUtil.close(out);\n      IOUtil.close(in);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 590, "initialization": ["BufferedReader bufferedReader = new BufferedReader(FileReader)"], "initializationStart": [604], "initializationEnd": [634], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 765, "focalAPIEnd": 782, "followUpCheck": "line.contains(\"jira@apache.org\")", "checkType": "IF", "followUpCheckExpressionStart": 848, "followUpCheckExpressionEnd": 886, "followUpCheckBlockStart": 848, "followUpCheckBlockEnd": 1216, "use": ["println(line)", "extractNomeJira(line)", "extractEmail(line)", "PrintWriter.println(line)"], "useStart": [815, 911, 1123, 1462], "useEnd": [840, 933, 1142, 1490], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/magsilva/presley/tree/master/code/presley-server/src/experiment/java/dados/cvs/AjusteArquivos.java", "rawCode": "  private void ajustarArquivos() throws IOException, Exception {\n    File diretorioCD = new File(PATH + \"/question/\");\n\n    File[] listagemDiretorio =\n        diretorioCD.listFiles(\n            new FilenameFilter() {\n              public boolean accept(File d, String name) {\n                return name.toLowerCase().endsWith(\".question\");\n              }\n            });\n\n    for (File arquivoQuestion : listagemDiretorio) {\n      String linha = \"\";\n      ArrayList<String> emails = new ArrayList<String>();\n\n      FileReader fileReader = new FileReader(arquivoQuestion);\n      BufferedReader reader = new BufferedReader(fileReader);\n\n      System.out.println(arquivoQuestion.getAbsolutePath());\n      // - Busca pelos e-mails dos desenvolvedores -\n      linha = reader.readLine();\n      String email = \"\";\n      System.out.println(linha);\n      if (linha.contains(\"jira@apache.org\")) {\n        String nome = extractNomeJira(linha);\n\n        Desenvolvedor desenvolvedor;\n        desenvolvedor = servicoDesenvolvedor.getDesenvolvedorPorNome(nome);\n\n        email = desenvolvedor.getEmail();\n      } else {\n        email = extractEmail(linha);\n        servicoDesenvolvedor.autenticaDesenvolvedor(email, \"1\");\n      }\n      emails.add(email);\n\n      // - Atualiza o arquivo -\n      PrintWriter saidaQuestion = new PrintWriter(new FileOutputStream(arquivoQuestion));\n      saidaQuestion.println(email);\n\n      while ((linha = reader.readLine()) != null) {\n        saidaQuestion.println(linha);\n      }\n\n      saidaQuestion.close();\n\n      ajustarArquivosEmails(email, arquivoQuestion);\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 591, "initialization": ["BufferedReader bufferedReader = new BufferedReader(InputStreamReader)"], "initializationStart": [270], "initializationEnd": [295], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 143, "tryExpressionEnd": 147, "tryBlockStart": 143, "tryBlockEnd": 854, "catchExpressionStart": 800, "catchExpressionEnd": 820, "catchBlockStart": 800, "catchBlockEnd": 854, "exceptionHandlingCallStart": [828], "exceptionHandlingCallEnd": [847], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 316, "focalAPIEnd": 329, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 337, "followUpCheckExpressionEnd": 380, "followUpCheckBlockStart": 337, "followUpCheckBlockEnd": 715, "use": ["line.split(String)", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [432, 693, 722], "useEnd": [447, 706, 732], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olanto/MYCAT/tree/master/prog/TMXsupport/src/org/olanto/mycat/tmx/multiun/extract/extractZHCorrection.java", "rawCode": "  static void Process(String fileName) {\n\n    System.out.println(\"------------- entry dictionary: \" + fileName);\n    int totdictEntry = 0;\n    try {\n      InputStreamReader isrso = new InputStreamReader(new FileInputStream(fileName), \"UTF-8\");\n      BufferedReader so = new BufferedReader(isrso);\n      String wso = so.readLine();\n      while (wso != null && totdictEntry < limit) {\n        totdictEntry++;\n        String[] entry = wso.split(\"\\t\");\n        entry[6] = stringManip.addSpace(entry[6]);\n        outmflf.append(\n            entry[0] + \"\\t\" + entry[1] + \"\\t\" + entry[2] + \"\\t\" + entry[3] + \"\\t\" + entry[4] + \"\\t\"\n                + entry[5] + \"\\t\" + entry[6] + \"\\n\");\n\n        wso = so.readLine();\n      }\n      so.close();\n      System.out.println(\" read entries: \" + totdictEntry);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 592, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [481], "initializationEnd": [517], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 545, "focalAPIEnd": 562, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(String,line)", "bufferedReader.close()"], "useStart": [523, 569], "useEnd": [563, 583], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xiaolezheng/com.zxl.http-request/tree/master/lib/src/test/java/com/github/kevinsawicki/http/HttpRequestTest.java", "rawCode": "  /**\n   * Make a GET and get response as a input stream reader\n   *\n   * @throws Exception\n   */\n  @Test\n  public void getReader() throws Exception {\n    handler =\n        new RequestHandler() {\n\n          @Override\n          public void handle(Request request, HttpServletResponse response) {\n            response.setStatus(HTTP_OK);\n            write(\"hello\");\n          }\n        };\n    HttpRequest request = get(url);\n    assertTrue(request.ok());\n    BufferedReader reader = new BufferedReader(request.reader());\n    assertEquals(\"hello\", reader.readLine());\n    reader.close();\n  }\n"}, {"dataset": "readLine", "exampleID": 593, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*,int)"], "initializationStart": [207], "initializationEnd": [257], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)", "printStackTrace()"], "tryExpressionStart": 171, "tryExpressionEnd": 175, "tryBlockStart": 171, "tryBlockEnd": 1038, "catchExpressionStart": 922, "catchExpressionEnd": 944, "catchBlockStart": 922, "catchBlockEnd": 1038, "exceptionHandlingCallStart": [952, 1012], "exceptionHandlingCallEnd": [1004, 1031], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 361, "focalAPIEnd": 378, "followUpCheck": "(line) != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 418, "followUpCheckExpressionEnd": 458, "followUpCheckBlockStart": 418, "followUpCheckBlockEnd": 870, "use": ["line.split(String)", "bufferedReader.close()"], "useStart": [520, 877], "useEnd": [535, 891], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/conceptstailored/NCSU-GBS-Pipeline/tree/master/TASSEL_20121011/maizegenetics/src/net/maizegenetics/genome/solexa/AlignmentQualityTest.java", "rawCode": "  public static void compareWithFile(\n      String infile, int siteIndex, int[] sites, boolean keepSites, String outfile) {\n    Arrays.sort(sites);\n    int count = 0;\n    try {\n      BufferedReader fileIn = new BufferedReader(new FileReader(infile), 100000);\n      BufferedWriter fileOut = new BufferedWriter(new FileWriter(outfile), 100000);\n      String sl = fileIn.readLine();\n      fileOut.write(sl + \"\\n\");\n      while ((sl = fileIn.readLine()) != null) {\n        int currSite = (int) Math.round(Double.parseDouble(sl.split(\"\\\\s\")[siteIndex]));\n        int hit = Arrays.binarySearch(sites, currSite);\n        // if(sl.contains(\"-\")) continue;\n        if (keepSites && (hit > -1)) {\n          fileOut.write(sl + \"\\n\");\n          count++;\n        } else if ((keepSites == false) && (hit < 0)) {\n          fileOut.write(sl + \"\\n\");\n          count++;\n        }\n      }\n      fileIn.close();\n      fileOut.close();\n    } catch (IOException e) {\n      System.out.println(\"Error with createSiteList:\" + e);\n      e.printStackTrace();\n    }\n    System.out.printf(\"File:%s Sites:%d %n\", outfile, count);\n  }\n"}, {"dataset": "readLine", "exampleID": 594, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [75], "initializationEnd": [126], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 291, "focalAPIEnd": 304, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 312, "followUpCheckExpressionEnd": 329, "followUpCheckBlockStart": 312, "followUpCheckBlockEnd": 336, "use": ["new StringTokenizer(line,String)", "bufferedReader.close()"], "useStart": [365, 1605], "useEnd": [404, 1615], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/miguelki/Emotion_Recognition/tree/master/test_svm/test_svm/libsvm-3.12/java/svm_train.java", "rawCode": "  private void read_problem() throws IOException {\n    BufferedReader fp = new BufferedReader(new FileReader(input_file_name));\n    Vector<Double> vy = new Vector<Double>();\n    Vector<svm_node[]> vx = new Vector<svm_node[]>();\n    int max_index = 0;\n\n    while (true) {\n      String line = fp.readLine();\n      if (line == null) break;\n\n      StringTokenizer st = new StringTokenizer(line, \" \\t\\n\\r\\f:\");\n\n      vy.addElement(atof(st.nextToken()));\n      int m = st.countTokens() / 2;\n      svm_node[] x = new svm_node[m];\n      for (int j = 0; j < m; j++) {\n        x[j] = new svm_node();\n        x[j].index = atoi(st.nextToken());\n        x[j].value = atof(st.nextToken());\n      }\n      if (m > 0) max_index = Math.max(max_index, x[m - 1].index);\n      vx.addElement(x);\n    }\n\n    prob = new svm_problem();\n    prob.l = vy.size();\n    prob.x = new svm_node[prob.l][];\n    for (int i = 0; i < prob.l; i++) prob.x[i] = vx.elementAt(i);\n    prob.y = new double[prob.l];\n    for (int i = 0; i < prob.l; i++) prob.y[i] = vy.elementAt(i);\n\n    if (param.gamma == 0 && max_index > 0) param.gamma = 1.0 / max_index;\n\n    if (param.kernel_type == svm_parameter.PRECOMPUTED)\n      for (int i = 0; i < prob.l; i++) {\n        if (prob.x[i][0].index != 0) {\n          System.err.print(\"Wrong kernel matrix: first column must be 0:sample_serial_number\\n\");\n          System.exit(1);\n        }\n        if ((int) prob.x[i][0].value <= 0 || (int) prob.x[i][0].value > max_index) {\n          System.err.print(\"Wrong input format: sample_serial_number out of range\\n\");\n          System.exit(1);\n        }\n      }\n\n    fp.close();\n  }\n"}, {"dataset": "readLine", "exampleID": 595, "initialization": ["BufferedReader bufferedReader = open(String)"], "initializationStart": [399], "initializationEnd": [414], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 470, "focalAPIEnd": 483, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["firstLine(line)", "bufferedReader.readLine()", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [456, 509, 1570, 1603], "useEnd": [484, 522, 1583, 1613], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dlyubimov/mahout-commits/tree/master/examples/src/main/java/org/apache/mahout/classifier/sgd/TrainAdaptiveLogistic.java", "rawCode": "  static void mainToOutput(String[] args, PrintWriter output) throws Exception {\n    if (parseArgs(args)) {\n\n      CsvRecordFactory csv = lmp.getCsvRecordFactory();\n      model = lmp.createAdaptiveLogisticRegression();\n      State<Wrapper, CrossFoldLearner> best;\n      CrossFoldLearner learner = null;\n\n      int k = 0;\n      for (int pass = 0; pass < passes; pass++) {\n        BufferedReader in = open(inputFile);\n\n        // read variable names\n        csv.firstLine(in.readLine());\n\n        String line = in.readLine();\n        while (line != null) {\n          // for each new line, get target and predictors\n          Vector input = new RandomAccessSparseVector(lmp.getNumFeatures());\n          int targetValue = csv.processLine(line, input);\n\n          // update model\n          model.train(targetValue, input);\n          k++;\n\n          if (showperf && (k % (skipperfnum + 1) == 0)) {\n\n            best = model.getBest();\n            if (best != null) {\n              learner = best.getPayload().getLearner();\n            }\n            if (learner != null) {\n              double averageCorrect = learner.percentCorrect();\n              double averageLL = learner.logLikelihood();\n              output.printf(\"%d\\t%.3f\\t%.2f%n\", k, averageLL, averageCorrect * 100);\n            } else {\n              output.printf(\n                  Locale.ENGLISH,\n                  \"%10d %2d %s%n\",\n                  k,\n                  targetValue,\n                  \"AdaptiveLogisticRegression has not found a good model ......\");\n            }\n          }\n          line = in.readLine();\n        }\n        in.close();\n      }\n\n      best = model.getBest();\n      if (best != null) {\n        learner = best.getPayload().getLearner();\n      }\n      if (learner == null) {\n        output.println(\"AdaptiveLogisticRegression has failed to train a model.\");\n        return;\n      }\n\n      try (OutputStream modelOutput = new FileOutputStream(outputFile)) {\n        lmp.saveTo(modelOutput);\n      }\n\n      OnlineLogisticRegression lr = learner.getModels().get(0);\n      output.println(lmp.getNumFeatures());\n      output.println(lmp.getTargetVariable() + \" ~ \");\n      String sep = \"\";\n      for (String v : csv.getTraceDictionary().keySet()) {\n        double weight = predictorWeight(lr, 0, csv, v);\n        if (weight != 0) {\n          output.printf(Locale.ENGLISH, \"%s%.3f*%s\", sep, weight, v);\n          sep = \" + \";\n        }\n      }\n      output.printf(\"%n\");\n\n      for (int row = 0; row < lr.getBeta().numRows(); row++) {\n        for (String key : csv.getTraceDictionary().keySet()) {\n          double weight = predictorWeight(lr, row, csv, key);\n          if (weight != 0) {\n            output.printf(Locale.ENGLISH, \"%20s %.5f%n\", key, weight);\n          }\n        }\n        for (int column = 0; column < lr.getBeta().numCols(); column++) {\n          output.printf(Locale.ENGLISH, \"%15.9f \", lr.getBeta().get(row, column));\n        }\n        output.println();\n      }\n    }\n  }\n"}, {"dataset": "readLine", "exampleID": 596, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 668, "focalAPIEnd": 681, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/endrix/xronos/tree/master/eclipse/plugins/org.xronos.openforge/src/org/xronos/openforge/util/license/License.java", "rawCode": "  /**\n   * function to return the license file as a String\n   *\n   * @return a string which is the license file\n   */\n  @SuppressWarnings(\"unused\")\n  public static String getLicenseFile() {\n    String licenseFile = \"\";\n\n    InputStream is = ForgeResource.loadForgeResourceStream(\"LICENSE_FILE\");\n\n    if (is == null) {\n      return \"license file not found\";\n    }\n\n    InputStreamReader isr = new InputStreamReader(is);\n\n    if (isr == null) {\n      return \"license file not found\";\n    }\n\n    BufferedReader br = new BufferedReader(isr);\n\n    if (br == null) {\n      return \"license file not found\";\n    }\n\n    try {\n      while (br.ready()) {\n        licenseFile += br.readLine() + \"\\n\";\n      }\n    } catch (Exception ioe) {\n      return licenseFile;\n    }\n\n    return (licenseFile);\n  }\n"}, {"dataset": "readLine", "exampleID": 597, "initialization": ["BufferedReader bufferedReader = new BufferedReader(InputStreamReader)"], "initializationStart": [3851], "initializationEnd": [3883], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 3900, "focalAPIEnd": 3917, "followUpCheck": "line != null", "checkType": "LOOP {", "followUpCheckExpressionStart": 3928, "followUpCheckExpressionEnd": 3948, "followUpCheckBlockStart": 3928, "followUpCheckBlockEnd": 4091, "use": ["line.trim()", "bufferedReader.readLine()", "bufferedReader.close()"], "useStart": [3968, 4063, 4227], "useEnd": [3979, 4080, 4241], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 4159, "finallyExpressionEnd": 4167, "finallyBlockStart": 4159, "finallyBlockEnd": 4312, "cleanUpCallStart": [4227], "cleanUpCallEnd": [4241], "url": "https://github.com/jponge/izpack-full-svn-history-copy/tree/master/izpack-src/tags/4.1.0/src/lib/com/izforge/izpack/util/TargetFactory.java", "rawCode": "  /**\n   * Returns the system dependent default install path. This is typically used to suggest an istall\n   * path to the end user, when performing an installation. The default install path is assembled\n   * form the OS specific path fragment specified in <code>INSTALL_PATH_FRAGMENT</code>, possibly a\n   * drive letter and the application name. The user the option to define resources that define\n   * default paths which differ from the path fragments defined here. The following resource names\n   * will be recognized by this method: <br>\n   * <br>\n   *\n   * <ul>\n   *   <li><code>TargetPanel.dir.windows</code>\n   *   <li><code>TargetPanel.dir.macosx</code>\n   *   <li><code>TargetPanel.dir.unix</code>\n   *   <li><code>TargetPanel.dir</code> plus the all lower case version of <code>\n   *       System.getProperty (\"os.name\")</code>, with all spaces replaced by an underscore ('_').\n   *   <li><code>TargetPanel.dir</code>\n   * </ul>\n   *\n   * @param appName the name of the application to install. If no specific resource has been set,\n   *     then this name will be appended to the OS specific default path fragment.\n   * @return the default install path for the target system\n   */\n  /*--------------------------------------------------------------------------*/\n  /*\n   * $ @design\n   *\n   * First try to read a path string from a resource file. This approach allows the user to\n   * customize the default install path that is suggested to the end user by IzPack. There are a\n   * number of choices for the naming of this resource, so we need to go through a few steps in\n   * order to exhaust the different possibilities. If this was not successful we use the default\n   * install path that is defined for the operating system we are running on. This path should be\n   * expanded by the application name to form the full path that to returne.\n   * --------------------------------------------------------------------------\n   */\n  public String getDefaultInstallPath(String appName) {\n    String path = null;\n    InputStream input;\n    String keyFragment = \"/res/\" + INSTALL_PATH_RESOURCE_KEY[GENERIC][STANDARD];\n\n    // ----------------------------------------------------\n    // attempt to get an input stream through a resource\n    // based on a key which is specific to the target OS\n    // ----------------------------------------------------\n    input = getClass().getResourceAsStream(\"/res/\" + INSTALL_PATH_RESOURCE_KEY[os][osFlavor]);\n\n    // ----------------------------------------------------\n    // attempt to get an input stream through a resource\n    // based on a key which is made specific to the target\n    // OS by using the string returned by\n    // System.getProperty (\"os.name\").toLowerCase ()\n    // ----------------------------------------------------\n    if (input == null) {\n      String key = OsVersion.OS_NAME.toLowerCase().replace(' ', '_'); // avoid\n      // spaces\n      // in\n      // file\n      // names\n      key = keyFragment + key.toLowerCase(); // for consistency among\n      // TargetPanel res files\n      input = TargetFactory.class.getResourceAsStream(key);\n    }\n\n    // ----------------------------------------------------\n    // attempt to get an input stream through a resource\n    // based on a key which is not specific to any target OS\n    // ----------------------------------------------------\n    if (input == null) {\n      input = TargetFactory.class.getResourceAsStream(keyFragment);\n    }\n\n    // ----------------------------------------------------\n    // If we got an input stream try to read the path\n    // from the file\n    // ----------------------------------------------------\n    if (input != null) {\n      InputStreamReader streamReader;\n      BufferedReader reader = null;\n      String line;\n\n      try {\n        streamReader = new InputStreamReader(input);\n        reader = new BufferedReader(streamReader);\n        line = reader.readLine();\n\n        while (line != null) {\n          line = line.trim();\n          if (!\"\".equals(line)) {\n            break;\n          }\n          line = reader.readLine();\n        }\n        path = line;\n      } catch (Throwable exception) {\n      } finally {\n        try {\n          if (reader != null) {\n            reader.close();\n          }\n        } catch (Throwable exception) {\n        }\n      }\n    }\n\n    // ----------------------------------------------------\n    // if we were unable to obtain a path from a resource,\n    // use the default for the traget operating system.\n    // ----------------------------------------------------\n    if (path == null || \"\".equals(path)) {\n      path = \"\";\n\n      // --------------------------------------------------\n      // if we run on windows, we need a valid drive letter\n      // to put in front of the path. The drive that\n      // contains the user's home directory is usually the\n      // drive that also contains the install directory,\n      // so this seems the best choice here.\n      // --------------------------------------------------\n      if (os == WINDOWS) {\n        String home = System.getProperty(\"user.home\");\n        // take everything up to and including the first '\\'\n        path = home.substring(0, home.indexOf(File.separatorChar) + 1);\n      }\n\n      path = path + INSTALL_PATH_FRAGMENT[os] + appName;\n    }\n\n    return path;\n  }\n"}, {"dataset": "readLine", "exampleID": 598, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 118, "focalAPIEnd": 131, "followUpCheck": "line == null", "checkType": "IF", "followUpCheckExpressionStart": 140, "followUpCheckExpressionEnd": 157, "followUpCheckBlockStart": 140, "followUpCheckBlockEnd": 170, "use": ["new StringTokenizer(line)"], "useStart": [183], "useEnd": [208], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mastersobg/contests/tree/master/yandex/trains/21.09.2013/F/F.java", "rawCode": "  private String nextToken() throws IOException {\n    while (st == null || !st.hasMoreTokens()) {\n      String line = in.readLine();\n\n      if (line == null) return null;\n\n      st = new StringTokenizer(line);\n    }\n\n    return st.nextToken();\n  }\n"}, {"dataset": "readLine", "exampleID": 599, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [374], "initializationEnd": [463], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "bufferedReader.ready()", "guardType": "LOOP {", "guardExpressionStart": 550, "guardExpressionEnd": 572, "guardBlockStart": 550, "guardBlockEnd": 1170, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 647, "focalAPIEnd": 664, "followUpCheck": "line != null", "checkType": "IF", "followUpCheckExpressionStart": 672, "followUpCheckExpressionEnd": 686, "followUpCheckBlockStart": 672, "followUpCheckBlockEnd": 1164, "use": ["line.indexOf(String)", "line.substring(int,*)", "line.indexOf(String)", "line.substring(*)"], "useStart": [767, 752, 820, 808], "useEnd": [782, 783, 835, 836], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rockt/ChemSpot/tree/master/src/main/java/de/berlin/hu/chemspot/ChemSpot.java", "rawCode": "  /**\n   * Reads a text from a gzipped file and puts the content into the provided jcas.\n   *\n   * @param jcas the jcas\n   * @param pathToFile the path to the text file\n   * @throws IOException\n   */\n  public static void readGZFile(JCas jcas, String pathToFile) throws IOException {\n    File file = new File(pathToFile);\n    String text;\n    BufferedReader reader =\n        new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(file))));\n\n    StringBuilder textBuffer = new StringBuilder();\n    Integer currindex = -1;\n    while (reader.ready()) {\n      PubmedDocument pmdoc = new PubmedDocument(jcas);\n      String s = reader.readLine();\n      if (s != null) {\n        // split line into pmid and text\n        String pmid = s.substring(0, s.indexOf(\"\\t\"));\n        String annot = s.substring(s.indexOf(\"\\t\"));\n        // two = splitFirst(s, \"\\t\");\n        pmdoc.setPmid(pmid);\n\n        // append text\n        textBuffer.append(annot).append(\"\\n\");\n        pmdoc.setBegin(currindex + 1);\n        Integer len = annot.length();\n        currindex = currindex + len + 1;\n        pmdoc.setEnd(currindex);\n        pmdoc.addToIndexes();\n      }\n    }\n\n    text = textBuffer.toString();\n\n    // put document in CAS\n    jcas.setDocumentText(text);\n    SourceDocumentInformation srcDocInfo = new SourceDocumentInformation(jcas);\n    srcDocInfo.setUri(file.getAbsoluteFile().toURI().toString());\n    srcDocInfo.setOffsetInSource(0);\n    srcDocInfo.setDocumentSize((int) file.length());\n    srcDocInfo.setBegin(0);\n    srcDocInfo.setEnd(currindex);\n    srcDocInfo.addToIndexes();\n  }\n"}, {"dataset": "readLine", "exampleID": 600, "initialization": ["BufferedReader bufferedReader = new BufferedReader(*)"], "initializationStart": [651], "initializationEnd": [688], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(*)"], "tryExpressionStart": 178, "tryExpressionEnd": 182, "tryBlockStart": 178, "tryBlockEnd": 1712, "catchExpressionStart": 1654, "catchExpressionEnd": 1675, "catchBlockStart": 1654, "catchBlockEnd": 1712, "exceptionHandlingCallStart": [1683], "exceptionHandlingCallEnd": [1705], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = bufferedReader.readLine()", "focalAPIStart": 807, "focalAPIEnd": 820, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["string_to_object(line)", "bufferedReader.close()"], "useStart": [786, 829], "useEnd": [821, 839], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/metaswirl/middleware/tree/master/3/jacorb-3.2/demo/value/src/demo/value/Client.java", "rawCode": "  public static void main(String args[]) {\n    if (args.length != 1) {\n      System.out.println(\"Usage: java demo.value.idl.Client <ior_file>\");\n      System.exit(1);\n    }\n\n    try {\n      File f = new File(args[0]);\n\n      // check if file exists\n      if (!f.exists()) {\n        System.out.println(\"File \" + args[0] + \" does not exist.\");\n\n        System.exit(-1);\n      }\n\n      // check if args[0] points to a directory\n      if (f.isDirectory()) {\n        System.out.println(\"File \" + args[0] + \" is a directory.\");\n\n        System.exit(-1);\n      }\n\n      // initialize the ORB.\n      ORB orb = ORB.init(args, null);\n\n      BufferedReader br = new BufferedReader(new FileReader(f));\n\n      // get object reference from command-line argument file\n      org.omg.CORBA.Object obj = orb.string_to_object(br.readLine());\n      br.close();\n\n      ValueServer s = ValueServerHelper.narrow(obj);\n\n      // invoke operations and print the results\n      boxedLong p1 = new boxedLong(774);\n      boxedLong p2 = new boxedLong(774);\n\n      System.out.println(\"Passing two integers: \" + s.receive_long(p1, p2));\n\n      System.out.println(\"Passing one integer twice: \" + s.receive_long(p1, p1));\n\n      System.out.println(\"Passing two strings: \" + s.receive_string(\"hello\", \"hello\"));\n\n      System.out.println(\"Passing null: \" + s.receive_string(\"hello\", null));\n\n      Node n1 = new NodeImpl(1);\n      Node n2 = new NodeImpl(2);\n      Node n3 = new NodeImpl(3);\n      Node n4 = new NodeImpl(4);\n\n      n1.next = n2;\n      n2.next = n3;\n      n3.next = n4;\n      n4.next = n1;\n\n      System.out.println(\"Passing a list structure: \" + s.receive_list(n1));\n    } catch (Exception ex) {\n      System.err.println(ex);\n    }\n  }\n"}]