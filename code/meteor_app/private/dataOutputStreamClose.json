[{"dataset": "dataOutputStreamClose", "exampleID": 1501, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [1128], "initializationEnd": [1172], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["getMessage()", "e(String,String,*)", "getMessage()", "new PluginResult(*,*)", "error(PluginResult,String)"], "tryExpressionStart": 1181, "tryExpressionEnd": 1185, "tryBlockStart": 1181, "tryBlockEnd": 1674, "catchExpressionStart": 4932, "catchExpressionEnd": 4964, "catchBlockStart": 4932, "catchBlockEnd": 5152, "exceptionHandlingCallStart": [4756, 4723, 4876, 5053, 5120], "exceptionHandlingCallEnd": [4770, 4774, 4890, 5112, 5145], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.write(byte[],int,int)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.flush()"], "configurationStart": [1297, 1348, 1432, 1477, 1537, 1682, 1729, 1932, 1994, 2559, 3915, 3946, 4053], "configurationEnd": [1336, 1420, 1465, 1525, 1560, 1721, 1924, 1985, 2017, 2591, 3938, 3990, 4064], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 4282, "focalAPIEnd": 4293, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eaapa/phunt-mobile/tree/master/src/com/beetight/FileUploader.java", "rawCode": "  public void upload(\n      InputStream fileInputStream,\n      String server,\n      JSONObject params,\n      final String fileKey,\n      final String fileName,\n      final String mimeType,\n      final String callbackId) {\n    try {\n\n      String lineEnd = \"\\r\\n\";\n      String td = \"--\";\n      String boundary = \"*****com.beetight.formBoundary\";\n\n      URL url = new URL(server);\n      HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\n      // Get cookies that have been set in our webview\n      CookieManager cm = CookieManager.getInstance();\n      String cookie = cm.getCookie(server);\n\n      // allow inputs\n      conn.setDoInput(true);\n      // allow outputs\n      conn.setDoOutput(true);\n      // don't use a cached copy\n      conn.setUseCaches(false);\n      // use a post method\n      conn.setRequestMethod(\"POST\");\n      // set post headers\n      conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n      conn.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n      conn.setRequestProperty(\"Cookie\", cookie);\n      // open data output stream\n      DataOutputStream dos = new DataOutputStream(conn.getOutputStream());\n\n      try {\n        for (Iterator iter = params.keys(); iter.hasNext(); ) {\n          Object key = iter.next();\n          dos.writeBytes(td + boundary + lineEnd);\n          dos.writeBytes(\"Content-Disposition: form-data; name=\\\"\" + key + \"\\\"; \");\n          dos.writeBytes(lineEnd + lineEnd);\n          dos.writeBytes(params.getString(key.toString()));\n          dos.writeBytes(lineEnd);\n        }\n      } catch (JSONException e) {\n        Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      }\n\n      dos.writeBytes(td + boundary + lineEnd);\n      dos.writeBytes(\n          \"Content-Disposition: form-data; name=\\\"\"\n              + fileKey\n              + \"\\\";filename=\\\"\"\n              + fileName\n              + \"\\\"\"\n              + lineEnd);\n      dos.writeBytes(\"Content-Type: \" + mimeType + lineEnd);\n\n      dos.writeBytes(lineEnd);\n      // create a buffer of maximum size\n      int bytesAvailable = fileInputStream.available();\n      final int total = bytesAvailable;\n      Log.e(\"PhoneGapLog\", \"available: \" + bytesAvailable);\n\n      int maxBufferSize = 1024;\n      int bufferSize = Math.min(bytesAvailable, maxBufferSize);\n      byte[] buffer = new byte[bufferSize];\n      // read file and write it into form...\n      int bytesRead = fileInputStream.read(buffer, 0, bufferSize);\n      int progress = bytesRead;\n      int send = 0;\n      while (bytesRead > 0) {\n        dos.write(buffer, 0, bufferSize);\n        bytesAvailable = fileInputStream.available();\n        bufferSize = Math.min(bytesAvailable, maxBufferSize);\n        bytesRead = fileInputStream.read(buffer, 0, bufferSize);\n        progress += bytesRead;\n        final int prog = progress;\n        Log.e(\"PhoneGapLog\", \"read \" + progress + \" of \" + total);\n\n        // Sending every progress event is overkill\n        if (send++ % 20 == 0) {\n          ctx.runOnUiThread(\n              new Runnable() {\n                public void run() {\n                  try {\n                    JSONObject result = new JSONObject();\n                    result.put(\"status\", FileUploader.Status.PROGRESS);\n                    result.put(\"progress\", prog);\n                    result.put(\"total\", total);\n                    PluginResult progressResult = new PluginResult(PluginResult.Status.OK, result);\n                    progressResult.setKeepCallback(true);\n                    success(progressResult, callbackId);\n                  } catch (JSONException e) {\n                    Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n                  }\n                }\n              });\n          // Give a chance for the progress to be sent to javascript\n          Thread.sleep(100);\n        }\n      }\n      // send multipart form data necessary after file data...\n      dos.writeBytes(lineEnd);\n      dos.writeBytes(td + boundary + td + lineEnd);\n\n      // close streams\n      fileInputStream.close();\n      dos.flush();\n      InputStream is = conn.getInputStream();\n      int ch;\n      StringBuffer b = new StringBuffer();\n      while ((ch = is.read()) != -1) {\n        b.append((char) ch);\n      }\n      String s = b.toString();\n      dos.close();\n      JSONObject result = new JSONObject();\n      result.put(\"status\", FileUploader.Status.COMPLETE);\n\n      result.put(\"progress\", progress);\n      result.put(\"total\", total);\n      result.put(\"result\", s);\n      PluginResult progressResult = new PluginResult(PluginResult.Status.OK, result);\n      progressResult.setKeepCallback(true);\n      success(progressResult, callbackId);\n\n    } catch (MalformedURLException e) {\n      Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      PluginResult result =\n          new PluginResult(PluginResult.Status.MALFORMED_URL_EXCEPTION, e.getMessage());\n      error(result, callbackId);\n    } catch (FileNotFoundException e) {\n      Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      PluginResult result = new PluginResult(PluginResult.Status.ERROR, e.getMessage());\n      error(result, callbackId);\n    } catch (IOException e) {\n      Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      PluginResult result = new PluginResult(PluginResult.Status.IO_EXCEPTION, e.getMessage());\n      error(result, callbackId);\n    } catch (InterruptedException e) {\n      Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      PluginResult result = new PluginResult(PluginResult.Status.ERROR, e.getMessage());\n      error(result, callbackId);\n    } catch (JSONException e) {\n      Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      PluginResult result = new PluginResult(PluginResult.Status.JSON_EXCEPTION, e.getMessage());\n      error(result, callbackId);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1502, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 81, "focalAPIEnd": 92, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/distributed/tree/master/Fast_Copy_HDFS/src/mapred/org/apache/hadoop/mapred/TextOutputFormat.java", "rawCode": "    public synchronized void close(Reporter reporter) throws IOException {\n      out.close();\n    }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1503, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 599, "guardExpressionEnd": 615, "guardBlockStart": 599, "guardBlockEnd": 716, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 638, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gabrielmd/contiki/tree/master/tools/cooja/apps/collect-view/java/se/sics/cooja/plugins/collectview/CollectView.java", "rawCode": "  private void cleanup() {\n    if (serialDataObserver != null) {\n      serialPort.deleteSerialDataObserver(serialDataObserver);\n      serialDataObserver = null;\n    }\n\n    if (isRunning) {\n      logger.fatal(\"The CollectView application died!\");\n      if (GUI.isVisualized()) {\n        JOptionPane.showMessageDialog(\n            this,\n            \"The CollectView application died!\",\n            \"CollectView died!\",\n            JOptionPane.ERROR_MESSAGE);\n      }\n    }\n    isRunning = false;\n    if (commandProcess != null) {\n      commandProcess.destroy();\n      commandProcess = null;\n    }\n    if (out != null) {\n      try {\n        out.close();\n        out = null;\n      } catch (IOException e) {\n      }\n    }\n\n    if (GUI.isVisualized()) {\n      EventQueue.invokeLater(\n          new Runnable() {\n            public void run() {\n              setTitle(getTitle() + \" *DISCONNECTED*\");\n              inLabel.setEnabled(false);\n              outLabel.setEnabled(false);\n            }\n          });\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1504, "initialization": ["DataOutputStream dataOutputStream = FileSystem.create(Path)"], "initializationStart": [153], "initializationEnd": [173], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[])"], "configurationStart": [280], "configurationEnd": [297], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 303, "focalAPIEnd": 314, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benh/twesos/tree/master/frameworks/hadoop-0.20.2/src/test/org/apache/hadoop/hdfs/TestSeekBug.java", "rawCode": "  private void writeFile(FileSystem fileSys, Path name) throws IOException {\n    // create and write a file that contains 1MB\n    DataOutputStream stm = fileSys.create(name);\n    byte[] buffer = new byte[ONEMB];\n    Random rand = new Random(seed);\n    rand.nextBytes(buffer);\n    stm.write(buffer);\n    stm.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1505, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [151], "initializationEnd": [223], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeInt(int)", "dataOutputStream.writeLong(long)"], "configurationStart": [230, 315], "configurationEnd": [264, 349], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 361, "focalAPIEnd": 379, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spacecaker/android_frameworks_base_CSM9.1/tree/master/packages/SettingsProvider/src/com/android/providers/settings/SettingsBackupAgent.java", "rawCode": "  private void writeNewChecksums(long[] checksums, ParcelFileDescriptor newState)\n      throws IOException {\n    DataOutputStream dataOutput =\n        new DataOutputStream(new FileOutputStream(newState.getFileDescriptor()));\n\n    dataOutput.writeInt(STATE_VERSION);\n    for (int i = 0; i < STATE_SIZE; i++) {\n      dataOutput.writeLong(checksums[i]);\n    }\n    dataOutput.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1506, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [1520], "initializationEnd": [1572], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(String)", "dataOutputStream.writeLong(int)", "dataOutputStream.writeLong(int)", "dataOutputStream.writeLong(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.size()"], "configurationStart": [1705, 1757, 1817, 1877, 4542, 4574, 4635, 5056], "configurationEnd": [1751, 1778, 1838, 1903, 4564, 4625, 4690, 5070], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 5291, "focalAPIEnd": 5306, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TechnicPack/LegacyLauncher/tree/master/src/main/java/org/spoutcraft/diff/JBDiff.java", "rawCode": "  public static void bsdiff(File oldFile, File newFile, File diffFile) throws IOException {\n\n    int oldsize = (int) oldFile.length();\n    byte[] oldBuf = new byte[oldsize];\n\n    FileInputStream in = new FileInputStream(oldFile);\n    Util.readFromStream(in, oldBuf, 0, oldsize);\n    in.close();\n\n    int[] I = new int[oldsize + 1];\n    int[] V = new int[oldsize + 1];\n\n    qsufsort(I, V, oldBuf);\n\n    // free(V)\n    V = null;\n    System.gc();\n\n    int newsize = (int) newFile.length();\n    byte[] newBuf = new byte[newsize];\n    in = new FileInputStream(newFile);\n    Util.readFromStream(in, newBuf, 0, newsize);\n    in.close();\n\n    // diff block\n    int dblen = 0;\n    byte[] db = new byte[newsize];\n\n    // extra block\n    int eblen = 0;\n    byte[] eb = new byte[newsize];\n\n    /*\n     * Diff file is composed as follows:\n     *\n     * Header (32 bytes) Data (from offset 32 to end of file)\n     *\n     * Header: Offset 0, length 8 bytes: file magic \"jbdiff40\" Offset 8, length\n     * 8 bytes: length of ctrl block Offset 16, length 8 bytes: length of\n     * compressed diff block Offset 24, length 8 bytes: length of new file\n     *\n     * Data: 32 (length ctrlBlockLen): ctrlBlock 32+ctrlBlockLen (length\n     * diffBlockLen): diffBlock (gziped) 32+ctrlBlockLen+diffBlockLen (to end of\n     * file): extraBlock (gziped)\n     *\n     * ctrlBlock comprises a set of records, each record 12 bytes. A record\n     * comprises 3 x 32 bit integers. The ctrlBlock is not compressed.\n     */\n\n    DataOutputStream diffOut = new DataOutputStream(new FileOutputStream(diffFile));\n\n    /*\n     * Write as much of header as we have now. Size of ctrlBlock and diffBlock\n     * must be filled in later.\n     */\n    diffOut.write(\"jbdiff40\".getBytes(\"US-ASCII\"));\n    diffOut.writeLong(-1); // place holder for ctrlBlockLen\n    diffOut.writeLong(-1); // place holder for diffBlockLen\n    diffOut.writeLong(newsize);\n\n    int oldscore, scsc;\n\n    int overlap, Ss, lens;\n    int i;\n    int scan = 0;\n    int len = 0;\n    int lastscan = 0;\n    int lastpos = 0;\n    int lastoffset = 0;\n\n    IntByRef pos = new IntByRef();\n    int ctrlBlockLen = 0;\n\n    while (scan < newsize) {\n\n      oldscore = 0;\n\n      for (scsc = scan += len; scan < newsize; scan++) {\n\n        len = search(I, oldBuf, newBuf, scan, 0, oldsize, pos);\n\n        for (; scsc < scan + len; scsc++) {\n          if ((scsc + lastoffset < oldsize) && (oldBuf[scsc + lastoffset] == newBuf[scsc])) {\n            oldscore++;\n          }\n        }\n\n        if (((len == oldscore) && (len != 0)) || (len > oldscore + 8)) {\n          break;\n        }\n\n        if ((scan + lastoffset < oldsize) && (oldBuf[scan + lastoffset] == newBuf[scan])) {\n          oldscore--;\n        }\n      }\n\n      if ((len != oldscore) || (scan == newsize)) {\n        int s = 0;\n        int Sf = 0;\n        int lenf = 0;\n        for (i = 0; (lastscan + i < scan) && (lastpos + i < oldsize); ) {\n          if (oldBuf[lastpos + i] == newBuf[lastscan + i]) s++;\n          i++;\n          if (s * 2 - i > Sf * 2 - lenf) {\n            Sf = s;\n            lenf = i;\n          }\n        }\n\n        int lenb = 0;\n        if (scan < newsize) {\n          s = 0;\n          int Sb = 0;\n          for (i = 1; (scan >= lastscan + i) && (pos.value >= i); i++) {\n            if (oldBuf[pos.value - i] == newBuf[scan - i]) s++;\n            if (s * 2 - i > Sb * 2 - lenb) {\n              Sb = s;\n              lenb = i;\n            }\n          }\n        }\n\n        if (lastscan + lenf > scan - lenb) {\n          overlap = (lastscan + lenf) - (scan - lenb);\n          s = 0;\n          Ss = 0;\n          lens = 0;\n          for (i = 0; i < overlap; i++) {\n            if (newBuf[lastscan + lenf - overlap + i] == oldBuf[lastpos + lenf - overlap + i]) {\n              s++;\n            }\n            if (newBuf[scan - lenb + i] == oldBuf[pos.value - lenb + i]) {\n              s--;\n            }\n            if (s > Ss) {\n              Ss = s;\n              lens = i + 1;\n            }\n          }\n\n          lenf += lens - overlap;\n          lenb -= lens;\n        }\n\n        // ? byte casting introduced here -- might affect things\n        for (i = 0; i < lenf; i++) {\n          db[dblen + i] = (byte) (newBuf[lastscan + i] - oldBuf[lastpos + i]);\n        }\n\n        for (i = 0; i < (scan - lenb) - (lastscan + lenf); i++) {\n          eb[eblen + i] = newBuf[lastscan + lenf + i];\n        }\n\n        dblen += lenf;\n        eblen += (scan - lenb) - (lastscan + lenf);\n\n        /*\n         * Write control block entry (3 x int)\n         */\n        diffOut.writeInt(lenf);\n        diffOut.writeInt((scan - lenb) - (lastscan + lenf));\n        diffOut.writeInt((pos.value - lenb) - (lastpos + lenf));\n        ctrlBlockLen += 12;\n\n        lastscan = scan - lenb;\n        lastpos = pos.value - lenb;\n        lastoffset = pos.value - scan;\n      } // end if\n    } // end while loop\n\n    GZIPOutputStream gzOut;\n\n    /*\n     * Write diff block\n     */\n    gzOut = new GZIPOutputStream(diffOut);\n    gzOut.write(db, 0, dblen);\n    gzOut.finish();\n    int diffBlockLen = diffOut.size() - ctrlBlockLen - 32;\n    // System.err.println (\"diffBlockLen=\" + diffBlockLen);\n\n    /*\n     * Write extra block\n     */\n    gzOut = new GZIPOutputStream(diffOut);\n    gzOut.write(eb, 0, eblen);\n    gzOut.finish();\n    diffOut.close();\n\n    /*\n     * Write missing header info. Need to reopen the file with RandomAccessFile\n     * for this.\n     */\n    RandomAccessFile diff = new RandomAccessFile(diffFile, \"rw\");\n    diff.seek(8);\n    diff.writeLong(ctrlBlockLen); // ctrlBlockLen (compressed) @offset 8\n    diff.writeLong(diffBlockLen); // diffBlockLen (compressed) @offset 16\n    diff.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1507, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [1013], "initializationEnd": [1063], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[])"], "configurationStart": [1075], "configurationEnd": [1094], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1106, "focalAPIEnd": 1117, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/avenwu/volleyhelper/tree/master/src/com/android/volley/toolbox/HurlStack.java", "rawCode": "  @SuppressWarnings(\"deprecation\")\n  /* package */ static void setConnectionParametersForRequest(\n      HttpURLConnection connection, Request<?> request) throws IOException, AuthFailureError {\n    switch (request.getMethod()) {\n      case Method.DEPRECATED_GET_OR_POST:\n        // This is the deprecated way that needs to be handled for backwards compatibility.\n        // If the request's post body is null, then the assumption is that the request is\n        // GET. Otherwise, it is assumed that the request is a POST.\n        byte[] postBody = request.getPostBody();\n        if (postBody != null) {\n          // Prepare output. There is no need to set Content-Length explicitly,\n          // since this is handled by HttpURLConnection using the size of the prepared\n          // output stream.\n          connection.setDoOutput(true);\n          connection.setRequestMethod(\"POST\");\n          connection.addRequestProperty(HEADER_CONTENT_TYPE, request.getPostBodyContentType());\n          DataOutputStream out = new DataOutputStream(connection.getOutputStream());\n          out.write(postBody);\n          out.close();\n        }\n        break;\n      case Method.GET:\n        // Not necessary to set the request method because connection defaults to GET but\n        // being explicit here.\n        connection.setRequestMethod(\"GET\");\n        break;\n      case Method.DELETE:\n        connection.setRequestMethod(\"DELETE\");\n        break;\n      case Method.POST:\n        connection.setRequestMethod(\"POST\");\n        addBodyIfExists(connection, request);\n        break;\n      case Method.PUT:\n        connection.setRequestMethod(\"PUT\");\n        addBodyIfExists(connection, request);\n        break;\n      default:\n        throw new IllegalStateException(\"Unknown method type.\");\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1508, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "null!=dataOutputStream", "guardType": "IF {", "guardExpressionStart": 87, "guardExpressionEnd": 107, "guardBlockStart": 87, "guardBlockEnd": 124, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 108, "focalAPIEnd": 123, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/distributed/tree/master/Fast_Copy_HDFS/src/mapred/org/apache/hadoop/mapred/join/StreamBackedIterator.java", "rawCode": "  public void close() throws IOException {\n    if (null != infbuf) infbuf.close();\n    if (null != outfbuf) outfbuf.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1509, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 181, "focalAPIEnd": 191, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/test/java/libcore/java/io/OldDataInputStreamTest.java", "rawCode": "  /**\n   * Tears down the fixture, for example, close a network connection. This method is called after a\n   * test is executed.\n   */\n  protected void tearDown() {\n    try {\n      os.close();\n    } catch (Exception e) {\n    }\n    try {\n      dis.close();\n    } catch (Exception e) {\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1510, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 914, "guardExpressionEnd": 934, "guardBlockStart": 914, "guardBlockEnd": 951, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 935, "focalAPIEnd": 950, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["printStackTrace()"], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [992], "cleanUpCallEnd": [1011], "url": "https://github.com/wubs/485-Project/tree/master/pa6/hadoop/src/contrib/eclipse-plugin/src/java/org/apache/hadoop/eclipse/dfs/DFSFile.java", "rawCode": "  /**\n   * Upload a local file to this file on the distributed file system\n   *\n   * @param monitor\n   * @param file\n   */\n  public void upload(IProgressMonitor monitor, File file) {\n\n    final int taskSize = 1024;\n\n    monitor.setTaskName(\"Upload file \" + this.path);\n\n    BufferedInputStream istream = null;\n    DataOutputStream ostream = null;\n\n    try {\n      istream = new BufferedInputStream(new FileInputStream(file));\n      ostream = getDFS().create(this.path);\n\n      int bytes;\n      byte[] buffer = new byte[taskSize];\n\n      while ((bytes = istream.read(buffer)) >= 0) {\n        if (monitor.isCanceled()) return;\n        ostream.write(buffer, 0, bytes);\n        monitor.worked(1);\n      }\n\n    } catch (Exception e) {\n      ErrorMessageDialog.display(\n          String.format(\"Unable to uploade file %s to %s\", file, this.path),\n          e.getLocalizedMessage());\n\n    } finally {\n      try {\n        if (istream != null) istream.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n        // nothing we can do here\n      }\n      try {\n        if (ostream != null) ostream.close();\n      } catch (IOException e) {\n        e.printStackTrace();\n        // nothing we can do here\n      }\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1511, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [214], "initializationEnd": [261], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(char)", "dataOutputStream.flush()", "dataOutputStream.writeBytes(String)", "dataOutputStream.flush()"], "configurationStart": [330, 367, 385, 412], "configurationEnd": [359, 377, 404, 422], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 817, "guardExpressionEnd": 832, "guardBlockStart": 817, "guardBlockEnd": 866, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 845, "focalAPIEnd": 855, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["Process.destroy()"], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [908], "cleanUpCallEnd": [925], "url": "https://github.com/k-code/k-car/tree/master/CopProject/Cop/src/main/java/pro/kornev/kcar/cop/services/support/ShellInterface.java", "rawCode": "  private static String _runCommand(String command, OUTPUT o) throws IOException {\n    DataOutputStream os = null;\n    Process process = null;\n    try {\n      process = Runtime.getRuntime().exec(shell);\n      os = new DataOutputStream(process.getOutputStream());\n      InputStreamHandler sh = sinkProcessOutput(process, o);\n      os.writeBytes(command + '\\n');\n      os.flush();\n      os.writeBytes(EXIT);\n      os.flush();\n      process.waitFor();\n      if (sh != null) {\n        String output = sh.getOutput();\n        Log.d(TAG, command + \" output: \" + output);\n        return output;\n      } else {\n        return null;\n      }\n    } catch (Exception e) {\n      final String msg = e.getMessage();\n      Log.e(TAG, \"runCommand error: \" + msg);\n      throw new IOException(msg);\n    } finally {\n      try {\n        if (os != null) {\n          os.close();\n        }\n        if (process != null) {\n          process.destroy();\n        }\n      } catch (Exception ignored) {\n      }\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1512, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [939], "initializationEnd": [986], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["error(*)", "new IOException(String)"], "tryExpressionStart": 799, "tryExpressionEnd": 803, "tryBlockStart": 799, "tryBlockEnd": 1687, "catchExpressionStart": 1574, "catchExpressionEnd": 1594, "catchBlockStart": 1574, "catchBlockEnd": 1687, "exceptionHandlingCallStart": [1602, 1628], "exceptionHandlingCallEnd": [1614, 1680], "configuration": ["dataOutputStream.writeUTF(String)", "dataOutputStream.writeDouble(String)", "dataOutputStream.writeUTF(String)", "dataOutputStream.flush()"], "configurationStart": [1244, 1386, 1490, 1536], "configurationEnd": [1261, 1408, 1509, 1547], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1555, "focalAPIEnd": 1566, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ProjetX/ProjetX/tree/master/slick/src/org/newdawn/slick/muffin/WebstartMuffin.java", "rawCode": "  /** @see org.newdawn.slick.muffin.Muffin#saveFile(java.util.HashMap, java.lang.String) */\n  public void saveFile(HashMap scoreMap, String fileName) throws IOException {\n\n    PersistenceService ps;\n    BasicService bs;\n    URL configURL;\n\n    try {\n      ps = (PersistenceService) ServiceManager.lookup(\"javax.jnlp.PersistenceService\");\n      bs = (BasicService) ServiceManager.lookup(\"javax.jnlp.BasicService\");\n      URL baseURL = bs.getCodeBase();\n      // System.out.println(\"CodeBase was \" + baseURL);\n      configURL = new URL(baseURL, fileName);\n    } catch (Exception e) {\n      Log.error(e);\n      throw new IOException(\"Failed to save state: \");\n    }\n\n    try {\n      ps.delete(configURL);\n    } catch (Exception e) {\n      Log.info(\"No exisiting Muffin Found - First Save\");\n    }\n\n    try {\n      ps.create(configURL, 1024); // 1024 bytes for our data\n\n      FileContents fc = ps.get(configURL);\n      DataOutputStream oos = new DataOutputStream(fc.getOutputStream(false));\n\n      // scroll through hashMap and write key and value to file\n      Set keys = scoreMap.keySet(); // get the keys\n\n      // get values using keys\n      for (Iterator i = keys.iterator(); i.hasNext(); ) {\n        String key = (String) i.next();\n\n        oos.writeUTF(key);\n\n        if (fileName.endsWith(\"Number\")) {\n          double value = ((Double) scoreMap.get(key)).doubleValue();\n          oos.writeDouble(value);\n        } else {\n          String value = (String) scoreMap.get(key);\n          oos.writeUTF(value);\n        }\n      }\n\n      oos.flush();\n      oos.close();\n    } catch (Exception e) {\n      Log.error(e);\n      throw new IOException(\"Failed to store map of state data\");\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1513, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [347], "initializationEnd": [397], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[])"], "configurationStart": [405], "configurationEnd": [420], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 428, "focalAPIEnd": 439, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rutube/volley/tree/master/src/com/android/volley/toolbox/HurlStack.java", "rawCode": "  private static void addBodyIfExists(HttpURLConnection connection, Request<?> request)\n      throws IOException, AuthFailureError {\n    byte[] body = request.getBody();\n    if (body != null) {\n      connection.setDoOutput(true);\n      connection.addRequestProperty(HEADER_CONTENT_TYPE, request.getBodyContentType());\n      DataOutputStream out = new DataOutputStream(connection.getOutputStream());\n      out.write(body);\n      out.close();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1514, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getMessage()", "new RuntimeException(*)"], "tryExpressionStart": 40, "tryExpressionEnd": 44, "tryBlockStart": 40, "tryBlockEnd": 153, "catchExpressionStart": 74, "catchExpressionEnd": 96, "catchBlockStart": 74, "catchBlockEnd": 153, "exceptionHandlingCallStart": [131, 110], "exceptionHandlingCallEnd": [145, 146], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 52, "focalAPIEnd": 66, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fpsunflower/sunflow/tree/master/src/org/sunflow/BinaryFileSunflowAPI.java", "rawCode": "  @Override\n  public void close() {\n    try {\n      stream.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1515, "initialization": ["DataOutputStream dataOutputStream = getLocal(JobConf)"], "initializationStart": [318], "initializationEnd": [343], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 435, "focalAPIEnd": 446, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benh/twesos/tree/master/frameworks/hadoop-0.20.2/src/mapred/org/apache/hadoop/mapred/MapTask.java", "rawCode": "  @Override\n  public void localizeConfiguration(JobConf conf) throws IOException {\n    super.localizeConfiguration(conf);\n    if (isMapOrReduce()) {\n      Path localSplit = new Path(new Path(getJobFile()).getParent(), \"split.dta\");\n      LOG.debug(\"Writing local split to \" + localSplit);\n      DataOutputStream out = FileSystem.getLocal(conf).create(localSplit);\n      Text.writeString(out, splitClass);\n      split.write(out);\n      out.close();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1516, "initialization": ["DataOutputStream dataOutputStream = create(*)"], "initializationStart": [235], "initializationEnd": [306], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 312, "focalAPIEnd": 324, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/Hadoop-mdfs/tree/master/hadoop-1.2.1/src/test/org/apache/hadoop/mapred/lib/TestChainMapReduce.java", "rawCode": "  private static void writeFlag(JobConf conf, String flag) throws IOException {\n    FileSystem fs = FileSystem.get(conf);\n    if (getFlag(conf, flag)) {\n      fail(\"Flag \" + flag + \" already exists\");\n    }\n    DataOutputStream file = fs.create(new Path(getFlagDir(conf.getBoolean(\"localFS\", true)), flag));\n    file.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1517, "initialization": ["DataOutputStream dataOutputStream = prepareAppendKey(int)"], "initializationStart": [107], "initializationEnd": [139], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 172, "focalAPIEnd": 183, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["LogValue.write(dataOutputStream)", "dataOutputStream.close()"], "useStart": [239, 266], "useEnd": [258, 277], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java", "rawCode": "    public void append(LogKey logKey, LogValue logValue) throws IOException {\n      DataOutputStream out = this.writer.prepareAppendKey(-1);\n      logKey.write(out);\n      out.close();\n      out = this.writer.prepareAppendValue(-1);\n      logValue.write(out);\n      out.close();\n      this.fsDataOStream.hflush();\n    }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1518, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 75, "focalAPIEnd": 90, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Arzeyt/TheDarkness/tree/master/TheDarkness/src/us/twoguys/lib/jnbt/NBTOutputStream.java", "rawCode": "  /* */ public void close() /* */ throws IOException /* */ {\n    /* 254 */ this.os.close();\n    /* */ }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1519, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [361], "configurationEnd": [390], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 673, "focalAPIEnd": 686, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["MiniDFSCluster.shutdown()"], "finallyExpressionStart": 841, "finallyExpressionEnd": 849, "finallyBlockStart": 841, "finallyBlockEnd": 921, "cleanUpCallStart": [888], "cleanUpCallEnd": [906], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/TestLease.java", "rawCode": "  @Test\n  public void testLease() throws Exception {\n    MiniDFSCluster cluster = new MiniDFSCluster.Builder(conf).numDataNodes(2).build();\n    try {\n      FileSystem fs = cluster.getFileSystem();\n      Assert.assertTrue(fs.mkdirs(dir));\n\n      Path a = new Path(dir, \"a\");\n      Path b = new Path(dir, \"b\");\n\n      DataOutputStream a_out = fs.create(a);\n      a_out.writeBytes(\"something\");\n\n      Assert.assertTrue(hasLease(cluster, a));\n      Assert.assertTrue(!hasLease(cluster, b));\n\n      DataOutputStream b_out = fs.create(b);\n      b_out.writeBytes(\"something\");\n\n      Assert.assertTrue(hasLease(cluster, a));\n      Assert.assertTrue(hasLease(cluster, b));\n\n      a_out.close();\n      b_out.close();\n\n      Assert.assertTrue(!hasLease(cluster, a));\n      Assert.assertTrue(!hasLease(cluster, b));\n\n      fs.delete(dir, true);\n    } finally {\n      if (cluster != null) {\n        cluster.shutdown();\n      }\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1520, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [150], "initializationEnd": [221], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeUTF(String)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.flush()"], "configurationStart": [229, 271, 310, 349], "configurationEnd": [263, 302, 341, 360], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 573, "guardExpressionEnd": 589, "guardBlockStart": 573, "guardBlockEnd": 700, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 616, "focalAPIEnd": 627, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/javroch/android_packages_apps_Launcher2/tree/master/src/com/android/launcher2/Launcher.java", "rawCode": "  private static void writeConfiguration(Context context, LocaleConfiguration configuration) {\n    DataOutputStream out = null;\n    try {\n      out = new DataOutputStream(context.openFileOutput(PREFERENCES, MODE_PRIVATE));\n      out.writeUTF(configuration.locale);\n      out.writeInt(configuration.mcc);\n      out.writeInt(configuration.mnc);\n      out.flush();\n    } catch (FileNotFoundException e) {\n      // Ignore\n    } catch (IOException e) {\n      // noinspection ResultOfMethodCallIgnored\n      context.getFileStreamPath(PREFERENCES).delete();\n    } finally {\n      if (out != null) {\n        try {\n          out.close();\n        } catch (IOException e) {\n          // Ignore\n        }\n      }\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1521, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [562], "initializationEnd": [606], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["reportStatus(*)"], "tryExpressionStart": 53, "tryExpressionEnd": 57, "tryBlockStart": 53, "tryBlockEnd": 1467, "catchExpressionStart": 1408, "catchExpressionEnd": 1428, "catchBlockStart": 1408, "catchBlockEnd": 1467, "exceptionHandlingCallStart": [1436], "exceptionHandlingCallEnd": [1460], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.flush()"], "configurationStart": [614, 641], "configurationEnd": [633, 651], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 659, "focalAPIEnd": 669, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jpcaruana/jsynthlib/tree/master/src/main/java/org/jsynthlib/core/UploadPatchDialog.java", "rawCode": "  int postData(String repository, String mime) {\n    try {\n      URL url = new URL(repository + \"/cgi-bin/upload.cgi\");\n      HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n      conn.setDoInput(true);\n      conn.setDoOutput(true);\n      conn.setUseCaches(false);\n      conn.setRequestMethod(\"POST\");\n      conn.setRequestProperty(\"Connection\", \"Close\");\n      conn.setRequestProperty(\n          \"Content-Type\",\n          \"multipart/form-data;boundary=-----------------------------18042893838469308861681692777\");\n      DataOutputStream os = new DataOutputStream(conn.getOutputStream());\n      os.writeBytes(mime);\n      os.flush();\n      os.close();\n      BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n      String str;\n      while ((str = in.readLine()) != null) {\n        // ErrorMsg.reportStatus(\"Server: \"+str);\n\n        if (str.indexOf(\"<h2\") > -1) {\n          int st = str.indexOf(\">\");\n          int en = str.indexOf(\"</h\");\n          if (st < 0 || en < 0)\n            ErrorMsg.reportError(\"Error\", \"Can not Understand Server Response: \" + str);\n          else {\n            if (str.indexOf(\"Success\") > -1) {\n              ErrorMsg.reportError(\"Info\", \"Patch Uploaded Successfully\");\n              return 1;\n            } else ErrorMsg.reportError(\"Error\", str.substring(st + 1, en));\n          }\n        }\n      }\n      in.close();\n    } catch (Exception e) {\n      ErrorMsg.reportStatus(e);\n    }\n\n    return 0;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1522, "initialization": ["DataOutputStream dataOutputStream = create(*)"], "initializationStart": [559], "initializationEnd": [597], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [650], "configurationEnd": [672], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 695, "focalAPIEnd": 707, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop/hadoop-1.1.2/src/test/system/java/org/apache/hadoop/mapred/TestTaskTrackerInfoSuccessfulFailedJobs.java", "rawCode": "  private void createInput(Path inDir, Configuration conf) throws IOException {\n    String input =\n        \"Hadoop is framework for data intensive distributed \"\n            + \"applications.\\n\"\n            + \"Hadoop enables applications to work with thousands of nodes.\";\n    FileSystem fs = inDir.getFileSystem(conf);\n    if (!fs.mkdirs(inDir)) {\n      throw new IOException(\"Failed to create the input directory:\" + inDir.toString());\n    }\n    fs.setPermission(inDir, new FsPermission(FsAction.ALL, FsAction.ALL, FsAction.ALL));\n    DataOutputStream file = fs.create(new Path(inDir, \"data.txt\"));\n    int i = 0;\n    while (i < 1000 * 3000) {\n      file.writeBytes(input);\n      i++;\n    }\n    file.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1523, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [683], "initializationEnd": [735], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new XAException(*)"], "tryExpressionStart": 369, "tryExpressionEnd": 373, "tryBlockStart": 369, "tryBlockEnd": 1043, "catchExpressionStart": 961, "catchExpressionEnd": 983, "catchBlockStart": 961, "catchBlockEnd": 1043, "exceptionHandlingCallStart": [997], "exceptionHandlingCallEnd": [1036], "configuration": ["dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.write(byte[],int,int)", "dataOutputStream.writeInt(int)", "dataOutputStream.write(byte[],int,int)", "dataOutputStream.flush()"], "configurationStart": [743, 773, 807, 848, 882, 923], "configurationEnd": [765, 799, 840, 874, 915, 934], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 942, "focalAPIEnd": 953, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jbosstm/quickstart/tree/master/ArjunaJTS/recovery/src/main/java/AbstractExampleXAResource.java", "rawCode": "  /**\n   * @param xid <description>\n   * @return <description>\n   * @exception javax.transaction.xa.XAException <description>\n   */\n  public synchronized int prepare(Xid xid) throws XAException {\n    System.out.println(\"******: \" + this.getClass().getName() + \": \" + \"PREPARE \" + xid);\n\n    File prepared = new File(DATA_DIR + this.getClass().getName() + \".xid_\");\n    try {\n      prepared.createNewFile();\n      final int formatId = xid.getFormatId();\n      final byte[] gtrid = xid.getGlobalTransactionId();\n      final int gtrid_length = gtrid.length;\n      final byte[] bqual = xid.getBranchQualifier();\n      final int bqual_length = bqual.length;\n\n      DataOutputStream fos = new DataOutputStream(new FileOutputStream(prepared));\n      fos.writeInt(formatId);\n      fos.writeInt(gtrid_length);\n      fos.write(gtrid, 0, gtrid_length);\n      fos.writeInt(bqual_length);\n      fos.write(bqual, 0, bqual_length);\n      fos.flush();\n      fos.close();\n    } catch (IOException e) {\n      throw new XAException(XAException.XAER_RMERR);\n    }\n    return XA_OK;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1524, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "UnknownHostException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 167, "tryExpressionEnd": 171, "tryBlockStart": 167, "tryBlockEnd": 346, "catchExpressionStart": 239, "catchExpressionEnd": 270, "catchBlockStart": 239, "catchBlockEnd": 346, "exceptionHandlingCallStart": [278], "exceptionHandlingCallEnd": [339], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 179, "focalAPIEnd": 189, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bj0rn/Gruppe34/tree/master/Code/src/no/ntnu/fp/net/co/SimpleConnection.java", "rawCode": "  public void close() throws IOException {\n    // clean up:\n    // close the output stream\n    // close the input stream\n    // close the socket\n\n    stop = true;\n    try {\n      os.close();\n      is.close();\n      mySocket.close();\n    } catch (UnknownHostException e) {\n      System.err.println(\"Trying to connect to unknown host: \" + e);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1525, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 296, "guardExpressionEnd": 312, "guardBlockStart": 296, "guardBlockEnd": 363, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 323, "focalAPIEnd": 334, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Flexibity/contiki/tree/master/tools/cooja/apps/serial_socket/java/SerialSocketServer.java", "rawCode": "  private void cleanupClient() {\n    try {\n      if (client != null) {\n        client.close();\n        client = null;\n      }\n    } catch (IOException e1) {\n    }\n    try {\n      if (in != null) {\n        in.close();\n        in = null;\n      }\n    } catch (IOException e) {\n    }\n    try {\n      if (out != null) {\n        out.close();\n        out = null;\n      }\n    } catch (IOException e) {\n    }\n\n    if (GUI.isVisualized()) {\n      SwingUtilities.invokeLater(\n          new Runnable() {\n            public void run() {\n              statusLabel.setText(\"Listening on port: \" + LISTEN_PORT);\n            }\n          });\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1526, "initialization": ["DataOutputStream dataOutputStream = prepareAppendKey(int)"], "initializationStart": [1006], "initializationEnd": [1028], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[],int,int)"], "configurationStart": [1078], "configurationEnd": [1107], "guardCondition": "bitwise", "guardType": "IF {", "guardExpressionStart": 608, "guardExpressionEnd": 677, "guardBlockStart": 608, "guardBlockEnd": 777, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1163, "focalAPIEnd": 1177, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["DataOutputStream.close()"], "finallyExpressionStart": 1369, "finallyExpressionEnd": 1377, "finallyBlockStart": 1369, "finallyBlockEnd": 1416, "cleanUpCallStart": [1389], "cleanUpCallEnd": [1405], "url": "https://github.com/wubs/485-Project/tree/master/pa6/hadoop/src/core/org/apache/hadoop/io/file/tfile/TFile.java", "rawCode": "    /**\n     * Adding a new key-value pair to TFile.\n     *\n     * @param key buffer for key.\n     * @param koff offset in key buffer.\n     * @param klen length of key.\n     * @param value buffer for value.\n     * @param voff offset in value buffer.\n     * @param vlen length of value.\n     * @throws IOException Upon IO errors.\n     *     <p>If an exception is thrown, the TFile will be in an inconsistent state. The only\n     *     legitimate call after that would be close\n     */\n    public void append(byte[] key, int koff, int klen, byte[] value, int voff, int vlen)\n        throws IOException {\n      if ((koff | klen | (koff + klen) | (key.length - (koff + klen))) < 0) {\n        throw new IndexOutOfBoundsException(\"Bad key buffer offset-length combination.\");\n      }\n\n      if ((voff | vlen | (voff + vlen) | (value.length - (voff + vlen))) < 0) {\n        throw new IndexOutOfBoundsException(\"Bad value buffer offset-length combination.\");\n      }\n\n      try {\n        DataOutputStream dosKey = prepareAppendKey(klen);\n        try {\n          ++errorCount;\n          dosKey.write(key, koff, klen);\n          --errorCount;\n        } finally {\n          dosKey.close();\n        }\n\n        DataOutputStream dosValue = prepareAppendValue(vlen);\n        try {\n          ++errorCount;\n          dosValue.write(value, voff, vlen);\n          --errorCount;\n        } finally {\n          dosValue.close();\n        }\n      } finally {\n        state = State.READY;\n      }\n    }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1527, "initialization": ["DataOutputStream dataOutputStream = create(*)"], "initializationStart": [401], "initializationEnd": [437], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [445], "configurationEnd": [467], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 475, "focalAPIEnd": 487, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop/hadoop-1.1.2/src/test/org/apache/hadoop/mapred/TestMiniMRClasspath.java", "rawCode": "  static void configureWordCount(\n      FileSystem fs,\n      String jobTracker,\n      JobConf conf,\n      String input,\n      int numMaps,\n      int numReduces,\n      Path inDir,\n      Path outDir)\n      throws IOException {\n    fs.delete(outDir, true);\n    if (!fs.mkdirs(inDir)) {\n      throw new IOException(\"Mkdirs failed to create \" + inDir.toString());\n    }\n    {\n      DataOutputStream file = fs.create(new Path(inDir, \"part-0\"));\n      file.writeBytes(input);\n      file.close();\n    }\n    FileSystem.setDefaultUri(conf, fs.getUri());\n    conf.set(\"mapred.job.tracker\", jobTracker);\n    conf.setJobName(\"wordcount\");\n    conf.setInputFormat(TextInputFormat.class);\n\n    // the keys are words (strings)\n    conf.setOutputKeyClass(Text.class);\n    // the values are counts (ints)\n    conf.setOutputValueClass(IntWritable.class);\n\n    conf.set(\"mapred.mapper.class\", \"testjar.ClassWordCount$MapClass\");\n    conf.set(\"mapred.combine.class\", \"testjar.ClassWordCount$Reduce\");\n    conf.set(\"mapred.reducer.class\", \"testjar.ClassWordCount$Reduce\");\n    FileInputFormat.setInputPaths(conf, inDir);\n    FileOutputFormat.setOutputPath(conf, outDir);\n    conf.setNumMapTasks(numMaps);\n    conf.setNumReduceTasks(numReduces);\n    // pass a job.jar already included in the hadoop build\n    conf.setJar(\"build/test/testjar/testjob.jar\");\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1528, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 296, "guardExpressionEnd": 312, "guardBlockStart": 296, "guardBlockEnd": 363, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 323, "focalAPIEnd": 334, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/retornaz/contiki-cc253x/tree/master/tools/cooja/apps/serial_socket/java/SerialSocketServer.java", "rawCode": "  private void cleanupClient() {\n    try {\n      if (client != null) {\n        client.close();\n        client = null;\n      }\n    } catch (IOException e1) {\n    }\n    try {\n      if (in != null) {\n        in.close();\n        in = null;\n      }\n    } catch (IOException e) {\n    }\n    try {\n      if (out != null) {\n        out.close();\n        out = null;\n      }\n    } catch (IOException e) {\n    }\n\n    if (GUI.isVisualized()) {\n      SwingUtilities.invokeLater(\n          new Runnable() {\n            public void run() {\n              statusLabel.setText(\"Listening on port: \" + LISTEN_PORT);\n            }\n          });\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1529, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(ByteArrayOutputStream)"], "initializationStart": [188], "initializationEnd": [212], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[],int,int)", "dataOutputStream.write(char)", "dataOutputStream.writeByte(char)", "dataOutputStream.writeBytes(String)"], "configurationStart": [231, 269, 392, 483], "configurationEnd": [261, 281, 408, 504], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 600, "focalAPIEnd": 609, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robovm/robovm/tree/master/tests/libcore/luni/src/test/java/libcore/java/io/OldAndroidDataOutputStreamTest.java", "rawCode": "  public void testDataOutputStream() throws Exception {\n    String str = \"AbCdEfGhIjKlMnOpQrStUvWxYz\";\n    ByteArrayOutputStream aa = new ByteArrayOutputStream();\n    DataOutputStream a = new DataOutputStream(aa);\n\n    try {\n      a.write(str.getBytes(), 0, 26);\n      a.write('A');\n\n      assertEquals(27, aa.size());\n      assertEquals(\"AbCdEfGhIjKlMnOpQrStUvWxYzA\", aa.toString());\n\n      a.writeByte('B');\n      assertEquals(\"AbCdEfGhIjKlMnOpQrStUvWxYzAB\", aa.toString());\n      a.writeBytes(\"BYTES\");\n      assertEquals(\"AbCdEfGhIjKlMnOpQrStUvWxYzABBYTES\", aa.toString());\n    } finally {\n      a.close();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1530, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [132], "initializationEnd": [216], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 88, "tryExpressionEnd": 92, "tryBlockStart": 88, "tryBlockEnd": 1368, "catchExpressionStart": 1276, "catchExpressionEnd": 1296, "catchBlockStart": 1276, "catchBlockEnd": 1368, "exceptionHandlingCallStart": [1304], "exceptionHandlingCallEnd": [1361], "configuration": ["dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeUTF(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.flush()"], "configurationStart": [246, 276, 356, 416, 522, 576, 689, 781, 840, 888, 973, 1060], "configurationEnd": [266, 300, 381, 466, 556, 595, 721, 816, 859, 913, 1000, 1070], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1078, "focalAPIEnd": 1088, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/conceptstailored/NCSU-GBS-Pipeline/tree/master/TASSEL_20121011/maizegenetics/src/net/maizegenetics/genome/GBS/deNovoContigs/ContigHaplotypesByTaxa.java", "rawCode": "  public void writeDistFile(File outFile, boolean binary) {\n    int hapsOutput = 0;\n    try {\n      DataOutputStream fw =\n          new DataOutputStream(new BufferedOutputStream(new FileOutputStream(outFile), 65536));\n      if (binary) {\n        fw.writeInt(taxaNum);\n        fw.writeInt(contigCount);\n        for (int t = 0; t < taxaNum; t++) {\n          fw.writeUTF(taxaNames[t]);\n        }\n      } else {\n        fw.writeBytes(taxaNum + \"\\t\" + contigCount + \"\\n\");\n        for (int t = 0; t < taxaNum; t++) {\n          fw.writeBytes(\"\\t\" + taxaNames[t]);\n        }\n        fw.writeBytes(\"\\n\");\n      }\n      for (int i = 0; i < contigIDs.length; i++) {\n        if (!binary) {\n          fw.writeBytes(contigIDs[i] + \"\");\n          for (int t = 0; t < taxaNum; t++) {\n            fw.writeBytes(\"\\t\" + hapDist[i][t]);\n          }\n          fw.writeBytes(\"\\n\");\n        } else {\n          fw.writeInt(contigIDs[i]);\n          for (int t = 0; t < taxaNum; t++) {\n            fw.writeByte(hapDist[i][t]);\n          }\n        }\n        hapsOutput++;\n      }\n      fw.flush();\n      fw.close();\n      System.out.println(\"Contig Haplotypes by Taxa distribution written to:\" + outFile.toString());\n      System.out.println(\"Number of contig haplotypes in file:\" + hapsOutput);\n    } catch (Exception e) {\n      System.out.println(\"Catch in writing output file e=\" + e);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1531, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 41, "tryExpressionEnd": 45, "tryBlockStart": 41, "tryBlockEnd": 336, "catchExpressionStart": 278, "catchExpressionEnd": 301, "catchBlockStart": 278, "catchBlockEnd": 336, "exceptionHandlingCallStart": [309], "exceptionHandlingCallEnd": [329], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 53, "guardExpressionEnd": 69, "guardBlockStart": 53, "guardBlockEnd": 120, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 80, "focalAPIEnd": 91, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joristork/robots/tree/master/sander/robotica/BounceDemo/BounceDemo-OnSPOT/src/org/sunspotworld/demo/utilities/RadioDataIOStream.java", "rawCode": "  public synchronized void close() {\n    try {\n      if (dos != null) {\n        dos.close();\n        dos = null;\n      }\n      if (dis != null) {\n        dis.close();\n        dis = null;\n      }\n      if (conn != null) {\n        conn.close();\n        conn = null;\n      }\n    } catch (IOException ex) {\n      ex.printStackTrace();\n    }\n    open = false;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1532, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 666, "guardExpressionEnd": 681, "guardBlockStart": 666, "guardBlockEnd": 693, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 682, "focalAPIEnd": 692, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bbockelm/DBS/tree/master/Servers/MS2/client/src/gov/fnal/ms/client/util/HttpUtil.java", "rawCode": "  public String postSecureUrl(String url, String data) throws Exception {\n    initSecureConnection();\n    HttpsURLConnection con = null;\n    BufferedReader in = null;\n    DataOutputStream out = null;\n    String toReturn = \"\";\n    // System.out.println(\"\\n\\n\\n*********************************************\\n\\ndata is \" + data);\n    try {\n      con = (HttpsURLConnection) (new URL(url)).openConnection();\n      con.setDoOutput(true);\n\n      out = new DataOutputStream(con.getOutputStream());\n      out.writeBytes(data);\n      out.flush();\n\n      in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n      toReturn = readUrl(in);\n    } finally {\n      if (in != null) in.close();\n      if (out != null) out.close();\n      if (con != null) con.disconnect();\n    }\n    return toReturn;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1533, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(OutputStream)"], "initializationStart": [183], "initializationEnd": [217], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new DataException(*,*,String)"], "tryExpressionStart": 223, "tryExpressionEnd": 227, "tryBlockStart": 223, "tryBlockEnd": 1138, "catchExpressionStart": 1026, "catchExpressionEnd": 1048, "catchBlockStart": 1026, "catchBlockEnd": 1138, "exceptionHandlingCallStart": [1062], "exceptionHandlingCallEnd": [1131], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1007, "focalAPIEnd": 1018, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.data/tree/master/plugins/org.eclipse.birt.data/src/org/eclipse/birt/data/engine/impl/ResultIterator2.java", "rawCode": "  private void doSaveResultClass(OutputStream outputStream, List<IBinding> requestColumnMap)\n      throws BirtException {\n    assert outputStream != null;\n\n    DataOutputStream dos = new DataOutputStream(outputStream);\n    try {\n      IOUtil.writeInt(outputStream, requestColumnMap.size());\n\n      for (int i = 0; i < requestColumnMap.size(); i++) {\n        IBinding binding = requestColumnMap.get(i);\n        IOUtil.writeInt(dos, i + 1);\n        IOUtil.writeString(dos, binding.getBindingName());\n        IOUtil.writeString(dos, null);\n        IOUtil.writeString(dos, null);\n        IOUtil.writeString(dos, String.class.getName());\n        IOUtil.writeString(dos, null);\n        IOUtil.writeBool(dos, false);\n        IOUtil.writeString(dos, null);\n        if (streamManager.getVersion() >= VersionManager.VERSION_2_5_2_0) {\n          IOUtil.writeInt(dos, -1);\n          IOUtil.writeString(dos, null);\n          IOUtil.writeBool(dos, false);\n          IOUtil.writeBool(dos, false);\n        }\n      }\n\n      dos.close();\n    } catch (IOException e) {\n      throw new DataException(ResourceConstants.RD_SAVE_ERROR, e, \"Result Class\");\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1534, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [326], "initializationEnd": [413], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.flush()"], "configurationStart": [472], "configurationEnd": [483], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 679, "focalAPIEnd": 690, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iBot/HAW_SS13_AI/tree/master/code/HES/lib/hibernate-release-4.0.1.Final/project/buildSrc/src/main/groovy/org/hibernate/build/gradle/inject/InjectionAction.java", "rawCode": "    protected void writeOutChanges() {\n      log.info(\"writing injection changes back [\" + classFileLocation.getAbsolutePath() + \"]\");\n      long timeStamp = classFileLocation.lastModified();\n      ClassFile classFile = ctClass.getClassFile();\n      classFile.compact();\n      try {\n        DataOutputStream out =\n            new DataOutputStream(new BufferedOutputStream(new FileOutputStream(classFileLocation)));\n        try {\n\n          classFile.write(out);\n          out.flush();\n          if (!classFileLocation.setLastModified(System.currentTimeMillis())) {\n            log.info(\"Unable to manually update class file timestamp\");\n          }\n        } finally {\n          out.close();\n          classFileLocation.setLastModified(timeStamp);\n        }\n      } catch (IOException e) {\n        throw new InjectionException(\"Unable to write out modified class file\", e);\n      }\n    }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1535, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(ByteArrayOutputStream)"], "initializationStart": [1165], "initializationEnd": [1188], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBoolean(boolean)", "dataOutputStream.writeByte(char)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeChar(char)", "dataOutputStream.writeChars(String)", "dataOutputStream.writeUTF(String)", "dataOutputStream.writeDouble(int)", "dataOutputStream.writeFloat(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeLong(int)", "dataOutputStream.writeShort(int)"], "configurationStart": [1206, 1234, 1258, 1285, 1309, 1336, 1363, 1387, 1410, 1431, 1453], "configurationEnd": [1226, 1250, 1277, 1301, 1328, 1355, 1379, 1402, 1423, 1445, 1468], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1492, "focalAPIEnd": 1501, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/libcore/java/io/OldAndroidDataInputStreamTest.java", "rawCode": "  public void testDataInputStream() throws Exception {\n    String str = \"AbCdEfGhIjKlM\\nOpQ\\rStUvWxYz\";\n    ByteArrayInputStream aa = new ByteArrayInputStream(str.getBytes());\n    ByteArrayInputStream ba = new ByteArrayInputStream(str.getBytes());\n    ByteArrayInputStream ca = new ByteArrayInputStream(str.getBytes());\n    ByteArrayInputStream da = new ByteArrayInputStream(str.getBytes());\n\n    DataInputStream a = new DataInputStream(aa);\n    try {\n      Assert.assertEquals(str, read(a));\n    } finally {\n      a.close();\n    }\n\n    DataInputStream b = new DataInputStream(ba);\n    try {\n      Assert.assertEquals(\"AbCdEfGhIj\", read(b, 10));\n    } finally {\n      b.close();\n    }\n\n    DataInputStream c = new DataInputStream(ca);\n    try {\n      Assert.assertEquals(\"bdfhjl\\np\\rtvxz\", skipRead(c));\n    } finally {\n      c.close();\n    }\n\n    DataInputStream d = new DataInputStream(da);\n    try {\n      assertEquals(\"AbCdEfGhIjKlM\", d.readLine());\n      assertEquals(\"OpQ\", d.readLine());\n      assertEquals(\"StUvWxYz\", d.readLine());\n    } finally {\n      d.close();\n    }\n\n    ByteArrayOutputStream e = new ByteArrayOutputStream();\n    DataOutputStream f = new DataOutputStream(e);\n    try {\n      f.writeBoolean(true);\n      f.writeByte('a');\n      f.writeBytes(\"BCD\");\n      f.writeChar('e');\n      f.writeChars(\"FGH\");\n      f.writeUTF(\"ijklm\");\n      f.writeDouble(1);\n      f.writeFloat(2);\n      f.writeInt(3);\n      f.writeLong(4);\n      f.writeShort(5);\n    } finally {\n      f.close();\n    }\n\n    ByteArrayInputStream ga = new ByteArrayInputStream(e.toByteArray());\n    DataInputStream g = new DataInputStream(ga);\n\n    try {\n      assertTrue(g.readBoolean());\n      assertEquals('a', g.readByte());\n      assertEquals(2, g.skipBytes(2));\n      assertEquals('D', g.readByte());\n      assertEquals('e', g.readChar());\n      assertEquals('F', g.readChar());\n      assertEquals('G', g.readChar());\n      assertEquals('H', g.readChar());\n      assertEquals(\"ijklm\", g.readUTF());\n      assertEquals(1, g.readDouble(), 0);\n      assertEquals(2f, g.readFloat(), 0f);\n      assertEquals(3, g.readInt());\n      assertEquals(4, g.readLong());\n      assertEquals(5, g.readShort());\n    } finally {\n      g.close();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1536, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [384], "initializationEnd": [438], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 503, "guardExpressionEnd": 519, "guardBlockStart": 503, "guardBlockEnd": 532, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 520, "focalAPIEnd": 531, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mariusaeriksen/cassandra/tree/master/src/java/org/apache/cassandra/db/commitlog/CommitLogHeader.java", "rawCode": "  static void writeCommitLogHeader(CommitLogHeader header, String headerFile) throws IOException {\n    DataOutputStream out = null;\n    try {\n      /*\n       * FileOutputStream doesn't sync on flush/close.\n       * As headers are \"optional\" now there is no reason to sync it.\n       * This provides nearly double the performance of BRAF, more under heavey load.\n       */\n      out = new DataOutputStream(new FileOutputStream(headerFile));\n      serializer.serialize(header, out);\n    } finally {\n      if (out != null) out.close();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1537, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [1220], "initializationEnd": [1268], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[])"], "configurationStart": [1866], "configurationEnd": [1890], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 2260, "focalAPIEnd": 2274, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Blakez/android_frameworks_base/tree/master/core/tests/coretests/src/android/app/DownloadManagerBaseTest.java", "rawCode": "  /**\n   * Helper to create a large file of random data on the SD card.\n   *\n   * @param filename (optional) The name of the file to create on the SD card; pass in null to use a\n   *     default temp filename.\n   * @param type The type of file to create\n   * @param subdirectory If not null, the subdirectory under the SD card where the file should go\n   * @return The File that was created\n   * @throws IOException if there was an error while creating the file.\n   */\n  protected File createFileOnSD(String filename, long fileSize, DataType type, String subdirectory)\n      throws IOException {\n\n    // Build up the file path and name\n    String sdPath = Environment.getExternalStorageDirectory().getPath();\n    StringBuilder fullPath = new StringBuilder(sdPath);\n    if (subdirectory != null) {\n      fullPath.append(File.separatorChar).append(subdirectory);\n    }\n\n    File file = null;\n    if (filename == null) {\n      file = File.createTempFile(\"DMTEST_\", null, new File(fullPath.toString()));\n    } else {\n      fullPath.append(File.separatorChar).append(filename);\n      file = new File(fullPath.toString());\n      file.createNewFile();\n    }\n\n    // Fill the file with random data\n    DataOutputStream output = new DataOutputStream(new FileOutputStream(file));\n    final int CHUNK_SIZE = 1000000; // copy random data in 1000000-char chunks\n    long remaining = fileSize;\n    int nextChunkSize = CHUNK_SIZE;\n    byte[] randomData = null;\n    Random rng = new LoggingRng();\n    byte[] chunkSizeData = generateData(nextChunkSize, type, rng);\n\n    try {\n      while (remaining > 0) {\n        if (remaining < CHUNK_SIZE) {\n          nextChunkSize = (int) remaining;\n          remaining = 0;\n          randomData = generateData(nextChunkSize, type, rng);\n        } else {\n          remaining -= CHUNK_SIZE;\n          randomData = chunkSizeData;\n        }\n        output.write(randomData);\n        Log.i(\n            TAG,\n            \"while creating \"\n                + fileSize\n                + \" file, \"\n                + \"remaining bytes to be written: \"\n                + remaining);\n      }\n    } catch (IOException e) {\n      Log.e(LOG_TAG, \"Error writing to file \" + file.getAbsolutePath());\n      file.delete();\n      throw e;\n    } finally {\n      output.close();\n    }\n    return file;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1538, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [200], "initializationEnd": [251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeInt(int)"], "configurationStart": [259], "configurationEnd": [280], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 288, "focalAPIEnd": 298, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kevinweil/elephant-bird/tree/master/core/src/test/java/com/twitter/elephantbird/mapreduce/io/TestProtobufWritable.java", "rawCode": "    public static void main(String[] args) throws IOException {\n      setUp();\n      int hashCode = referenceAbWritable.hashCode();\n      File tmpFile = new File(args[0]);\n      DataOutputStream os = new DataOutputStream(new FileOutputStream(tmpFile));\n      os.writeInt(hashCode);\n      os.close();\n      System.exit(0);\n    }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1539, "initialization": ["DataOutputStream dataOutputStream = outCreateCacheFile(JarXEntry,boolean)"], "initializationStart": [157], "initializationEnd": [192], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["warning(String)"], "tryExpressionStart": 118, "tryExpressionEnd": 122, "tryBlockStart": 118, "tryBlockEnd": 725, "catchExpressionStart": 630, "catchExpressionEnd": 654, "catchBlockStart": 630, "catchBlockEnd": 725, "exceptionHandlingCallStart": [662], "exceptionHandlingCallEnd": [718], "configuration": ["dataOutputStream.writeUTF(String)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeUTF(String)", "dataOutputStream.writeUTF(String)"], "configurationStart": [200, 234, 527, 566], "configurationEnd": [226, 264, 556, 591], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 607, "focalAPIEnd": 622, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aptana/Pydev/tree/master/plugins/org.python.pydev.jython/src_jython/org/python/core/CachedJarsPackageManager.java", "rawCode": "  private void writeCacheFile(\n      JarXEntry entry, String jarcanon, Hashtable zipPackages, boolean brandNew) {\n    try {\n      DataOutputStream ostream = outCreateCacheFile(entry, brandNew);\n      ostream.writeUTF(jarcanon);\n      ostream.writeLong(entry.mtime);\n      comment(\"rewriting cachefile for '\" + jarcanon + \"'\");\n\n      for (Enumeration e = zipPackages.keys(); e.hasMoreElements(); ) {\n        String packageName = (String) e.nextElement();\n        String classes = (String) zipPackages.get(packageName);\n        ostream.writeUTF(packageName);\n        ostream.writeUTF(classes);\n      }\n      ostream.close();\n    } catch (IOException ioe) {\n      warning(\"can't write cache file for '\" + jarcanon + \"'\");\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1540, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "UnknownHostException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 64, "tryExpressionEnd": 68, "tryBlockStart": 64, "tryBlockEnd": 243, "catchExpressionStart": 136, "catchExpressionEnd": 167, "catchBlockStart": 136, "catchBlockEnd": 243, "exceptionHandlingCallStart": [175], "exceptionHandlingCallEnd": [236], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 76, "focalAPIEnd": 86, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Raane/fellesprosjekt/tree/master/src/connection/Connection.java", "rawCode": "  public void close() throws IOException {\n    stop = true;\n    try {\n      os.close();\n      is.close();\n      mySocket.close();\n    } catch (UnknownHostException e) {\n      System.err.println(\"Trying to connect to unknown host: \" + e);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1541, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 1390, "guardExpressionEnd": 1406, "guardBlockStart": 1390, "guardBlockEnd": 1419, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1407, "focalAPIEnd": 1418, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/caadapter/tree/master/software/caadapter/src/java/gov/nih/nci/caadapter/hl7/v2v3/tools/CodeActivationOrDeactivation.java", "rawCode": "  private void copyBinaryFileWithDataStream(File file, String targetDirName) throws IOException {\n\n    String fileName = file.getName();\n    System.out.println(\"Copy file (binary) : \" + targetDirName + fileName);\n    DataInputStream distr = null;\n    FileInputStream fis = null;\n\n    FileOutputStream fos = null;\n    DataOutputStream dos2 = null;\n    try {\n      fis = new FileInputStream(file);\n      distr = new DataInputStream(fis);\n\n      fos = new FileOutputStream(targetDirName + fileName);\n      dos2 = new DataOutputStream(fos);\n\n      byte nn = 0;\n      boolean endSig = false;\n      byte[] bytes = new byte[fis.available()];\n      int n = 0;\n      while (true) {\n        int q = -1;\n        for (int i = 0; i < bytes.length; i++) {\n          try {\n\n            bytes[i] = distr.readByte();\n          } catch (EOFException ie) {\n            endSig = true;\n          }\n\n          if (endSig) break;\n          q = i;\n        }\n        if (q == (bytes.length - 1)) dos2.write(bytes);\n        else for (int i = 0; i < q; i++) dos2.writeByte(bytes[i]);\n\n        // dos2.writeByte(nn);\n        if (endSig) break;\n      }\n    } catch (IOException cse) {\n      throw new IOException(\"Binary File Input failure... (IOException) \" + cse.getMessage());\n    } catch (Exception ne) {\n      throw new IOException(\"Binary File Input failure... (Excep) \" + ne.getMessage());\n    } finally {\n      if (fis != null) fis.close();\n      if (distr != null) distr.close();\n      if (fos != null) fos.close();\n      if (dos2 != null) dos2.close();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1542, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(BufferedOutputStream)"], "initializationStart": [773], "initializationEnd": [798], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeLong(int)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeShort(int)", "dataOutputStream.writeChar(char)", "dataOutputStream.writeLong(long)"], "configurationStart": [958, 1019, 1115, 1271, 1424, 1470], "configurationEnd": [974, 1049, 1132, 1307, 1440, 1494], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1640, "focalAPIEnd": 1651, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/skrul/greasefire/tree/master/java/greasefire-scraper/src/com/skrul/greasefire/IndexWriter.java", "rawCode": "  public void serialize(OutputStream os) throws Exception {\n\n    Queue<Node> queue = new LinkedList<Node>();\n    queue.add(root);\n\n    List<Node> nodes = new ArrayList<Node>();\n\n    int pos = 0;\n    while (queue.size() > 0) {\n      Node node = queue.remove();\n      nodes.add(node);\n\n      node.pos = pos;\n\n      // eight bytes for id length\n      pos += 8;\n\n      // eight bytes per id\n      if (node.ids != null) {\n        pos += node.ids.size() * 8;\n      }\n\n      // two bytes for children length\n      pos += 2;\n\n      // 10 bytes for each child (2 for the char, 8 for the pointer)\n      pos += node.children.size() * 10;\n\n      queue.addAll(node.children.values());\n    }\n\n    BufferedOutputStream bos = new BufferedOutputStream(os, 4096);\n    DataOutputStream dos = new DataOutputStream(bos);\n\n    int bytes = 0;\n    for (Node node : nodes) {\n\n      // System.out.print(\"pos: \" + node.pos + \" (\" + bytes + \")\");\n\n      if (node.ids == null) {\n        dos.writeLong(0);\n        bytes += 8;\n      } else {\n        dos.writeLong(node.ids.size());\n        bytes += 8;\n        for (int id : node.ids) {\n          dos.writeLong(id);\n          bytes += 8;\n        }\n      }\n      // System.out.print(\" ids: \" + node.ids);\n\n      // System.out.print(\" children: \");\n      dos.writeShort(node.children.size());\n      bytes += 2;\n      for (char c : node.children.keySet()) {\n        Node child = node.children.get(c);\n        dos.writeChar(c);\n        bytes += 2;\n        dos.writeLong(child.pos);\n        bytes += 8;\n        // System.out.print(c + \" \" + child.pos + \" \");\n      }\n      // System.out.println(\"\");\n    }\n    bos.close();\n    dos.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1543, "initialization": ["DataOutputStream dataOutputStream = makeFileOutput(String)"], "initializationStart": [410], "initializationEnd": [439], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 496, "focalAPIEnd": 507, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/javassist/tree/master/src/main/javassist/CtClass.java", "rawCode": "  /**\n   * Writes a class file represented by this <code>CtClass</code> object on a local disk. Once this\n   * method is called, further modifications are not possible any more.\n   *\n   * @param directoryName it must end without a directory separator.\n   * @see #debugWriteFile(String)\n   */\n  public void writeFile(String directoryName) throws CannotCompileException, IOException {\n    DataOutputStream out = makeFileOutput(directoryName);\n    try {\n      toBytecode(out);\n    } finally {\n      out.close();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1544, "initialization": ["DataOutputStream dataOutputStream = create(*)"], "initializationStart": [2343], "initializationEnd": [2379], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [2387], "configurationEnd": [2413], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 2421, "focalAPIEnd": 2433, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dataOutputStream.writeBytes(String)", "dataOutputStream.close()"], "useStart": [2492, 2528], "useEnd": [2520, 2540], "hasFinally": 1, "cleanUpCall": ["MiniDFSCluster.shutdown()"], "finallyExpressionStart": 3173, "finallyExpressionEnd": 3181, "finallyBlockStart": 3173, "finallyBlockEnd": 3300, "cleanUpCallStart": [3216], "cleanUpCallEnd": [3230], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop_src/hadoop-2.0.5-alpha-src/hadoop-tools/hadoop-streaming/src/test/java/org/apache/hadoop/streaming/TestSymLink.java", "rawCode": "  @Test\n  public void testSymLink() throws Exception {\n    boolean mayExit = false;\n    MiniMRCluster mr = null;\n    MiniDFSCluster dfs = null;\n    try {\n      Configuration conf = new Configuration();\n      dfs = new MiniDFSCluster(conf, 1, true, null);\n      FileSystem fileSys = dfs.getFileSystem();\n      String namenode = fileSys.getUri().toString();\n      mr = new MiniMRCluster(1, namenode, 3);\n\n      List<String> args = new ArrayList<String>();\n      for (Map.Entry<String, String> entry : mr.createJobConf()) {\n        args.add(\"-jobconf\");\n        args.add(entry.getKey() + \"=\" + entry.getValue());\n      }\n\n      // During tests, the default Configuration will use a local mapred\n      // So don't specify -config or -cluster\n      String argv[] =\n          new String[] {\n            \"-input\",\n            INPUT_FILE,\n            \"-output\",\n            OUTPUT_DIR,\n            \"-mapper\",\n            map,\n            \"-reducer\",\n            reduce,\n            \"-jobconf\",\n            \"stream.tmpdir=\" + System.getProperty(\"test.build.data\", \"/tmp\"),\n            \"-jobconf\",\n            JobConf.MAPRED_MAP_TASK_JAVA_OPTS\n                + \"=\"\n                + \"-Dcontrib.name=\"\n                + System.getProperty(\"contrib.name\")\n                + \" \"\n                + \"-Dbuild.test=\"\n                + System.getProperty(\"build.test\")\n                + \" \"\n                + conf.get(\n                    JobConf.MAPRED_MAP_TASK_JAVA_OPTS, conf.get(JobConf.MAPRED_TASK_JAVA_OPTS, \"\")),\n            \"-jobconf\",\n            JobConf.MAPRED_REDUCE_TASK_JAVA_OPTS\n                + \"=\"\n                + \"-Dcontrib.name=\"\n                + System.getProperty(\"contrib.name\")\n                + \" \"\n                + \"-Dbuild.test=\"\n                + System.getProperty(\"build.test\")\n                + \" \"\n                + conf.get(\n                    JobConf.MAPRED_REDUCE_TASK_JAVA_OPTS,\n                    conf.get(JobConf.MAPRED_TASK_JAVA_OPTS, \"\")),\n            \"-cacheFile\",\n            fileSys.getUri() + CACHE_FILE + \"#testlink\",\n            \"-jobconf\",\n            \"mapred.jar=\" + TestStreaming.STREAMING_JAR,\n          };\n\n      for (String arg : argv) {\n        args.add(arg);\n      }\n      argv = args.toArray(new String[args.size()]);\n\n      fileSys.delete(new Path(OUTPUT_DIR), true);\n\n      DataOutputStream file = fileSys.create(new Path(INPUT_FILE));\n      file.writeBytes(mapString);\n      file.close();\n      file = fileSys.create(new Path(CACHE_FILE));\n      file.writeBytes(cacheString);\n      file.close();\n\n      job = new StreamJob(argv, mayExit);\n      job.go();\n\n      fileSys = dfs.getFileSystem();\n      String line = null;\n      Path[] fileList =\n          FileUtil.stat2Paths(\n              fileSys.listStatus(\n                  new Path(OUTPUT_DIR), new Utils.OutputFileUtils.OutputFilesFilter()));\n      for (int i = 0; i < fileList.length; i++) {\n        System.out.println(fileList[i].toString());\n        BufferedReader bread = new BufferedReader(new InputStreamReader(fileSys.open(fileList[i])));\n        line = bread.readLine();\n        System.out.println(line);\n      }\n      assertEquals(cacheString + \"\\t\", line);\n    } finally {\n      if (dfs != null) {\n        dfs.shutdown();\n      }\n      if (mr != null) {\n        mr.shutdown();\n      }\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1545, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[])"], "configurationStart": [336], "configurationEnd": [367], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 373, "focalAPIEnd": 383, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arjunroy/cinder_dalvik/tree/master/libcore/luni/src/test/java/tests/api/java/io/DataInputStreamTest.java", "rawCode": "  /** @tests java.io.DataInputStream#read(byte[]) */\n  @TestTargetNew(\n    level = TestLevel.COMPLETE,\n    method = \"read\",\n    args = {byte[].class}\n  )\n  public void test_read$B() throws IOException {\n    byte rbytes[] = new byte[testLength - 5];\n    Support_ASimpleInputStream sis = new Support_ASimpleInputStream();\n    int r;\n\n    os.write(fileString.getBytes());\n    os.close();\n    openDataInputStream();\n\n    r = dis.read(rbytes);\n    assertEquals(\"Test 1: Incorrect number of bytes read;\", testLength - 5, r);\n    assertTrue(\n        \"Test 2: Incorrect data written or read.\",\n        new String(rbytes).equals(fileString.substring(0, testLength - 5)));\n\n    r = dis.read(rbytes);\n    assertEquals(\"Test 3: Incorrect number of bytes read;\", 5, r);\n    assertTrue(\n        \"Test 4: Incorrect data written or read.\",\n        new String(rbytes, 0, 5).equals(fileString.substring(testLength - 5)));\n\n    dis.close();\n    sis.throwExceptionOnNextUse = true;\n    dis = new DataInputStream(sis);\n    try {\n      dis.read(rbytes);\n      fail(\"Test 5: IOException expected.\");\n    } catch (IOException e) {\n      // Expected.\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1546, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [411], "initializationEnd": [524], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeUTF(String)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.flush()"], "configurationStart": [646, 677, 714, 787, 965, 1014, 1099, 1154], "configurationEnd": [669, 706, 735, 814, 994, 1043, 1128, 1165], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1173, "focalAPIEnd": 1184, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/conceptstailored/NCSU-GBS-Pipeline/tree/master/TASSEL_20121011/maizegenetics/src/net/maizegenetics/gbs/pav/PAVUtils.java", "rawCode": "  private void writeSubTBTByList(String inputTBTFileS, String outputTBTFileS, boolean[] ifOutput) {\n    int outTagNum = 0;\n    for (int i = 0; i < ifOutput.length; i++) {\n      if (ifOutput[i]) outTagNum++;\n    }\n    try {\n      DataInputStream dis =\n          new DataInputStream(\n              new BufferedInputStream(new FileInputStream(inputTBTFileS), 65536 * 1024));\n      DataOutputStream dos =\n          new DataOutputStream(\n              new BufferedOutputStream(new FileOutputStream(outputTBTFileS), 65536 * 1024));\n      int inTagNum = dis.readInt();\n      int tagLengthInLong = dis.readInt();\n      int taxaNum = dis.readInt();\n      dos.writeInt(outTagNum);\n      dos.writeInt(tagLengthInLong);\n      dos.writeInt(taxaNum);\n      for (int i = 0; i < taxaNum; i++) {\n        dos.writeUTF(dis.readUTF());\n      }\n      for (int i = 0; i < inTagNum; i++) {\n        if (!ifOutput[i]) continue;\n        for (int j = 0; j < tagLengthInLong; j++) {\n          dos.writeLong(dis.readLong());\n        }\n        dos.writeByte(dis.readByte());\n        for (int j = 0; j < taxaNum; j++) {\n          dos.writeByte(dis.readByte());\n        }\n      }\n      dos.flush();\n      dos.close();\n      dis.close();\n    } catch (Exception e) {\n\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1547, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 35, "tryExpressionEnd": 39, "tryBlockStart": 35, "tryBlockEnd": 160, "catchExpressionStart": 102, "catchExpressionEnd": 125, "catchBlockStart": 102, "catchBlockEnd": 160, "exceptionHandlingCallStart": [133], "exceptionHandlingCallEnd": [153], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 74, "focalAPIEnd": 94, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/clubcapra/Viki/tree/master/src/main/java/ca/etsmtl/capra/digitizer/implementations/SerialDigitizerServiceAbstract.java", "rawCode": "  private void disconnect() {\n\n    try {\n      inputStream.close();\n      outputStream.close();\n    } catch (IOException e1) {\n      e1.printStackTrace();\n    }\n\n    try {\n      Thread.sleep(100);\n    } catch (InterruptedException e1) {\n      e1.printStackTrace();\n    }\n\n    if (portOverriden) portDealer.requestSpecificDisconnect(serialPort.getName());\n    else {\n      try {\n        portDealer.requestDisconnect(this);\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1548, "initialization": ["DataOutputStream dataOutputStream = Writer.prepareAppendKey(int)"], "initializationStart": [376], "initializationEnd": [407], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[])"], "configurationStart": [473], "configurationEnd": [503], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 511, "focalAPIEnd": 522, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dataOutputStream.write(byte[])", "dataOutputStream.close()"], "useStart": [625, 665], "useEnd": [657, 676], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop_src/hadoop-2.0.5-alpha-src/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/io/file/tfile/TestTFile.java", "rawCode": "  private int writePrepWithKnownLength(Writer writer, int start, int n) throws IOException {\n    // get the length of the key\n    String key = String.format(localFormatter, start);\n    int keyLen = key.getBytes().length;\n    String value = \"value\" + key;\n    int valueLen = value.getBytes().length;\n    for (int i = start; i < (start + n); i++) {\n      DataOutputStream out = writer.prepareAppendKey(keyLen);\n      String localKey = String.format(localFormatter, i);\n      out.write(localKey.getBytes());\n      out.close();\n      out = writer.prepareAppendValue(valueLen);\n      String localValue = \"value\" + localKey;\n      out.write(localValue.getBytes());\n      out.close();\n    }\n    return (start + n);\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1549, "initialization": ["DataOutputStream dataOutputStream = create(*)"], "initializationStart": [440], "initializationEnd": [478], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [486], "configurationEnd": [508], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 516, "focalAPIEnd": 528, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/Hadoop-mdfs/tree/master/hadoop-1.2.1/src/test/org/apache/hadoop/mapred/TestMiniMRWithDFS.java", "rawCode": "  public static TestResult launchWordCount(\n      JobConf conf, Path inDir, Path outDir, String input, int numMaps, int numReduces)\n      throws IOException {\n    FileSystem inFs = inDir.getFileSystem(conf);\n    FileSystem outFs = outDir.getFileSystem(conf);\n    outFs.delete(outDir, true);\n    if (!inFs.mkdirs(inDir)) {\n      throw new IOException(\"Mkdirs failed to create \" + inDir.toString());\n    }\n    {\n      DataOutputStream file = inFs.create(new Path(inDir, \"part-0\"));\n      file.writeBytes(input);\n      file.close();\n    }\n    conf.setJobName(\"wordcount\");\n    conf.setInputFormat(TextInputFormat.class);\n\n    // the keys are words (strings)\n    conf.setOutputKeyClass(Text.class);\n    // the values are counts (ints)\n    conf.setOutputValueClass(IntWritable.class);\n\n    conf.setMapperClass(WordCount.MapClass.class);\n    conf.setCombinerClass(WordCount.Reduce.class);\n    conf.setReducerClass(WordCount.Reduce.class);\n    FileInputFormat.setInputPaths(conf, inDir);\n    FileOutputFormat.setOutputPath(conf, outDir);\n    conf.setNumMapTasks(numMaps);\n    conf.setNumReduceTasks(numReduces);\n    RunningJob job = JobClient.runJob(conf);\n    return new TestResult(job, readOutput(outDir, conf));\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1550, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [478], "initializationEnd": [552], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getMessage()", "println(String)"], "tryExpressionStart": 795, "tryExpressionEnd": 799, "tryBlockStart": 795, "tryBlockEnd": 948, "catchExpressionStart": 830, "catchExpressionEnd": 852, "catchBlockStart": 830, "catchBlockEnd": 948, "exceptionHandlingCallStart": [924, 862], "exceptionHandlingCallEnd": [938, 939], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 809, "focalAPIEnd": 820, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Nantes1900/Nantes-1900/tree/master/src/fr/nantes1900/utils/FileTools.java", "rawCode": "  /**\n   * Saves or update new properties in the given file. If the file doesn't exists, a new one is\n   * created.\n   *\n   * @param file The file to SAVE data in.\n   * @param prop Data to SAVE.\n   * @return true - Data have been correctly saved.\\n false - A problem has occurred during the\n   *     saving process.\n   */\n  public static boolean saveProperties(final File file, final Properties prop) {\n    boolean saveOk = true;\n    DataOutputStream dos;\n    try {\n      dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)));\n      try {\n        prop.store(dos, null); // 2nd parameter allows to store comments\n      } catch (IOException e) {\n        saveOk = false;\n        System.err.println(\"IO exception during storage process: \" + e.getMessage());\n      }\n      try {\n        dos.close();\n      } catch (IOException e) {\n        System.err.println(\"IO exeption while closing the stream: \" + e.getMessage());\n      }\n    } catch (FileNotFoundException e1) {\n      saveOk = false;\n      System.err.println(\"File wasn't found: \" + e1.getMessage());\n    }\n\n    return saveOk;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1551, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [870], "initializationEnd": [920], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 534, "tryExpressionEnd": 538, "tryBlockStart": 534, "tryBlockEnd": 1567, "catchExpressionStart": 1328, "catchExpressionEnd": 1348, "catchBlockStart": 1328, "catchBlockEnd": 1474, "exceptionHandlingCallStart": [1358], "exceptionHandlingCallEnd": [1377], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.flush()"], "configurationStart": [928, 969], "configurationEnd": [961, 983], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 991, "focalAPIEnd": 1005, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nettapper/GameCenter/tree/master/GameCenterClient/src/client/ClientControl.java", "rawCode": "  /**\n   * Connects to server and sends the json string 'outputData'\n   *\n   * @param path The path connecting to\n   * @param gsonClientPack The json formated string to be sent to the server\n   * @return String The data from the server\n   */\n  public static String connect(String path, String gsonClientPack) {\n\n    System.out.println(\"Client attempting a connection to : \" + ADDRESS + path); // Debugging\n\n    HttpURLConnection connection;\n    URL link;\n    InputStream input;\n    String data = \"\";\n    DataOutputStream output;\n\n    try {\n      link = new URL(ADDRESS + path);\n      connection = (HttpURLConnection) link.openConnection();\n      connection.setAllowUserInteraction(true);\n      connection.setRequestMethod(\"POST\");\n      connection.setDoOutput(true);\n      connection.setDoInput(true);\n      connection.setInstanceFollowRedirects(false);\n\n      output = new DataOutputStream(connection.getOutputStream());\n      output.writeBytes(gsonClientPack);\n      output.flush();\n      output.close();\n\n      try { // Try to read the data from server\n        input = connection.getInputStream();\n        while (input.available() <= 0) ; // no data from server, waiting...\n        while (input.available() > 0) {\n          int number = input.read();\n          data += (char) number;\n        }\n        input.close();\n      } catch (Exception e) {\n        e.printStackTrace();\n        data = gsonClientPack; // in the case of an exception, return the original pack\n      }\n\n      connection.disconnect();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    // DEBUGGING //\n\n    System.out.println(\"Client succesfully connected to : \" + ADDRESS + path); // Debugging\n    System.out.println(\"Data To Server: \" + gsonClientPack);\n    System.out.println(\"Data From Server: \" + data);\n    System.out.println(\"---------------------------------------\");\n\n    // END //\n\n    return data;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1552, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [116], "configurationEnd": [145], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 151, "focalAPIEnd": 164, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/distributed/tree/master/Fast_Copy_HDFS/src/test/org/apache/hadoop/hdfs/TestDFSRename.java", "rawCode": "  static void createFile(FileSystem fs, Path f) throws IOException {\n    DataOutputStream a_out = fs.create(f);\n    a_out.writeBytes(\"something\");\n    a_out.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1553, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 59, "focalAPIEnd": 88, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dimalabs/stratosphere-iterations/tree/master/pact/pact-common/src/main/java/eu/stratosphere/pact/common/io/BinaryOutputFormat.java", "rawCode": "  @Override\n  public void close() throws IOException {\n    this.dataOutputStream.close();\n    super.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1554, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [99], "initializationEnd": [154], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 271, "focalAPIEnd": 282, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kevinweil/elephant-bird/tree/master/core/src/test/java/com/twitter/elephantbird/mapreduce/io/TestTypedProtobufWritable.java", "rawCode": "  @Test\n  public void testMessageReadWriteEmpty() throws IOException {\n\n    DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"test3.txt\"));\n    TypedProtobufWritable<AddressBook> empty = new TypedProtobufWritable<AddressBook>();\n    empty.write(dos);\n    dos.close();\n\n    DataInputStream dis = new DataInputStream(new FileInputStream(\"test3.txt\"));\n    TypedProtobufWritable<Message> after = new TypedProtobufWritable<Message>();\n    after.readFields(dis);\n    dis.close();\n\n    AddressBook ab2 = (AddressBook) after.get();\n    assertNull(ab2);\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1555, "initialization": ["DataOutputStream dataOutputStream = create(*)"], "initializationStart": [443], "initializationEnd": [483], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [489], "configurationEnd": [519], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 525, "focalAPIEnd": 537, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bryanjimenez/empanada/tree/master/hadoop/hadoop-1.2.1/src/contrib/fairscheduler/src/test/org/apache/hadoop/mapred/TestFairSchedulerPoolNames.java", "rawCode": "  private void submitJob(String pool) throws IOException {\n    JobConf conf = new JobConf();\n    final Path inDir = new Path(\"/tmp/testing/wc/input\");\n    final Path outDir = new Path(\"/tmp/testing/wc/output\");\n    FileSystem fs = FileSystem.get(URI.create(namenode), conf);\n    fs.delete(outDir, true);\n    if (!fs.mkdirs(inDir)) {\n      throw new IOException(\"Mkdirs failed to create \" + inDir.toString());\n    }\n    DataOutputStream file = fs.create(new Path(inDir, \"part-00000\"));\n    file.writeBytes(\"Sample text\");\n    file.close();\n\n    FileSystem.setDefaultUri(conf, namenode);\n    conf.set(\"mapred.job.tracker\", \"localhost:\" + miniMRCluster.getJobTrackerPort());\n    conf.setJobName(\"wordcount\");\n    conf.setInputFormat(TextInputFormat.class);\n\n    // the keys are words (strings)\n    conf.setOutputKeyClass(Text.class);\n    // the values are counts (ints)\n    conf.setOutputValueClass(IntWritable.class);\n\n    conf.setMapperClass(WordCount.MapClass.class);\n    conf.setCombinerClass(WordCount.Reduce.class);\n    conf.setReducerClass(WordCount.Reduce.class);\n\n    FileInputFormat.setInputPaths(conf, inDir);\n    FileOutputFormat.setOutputPath(conf, outDir);\n    conf.setNumMapTasks(1);\n    conf.setNumReduceTasks(0);\n\n    if (pool != null) {\n      conf.set(POOL_PROPERTY, pool);\n    }\n    JobClient.runJob(conf);\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1556, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[],int,int)"], "configurationStart": [67], "configurationEnd": [117], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 123, "focalAPIEnd": 133, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wsot/platform_libcore/tree/master/luni/src/test/java/libcore/java/io/OldDataOutputStreamTest.java", "rawCode": "  public void test_write$BII() throws IOException {\n    int r;\n    os.write(testString.getBytes(), 5, testLength - 7);\n    os.close();\n    openDataInputStream();\n    byte[] rbuf = new byte[testLength];\n    r = dis.read(rbuf, 0, testLength);\n    assertEquals(\"Test 1: Incorrect number of bytes read;\", testLength - 7, r);\n    dis.close();\n    assertTrue(\n        \"Test 2: Incorrect bytes written or read.\",\n        new String(rbuf, 0, r).equals(testString.substring(5, testLength - 2)));\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1557, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 640, "tryExpressionEnd": 644, "tryBlockStart": 640, "tryBlockEnd": 775, "catchExpressionStart": 1178, "catchExpressionEnd": 1200, "catchBlockStart": 1178, "catchBlockEnd": 1226, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBoolean(boolean)", "dataOutputStream.writeBoolean(boolean)"], "configurationStart": [579, 652], "configurationEnd": [600, 674], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 816, "focalAPIEnd": 826, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benjaminvm/vm/tree/master/libcore/luni/src/test/java/tests/api/java/io/DataInputOutputStreamTest.java", "rawCode": "  /**\n   * @tests java.io.DataInputStream#readBoolean()\n   * @tests java.io.DataOutputStream#writeBoolean(boolean)\n   */\n  @TestTargets({\n    @TestTargetNew(\n      level = TestLevel.SUFFICIENT,\n      notes = \"Tests against golden file missing.\",\n      method = \"writeBoolean\",\n      args = {boolean.class}\n    ),\n    @TestTargetNew(\n      level = TestLevel.SUFFICIENT,\n      notes = \"Tests against golden file missing.\",\n      method = \"readBoolean\",\n      args = {},\n      clazz = DataInputStream.class\n    )\n  })\n  public void test_read_writeBoolean() throws IOException {\n    os.writeBoolean(true);\n    sos.setThrowsException(true);\n    try {\n      os.writeBoolean(false);\n      fail(\"Test 1: IOException expected.\");\n    } catch (IOException e) {\n      // Expected.\n    }\n    sos.setThrowsException(false);\n\n    os.close();\n    openDataInputStream();\n    assertTrue(\"Test 2: Incorrect boolean written or read.\", dis.readBoolean());\n\n    try {\n      dis.readBoolean();\n      fail(\"Test 3: EOFException expected.\");\n    } catch (EOFException e) {\n      // Expected.\n    }\n\n    dis.close();\n    try {\n      dis.readBoolean();\n      fail(\"Test 4: IOException expected.\");\n    } catch (IOException e) {\n      // Expected.\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1558, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(FileOutputStream)"], "initializationStart": [175], "initializationEnd": [200], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 47, "tryExpressionEnd": 51, "tryBlockStart": 47, "tryBlockEnd": 588, "catchExpressionStart": 532, "catchExpressionEnd": 554, "catchBlockStart": 532, "catchBlockEnd": 588, "exceptionHandlingCallStart": [562], "exceptionHandlingCallEnd": [581], "configuration": ["dataOutputStream.writeUTF(String)", "dataOutputStream.writeInt(int)"], "configurationStart": [440, 474], "configurationEnd": [464, 497], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 513, "focalAPIEnd": 524, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ferquies/2dam/tree/master/AD/ej12.java", "rawCode": "  public static void main(String args[]) {\n    try {\n      File f = new File(\"f_ej12.dat\");\n      FileOutputStream fos = new FileOutputStream(f);\n      DataOutputStream dos = new DataOutputStream(fos);\n      String nombres[] = {\n        \"Ana\", \"Maria\", \"Pepe\", \"Manuel\", \"Elisa\", \"Juan\", \"Pedro\", \"Angel\", \"Emilio\"\n      };\n      int edades[] = {13, 16, 21, 32, 12, 15, 22, 14, 18};\n\n      for (int i = 0; i < edades.length; i++) {\n        dos.writeUTF(nombres[i]);\n        dos.writeInt(edades[i]);\n      }\n      dos.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1559, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [97], "initializationEnd": [177], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeDouble(double)", "dataOutputStream.writeUTF(String)", "dataOutputStream.writeDouble(double)", "dataOutputStream.writeUTF(String)"], "configurationStart": [183, 213, 246, 276], "configurationEnd": [207, 240, 270, 308], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 314, "focalAPIEnd": 325, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/quchunguang/test/tree/master/testjava/TIJ4-code/io/StoringAndRecoveringData.java", "rawCode": "  public static void main(String[] args) throws IOException {\n    DataOutputStream out =\n        new DataOutputStream(new BufferedOutputStream(new FileOutputStream(\"Data.txt\")));\n    out.writeDouble(3.14159);\n    out.writeUTF(\"That was pi\");\n    out.writeDouble(1.41413);\n    out.writeUTF(\"Square root of 2\");\n    out.close();\n    DataInputStream in =\n        new DataInputStream(new BufferedInputStream(new FileInputStream(\"Data.txt\")));\n    System.out.println(in.readDouble());\n    // Only readUTF() will recover the\n    // Java-UTF String properly:\n    System.out.println(in.readUTF());\n    System.out.println(in.readDouble());\n    System.out.println(in.readUTF());\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1560, "initialization": ["DataOutputStream dataOutputStream = NXTConnection.openDataOutputStream()"], "initializationStart": [1154], "initializationEnd": [1180], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["drawString(String,int,int)", "refresh()"], "tryExpressionStart": 1658, "tryExpressionEnd": 1662, "tryBlockStart": 1658, "tryBlockEnd": 1869, "catchExpressionStart": 1770, "catchExpressionEnd": 1794, "catchBlockStart": 1770, "catchBlockEnd": 1869, "exceptionHandlingCallStart": [1802, 1849], "exceptionHandlingCallEnd": [1841, 1862], "configuration": ["dataOutputStream.writeInt(int)", "dataOutputStream.flush()"], "configurationStart": [1321, 1354], "configurationEnd": [1344, 1365], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1732, "focalAPIEnd": 1743, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Zab-38/NXT-Lejos/tree/master/LejosSamples/src/org/lejos/sample/nxtconnecttest/NXTConnectTest.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    String name = \"NXT\";\n    String[] connectionStrings = {\"Bluetooth\", \"RS485\"};\n    TextMenu connectionMenu = new TextMenu(connectionStrings, 1, \"Connection\");\n    String[] modeStrings = {\"Packet\", \"Raw\"};\n    TextMenu modeMenu = new TextMenu(modeStrings, 1, \"Mode\");\n    NXTCommConnector[] connectors = {Bluetooth.getConnector(), RS485.getConnector()};\n    int[] modes = {NXTConnection.PACKET, NXTConnection.RAW};\n\n    int connectionType = connectionMenu.select();\n    LCD.clear();\n    int mode = modeMenu.select();\n\n    LCD.clear();\n    LCD.drawString(\"Name: \" + name, 0, 0);\n    LCD.drawString(\"Type: \" + connectionStrings[connectionType], 0, 1);\n    LCD.drawString(\"Mode: \" + modeStrings[mode], 0, 2);\n    LCD.drawString(\"Connecting...\", 0, 3);\n\n    NXTConnection con = connectors[connectionType].connect(name, modes[mode]);\n\n    if (con == null) {\n      LCD.drawString(\"Connect fail\", 0, 5);\n      Thread.sleep(2000);\n      System.exit(1);\n    }\n\n    LCD.drawString(\"Connected \", 0, 3);\n    LCD.refresh();\n\n    DataInputStream dis = con.openDataInputStream();\n    DataOutputStream dos = con.openDataOutputStream();\n\n    for (int i = 0; i < 100; i++) {\n      try {\n        LCD.drawString(\"write: \", 0, 6);\n        LCD.drawInt(i * 30000, 8, 6, 6);\n        dos.writeInt(i * 30000);\n        dos.flush();\n      } catch (IOException ioe) {\n        LCD.drawString(\"Write Exception\", 0, 5);\n      }\n\n      try {\n        LCD.drawString(\"Read: \", 0, 7);\n        LCD.drawInt(dis.readInt(), 8, 6, 7);\n      } catch (IOException ioe) {\n        LCD.drawString(\"Read Exception \", 0, 5);\n      }\n    }\n\n    try {\n      LCD.drawString(\"Closing... \", 0, 3);\n      dis.close();\n      dos.close();\n      con.close();\n    } catch (IOException ioe) {\n      LCD.drawString(\"Close Exception\", 0, 5);\n      LCD.refresh();\n    }\n    LCD.drawString(\"Finished \", 0, 3);\n    Thread.sleep(2000);\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1561, "initialization": ["DataOutputStream dataOutputStream = getOutput(String)"], "initializationStart": [488], "initializationEnd": [528], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 642, "focalAPIEnd": 653, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/godares79/CS848-Project/tree/master/apache-cassandra-1.1.6-src/test/unit/org/apache/cassandra/utils/SerializationsTest.java", "rawCode": "  private void testLegacyBloomFilterWrite() throws IOException {\n    LegacyBloomFilter a = LegacyBloomFilter.getFilter(1000000, 1000);\n    LegacyBloomFilter b = LegacyBloomFilter.getFilter(1000000, 0.0001);\n    for (int i = 0; i < 100; i++) {\n      ByteBuffer key =\n          StorageService.getPartitioner()\n              .getTokenFactory()\n              .toByteArray(StorageService.getPartitioner().getRandomToken());\n      a.add(key);\n      b.add(key);\n    }\n    DataOutputStream out = getOutput(\"utils.LegacyBloomFilter.bin\");\n    LegacyBloomFilter.serializer().serialize(a, out);\n    LegacyBloomFilter.serializer().serialize(b, out);\n    out.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1562, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(ByteArrayOutputStream)"], "initializationStart": [368], "initializationEnd": [394], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 529, "focalAPIEnd": 540, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/KommuSoft/ParallelHyFlex/tree/master/ParallelHyFlex/test/parallelhyflex/problems/fdcsp/problem/MutableFiniteIntegerDomainTest.java", "rawCode": "  /** Test of readAndGenerate method, of class MutableFiniteIntegerDomain. */\n  @Test\n  public void testReadAndGenerate() throws Exception {\n    MutableFiniteIntegerDomain fid3 = new MutableFiniteIntegerDomain();\n    for (int i = 0; i < TestParameters.LOOP_PARAMETER; i++) {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      DataOutputStream dos = new DataOutputStream(baos);\n      MutableFiniteIntegerDomain fid1 = new MutableFiniteIntegerDomain(), fid2;\n      fillRandom(fid1);\n      fid1.write(dos);\n      dos.close();\n      baos.close();\n      ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n      DataInputStream dis = new DataInputStream(bais);\n      fid2 = fid3.readAndGenerate(dis);\n      dis.close();\n      bais.close();\n      Assert.assertEquals(fid1, fid2);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1563, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [423], "initializationEnd": [505], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeInt(int)"], "configurationStart": [581, 652, 1419, 1453, 2761, 2810, 3534, 3581], "configurationEnd": [597, 678, 1445, 1469, 2800, 2832, 3573, 3597], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 4643, "focalAPIEnd": 4654, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/marytts/marytts/tree/master/marytts-builder/src/main/java/marytts/tools/voiceimport/PhoneUnitfileWriter.java", "rawCode": "  public boolean compute() throws Exception {\n\n    System.out.println(\"Unitfile writer started.\");\n    System.out.println(\"Verifying that unit feature and label files are perfectly aligned...\");\n\n    if (!aligner.compute())\n      throw new IllegalStateException(\n          \"Database is NOT perfectly aligned. Cannot create unit file.\");\n    System.out.println(\"OK, alignment verified.\");\n    DataOutputStream out =\n        new DataOutputStream(new BufferedOutputStream(new FileOutputStream(unitFileName)));\n    long posNumUnits = new MaryHeader(MaryHeader.UNITS).writeTo(out);\n    out.writeInt(-1); // number of units; needs to be corrected later.\n    out.writeInt(samplingRate);\n\n    // Loop over all utterances\n    int index = 0; // the unique index number of units in the unit file\n    long globalStart = 0l; // time, given as sample position with samplingRate\n    long localStart = 0l; // time, given as sample position with samplingRate\n    long totalNbrSamples = 0l;\n    long localNbrSamples = 0l;\n    long localNbrSamplesFromPM = 0l;\n    ESTTrackReader pmFile = null;\n    for (int i = 0; i < bnl.getLength(); i++) {\n      percent = 100 * i / bnl.getLength();\n      /* Open the relevant pitchmark file */\n      pmFile =\n          new ESTTrackReader(\n              db.getProp(DatabaseLayout.PMDIR) + bnl.getName(i) + db.getProp(DatabaseLayout.PMEXT));\n      // Output the utterance start marker: \"null\" unit\n      out.writeLong(globalStart);\n      out.writeInt(-1);\n      index++;\n      // Open the label file and reset the local time pointer\n      BufferedReader labels =\n          new BufferedReader(\n              new InputStreamReader(\n                  new FileInputStream(new File(unitlabelDir, bnl.getName(i) + unitlabelExt)),\n                  \"UTF-8\"));\n      String line;\n      localNbrSamples = 0l;\n      localStart = 0l;\n      // Skip label file header\n      while ((line = labels.readLine()) != null) {\n        if (line.startsWith(\"#\")) break; // line starting with \"#\" marks end of header\n      }\n      // Now read the actual units\n      System.out.println(\"Start unit listing in file \" + bnl.getName(i));\n      while ((line = labels.readLine()) != null) {\n        // Get the line and the double value in first position\n        line = line.trim();\n        if (line.equals(\"\")) continue; // ignore empty lines\n        String[] parts = line.split(\"\\\\s\", 3);\n        String unit_name = parts[2];\n        double endTime = Double.valueOf(parts[0]).doubleValue();\n        /* Relocate the label-specific end time on the nearest pitchmark */\n        endTime = (double) (pmFile.getClosestTime(endTime));\n        long end = (long) (endTime * (double) (samplingRate));\n        // Output the unit\n        int duration = (int) (end - localStart);\n        out.writeLong(globalStart + localStart);\n        out.writeInt(duration);\n        // System.out.println( \"Unit [\" + index + \"] starts at [\" + localStart + \"] and has duration\n        // [\" + duration + \"].\"\n        // );\n        System.out.println(\n            \"Unit [\"\n                + index\n                + \"] <\"\n                + unit_name\n                + \"> starts at [\"\n                + (double) localStart / (samplingRate)\n                + \"] and has duration [\"\n                + (double) duration / (samplingRate)\n                + \"].\");\n        // Update various pointers\n        localStart = end;\n        index++;\n        localNbrSamples += duration;\n        totalNbrSamples += duration;\n      }\n      // Output the utterance end marker: \"null\" unit\n      out.writeLong(globalStart + localStart);\n      out.writeInt(-1);\n      index++;\n      /*\n       * Locate the global start of the next file: this corrects the discrepancy between the duration of the label file and\n       * the duration of the pitchmark file (which is considered as the authority).\n       */\n      localNbrSamplesFromPM = (long) ((double) (pmFile.getTimeSpan()) * (double) (samplingRate));\n      globalStart += localNbrSamplesFromPM;\n      /* Clean the house */\n      labels.close();\n      System.out.println(\n          \" \"\n              + bnl.getName(i)\n              + \" (\"\n              + index\n              + \") (This file has [\"\n              + localNbrSamples\n              + \"] samples from .lab, rectified to [\"\n              + localNbrSamplesFromPM\n              + \"] from the pitchmarks, diff [\"\n              + (localNbrSamplesFromPM - localNbrSamples)\n              + \"], cumul [\"\n              + globalStart\n              + \"])\");\n      if ((localNbrSamplesFromPM - localNbrSamples) < 0)\n        System.out.println(\"BORK BORK BORK: .lab file longer than pitchmarks !\");\n    }\n    out.close();\n    // Now index is the number of units. Set this in the file:\n    RandomAccessFile raf = new RandomAccessFile(unitFileName, \"rw\");\n    raf.seek(posNumUnits);\n    raf.writeInt(index);\n    raf.close();\n    System.out.println(\"Number of processed units: \" + index);\n\n    UnitFileReader tester = new UnitFileReader(unitFileName);\n    int unitsOnDisk = tester.getNumberOfUnits();\n    if (unitsOnDisk == index) {\n      System.out.println(\"Can read right number of units\");\n      return true;\n    } else {\n      System.out.println(\"Read wrong number of units: \" + unitsOnDisk);\n      return false;\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1564, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 90, "focalAPIEnd": 101, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/Hadoop-mdfs/tree/master/hadoop-1.2.1/src/mapred/org/apache/hadoop/mapreduce/lib/output/TextOutputFormat.java", "rawCode": "    public synchronized void close(TaskAttemptContext context) throws IOException {\n      out.close();\n    }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1565, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [79], "initializationEnd": [151], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[])"], "configurationStart": [157], "configurationEnd": [191], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 197, "focalAPIEnd": 208, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/distributed/tree/master/Fast_Copy_HDFS/src/contrib/streaming/src/test/org/apache/hadoop/streaming/TestStreamDataProtocol.java", "rawCode": "  protected void createInput() throws IOException {\n    DataOutputStream out = new DataOutputStream(new FileOutputStream(INPUT_FILE.getAbsoluteFile()));\n    out.write(input.getBytes(\"UTF-8\"));\n    out.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1566, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(AuxOutputStream)"], "initializationStart": [222], "initializationEnd": [247], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()", "new Error(String)"], "tryExpressionStart": 345, "tryExpressionEnd": 349, "tryBlockStart": 345, "tryBlockEnd": 3014, "catchExpressionStart": 2927, "catchExpressionEnd": 2948, "catchBlockStart": 2927, "catchBlockEnd": 3014, "exceptionHandlingCallStart": [2956, 2990], "exceptionHandlingCallEnd": [2976, 3007], "configuration": ["dataOutputStream.writeShort(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeLong(int)", "dataOutputStream.writeFloat(int)", "dataOutputStream.writeDouble(int)", "dataOutputStream.writeBoolean(boolean)"], "configurationStart": [398, 841, 1274, 1713, 2158, 2609], "configurationEnd": [426, 865, 1299, 1739, 2185, 2631], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 2889, "focalAPIEnd": 2900, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/tags/release_4_0_0/src/net/sf/appia/core/message/Message.java", "rawCode": "  private void check() {\n    if (aos == null) aos = new AuxOutputStream();\n    if (ais == null) ais = new AuxInputStream();\n\n    byte[] aux = new byte[24];\n    aos.setBuffer(aux, 0, aux.length);\n    DataOutputStream dos = new DataOutputStream(aos);\n    ais.setBuffer(aux, 0, aux.length);\n    DataInputStream dis = new DataInputStream(ais);\n\n    try {\n      aos.setBuffer(aux, 0, aux.length);\n      dos.writeShort((short) -514);\n      pushShort((short) -514);\n      mbuf.len = length();\n      if (mbuf.len != aos.length()) throw new Error(\"Size mismatch in type Short\");\n      peek(mbuf);\n      if (!equalBytes(mbuf.data, mbuf.off, aux, 0, mbuf.len))\n        throw new Error(\"Raw contents mismatch in type Short\");\n      if (popShort() != -514) throw new Error(\"Value mismatch in type Short\");\n\n      aos.setBuffer(aux, 0, aux.length);\n      dos.writeInt(-134480386);\n      pushInt(-134480386);\n      mbuf.len = length();\n      if (mbuf.len != aos.length()) throw new Error(\"Size mismatch in type Int\");\n      peek(mbuf);\n      if (!equalBytes(mbuf.data, mbuf.off, aux, 0, mbuf.len))\n        throw new Error(\"Raw contents mismatch in type Int\");\n      if (popInt() != -134480386) throw new Error(\"Value mismatch in type Int\");\n\n      aos.setBuffer(aux, 0, aux.length);\n      dos.writeLong(-119247870);\n      pushLong(-119247870);\n      mbuf.len = length();\n      if (mbuf.len != aos.length()) throw new Error(\"Size mismatch in type Long\");\n      peek(mbuf);\n      if (!equalBytes(mbuf.data, mbuf.off, aux, 0, mbuf.len))\n        throw new Error(\"Raw contents mismatch in type Long\");\n      if (popLong() != -119247870) throw new Error(\"Value mismatch in type Long\");\n\n      aos.setBuffer(aux, 0, aux.length);\n      dos.writeFloat(-134480386);\n      pushFloat(-134480386);\n      mbuf.len = length();\n      if (mbuf.len != aos.length()) throw new Error(\"Size mismatch in type Float\");\n      peek(mbuf);\n      if (!equalBytes(mbuf.data, mbuf.off, aux, 0, mbuf.len))\n        throw new Error(\"Raw contents mismatch in type Float\");\n      if (popFloat() != -134480386) throw new Error(\"Value mismatch in type Float\");\n\n      aos.setBuffer(aux, 0, aux.length);\n      dos.writeDouble(-134480386);\n      pushDouble(-134480386);\n      mbuf.len = length();\n      if (mbuf.len != aos.length()) throw new Error(\"Size mismatch in type Double\");\n      peek(mbuf);\n      if (!equalBytes(mbuf.data, mbuf.off, aux, 0, mbuf.len))\n        throw new Error(\"Raw contents mismatch in type Double\");\n      if (popDouble() != -134480386) throw new Error(\"Value mismatch in type Double\");\n\n      aos.setBuffer(aux, 0, aux.length);\n      dos.writeBoolean(true);\n      pushBoolean(true);\n      mbuf.len = length();\n      if (mbuf.len != aos.length()) throw new Error(\"Size mismatch in type Boolean\");\n      if (popBoolean() != true) throw new Error(\"Value mismatch in type Boolean\");\n\n      // TODO: test String\n\n      dos.close();\n      dis.close();\n    } catch (Exception ex) {\n      ex.printStackTrace();\n      throw new Error(\"DHHH\");\n    }\n\n    discard(length());\n    checked = true;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1567, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(FileOutputStream)"], "initializationStart": [972], "initializationEnd": [1004], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeLong(long)", "dataOutputStream.flush()"], "configurationStart": [1012, 1101], "configurationEnd": [1043, 1119], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 1067, "guardExpressionEnd": 1090, "guardBlockStart": 1067, "guardBlockEnd": 1156, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1129, "focalAPIEnd": 1147, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spacecaker/android_frameworks_base_CSM9.1/tree/master/core/tests/hosttests/test-apps/DownloadManagerTestApp/src/com/android/frameworks/DownloadManagerTestApp.java", "rawCode": "  /**\n   * Initiates a download.\n   *\n   * <p>Queues up a download to the download manager, and saves the DownloadManager's assigned\n   * download ID for this download to a file.\n   *\n   * @throws Exception if unsuccessful\n   */\n  public void initiateDownload() throws Exception {\n    String filename = DOWNLOAD_5MB_FILENAME;\n    mContext.deleteFile(DOWNLOAD_STARTED_FLAG);\n    FileOutputStream fileOutput = mContext.openFileOutput(DOWNLOAD_STARTED_FLAG, 0);\n    DataOutputStream outputFile = null;\n    doCommonDownloadSetup();\n\n    try {\n      long dlRequest = -1;\n\n      // Make sure there are no pending downloads currently going on\n      removeAllCurrentDownloads();\n\n      Uri remoteUri = getExternalFileUri(filename);\n      Request request = new Request(remoteUri);\n\n      dlRequest = mDownloadManager.enqueue(request);\n      waitForDownloadToStart(dlRequest);\n      assertTrue(dlRequest != -1);\n\n      // Store ID of download for later retrieval\n      outputFile = new DataOutputStream(fileOutput);\n      outputFile.writeLong(dlRequest);\n    } finally {\n      if (outputFile != null) {\n        outputFile.flush();\n        outputFile.close();\n      }\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1568, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [416], "initializationEnd": [479], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 676, "focalAPIEnd": 688, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dataOutputStream.close()"], "useStart": [1546], "useEnd": [1558], "hasFinally": 1, "cleanUpCall": ["DataOutputStream.close()"], "finallyExpressionStart": 1475, "finallyExpressionEnd": 1483, "finallyBlockStart": 1475, "finallyBlockEnd": 1726, "cleanUpCallStart": [1546], "cleanUpCallEnd": [1558], "url": "https://github.com/stratosphere/stratosphere/tree/master/stratosphere-runtime/src/test/java/eu/stratosphere/nephele/services/iomanager/IOManagerPerformanceBenchmark.java", "rawCode": "  private final void speedTestStream(int bufferSize) throws IOException {\n    final Channel.ID tmpChannel = ioManager.createChannel();\n    final IntegerRecord rec = new IntegerRecord(0);\n\n    File tempFile = null;\n    DataOutputStream daos = null;\n    DataInputStream dais = null;\n\n    try {\n      tempFile = new File(tmpChannel.getPath());\n\n      FileOutputStream fos = new FileOutputStream(tempFile);\n      daos = new DataOutputStream(new BufferedOutputStream(fos, bufferSize));\n\n      long writeStart = System.currentTimeMillis();\n\n      int valsLeft = NUM_INTS_WRITTEN;\n      while (valsLeft-- > 0) {\n        rec.setValue(valsLeft);\n        rec.write(daos);\n      }\n      daos.close();\n      daos = null;\n\n      long writeElapsed = System.currentTimeMillis() - writeStart;\n\n      // ----------------------------------------------------------------\n\n      FileInputStream fis = new FileInputStream(tempFile);\n      dais = new DataInputStream(new BufferedInputStream(fis, bufferSize));\n\n      long readStart = System.currentTimeMillis();\n\n      valsLeft = NUM_INTS_WRITTEN;\n      while (valsLeft-- > 0) {\n        rec.read(dais);\n      }\n      dais.close();\n      dais = null;\n\n      long readElapsed = System.currentTimeMillis() - readStart;\n\n      LOG.info(\n          \"File-Stream with buffer \"\n              + bufferSize\n              + \": write \"\n              + writeElapsed\n              + \" msecs, read \"\n              + readElapsed\n              + \" msecs.\");\n    } finally {\n      // close if possible\n      if (daos != null) {\n        daos.close();\n      }\n      if (dais != null) {\n        dais.close();\n      }\n      // try to delete the file\n      if (tempFile != null) {\n        tempFile.delete();\n      }\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1569, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(ByteArrayOutputStream)"], "initializationStart": [508], "initializationEnd": [536], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 570, "focalAPIEnd": 581, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stumbleupon/hbase/tree/master/src/test/java/org/apache/hadoop/hbase/filter/TestFilterList.java", "rawCode": "  /**\n   * Test serialization\n   *\n   * @throws Exception\n   */\n  public void testSerialization() throws Exception {\n    List<Filter> filters = new ArrayList<Filter>();\n    filters.add(new PageFilter(MAX_PAGES));\n    filters.add(new WhileMatchFilter(new PrefixFilter(Bytes.toBytes(\"yyy\"))));\n    Filter filterMPALL = new FilterList(FilterList.Operator.MUST_PASS_ALL, filters);\n\n    // Decompose filterMPALL to bytes.\n    ByteArrayOutputStream stream = new ByteArrayOutputStream();\n    DataOutputStream out = new DataOutputStream(stream);\n    filterMPALL.write(out);\n    out.close();\n    byte[] buffer = stream.toByteArray();\n\n    // Recompose filterMPALL.\n    DataInputStream in = new DataInputStream(new ByteArrayInputStream(buffer));\n    FilterList newFilter = new FilterList();\n    newFilter.readFields(in);\n\n    // TODO: Run TESTS!!!\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1570, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(ByteArrayOutputStream)"], "initializationStart": [175], "initializationEnd": [201], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeLong(long)"], "configurationStart": [207], "configurationEnd": [234], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 240, "focalAPIEnd": 250, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/activemq/tree/master/activemq-unit-tests/src/test/java/org/apache/activemq/broker/BrokerTestSupport.java", "rawCode": "  protected XATransactionId createXATransaction(SessionInfo info) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    DataOutputStream os = new DataOutputStream(baos);\n    os.writeLong(++txGenerator);\n    os.close();\n    byte[] bs = baos.toByteArray();\n\n    XATransactionId xid = new XATransactionId();\n    xid.setBranchQualifier(bs);\n    xid.setGlobalTransactionId(bs);\n    xid.setFormatId(55);\n    return xid;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1571, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(FileOutputStream)"], "initializationStart": [1466], "initializationEnd": [1495], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1719, "focalAPIEnd": 1735, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop/hadoop-1.1.2/src/contrib/streaming/src/test/org/apache/hadoop/typedbytes/TestIO.java", "rawCode": "  public void testWritableIO() throws IOException {\n    Writable[] vectorValues =\n        new Writable[] {new Text(\"test1\"), new Text(\"test2\"), new Text(\"test3\")};\n    ArrayWritable vector = new ArrayWritable(Text.class, vectorValues);\n    MapWritable map = new MapWritable();\n    map.put(new Text(\"one\"), new VIntWritable(1));\n    map.put(new Text(\"two\"), new VLongWritable(2));\n    Writable[] writables =\n        new Writable[] {\n          new BytesWritable(new byte[] {1, 2, 3, 4}),\n          new ByteWritable((byte) 123),\n          new BooleanWritable(true),\n          new VIntWritable(12345),\n          new VLongWritable(123456789L),\n          new FloatWritable((float) 1.2),\n          new DoubleWritable(1.234),\n          new Text(\"random string\"),\n          new ObjectWritable(\"test\")\n        };\n    TypedBytesWritable tbw = new TypedBytesWritable();\n    tbw.setValue(\"typed bytes text\");\n    RecRecord1 r1 = new RecRecord1();\n    r1.setBoolVal(true);\n    r1.setByteVal((byte) 0x66);\n    r1.setFloatVal(3.145F);\n    r1.setDoubleVal(1.5234);\n    r1.setIntVal(-4567);\n    r1.setLongVal(-2367L);\n    r1.setStringVal(\"random text\");\n    r1.setBufferVal(new Buffer());\n    r1.setVectorVal(new ArrayList<String>());\n    r1.setMapVal(new TreeMap<String, String>());\n    RecRecord0 r0 = new RecRecord0();\n    r0.setStringVal(\"other random text\");\n    r1.setRecordVal(r0);\n\n    FileOutputStream ostream = new FileOutputStream(tmpfile);\n    DataOutputStream dostream = new DataOutputStream(ostream);\n    TypedBytesWritableOutput out = new TypedBytesWritableOutput(dostream);\n    for (Writable w : writables) {\n      out.write(w);\n    }\n    out.write(tbw);\n    out.write(vector);\n    out.write(map);\n    out.write(r1);\n    dostream.close();\n    ostream.close();\n\n    FileInputStream istream = new FileInputStream(tmpfile);\n    DataInputStream distream = new DataInputStream(istream);\n\n    TypedBytesWritableInput in = new TypedBytesWritableInput(distream);\n    for (Writable w : writables) {\n      assertEquals(w.toString(), in.read().toString());\n    }\n\n    assertEquals(tbw.getValue().toString(), in.read().toString());\n\n    assertEquals(ArrayWritable.class, in.readType());\n    ArrayWritable aw = in.readArray();\n    Writable[] writables1 = vector.get(), writables2 = aw.get();\n    assertEquals(writables1.length, writables2.length);\n    for (int i = 0; i < writables1.length; i++) {\n      assertEquals(\n          ((Text) writables1[i]).toString(), ((TypedBytesWritable) writables2[i]).getValue());\n    }\n    assertEquals(MapWritable.class, in.readType());\n\n    MapWritable mw = in.readMap();\n    assertEquals(map.entrySet(), mw.entrySet());\n\n    assertEquals(Type.LIST, TypedBytesInput.get(distream).readType());\n    assertEquals(r1.getBoolVal(), TypedBytesInput.get(distream).read());\n    assertEquals(r1.getByteVal(), TypedBytesInput.get(distream).read());\n    assertEquals(r1.getIntVal(), TypedBytesInput.get(distream).read());\n    assertEquals(r1.getLongVal(), TypedBytesInput.get(distream).read());\n    assertEquals(r1.getFloatVal(), TypedBytesInput.get(distream).read());\n    assertEquals(r1.getDoubleVal(), TypedBytesInput.get(distream).read());\n    assertEquals(r1.getStringVal(), TypedBytesInput.get(distream).read());\n    Object prevObj = null, obj = TypedBytesInput.get(distream).read();\n    while (obj != null) {\n      prevObj = obj;\n      obj = TypedBytesInput.get(distream).read();\n    }\n    List recList = (List) prevObj;\n    assertEquals(r0.getStringVal(), recList.get(0));\n\n    distream.close();\n    istream.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1572, "initialization": ["DataOutputStream dataOutputStream = FileSystem.create(Path)"], "initializationStart": [1341], "initializationEnd": [1358], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)"], "configurationStart": [1366, 1405, 1444], "configurationEnd": [1397, 1436, 1480], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1488, "focalAPIEnd": 1497, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["FileSystem.delete(Path,boolean)"], "finallyExpressionStart": 2043, "finallyExpressionEnd": 2051, "finallyBlockStart": 2043, "finallyBlockEnd": 2090, "cleanUpCallStart": [2059], "cleanUpCallEnd": [2083], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/test/java/org/apache/hadoop/mapred/TestMapRed.java", "rawCode": "  private void checkCompression(\n      boolean compressMapOutputs, CompressionType redCompression, boolean includeCombine)\n      throws Exception {\n    JobConf conf = new JobConf(TestMapRed.class);\n    Path testdir = new Path(\"build/test/test.mapred.compress\");\n    Path inDir = new Path(testdir, \"in\");\n    Path outDir = new Path(testdir, \"out\");\n    FileSystem fs = FileSystem.get(conf);\n    fs.delete(testdir, true);\n    FileInputFormat.setInputPaths(conf, inDir);\n    FileOutputFormat.setOutputPath(conf, outDir);\n    conf.setMapperClass(MyMap.class);\n    conf.setReducerClass(MyReduce.class);\n    conf.setOutputKeyClass(Text.class);\n    conf.setOutputValueClass(Text.class);\n    conf.setOutputFormat(SequenceFileOutputFormat.class);\n    conf.set(MRConfig.FRAMEWORK_NAME, MRConfig.LOCAL_FRAMEWORK_NAME);\n    if (includeCombine) {\n      conf.setCombinerClass(IdentityReducer.class);\n    }\n    conf.setCompressMapOutput(compressMapOutputs);\n    SequenceFileOutputFormat.setOutputCompressionType(conf, redCompression);\n    try {\n      if (!fs.mkdirs(testdir)) {\n        throw new IOException(\"Mkdirs failed to create \" + testdir.toString());\n      }\n      if (!fs.mkdirs(inDir)) {\n        throw new IOException(\"Mkdirs failed to create \" + inDir.toString());\n      }\n      Path inFile = new Path(inDir, \"part0\");\n      DataOutputStream f = fs.create(inFile);\n      f.writeBytes(\"Owen was here\\n\");\n      f.writeBytes(\"Hadoop is fun\\n\");\n      f.writeBytes(\"Is this done, yet?\\n\");\n      f.close();\n      RunningJob rj = JobClient.runJob(conf);\n      assertTrue(\"job was complete\", rj.isComplete());\n      assertTrue(\"job was successful\", rj.isSuccessful());\n      Path output = new Path(outDir, Task.getOutputName(0));\n      assertTrue(\"reduce output exists \" + output, fs.exists(output));\n      SequenceFile.Reader rdr = new SequenceFile.Reader(fs, output, conf);\n      assertEquals(\n          \"is reduce output compressed \" + output,\n          redCompression != CompressionType.NONE,\n          rdr.isCompressed());\n      rdr.close();\n    } finally {\n      fs.delete(testdir, true);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1573, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [164], "initializationEnd": [216], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeInt(int)", "dataOutputStream.writeDouble(double)"], "configurationStart": [222, 242], "configurationEnd": [236, 259], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 265, "focalAPIEnd": 275, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IanDarwin/javasrc/tree/master/src/main/java/io/WriteBinary.java", "rawCode": "  public static void main(String[] argv) throws IOException {\n    int i = 42;\n    double d = Math.PI;\n    String FILENAME = \"binary.dat\";\n    DataOutputStream os = new DataOutputStream(new FileOutputStream(FILENAME));\n    os.writeInt(i);\n    os.writeDouble(d);\n    os.close();\n    System.out.println(\"Wrote \" + i + \", \" + d + \" to file \" + FILENAME);\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1574, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [773], "initializationEnd": [854], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["exit_with_help()"], "tryExpressionStart": 651, "tryExpressionEnd": 655, "tryBlockStart": 651, "tryBlockEnd": 1557, "catchExpressionStart": 1421, "catchExpressionEnd": 1453, "catchBlockStart": 1421, "catchBlockEnd": 1484, "exceptionHandlingCallStart": [1461], "exceptionHandlingCallEnd": [1477], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1399, "focalAPIEnd": 1413, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wensby/ai-project/tree/master/src/svm/svm_predict.java", "rawCode": "  public static void main(String argv[]) throws IOException {\n    int i, predict_probability = 0;\n    svm_print_string = svm_print_stdout;\n\n    // parse options\n    for (i = 0; i < argv.length; i++) {\n      if (argv[i].charAt(0) != '-') break;\n      ++i;\n      switch (argv[i - 1].charAt(1)) {\n        case 'b':\n          predict_probability = atoi(argv[i]);\n          break;\n        case 'q':\n          svm_print_string = svm_print_null;\n          i--;\n          break;\n        default:\n          System.err.print(\"Unknown option: \" + argv[i - 1] + \"\\n\");\n          exit_with_help();\n      }\n    }\n    if (i >= argv.length - 2) exit_with_help();\n    try {\n      BufferedReader input = new BufferedReader(new FileReader(argv[i]));\n      DataOutputStream output =\n          new DataOutputStream(new BufferedOutputStream(new FileOutputStream(argv[i + 2])));\n      svm_model model = svm.svm_load_model(argv[i + 1]);\n      if (predict_probability == 1) {\n        if (svm.svm_check_probability_model(model) == 0) {\n          System.err.print(\"Model does not support probabiliy estimates\\n\");\n          System.exit(1);\n        }\n      } else {\n        if (svm.svm_check_probability_model(model) != 0) {\n          svm_predict.info(\"Model supports probability estimates, but disabled in prediction.\\n\");\n        }\n      }\n      predict(input, output, model, predict_probability);\n      input.close();\n      output.close();\n    } catch (FileNotFoundException e) {\n      exit_with_help();\n    } catch (ArrayIndexOutOfBoundsException e) {\n      exit_with_help();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1575, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [2039], "initializationEnd": [2089], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.flush()"], "configurationStart": [2098, 2138], "configurationEnd": [2130, 2155], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 2163, "focalAPIEnd": 2180, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["HttpURLConnection.disconnect()"], "finallyExpressionStart": 2773, "finallyExpressionEnd": 2781, "finallyBlockStart": 2773, "finallyBlockEnd": 2862, "cleanUpCallStart": [2824], "cleanUpCallEnd": [2847], "url": "https://github.com/aldaris/opensso/tree/master/extensions/jsr196/src/main/java/com/sun/security/sam/openid2/AssociationManager.java", "rawCode": "  public Object checkAuthentication(String idp, Map token) throws IOException {\n\n    Object rvalue = null;\n\n    URL idpURL = new URL(idp);\n\n    HttpURLConnection connection = null;\n\n    try {\n\n      StringBuffer pBuffer = new StringBuffer(\"openid.mode=check_association\");\n\n      pBuffer.append(\"&openid.assoc_handle=\" + (String) token.get(\"openid.assoc_handle\"));\n\n      pBuffer.append(\"&openid.sig=\" + (String) token.get(\"openid.sig\"));\n\n      String signed = (String) token.get(\"openid.signed\");\n\n      pBuffer.append(\"&openid.signed=\" + signed);\n\n      ArrayList fields = null;\n      StringTokenizer tokenizer = new StringTokenizer(signed, \",\");\n\n      while (tokenizer.hasMoreTokens()) {\n        String field = new String(\"openid.\" + tokenizer.nextToken());\n        pBuffer.append(\"&\" + field + \"=\" + (String) token.get(field));\n      }\n\n      String iHandle = (String) token.get(\"openid.invalidate_handle\");\n      if (iHandle != null) {\n        pBuffer.append(\"&openid.invalidate_handle=\" + iHandle);\n      }\n\n      String parameters = pBuffer.toString();\n\n      if (debug) {\n        logger.log(Level.INFO, \"openid.idp_check_url: \" + idpURL);\n        logger.log(Level.INFO, \"openid.idp_check_parameters: \" + parameters);\n      }\n\n      connection = (HttpURLConnection) idpURL.openConnection();\n\n      if (connection instanceof HttpsURLConnection) {\n        ((HttpsURLConnection) connection).setHostnameVerifier(hostnameVerifier);\n      } else {\n        String msg = \"openid.idp_url_not_secure\";\n        logger.log(Level.WARNING, msg, idpURL);\n        return null;\n      }\n\n      connection.setRequestMethod(\"POST\");\n\n      connection.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n      connection.setRequestProperty(\n          \"Content-Length\", Integer.toString(parameters.getBytes().length));\n      connection.setRequestProperty(\"Content-Language\", \"en-US\");\n\n      connection.setDoInput(true);\n      connection.setDoOutput(true);\n      connection.setUseCaches(false);\n\n      DataOutputStream outStream = new DataOutputStream(connection.getOutputStream());\n\n      outStream.writeBytes(parameters);\n      outStream.flush();\n      outStream.close();\n\n      Map responseToken = getIdpResponse(connection);\n\n      if (responseToken != null) {\n        String valid = (String) responseToken.get(\"openid.is_valid\");\n        if (valid != null && valid.equals(\"true\")) {\n\n          // Store Data in token\n          // whi did is 'DH-SHA1' hard coded here? should we use the sessiontype ?\n\n          token.put(OpenIDToken.SESSION_TYPE, \"DH-SHA1\");\n          token.put(OpenIDToken.IDP, idp);\n        }\n\n        if (!responseToken.containsKey(\"openid.invalidate_handle\")) {\n          token.remove(\"openid.invalidate_handle\");\n        }\n      }\n\n    } finally {\n\n      if (connection != null) {\n        connection.disconnect();\n      }\n    }\n\n    return rvalue;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1576, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(ByteArrayOutputStream)"], "initializationStart": [192], "initializationEnd": [218], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new SerializationException(*)"], "tryExpressionStart": 224, "tryExpressionEnd": 228, "tryBlockStart": 224, "tryBlockEnd": 504, "catchExpressionStart": 428, "catchExpressionEnd": 452, "catchBlockStart": 428, "catchBlockEnd": 504, "exceptionHandlingCallStart": [466], "exceptionHandlingCallEnd": [497], "configuration": ["dataOutputStream.writeInt(int)", "dataOutputStream.writeBytes(String)", "dataOutputStream.flush()"], "configurationStart": [237, 277, 310], "configurationEnd": [269, 302, 322], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 370, "focalAPIEnd": 382, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jinhyung/MIPL/tree/master/reference/MapReduceMatrixMult/twister/twister-0.9/src/cgl/imr/data/file/FileData.java", "rawCode": "  @Override\n  public byte[] getBytes() throws SerializationException {\n    byte[] outputBytes = null;\n    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n    DataOutputStream dout = new DataOutputStream(bout);\n    try {\n\n      dout.writeInt(fileName.length());\n      dout.writeBytes(fileName);\n      dout.flush();\n      outputBytes = bout.toByteArray();\n      dout.close();\n      dout = null;\n      bout = null;\n    } catch (IOException ioe) {\n      throw new SerializationException(ioe);\n    }\n    return outputBytes;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1577, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 458, "guardExpressionEnd": 473, "guardBlockStart": 458, "guardBlockEnd": 485, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 474, "focalAPIEnd": 484, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/Hadoop-mdfs/tree/master/hadoop-1.2.1/src/test/org/apache/hadoop/hdfs/tools/offlineImageViewer/TestOfflineImageViewer.java", "rawCode": "  private void changeLayoutVersion(File src, File dest, int newVersion) throws IOException {\n    DataInputStream in = null;\n    DataOutputStream out = null;\n\n    try {\n      in = new DataInputStream(new FileInputStream(src));\n      out = new DataOutputStream(new FileOutputStream(dest));\n\n      in.readInt();\n      out.writeInt(newVersion);\n\n      byte[] b = new byte[1024];\n      while (in.read(b) > 0) {\n        out.write(b);\n      }\n    } finally {\n      if (in != null) in.close();\n      if (out != null) out.close();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1578, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [1128], "initializationEnd": [1172], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["getMessage()", "e(String,String,*)", "getMessage()", "new PluginResult(*,*)", "error(PluginResult,String)"], "tryExpressionStart": 1181, "tryExpressionEnd": 1185, "tryBlockStart": 1181, "tryBlockEnd": 1674, "catchExpressionStart": 4932, "catchExpressionEnd": 4964, "catchBlockStart": 4932, "catchBlockEnd": 5152, "exceptionHandlingCallStart": [4756, 4723, 4876, 5053, 5120], "exceptionHandlingCallEnd": [4770, 4774, 4890, 5112, 5145], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.write(byte[],int,int)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.flush()"], "configurationStart": [1297, 1348, 1432, 1477, 1537, 1682, 1729, 1932, 1994, 2559, 3915, 3946, 4053], "configurationEnd": [1336, 1420, 1465, 1525, 1560, 1721, 1924, 1985, 2017, 2591, 3938, 3990, 4064], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 4282, "focalAPIEnd": 4293, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pankajkainthla/phonegap-plugins-all/tree/master/Android/FileUploader/FileUploader.java", "rawCode": "  public void upload(\n      InputStream fileInputStream,\n      String server,\n      JSONObject params,\n      final String fileKey,\n      final String fileName,\n      final String mimeType,\n      final String callbackId) {\n    try {\n\n      String lineEnd = \"\\r\\n\";\n      String td = \"--\";\n      String boundary = \"*****com.beetight.formBoundary\";\n\n      URL url = new URL(server);\n      HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\n      // Get cookies that have been set in our webview\n      CookieManager cm = CookieManager.getInstance();\n      String cookie = cm.getCookie(server);\n\n      // allow inputs\n      conn.setDoInput(true);\n      // allow outputs\n      conn.setDoOutput(true);\n      // don't use a cached copy\n      conn.setUseCaches(false);\n      // use a post method\n      conn.setRequestMethod(\"POST\");\n      // set post headers\n      conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n      conn.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n      conn.setRequestProperty(\"Cookie\", cookie);\n      // open data output stream\n      DataOutputStream dos = new DataOutputStream(conn.getOutputStream());\n\n      try {\n        for (Iterator iter = params.keys(); iter.hasNext(); ) {\n          Object key = iter.next();\n          dos.writeBytes(td + boundary + lineEnd);\n          dos.writeBytes(\"Content-Disposition: form-data; name=\\\"\" + key + \"\\\"; \");\n          dos.writeBytes(lineEnd + lineEnd);\n          dos.writeBytes(params.getString(key.toString()));\n          dos.writeBytes(lineEnd);\n        }\n      } catch (JSONException e) {\n        Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      }\n\n      dos.writeBytes(td + boundary + lineEnd);\n      dos.writeBytes(\n          \"Content-Disposition: form-data; name=\\\"\"\n              + fileKey\n              + \"\\\";filename=\\\"\"\n              + fileName\n              + \"\\\"\"\n              + lineEnd);\n      dos.writeBytes(\"Content-Type: \" + mimeType + lineEnd);\n\n      dos.writeBytes(lineEnd);\n      // create a buffer of maximum size\n      int bytesAvailable = fileInputStream.available();\n      final int total = bytesAvailable;\n      Log.e(\"PhoneGapLog\", \"available: \" + bytesAvailable);\n\n      int maxBufferSize = 1024;\n      int bufferSize = Math.min(bytesAvailable, maxBufferSize);\n      byte[] buffer = new byte[bufferSize];\n      // read file and write it into form...\n      int bytesRead = fileInputStream.read(buffer, 0, bufferSize);\n      int progress = bytesRead;\n      int send = 0;\n      while (bytesRead > 0) {\n        dos.write(buffer, 0, bufferSize);\n        bytesAvailable = fileInputStream.available();\n        bufferSize = Math.min(bytesAvailable, maxBufferSize);\n        bytesRead = fileInputStream.read(buffer, 0, bufferSize);\n        progress += bytesRead;\n        final int prog = progress;\n        Log.e(\"PhoneGapLog\", \"read \" + progress + \" of \" + total);\n\n        // Sending every progress event is overkill\n        if (send++ % 20 == 0) {\n          ctx.runOnUiThread(\n              new Runnable() {\n                public void run() {\n                  try {\n                    JSONObject result = new JSONObject();\n                    result.put(\"status\", FileUploader.Status.PROGRESS);\n                    result.put(\"progress\", prog);\n                    result.put(\"total\", total);\n                    PluginResult progressResult = new PluginResult(PluginResult.Status.OK, result);\n                    progressResult.setKeepCallback(true);\n                    success(progressResult, callbackId);\n                  } catch (JSONException e) {\n                    Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n                  }\n                }\n              });\n          // Give a chance for the progress to be sent to javascript\n          Thread.sleep(100);\n        }\n      }\n      // send multipart form data necessary after file data...\n      dos.writeBytes(lineEnd);\n      dos.writeBytes(td + boundary + td + lineEnd);\n\n      // close streams\n      fileInputStream.close();\n      dos.flush();\n      InputStream is = conn.getInputStream();\n      int ch;\n      StringBuffer b = new StringBuffer();\n      while ((ch = is.read()) != -1) {\n        b.append((char) ch);\n      }\n      String s = b.toString();\n      dos.close();\n      JSONObject result = new JSONObject();\n      result.put(\"status\", FileUploader.Status.COMPLETE);\n\n      result.put(\"progress\", progress);\n      result.put(\"total\", total);\n      result.put(\"result\", s);\n      PluginResult progressResult = new PluginResult(PluginResult.Status.OK, result);\n      progressResult.setKeepCallback(true);\n      success(progressResult, callbackId);\n\n    } catch (MalformedURLException e) {\n      Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      PluginResult result =\n          new PluginResult(PluginResult.Status.MALFORMED_URL_EXCEPTION, e.getMessage());\n      error(result, callbackId);\n    } catch (FileNotFoundException e) {\n      Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      PluginResult result = new PluginResult(PluginResult.Status.ERROR, e.getMessage());\n      error(result, callbackId);\n    } catch (IOException e) {\n      Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      PluginResult result = new PluginResult(PluginResult.Status.IO_EXCEPTION, e.getMessage());\n      error(result, callbackId);\n    } catch (InterruptedException e) {\n      Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      PluginResult result = new PluginResult(PluginResult.Status.ERROR, e.getMessage());\n      error(result, callbackId);\n    } catch (JSONException e) {\n      Log.e(\"PhoneGapLog\", \"error: \" + e.getMessage(), e);\n      PluginResult result = new PluginResult(PluginResult.Status.JSON_EXCEPTION, e.getMessage());\n      error(result, callbackId);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1579, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [112], "initializationEnd": [186], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace(*)", "exit(int)"], "tryExpressionStart": 67, "tryExpressionEnd": 71, "tryBlockStart": 67, "tryBlockEnd": 424, "catchExpressionStart": 336, "catchExpressionEnd": 358, "catchBlockStart": 336, "catchBlockEnd": 424, "exceptionHandlingCallStart": [366, 403], "exceptionHandlingCallEnd": [395, 417], "configuration": ["dataOutputStream.write(byte[])", "dataOutputStream.flush()"], "configurationStart": [194, 218], "configurationEnd": [210, 229], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 237, "focalAPIEnd": 248, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bizosys/hsearch-core/tree/master/src/java/com/bizosys/hsearch/admin/TableGenerator.java", "rawCode": "  public static void downloadToFile(byte[] bytes, File file) {\n    try {\n      DataOutputStream out =\n          new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)));\n      out.write(bytes);\n      out.flush();\n      out.close();\n      System.out.println(file.getAbsolutePath() + \" is written sucessfully.\");\n\n    } catch (IOException e) {\n      e.printStackTrace(System.err);\n      System.exit(1);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1580, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [747], "initializationEnd": [790], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["e(String,String)"], "tryExpressionStart": 156, "tryExpressionEnd": 160, "tryBlockStart": 156, "tryBlockEnd": 2069, "catchExpressionStart": 2010, "catchExpressionEnd": 2030, "catchBlockStart": 2010, "catchBlockEnd": 2069, "exceptionHandlingCallStart": [2038], "exceptionHandlingCallEnd": [2062], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.write(byte[],int,int)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.flush()"], "configurationStart": [798, 849, 1067, 1432, 1475, 1501, 1613], "configurationEnd": [840, 1059, 1085, 1459, 1493, 1556, 1623], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1973, "focalAPIEnd": 1983, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sunqimin09/FirstApp/tree/master/AppTellOut/src/com/tellout/util/ImageUpload.java", "rawCode": "  private boolean uploadFile(String actionUrl, File uploadFile) {\n    String end = \"\\r\\n\";\n    String twoHyphens = \"--\";\n    String boundary = \"*****\";\n    try {\n      URL url = new URL(actionUrl);\n      HttpURLConnection con = (HttpURLConnection) url.openConnection();\n      /* 允许Input、Output，不使用Cache */\n      con.setDoInput(true);\n      con.setDoOutput(true);\n      con.setUseCaches(false);\n      /* 设置传送的method=POST */\n      con.setRequestMethod(\"POST\");\n      /* setRequestProperty */\n      con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n      con.setRequestProperty(\"Charset\", \"UTF-8\");\n      con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n      /* 设置DataOutputStream */\n      DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n      ds.writeBytes(twoHyphens + boundary + end);\n\n      ds.writeBytes(\n          \"Content-Disposition: form-data; \"\n              + \"name=\\\"file1\\\";filename=\\\"\"\n              + MConstant.USER_ID_VALUE\n              + \".jpeg\"\n              + \"\\\"\"\n              + end);\n      ds.writeBytes(end);\n      /* 取得文件的FileInputStream */\n      FileInputStream fStream = new FileInputStream(uploadFile);\n      /* 设置每次写入1024bytes */\n      int bufferSize = 1024;\n      byte[] buffer = new byte[bufferSize];\n      int length = -1;\n      /* 从文件读取数据至缓冲区 */\n      while ((length = fStream.read(buffer)) != -1) {\n        /* 将资料写入DataOutputStream中 */\n        ds.write(buffer, 0, length);\n      }\n      ds.writeBytes(end);\n      ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n      /* close streams */\n      fStream.close();\n      ds.flush();\n      /* 取得Response内容 */\n      InputStream is = con.getInputStream();\n      int ch;\n      StringBuffer b = new StringBuffer();\n      while ((ch = is.read()) != -1) {\n        b.append((char) ch);\n      }\n      // Looper.prepare();\n      /* 将Response显示于Dialog */\n      Log.i(\"tag\", \"上传成功\" + b.toString().trim());\n      /* 关闭DataOutputStream */\n      ds.close();\n      return true;\n    } catch (Exception e) {\n      Log.e(\"tag\", \"上传失败\" + e);\n    }\n    return false;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1581, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [268], "initializationEnd": [342], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["showErrorMessage(*)"], "tryExpressionStart": 177, "tryExpressionEnd": 181, "tryBlockStart": 177, "tryBlockEnd": 468, "catchExpressionStart": 392, "catchExpressionEnd": 414, "catchBlockStart": 392, "catchBlockEnd": 468, "exceptionHandlingCallStart": [422], "exceptionHandlingCallEnd": [441], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 373, "focalAPIEnd": 384, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/astraw/micromanager1.3/tree/master/mmstudio/src/org/micromanager/image5d/Test_Save.java", "rawCode": "  /** Save the image in TIFF format using the specified path. */\n  public boolean saveAsTiff(String path) {\n    fi.nImages = 1;\n    fi.description = getDescriptionString();\n    try {\n      TiffEncoder file = new TiffEncoder(fi);\n      DataOutputStream out =\n          new DataOutputStream(new BufferedOutputStream(new FileOutputStream(path)));\n      file.write(out);\n      out.close();\n    } catch (IOException e) {\n      showErrorMessage(e);\n      return false;\n    }\n    // updateImp(fi, fi.TIFF);\n    return true;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1582, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [716], "initializationEnd": [769], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)", "dataOutputStream.write(byte[])", "dataOutputStream.writeBytes(String)", "dataOutputStream.flush()"], "configurationStart": [775, 834, 959, 1047, 1086, 1151], "configurationEnd": [828, 953, 1040, 1079, 1145, 1175], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1181, "focalAPIEnd": 1205, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jbosstools/jbosstools-jbpm/tree/master/plugins/org.jbpm.gd.jpdl/src/org/jbpm/gd/jpdl/util/ProcessDeployer.java", "rawCode": "  private void deployProcessWithServlet(byte[] parBytes) throws Exception {\n    String urlStr = \"http://\" + serverName + \":\" + serverPort + serverDeployer;\n    URL url = new URL(urlStr);\n    URLConnection urlConnection = url.openConnection();\n    if (useCredentials) {\n      String userPassword = username + \":\" + password;\n      String encoding = Base64Converter.encode(userPassword);\n      urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n    }\n    urlConnection.setDoInput(true);\n    urlConnection.setDoOutput(true);\n    urlConnection.setUseCaches(false);\n    urlConnection.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=AaB03x\");\n    DataOutputStream dataOutputStream = new DataOutputStream(urlConnection.getOutputStream());\n    dataOutputStream.writeBytes(\"--\" + boundary + \"\\r\\n\");\n    dataOutputStream.writeBytes(\n        \"Content-Disposition: form-data; name=\\\"definition\\\"; filename=\\\"dummy.par\\\"\\r\\n\");\n    dataOutputStream.writeBytes(\"Content-Type: application/x-zip-compressed\\r\\n\\r\\n\");\n\n    dataOutputStream.write(parBytes);\n\n    dataOutputStream.writeBytes(\"\\r\\n--\" + boundary + \"--\\r\\n\");\n    dataOutputStream.flush();\n    dataOutputStream.close();\n    InputStream inputStream = urlConnection.getInputStream();\n    StringBuffer result = new StringBuffer();\n    int read;\n    while ((read = inputStream.read()) != -1) {\n      result.append((char) read);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1583, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [1664], "initializationEnd": [1748], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)", "printStackTrace()"], "tryExpressionStart": 2233, "tryExpressionEnd": 2237, "tryBlockStart": 2233, "tryBlockEnd": 4938, "catchExpressionStart": 4814, "catchExpressionEnd": 4834, "catchBlockStart": 4814, "catchBlockEnd": 4938, "exceptionHandlingCallStart": [4844, 4910], "exceptionHandlingCallEnd": [4900, 4929], "configuration": ["dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeUTF(String)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeByte(byte)", "dataOutputStream.writeLong(long)"], "configurationStart": [2247, 2276, 2314, 2402, 4009, 4109, 4675], "configurationEnd": [2266, 2304, 2340, 2428, 4043, 4132, 4701], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 4774, "focalAPIEnd": 4784, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/conceptstailored/NCSU-GBS-Pipeline/tree/master/TASSEL_20121011/maizegenetics/src/net/maizegenetics/gbs/tagdist/TagsByTaxaCBSUAdapter.java", "rawCode": "  /**\n   * @param inFile Name of a tag map file in the format supplied by Harpreet.\n   * @param taxonNameFile Name of a file which lists biological line names present in infile, one\n   *     per line.\n   * @param outFile Name of a file in which to write new tag map.\n   */\n  public void convertCBSUFile(File inFile, File taxonNameFile, File outFile) {\n    System.out.println(\"Reading tag alignment from:\" + inFile.toString());\n    String[] inputLine = {\"Not\", \"Started\"};\n    int numTaxonNames = 0; // Number of distinct taxon names from taxonNameFile\n    int currLine = 0;\n\n    try {\n      BufferedReader taxonNameCounter = new BufferedReader(new FileReader(taxonNameFile), 65536);\n      while (taxonNameCounter.readLine() != null) {\n        numTaxonNames++;\n      } // 1st pass through file counts lines\n      taxonNameCounter.close();\n    } catch (Exception e) {\n      System.out.println(\"Catch in counting taxon names: \" + e);\n    }\n\n    String[] taxonNames = new String[numTaxonNames];\n    try {\n      BufferedReader taxonNameReader = new BufferedReader(new FileReader(taxonNameFile), 65536);\n      for (int i = 0; i < numTaxonNames; i++) {\n        taxonNames[i] = taxonNameReader.readLine().trim();\n      } // Trim each line name and add to array\n      taxonNameReader.close();\n    } catch (Exception e) {\n      System.out.println(\"Catch in reading taxon names: \" + e);\n    }\n    System.out.println(\"Taxa names read. TaxaNumber:\" + numTaxonNames);\n    try {\n      BufferedReader br = new BufferedReader(new FileReader(inFile), 65536);\n      BufferedReader tagCounter = new BufferedReader(new FileReader(inFile), 65536);\n      DataOutputStream fw =\n          new DataOutputStream(new BufferedOutputStream(new FileOutputStream(outFile), 65536));\n      int tagNum = 0;\n      int tagLengthInLong = 2;\n      ReadBarcodeResult tagProcessingResults = null;\n      byte tagLength;\n      String tagSequence;\n      long[] binaryTagSequence = new long[tagLengthInLong];\n      System.out.print(\"Tag counting....\");\n      while (tagCounter.readLine() != null) {\n        tagNum++;\n      }\n      tagCounter.close(); // Loop through tag map file, count #tags (i.e. #lines) and then close\n      System.out.println(\" TagNumber:\" + tagNum);\n      try {\n        fw.writeInt(tagNum);\n        fw.writeInt(tagLengthInLong);\n        fw.writeInt(numTaxonNames);\n        for (int t = 0; t < numTaxonNames; t++) {\n          fw.writeUTF(taxonNames[t]);\n        }\n        for (int row = 0; row < tagNum; row++) { // Fill byte arrays\n          if (row % 100000 == 0) System.out.println(\"Processed Row:\" + row);\n          inputLine = br.readLine().split(\"\\t\");\n          String corrSeq = inputLine[5];\n\n          if (!corrSeq.startsWith(\"CAGC\")\n              && !corrSeq.startsWith(\"CTGC\")\n              && !corrSeq.endsWith(\"CGTC\")\n              && !corrSeq.endsWith(\"CGAC\")) {\n            continue;\n          }\n\n          if (cleanCutSites) {\n            if (ParseBarcodeRead.getInitialCutSiteRemnant() == null) {\n              ParseBarcodeRead.chooseEnzyme(\"ApeKI\");\n            }\n            tagProcessingResults =\n                ParseBarcodeRead.removeSeqAfterSecondCutSite(\n                    corrSeq, (byte) (tagLengthInLong * 32));\n          } // Process tag sequence to find cut sites\n          if (tagProcessingResults.processedSequence != null) {\n            tagLength =\n                tagProcessingResults\n                    .getLength(); // If cut site was found, write length of processed tag...\n            tagSequence = tagProcessingResults.paddedSequence; // And sequence of processed tag...\n          } else {\n            tagLength = (byte) corrSeq.length(); // ...otherwise write length of unprocessed tag.\n            tagSequence = corrSeq; // ...and sequence of unprocessed tag.\n          }\n\n          binaryTagSequence =\n              BaseEncoder.getLongArrayFromSeq(\n                  tagSequence); // Convert sequence from string to long[]\n\n          for (int j = 0; j < tagLengthInLong; j++) {\n            fw.writeLong(binaryTagSequence[j]); // Write long[] array of sequence to disk\n          }\n          fw.writeByte(tagLength);\n\n          OpenBitSet obs =\n              new OpenBitSet(numTaxonNames); // New binary object to store presence/absence data\n          for (int t = 0; t < numTaxonNames; t++) { // Create a marker presence/absence bitmap\n            // if(inputLine[9].substring(t, t+1).matches(\"1\")){\n            // obs.set(t);\n            // }\n            if (inputLine[9].charAt(t) == '1') {\n              obs.set(t);\n            }\n          }\n\n          long[] obsInLong = obs.getBits();\n          for (int t = 0; t < obsInLong.length; t++) {\n            fw.writeLong(obsInLong[t]); // Write presence/absence bitmap to file\n          }\n        }\n        fw.close();\n        br.close();\n      } catch (Exception e) {\n        System.out.println(\"Catch in writing output file: \" + e);\n        e.printStackTrace();\n      }\n    } catch (Exception e) {\n      System.out.println(\"Catch in reading tag map file: \" + e);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1584, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(ByteArrayOutputStream)"], "initializationStart": [1248], "initializationEnd": [1280], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "dataOutputStream!=null", "guardType": "IF {", "guardExpressionStart": 1563, "guardExpressionEnd": 1579, "guardBlockStart": 1563, "guardBlockEnd": 1592, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1580, "focalAPIEnd": 1591, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/drepshas/hib-core/tree/master/hibernate-core/src/main/java/org/hibernate/bytecode/internal/javassist/JavassistClassTransformer.java", "rawCode": "  @Override\n  protected byte[] doTransform(\n      ClassLoader loader,\n      String className,\n      Class classBeingRedefined,\n      ProtectionDomain protectionDomain,\n      byte[] classfileBuffer) {\n    ClassFile classfile;\n    try {\n      // WARNING: classfile only\n      classfile = new ClassFile(new DataInputStream(new ByteArrayInputStream(classfileBuffer)));\n    } catch (IOException e) {\n      LOG.unableToBuildEnhancementMetamodel(className);\n      return classfileBuffer;\n    }\n    // This is the same as ClassPool.getDefault() but ensures a new ClassPool per\n    ClassPool cp = new ClassPool();\n    cp.appendSystemPath();\n    cp.appendClassPath(new ClassClassPath(this.getClass()));\n    cp.appendClassPath(new ClassClassPath(classfile.getClass()));\n    try {\n      cp.makeClassIfNew(new ByteArrayInputStream(classfileBuffer));\n    } catch (IOException e) {\n      throw new RuntimeException(e.getMessage(), e);\n    }\n    FieldTransformer transformer = getFieldTransformer(classfile, cp);\n    if (transformer != null) {\n      LOG.debugf(\"Enhancing %s\", className);\n      DataOutputStream out = null;\n      try {\n        transformer.transform(classfile);\n        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n        out = new DataOutputStream(byteStream);\n        classfile.write(out);\n        return byteStream.toByteArray();\n      } catch (Exception e) {\n        LOG.unableToTransformClass(e.getMessage());\n        throw new HibernateException(\"Unable to transform class: \" + e.getMessage());\n      } finally {\n        try {\n          if (out != null) out.close();\n        } catch (IOException e) {\n          // swallow\n        }\n      }\n    }\n    return classfileBuffer;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1585, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [602], "initializationEnd": [657], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["exit_with_help()"], "tryExpressionStart": 490, "tryExpressionEnd": 494, "tryBlockStart": 490, "tryBlockEnd": 1167, "catchExpressionStart": 1031, "catchExpressionEnd": 1063, "catchBlockStart": 1031, "catchBlockEnd": 1094, "exceptionHandlingCallStart": [1071], "exceptionHandlingCallEnd": [1087], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1009, "focalAPIEnd": 1023, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/adelq/WebcamStudio/tree/master/trunk/src/svm/svm_predict.java", "rawCode": "  public static void main(String argv[]) throws IOException {\n    int i, predict_probability = 0;\n\n    // parse options\n    for (i = 0; i < argv.length; i++) {\n      if (argv[i].charAt(0) != '-') break;\n      ++i;\n      switch (argv[i - 1].charAt(1)) {\n        case 'b':\n          predict_probability = atoi(argv[i]);\n          break;\n        default:\n          System.err.print(\"unknown option\\n\");\n          exit_with_help();\n      }\n    }\n    if (i >= argv.length) exit_with_help();\n    try {\n      BufferedReader input = new BufferedReader(new FileReader(argv[i]));\n      DataOutputStream output = new DataOutputStream(new FileOutputStream(argv[i + 2]));\n      svm_model model = svm.svm_load_model(argv[i + 1]);\n      if (predict_probability == 1)\n        if (svm.svm_check_probability_model(model) == 0) {\n          System.err.print(\"Model does not support probabiliy estimates\\n\");\n          System.exit(1);\n        }\n      predict(input, output, model, predict_probability);\n      input.close();\n      output.close();\n    } catch (FileNotFoundException e) {\n      exit_with_help();\n    } catch (ArrayIndexOutOfBoundsException e) {\n      exit_with_help();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1586, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [79], "initializationEnd": [151], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[])"], "configurationStart": [157], "configurationEnd": [191], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 197, "focalAPIEnd": 208, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-tools/hadoop-streaming/src/test/java/org/apache/hadoop/streaming/TestTypedBytesStreaming.java", "rawCode": "  protected void createInput() throws IOException {\n    DataOutputStream out = new DataOutputStream(new FileOutputStream(INPUT_FILE.getAbsoluteFile()));\n    out.write(input.getBytes(\"UTF-8\"));\n    out.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1587, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 65, "tryExpressionEnd": 69, "tryBlockStart": 65, "tryBlockEnd": 221, "catchExpressionStart": 165, "catchExpressionEnd": 187, "catchBlockStart": 165, "catchBlockEnd": 221, "exceptionHandlingCallStart": [195], "exceptionHandlingCallEnd": [214], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.flush()"], "configurationStart": [77, 104], "configurationEnd": [96, 114], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 122, "focalAPIEnd": 132, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tpruvot/android_packages_apps_SQLiteManager/tree/master/src/dk/andsen/utils/AShellInterface.java", "rawCode": "  /** Close current shell session */\n  public void close() {\n    try {\n      os.writeBytes(EXIT);\n      os.flush();\n      os.close();\n      process.destroy();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1588, "initialization": ["DataOutputStream dataOutputStream = FileSystem.create(Path)"], "initializationStart": [303], "initializationEnd": [322], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(byte[])"], "configurationStart": [405], "configurationEnd": [419], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 425, "focalAPIEnd": 435, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop_src/hadoop-2.0.5-alpha-src/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/BlockReaderTestUtil.java", "rawCode": "  /**\n   * Create a file of the given size filled with random data.\n   *\n   * @return File data.\n   */\n  public byte[] writeFile(Path filepath, int sizeKB) throws IOException {\n    FileSystem fs = cluster.getFileSystem();\n\n    // Write a file with the specified amount of data\n    DataOutputStream os = fs.create(filepath);\n    byte data[] = new byte[1024 * sizeKB];\n    new Random().nextBytes(data);\n    os.write(data);\n    os.close();\n    return data;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1589, "initialization": ["DataOutputStream dataOutputStream = FileSystem.create(Path)"], "initializationStart": [369], "initializationEnd": [386], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [392], "configurationEnd": [424], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 430, "focalAPIEnd": 439, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/madiator/HadoopUSC/tree/master/src/test/org/apache/hadoop/mapred/TestMapRed.java", "rawCode": "  public void testPartitioner() throws Exception {\n    JobConf conf = new JobConf(TestMapRed.class);\n    conf.setPartitionerClass(BadPartitioner.class);\n    FileSystem fs = FileSystem.getLocal(conf);\n    Path testdir = new Path(System.getProperty(\"test.build.data\", \"/tmp\")).makeQualified(fs);\n    Path inFile = new Path(testdir, \"blah/blah\");\n    DataOutputStream f = fs.create(inFile);\n    f.writeBytes(\"blah blah blah\\n\");\n    f.close();\n    FileInputFormat.setInputPaths(conf, inFile);\n    FileOutputFormat.setOutputPath(conf, new Path(testdir, \"out\"));\n    conf.setMapperClass(IdentityMapper.class);\n    conf.setReducerClass(IdentityReducer.class);\n    conf.setOutputKeyClass(LongWritable.class);\n    conf.setOutputValueClass(Text.class);\n\n    // partition too low\n    conf.setBoolean(\"test.testmapred.badpartition\", true);\n    boolean pass = true;\n    try {\n      JobClient.runJob(conf);\n    } catch (IOException e) {\n      pass = false;\n    }\n    assertFalse(\"should fail for partition < 0\", pass);\n\n    // partition too high\n    conf.setBoolean(\"test.testmapred.badpartition\", false);\n    pass = true;\n    try {\n      JobClient.runJob(conf);\n    } catch (IOException e) {\n      pass = false;\n    }\n    assertFalse(\"should fail for partition >= numPartitions\", pass);\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1590, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(ByteArrayOutputStream)"], "initializationStart": [351], "initializationEnd": [379], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 436, "focalAPIEnd": 447, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/javassist_mirror/tree/master/src/main/javassist/CtClass.java", "rawCode": "  /**\n   * Converts this class to a class file. Once this method is called, further modifications are not\n   * possible any more.\n   *\n   * @return the contents of the class file.\n   */\n  public byte[] toBytecode() throws IOException, CannotCompileException {\n    ByteArrayOutputStream barray = new ByteArrayOutputStream();\n    DataOutputStream out = new DataOutputStream(barray);\n    try {\n      toBytecode(out);\n    } finally {\n      out.close();\n    }\n\n    return barray.toByteArray();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1591, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [154], "initializationEnd": [240], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 110, "tryExpressionEnd": 114, "tryBlockStart": 110, "tryBlockEnd": 1094, "catchExpressionStart": 1002, "catchExpressionEnd": 1022, "catchBlockStart": 1002, "catchBlockEnd": 1094, "exceptionHandlingCallStart": [1030], "exceptionHandlingCallEnd": [1087], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeInt(int)", "dataOutputStream.flush()"], "configurationStart": [380, 655, 698, 741, 831], "configurationEnd": [622, 684, 727, 769, 841], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 849, "focalAPIEnd": 859, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/conceptstailored/NCSU-GBS-Pipeline/tree/master/TASSEL_20121011/maizegenetics/src/net/maizegenetics/genome/GBS/ReadsByTaxa.java", "rawCode": "  protected void writeReadCountFile(File outFile, boolean binary, int minCount) {\n    int hapsOutput = 0;\n    try {\n      DataOutputStream fw =\n          new DataOutputStream(new BufferedOutputStream(new FileOutputStream(outFile), 4000000));\n      for (int i = 0; i < haplotype[0].length - 1; i++) {\n        if (getReadCount(i) >= minCount) {\n          if (!binary) {\n            fw.writeBytes(\n                BaseEncoder.getSequenceFromLong(haplotype[0][i])\n                    + BaseEncoder.getSequenceFromLong(haplotype[1][i])\n                    + \" \"\n                    + getReadCount(i)\n                    + \"\\n\");\n          } else {\n            fw.writeLong(haplotype[0][i]);\n            fw.writeLong(haplotype[1][i]);\n            fw.writeInt(getReadCount(i));\n          }\n          hapsOutput++;\n        }\n      }\n      fw.flush();\n      fw.close();\n      System.out.println(\"Reads written to:\" + outFile.toString());\n      System.out.println(\"Number of Reads in file:\" + hapsOutput);\n    } catch (Exception e) {\n      System.out.println(\"Catch in writing output file e=\" + e);\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1592, "initialization": ["DataOutputStream dataOutputStream = create(*)"], "initializationStart": [2330], "initializationEnd": [2366], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.writeBytes(String)"], "configurationStart": [2374, 2415], "configurationEnd": [2407, 2449], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 2457, "focalAPIEnd": 2469, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dataOutputStream.writeBytes(String)", "dataOutputStream.close()", "dataOutputStream.writeBytes(String)", "dataOutputStream.close()"], "useStart": [2528, 2571, 2644, 2688], "useEnd": [2563, 2583, 2680, 2700], "hasFinally": 1, "cleanUpCall": ["MiniDFSCluster.shutdown()"], "finallyExpressionStart": 3477, "finallyExpressionEnd": 3485, "finallyBlockStart": 3477, "finallyBlockEnd": 3604, "cleanUpCallStart": [3520], "cleanUpCallEnd": [3534], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop_src/hadoop-2.0.5-alpha-src/hadoop-tools/hadoop-streaming/src/test/java/org/apache/hadoop/streaming/TestMultipleCachefiles.java", "rawCode": "  @Test\n  public void testMultipleCachefiles() throws Exception {\n    boolean mayExit = false;\n    MiniMRCluster mr = null;\n    MiniDFSCluster dfs = null;\n    try {\n      Configuration conf = new Configuration();\n      dfs = new MiniDFSCluster(conf, 1, true, null);\n      FileSystem fileSys = dfs.getFileSystem();\n      String namenode = fileSys.getUri().toString();\n\n      mr = new MiniMRCluster(1, namenode, 3);\n\n      List<String> args = new ArrayList<String>();\n      for (Map.Entry<String, String> entry : mr.createJobConf()) {\n        args.add(\"-jobconf\");\n        args.add(entry.getKey() + \"=\" + entry.getValue());\n      }\n\n      String argv[] =\n          new String[] {\n            \"-input\",\n            INPUT_FILE,\n            \"-output\",\n            OUTPUT_DIR,\n            \"-mapper\",\n            map,\n            \"-reducer\",\n            reduce,\n            \"-jobconf\",\n            \"stream.tmpdir=\" + System.getProperty(\"test.build.data\", \"/tmp\"),\n            \"-jobconf\",\n            JobConf.MAPRED_MAP_TASK_JAVA_OPTS\n                + \"=\"\n                + \"-Dcontrib.name=\"\n                + System.getProperty(\"contrib.name\")\n                + \" \"\n                + \"-Dbuild.test=\"\n                + System.getProperty(\"build.test\")\n                + \" \"\n                + conf.get(\n                    JobConf.MAPRED_MAP_TASK_JAVA_OPTS, conf.get(JobConf.MAPRED_TASK_JAVA_OPTS, \"\")),\n            \"-jobconf\",\n            JobConf.MAPRED_REDUCE_TASK_JAVA_OPTS\n                + \"=\"\n                + \"-Dcontrib.name=\"\n                + System.getProperty(\"contrib.name\")\n                + \" \"\n                + \"-Dbuild.test=\"\n                + System.getProperty(\"build.test\")\n                + \" \"\n                + conf.get(\n                    JobConf.MAPRED_REDUCE_TASK_JAVA_OPTS,\n                    conf.get(JobConf.MAPRED_TASK_JAVA_OPTS, \"\")),\n            \"-cacheFile\",\n            fileSys.getUri() + CACHE_FILE + \"#\" + mapString,\n            \"-cacheFile\",\n            fileSys.getUri() + CACHE_FILE_2 + \"#\" + mapString2,\n            \"-jobconf\",\n            \"mapred.jar=\" + TestStreaming.STREAMING_JAR,\n          };\n\n      for (String arg : argv) {\n        args.add(arg);\n      }\n      argv = args.toArray(new String[args.size()]);\n\n      fileSys.delete(new Path(OUTPUT_DIR), true);\n\n      DataOutputStream file = fileSys.create(new Path(INPUT_FILE));\n      file.writeBytes(mapString + \"\\n\");\n      file.writeBytes(mapString2 + \"\\n\");\n      file.close();\n      file = fileSys.create(new Path(CACHE_FILE));\n      file.writeBytes(cacheString + \"\\n\");\n      file.close();\n      file = fileSys.create(new Path(CACHE_FILE_2));\n      file.writeBytes(cacheString2 + \"\\n\");\n      file.close();\n\n      job = new StreamJob(argv, mayExit);\n      job.go();\n\n      fileSys = dfs.getFileSystem();\n      String line = null;\n      String line2 = null;\n      Path[] fileList =\n          FileUtil.stat2Paths(\n              fileSys.listStatus(\n                  new Path(OUTPUT_DIR), new Utils.OutputFileUtils.OutputFilesFilter()));\n      for (int i = 0; i < fileList.length; i++) {\n        System.out.println(fileList[i].toString());\n        BufferedReader bread = new BufferedReader(new InputStreamReader(fileSys.open(fileList[i])));\n        line = bread.readLine();\n        System.out.println(line);\n        line2 = bread.readLine();\n        System.out.println(line2);\n      }\n      assertEquals(cacheString + \"\\t\", line);\n      assertEquals(cacheString2 + \"\\t\", line2);\n    } finally {\n      if (dfs != null) {\n        dfs.shutdown();\n      }\n      if (mr != null) {\n        mr.shutdown();\n      }\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1593, "initialization": ["DataOutputStream dataOutputStream = create(*)"], "initializationStart": [931], "initializationEnd": [969], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [977], "configurationEnd": [999], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1007, "focalAPIEnd": 1019, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop/hadoop-1.1.2/src/test/org/apache/hadoop/mapred/TestMiniMRMapRedDebugScript.java", "rawCode": "  /**\n   * Launches failed map task and debugs the failed task\n   *\n   * @param conf configuration for the mapred job\n   * @param inDir input path\n   * @param outDir output path\n   * @param debugDir debug directory where script is present\n   * @param debugCommand The command to execute script\n   * @param input Input text\n   * @return the output of debug script\n   * @throws IOException\n   */\n  public String launchFailMapAndDebug(\n      JobConf conf, Path inDir, Path outDir, Path debugDir, String debugScript, String input)\n      throws IOException {\n\n    // set up the input file system and write input text.\n    FileSystem inFs = inDir.getFileSystem(conf);\n    FileSystem outFs = outDir.getFileSystem(conf);\n    outFs.delete(outDir, true);\n    if (!inFs.mkdirs(inDir)) {\n      throw new IOException(\"Mkdirs failed to create \" + inDir.toString());\n    }\n    {\n      // write input into input file\n      DataOutputStream file = inFs.create(new Path(inDir, \"part-0\"));\n      file.writeBytes(input);\n      file.close();\n    }\n\n    // configure the mapred Job for failing map task.\n    conf.setJobName(\"failmap\");\n    conf.setMapperClass(MapClass.class);\n    conf.setReducerClass(IdentityReducer.class);\n    conf.setNumMapTasks(1);\n    conf.setNumReduceTasks(0);\n    conf.setMapDebugScript(debugScript);\n    FileInputFormat.setInputPaths(conf, inDir);\n    FileOutputFormat.setOutputPath(conf, outDir);\n    String TEST_ROOT_DIR =\n        new Path(System.getProperty(\"test.build.data\", \"/tmp\")).toString().replace(' ', '+');\n    conf.set(\"test.build.data\", TEST_ROOT_DIR);\n\n    // copy debug script to cache from local file system.\n    FileSystem debugFs = debugDir.getFileSystem(conf);\n    Path scriptPath = new Path(debugDir, \"testscript.txt\");\n    Path cachePath = new Path(\"/cacheDir\");\n    if (!debugFs.mkdirs(cachePath)) {\n      throw new IOException(\"Mkdirs failed to create \" + cachePath.toString());\n    }\n    debugFs.copyFromLocalFile(scriptPath, cachePath);\n\n    URI uri = debugFs.getUri().resolve(cachePath + \"/testscript.txt#testscript\");\n    DistributedCache.createSymlink(conf);\n    DistributedCache.addCacheFile(uri, conf);\n\n    RunningJob job = null;\n    // run the job. It will fail with IOException.\n    try {\n      job = new JobClient(conf).submitJob(conf);\n    } catch (IOException e) {\n      LOG.info(\"Running Job failed\", e);\n    }\n\n    JobID jobId = job.getID();\n    // construct the task id of first map task of failmap\n    TaskAttemptID taskId = new TaskAttemptID(new TaskID(jobId, true, 0), 0);\n    // wait for the job to finish.\n    while (!job.isComplete()) ;\n\n    // return the output of debugout log.\n    return readTaskLog(TaskLog.LogName.DEBUGOUT, taskId, false);\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1594, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [533], "initializationEnd": [607], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["showErrorMessage(*)"], "tryExpressionStart": 119, "tryExpressionEnd": 123, "tryBlockStart": 119, "tryBlockEnd": 733, "catchExpressionStart": 657, "catchExpressionEnd": 679, "catchBlockStart": 657, "catchBlockEnd": 733, "exceptionHandlingCallStart": [687], "exceptionHandlingCallEnd": [706], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 638, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/DmitriBoulanger/samples/tree/master/image/filter/AutoLocalThreshold/src-ij/ij/io/FileSaver.java", "rawCode": "  /** Save the image as tab-delimited text using the specified path. */\n  public boolean saveAsText(String path) {\n    try {\n      Calibration cal = imp.getCalibration();\n      int precision = Analyzer.getPrecision();\n      int measurements = Analyzer.getMeasurements();\n      boolean scientificNotation = (measurements & Measurements.SCIENTIFIC_NOTATION) != 0;\n      if (scientificNotation) precision = -precision;\n      TextEncoder file = new TextEncoder(imp.getProcessor(), cal, precision);\n      DataOutputStream out =\n          new DataOutputStream(new BufferedOutputStream(new FileOutputStream(path)));\n      file.write(out);\n      out.close();\n    } catch (IOException e) {\n      showErrorMessage(e);\n      return false;\n    }\n    return true;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1595, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(FileOutputStream)"], "initializationStart": [375], "initializationEnd": [400], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 168, "tryExpressionEnd": 172, "tryBlockStart": 168, "tryBlockEnd": 4308, "catchExpressionStart": 3662, "catchExpressionEnd": 3694, "catchBlockStart": 3662, "catchBlockEnd": 3828, "exceptionHandlingCallStart": [3727], "exceptionHandlingCallEnd": [3746], "configuration": ["dataOutputStream.writeBytes(String)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeLong(long)", "dataOutputStream.writeBytes(String)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeBytes(String)"], "configurationStart": [2052, 2091, 2273, 2307, 2385, 2500, 2746, 2779, 2851, 2924, 3001, 3072, 3144, 3215, 3286, 3525], "configurationEnd": [2083, 2110, 2299, 2377, 2492, 2585, 2771, 2843, 2916, 2993, 3064, 3136, 3207, 3278, 3354, 3554], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 3563, "focalAPIEnd": 3574, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dataOutputStream.close()"], "useStart": [4051], "useEnd": [4062], "hasFinally": 1, "cleanUpCall": ["DataOutputStream.close()"], "finallyExpressionStart": 3986, "finallyExpressionEnd": 3994, "finallyBlockStart": 3986, "finallyBlockEnd": 4308, "cleanUpCallStart": [4051], "cleanUpCallEnd": [4062], "url": "https://github.com/mtakemiya/BMIDesktop/tree/master/neuroshareUtils/src/jp/atr/dni/bmi/desktop/neuroshareutils/nsn/NSNCreateFile.java", "rawCode": "  private int saveFileInfo() {\n\n    int rtnVal = ConstantValues.NS_OK;\n    File tempFile = null;\n    FileOutputStream fos = null;\n    DataOutputStream dos = null;\n\n    try {\n      // Open the intermediatefile. (use FileOutputStream, DataOutputStream.)\n      tempFile = new File(this.intermediateFileNameForInfo);\n      fos = new FileOutputStream(tempFile, true);\n      dos = new DataOutputStream(fos);\n\n      // Add ns_FileInfo.\n      // Write in BIG Endian (JAVA Default)\n      /*\n       * dos.writeBytes(this.MAGICCODE); dos.writeByte(0x00); String szFileType =\n       * (this.nsFileInfo.getMembers().getSzFileType() + (new Const_values()).getBlank32())\n       * .substring(0, Const_values.CHAR32_LENGTH); dos.writeBytes(szFileType);\n       * dos.writeInt(this.nsFileInfo.getDwEntityCount());\n       * dos.writeDouble(this.nsFileInfo.getMembers().getDTimeStampResolution());\n       * dos.writeDouble(this.nsFileInfo.getMembers().getDTimeSpan()); String szAppName =\n       * (this.nsFileInfo.getMembers().getSzAppName() + (new Const_values()).getBlank64())\n       * .substring(0, (new Const_values()).getChar64()); dos.writeBytes(szAppName);\n       * dos.writeInt(this.nsFileInfo.getMembers().getDwTime_Year());\n       * dos.writeInt(this.nsFileInfo.getMembers().getDwTime_Month());\n       * dos.writeInt(this.nsFileInfo.getMembers().getDwTime_DayOfWeek());\n       * dos.writeInt(this.nsFileInfo.getMembers().getDwTime_Day());\n       * dos.writeInt(this.nsFileInfo.getMembers().getDwTime_Hour());\n       * dos.writeInt(this.nsFileInfo.getMembers().getDwTime_Min());\n       * dos.writeInt(this.nsFileInfo.getMembers().getDwTime_Sec());\n       * dos.writeInt(this.nsFileInfo.getMembers().getDwTime_MilliSec()); String szFileComment =\n       * (this.nsFileInfo.getMembers().getSzFileComment() + (new Const_values())\n       * .getBlank256()).substring(0, (new Const_values()).getChar256());\n       * dos.writeBytes(szFileComment);\n       */\n\n      // Write in LITTLE Endian (MATLAB Default)\n      NSAFileInfo nsaFileInfo = nsFileInfo.getMembers();\n\n      dos.writeBytes(this.sMagicCode);\n      dos.writeByte(0x00);\n      String szFileType =\n          (nsaFileInfo.getSzFileType() + ConstantValues.BLANK_CHAR32)\n              .substring(0, ConstantValues.CHAR32_LENGTH);\n      dos.writeBytes(szFileType);\n      dos.writeInt(Integer.reverseBytes(this.nsFileInfo.getDwEntityCount()));\n      dos.writeLong(\n          Long.reverseBytes(Double.doubleToLongBits(nsaFileInfo.getDTimeStampResolution())));\n      dos.writeLong(Long.reverseBytes(Double.doubleToLongBits(nsaFileInfo.getDTimeSpan())));\n      String szAppName =\n          (nsaFileInfo.getSzAppName() + ConstantValues.BLANK_CHAR64)\n              .substring(0, ConstantValues.CHAR64_LENGTH);\n      dos.writeBytes(szAppName);\n      dos.writeInt(Integer.reverseBytes(nsaFileInfo.getDwTime_Year()));\n      dos.writeInt(Integer.reverseBytes(nsaFileInfo.getDwTime_Month()));\n      dos.writeInt(Integer.reverseBytes(nsaFileInfo.getDwTime_DayOfWeek()));\n      dos.writeInt(Integer.reverseBytes(nsaFileInfo.getDwTime_Day()));\n      dos.writeInt(Integer.reverseBytes(nsaFileInfo.getDwTime_Hour()));\n      dos.writeInt(Integer.reverseBytes(nsaFileInfo.getDwTime_Min()));\n      dos.writeInt(Integer.reverseBytes(nsaFileInfo.getDwTime_Sec()));\n      dos.writeInt(Integer.reverseBytes(nsaFileInfo.getDwTime_MilliSec()));\n      String szFileComment =\n          (nsaFileInfo.getSzFileComment() + ConstantValues.BLANK_CHAR256)\n              .substring(0, ConstantValues.CHAR256_LENGTH);\n      dos.writeBytes(szFileComment);\n\n      dos.close();\n      fos.close();\n\n      // Then, NS_OK.\n      rtnVal = ConstantValues.NS_OK;\n\n    } catch (FileNotFoundException e) {\n      // File Not Found.\n      e.printStackTrace();\n\n      // Then, NS_FILEERROR.\n      rtnVal = ConstantValues.NS_FILEERROR;\n\n    } catch (IOException e) {\n      // File I/O error.\n      e.printStackTrace();\n\n      // Then, NS_FILEERROR.\n      rtnVal = ConstantValues.NS_FILEERROR;\n\n    } finally {\n      try {\n        if (!dos.equals(null)) {\n          dos.close();\n        }\n        if (!fos.equals(null)) {\n          fos.close();\n        }\n\n      } catch (IOException e) {\n        // May be sequence doesn't reach here.\n        e.printStackTrace();\n        rtnVal = ConstantValues.NS_FILEERROR;\n      }\n    }\n\n    // return the value.\n    return rtnVal;\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1596, "initialization": ["DataOutputStream dataOutputStream = Writer.prepareAppendKey(int)"], "initializationStart": [113], "initializationEnd": [139], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.write(String)"], "configurationStart": [145], "configurationEnd": [176], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 182, "focalAPIEnd": 196, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dataOutputStream.close()", "dataOutputStream.close()"], "useStart": [479, 501], "useEnd": [493, 515], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/Hadoop-mdfs/tree/master/hadoop-1.2.1/src/test/org/apache/hadoop/io/file/tfile/TestTFileStreams.java", "rawCode": "  public void testFailureValueTooLong() throws IOException {\n    if (skip) return;\n    DataOutputStream outKey = writer.prepareAppendKey(4);\n    outKey.write(\"key0\".getBytes());\n    outKey.close();\n    DataOutputStream outValue = writer.prepareAppendValue(3);\n    try {\n      outValue.write(\"value0\".getBytes());\n      outValue.close();\n      Assert.fail(\"Value is longer than expected.\");\n    } catch (Exception e) {\n      // noop, expecting an exception\n    }\n\n    try {\n      outKey.close();\n      outKey.close();\n    } catch (Exception e) {\n      Assert.fail(\"Second or more close() should have no effect.\");\n    }\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1597, "initialization": ["DataOutputStream dataOutputStream = FileSystem.create(Path)"], "initializationStart": [104], "initializationEnd": [124], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [130], "configurationEnd": [151], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 157, "focalAPIEnd": 168, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nourlcn/yarn-comment/tree/master/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/TestLocalDFS.java", "rawCode": "  private void writeFile(FileSystem fileSys, Path name) throws IOException {\n    DataOutputStream stm = fileSys.create(name);\n    stm.writeBytes(\"oom\");\n    stm.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1598, "initialization": ["DataOutputStream dataOutputStream = FileSystem.create(Path)"], "initializationStart": [176], "initializationEnd": [188], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeBytes(String)"], "configurationStart": [210], "configurationEnd": [251], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 279, "focalAPIEnd": 290, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop/hadoop-1.1.2/src/test/org/apache/hadoop/tools/TestDistCh.java", "rawCode": "    Path createSmallFile(Path dir) throws IOException {\n      final Path f = new Path(dir, \"f\" + ++fcount);\n      assertTrue(!fs.exists(f));\n      final DataOutputStream out = fs.create(f);\n      try {\n        out.writeBytes(\"createSmallFile: f=\" + f);\n      } finally {\n        out.close();\n      }\n      assertTrue(fs.exists(f));\n      return f;\n    }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1599, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [1460], "initializationEnd": [1536], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeInt(int)", "dataOutputStream.writeFloat(int)"], "configurationStart": [1542, 1566, 1590, 5041, 5176, 5276, 5316], "configurationEnd": [1560, 1584, 1611, 5056, 5198, 5304, 5341], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 5371, "focalAPIEnd": 5382, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fozziethebeat/S-Space/tree/master/src/main/java/edu/ucla/sspace/matrix/MatrixIO.java", "rawCode": "  /**\n   * Reads in a matrix in the {@link Format#MATLAB_SPARSE} format and writes it to the output file\n   * in {@link Format#SVDLIBC_SPARSE_BINARY} format.\n   */\n  private static void matlabToSvdlibcSparseBinary(File input, File output, boolean transpose)\n      throws IOException {\n    MATRIX_IO_LOGGER.info(\n        \"Converting from Matlab double values to \"\n            + \"SVDLIBC float values; possible loss of \"\n            + \"precision\");\n    BufferedReader br = new BufferedReader(new FileReader(input));\n    Map<Integer, Integer> colToNonZero = new HashMap<Integer, Integer>();\n\n    // read through once to get matrix dimensions\n    int rows = 0, cols = 0, nonZero = 0;\n    for (String line = null; (line = br.readLine()) != null; ) {\n      String[] rowColVal = line.split(\"\\\\s+\");\n      int row, col;\n      if (transpose) {\n        row = Integer.parseInt(rowColVal[1]);\n        col = Integer.parseInt(rowColVal[0]);\n      } else {\n        row = Integer.parseInt(rowColVal[0]);\n        col = Integer.parseInt(rowColVal[1]);\n      }\n      if (row > rows) rows = row;\n      if (col > cols) cols = col;\n      ++nonZero;\n\n      // NOTE: subtract by 1 here because Matlab arrays start at 1, while\n      // SVDLIBC arrays start at 0.\n      Integer colCount = colToNonZero.get(col - 1);\n      colToNonZero.put(col - 1, (colCount == null) ? 1 : colCount + 1);\n    }\n    br.close();\n\n    // Print out the header information\n    DataOutputStream dos =\n        new DataOutputStream(new BufferedOutputStream(new FileOutputStream(output)));\n    dos.writeInt(rows);\n    dos.writeInt(cols);\n    dos.writeInt(nonZero);\n\n    // Process the entire array in chunks in case the matlab array is too\n    // big to fit into memory.\n\n    // REMINDER: this should probably be chosen based on the number of rows\n    // and their expected density\n    int chunkSize = 1000;\n\n    // This keeps track of the last columns printed. We need this outside\n    // the loop to ensure that blank columns at the end of a chunk are still\n    // printed by the next non-zero chunk\n    int lastCol = -1;\n\n    // lower bound inclusive, upper bound exclusive\n    for (int lowerBound = 0, upperBound = chunkSize;\n        lowerBound < rows;\n        lowerBound = upperBound, upperBound += chunkSize) {\n      // Once the dimensions and number of non-zero values are known,\n      // reprocess the matrix, storing the rows and values for each column\n      // that are inside the bounds\n      br = new BufferedReader(new FileReader(input));\n\n      // for each column, keep track of which in the next index into the\n      // rows array that should be used to store the row index. Also keep\n      // track of the value associated for that row\n      int[] colIndices = new int[cols];\n\n      // columns are kept in sorted order\n      SortedMap<Integer, int[]> colToRowIndex = new TreeMap<Integer, int[]>();\n      SortedMap<Integer, float[]> colToRowValues = new TreeMap<Integer, float[]>();\n\n      for (String line = null; (line = br.readLine()) != null; ) {\n        String[] rowColVal = line.split(\"\\\\s+\");\n        int row, col;\n        if (transpose) {\n          row = Integer.parseInt(rowColVal[1]) - 1;\n          col = Integer.parseInt(rowColVal[0]) - 1;\n        } else {\n          row = Integer.parseInt(rowColVal[0]) - 1;\n          col = Integer.parseInt(rowColVal[1]) - 1;\n        }\n        // NOTE: SVDLIBC uses floats instead of doubles, which can cause\n        // a loss of precision\n        float val = Double.valueOf(rowColVal[2]).floatValue();\n\n        // check that the current column is within the current chunk\n        if (col < lowerBound || col >= upperBound) continue;\n\n        // get the arrays used to store the non-zero row indices for\n        // this column and the parallel array that stores the\n        // row-index's value\n        int[] rowIndices = colToRowIndex.get(col);\n        float[] rowValues = colToRowValues.get(col);\n        if (rowIndices == null) {\n          rowIndices = new int[colToNonZero.get(col)];\n          rowValues = new float[colToNonZero.get(col)];\n          colToRowIndex.put(col, rowIndices);\n          colToRowValues.put(col, rowValues);\n        }\n\n        // determine what is the current index in the non-zero row array\n        // that can be used to store this row.\n        int curColIndex = colIndices[col];\n        rowIndices[curColIndex] = row;\n        rowValues[curColIndex] = val;\n        colIndices[col] += 1;\n      }\n      br.close();\n\n      // loop through the stored column and row values, printing out for\n      // each column, the number of non zero rows, followed by each row\n      // index and the value. This is the SVDLIBC sparse text format.\n      for (Map.Entry<Integer, int[]> e : colToRowIndex.entrySet()) {\n        int col = e.getKey().intValue();\n        int[] nonZeroRows = e.getValue();\n        float[] values = colToRowValues.get(col);\n\n        if (col != lastCol) {\n          // print any missing columns in case not all the columns\n          // have data\n          for (int i = lastCol + 1; i < col; ++i) dos.writeInt(0);\n\n          // print the new header\n          int colCount = colToNonZero.get(col);\n          lastCol = col;\n          dos.writeInt(colCount);\n        }\n\n        for (int i = 0; i < nonZeroRows.length; ++i) {\n          dos.writeInt(nonZeroRows[i]);\n          dos.writeFloat(values[i]);\n        }\n      }\n    }\n    dos.close();\n  }\n"}, {"dataset": "dataOutputStreamClose", "exampleID": 1600, "initialization": ["DataOutputStream dataOutputStream = new DataOutputStream(*)"], "initializationStart": [301], "initializationEnd": [355], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["dataOutputStream.writeByte(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeShort(int)", "dataOutputStream.writeShort(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeShort(int)", "dataOutputStream.writeShort(int)", "dataOutputStream.writeShort(int)", "dataOutputStream.writeShort(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeByte(int)", "dataOutputStream.writeByte(int)"], "configurationStart": [379, 426, 474, 531, 574, 617, 666, 709, 781, 839, 922, 1096, 1140, 1313, 1535, 1581, 1627, 1701], "configurationEnd": [402, 449, 497, 568, 611, 640, 703, 746, 833, 892, 946, 1119, 1164, 1336, 1571, 1617, 1663, 1737], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = dataOutputStream.close()", "focalAPIStart": 1768, "focalAPIEnd": 1779, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nam0r/Devint/tree/master/Slick/Slick/src/org/newdawn/slick/imageout/TGAWriter.java", "rawCode": "  /**\n   * @see org.newdawn.slick.imageout.ImageWriter#saveImage(org.newdawn.slick.Image,\n   *     java.lang.String, java.io.OutputStream, boolean)\n   */\n  public void saveImage(Image image, String format, OutputStream output, boolean writeAlpha)\n      throws IOException {\n    DataOutputStream out = new DataOutputStream(new BufferedOutputStream(output));\n\n    // ID Length\n    out.writeByte((byte) 0);\n\n    // Color Map\n    out.writeByte((byte) 0);\n\n    // Image Type\n    out.writeByte((byte) 2);\n\n    // Color Map - Ignored\n    out.writeShort(flipEndian((short) 0));\n    out.writeShort(flipEndian((short) 0));\n    out.writeByte((byte) 0);\n\n    // X, Y Offset\n    out.writeShort(flipEndian((short) 0));\n    out.writeShort(flipEndian((short) 0));\n\n    // Width, Height, Depth\n    out.writeShort(flipEndian((short) image.getWidth()));\n    out.writeShort(flipEndian((short) image.getHeight()));\n    if (writeAlpha) {\n      out.writeByte((byte) 32);\n      // Image Descriptor (can't be 0 since we're using 32-bit TGAs)\n      // needs to not have 0x20 set to indicate it's not a flipped image\n      out.writeByte((byte) 1);\n    } else {\n      out.writeByte((byte) 24);\n      // Image Descriptor (must be 0 since we're using 24-bit TGAs)\n      // needs to not have 0x20 set to indicate it's not a flipped image\n      out.writeByte((byte) 0);\n    }\n\n    // Write out the image data\n    Color c;\n\n    for (int y = 0; y < image.getHeight(); y++) {\n      for (int x = 0; x < image.getWidth(); x++) {\n        c = image.getColor(x, y);\n\n        out.writeByte((byte) (c.b * 255.0f));\n        out.writeByte((byte) (c.g * 255.0f));\n        out.writeByte((byte) (c.r * 255.0f));\n        if (writeAlpha) {\n          out.writeByte((byte) (c.a * 255.0f));\n        }\n      }\n    }\n\n    out.close();\n  }\n"}]