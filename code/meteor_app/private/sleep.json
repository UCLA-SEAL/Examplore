[{"dataset": "sleep", "exampleID": 9401, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["currentThread()", "interrupt()"], "tryExpressionStart": 44, "tryExpressionEnd": 48, "tryBlockStart": 44, "tryBlockEnd": 195, "catchExpressionStart": 108, "catchExpressionEnd": 142, "catchBlockStart": 108, "catchBlockEnd": 195, "exceptionHandlingCallStart": [152, 152], "exceptionHandlingCallEnd": [174, 186], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 58, "focalAPIEnd": 80, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.currentThread()"], "useStart": [152], "useEnd": [174], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/commons-jexl/tree/master/src/test/java/org/apache/commons/jexl3/ScriptCallableTest.java", "rawCode": "    public int waitInterrupt(int s) {\n      try {\n        Thread.sleep(1000 * s);\n        return s;\n      } catch (InterruptedException xint) {\n        Thread.currentThread().interrupt();\n      }\n      return -1;\n    }\n"}, {"dataset": "sleep", "exampleID": 9402, "initialization": ["long miliseconds = new Long(*)"], "initializationStart": [322], "initializationEnd": [343], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["new TestSuiteException(String,*)"], "tryExpressionStart": 349, "tryExpressionEnd": 353, "tryBlockStart": 349, "tryBlockEnd": 514, "catchExpressionStart": 392, "catchExpressionEnd": 423, "catchBlockStart": 392, "catchBlockEnd": 514, "exceptionHandlingCallStart": [437], "exceptionHandlingCallEnd": [507], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 361, "focalAPIEnd": 384, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Testium/testium/tree/master/src/main/java/net/sf/testium/executor/general/Wait.java", "rawCode": "  @Override\n  protected void doExecute(\n      RunTimeData aVariables, ParameterArrayList parameters, TestStepCommandResult result)\n      throws Exception {\n    int time = (Integer) this.obtainValue(aVariables, parameters, PARSPEC_TIME);\n    result.setDisplayName(this.toString() + \" \" + time + \"s\");\n\n    long sleeptime = new Long(time * 1000);\n    try {\n      Thread.sleep(sleeptime);\n    } catch (InterruptedException e) {\n      throw new TestSuiteException(\"Test Step \" + COMMAND + \" was interrupted\", e);\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9403, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 4716, "focalAPIEnd": 4747, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta12/kernel-impl/src/main/java/org/sakaiproject/cluster/impl/SakaiClusterService.java", "rawCode": "    /**\n     * Run the maintenance thread. Every REFRESH seconds, re-register this app server as alive in\n     * the cluster. Then check for any cluster entries that are more than EXPIRED seconds old,\n     * indicating a failed app server, and remove that record, that server's sessions, generating\n     * appropriate session events so the other app servers know what's going on. The \"then\" checks\n     * need not be done each iteration - run them on 1 of n randomly choosen iterations. In a\n     * clustered environment, this also distributes the work over the cluster better.\n     */\n    public void run() {\n      // wait till things are rolling\n      ComponentManager.waitTillConfigured();\n\n      if (M_log.isDebugEnabled()) M_log.debug(\"run()\");\n\n      while (!m_maintenanceCheckerStop) {\n        try {\n          final String serverIdInstance = m_serverConfigurationService.getServerIdInstance();\n\n          if (M_log.isDebugEnabled()) M_log.debug(\"checking...\");\n\n          // if we have been closed, reopen!\n          String statement = clusterServiceSql.getReadServerSql();\n          Object[] fields = new Object[1];\n          fields[0] = serverIdInstance;\n          List results = m_sqlService.dbRead(statement, fields, null);\n          if (results.isEmpty()) {\n            M_log.warn(\n                \"run(): server has been closed in cluster table, reopened: \" + serverIdInstance);\n\n            statement = clusterServiceSql.getInsertServerSql();\n            fields[0] = serverIdInstance;\n            boolean ok = m_sqlService.dbWrite(statement, fields);\n            if (!ok) {\n              M_log.warn(\"start(): dbWrite failed\");\n            }\n          }\n\n          // update our alive and well status\n          else {\n            // register that this app server is alive and well\n            statement = clusterServiceSql.getUpdateServerSql();\n            fields[0] = serverIdInstance;\n            boolean ok = m_sqlService.dbWrite(statement, fields);\n            if (!ok) {\n              M_log.warn(\"run(): dbWrite failed: \" + statement);\n            }\n          }\n\n          // pick a random number, 0..99, to see if we want to do the full ghosting / cleanup\n          // activities now\n          int rand = (int) (Math.random() * 100.0);\n          if (rand < m_ghostingPercent) {\n            // get all expired open app servers not me\n            statement = clusterServiceSql.getListExpiredServers(m_expired);\n            // setup the fields to skip reading me!\n            fields[0] = serverIdInstance;\n\n            List instances = m_sqlService.dbRead(statement, fields, null);\n\n            // close any severs found to be expired\n            for (Iterator iInstances = instances.iterator(); iInstances.hasNext(); ) {\n              String serverId = (String) iInstances.next();\n\n              // close the server - delete the record\n              statement = clusterServiceSql.getDeleteServerSql();\n              fields[0] = serverId;\n              boolean ok = m_sqlService.dbWrite(statement, fields);\n              if (!ok) {\n                M_log.warn(\"run(): dbWrite failed: \" + statement);\n              }\n\n              M_log.warn(\n                  \"run(): ghost-busting server: \" + serverId + \" from : \" + serverIdInstance);\n            }\n\n            // Close all sessions left over from deleted servers.\n            int nbrClosed = m_usageSessionService.closeSessionsOnInvalidServers(getServers());\n            if ((nbrClosed > 0) && M_log.isInfoEnabled())\n              M_log.info(\"Closed \" + nbrClosed + \" orphaned usage session records\");\n\n            // Delete any orphaned locks from closed or missing sessions.\n            statement = clusterServiceSql.getOrphanedLockSessionsSql();\n            List sessions = m_sqlService.dbRead(statement);\n            if (sessions.size() > 0) {\n              if (M_log.isInfoEnabled())\n                M_log.info(\n                    \"Found \" + sessions.size() + \" closed or deleted sessions in lock table\");\n              statement = clusterServiceSql.getDeleteLocksSql();\n              for (Iterator iSessions = sessions.iterator(); iSessions.hasNext(); ) {\n                fields[0] = (String) iSessions.next();\n                boolean ok = m_sqlService.dbWrite(statement, fields);\n                if (!ok) {\n                  M_log.warn(\"run(): dbWrite failed: \" + statement);\n                }\n              }\n            }\n          }\n        } catch (Throwable e) {\n          M_log.warn(\"exception: \", e);\n        } finally {\n          // clear out any current access bindings\n          m_threadLocalManager.clear();\n        }\n\n        // cycle every REFRESH seconds\n        if (!m_maintenanceCheckerStop) {\n          try {\n            Thread.sleep(m_refresh * 1000L);\n          } catch (Exception ignore) {\n          }\n        }\n      }\n\n      if (M_log.isDebugEnabled()) M_log.debug(\"done\");\n    }\n"}, {"dataset": "sleep", "exampleID": 9404, "initialization": ["long miliseconds = parseLong(String)"], "initializationStart": [610], "initializationEnd": [632], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 638, "focalAPIEnd": 655, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thihy/lucene/tree/master/solr/core/src/test/org/apache/solr/core/TestSolrDeletionPolicy1.java", "rawCode": "  @Test\n  public void testCommitAge() throws InterruptedException {\n    assumeFalse(\n        \"This test is not working on Windows (or maybe machines with only 2 CPUs)\",\n        Constants.WINDOWS);\n\n    IndexDeletionPolicyWrapper delPolicy = h.getCore().getDeletionPolicy();\n    addDocs();\n    Map<Long, IndexCommit> commits = delPolicy.getCommits();\n    IndexCommit ic = delPolicy.getLatestCommit();\n    String agestr =\n        ((SolrDeletionPolicy) (delPolicy.getWrappedDeletionPolicy()))\n            .getMaxCommitAge()\n            .replaceAll(\"[a-zA-Z]\", \"\")\n            .replaceAll(\"-\", \"\");\n    long age = Long.parseLong(agestr);\n    Thread.sleep(age);\n\n    assertU(adoc(\"id\", String.valueOf(6), \"name\", \"name\" + String.valueOf(6)));\n    assertU(optimize());\n    assertQ(\"return all docs\", req(\"id:[0 TO 6]\"), \"*[count(//doc)=6]\");\n\n    commits = delPolicy.getCommits();\n    assertTrue(!commits.containsKey(ic.getGeneration()));\n  }\n"}, {"dataset": "sleep", "exampleID": 9405, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["getName()", "getLogger(*)", "log(*,*,*)"], "tryExpressionStart": 325, "tryExpressionEnd": 329, "tryBlockStart": 325, "tryBlockEnd": 520, "catchExpressionStart": 401, "catchExpressionEnd": 433, "catchBlockStart": 401, "catchBlockEnd": 520, "exceptionHandlingCallStart": [458, 441, 441], "exceptionHandlingCallEnd": [484, 485, 513], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 337, "focalAPIEnd": 359, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tdubourg/packaging-simulator/tree/master/ihm/client/src/IHM/GameOverPopup.java", "rawCode": "  /**\n   * Shutdown client and server after cliking on button \"Terminer...\"\n   *\n   * @param evt click on button \"Terminer définitivement la production\"\n   */\n  private void jB_ShutdownActionPerformed(\n      java.awt.event.ActionEvent evt) { // GEN-FIRST:event_jB_ShutdownActionPerformed\n    this.command.sendShutdown();\n    try {\n      Thread.sleep(1 * 1000); // Wait for server to shutdown...\n    } catch (InterruptedException ex) {\n      Logger.getLogger(ErrorPopup.class.getName()).log(Level.SEVERE, null, ex);\n    }\n    System.exit(0); // Shutdown the client app\n  } // GEN-LAST:event_jB_ShutdownActionPerformed\n"}, {"dataset": "sleep", "exampleID": 9406, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 182, "focalAPIEnd": 206, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mccoyst/tact/tree/master/src/edu/unh/cs/files/SendFile.java", "rawCode": "  public void sendFile(File f) {\n    System.err.printf(\" Start sending %s by %s%n\", f, Thread.currentThread().getName());\n    long time = System.currentTimeMillis();\n    try {\n      Thread.sleep(f.duration);\n    } catch (InterruptedException e) {\n      return;\n    }\n    time = System.currentTimeMillis() - time;\n    System.err.printf(\" %s sent in %.2f seconds%n\", f, time / 1000.0);\n  }\n"}, {"dataset": "sleep", "exampleID": 9407, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["unexpectedException()"], "tryExpressionStart": 533, "tryExpressionEnd": 537, "tryBlockStart": 533, "tryBlockEnd": 686, "catchExpressionStart": 618, "catchExpressionEnd": 650, "catchBlockStart": 618, "catchBlockEnd": 686, "exceptionHandlingCallStart": [658], "exceptionHandlingCallEnd": [679], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 545, "focalAPIEnd": 573, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/concurrent/src/test/java/tests/api/java/util/concurrent/SynchronousQueueTest.java", "rawCode": "  /** Interrupted timed poll throws InterruptedException instead of returning timeout status */\n  public void testFairInterruptedTimedPoll() {\n    Thread t =\n        new Thread(\n            new Runnable() {\n              public void run() {\n                try {\n                  SynchronousQueue q = new SynchronousQueue(true);\n                  assertNull(q.poll(SHORT_DELAY_MS, TimeUnit.MILLISECONDS));\n                } catch (InterruptedException success) {\n                }\n              }\n            });\n    t.start();\n    try {\n      Thread.sleep(SHORT_DELAY_MS);\n      t.interrupt();\n      t.join();\n    } catch (InterruptedException ie) {\n      unexpectedException();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9408, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["org.slf4j.Logger.warn(String)"], "tryExpressionStart": 410, "tryExpressionEnd": 414, "tryBlockStart": 410, "tryBlockEnd": 853, "catchExpressionStart": 500, "catchExpressionEnd": 537, "catchBlockStart": 500, "catchBlockEnd": 853, "exceptionHandlingCallStart": [545], "exceptionHandlingCallEnd": [622], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 422, "focalAPIEnd": 492, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mehant/incubator-drill/tree/master/exec/java-exec/src/main/java/org/apache/drill/exec/server/Drillbit.java", "rawCode": "  @Override\n  public synchronized void close() {\n    // avoid complaints about double closing\n    if (isClosed) {\n      return;\n    }\n    final Stopwatch w = new Stopwatch().start();\n    logger.debug(\"Shutdown begun.\");\n\n    // wait for anything that is running to complete\n    manager.waitToExit();\n\n    if (coord != null && registrationHandle != null) {\n      coord.unregister(registrationHandle);\n    }\n    try {\n      Thread.sleep(context.getConfig().getInt(ExecConstants.ZK_REFRESH) * 2);\n    } catch (final InterruptedException e) {\n      logger.warn(\"Interrupted while sleeping during coordination deregistration.\");\n\n      // Preserve evidence that the interruption occurred so that code higher up on the call stack\n      // can learn of the\n      // interruption and respond to it if it wants to.\n      Thread.currentThread().interrupt();\n    }\n\n    // TODO these should use a DeferredException\n    AutoCloseables.close(webServer, logger);\n    AutoCloseables.close(engine, logger);\n    AutoCloseables.close(storeProvider, logger);\n    AutoCloseables.close(coord, logger);\n    AutoCloseables.close(manager, logger);\n    AutoCloseables.close(context, logger);\n\n    logger.info(\"Shutdown completed ({} ms).\", w.elapsed(TimeUnit.MILLISECONDS));\n    isClosed = true;\n  }\n"}, {"dataset": "sleep", "exampleID": 9409, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 745, "tryExpressionEnd": 749, "tryBlockStart": 745, "tryBlockEnd": 857, "catchExpressionStart": 792, "catchExpressionEnd": 823, "catchBlockStart": 792, "catchBlockEnd": 857, "exceptionHandlingCallStart": [831], "exceptionHandlingCallEnd": [850], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 757, "focalAPIEnd": 784, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/egelmex/PlugableBot/tree/master/EmailReader/trunk/src/EmailReader/Connection.java", "rawCode": "  private void read(javax.mail.Store store, String mailbox) {\n    System.out.println(\"reading mailbox\");\n    try {\n      Folder folder = store.getFolder(mailbox);\n\n      folder.open(Folder.READ_WRITE);\n\n      // Get directory\n      Message message[] = folder.getMessages();\n\n      for (int i = 0, n = message.length; (i < n) && running; i++) {\n        for (String chan : props.getProperty(\"channels\").split(\",\")) {\n          System.out.println(chan.trim() + \" : \" + message[i].getSubject());\n          reader.bot.Message(chan.trim(), \"email: \" + message[i].getSubject());\n        }\n        message[i].setFlag(Flags.Flag.DELETED, true);\n      }\n\n      folder.close(true);\n    } catch (MessagingException e) {\n      e.printStackTrace();\n    }\n    try {\n      Thread.sleep(2 * 60 * 1000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9410, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 645, "focalAPIEnd": 662, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ybrs/hazelcastforked/tree/master/hazelcast-client/src/test/java/com/hazelcast/client/HazelcastClientMapTest.java", "rawCode": "  @Test\n  public void testIssue321_2() throws Exception {\n    HazelcastClient hClient = getHazelcastClient();\n    final IMap<Integer, Integer> imap = hClient.getMap(\"testIssue321_2\");\n    final BlockingQueue<EntryEvent<Integer, Integer>> events1 =\n        new LinkedBlockingQueue<EntryEvent<Integer, Integer>>();\n    final BlockingQueue<EntryEvent<Integer, Integer>> events2 =\n        new LinkedBlockingQueue<EntryEvent<Integer, Integer>>();\n    imap.addEntryListener(\n        new EntryAdapter() {\n          @Override\n          public void entryAdded(EntryEvent event) {\n            events1.add(event);\n          }\n        },\n        true);\n    Thread.sleep(50L);\n    imap.addEntryListener(\n        new EntryAdapter() {\n          @Override\n          public void entryAdded(EntryEvent event) {\n            events2.add(event);\n          }\n        },\n        false);\n    imap.put(1, 1);\n    final EntryEvent<Integer, Integer> event1 = events1.poll(10, TimeUnit.MILLISECONDS);\n    final EntryEvent<Integer, Integer> event2 = events2.poll(10, TimeUnit.MILLISECONDS);\n    assertNotNull(event1);\n    assertNotNull(event2);\n    assertNotNull(event1.getValue());\n    assertNull(event2.getValue());\n  }\n"}, {"dataset": "sleep", "exampleID": 9411, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 549, "focalAPIEnd": 566, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ybrs/hazelcastforked/tree/master/hazelcast-client/src/test/java/com/hazelcast/client/HazelcastClientMapTest.java", "rawCode": "  @Test\n  public void testIssue321_3() throws Exception {\n    HazelcastClient hClient = getHazelcastClient();\n    final IMap<Integer, Integer> imap = hClient.getMap(\"testIssue321_3\");\n    final BlockingQueue<EntryEvent<Integer, Integer>> events =\n        new LinkedBlockingQueue<EntryEvent<Integer, Integer>>();\n    final EntryAdapter listener =\n        new EntryAdapter() {\n          @Override\n          public void entryAdded(EntryEvent event) {\n            events.add(event);\n          }\n        };\n    imap.addEntryListener(listener, true);\n    Thread.sleep(50L);\n    imap.addEntryListener(listener, false);\n    imap.put(1, 1);\n    final EntryEvent<Integer, Integer> event1 = events.poll(10, TimeUnit.MILLISECONDS);\n    final EntryEvent<Integer, Integer> event2 = events.poll(10, TimeUnit.MILLISECONDS);\n    assertNotNull(event1);\n    assertNotNull(event2);\n    assertNotNull(event1.getValue());\n    assertNull(event2.getValue());\n  }\n"}, {"dataset": "sleep", "exampleID": 9412, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 47, "tryExpressionEnd": 51, "tryBlockStart": 47, "tryBlockEnd": 139, "catchExpressionStart": 85, "catchExpressionEnd": 105, "catchBlockStart": 85, "catchBlockEnd": 139, "exceptionHandlingCallStart": [113], "exceptionHandlingCallEnd": [132], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 59, "focalAPIEnd": 77, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jeffreyawest/WInS_Demos/tree/master/jms-examples/jms-store-and-forward/saf-sender/src/main/java/com/oracle/example/jms/producer/WLJMSProducer.java", "rawCode": "  protected static void sleep(long time) {\n    try {\n      Thread.sleep(time);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9413, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 366, "focalAPIEnd": 393, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/funambol-mirror/funambol-client-sdk/tree/master/us8885/common/src/test/java-me/com/funambol/TestServerHttpTransportAgent.java", "rawCode": "  /**\n   * Send a message to the channel\n   *\n   * @param msg the message to be sent\n   * @throws IOException if the message cannot be sent\n   */\n  public void sendMessage() throws IOException {\n    try {\n      Log.debug(\n          \"[TestServerHttpTransportAgent] waiting \"\n              + delayResponse / 1000\n              + \" sec before to send message \");\n      Thread.sleep(delayResponse);\n    } catch (InterruptedException ex) {\n    }\n    os.write(response.getBytes());\n    os.flush();\n    Log.debug(\"[TestServerHttpTransportAgent.sendMessage]Message sent: \" + response);\n  }\n"}, {"dataset": "sleep", "exampleID": 9414, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 894, "focalAPIEnd": 912, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MrZoraman/WarpSuite/tree/master/WarpSuite/src/com/mrz/dyndns/server/warpsuite/evilmidget38/UUIDFetcher.java", "rawCode": "  public Map<String, UUID> call() throws Exception {\n    Map<String, UUID> uuidMap = new HashMap<String, UUID>();\n    int requests = (int) Math.ceil(names.size() / PROFILES_PER_REQUEST);\n    for (int i = 0; i < requests; i++) {\n      HttpURLConnection connection = createConnection();\n      String body =\n          JSONArray.toJSONString(names.subList(i * 100, Math.min((i + 1) * 100, names.size())));\n      writeBody(connection, body);\n      JSONArray array =\n          (JSONArray) jsonParser.parse(new InputStreamReader(connection.getInputStream()));\n      for (Object profile : array) {\n        JSONObject jsonProfile = (JSONObject) profile;\n        String id = (String) jsonProfile.get(\"id\");\n        String name = (String) jsonProfile.get(\"name\");\n        UUID uuid = UUIDFetcher.getUUID(id);\n        uuidMap.put(name, uuid);\n      }\n      if (rateLimiting && i != requests - 1) {\n        Thread.sleep(100L);\n      }\n    }\n    return uuidMap;\n  }\n"}, {"dataset": "sleep", "exampleID": 9415, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["unexpectedException()"], "tryExpressionStart": 602, "tryExpressionEnd": 606, "tryBlockStart": 602, "tryBlockEnd": 769, "catchExpressionStart": 702, "catchExpressionEnd": 733, "catchBlockStart": 702, "catchBlockEnd": 769, "exceptionHandlingCallStart": [741], "exceptionHandlingCallEnd": [762], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 614, "focalAPIEnd": 642, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arjunroy/cinder_dalvik/tree/master/libcore/concurrent/src/test/java/tests/api/java/util/concurrent/AbstractQueuedSynchronizerTest.java", "rawCode": "  /** acquireSharedTimed times out if not released before timeout */\n  public void testAcquireSharedNanos_Timeout() {\n    final BooleanLatch l = new BooleanLatch();\n    Thread t =\n        new Thread(\n            new Runnable() {\n              public void run() {\n                try {\n                  threadAssertFalse(l.isSignalled());\n                  threadAssertFalse(l.tryAcquireSharedNanos(0, SMALL_DELAY_MS * 1000 * 1000));\n                } catch (InterruptedException ie) {\n                  threadUnexpectedException();\n                }\n              }\n            });\n    t.start();\n    try {\n      Thread.sleep(SHORT_DELAY_MS);\n      assertFalse(l.isSignalled());\n      t.join();\n    } catch (InterruptedException e) {\n      unexpectedException();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9416, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 476, "focalAPIEnd": 495, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zeromq/jzmq-api/tree/master/src/test/java/guide/psenvpub.java", "rawCode": "  public static void main(String[] args) throws InterruptedException {\n    ManagedContext context = new ManagedContext();\n    Socket publisher = context.buildSocket(SocketType.PUB).bind(\"tcp://*:5563\");\n\n    while (true) {\n      publisher.send(\"A\".getBytes(), MessageFlag.SEND_MORE);\n      publisher.send(\"We don't want to see this\".getBytes());\n\n      publisher.send(\"B\".getBytes(), MessageFlag.SEND_MORE);\n      publisher.send(\"We would like to see this\".getBytes());\n      Thread.sleep(1000L);\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9417, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 1629, "tryExpressionEnd": 1633, "tryBlockStart": 1629, "tryBlockEnd": 1783, "catchExpressionStart": 1677, "catchExpressionEnd": 1708, "catchBlockStart": 1677, "catchBlockEnd": 1783, "exceptionHandlingCallStart": [1757], "exceptionHandlingCallEnd": [1776], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 1641, "focalAPIEnd": 1669, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnnyeven/godwar-server/tree/master/GodwarGameServer/src/com/xgame/server/game/GameServer.java", "rawCode": "  public void run() {\n    System.out.println(\" MMMM\");\n    System.out.println(\" MMM MMM MMMMMMM MMMMMMMM\");\n    System.out.println(\" MMM MMM MMMMMMMMM MMMMMMMM\");\n    System.out.println(\" MMM MMM MMMM MMM MM\");\n    System.out.println(\" MMM MMM MMM MMM MMM MM MMM MMM MM\");\n    System.out.println(\" MMMMMM MMM MM MMMMMM MMMMMMMMMMMMM MM\");\n    System.out.println(\" MMMMMM MMM MMMMMMM MMMMMMMMMMMMM MM\");\n    System.out.println(\" MMMM MM MM MM MM MMM MMM MMMMMMMM\");\n    System.out.println(\" MMMM MM MMMMM MM MM MMM MM MMMMMMMM\");\n    System.out.println(\" MMMM MM MMMMM MMMMM MM MMM MM MM\");\n    System.out.println(\" MMMMMM MMM MM MMMMMMM MM MMM MM MM\");\n    System.out.println(\" MMMMMM MMM MM MMMM MM MM MMM MM MM\");\n    System.out.println(\" MMM MMM MMM MM MM MM MM MMM MM MM\");\n    System.out.println(\" MMMM MMMM MMM MMM MM MM MM MMM MM MM\");\n    System.out.println(\" MMM MMM MMMMMMMMM MMMMMMMM MM MMM MM MMMMMMMM\");\n    System.out.println(\"MMMM MMMM MMMMMMMM MMMMMMMM MM MMM MM MMMMMMMM\");\n    System.out.println(\" MMM MM MM\\n\");\n    System.out.println(\"GameServer\\n\\n\");\n\n    try {\n      loadConfig();\n    } catch (ParserConfigurationException | SAXException | IOException e) {\n      e.printStackTrace();\n    }\n\n    BattleHall.getInstance().setInitialWorldSettings();\n    MeleeHall.getInstance().setInitialWorldSettings();\n\n    Hall.getInstance().startHall();\n\n    Thread thLogicServerListen = new Thread(new LogicServerListenThread());\n    thLogicServerListen.setName(\"LogicServerListenThread\");\n    thLogicServerListen.start();\n\n    startLogicServerHolderThread();\n\n    AIOSocketMgr.getInstance().startCompletionPort();\n\n    try {\n      Thread.sleep(Long.MAX_VALUE);\n    } catch (InterruptedException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9418, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 1636, "focalAPIEnd": 1665, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sgothel/jogl/tree/master/src/test/com/jogamp/opengl/test/junit/jogl/awt/TestBug461FBOSupersamplingSwingAWT.java", "rawCode": "  @Test\n  public void testOffscreenSupersampling() throws InterruptedException, InvocationTargetException {\n    jframe = new JFrame(\"Offscreen Supersampling\");\n    Assert.assertNotNull(jframe);\n    jframe.addWindowListener(\n        new WindowAdapter() {\n          public void windowClosing(final WindowEvent e) {\n            System.exit(0);\n          }\n        });\n\n    final GLProfile glp = GLProfile.get(GLProfile.GL2);\n    Assert.assertNotNull(glp);\n\n    final GLDrawableFactory fac = GLDrawableFactory.getFactory(glp);\n    Assert.assertNotNull(fac);\n\n    final GLCapabilities glCap = new GLCapabilities(glp);\n    Assert.assertNotNull(glCap);\n\n    // COMMENTING OUT THIS LINE FIXES THE ISSUE.\n    // Setting this in JOGL1 works. Thus this is a JOGL2 issue.\n    glCap.setSampleBuffers(true);\n    glCap.setNumSamples(4);\n\n    // Without line below, there is an error on Windows.\n    // glCap.setDoubleBuffered(false); // implicit double buffer -> MSAA + FBO\n\n    // Needed for drop shadows\n    glCap.setStencilBits(1);\n\n    // makes a new buffer\n    offScreenBuffer =\n        fac.createOffscreenAutoDrawable(GLProfile.getDefaultDevice(), glCap, null, 200, 200);\n    Assert.assertNotNull(offScreenBuffer);\n    offScreenBuffer.addGLEventListener(this);\n    javax.swing.SwingUtilities.invokeAndWait(\n        new Runnable() {\n          public void run() {\n            jframe.setSize(300, 300);\n            jframe.setVisible(true);\n          }\n        });\n    offScreenBuffer.display(); // read from front buffer due to FBO+MSAA -> double-buffer\n    offScreenBuffer.display(); // now we have prev. image in front buffer to be read out\n\n    Thread.sleep(durationPerTest);\n\n    offScreenBuffer.destroy();\n  }\n"}, {"dataset": "sleep", "exampleID": 9419, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["getClass()", "getSimpleName()", "warn(*,*)", "Log.info(String)"], "tryExpressionStart": 170, "tryExpressionEnd": 174, "tryBlockStart": 170, "tryBlockEnd": 470, "catchExpressionStart": 272, "catchExpressionEnd": 292, "catchBlockStart": 272, "catchBlockEnd": 470, "exceptionHandlingCallStart": [311, 311, 302, 400], "exceptionHandlingCallEnd": [321, 337, 390, 461], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 201, "focalAPIEnd": 230, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop/hadoop-1.1.2/src/mapred/org/apache/hadoop/mapred/UserLogCleaner.java", "rawCode": "  @Override\n  public void run() {\n    // This thread wakes up after every threadSleepTime interval\n    // and deletes if there are any old logs.\n    while (true) {\n      try {\n        // sleep\n        Thread.sleep(threadSleepTime);\n        processCompletedJobs();\n      } catch (Throwable e) {\n        LOG.warn(getClass().getSimpleName() + \" encountered an exception while monitoring :\", e);\n        LOG.info(\"Ingoring the exception and continuing monitoring.\");\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9420, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SqlServiceDeadlockException", "exceptionHandlingCall": ["Connection.rollback()"], "tryExpressionStart": 704, "tryExpressionEnd": 708, "tryBlockStart": 704, "tryBlockEnd": 790, "catchExpressionStart": 1212, "catchExpressionEnd": 1250, "catchBlockStart": 1212, "catchBlockEnd": 1753, "exceptionHandlingCallStart": [1334], "exceptionHandlingCallEnd": [1355], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 720, "focalAPIEnd": 742, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.3.0-b01/kernel-impl/src/main/java/org/sakaiproject/db/impl/BasicSqlService.java", "rawCode": "  /** {@inheritDoc} */\n  public boolean transact(Runnable callback, String tag) {\n    // if we are already in a transaction, stay in it (don't start a new one), and just run the\n    // callback (no retries, let the outside transaction\n    // code handle that)\n    if (threadLocalManager().get(TRANSACTION_CONNECTION) != null) {\n      callback.run();\n      return true;\n    }\n\n    // in case of deadlock we might retry\n    for (int i = 0; i <= m_deadlockRetries; i++) {\n      if (i > 0) {\n        // make a little fuss\n        LOG.warn(\"transact: deadlock: retrying (\" + i + \" / \" + m_deadlockRetries + \"): \" + tag);\n\n        // do a little wait, longer for each retry\n        // TODO: randomize?\n        try {\n          Thread.sleep(i * 100L);\n        } catch (Exception ignore) {\n        }\n      }\n\n      Connection connection = null;\n      boolean wasCommit = true;\n      try {\n        connection = borrowConnection();\n        wasCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n\n        // store the connection in the thread\n        threadLocalManager().set(TRANSACTION_CONNECTION, connection);\n\n        callback.run();\n\n        connection.commit();\n\n        return true;\n      } catch (SqlServiceDeadlockException e) {\n        // rollback\n        if (connection != null) {\n          try {\n            connection.rollback();\n            LOG.warn(\"transact: deadlock: rolling back: \" + tag);\n          } catch (Exception ee) {\n            LOG.warn(\"transact: (deadlock: rollback): \" + tag + \" : \" + ee);\n          }\n        }\n\n        // if this was the last attempt, throw to abort\n        if (i == m_deadlockRetries) {\n          LOG.warn(\"transact: deadlock: retry failure: \" + tag);\n          throw e;\n        }\n      } catch (RuntimeException e) {\n        // rollback\n        if (connection != null) {\n          try {\n            connection.rollback();\n            LOG.warn(\"transact: rolling back: \" + tag);\n          } catch (Exception ee) {\n            LOG.warn(\"transact: (rollback): \" + tag + \" : \" + ee);\n          }\n        }\n        LOG.warn(\"transact: failure: \" + e);\n        throw e;\n      } catch (SQLException e) {\n        // rollback\n        if (connection != null) {\n          try {\n            connection.rollback();\n            LOG.warn(\"transact: rolling back: \" + tag);\n          } catch (Exception ee) {\n            LOG.warn(\"transact: (rollback): \" + tag + \" : \" + ee);\n          }\n        }\n        LOG.warn(\"transact: failure: \" + e);\n        throw new RuntimeException(\"SqlService.transact failure\", e);\n      } finally {\n        if (connection != null) {\n          // clear the connection from the thread\n          threadLocalManager().set(TRANSACTION_CONNECTION, null);\n\n          try {\n            connection.setAutoCommit(wasCommit);\n          } catch (Exception e) {\n            LOG.warn(\"transact: (setAutoCommit): \" + tag + \" : \" + e);\n          }\n          returnConnection(connection);\n        }\n      }\n    }\n\n    return false;\n  }\n"}, {"dataset": "sleep", "exampleID": 9421, "initialization": ["long miliseconds = ConnectionHandle.getPool()", "long miliseconds = getConfig()", "long miliseconds = getAcquireRetryDelayInMs()"], "initializationStart": [602, 681, 763], "initializationEnd": [615, 706, 815], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 4789, "focalAPIEnd": 4820, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wwadge/bonecp/tree/master/bonecp/src/main/java/com/jolbox/bonecp/MemorizeTransactionProxy.java", "rawCode": "  /**\n   * Play back a transaction\n   *\n   * @param oldReplayLog\n   * @return map + result\n   * @throws SQLException\n   */\n  private TransactionRecoveryResult attemptRecovery(List<ReplayLog> oldReplayLog)\n      throws SQLException {\n    boolean tryAgain = false;\n    Throwable failedThrowable = null;\n\n    ConnectionHandle con = this.connectionHandle.get();\n    if (con == null) { // safety!\n      throw PoolUtil.generateSQLException(\"ConnectionHandle is gone!\", new IllegalStateException());\n    }\n    TransactionRecoveryResult recoveryResult = con.recoveryResult;\n    ConnectionHook connectionHook = con.getPool().getConfig().getConnectionHook();\n\n    int acquireRetryAttempts = con.getPool().getConfig().getAcquireRetryAttempts();\n    long acquireRetryDelay = con.getPool().getConfig().getAcquireRetryDelayInMs();\n    AcquireFailConfig acquireConfig = new AcquireFailConfig();\n    acquireConfig.setAcquireRetryAttempts(new AtomicInteger(acquireRetryAttempts));\n    acquireConfig.setAcquireRetryDelayInMs(acquireRetryDelay);\n    acquireConfig.setLogMessage(\"Failed to replay transaction\");\n\n    Map<Object, Object> replaceTarget = new HashMap<Object, Object>();\n    do {\n      replaceTarget.clear();\n      // make a copy\n      for (Entry<Object, Object> entry : recoveryResult.getReplaceTarget().entrySet()) {\n        replaceTarget.put(entry.getKey(), entry.getValue());\n      }\n\n      List<PreparedStatement> prepStatementTarget = new ArrayList<PreparedStatement>();\n      List<CallableStatement> callableStatementTarget = new ArrayList<CallableStatement>();\n      List<Statement> statementTarget = new ArrayList<Statement>();\n      Object result = null;\n      tryAgain = false;\n      // this connection is dead\n      con.setInReplayMode(true); // don't go in a loop of saving our saved log!\n      try {\n        con.clearStatementCaches(true);\n        con.getInternalConnection().close();\n      } catch (Throwable t) {\n        // do nothing - also likely to fail here\n      }\n      try {\n        con.setInternalConnection(memorize(con.getPool().obtainInternalConnection(con), con));\n      } catch (SQLException e) {\n        throw con.markPossiblyBroken(e);\n      }\n\n      con.getOriginatingPartition().trackConnectionFinalizer(con); // track this too.\n\n      for (ReplayLog replay : oldReplayLog) {\n\n        // we got new connections/statement handles so replace what we've got with the new ones\n        if (replay.getTarget() instanceof Connection) {\n          replaceTarget.put(replay.getTarget(), con.getInternalConnection());\n        } else if (replay.getTarget() instanceof CallableStatement) {\n          if (replaceTarget.get(replay.getTarget()) == null) {\n            replaceTarget.put(replay.getTarget(), callableStatementTarget.remove(0));\n          }\n        } else if (replay.getTarget() instanceof PreparedStatement) {\n          if (replaceTarget.get(replay.getTarget()) == null) {\n            replaceTarget.put(replay.getTarget(), prepStatementTarget.remove(0));\n          }\n        } else if (replay.getTarget() instanceof Statement) {\n          if (replaceTarget.get(replay.getTarget()) == null) {\n            replaceTarget.put(replay.getTarget(), statementTarget.remove(0));\n          }\n        }\n\n        try {\n          // run again using the new connection/statement\n          // result = replay.getMethod().invoke(, replay.getArgs());\n          result =\n              runWithPossibleProxySwap(\n                  replay.getMethod(), replaceTarget.get(replay.getTarget()), replay.getArgs());\n\n          // remember what we've got last\n          recoveryResult.setResult(result);\n\n          // if we got a new statement (eg a prepareStatement call), save it, we'll use it for our\n          // search/replace\n          if (result instanceof CallableStatement) {\n            callableStatementTarget.add((CallableStatement) result);\n          } else if (result instanceof PreparedStatement) {\n            prepStatementTarget.add((PreparedStatement) result);\n          } else if (result instanceof Statement) {\n            statementTarget.add((Statement) result);\n          }\n        } catch (Throwable t) {\n          // It blew up again, let's try a couple more times before giving up...\n          // call the hook, if available.\n          if (connectionHook != null) {\n            tryAgain = connectionHook.onAcquireFail(t, acquireConfig);\n          } else {\n\n            logger.error(\n                \"Failed to replay transaction. Sleeping for \"\n                    + acquireRetryDelay\n                    + \"ms and trying again. Attempts left: \"\n                    + acquireRetryAttempts\n                    + \". Exception: \"\n                    + t.getCause()\n                    + \" Message:\"\n                    + t.getMessage());\n\n            try {\n              Thread.sleep(acquireRetryDelay);\n              if (acquireRetryAttempts > 0) {\n                tryAgain = (--acquireRetryAttempts) != 0;\n              }\n            } catch (InterruptedException e) {\n              tryAgain = false;\n            }\n          }\n          if (!tryAgain) {\n            failedThrowable = t;\n          }\n          break;\n        }\n      }\n    } while (tryAgain);\n\n    // fill last successful results\n    for (Entry<Object, Object> entry : replaceTarget.entrySet()) {\n      recoveryResult.getReplaceTarget().put(entry.getKey(), entry.getValue());\n    }\n\n    for (ReplayLog replay : oldReplayLog) {\n      replay.setTarget(replaceTarget.get(replay.getTarget())); // fix our log\n    }\n\n    if (failedThrowable != null) {\n      throw PoolUtil.generateSQLException(failedThrowable.getMessage(), failedThrowable);\n    }\n\n    return recoveryResult;\n  }\n"}, {"dataset": "sleep", "exampleID": 9422, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 195, "focalAPIEnd": 218, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/StratusLab/marketplace/tree/master/server/war/src/test/java/eu/stratuslab/marketplace/server/store/file/FileMonitorTest.java", "rawCode": "  @Test\n  public void testGetFiles() throws Exception {\n    FileMonitor monitor = new FileMonitor(tmpDir, \".xml\");\n\n    File tmpFile = File.createTempFile(\"test\", \".xml\", new File(tmpDir));\n\n    Thread.sleep(6 * 1000L);\n\n    File monitorFile = monitor.getFile();\n\n    assertNotNull(monitorFile);\n    assertThat(monitorFile.getCanonicalPath(), is(tmpFile.getCanonicalPath()));\n  }\n"}, {"dataset": "sleep", "exampleID": 9423, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 2721, "focalAPIEnd": 2757, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brrr2/irccasino/tree/master/texastourney/TexasTourney.java", "rawCode": "  @Override\n  public void continueRound() {\n    state = PokerState.CONTINUE_ROUND;\n\n    // Set currentPlayer if it hasn't been set yet\n    if (currentPlayer == null) {\n      if (betState.equals(PokerBet.PRE_FLOP)) {\n        currentPlayer = bigBlind;\n      } else {\n        currentPlayer = dealer;\n      }\n    }\n\n    /*\n     * Find the next player. Look for a player who can bet that is not the\n     * currentPlayer or the topBettor. If we reach the currentPlayer or\n     * topBettor then stop looking.\n     */\n    Player nextPlayer = getPlayerAfter(currentPlayer);\n    while ((nextPlayer.has(\"fold\") || nextPlayer.has(\"allin\"))\n        && nextPlayer != currentPlayer\n        && nextPlayer != topBettor) {\n      nextPlayer = getPlayerAfter(nextPlayer);\n    }\n\n    if (getNumberNotFolded() < 2) {\n      // If only one player hasn't folded, expedite to end of round\n      addBetsToPot();\n      currentPlayer = null;\n      topBettor = null;\n\n      // Deal some community cards\n      while (!betState.equals(PokerBet.RIVER)) {\n        burnCard();\n        dealCommunity();\n        betState = betState.next();\n\n        // Show final community if required\n        if (settings.get(\"revealcommunity\") == 1 && betState.equals(PokerBet.RIVER)) {\n          showCommunityCards(true);\n        }\n      }\n\n      endRound();\n    } else if (nextPlayer == topBettor\n        || nextPlayer == currentPlayer\n        || (betState == PokerBet.PRE_FLOP && getNumberCanBet() == 0)) {\n      // If we reach the firstPlayer or topBettor, then we have reached\n      // the end of a round of betting and we should deal community cards.\n      // Reset minimum raise (override)\n      minRaise =\n          (int) (get(\"minbet\") * (Math.pow(2, tourneyRounds / get(\"doubleblinds\") + numOuts)));\n      addBetsToPot();\n      currentPlayer = null;\n      topBettor = null;\n\n      // If all community cards have been dealt, move to end of round.\n      // Otherwise, deal more community cards\n      if (betState.equals(PokerBet.RIVER)) {\n        endRound();\n      } else if (getNumberCanBet() < 2) {\n        /*\n         * Check for showdown. Show player hands and their win/tie\n         * probabilities immediately and each time additional community\n         * cards are revealed. Adds a dramatic delay between each reveal.\n         */\n        state = PokerState.SHOWDOWN;\n        PokerSimulator sim = new PokerSimulator();\n        ArrayList<PokerPlayer> list = pots.get(0).getEligibles();\n        sim.addPlayers(list);\n\n        while (!betState.equals(PokerBet.RIVER)) {\n          sim.addCommunity(community);\n          sim.run();\n          showShowdown(list, sim);\n          sim.reset();\n\n          // Add a delay for dramatic effect\n          try {\n            Thread.sleep(get(\"showdown\") * 1000);\n          } catch (InterruptedException e) {\n          }\n\n          // Deal some community cards\n          burnCard();\n          dealCommunity();\n          betState = betState.next();\n          showCommunityCards(false);\n        }\n        endRound();\n      } else {\n        burnCard();\n        dealCommunity();\n        betState = betState.next();\n        showCommunityCards(false);\n        continueRound();\n      }\n      // Continue to the next bettor\n    } else {\n      state = PokerState.BETTING;\n      currentPlayer = nextPlayer;\n      showMsg(\n          getMsg(\"tp_turn\"),\n          currentPlayer.getNickStr(),\n          currentBet - currentPlayer.getInteger(\"bet\"),\n          currentPlayer.getInteger(\"bet\"),\n          currentBet,\n          getCashInPlay(),\n          currentPlayer.getInteger(\"cash\") - currentPlayer.getInteger(\"bet\"));\n      setIdleOutTask();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9424, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 165, "tryExpressionEnd": 169, "tryBlockStart": 165, "tryBlockEnd": 317, "catchExpressionStart": 232, "catchExpressionEnd": 263, "catchBlockStart": 232, "catchBlockEnd": 317, "exceptionHandlingCallStart": [271], "exceptionHandlingCallEnd": [290], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 177, "focalAPIEnd": 205, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dionbosschieter/cleanstormers/tree/master/CleanStorms/src/org/saseros/cleanstorms/ContinousCheck.java", "rawCode": "  /**\n   * Sleep method to use in the while loop\n   *\n   * @return true if sleep is succesful and false if a exception occured\n   */\n  private boolean sleep() {\n    try {\n      Thread.sleep(1000 * seconds);\n      return true;\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n      return false;\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9425, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["new RuntimeException(String,*)"], "tryExpressionStart": 78, "tryExpressionEnd": 82, "tryBlockStart": 78, "tryBlockEnd": 205, "catchExpressionStart": 116, "catchExpressionEnd": 147, "catchBlockStart": 116, "catchBlockEnd": 205, "exceptionHandlingCallStart": [161], "exceptionHandlingCallEnd": [198], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 90, "focalAPIEnd": 108, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dmontag/graphdb-traversal-context/tree/master/ha/src/main/java/org/neo4j/kernel/HighlyAvailableGraphDatabase.java", "rawCode": "  private void sleepWithoutInterruption(long time, String errorMessage) {\n    try {\n      Thread.sleep(time);\n    } catch (InterruptedException e) {\n      throw new RuntimeException(errorMessage, e);\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9426, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["currentThread()", "getName()", "error(String,*)"], "tryExpressionStart": 60, "tryExpressionEnd": 64, "tryBlockStart": 60, "tryBlockEnd": 377, "catchExpressionStart": 252, "catchExpressionEnd": 283, "catchBlockStart": 252, "catchBlockEnd": 377, "exceptionHandlingCallStart": [186, 186, 291], "exceptionHandlingCallEnd": [208, 218, 370], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 127, "focalAPIEnd": 148, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.currentThread()"], "useStart": [186], "useEnd": [208], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cm4j/cm4j-all/tree/master/cm4j-test/src/main/java/com/cm4j/test/thread/concurrent/queue/cache/perfect/sleepstrategy/LoopSleepStrategy.java", "rawCode": "  @Override\n  public void sleep(long singleSleepTime) {\n    try {\n      if (sleepms < 2000) sleepms += singleSleepTime;\n\n      Thread.sleep(sleepms);\n      logger.debug(\"线程[{}] 等待{}ms\", Thread.currentThread().getName(), String.valueOf(sleepms));\n    } catch (InterruptedException e) {\n      logger.error(\"thread[\" + Thread.currentThread().getName() + \"] sleep error\", e);\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9427, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["thread.sleep(int)", "thread.sleep(int)", "thread.sleep(int)", "thread.sleep(int)", "thread.sleep(int)"], "configurationStart": [3627, 4447, 4491, 4771, 7002], "configurationEnd": [3644, 4464, 4508, 4789, 7021], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 7038, "focalAPIEnd": 7063, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.sleep(int)"], "useStart": [7458], "useEnd": [7477], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stas/pos/tree/master/jetty/contrib/cometd/client/src/test/java/org/mortbay/cometd/client/BayeuxLoadGenerator.java", "rawCode": "  public void generateLoad() throws Exception {\n    LineNumberReader in = new LineNumberReader(new InputStreamReader(System.in));\n\n    System.err.print(\"server[localhost]: \");\n    String t = in.readLine().trim();\n    if (t.length() == 0) t = \"localhost\";\n    String host = t;\n\n    System.err.print(\"port[8080]: \");\n    t = in.readLine().trim();\n    if (t.length() == 0) t = \"8080\";\n    int port = Integer.parseInt(t);\n\n    System.err.print(\"context[/cometd]: \");\n    t = in.readLine().trim();\n    if (t.length() == 0) t = \"/cometd\";\n    String uri = t + \"/cometd\";\n\n    address = new Address(host, port);\n\n    int nclients = 100;\n    int size = 50;\n    int rooms = 100;\n    int rooms_per_client = 1;\n    int publish = 1000;\n    int pause = 100;\n    int burst = 10;\n    int maxLatency = 5000;\n\n    System.err.print(\"base[/chat/demo]: \");\n    t = in.readLine().trim();\n    if (t.length() == 0) t = \"/chat/demo\";\n    String base = t;\n\n    System.err.print(\"rooms [\" + rooms + \"]: \");\n    t = in.readLine().trim();\n    if (t.length() == 0) t = \"\" + rooms;\n    rooms = Integer.parseInt(t);\n\n    System.err.print(\"rooms per client [\" + rooms_per_client + \"]: \");\n    t = in.readLine().trim();\n    if (t.length() == 0) t = \"\" + rooms_per_client;\n    rooms_per_client = Integer.parseInt(t);\n\n    System.err.print(\"max Latency [\" + maxLatency + \"]: \");\n    t = in.readLine().trim();\n    if (t.length() == 0) t = \"\" + maxLatency;\n    maxLatency = Integer.parseInt(t);\n\n    while (true) {\n      System.err.println(\"--\");\n\n      System.err.print(\"clients [\" + nclients + \"]: \");\n      t = in.readLine().trim();\n      if (t.length() == 0) t = \"\" + nclients;\n      nclients = Integer.parseInt(t);\n\n      if (nclients < rooms || (nclients % rooms) != 0) {\n        System.err.println(\"Clients must be a multiple of \" + rooms);\n        nclients = (nclients / rooms) * rooms;\n        continue;\n      }\n\n      while (clients.size() < nclients) {\n        int u = clients.size();\n        BayeuxClient client =\n            new BayeuxClient(http, address, uri) {\n              public void deliver(Client from, Message message) {\n                if (Bayeux.META_SUBSCRIBE.equals(message.get(Bayeux.CHANNEL_FIELD))\n                    && ((Boolean) message.get(Bayeux.SUCCESSFUL_FIELD)).booleanValue())\n                  _subscribed.incrementAndGet();\n                super.deliver(from, message);\n              }\n            };\n\n        MessageListener listener =\n            new MessageListener() {\n              public void deliver(Client fromClient, Client toClient, Message msg) {\n                Object data = (Object) msg.get(AbstractBayeux.DATA_FIELD);\n                if (data != null) {\n                  String msgId = (String) msg.get(AbstractBayeux.ID_FIELD);\n                  // System.err.println(name+\": \"+data);\n                  if (msgId != null) {\n                    long latency = System.currentTimeMillis() - Long.parseLong(msgId);\n                    synchronized (BayeuxLoadGenerator.this) {\n                      _got++;\n                      if (_maxLatency < latency) _maxLatency = latency;\n                      if (_minLatency == 0 || latency < _minLatency) _minLatency = latency;\n                      _totalLatency += latency;\n                    }\n                  }\n                }\n              }\n            };\n        client.addListener(listener);\n\n        client.start();\n\n        clients.add(client);\n        if (clients.size() % 10 == 0) {\n          int i = clients.size();\n          System.err.println(\n              \"clients = \" + (i >= 1000 ? \"\" : i >= 100 ? \"0\" : i >= 10 ? \"00\" : \"000\") + i);\n          Thread.sleep(300);\n        }\n\n        client.startBatch();\n        if (rooms_per_client == 1) {\n          int room = u % rooms;\n          client.subscribe(room > 0 ? (base + \"/\" + room) : base);\n        } else {\n          for (int i = 0; i < rooms_per_client; i++) {\n            int room = _random.nextInt(rooms);\n            client.subscribe(room > 0 ? (base + \"/\" + room) : base);\n          }\n        }\n        client.endBatch();\n      }\n\n      while (clients.size() > nclients) {\n        BayeuxClient client = clients.remove(0);\n        client.remove(false);\n        _subscribed.addAndGet(-rooms_per_client);\n        if (clients.size() % 10 == 0) {\n          int i = clients.size();\n          System.err.println(\n              \"clients = \" + (i >= 1000 ? \"\" : i >= 100 ? \"0\" : i >= 10 ? \"00\" : \"000\") + i);\n          Thread.sleep(300);\n        }\n      }\n\n      Thread.sleep(500);\n\n      while (_subscribed.get() != nclients * rooms_per_client) {\n        // System.err.println(destination.toDetailString());\n        System.err.println(\n            \"Subscribed:\" + _subscribed.get() + \" != \" + (nclients * rooms_per_client) + \" ...\");\n        Thread.sleep(1000);\n      }\n\n      System.err.println(\"Clients: \" + nclients + \" subscribed:\" + _subscribed.get());\n\n      synchronized (this) {\n        _got = 0;\n        _minLatency = 0;\n        _maxLatency = 0;\n        _totalLatency = 0;\n      }\n\n      System.err.print(\"publish [\" + publish + \"]: \");\n      t = in.readLine().trim();\n      if (t.length() == 0) t = \"\" + publish;\n      publish = Integer.parseInt(t);\n\n      System.err.print(\"publish size [\" + size + \"]: \");\n      t = in.readLine().trim();\n      if (t.length() == 0) t = \"\" + size;\n      size = Integer.parseInt(t);\n      String chat = \"\";\n      for (int i = 0; i < size; i++) chat += \"x\";\n\n      System.err.print(\"pause [\" + pause + \"]: \");\n      t = in.readLine().trim();\n      if (t.length() == 0) t = \"\" + pause;\n      pause = Integer.parseInt(t);\n\n      System.err.print(\"batch [\" + burst + \"]: \");\n      t = in.readLine().trim();\n      if (t.length() == 0) t = \"\" + burst;\n      burst = Integer.parseInt(t);\n\n      long start = System.currentTimeMillis();\n      trial:\n      for (int i = 1; i <= publish; ) {\n        // System.err.print(i);\n        // System.err.print(',');\n        int u = _random.nextInt(nclients);\n        BayeuxClient c = clients.get(u);\n        final String name =\n            \"Client\" + (u >= 1000 ? \"\" : u >= 100 ? \"0\" : u >= 10 ? \"00\" : \"000\") + u;\n        Object msg =\n            new JSON.Literal(\"{\\\"user\\\":\\\"\" + name + \"\\\",\\\"chat\\\":\\\"\" + chat + \" \" + i + \"\\\"}\");\n        c.startBatch();\n        for (int b = 0; b < burst; b++) {\n          int room = _random.nextInt(rooms);\n          String id = \"\" + System.currentTimeMillis();\n          c.publish(room > 0 ? (base + \"/\" + room) : base, msg, id);\n          i++;\n\n          if (i % 10 == 0) {\n            long latency = 0;\n            synchronized (this) {\n              if (_got > 0) latency = _totalLatency / _got;\n            }\n            if (latency > maxLatency) {\n              System.err.println(\"\\nABORTED!\");\n              break trial;\n            }\n\n            char dot = (char) ('0' + (int) (latency / 100));\n            System.err.print(dot);\n            if (i % 1000 == 0) System.err.println();\n          }\n        }\n        c.endBatch();\n\n        if (pause > 0) Thread.sleep(pause);\n      }\n\n      Thread.sleep(_maxLatency);\n\n      for (BayeuxClient c : clients) {\n        if (!c.isPolling()) System.err.println(\"PROBLEM WITH \" + c);\n      }\n\n      System.err.println();\n\n      long last = 0;\n      int sleep = 100;\n      while (_got < (nclients / rooms * rooms_per_client * publish)) {\n        System.err.println(\n            \"Got:\" + _got + \" < \" + (nclients / rooms * rooms_per_client * publish) + \" ...\");\n        Thread.sleep(sleep);\n        if (last != 0 && _got == last) break;\n        last = _got;\n        sleep += 100;\n      }\n      System.err.println(\"Got:\" + _got + \" of \" + (nclients / rooms * rooms_per_client * publish));\n\n      long end = System.currentTimeMillis();\n\n      System.err.println(\n          \"Got \"\n              + _got\n              + \" at \"\n              + (_got * 1000 / (end - start))\n              + \"/s, latency min/ave/max =\"\n              + _minLatency\n              + \"/\"\n              + (_totalLatency / _got)\n              + \"/\"\n              + _maxLatency\n              + \"ms\");\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9428, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["unexpectedException()"], "tryExpressionStart": 569, "tryExpressionEnd": 573, "tryBlockStart": 569, "tryBlockEnd": 853, "catchExpressionStart": 786, "catchExpressionEnd": 817, "catchBlockStart": 786, "catchBlockEnd": 853, "exceptionHandlingCallStart": [825], "exceptionHandlingCallEnd": [846], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 618, "focalAPIEnd": 646, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/goodow/j2objc/tree/master/jre_emul/apache_harmony/classlib/modules/concurrent/src/test/java/CountDownLatchTest.java", "rawCode": "  /** await returns after countDown to zero, but not before */\n  public void testAwait() {\n    final CountDownLatch l = new CountDownLatch(2);\n\n    Thread t =\n        new Thread(\n            new Runnable() {\n              public void run() {\n                try {\n                  threadAssertTrue(l.getCount() > 0);\n                  l.await();\n                  threadAssertTrue(l.getCount() == 0);\n                } catch (InterruptedException e) {\n                  threadUnexpectedException();\n                }\n              }\n            });\n    t.start();\n    try {\n      assertEquals(l.getCount(), 2);\n      Thread.sleep(SHORT_DELAY_MS);\n      l.countDown();\n      assertEquals(l.getCount(), 1);\n      l.countDown();\n      assertEquals(l.getCount(), 0);\n      t.join();\n    } catch (InterruptedException e) {\n      unexpectedException();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9429, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 794, "focalAPIEnd": 849, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["MiniDFSCluster.shutdown()"], "finallyExpressionStart": 1259, "finallyExpressionEnd": 1267, "finallyBlockStart": 1259, "finallyBlockEnd": 1339, "cleanUpCallStart": [1306], "cleanUpCallEnd": [1324], "url": "https://github.com/johnugeorge/distributed/tree/master/Fast_Copy_HDFS/src/test/org/apache/hadoop/hdfs/TestDFSRemove.java", "rawCode": "  public void testRemove() throws Exception {\n    Configuration conf = new Configuration();\n    MiniDFSCluster cluster = new MiniDFSCluster(conf, 2, true, null);\n    try {\n      FileSystem fs = cluster.getFileSystem();\n      assertTrue(fs.mkdirs(dir));\n\n      long dfsUsedStart = getTotalDfsUsed(cluster);\n      {\n        // Create 100 files\n        final int fileCount = 100;\n        for (int i = 0; i < fileCount; i++) {\n          Path a = new Path(dir, \"a\" + i);\n          createFile(fs, a);\n        }\n        long dfsUsedMax = getTotalDfsUsed(cluster);\n        // Remove 100 files\n        for (int i = 0; i < fileCount; i++) {\n          Path a = new Path(dir, \"a\" + i);\n          fs.delete(a, false);\n        }\n        // wait 5 heartbeat intervals, so that all blocks are deleted.\n        Thread.sleep(5 * FSConstants.HEARTBEAT_INTERVAL * 1000);\n        // all blocks should be gone now.\n        long dfsUsedFinal = getTotalDfsUsed(cluster);\n        assertEquals(\n            \"All blocks should be gone. start=\"\n                + dfsUsedStart\n                + \" max=\"\n                + dfsUsedMax\n                + \" final=\"\n                + dfsUsedFinal,\n            dfsUsedStart,\n            dfsUsedFinal);\n      }\n\n      fs.delete(dir, true);\n    } finally {\n      if (cluster != null) {\n        cluster.shutdown();\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9430, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 292, "tryExpressionEnd": 296, "tryBlockStart": 292, "tryBlockEnd": 463, "catchExpressionStart": 351, "catchExpressionEnd": 382, "catchBlockStart": 351, "catchBlockEnd": 463, "exceptionHandlingCallStart": [435], "exceptionHandlingCallEnd": [454], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 306, "focalAPIEnd": 341, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tpummer/trayrss-desk/tree/master/trayrss-desk-service/src/main/java/at/nullpointer/trayrss/notification/TrayNotifier.java", "rawCode": "  public void run() {\n\n    while (true) {\n      final Integer displaySeconds =\n          ConfigurationControllerImpl.getInstance().getConfigurationModel().getDisplayTime();\n\n      popupManager =\n          new PopupManager(displaySeconds * 1000, Corner.LOWER_RIGHT, new Point(30, 100));\n      try {\n        Thread.sleep(displaySeconds * 1000);\n      } catch (InterruptedException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n      }\n      this.notifyNews();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9431, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 362, "focalAPIEnd": 411, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.sleep(int)"], "useStart": [442], "useEnd": [459], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/H2-Mirror/tree/master/h2/src/test/org/h2/test/unit/TestFileLock.java", "rawCode": "  private void test(boolean allowSocketsLock) throws Exception {\n    int threadCount = getSize(3, 5);\n    wait = getSize(20, 200);\n    Thread[] threads = new Thread[threadCount];\n    new File(getFile()).delete();\n    for (int i = 0; i < threadCount; i++) {\n      threads[i] = new Thread(new TestFileLock(this, allowSocketsLock));\n      threads[i].start();\n      Thread.sleep(wait + (int) (Math.random() * wait));\n    }\n    trace(\"wait\");\n    Thread.sleep(500);\n    stop = true;\n    trace(\"STOP file\");\n    for (int i = 0; i < threadCount; i++) {\n      threads[i].join();\n    }\n    assertEquals(0, locks);\n  }\n"}, {"dataset": "sleep", "exampleID": 9432, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 103, "focalAPIEnd": 122, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/germanescobar/mokai/tree/master/mokai-core/src/test/java/org/mokai/config/xml/test/ConfigurationTest.java", "rawCode": "    @Override\n    public ConnectorService answer(InvocationOnMock invocation) throws Throwable {\n      Thread.sleep(delay);\n      return connectorService;\n    }\n"}, {"dataset": "sleep", "exampleID": 9433, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 1157, "focalAPIEnd": 1185, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/samthiriot/genlab/tree/master/genlab.gui/src/genlab/gui/views/TasksProgressView.java", "rawCode": "    @Override\n    public void run() {\n\n      /** The runnable used to actually refresh the widgets */\n      final Runnable updateRunnable =\n          new Runnable() {\n\n            @Override\n            public void run() {\n              if (TestResponsivity.AUDIT_SWT_THREAD_USE)\n                TestResponsivity.singleton.notifySWTThreadUserStartsRunnable(SWT_THREAD_USER_ID);\n\n              view._ui_updateWidgets();\n              updatePending = false;\n\n              if (TestResponsivity.AUDIT_SWT_THREAD_USE)\n                TestResponsivity.singleton.notifySWTThreadUserEndsRunnable(SWT_THREAD_USER_ID);\n            }\n          };\n\n      while (!canceled && (display == null || !display.isDisposed())) {\n\n        if (!updatePending && view.hasSomethingToUpdate()) {\n          // GLLogger.traceTech(\"refresh !.\", getClass());\n          updatePending = true;\n          if (TestResponsivity.AUDIT_SWT_THREAD_USE)\n            TestResponsivity.singleton.notifySWTThreadUserSubmitsRunnable(SWT_THREAD_USER_ID);\n          view.getDisplay().asyncExec(updateRunnable);\n        }\n\n        try {\n          // GLLogger.traceTech(\"sleeping\", getClass());\n          Thread.sleep(REFRESH_PERIOD);\n        } catch (InterruptedException e) {\n        }\n      }\n    }\n"}, {"dataset": "sleep", "exampleID": 9434, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new MessageSendException()"], "tryExpressionStart": 465, "tryExpressionEnd": 469, "tryBlockStart": 465, "tryBlockEnd": 789, "catchExpressionStart": 722, "catchExpressionEnd": 742, "catchBlockStart": 722, "catchBlockEnd": 789, "exceptionHandlingCallStart": [756], "exceptionHandlingCallEnd": [782], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 689, "focalAPIEnd": 714, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/koanlogic/tinyos-fork/tree/master/apps/tests/LinkBench/javasrc/benchmark/common/BenchmarkController.java", "rawCode": "  /**\n   * Send a RESET control message to the network. It is a broadcast message, so every mote should\n   * receive it.\n   *\n   * @param use_bcast Whether send one broadcast message or iterate through the motes\n   * @throws MessageSendException if an error occured (message is failed to send)\n   */\n  public boolean reset(final boolean use_bcast) throws MessageSendException {\n    CtrlMsgT cmsg = new CtrlMsgT();\n    cmsg.set_type(BenchmarkStatic.CTRL_RESET);\n    try {\n      if (use_bcast) {\n        mif.send(MoteIF.TOS_BCAST_ADDR, cmsg);\n      } else {\n        currentMote = 1;\n        while (currentMote <= maxMoteId) {\n          mif.send(currentMote++, cmsg);\n        }\n      }\n      Thread.sleep((int) (500));\n    } catch (Exception e) {\n      throw new MessageSendException();\n    }\n    return true;\n  }\n"}, {"dataset": "sleep", "exampleID": 9435, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new DeviceException(String,*)"], "tryExpressionStart": 69, "tryExpressionEnd": 73, "tryBlockStart": 69, "tryBlockEnd": 1050, "catchExpressionStart": 927, "catchExpressionEnd": 947, "catchBlockStart": 927, "catchBlockEnd": 1050, "exceptionHandlingCallStart": [997], "exceptionHandlingCallEnd": [1043], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 795, "focalAPIEnd": 844, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openGDA/gda-epics/tree/master/uk.ac.gda.epics/src/gda/device/detector/EpicsScalerSimple.java", "rawCode": "  @Override\n  public void collectData() throws DeviceException {\n    try {\n      // set to true before call to setValue to ensure the change in PutListener is last\n      waitingForPutToStart = true;\n      epicsDevice.setValue(\n          RECORD,\n          START,\n          new Short((short) 1),\n          5,\n          new PutListener() {\n\n            @Override\n            public void putCompleted(PutEvent arg0) {\n              if (arg0 == null) {\n                // complete in dummy mode\n              } else {\n                if (arg0.getStatus() != CAStatus.NORMAL) {\n                  logger.error(\"Error in collectData for \" + getName());\n                }\n              }\n              waitingForPutToStart = false;\n            }\n          });\n      if (epicsDevice.getDummy()) {\n        Thread.sleep((long) (getCollectionTime() * 1000));\n        epicsDevice.setValue(RECORD, START, new Short((short) 0));\n      }\n    } catch (Exception e) {\n      waitingForPutToStart = false;\n      throw new DeviceException(\"Error in collectData\", e);\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9436, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 115, "focalAPIEnd": 146, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rmpvilaca/EscadaTPC-C/tree/master/src/main/java/escada/tpc/common/clients/jmx/ClientEmulationStartup.java", "rawCode": "  private void waitForStart(int start) throws InterruptedException {\n    if (start < 0) {\n      return;\n    }\n\n    Thread.sleep(start * 60 * 1000); // TODO - It must be changed to a\n    // constant.\n  }\n"}, {"dataset": "sleep", "exampleID": 9437, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 104, "focalAPIEnd": 122, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Top-Q/jsystem/tree/master/jsystem-core-projects/jsystemCore/src/main/java/junit/framework/SystemTestCaseImpl.java", "rawCode": "  public void sleep(long time) {\n    report.report(\"Sleep \" + (time / 1000) + \" sec.\");\n    try {\n      Thread.sleep(time);\n    } catch (InterruptedException e) {\n      return;\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9438, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["getClass()", "getName()", "getMessage()", "warn(String)"], "tryExpressionStart": 276, "tryExpressionEnd": 280, "tryBlockStart": 276, "tryBlockEnd": 578, "catchExpressionStart": 319, "catchExpressionEnd": 350, "catchBlockStart": 319, "catchBlockEnd": 578, "exceptionHandlingCallStart": [490, 490, 554, 360], "exceptionHandlingCallEnd": [502, 512, 568, 569], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 290, "focalAPIEnd": 309, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ebayopensource/turmeric-runtime/tree/master/integration-tests/SOATestsCommon/src/main/java/org/ebayopensource/turmeric/runtime/tests/common/jetty/IntentionalDelayHandler.java", "rawCode": "  @Override\n  public void handle(\n      String target, HttpServletRequest request, HttpServletResponse response, int dispatch)\n      throws IOException, ServletException {\n    /* only delay proper requests, not internal routing */\n    if (dispatch == Handler.REQUEST) {\n      try {\n        Thread.sleep(delay);\n      } catch (InterruptedException e) {\n        Log.warn(\n            \"Unable to cause intentional delay of \"\n                + delay\n                + \" ms: \"\n                + e.getClass().getName()\n                + \": \"\n                + e.getMessage());\n      }\n    }\n    super.handle(target, request, response, dispatch);\n  }\n"}, {"dataset": "sleep", "exampleID": 9439, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 38, "tryExpressionEnd": 42, "tryBlockStart": 38, "tryBlockEnd": 141, "catchExpressionStart": 76, "catchExpressionEnd": 107, "catchBlockStart": 76, "catchBlockEnd": 141, "exceptionHandlingCallStart": [115], "exceptionHandlingCallEnd": [134], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 50, "focalAPIEnd": 68, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/clubcapra/Viki/tree/master/src/main/java/ca/etsmtl/capra/digitizer/simulators/replays/ReplayTimeManager.java", "rawCode": "  private void sleep(long time) {\n    try {\n      Thread.sleep(time);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9440, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 435, "focalAPIEnd": 461, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/UrbanCode/terraform/tree/master/src/main/java/com/urbancode/terraform/tasks/vmware/util/VirtualHost.java", "rawCode": "  public void waitForIp(VirtualMachine vm) throws RemoteException, InterruptedException {\n    long pollInterval = 3000L;\n    long timeoutInterval = 10L * 60L * 1000L;\n    long start = System.currentTimeMillis();\n\n    String address = vm.getGuest().getIpAddress();\n    while (address == null) {\n      if (System.currentTimeMillis() - start > timeoutInterval) {\n        throw new RemoteException(\"Timeout waiting for IP\");\n      }\n      Thread.sleep(pollInterval);\n      address = vm.getGuest().getIpAddress();\n    }\n    assert address != null;\n  }\n"}, {"dataset": "sleep", "exampleID": 9441, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 501, "tryExpressionEnd": 505, "tryBlockStart": 501, "tryBlockEnd": 775, "catchExpressionStart": 652, "catchExpressionEnd": 683, "catchBlockStart": 652, "catchBlockEnd": 775, "exceptionHandlingCallStart": [693], "exceptionHandlingCallEnd": [766], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 619, "focalAPIEnd": 642, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/propra13-orga/gruppe13/tree/master/src/hhu/propra_2013/gruppe_13/CoreGameDrawer.java", "rawCode": "  @Override // Override Thread method run, this will implement the game loop\n\n  /** Run-Methode Solange das Spiel läuft wird weitergezeichnet */\n  public void run() {\n    long time;\n    long temp;\n\n    // game loop, TODO: repaint on screen synchronization (not sure if this is possible with our\n    // library)\n    while (gameRunning) {\n      // get current system time, this will determine fps\n      time = System.currentTimeMillis();\n\n      // Repaint the game and wait\n      game.repaint();\n\n      try {\n        // tries to set the draw method at 62.5fps\n        if ((temp = System.currentTimeMillis() - time) < 16) Thread.sleep(16 - temp);\n      } catch (InterruptedException e) {\n        System.err.println(\"Graphics Thread interrupted, continuing execution. \");\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9442, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "fail(*)"], "tryExpressionStart": 1253, "tryExpressionEnd": 1257, "tryBlockStart": 1253, "tryBlockEnd": 1622, "catchExpressionStart": 1567, "catchExpressionEnd": 1587, "catchBlockStart": 1567, "catchBlockEnd": 1622, "exceptionHandlingCallStart": [1600, 1595], "exceptionHandlingCallEnd": [1614, 1615], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 1506, "focalAPIEnd": 1559, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinedelson/felix/tree/master/ipojo/tests/core/configadmin/src/main/java/org/apache/felix/ipojo/test/scenarios/configadmin/ManagedServiceTestForService.java", "rawCode": "  public void testFactoryCreationAndReconfiguration() {\n    Properties props = new Properties();\n    props.put(\"managed.service.pid\", msp);\n    props.put(\"message\", \"message\");\n    ComponentInstance instance = null;\n    try {\n      instance = factSvc.createComponentInstance(props);\n    } catch (Exception e) {\n      fail(e.getMessage());\n    }\n\n    ServiceReference ref =\n        Utils.getServiceReferenceByName(\n            getContext(), FooService.class.getName(), instance.getInstanceName());\n    assertEquals(\n        \"Check no object\",\n        0,\n        ((PrimitiveInstanceDescription) instance.getInstanceDescription())\n            .getCreatedObjects()\n            .length);\n    assertNotNull(\"FS availability\", ref);\n\n    FooService fs = (FooService) getContext().getService(ref);\n    Properties p = fs.fooProps();\n    String mes = p.getProperty(\"message\");\n    int count = ((Integer) p.get(\"count\")).intValue();\n    assertEquals(\n        \"Check 1 object\",\n        1,\n        ((PrimitiveInstanceDescription) instance.getInstanceDescription())\n            .getCreatedObjects()\n            .length);\n    assertEquals(\"Check message\", \"message\", mes);\n    assertEquals(\"Check count\", 1, count);\n\n    // Update\n    Configuration configuration;\n    try {\n      configuration = admin.getConfiguration(msp);\n      Dictionary prc = configuration.getProperties();\n      if (prc == null) {\n        prc = new Properties();\n      }\n      prc.put(\"message\", \"message2\");\n      configuration.update(prc);\n      Thread.sleep(ConfigurationTestSuite.UPDATE_WAIT_TIME);\n    } catch (Exception e) {\n      fail(e.getMessage());\n    }\n\n    ref =\n        Utils.getServiceReferenceByName(\n            getContext(), FooService.class.getName(), instance.getInstanceName());\n    assertEquals(\n        \"Check 1 object\",\n        1,\n        ((PrimitiveInstanceDescription) instance.getInstanceDescription())\n            .getCreatedObjects()\n            .length);\n    assertNotNull(\"FS availability\", ref);\n\n    fs = (FooService) getContext().getService(ref);\n    p = fs.fooProps();\n    mes = p.getProperty(\"message\");\n    count = ((Integer) p.get(\"count\")).intValue();\n    assertEquals(\n        \"Check 1 object\",\n        1,\n        ((PrimitiveInstanceDescription) instance.getInstanceDescription())\n            .getCreatedObjects()\n            .length);\n    if (mes.equals(\"message\")) {\n      System.out.println(\"Warning, configuration not yet applied\");\n      assertEquals(\"Check count - W\", 1, count);\n    } else {\n      assertEquals(\"Check message\", \"message2\", mes);\n      assertEquals(\"Check count\", 2, count);\n    }\n\n    instance.dispose();\n  }\n"}, {"dataset": "sleep", "exampleID": 9443, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["v(String,String)"], "tryExpressionStart": 489, "tryExpressionEnd": 493, "tryBlockStart": 489, "tryBlockEnd": 655, "catchExpressionStart": 553, "catchExpressionEnd": 574, "catchBlockStart": 553, "catchBlockEnd": 655, "exceptionHandlingCallStart": [584], "exceptionHandlingCallEnd": [646], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 503, "focalAPIEnd": 543, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Blakez/android_frameworks_base/tree/master/media/tests/MediaFrameworkTest/src/com/android/mediaframeworktest/unit/MediaPlayerStateUnitTestTemplate.java", "rawCode": "  private void setMediaPlayerToStartedStateAfterPause() {\n    try {\n      mMediaPlayer.reset();\n      mMediaPlayer.setDataSource(TEST_PATH);\n      mMediaPlayer.prepare();\n      mMediaPlayer.start();\n      mMediaPlayer.pause();\n\n      // pause() is an asynchronous call and returns immediately, but\n      // PV player engine may take quite a while to actually set the\n      // player state to Paused; if we call start() right after pause()\n      // without waiting, start() may fail.\n      try {\n        Thread.sleep(MediaNames.PAUSE_WAIT_TIME);\n      } catch (Exception ie) {\n        Log.v(TAG, \"sleep was interrupted and terminated prematurely\");\n      }\n\n      mMediaPlayer.start();\n    } catch (Exception e) {\n      Log.v(\n          TAG,\n          \"setMediaPlayerToStartedStateAfterPause: Exception \"\n              + e.getClass().getName()\n              + \" was thrown.\");\n      assertTrue(false);\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9444, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["Logger.warn(String)"], "tryExpressionStart": 283, "tryExpressionEnd": 287, "tryBlockStart": 283, "tryBlockEnd": 447, "catchExpressionStart": 323, "catchExpressionEnd": 354, "catchBlockStart": 323, "catchBlockEnd": 447, "exceptionHandlingCallStart": [362], "exceptionHandlingCallEnd": [426], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 295, "focalAPIEnd": 315, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.sleep(*)"], "useStart": [1021], "useEnd": [1094], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jacksonicson/rain/tree/master/src/radlab/rain/load/LoadManager.java", "rawCode": "  public void run() {\n    // The first load profile will be used during ramp-up phase\n    synchronized (this) {\n      currentLoad = loadSchedule.get(nextLoadIndex);\n    }\n\n    // Log ramp up\n    logger.info(\"Ramping up for \" + rampUp + \"ms.\");\n\n    // Sleep during ramp up phase\n    try {\n      Thread.sleep(rampUp);\n    } catch (InterruptedException e) {\n      logger.warn(\"Load manager was interrupted during ramp up phase\");\n      return;\n    }\n\n    // Log ramp up finished\n    try {\n      JSONObject obj = new JSONObject();\n      obj.put(\"targetId\", targetId);\n      logger.info(\"Ramp up finished: \" + obj.toString());\n    } catch (JSONException e1) {\n      logger.error(\"Error while creating JSON object\", e1);\n    }\n\n    // Activate load profile\n    currentLoad.activate();\n\n    // Main loop that goes over all load units in the load schedule\n    while (!interrupted) {\n      try {\n        // Sleep for interval length + transition time\n        // method to acquire current load will handle transition time\n        Thread.sleep(currentLoad.getInterval() + currentLoad.getTransitionTime());\n\n        logger.debug(\"advancing load schedule\");\n        synchronized (this) {\n          // Advance the schedule and if that returns false, then we're done\n          currentLoad = advanceSchedule();\n        }\n      } catch (InterruptedException e) {\n        continue;\n      } catch (Exception e) {\n        logger.error(\"Unknown error in load manager\", e);\n        interrupted = true;\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9445, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 66, "focalAPIEnd": 84, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gangeli/jeli/tree/master/src/org/goobs/util/Utils.java", "rawCode": "  public static final void sleepMili(long mili) {\n    try {\n      Thread.sleep(mili);\n    } catch (InterruptedException e) {\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9446, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 1047, "focalAPIEnd": 1066, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ebayopensource/turmeric-runtime/tree/master/integration-tests/AdvertisingUniqueIDServiceV1Consumer/src/test/java/org/ebayopensource/turmeric/qajunittests/advertisinguniqueidservicev1/sif/AsyncClientStreamingUploadAttachmentTests.java", "rawCode": "  @Test\n  @Ignore(\"client streaming not supported in opensource\")\n  public void testAsyncPushUploadClientStreamingTrueWith3GBAttachment() throws Exception {\n    logger.debug(\"-- testAsyncPushClientStreamingTrueWith3GBAttachment --\");\n    SharedAdvertisingUniqueIDServiceV1Consumer client =\n        new SharedAdvertisingUniqueIDServiceV1Consumer(\n            \"AdvertisingUniqueIDServiceV1Consumer\", \"ClientStreaming\");\n    AttachmentAsyncHandler<TestAttachmentResponse> attHandler =\n        new AttachmentAsyncHandler<TestAttachmentResponse>();\n    Future<?> attFutureObj = null;\n    DataHandler dh = new DataHandler(new FileDataSource(f2));\n    TestAttachment param0 = new TestAttachment();\n    FileAttachmentType value = new FileAttachmentType();\n    value.setData(dh);\n    value.setType(true);\n    value.setFilePath(currentDir + \"\\\\\");\n    value.setFileName(\"3gbAttachment.txt\");\n    value.setSize(MAX_SIZE2);\n    param0.setIn(value);\n    attFutureObj = client.testAttachmentAsync(param0, attHandler);\n    while (!attFutureObj.isDone()) {\n      Thread.sleep(1000L);\n    }\n    response = attHandler.resp.get().getOut();\n\n    assertOnResponseAttachment(f3gbServer, MAX_SIZE2);\n\n    logger.debug(\"-- testAsyncPushClientStreamingTrueWith3GBAttachment --\");\n  }\n"}, {"dataset": "sleep", "exampleID": 9447, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["warn(String,*)"], "tryExpressionStart": 69, "tryExpressionEnd": 73, "tryBlockStart": 69, "tryBlockEnd": 196, "catchExpressionStart": 228, "catchExpressionEnd": 248, "catchBlockStart": 228, "catchBlockEnd": 313, "exceptionHandlingCallStart": [256], "exceptionHandlingCallEnd": [306], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 85, "focalAPIEnd": 104, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wso2/commons/tree/master/ode_trunk/utils/src/main/java/org/apache/ode/utils/WatchDog.java", "rawCode": "  public void run() {\n    try {\n      while (!interrupted) {\n        try {\n          Thread.sleep(delay);\n        } catch (InterruptedException e) {\n          // no interruption expected\n        }\n        check();\n      }\n    } catch (Exception e) {\n      log.warn(\"Exception occured. Thread will stop\", e);\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9448, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 698, "focalAPIEnd": 724, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/UrbanCode/terraform/tree/master/src/main/java/com/urbancode/terraform/tasks/rackspace/ServerTask.java", "rawCode": "  @Override\n  public void create() throws Exception {\n    if (appendSuffix) {\n      name = name + \"-\" + env.fetchSuffix();\n    }\n    String imageId;\n    // Check if they supplied an image ID. If they didn't then try to match image name to an ID.\n    if (image.matches(\"[0-9a-fA-F]{8}(?:-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}\")) {\n      imageId = image;\n    } else {\n      imageId = resolveImageIDForImageName(image);\n    }\n    log.info(\"Creating server with name \" + name + \" from image \" + image);\n    createServerRestCall(imageId);\n    log.info(\"Server request succeeded. Polling for server to come online...\");\n    boolean active = false;\n    long pollInterval = 5000L;\n    while (!active) {\n      Thread.sleep(pollInterval);\n      JSONObject serverJSON = pollForServerStatus();\n      if (serverJSON.getString(\"status\").equalsIgnoreCase(\"ACTIVE\")) {\n        try {\n          updateIpAddresses(serverJSON.getJSONObject(\"addresses\"));\n          env.fetchContext().setProperty(name + \"-public-ip\", publicIp);\n          env.fetchContext().setProperty(name + \"-private-ip\", privateIp);\n        } catch (JSONException e) {\n          log.warn(\"Exception while finding IP addresses. Continuing...\", e);\n        } finally {\n          active = true;\n        }\n      }\n    }\n    log.info(\"Server \" + name + \" is online at IP \" + publicIp);\n  }\n"}, {"dataset": "sleep", "exampleID": 9449, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["error(String,*)"], "tryExpressionStart": 56, "tryExpressionEnd": 60, "tryBlockStart": 56, "tryBlockEnd": 297, "catchExpressionStart": 198, "catchExpressionEnd": 218, "catchBlockStart": 198, "catchBlockEnd": 297, "exceptionHandlingCallStart": [230], "exceptionHandlingCallEnd": [286], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 72, "focalAPIEnd": 100, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bryanjimenez/empanada/tree/master/hadoop/hadoop-1.2.1/src/contrib/fairscheduler/src/java/org/apache/hadoop/mapred/FairScheduler.java", "rawCode": "    public void run() {\n      while (running) {\n        try {\n          Thread.sleep(updateInterval);\n          update();\n          dumpIfNecessary();\n          preemptTasksIfNecessary();\n        } catch (Exception e) {\n          LOG.error(\"Exception in fair scheduler UpdateThread\", e);\n        }\n      }\n    }\n"}, {"dataset": "sleep", "exampleID": 9450, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 61, "focalAPIEnd": 91, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spring-projects/spring-integration/tree/master/spring-integration-xmpp/src/test/java/org/springframework/integration/xmpp/ignore/ConsoleChatTests.java", "rawCode": "  @Test\n  @Ignore\n  public void run() throws Exception {\n    Thread.sleep(10 * 1000 * 1000);\n  }\n"}, {"dataset": "sleep", "exampleID": 9451, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 50, "focalAPIEnd": 68, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BaiduQA/Cafe/tree/master/testrunner/src/com/baidu/cafe/local/record/WebElementRecorder.java", "rawCode": "  private void sleep(long time) {\n    try {\n      Thread.sleep(time);\n    } catch (Exception ignored) {\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9452, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 334, "tryExpressionEnd": 338, "tryBlockStart": 334, "tryBlockEnd": 913, "catchExpressionStart": 848, "catchExpressionEnd": 879, "catchBlockStart": 848, "catchBlockEnd": 913, "exceptionHandlingCallStart": [887], "exceptionHandlingCallEnd": [906], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 346, "focalAPIEnd": 385, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.sleep(*)", "thread.sleep(*)"], "useStart": [539, 792], "useEnd": [578, 840], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/photon-infotech/framework/tree/master/phresco-framework-web/test/functional/src/main/java/com/photon/phresco/Screens/WebScreen.java", "rawCode": "  public void jQueryMobWidgetArchetypeEditAppDesc(\n      String methodName, JQueryMobileWidgetConstants jQueryMobConst) throws Exception {\n    if (StringUtils.isEmpty(methodName)) {\n      methodName = Thread.currentThread().getStackTrace()[1].getMethodName();\n    }\n    log.info(\"@jQueryMobWidgetArchetypeEditAppDesc executing\");\n    try {\n      Thread.sleep(MagicNumbers.HALF_SECONDS);\n      waitForElementPresent(phrescoUiConst.getAppInfoTab(), methodName);\n      getXpathWebElement(phrescoUiConst.getAppInfoTab());\n      click();\n      Thread.sleep(MagicNumbers.HALF_SECONDS);\n      waitForElementPresent(phrescoUiConst.getAppDesc(), methodName);\n      getXpathWebElement(phrescoUiConst.getAppDesc());\n      click();\n      clear();\n      sendKeys(jQueryMobConst.getAppUpdateDesc());\n      Thread.sleep(MagicNumbers.FIVE_THOUSAND_SECONDS);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9453, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["unexpectedException()"], "tryExpressionStart": 295, "tryExpressionEnd": 299, "tryBlockStart": 295, "tryBlockEnd": 400, "catchExpressionStart": 344, "catchExpressionEnd": 364, "catchBlockStart": 344, "catchBlockEnd": 400, "exceptionHandlingCallStart": [372], "exceptionHandlingCallEnd": [393], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 307, "focalAPIEnd": 336, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arjunroy/cinder_dalvik/tree/master/libcore/concurrent/src/test/java/tests/api/java/util/concurrent/ScheduledExecutorTest.java", "rawCode": "  /** getCompletedTaskCount increases, but doesn't overestimate, when tasks complete */\n  public void testGetCompletedTaskCount() {\n    ScheduledThreadPoolExecutor p2 = new ScheduledThreadPoolExecutor(2);\n    assertEquals(0, p2.getCompletedTaskCount());\n    p2.execute(new SmallRunnable());\n    try {\n      Thread.sleep(MEDIUM_DELAY_MS);\n    } catch (Exception e) {\n      unexpectedException();\n    }\n    assertEquals(1, p2.getCompletedTaskCount());\n    joinPool(p2);\n  }\n"}, {"dataset": "sleep", "exampleID": 9454, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 240, "focalAPIEnd": 263, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/camsys/onebusaway-nyc/tree/master/onebusaway-nyc-tdm-webapp/src/main/java/org/onebusaway/nyc/transit_data_manager/bundle/TDMBundleManagementServiceImpl.java", "rawCode": "  @Override\n  protected void timingHook() {\n    _log.info(\"sleeping to stabilize\");\n    try {\n      /*\n       * TODO: long term goal of not needing this at all\n       * RestApiLibrary read timeout may have solved this issue\n       */\n      Thread.sleep(10 * 1000);\n    } catch (InterruptedException ie) {\n      return;\n    }\n    _log.info(\"end sleep\");\n  }\n"}, {"dataset": "sleep", "exampleID": 9455, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "miliseconds>0", "guardType": "IF {", "guardExpressionStart": 728, "guardExpressionEnd": 746, "guardBlockStart": 728, "guardBlockEnd": 965, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 840, "focalAPIEnd": 863, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nourlcn/yarn-comment/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/test/java/org/apache/hadoop/hdfs/NNBench.java", "rawCode": "    /**\n     * Returns when the current number of seconds from the epoch equals the command line argument\n     * given by <code>-startTime</code>. This allows multiple instances of this program, running on\n     * clock synchronized nodes, to start at roughly the same time.\n     *\n     * @return true if the method was able to sleep for <code>-startTime</code> without\n     *     interruption; false otherwise\n     */\n    private boolean barrier() {\n      long startTime = getConf().getLong(\"test.nnbench.starttime\", 0l);\n      long currentTime = System.currentTimeMillis();\n      long sleepTime = startTime - currentTime;\n      boolean retVal = false;\n\n      // If the sleep time is greater than 0, then sleep and return\n      if (sleepTime > 0) {\n        LOG.info(\"Waiting in barrier for: \" + sleepTime + \" ms\");\n\n        try {\n          Thread.sleep(sleepTime);\n          retVal = true;\n        } catch (Exception e) {\n          retVal = false;\n        }\n      }\n\n      return retVal;\n    }\n"}, {"dataset": "sleep", "exampleID": 9456, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["printStackTrace()", "List<String>.add(String)"], "tryExpressionStart": 157, "tryExpressionEnd": 161, "tryBlockStart": 157, "tryBlockEnd": 2814, "catchExpressionStart": 2732, "catchExpressionEnd": 2752, "catchBlockStart": 2732, "catchBlockEnd": 2814, "exceptionHandlingCallStart": [2760, 2787], "exceptionHandlingCallEnd": [2779, 2807], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 199, "focalAPIEnd": 258, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.sleep(*)"], "useStart": [1499], "useEnd": [1558], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/branches/DEV_v1_8/trunk-archive/src/om/loadtest/QETester.java", "rawCode": "  private void doIteration(Random r, QuestionSteps qsQuestion) {\n    List<String> lThings = new LinkedList<String>();\n\n    lThings.add(qsQuestion.sID);\n\n    try {\n      // Delay\n      if (r != null) Thread.sleep(r.nextInt(DELAYMAX - DELAYMIN + 1) + DELAYMIN);\n\n      // Init question\n      NameValuePairs nvp = new NameValuePairs();\n      nvp.add(\"randomseed\", \"\" + (qsQuestion.lRSeed + 1));\n      String sSession;\n      long lBefore = System.currentTimeMillis();\n      if (osRemote != null) {\n        om.axis.qengine.StartReturn sr =\n            osRemote.start(\n                qsQuestion.sID,\n                qsQuestion.iMajor + \".\" + qsQuestion.iMinor,\n                \"frog\",\n                nvp.getNames(),\n                nvp.getValues(),\n                null);\n        if (DEBUG) System.err.println(sr.getXHTML());\n        sSession = sr.getQuestionSession();\n      } else {\n        om.qengine.StartReturn sr =\n            osLocal.start(\n                qsQuestion.sID,\n                qsQuestion.iMajor + \".\" + qsQuestion.iMinor,\n                \"frog\",\n                nvp.getNames(),\n                nvp.getValues(),\n                null);\n        if (DEBUG) System.err.println(sr.getXHTML());\n        sSession = sr.getQuestionSession();\n      }\n      long lStartTime = System.currentTimeMillis() - lBefore;\n      lThings.add(lStartTime + \"\");\n      tsStart.add(lStartTime);\n\n      // Run each sequence\n      for (int iSequence = 1; ; iSequence++) {\n        // Delay\n        if (r != null) Thread.sleep(r.nextInt(DELAYMAX - DELAYMIN + 1) + DELAYMIN);\n\n        // Build up params\n        nvp = new NameValuePairs();\n        boolean bFound = false;\n        for (int iStep = 0; iStep < qsQuestion.asSteps.length; iStep++) {\n          Step s = qsQuestion.asSteps[iStep];\n          if (s.iSeq == iSequence) {\n            nvp.add(s.sName, s.sValue);\n            bFound = true;\n          }\n        }\n        if (!bFound) break;\n\n        // Send action\n        boolean bQuestionEnd = false;\n        lBefore = System.currentTimeMillis();\n        if (osRemote != null) {\n          om.axis.qengine.ProcessReturn pr =\n              osRemote.process(sSession, nvp.getNames(), nvp.getValues());\n          if (DEBUG) System.err.println(pr.getXHTML());\n          bQuestionEnd = pr.isQuestionEnd();\n        } else {\n          om.qengine.ProcessReturn pr = osLocal.process(sSession, nvp.getNames(), nvp.getValues());\n          if (DEBUG) System.err.println(pr.getXHTML());\n          bQuestionEnd = pr.isQuestionEnd();\n        }\n        long lProcess = System.currentTimeMillis() - lBefore;\n        lThings.add(lProcess + \"\");\n        tsProcess.add(lProcess);\n\n        if (LEAVESESSIONS) break;\n        if (bQuestionEnd) break;\n      }\n    } catch (Throwable t) {\n      t.printStackTrace();\n      lThings.add(\"ERROR\");\n    }\n\n    System.out.println(Strings.join(\"\\t\", lThings));\n  }\n"}, {"dataset": "sleep", "exampleID": 9457, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 127, "focalAPIEnd": 151, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/idettman/ProductionLib/tree/master/Java/Orbit_References/symetrical_step_method/Orbit.java", "rawCode": "  public void run() {\n    while (runner != null) {\n      repaint(); // notify paint() that it needs to run\n      try {\n        Thread.sleep(this.sleep);\n      } catch (InterruptedException e) {\n      }\n      if (t > maxt) {\n        should_move = false;\n        runner = null;\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9458, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "miliseconds>0", "guardType": "IF {", "guardExpressionStart": 61, "guardExpressionEnd": 82, "guardBlockStart": 61, "guardBlockEnd": 210, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 105, "focalAPIEnd": 131, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Photodeus/MsLuvaLuva/tree/master/src/org/jibble/pircbot/DccFileTransfer.java", "rawCode": "  /** Delay between packets. */\n  private void delay() {\n    if (_packetDelay > 0) {\n      try {\n        Thread.sleep(_packetDelay);\n      } catch (InterruptedException e) {\n        // Do nothing.\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9459, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 514, "focalAPIEnd": 536, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/barchart/barchart-feed-ddf/tree/master/barchart-feed-ddf-client/src/test/java/com/barchart/feed/ddf/client/provider/BlockingSnapshot.java", "rawCode": "  public static void main(final String[] args) throws Exception {\n\n    final String username = System.getProperty(\"barchart.username\");\n    final String password = System.getProperty(\"barchart.password\");\n\n    final Marketplace market =\n        BarchartMarketplace.builder().username(username).password(password).build();\n\n    market.startup();\n\n    final Market test = market.snapshot(instID).toBlockingObservable().first();\n\n    System.out.println(\"Passed Block\");\n\n    System.out.println(test.toString());\n\n    Thread.sleep(5 * 1000);\n\n    market.shutdown();\n  }\n"}, {"dataset": "sleep", "exampleID": 9460, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["new WebGenomeSystemException(String,*)"], "tryExpressionStart": 464, "tryExpressionEnd": 468, "tryBlockStart": 464, "tryBlockEnd": 705, "catchExpressionStart": 541, "catchExpressionEnd": 572, "catchBlockStart": 541, "catchBlockEnd": 705, "exceptionHandlingCallStart": [592], "exceptionHandlingCallEnd": [692], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 482, "focalAPIEnd": 527, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/webgenome/tree/master/java/core/src/org/rti/webgenome/service/job/SerialQueueJobManager.java", "rawCode": "    /**\n     * Monitor the job queue by executing jobs in the order that they were added to the queue and\n     * waiting if there are no jobs until the next one is added.\n     */\n    private void monitorJobQueue() {\n      JobServices jobServices =\n          new JobServices(ioService, analysisService, plotService, webGenomeDbService);\n      while (true) {\n\n        // Get next job from queue\n        Job job = this.next();\n        while (job == null) {\n          try {\n            Thread.sleep(JOB_EXECUTION_THREAD_SLEEP_TIME);\n          } catch (InterruptedException e) {\n            throw new WebGenomeSystemException(\n                \"Error putting job execution \" + \"thread to sleep\", e);\n          }\n          job = this.next();\n        }\n\n        // Set start time and persist\n        try {\n          LOGGER.info(\"Starting job with id '\" + job.getId() + \"'\");\n          job.setStartDate(new Date());\n          webGenomeDbService.saveOrUpdateJob(job);\n        } catch (Exception e) {\n          LOGGER.error(\"Unable to save job state\", e);\n        }\n\n        // Execute job\n        try {\n          job.execute(jobServices);\n          LOGGER.info(\"Job '\" + job.getId() + \"' successfully completed\");\n        } catch (Exception e) {\n          LOGGER.warn(\"Job '\" + job.getId() + \"' failed\");\n          LOGGER.warn(e);\n          Throwable throwable = e;\n          while (throwable != null) {\n            e.printStackTrace(System.err);\n            throwable = throwable.getCause();\n          }\n          String exceptionMsg = e.getMessage();\n          String msg = Job.JOB_EXECUTION_FAILURE_MESSAGE;\n          if (exceptionMsg != null && exceptionMsg.length() > 0) {\n            msg += \": \" + exceptionMsg;\n          }\n          job.setTerminationMessage(msg);\n        }\n\n        // Set end time and persist\n        try {\n          job.setEndDate(new Date());\n          webGenomeDbService.saveOrUpdateJob(job);\n        } catch (Exception e) {\n          LOGGER.error(\"Unable to save job state\", e);\n        }\n      }\n    }\n"}, {"dataset": "sleep", "exampleID": 9461, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 562, "focalAPIEnd": 600, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ties/winstone/tree/master/winstone-test/test-logic/src/main/java/net/winstone/test/load/LoadTest.java", "rawCode": "  public void test() throws InterruptedException {\n    WebConversation wc = null;\n\n    // Loop through in steps\n    for (int n = startThreads; n <= endThreads; n += stepSize) {\n      if (useKeepAlives) {\n        wc = new WebConversation();\n      }\n\n      // Spawn the threads\n      final int noOfSeconds = (int) stepPeriod / 1000;\n      final List<LoadTestThread> threads = new ArrayList<LoadTestThread>();\n      for (int m = 0; m < n; m++) {\n        threads.add(new LoadTestThread(url, this, wc, noOfSeconds - 1));\n      }\n\n      // Sleep for step period\n      Thread.sleep(stepPeriod + gracePeriod);\n\n      // int errorCount = (noOfSeconds * n) - this.successCount;\n      final Long averageSuccessTime =\n          successCount == 0 ? null : new Long(successTimeTotal / successCount);\n\n      // Write out results\n      LoadTest.logger.info(\n          \"n={}, success={}, error={}, averageTime={}ms\",\n          new Object[] {n, successCount, ((noOfSeconds * n) - successCount), averageSuccessTime});\n\n      // Close threads\n      for (final Iterator<LoadTestThread> i = threads.iterator(); i.hasNext(); ) {\n        i.next().destroy();\n      }\n\n      successTimeTotal = 0;\n      successCount = 0;\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9462, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 309, "focalAPIEnd": 332, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jclouds/legacy-jclouds/tree/master/apis/cloudstack/src/test/java/org/jclouds/cloudstack/features/LoadBalancerClientLiveTest.java", "rawCode": "  private void loopAndCheckSSH() throws IOException {\n    for (int i = 0; i < 5; i++) { // retry loop TODO replace with predicate.\n      try {\n        checkSSH(HostAndPort.fromParts(ip.getIPAddress(), 22));\n        return;\n      } catch (SshException e) {\n        e.printStackTrace();\n        try {\n          Thread.sleep(10 * 1000);\n        } catch (InterruptedException e1) {\n        }\n        continue;\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9463, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 57, "focalAPIEnd": 80, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TeamNyx/packages_apps_Mms/tree/master/tests/src/com/android/mms/ui/SmsTest.java", "rawCode": "  protected void sleep(long sleepTime) {\n    try {\n      Thread.sleep(sleepTime);\n    } catch (InterruptedException e) {\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9464, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["println(*)", "Map<String, List<StepStats>>.remove(String)"], "tryExpressionStart": 191, "tryExpressionEnd": 195, "tryBlockStart": 191, "tryBlockEnd": 2335, "catchExpressionStart": 2189, "catchExpressionEnd": 2209, "catchBlockStart": 2189, "catchBlockEnd": 2335, "exceptionHandlingCallStart": [2217, 2300], "exceptionHandlingCallEnd": [2260, 2320], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 294, "focalAPIEnd": 353, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.sleep(*)"], "useStart": [1443], "useEnd": [1502], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/DEV_v1_9/trunk-archive/src/om/loadtest/TNTester.java", "rawCode": "  /**\n   * Runs through the sequence with one user.\n   *\n   * @param ahsi Array of script items\n   */\n  private void doSequence(Random r, int iServer) {\n    String sOUCU = getNextOUCU();\n    try {\n      // Random delay before starting (so all threads don't begin in synch)\n      if (r != null) Thread.sleep(r.nextInt(DELAYMAX - DELAYMIN + 1) + DELAYMIN);\n\n      Map<String, String> mTokens = new HashMap<String, String>();\n      mTokens.put(\n          \"AUTHCOOKIE\",\n          \"1ed6b71fed0260d1d9aa1730b77325a5430cba4a\" + sOUCU + \"%2E%2E00000000%2E%2E\");\n      String sCookie = sendRequestGetCookie(iServer, mTokens, ahsi[0]);\n      mTokens.put(\"SESSIONCOOKIE\", sCookie);\n\n      if (DEBUG) System.err.println(\"* Got cookie: \" + sCookie);\n\n      List<StepStats> lSteps;\n      synchronized (mStats) {\n        lSteps = mStats.get(sOUCU);\n        if (lSteps == null) {\n          lSteps = new LinkedList<StepStats>();\n          mStats.put(sOUCU, lSteps);\n        } else throw new Error(\"wtf?\");\n        mHosts.put(sOUCU, HOSTS[iServer]);\n      }\n\n      for (int iItem = 1; iItem < ahsi.length; iItem++) {\n        HttpScript.Item i = ahsi[iItem];\n        if (i.getURL().matches(\"^.*/simple1/(\\\\?.*)?$\")) {\n          StepStats ss = new StepStats();\n          lSteps.add(ss);\n\n          if (DEBUG) System.err.println(\"* Step \" + (lSteps.size() - 1));\n          sendRequestGetMedia(iServer, mTokens, i, ss);\n\n          // Delay\n          if (r != null) Thread.sleep(r.nextInt(DELAYMAX - DELAYMIN + 1) + DELAYMIN);\n        }\n      }\n\n      StringBuffer sb = new StringBuffer(sOUCU + \"\\t\" + HOSTS[iServer] + \"\\n\");\n      sb.append(\"\\tXHTML\");\n      long lTotal = 0;\n      for (Iterator i = lSteps.iterator(); i.hasNext(); ) {\n        StepStats ss = (StepStats) i.next();\n        sb.append(\"\\t\" + ss.lTime);\n        lTotal += ss.lTime;\n      }\n      sb.append(\"\\t\\t\" + lTotal);\n      sb.append(\"\\n\\tMedia\");\n      lTotal = 0;\n      for (Iterator i = lSteps.iterator(); i.hasNext(); ) {\n        StepStats ss = (StepStats) i.next();\n        sb.append(\"\\t\" + ss.getMediaTime());\n        lTotal += ss.getMediaTime();\n      }\n      sb.append(\"\\t\\t\" + lTotal);\n      System.out.println(sb.toString());\n    } catch (Throwable t) {\n      System.err.println(sOUCU + \"\\tError\\t\" + t);\n      synchronized (mStats) {\n        mStats.remove(sOUCU);\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9465, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 476, "focalAPIEnd": 493, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ybrs/hazelcastforked/tree/master/hazelcast-client/src/test/java/com/hazelcast/client/HazelcastClientClusterTest.java", "rawCode": "  @Test\n  public void testUseBackupDataGet() throws Exception {\n    final Config config = new Config();\n    final MapConfig mapConfig = new MapConfig();\n    mapConfig.setName(\"q\");\n    mapConfig.setReadBackupData(true);\n    config.setMapConfigs(Collections.singletonMap(mapConfig.getName(), mapConfig));\n    HazelcastInstance h1 = Hazelcast.newHazelcastInstance(config);\n    HazelcastInstance h2 = Hazelcast.newHazelcastInstance(config);\n    h1.getMap(\"q\").put(\"q\", \"Q\");\n    Thread.sleep(50L);\n    HazelcastClient client = newHazelcastClient(h2);\n    assertEquals(\"Q\", client.getMap(\"q\").get(\"q\"));\n  }\n"}, {"dataset": "sleep", "exampleID": 9466, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 717, "focalAPIEnd": 743, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eugenp/stackexchange2twitter/tree/master/src/main/java/org/tweet/meta/component/MetaPoller.java", "rawCode": "  @Scheduled(cron = \"0 30 5 * * *\")\n  public void checkRetweetsMatch() throws JsonProcessingException, InterruptedException {\n    logger.info(\"Starting Meta validity checks\");\n\n    for (final TwitterAccountEnum twitterAccount : TwitterAccountEnum.values()) {\n      if (twitterAccount.isRt()) {\n        logger.info(\n            \"Performing meta validity checks for twitterAccount= \"\n                + twitterAccount.name()\n                + \"; sleeping for 2 secs...\");\n        checkRetweetsMatchOnAccount(twitterAccount.name());\n        logger.info(\n            \"Done performing meta validity checks for twitterAccount= \"\n                + twitterAccount.name()\n                + \"; sleeping for 2 secs...\");\n        Thread.sleep(1000 * 2 * 1); // 2 sec\n      }\n    }\n\n    logger.info(\"Finished Meta validity checks\");\n  }\n"}, {"dataset": "sleep", "exampleID": 9467, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 397, "focalAPIEnd": 423, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ophirdj/shitot4/tree/master/shitot4/tests/acceptanceTest/AcceptanceTest.java", "rawCode": "  /**\n   * Voter changes vote 1 time, tries different station after long time\n   *\n   * @throws Exception\n   */\n  @Test\n  public void testRevoteDifferentStationAfterLongWait() throws Exception {\n    final long waiting_time = (maxVotingTimeSeconds + 1) * 1000;\n    votingData voting[] = {new votingData(1, 0, 0)};\n    startVoting(voting);\n    votingData reVoting[] = {new votingData(1, 1, 1)};\n    Thread.sleep(waiting_time);\n    startVoting(reVoting);\n    expectedPartiesList = initialPartiesList.copy();\n    expectedPartiesList.getPartyBySymbol(getSymbolByPlace(0)).increaseVoteNumber();\n  }\n"}, {"dataset": "sleep", "exampleID": 9468, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["unexpectedException()"], "tryExpressionStart": 629, "tryExpressionEnd": 633, "tryBlockStart": 629, "tryBlockEnd": 933, "catchExpressionStart": 877, "catchExpressionEnd": 897, "catchBlockStart": 877, "catchBlockEnd": 933, "exceptionHandlingCallStart": [905], "exceptionHandlingCallEnd": [926], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 677, "focalAPIEnd": 705, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/concurrent/src/test/java/tests/api/java/util/concurrent/ReentrantReadWriteLockTest.java", "rawCode": "  /** Readlocks succeed after a writing thread unlocks */\n  public void testReadAfterWriteLock() {\n    final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    lock.writeLock().lock();\n    Thread t1 =\n        new Thread(\n            new Runnable() {\n              public void run() {\n                lock.readLock().lock();\n                lock.readLock().unlock();\n              }\n            });\n    Thread t2 =\n        new Thread(\n            new Runnable() {\n              public void run() {\n                lock.readLock().lock();\n                lock.readLock().unlock();\n              }\n            });\n\n    try {\n      t1.start();\n      t2.start();\n      Thread.sleep(SHORT_DELAY_MS);\n      lock.writeLock().unlock();\n      t1.join(MEDIUM_DELAY_MS);\n      t2.join(MEDIUM_DELAY_MS);\n      assertTrue(!t1.isAlive());\n      assertTrue(!t2.isAlive());\n\n    } catch (Exception e) {\n      unexpectedException();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9469, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 302, "focalAPIEnd": 331, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Blakez/android_frameworks_base/tree/master/core/java/android/speech/tts/BlockingAudioTrack.java", "rawCode": "  private void blockUntilEstimatedCompletion() {\n    final int lengthInFrames = mBytesWritten / mBytesPerFrame;\n    final long estimatedTimeMs = (lengthInFrames * 1000 / mSampleRateInHz);\n\n    if (DBG) Log.d(TAG, \"About to sleep for: \" + estimatedTimeMs + \"ms for a short utterance\");\n\n    try {\n      Thread.sleep(estimatedTimeMs);\n    } catch (InterruptedException ie) {\n      // Do nothing.\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9470, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(miliseconds<=0)", "guardType": "IF {", "guardExpressionStart": 289, "guardExpressionEnd": 305, "guardBlockStart": 289, "guardBlockEnd": 313, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 428, "focalAPIEnd": 448, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tubs-legolabor-teamprojekt/schach/tree/master/lejos_nxj/projects/pccomms/lejos/util/Delay.java", "rawCode": "  /**\n   * Wait for the specified number of milliseconds. Delays the current thread for the specified\n   * period of time. Can not be interrupted (but it does preserve the interrupted state).\n   *\n   * @param period time to wait in ms\n   */\n  public static void msDelay(long period) {\n    if (period <= 0) return;\n    long end = System.currentTimeMillis() + period;\n    boolean interrupted = false;\n    do {\n      try {\n        Thread.sleep(period);\n      } catch (InterruptedException ie) {\n        interrupted = true;\n      }\n      period = end - System.currentTimeMillis();\n    } while (period > 0);\n    if (interrupted) Thread.currentThread().interrupt();\n  }\n"}, {"dataset": "sleep", "exampleID": 9471, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 5571, "focalAPIEnd": 5593, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.2/kernel-impl/src/main/java/org/sakaiproject/event/impl/ClusterEventTracking.java", "rawCode": "  /** Run the event checking thread. */\n  public void run() {\n    // since we might be running while the component manager is still being created and populated,\n    // such as at server startup, wait here for a\n    // complete component manager\n    ComponentManager.waitTillConfigured();\n\n    // find the latest event in the db\n    initLastEvent();\n\n    // loop till told to stop\n    while ((!m_threadStop) && (!Thread.currentThread().isInterrupted())) {\n      final String serverInstance = serverConfigurationService().getServerIdInstance();\n      final String serverId = serverConfigurationService().getServerId();\n\n      try {\n        // write any batched events\n        Collection myEvents = new Vector();\n        if (m_batchWrite) {\n          synchronized (m_eventQueue) {\n            if (m_eventQueue.size() > 0) {\n              myEvents.addAll(m_eventQueue);\n              m_eventQueue.clear();\n            }\n          }\n\n          if (myEvents.size() > 0) {\n            if (M_log.isDebugEnabled())\n              M_log.debug(\"writing \" + myEvents.size() + \" batched events\");\n            writeBatchEvents(myEvents);\n          }\n        }\n\n        if (M_log.isDebugEnabled()) M_log.debug(\"checking for events > \" + m_lastEventSeq);\n        // check the db for new events\n        // Note: the events may not all have sessions, so to get them we need an outer join.\n        // TODO: switch to a \"view\" read once that's established, for now, a join -ggolden\n        String statement = clusterEventTrackingServiceSql.getEventSql();\n\n        // we might want a left join, which would get us records from non-sessions, which the above\n        // mysql code does NOT give -ggolden\n        // select e.EVENT_ID,e.EVENT_DATE,e.EVENT,e.REF,e.SESSION_ID,e.EVENT_CODE,s.SESSION_SERVER\n        // from SAKAI_EVENT e\n        // left join SAKAI_SESSION s on (e.SESSION_ID = s.SESSION_ID)\n        // where EVENT_ID > 0\n\n        // send in the last seq number parameter\n        Object[] fields = new Object[1];\n        fields[0] = Long.valueOf(m_lastEventSeq);\n\n        List events =\n            sqlService()\n                .dbRead(\n                    statement,\n                    fields,\n                    new SqlReader() {\n                      public Object readSqlResultRecord(ResultSet result) {\n                        try {\n                          // read the Event\n                          long id = result.getLong(1);\n                          Time date =\n                              timeService()\n                                  .newTime(result.getTimestamp(2, sqlService().getCal()).getTime());\n                          String function = result.getString(3);\n                          String ref = result.getString(4);\n                          String session = result.getString(5);\n                          String code = result.getString(6);\n                          String context = result.getString(7);\n                          String eventSessionServerId = result.getString(8);\n\n                          // for each one (really, for the last one), update the last event seen seq\n                          // number\n                          if (id > m_lastEventSeq) {\n                            m_lastEventSeq = id;\n                          }\n\n                          boolean nonSessionEvent = session.startsWith(\"~\");\n                          String userId = null;\n                          boolean skipIt = false;\n\n                          if (nonSessionEvent) {\n                            String[] parts = StringUtil.split(session, \"~\");\n                            userId = parts[2];\n\n                            // we skip this event if it came from our server\n                            skipIt = serverId.equals(parts[1]);\n                          }\n\n                          // for session events, if the event is from this server instance,\n                          // we have already processed it and can skip it here.\n                          else {\n                            skipIt = serverInstance.equals(eventSessionServerId);\n                          }\n\n                          if (skipIt) {\n                            return null;\n                          }\n\n                          // Note: events from outside the server don't need notification info,\n                          // since notification is processed only on internal\n                          // events -ggolden\n                          BaseEvent event =\n                              new BaseEvent(\n                                  id,\n                                  function,\n                                  ref,\n                                  context,\n                                  \"m\".equals(code),\n                                  NotificationService.NOTI_NONE);\n                          if (nonSessionEvent) {\n                            event.setUserId(userId);\n                          } else {\n                            event.setSessionId(session);\n                          }\n\n                          return event;\n                        } catch (SQLException ignore) {\n                          return null;\n                        }\n                      }\n                    });\n\n        // for each new event found, notify observers\n        for (int i = 0; i < events.size(); i++) {\n          Event event = (Event) events.get(i);\n          notifyObservers(event, false);\n        }\n      } catch (Exception e) {\n        M_log.warn(\"run: will continue: \", e);\n      }\n\n      // take a small nap\n      try {\n        Thread.sleep(m_period);\n      } catch (Exception ignore) {\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9472, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 1004, "focalAPIEnd": 1053, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jonnyzzz/maragogype/tree/master/tags/v1.4/java/com/xerox/amazonws/ec2/EC2Utils.java", "rawCode": "  /**\n   * This method makes a best effort to fetch a piece of instance metadata.\n   *\n   * @param key the name of the metadata to fetch\n   * @return value of the metadata item\n   */\n  public static String getInstanceUserdata() throws IOException {\n    int retries = 0;\n    while (true) {\n      try {\n        URL url = new URL(\"http://169.254.169.254/latest/user-data/\");\n        InputStreamReader rdr = new InputStreamReader(url.openStream());\n        StringWriter wtr = new StringWriter();\n        char[] buf = new char[1024];\n        int bytes;\n        while ((bytes = rdr.read(buf)) > -1) {\n          if (bytes > 0) {\n            wtr.write(buf, 0, bytes);\n          }\n        }\n        rdr.close();\n        return wtr.toString();\n      } catch (IOException ex) {\n        if (retries == 5) {\n          logger.debug(\"Problem getting user data, retries exhausted...\");\n          return null;\n        } else {\n          logger.debug(\"Problem getting user data, retrying...\");\n          try {\n            Thread.sleep((int) Math.pow(2.0, retries) * 1000);\n          } catch (InterruptedException e) {\n          }\n          retries++;\n        }\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9473, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "v(String,*)"], "tryExpressionStart": 221, "tryExpressionEnd": 225, "tryBlockStart": 221, "tryBlockEnd": 571, "catchExpressionStart": 512, "catchExpressionEnd": 532, "catchBlockStart": 512, "catchBlockEnd": 571, "exceptionHandlingCallStart": [551, 540], "exceptionHandlingCallEnd": [563, 564], "configuration": ["thread.sleep(int)"], "configurationStart": [380], "configurationEnd": [399], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 425, "focalAPIEnd": 465, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/faux123/android_frameworks_base/tree/master/media/tests/MediaFrameworkTest/src/com/android/mediaframeworktest/functional/CodecTest.java", "rawCode": "  public static boolean getCurrentPosition(String filePath) {\n    Log.v(TAG, \"GetCurrentPosition - \" + filePath);\n    int currentPosition = 0;\n    long t1 = 0;\n    long t2 = 0;\n    MediaPlayer mp = new MediaPlayer();\n    try {\n      mp.setDataSource(filePath);\n      Log.v(TAG, \"start playback\");\n      mp.prepare();\n      mp.start();\n      t1 = SystemClock.uptimeMillis();\n      Thread.sleep(10000);\n      mp.pause();\n      Thread.sleep(MediaNames.PAUSE_WAIT_TIME);\n      t2 = SystemClock.uptimeMillis();\n    } catch (Exception e) {\n      Log.v(TAG, e.toString());\n    }\n    currentPosition = mp.getCurrentPosition();\n    mp.stop();\n    mp.release();\n    Log.v(TAG, \"mp currentPositon = \" + currentPosition + \" play duration = \" + (t2 - t1));\n    // The currentposition should be within 10% of the sleep time\n    // For the very short mp3, it should return the length instead of 10 seconds\n    if (filePath.equals(MediaNames.SHORTMP3)) {\n      if (currentPosition < 1000) return true;\n    }\n    if ((currentPosition < ((t2 - t1) * 1.2)) && (currentPosition > 0)) return true;\n    else return false;\n  }\n"}, {"dataset": "sleep", "exampleID": 9474, "initialization": ["long miliseconds = Retry.getRetryDelay()"], "initializationStart": [211], "initializationEnd": [232], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["exception_retryDelayInterrupted()", "new BapPublisherException(*,*)"], "tryExpressionStart": 242, "tryExpressionEnd": 246, "tryBlockStart": 242, "tryBlockEnd": 431, "catchExpressionStart": 301, "catchExpressionEnd": 333, "catchBlockStart": 301, "catchBlockEnd": 431, "exceptionHandlingCallStart": [375, 349], "exceptionHandlingCallEnd": [417, 422], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 256, "focalAPIEnd": 291, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bap2000/jenkins-publish-over-plugin/tree/master/src/main/java/jenkins/plugins/publish_over/BapPublisher.java", "rawCode": "    private boolean delay() {\n      LOGGER.log(Level.WARNING, Messages.log_exceptionCaught_retrying(), exception);\n      buildInfo.println(\n          Messages.console_retryDelay(exception.getLocalizedMessage(), retry.getRetryDelay()));\n      try {\n        Thread.sleep(retry.getRetryDelay());\n      } catch (InterruptedException ie) {\n        throw new BapPublisherException(Messages.exception_retryDelayInterrupted(), ie);\n      }\n      return true;\n    }\n"}, {"dataset": "sleep", "exampleID": 9475, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 194, "focalAPIEnd": 217, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/madiator/HadoopUSC/tree/master/src/test/org/apache/hadoop/hdfs/server/namenode/metrics/TestNameNodeMetrics.java", "rawCode": "  private void updateMetrics(long sleepTime) throws Exception {\n    // Wait for metrics update (corresponds to dfs.replication.interval\n    // for some block related metrics to get updated)\n    Thread.sleep(sleepTime);\n    metrics.doUpdates(null);\n  }\n"}, {"dataset": "sleep", "exampleID": 9476, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 636, "focalAPIEnd": 659, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/alandbarroso/tcc-rr/tree/master/robocuprescue2013/Simuladores/roborescue-2013/modules/standard/src/rescuecore2/standard/kernel/StandardCommandCollector.java", "rawCode": "  @Override\n  public Collection<Command> getAgentCommands(Collection<AgentProxy> agents, int timestep)\n      throws InterruptedException {\n    Set<AgentProxy> waiting = new HashSet<AgentProxy>(agents);\n    while (!waiting.isEmpty()) {\n      for (AgentProxy next : agents) {\n        Collection<Command> commands = next.getAgentCommands(timestep);\n        for (Command c : commands) {\n          if (isTriggerCommand(c)) {\n            Logger.debug(next + \" sent a trigger command\");\n            waiting.remove(next);\n          }\n        }\n      }\n      Logger.info(this + \" waiting for commands from \" + waiting.size() + \" agents\");\n      Thread.sleep(WAIT_TIME);\n    }\n    Collection<Command> result = new ArrayList<Command>();\n    for (AgentProxy next : agents) {\n      result.addAll(next.getAgentCommands(timestep));\n    }\n    Logger.trace(this + \" returning \" + result.size() + \" commands\");\n    return result;\n  }\n"}, {"dataset": "sleep", "exampleID": 9477, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 1268, "focalAPIEnd": 1286, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Spoutcraft/Spoutcraft/tree/master/src/main/java/net/minecraft/src/Minecraft.java", "rawCode": "  /** Arguments: World foldername, World ingame name, WorldSettings */\n  public void launchIntegratedServer(\n      String par1Str, String par2Str, WorldSettings par3WorldSettings) {\n    this.loadWorld((WorldClient) null);\n    System.gc();\n    ISaveHandler var4 = this.saveLoader.getSaveLoader(par1Str, false);\n    WorldInfo var5 = var4.loadWorldInfo();\n\n    if (var5 == null && par3WorldSettings != null) {\n      var5 = new WorldInfo(par3WorldSettings, par1Str);\n      var4.saveWorldInfo(var5);\n    }\n\n    if (par3WorldSettings == null) {\n      par3WorldSettings = new WorldSettings(var5);\n    }\n\n    this.statFileWriter.readStat(StatList.startGameStat, 1);\n    this.theIntegratedServer = new IntegratedServer(this, par1Str, par2Str, par3WorldSettings);\n    this.theIntegratedServer.startServerThread();\n    this.integratedServerIsRunning = true;\n    this.loadingScreen.displayProgressMessage(I18n.getString(\"menu.loadingLevel\"));\n\n    while (!this.theIntegratedServer.serverIsInRunLoop()) {\n      String var6 = this.theIntegratedServer.getUserMessage();\n\n      if (var6 != null) {\n        this.loadingScreen.resetProgresAndWorkingMessage(I18n.getString(var6));\n      } else {\n        this.loadingScreen.resetProgresAndWorkingMessage(\"\");\n      }\n\n      try {\n        Thread.sleep(200L);\n      } catch (InterruptedException var9) {;\n      }\n    }\n\n    this.displayGuiScreen((GuiScreen) null);\n\n    try {\n      NetClientHandler var10 = new NetClientHandler(this, this.theIntegratedServer);\n      this.myNetworkManager = var10.getNetManager();\n    } catch (IOException var8) {\n      this.displayCrashReport(\n          this.addGraphicsAndWorldToCrashReport(\n              new CrashReport(\"Connecting to integrated server\", var8)));\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9478, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "miliseconds>0", "guardType": "IF {", "guardExpressionStart": 327, "guardExpressionEnd": 341, "guardBlockStart": 327, "guardBlockEnd": 982, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 417, "focalAPIEnd": 436, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/muloem/xins/tree/master/src/java-common/org/xins/common/collections/expiry/ExpiryStrategy.java", "rawCode": "    /** Runs this thread. The thread keeps running until the expiry strategy is stopped. */\n    public void run() {\n\n      Log.log_1402(_instanceNum);\n\n      long now = System.currentTimeMillis();\n      long next = now + _precision;\n\n      while (!_stop) {\n        boolean interrupted;\n        long sleep = next - now;\n        if (sleep > 0) {\n          Log.log_1404(_instanceNum, sleep);\n          try {\n            Thread.sleep(sleep);\n            interrupted = false;\n\n            // Sleep was interrupted\n          } catch (InterruptedException exception) {\n            interrupted = true;\n          }\n\n          // Determine how much time we spent since we started sleeping\n          long after = System.currentTimeMillis();\n          long slept = after - now;\n          now = after;\n\n          // Perform logging\n          if (interrupted) {\n            Log.log_1405(_instanceNum, slept);\n          } else {\n            Log.log_1406(_instanceNum, slept);\n          }\n        }\n\n        // If we should stop, then exit the loop\n        if (_stop) {\n          break;\n        }\n\n        while (next <= now) {\n          Log.log_1407(_instanceNum);\n          doTick();\n          now = System.currentTimeMillis();\n          next += _precision;\n        }\n      }\n\n      Log.log_1403(_instanceNum);\n    }\n"}, {"dataset": "sleep", "exampleID": 9479, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 1585, "tryExpressionEnd": 1589, "tryBlockStart": 1585, "tryBlockEnd": 1727, "catchExpressionStart": 1633, "catchExpressionEnd": 1653, "catchBlockStart": 1633, "catchBlockEnd": 1727, "exceptionHandlingCallStart": [1685], "exceptionHandlingCallEnd": [1718], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 1599, "focalAPIEnd": 1623, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dustin/snippets/tree/master/java/swing/eBayWatch/eBayWatch.java", "rawCode": "  public void run() {\n\n    while (true) {\n\n      for (Enumeration e = queue.keys(); e.hasMoreElements(); ) {\n        try {\n\n          String key = (String) e.nextElement();\n          Watcher ebw = (Watcher) queue.get(key);\n          String tl = ebw.getTime();\n\n          if (tl.length() > 0) {\n            tl += \" left\";\n          }\n\n          // Go ahead and remove stuff first.\n          if (tl.startsWith(\"Auction has ended\")) {\n            setStatus(\"Removing \" + key);\n            queue.remove(key);\n            prop.remove(\"item.\" + key);\n          } else {\n            setStatus(\"Checking on \" + key + \" \" + tl);\n\n            if (ebw.hasChanged()) {\n              setStatus(key + \" has changed.\");\n\n              // Figure out if we need a Was line\n              String was = \"\";\n              was = ebw.oldStatus();\n              if (was.length() > 0) {\n                was = \"\\n\\nWas:\\n\" + was + \"\\n\";\n              } else {\n                // If we didn't have a was, we didn't have\n                // a description for this item in the\n                // properties file (maybe)\n                prop.put(\"item.\" + key, ebw.describe());\n              }\n\n              String msg = \"Item \" + key + \" has changed:\\n\" + ebw.currentStatus() + was + tl;\n              popUp(msg);\n            } // Item info has changed\n          } // Auction for item has not ended\n\n        } catch (Exception cept) {\n          System.err.println(\"Error checking stuff: \" + cept);\n          cept.printStackTrace();\n        }\n      } // Looking through all of the queued items\n\n      // Wait\n      try {\n        Thread.sleep(300 * 1000);\n      } catch (Exception e) {\n        // Don't care\n        System.err.println(\"Error! \" + e);\n      } // sleep (and exception)\n    } // Infinite Loop(tm)\n  } // Thread run\n"}, {"dataset": "sleep", "exampleID": 9480, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 440, "focalAPIEnd": 459, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/funambol-mirror/funambol-client-sdk/tree/master/us8885/client/src/test/com/funambol/client/push/SyncSchedulerTest.java", "rawCode": "  /** Test multiple SyncRequests of the same type, from the same caller */\n  public void testMultipleRequests(Object item, int num, long delay, long interval)\n      throws Exception {\n\n    Log.debug(\"==== Running testMultipleRequests test. Interval=\" + interval + \" ====\");\n\n    Object[] content = {item};\n\n    // setting up a sync request\n    request = new TestSyncRequest(content[0], interval);\n\n    for (int i = 0; i < num; i++) {\n      Thread.sleep(delay);\n      scheduler.addRequest(request);\n      if (Log.isLoggable(Log.DEBUG)) {\n        Log.debug(\"Sync Request added\");\n      }\n    }\n    assertSync(content, interval);\n  }\n"}, {"dataset": "sleep", "exampleID": 9481, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 1356, "focalAPIEnd": 1383, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["JHEvenHandlerForTest.stop()", "verify(EventWriter)", "close()"], "finallyExpressionStart": 1470, "finallyExpressionEnd": 1478, "finallyBlockStart": 1470, "finallyBlockEnd": 1538, "cleanUpCallStart": [1486, 1505, 1505], "cleanUpCallEnd": [1497, 1523, 1531], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/test/java/org/apache/hadoop/mapreduce/jobhistory/TestJobHistoryEventHandler.java", "rawCode": "  @Test\n  public void testUnflushedTimer() throws Exception {\n    TestParams t = new TestParams();\n    Configuration conf = new Configuration();\n    conf.set(MRJobConfig.MR_AM_STAGING_DIR, t.workDir);\n    conf.setLong(\n        MRJobConfig.MR_AM_HISTORY_COMPLETE_EVENT_FLUSH_TIMEOUT_MS, 2 * 1000l); // 2 seconds.\n    conf.setInt(MRJobConfig.MR_AM_HISTORY_JOB_COMPLETE_UNFLUSHED_MULTIPLIER, 10);\n    conf.setInt(MRJobConfig.MR_AM_HISTORY_MAX_UNFLUSHED_COMPLETE_EVENTS, 100);\n    conf.setInt(MRJobConfig.MR_AM_HISTORY_USE_BATCHED_FLUSH_QUEUE_SIZE_THRESHOLD, 5);\n\n    JHEvenHandlerForTest realJheh = new JHEvenHandlerForTest(t.mockAppContext, 0);\n    JHEvenHandlerForTest jheh = spy(realJheh);\n    jheh.init(conf);\n\n    EventWriter mockWriter = null;\n    try {\n      jheh.start();\n      handleEvent(\n          jheh,\n          new JobHistoryEvent(\n              t.jobId,\n              new AMStartedEvent(t.appAttemptId, 200, t.containerId, \"nmhost\", 3000, 4000)));\n      mockWriter = jheh.getEventWriter();\n      verify(mockWriter).write(any(HistoryEvent.class));\n\n      for (int i = 0; i < 100; i++) {\n        queueEvent(\n            jheh,\n            new JobHistoryEvent(\n                t.jobId, new TaskFinishedEvent(t.taskID, null, 0, TaskType.MAP, \"\", null)));\n      }\n\n      handleNextNEvents(jheh, 9);\n      verify(mockWriter, times(0)).flush();\n\n      Thread.sleep(2 * 4 * 1000l); // 4 seconds should be enough. Just be safe.\n      verify(mockWriter).flush();\n    } finally {\n      jheh.stop();\n      verify(mockWriter).close();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9482, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 7645, "tryExpressionEnd": 7649, "tryBlockStart": 7645, "tryBlockEnd": 7760, "catchExpressionStart": 7687, "catchExpressionEnd": 7725, "catchBlockStart": 7687, "catchBlockEnd": 7760, "exceptionHandlingCallStart": [7733], "exceptionHandlingCallEnd": [7753], "configuration": ["thread.sleep(int)"], "configurationStart": [6751], "configurationEnd": [6768], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 7657, "focalAPIEnd": 7679, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sgothel/jogl/tree/master/src/test/com/jogamp/opengl/test/junit/jogl/perf/TestPerf001GLJPanelInit02AWT.java", "rawCode": "  public void test(\n      final GLCapabilitiesImmutable caps,\n      final boolean useGears,\n      final boolean skipGLOrientationVerticalFlip,\n      final int width,\n      final int height,\n      final int frameCount,\n      final boolean initMT,\n      final boolean useSwingDoubleBuffer,\n      final CanvasType canvasType,\n      final boolean useAnim,\n      final boolean overlap) {\n    final GLAnimatorControl animator;\n    if (useAnim) {\n      animator = new Animator();\n    } else {\n      animator = null;\n    }\n    final int eWidth, eHeight;\n    {\n      final int cols = (int) Math.round(Math.sqrt(frameCount));\n      final int rows = frameCount / cols;\n      eWidth = width / cols - 32;\n      eHeight = height / rows - 32;\n    }\n    System.err.println(\n        \"Frame size: \"\n            + width\n            + \"x\"\n            + height\n            + \" -> \"\n            + frameCount\n            + \" x \"\n            + eWidth\n            + \"x\"\n            + eHeight\n            + \", overlap \"\n            + overlap);\n    System.err.println(\n        \"SkipGLOrientationVerticalFlip \"\n            + skipGLOrientationVerticalFlip\n            + \", useGears \"\n            + useGears\n            + \", initMT \"\n            + initMT\n            + \", useAnim \"\n            + useAnim);\n    final JFrame[] frame = new JFrame[frameCount];\n    final List<NewtCanvasAWT> newtCanvasAWTList = new ArrayList<NewtCanvasAWT>();\n\n    final long[] t = new long[10];\n    if (wait) {\n      UITestCase.waitForKey(\"Pre-Init\");\n    }\n    System.err.println(\"INIT START\");\n    initCount.set(0);\n    try {\n      javax.swing.SwingUtilities.invokeAndWait(\n          new Runnable() {\n            public void run() {\n              t[0] = Platform.currentTimeMillis();\n              int x = 32, y = 32;\n              for (int i = 0; i < frameCount; i++) {\n                frame[i] = new JFrame(i + \"/\" + frameCount);\n                frame[i].setLocation(x, y);\n                if (!overlap) {\n                  x += eWidth + 32;\n                  if (x >= width) {\n                    x = 32;\n                    y += eHeight + 32;\n                  }\n                }\n                final JPanel panel = new JPanel();\n                panel.setLayout(new BorderLayout());\n                panel.setDoubleBuffered(useSwingDoubleBuffer);\n                // panel.setBounds(0, 0, width, height);\n                final Dimension eSize = new Dimension(eWidth, eHeight);\n                final GLADComp gladComp;\n                switch (canvasType) {\n                  case GLCanvas_T:\n                    gladComp = createGLCanvas(caps, useGears, animator, eSize);\n                    break;\n                  case GLJPanel_T:\n                    gladComp =\n                        createGLJPanel(\n                            initMT,\n                            useSwingDoubleBuffer,\n                            caps,\n                            useGears,\n                            skipGLOrientationVerticalFlip,\n                            animator,\n                            eSize);\n                    break;\n                  case NewtCanvasAWT_T:\n                    gladComp = createNewtCanvasAWT(caps, useGears, animator, eSize);\n                    newtCanvasAWTList.add((NewtCanvasAWT) gladComp.comp);\n                    break;\n                  case NOP_T:\n                    gladComp = null;\n                    break;\n                  default:\n                    throw new InternalError(\"XXX\");\n                }\n\n                if (null != gladComp) {\n                  gladComp.glad.addGLEventListener(\n                      new GLEventListener() {\n                        @Override\n                        public void init(final GLAutoDrawable drawable) {\n                          initCount.incrementAndGet();\n                        }\n\n                        @Override\n                        public void dispose(final GLAutoDrawable drawable) {}\n\n                        @Override\n                        public void display(final GLAutoDrawable drawable) {}\n\n                        @Override\n                        public void reshape(\n                            final GLAutoDrawable drawable,\n                            final int x,\n                            final int y,\n                            final int width,\n                            final int height) {}\n                      });\n                  panel.add(gladComp.comp);\n                } else {\n                  @SuppressWarnings(\"serial\")\n                  final JTextArea c =\n                      new JTextArea(\"area \" + i) {\n                        boolean initialized = false, added = false;\n                        int reshapeWidth = 0, reshapeHeight = 0;\n\n                        @Override\n                        public void addNotify() {\n                          added = true;\n                          super.addNotify();\n                        }\n\n                        @SuppressWarnings(\"deprecation\")\n                        @Override\n                        public void reshape(\n                            final int x, final int y, final int width, final int height) {\n                          super.reshape(x, y, width, height);\n                          reshapeWidth = width;\n                          reshapeHeight = height;\n                        }\n\n                        @Override\n                        protected void paintComponent(final Graphics g) {\n                          super.paintComponent(g);\n                          if (!initialized\n                              && added\n                              && reshapeWidth > 0\n                              && reshapeHeight > 0\n                              && isDisplayable()) {\n                            initialized = true;\n                            initCount.incrementAndGet();\n                          }\n                        }\n                      };\n                  c.setEditable(false);\n                  c.setSize(eSize);\n                  c.setPreferredSize(eSize);\n                  panel.add(c);\n                }\n                frame[i].getContentPane().add(panel);\n\n                // frame.validate();\n                frame[i].pack();\n              }\n              t[1] = Platform.currentTimeMillis();\n              for (int i = 0; i < frameCount; i++) {\n                frame[i].setVisible(true);\n              }\n              t[2] = Platform.currentTimeMillis();\n            }\n          });\n    } catch (final Throwable throwable) {\n      throwable.printStackTrace();\n      Assume.assumeNoException(throwable);\n    }\n    final long t0 = System.currentTimeMillis();\n    long t1 = t0;\n    while (frameCount > initCount.get() && INIT_TIMEOUT > t1 - t0) {\n      try {\n        Thread.sleep(100);\n        System.err.println(\"Sleep initialized: \" + initCount + \"/\" + frameCount);\n      } catch (final InterruptedException e1) {\n        e1.printStackTrace();\n      }\n      t1 = System.currentTimeMillis();\n    }\n    t[3] = Platform.currentTimeMillis();\n    final double panelCountF = initCount.get();\n    System.err.printf(\n        \"P: %d %s%s:%n\\tctor\\t%6d/t %6.2f/1%n\\tvisible\\t%6d/t %6.2f/1%n\\tsum-i\\t%6d/t %6.2f/1%n\",\n        initCount.get(),\n        canvasType,\n        initMT ? \" (mt)\" : \" (01)\",\n        t[1] - t[0],\n        (t[1] - t[0]) / panelCountF,\n        t[3] - t[1],\n        (t[3] - t[1]) / panelCountF,\n        t[3] - t[0],\n        (t[3] - t[0]) / panelCountF);\n\n    System.err.println(\"INIT END: \" + initCount + \"/\" + frameCount);\n    if (wait) {\n      UITestCase.waitForKey(\"Post-Init\");\n    }\n    if (null != animator) {\n      animator.start();\n    }\n    try {\n      Thread.sleep(duration);\n    } catch (final InterruptedException e1) {\n      e1.printStackTrace();\n    }\n    if (null != animator) {\n      animator.stop();\n    }\n    t[4] = Platform.currentTimeMillis();\n    try {\n      SwingUtilities.invokeAndWait(\n          new Runnable() {\n            public void run() {\n              while (!newtCanvasAWTList.isEmpty()) {\n                newtCanvasAWTList.remove(0).destroy(); // removeNotify does not destroy GLWindow\n              }\n              for (int i = 0; i < frameCount; i++) {\n                frame[i].dispose();\n              }\n            }\n          });\n    } catch (final Exception e1) {\n      e1.printStackTrace();\n    }\n\n    final long ti_net = (t[4] - t[0]) - duration;\n    System.err.printf(\n        \"T: duration %d %d%n\\ttotal-d\\t%6d/t %6.2f/1%n\\ttotal-i\\t%6d/t %6.2f/1%n\",\n        duration,\n        t[4] - t[3],\n        t[4] - t[0],\n        (t[4] - t[0]) / panelCountF,\n        ti_net,\n        ti_net / panelCountF);\n    System.err.println(\"Total: \" + (t[4] - t[0]));\n  }\n"}, {"dataset": "sleep", "exampleID": 9483, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(miliseconds<=0)", "guardType": "IF {", "guardExpressionStart": 289, "guardExpressionEnd": 305, "guardBlockStart": 289, "guardBlockEnd": 313, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 428, "focalAPIEnd": 448, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tubs-legolabor-teamprojekt/schach/tree/master/lejos_nxj/projects/classes/lejos/util/Delay.java", "rawCode": "  /**\n   * Wait for the specified number of milliseconds. Delays the current thread for the specified\n   * period of time. Can not be interrupted (but it does preserve the interrupted state).\n   *\n   * @param period time to wait in ms\n   */\n  public static void msDelay(long period) {\n    if (period <= 0) return;\n    long end = System.currentTimeMillis() + period;\n    boolean interrupted = false;\n    do {\n      try {\n        Thread.sleep(period);\n      } catch (InterruptedException ie) {\n        interrupted = true;\n      }\n      period = end - System.currentTimeMillis();\n    } while (period > 0);\n    if (interrupted) Thread.currentThread().interrupt();\n  }\n"}, {"dataset": "sleep", "exampleID": 9484, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "e(String,*)"], "tryExpressionStart": 88, "tryExpressionEnd": 92, "tryBlockStart": 88, "tryBlockEnd": 1144, "catchExpressionStart": 1085, "catchExpressionEnd": 1105, "catchBlockStart": 1085, "catchBlockEnd": 1144, "exceptionHandlingCallStart": [1124, 1113], "exceptionHandlingCallEnd": [1136, 1137], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 363, "focalAPIEnd": 408, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.sleep(*)"], "useStart": [568], "useEnd": [613], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dileepbapat/music/tree/master/tests/src/com/android/music/stress/MusicPlaybackStress.java", "rawCode": "  @LargeTest\n  public void testPlayAllSongs() {\n    Activity mediaPlaybackActivity;\n    try {\n      Instrumentation inst = getInstrumentation();\n      ActivityMonitor mediaPlaybackMon =\n          inst.addMonitor(\"com.android.music.MediaPlaybackActivity\", null, false);\n      inst.invokeMenuActionSync(getActivity(), MusicUtils.Defs.CHILD_MENU_BASE + 3, 0);\n      Thread.sleep(MusicPlayerNames.WAIT_LONG_TIME);\n      mediaPlaybackActivity = mediaPlaybackMon.waitForActivityWithTimeout(2000);\n      for (int i = 0; i < MusicPlayerNames.NO_SKIPPING_SONGS; i++) {\n        Thread.sleep(MusicPlayerNames.SKIP_WAIT_TIME);\n        if (i == 0) {\n          // Set the repeat all\n          inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_RIGHT);\n          inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_UP);\n          inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_CENTER);\n\n          // Set focus on the next button\n          inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_DOWN);\n        }\n        inst.sendKeyDownUpSync(KeyEvent.KEYCODE_DPAD_CENTER);\n      }\n      mediaPlaybackActivity.finish();\n    } catch (Exception e) {\n      Log.e(TAG, e.toString());\n    }\n    // Verification: check if it is in low memory\n    ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();\n    ((ActivityManager) getActivity().getSystemService(Context.ACTIVITY_SERVICE)).getMemoryInfo(mi);\n    assertFalse(TAG, mi.lowMemory);\n  }\n"}, {"dataset": "sleep", "exampleID": 9485, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 40, "tryExpressionEnd": 44, "tryBlockStart": 40, "tryBlockEnd": 148, "catchExpressionStart": 83, "catchExpressionEnd": 114, "catchBlockStart": 83, "catchBlockEnd": 148, "exceptionHandlingCallStart": [122], "exceptionHandlingCallEnd": [141], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 52, "focalAPIEnd": 75, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/elka-projekt/cs-voltdb/tree/master/tests/frontend/org/voltdb/client/ArbitraryDurationProc.java", "rawCode": "  public long run(long timeoutMS) {\n    try {\n      Thread.sleep(timeoutMS);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n    return 0;\n  }\n"}, {"dataset": "sleep", "exampleID": 9486, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 105, "tryExpressionEnd": 109, "tryBlockStart": 105, "tryBlockEnd": 254, "catchExpressionStart": 150, "catchExpressionEnd": 181, "catchBlockStart": 150, "catchBlockEnd": 254, "exceptionHandlingCallStart": [191], "exceptionHandlingCallEnd": [245], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 119, "focalAPIEnd": 140, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dbisiw07/multiplegerrit/tree/master/gerrit-events/src/test/java/com/sonyericsson/hudson/plugins/gerrit/gerritevents/watchdog/StreamWatchdogTest.java", "rawCode": "    @Override\n    public void run() {\n      System.out.println(\"WaitLongTimeCommand starting...\");\n      try {\n        Thread.sleep(timeout);\n      } catch (InterruptedException e) {\n        System.err.println(\"WaitLongTimeCommand interrupted!\");\n      }\n      System.out.println(\"WaitLongTimeCommand finished.\");\n      stop(0);\n    }\n"}, {"dataset": "sleep", "exampleID": 9487, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 96, "focalAPIEnd": 140, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/trxsys/gluon/tree/master/test/validation/Store/Worker.java", "rawCode": "  /** Wait for the entrance of more clients.. */\n  private void waitClients() {\n    try {\n      Thread.sleep((new Random()).nextInt(10) * 5);\n    } catch (InterruptedException e) {\n      // Wake up... more clients?\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9488, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 329, "focalAPIEnd": 369, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.2/kernel-impl/src/test/java/org/sakaiproject/tool/impl/MySessionTest.java", "rawCode": "  public void testIsInactive() throws InterruptedException {\n    // return ((m_inactiveInterval > 0) && (System.currentTimeMillis() > (m_accessed +\n    // (m_inactiveInterval * 1000))));\n    MySession session = createSession();\n    int inactivityThreshold = 1;\n    session.setMaxInactiveInterval(1);\n    session.setActive();\n    Thread.sleep(inactivityThreshold * 2000);\n    assertTrue(session.isInactive());\n  }\n"}, {"dataset": "sleep", "exampleID": 9489, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 397, "focalAPIEnd": 439, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Rubusch/android/tree/master/WSN04/src/edu/wsn/phoneusage/main/NetDeviceObserver.java", "rawCode": "  public void run() {\n    int numberOfComponents = deviceComponents.size();\n    for (int i = 0; i < numberOfComponents; i++) {\n      deviceComponents.get(i).init(SystemInfo.PERIOD_NET_DEVICE);\n      deviceComponents.get(i).start();\n    }\n    IterationData[] dataTemp = new IterationData[numberOfComponents];\n    while (!Thread.interrupted()) {\n\n      try {\n        Thread.currentThread();\n        Thread.sleep(SystemInfo.PERIOD_NET_DEVICE);\n      } catch (InterruptedException e) {\n        break;\n      }\n\n      // wifi\n      probe_wifi(dataTemp[0]);\n\n      // threeg\n      probe_threeg(dataTemp[1]);\n    }\n\n    // in case, join components thread and stop them\n    for (int i = 0; i < numberOfComponents; i++) {\n      deviceComponents.get(i).interrupt();\n    }\n\n    for (int i = 0; i < numberOfComponents; i++) {\n      try {\n        deviceComponents.get(i).join();\n      } catch (InterruptedException e) {\n      }\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9490, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 198, "focalAPIEnd": 224, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cityindex/JsTestDriver/tree/master/JsTestDriver/src/com/google/jstestdriver/util/Sleeper.java", "rawCode": "  /**\n   * Stops execution in the current thread for the definied milliseconds.\n   *\n   * @throws InterruptedException\n   */\n  public void sleep(long milliseconds) throws InterruptedException {\n    Thread.sleep(milliseconds);\n  }\n"}, {"dataset": "sleep", "exampleID": 9491, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": [], "tryExpressionStart": 882, "tryExpressionEnd": 886, "tryBlockStart": 882, "tryBlockEnd": 992, "catchExpressionStart": 1225, "catchExpressionEnd": 1245, "catchBlockStart": 1225, "catchBlockEnd": 1287, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 896, "focalAPIEnd": 920, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Blakez/android_frameworks_base/tree/master/services/tests/servicestests/src/com/android/server/AccessibilityManagerServiceTest.java", "rawCode": "  /**\n   * Asserts the the mock accessibility service has been successfully verified (which is it has\n   * received the expected method calls with expected arguments) within the {@link\n   * #TIMEOUT_BINDER_CALL}. The verified state is checked by polling upon small intervals.\n   *\n   * @param service The service to verify.\n   * @throws Exception If the verification has failed with exception after the {@link\n   *     #TIMEOUT_BINDER_CALL}.\n   */\n  private void assertMockServiceVerifiedWithinTimeout(MockAccessibilityService service)\n      throws Exception {\n    Exception lastVerifyException = null;\n    long beginTime = SystemClock.uptimeMillis();\n    long pollTmeout = TIMEOUT_BINDER_CALL / 5;\n\n    // poll until the timeout has elapsed\n    while (SystemClock.uptimeMillis() - beginTime < TIMEOUT_BINDER_CALL) {\n      // sleep first since immediate call will always fail\n      try {\n        Thread.sleep(pollTmeout);\n      } catch (InterruptedException ie) {\n        /* ignore */\n      }\n      // poll for verification and if this fails save the exception and\n      // keep polling\n      try {\n        service.verify();\n        // reset so it does not accept more events\n        service.reset();\n        return;\n      } catch (Exception e) {\n        lastVerifyException = e;\n      }\n    }\n\n    // reset, we have already failed\n    service.reset();\n\n    // always not null\n    throw lastVerifyException;\n  }\n"}, {"dataset": "sleep", "exampleID": 9492, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 424, "focalAPIEnd": 447, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/shutterstock/bristlecone/tree/master/src/com/continuent/bristlecone/benchmark/tpcb/TPCBScenario.java", "rawCode": "  /**\n   * Execute a single TPC-B transaction. {@inheritDoc}\n   *\n   * @see com.continuent.bristlecone.benchmark.Scenario#iterate(long)\n   */\n  public void iterate(long iterationCount) throws Exception {\n    // If think time is enabled, wait for a [possibly random] interval.\n    if (thinkMillis > 0) {\n      int variance = (int) (thinkMillis * randomizationPct / 100.);\n      long thinkTime = thinkMillis + variance;\n      Thread.sleep(thinkTime);\n    }\n\n    // Execute a transaction or query.\n    executeOneTransaction();\n  }\n"}, {"dataset": "sleep", "exampleID": 9493, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 26, "tryExpressionEnd": 30, "tryBlockStart": 26, "tryBlockEnd": 458, "catchExpressionStart": 393, "catchExpressionEnd": 424, "catchBlockStart": 393, "catchBlockEnd": 458, "exceptionHandlingCallStart": [432], "exceptionHandlingCallEnd": [451], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 203, "focalAPIEnd": 247, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robworth/myibdportal/tree/master/patientview/src/main/java/com/worthsoln/patientview/uktransplant/UktParserThread.java", "rawCode": "  public void run() {\n    try {\n      while (true) {\n        File uktDir = new File(directory);\n        File[] uktFiles = uktDir.listFiles(new UktFileFilter());\n        updateUktFiles(uktFiles);\n        Thread.sleep(1000 * 60 * minutesBetweenWait);\n        Date now = new Date(System.currentTimeMillis());\n        System.out.println(\"UktParserThread \" + dateFormat.format(now));\n      }\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9494, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["datanodeReport(*)", "printDatanodeReport(DatanodeInfo[])"], "tryExpressionStart": 3277, "tryExpressionEnd": 3281, "tryBlockStart": 3277, "tryBlockEnd": 3372, "catchExpressionStart": 3918, "catchExpressionEnd": 3940, "catchBlockStart": 3918, "catchBlockEnd": 4055, "exceptionHandlingCallStart": [3955, 4008], "exceptionHandlingCallEnd": [4000, 4033], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 3291, "focalAPIEnd": 3322, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["FileSystem.close()", "MiniDFSCluster.shutdown()"], "finallyExpressionStart": 4056, "finallyExpressionEnd": 4064, "finallyBlockStart": 4056, "finallyBlockEnd": 4120, "cleanUpCallStart": [4072, 4095], "cleanUpCallEnd": [4087, 4113], "url": "https://github.com/johnugeorge/Hadoop-mdfs/tree/master/hadoop-1.2.1/src/test/org/apache/hadoop/hdfs/TestSetTimes.java", "rawCode": "  /** Tests mod & access time in DFS. */\n  public void testTimes() throws IOException {\n    Configuration conf = new Configuration();\n    final int MAX_IDLE_TIME = 2000; // 2s\n    conf.setInt(\"ipc.client.connection.maxidletime\", MAX_IDLE_TIME);\n    conf.setInt(\"heartbeat.recheck.interval\", 1000);\n    conf.setInt(\"dfs.heartbeat.interval\", 1);\n\n    MiniDFSCluster cluster = new MiniDFSCluster(conf, numDatanodes, true, null);\n    cluster.waitActive();\n    final int nnport = cluster.getNameNodePort();\n    InetSocketAddress addr = new InetSocketAddress(\"localhost\", cluster.getNameNodePort());\n    DFSClient client = new DFSClient(addr, conf);\n    DatanodeInfo[] info = client.datanodeReport(DatanodeReportType.LIVE);\n    assertEquals(\"Number of Datanodes \", numDatanodes, info.length);\n    FileSystem fileSys = cluster.getFileSystem();\n    int replicas = 1;\n    assertTrue(fileSys instanceof DistributedFileSystem);\n\n    try {\n      //\n      // create file and record atime/mtime\n      //\n      System.out.println(\"Creating testdir1 and testdir1/test1.dat.\");\n      Path dir1 = new Path(\"testdir1\");\n      Path file1 = new Path(dir1, \"test1.dat\");\n      FSDataOutputStream stm = writeFile(fileSys, file1, replicas);\n      FileStatus stat = fileSys.getFileStatus(file1);\n      long atimeBeforeClose = stat.getAccessTime();\n      String adate = dateForm.format(new Date(atimeBeforeClose));\n      System.out.println(\n          \"atime on \" + file1 + \" before close is \" + adate + \" (\" + atimeBeforeClose + \")\");\n      assertTrue(atimeBeforeClose != 0);\n      stm.close();\n\n      stat = fileSys.getFileStatus(file1);\n      long atime1 = stat.getAccessTime();\n      long mtime1 = stat.getModificationTime();\n      adate = dateForm.format(new Date(atime1));\n      String mdate = dateForm.format(new Date(mtime1));\n      System.out.println(\"atime on \" + file1 + \" is \" + adate + \" (\" + atime1 + \")\");\n      System.out.println(\"mtime on \" + file1 + \" is \" + mdate + \" (\" + mtime1 + \")\");\n      assertTrue(atime1 != 0);\n\n      //\n      // record dir times\n      //\n      stat = fileSys.getFileStatus(dir1);\n      long mdir1 = stat.getAccessTime();\n      assertTrue(mdir1 == 0);\n\n      // set the access time to be one day in the past\n      long atime2 = atime1 - (24L * 3600L * 1000L);\n      fileSys.setTimes(file1, -1, atime2);\n\n      // check new access time on file\n      stat = fileSys.getFileStatus(file1);\n      long atime3 = stat.getAccessTime();\n      String adate3 = dateForm.format(new Date(atime3));\n      System.out.println(\"new atime on \" + file1 + \" is \" + adate3 + \" (\" + atime3 + \")\");\n      assertTrue(atime2 == atime3);\n      assertTrue(mtime1 == stat.getModificationTime());\n\n      // set the modification time to be 1 hour in the past\n      long mtime2 = mtime1 - (3600L * 1000L);\n      fileSys.setTimes(file1, mtime2, -1);\n\n      // check new modification time on file\n      stat = fileSys.getFileStatus(file1);\n      long mtime3 = stat.getModificationTime();\n      String mdate3 = dateForm.format(new Date(mtime3));\n      System.out.println(\"new mtime on \" + file1 + \" is \" + mdate3 + \" (\" + mtime3 + \")\");\n      assertTrue(atime2 == stat.getAccessTime());\n      assertTrue(mtime2 == mtime3);\n\n      // shutdown cluster and restart\n      cluster.shutdown();\n      try {\n        Thread.sleep(2 * MAX_IDLE_TIME);\n      } catch (InterruptedException e) {\n      }\n      cluster = new MiniDFSCluster(nnport, conf, 1, false, true, null, null, null);\n      cluster.waitActive();\n      fileSys = cluster.getFileSystem();\n\n      // verify that access times and modification times persist after a\n      // cluster restart.\n      System.out.println(\"Verifying times after cluster restart\");\n      stat = fileSys.getFileStatus(file1);\n      assertTrue(atime2 == stat.getAccessTime());\n      assertTrue(mtime3 == stat.getModificationTime());\n\n      cleanupFile(fileSys, file1);\n      cleanupFile(fileSys, dir1);\n    } catch (IOException e) {\n      info = client.datanodeReport(DatanodeReportType.ALL);\n      printDatanodeReport(info);\n      throw e;\n    } finally {\n      fileSys.close();\n      cluster.shutdown();\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9495, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 894, "focalAPIEnd": 918, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["Session.exit()"], "finallyExpressionStart": 1694, "finallyExpressionEnd": 1702, "finallyBlockStart": 1694, "finallyBlockEnd": 1731, "cleanUpCallStart": [1710], "cleanUpCallEnd": [1724], "url": "https://github.com/jianwang2010/Test/tree/master/public/java/test/org/broadinstitute/sting/jna/drmaa/v1_0/JnaSessionIntegrationTest.java", "rawCode": "  @Test\n  public void testSubmitEcho() throws Exception {\n    File outFile = createNetworkTempFile(\"JnaSessionIntegrationTest-\", \".out\");\n    Session session = factory.getSession();\n    session.init(null);\n    try {\n      JobTemplate template = session.createJobTemplate();\n      template.setRemoteCommand(\"sh\");\n      template.setOutputPath(\":\" + outFile.getAbsolutePath());\n      template.setJoinFiles(true);\n      template.setArgs(Arrays.asList(\"-c\", \"echo \\\"Hello world.\\\"\"));\n\n      String jobId = session.runJob(template);\n      System.out.println(String.format(\"Job id %s\", jobId));\n      session.deleteJobTemplate(template);\n\n      System.out.println(\"Waiting for job to run: \" + jobId);\n      int remotePs = Session.QUEUED_ACTIVE;\n\n      List<Integer> runningStatuses = Arrays.asList(Session.QUEUED_ACTIVE, Session.RUNNING);\n\n      while (runningStatuses.contains(remotePs)) {\n        Thread.sleep(30 * 1000L);\n        remotePs = session.getJobProgramStatus(jobId);\n      }\n\n      Assert.assertEquals(remotePs, Session.DONE, \"Job status is not DONE.\");\n\n      JobInfo jobInfo = session.wait(jobId, Session.TIMEOUT_NO_WAIT);\n\n      Assert.assertTrue(jobInfo.hasExited(), String.format(\"Job did not exit cleanly: %s\", jobId));\n      Assert.assertEquals(\n          jobInfo.getExitStatus(), 0, String.format(\"Exit status for jobId %s is non-zero\", jobId));\n      if (jobInfo.hasSignaled())\n        Assert.fail(\n            String.format(\n                \"JobId %s exited with signal %s and core dump flag %s\",\n                jobId, jobInfo.getTerminatingSignal(), jobInfo.hasCoreDump()));\n      Assert.assertFalse(jobInfo.wasAborted(), String.format(\"Job was aborted: %s\", jobId));\n    } finally {\n      session.exit();\n    }\n\n    Assert.assertTrue(\n        FileUtils.waitFor(outFile, 120), \"File not found: \" + outFile.getAbsolutePath());\n    System.out.println(\"--- output ---\");\n    System.out.println(FileUtils.readFileToString(outFile));\n    System.out.println(\"--- output ---\");\n    Assert.assertTrue(outFile.delete(), \"Unable to delete \" + outFile.getAbsolutePath());\n    System.out.println(\"Validating that we reached the end of the test without exit.\");\n  }\n"}, {"dataset": "sleep", "exampleID": 9496, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 328, "focalAPIEnd": 347, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.sleep(long)", "thread.sleep(int)"], "useStart": [457, 1368], "useEnd": [476, 1386], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/clairebruce-qa/Smoketest/tree/master/src/lib/Claireandbruce.java", "rawCode": "  public static String deleteAlbum(Selenium selenium, String albumName) throws Exception {\n\n    Helper.log(\"execute deleteAlbum: \" + albumName);\n\n    String message;\n\n    // click albums link\n    selenium.click(\"//div[@id='main-subheader']/div[1]/div[1]/ul/li[3]/a/cufon/canvas\");\n\n    selenium.waitForPageToLoad(\"30000\");\n\n    Thread.sleep(small);\n\n    try {\n\n      // click the album name\n      selenium.click(\"//input[@name='\" + albumName + \"']\");\n      Thread.sleep(small);\n\n      // click delete link\n      selenium.click(\"//div[@id='main-wrapper']/div[2]/div/div[1]/div[1]/div[4]/div/div\");\n\n    } catch (SeleniumException e) {\n      message = albumName + \" non present in Albums list\";\n      Helper.log(albumName + \" non present in Albums list\");\n      // return message;\n\n      throw new ElementNotFoundException(message);\n    }\n\n    // wait for delete album confirmation window\n    Helper.waitForElement(\n        selenium, \"//div[@id='dialog-popup']\", \"delete album confirmation window not shown\");\n\n    // verify the message Are you sure you want to delete <albumName>? is present\n    Assert.assertTrue(selenium.isTextPresent(\"Are you sure you want to delete these?\"));\n\n    // click the delete album button\n    selenium.click(\"//div[@class='button-blue btn-delete right btndelete key-control']\");\n\n    // Wait 6 seconds until deletion pop-up dissapears\n    Thread.sleep(6000);\n\n    // wait \"delete windows\" not present\n    Helper.waitForElementNoPresent(\n        selenium, \"//input[@name='\" + albumName + \"']\", \"Delete album windows is still present\");\n\n    // verify album name is not anymore in the page\n    stc.verifyFalse(selenium.isElementPresent(\"//input[@name='\" + albumName + \"']\"));\n    message = \"deleteAlbumOk\";\n    Helper.log(message);\n\n    return message;\n  }\n"}, {"dataset": "sleep", "exampleID": 9497, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InterruptedException", "exceptionHandlingCall": ["Logger.info(String)"], "tryExpressionStart": 1001, "tryExpressionEnd": 1005, "tryBlockStart": 1001, "tryBlockEnd": 2455, "catchExpressionStart": 2336, "catchExpressionEnd": 2379, "catchBlockStart": 2336, "catchBlockEnd": 2455, "exceptionHandlingCallStart": [2389], "exceptionHandlingCallEnd": [2430], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 2054, "focalAPIEnd": 2076, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["thread.sleep(*)", "thread.sleep(*)"], "useStart": [2097, 2253], "useEnd": [2137, 2283], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/colombbus/tangara/tree/master/software/src/test/java/org/colombbus/tangara/net/UserActivitySimulator.java", "rawCode": "  @Override\n  public void run() {\n    try {\n      LOG.info(username + \" initialisation\");\n      connectID = userMgtCmd.register(conn, username);\n      LOG.info(username + \" user registered\");\n\n      DefaultNetMessageHandler handler = new DefaultNetMessageHandler(username);\n      DefaultNetMsgProcessor processor = new DefaultNetMsgProcessor();\n      processor.addMessageHandler(handler);\n      processor.setUnsupportedMessageHandler(handler);\n\n      LOG.info(username + \" pump created\");\n      TMessageExchangeManager mgr =\n          new TMessageExchangeManager(\n              conn, connectID, sendFreq, 10, \"0.10\", processor, new ConsoleMsgExchErrHandler());\n      // MessagePump pump = new MessagePump(conn, exchangeFreq, connectID, msgHandler, \"0.9\");\n      // pump.start();\n      LOG.info(username + \" pump activated\");\n\n      nbSentMsg = 0;\n      long maxTime = System.currentTimeMillis() + duration;\n      LOG.info(username + \" shall end at \" + DATE_FORMATTER.format(new Date(maxTime)));\n      try {\n        while (System.currentTimeMillis() < maxTime) {\n          List<UserInfo> users = userMgtCmd.getRegisteredUsers(conn);\n          if (users.size() > 1) {\n            // remove myself\n            UserInfo selUser = null;\n            for (UserInfo user : users) {\n              if (user.getUsername().equals(\"Simu0\")) {\n                selUser = user;\n                break;\n              }\n            }\n            // find a user\n            // int userId = rand.nextInt(users.size());\n            // System.out.println(userId+\" / \"+users.size());\n            // if (userId < 0 || userId >= users.size()) {\n            // System.err.println(\"bad userId value (userId=\"\n            // + userId + \", max=\" + users.size() + \")\");\n            // System.exit(-1);\n            // }\n            // UserInfo user = users.get(userId);\n            if (selUser != null) {\n              sendMessage(mgr, selUser);\n            }\n          } else {\n            LOG.debug(username + \" Not enough users connected. Wait a little bit\");\n          }\n\n          Thread.sleep(sendFreq);\n        }\n\n        Thread.sleep(\n            1000 * 60 * 2); // sleep during long time and check if we are still connected at the end\n\n        sendAliveMessage(mgr);\n\n        Thread.sleep(exchangeFreq * 3); // let time to take all remaining messages\n      } catch (InterruptedException interruptedEx) {\n        LOG.info(username + \" sleep interrupted\");\n        return;\n      }\n\n      mgr.shutdown();\n      LOG.info(username + \" Pump shutdown\");\n      userMgtCmd.unregister(conn, connectID);\n      LOG.info(username + \" user unregistered\");\n    } catch (Throwable th) {\n      LOG.info(username + \" error detected \" + th.getMessage());\n      lastError = th;\n    }\n  }\n"}, {"dataset": "sleep", "exampleID": 9498, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 1201, "focalAPIEnd": 1235, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/KNL-1011/kernel-impl/src/main/java/org/sakaiproject/tool/impl/SessionComponent.java", "rawCode": "    /** Run the maintenance thread. Every m_checkEvery seconds, check for expired sessions. */\n    public void run() {\n      // since we might be running while the component manager is still being created and populated,\n      // such as at server\n      // startup, wait here for a complete component manager\n      ComponentManager.waitTillConfigured();\n\n      while (!m_maintenanceCheckerStop) {\n        try {\n          for (Map.Entry<String, MutableLong> entry : expirationTimeSuggestionMap.entrySet()) {\n            if (entry.getValue().longValue() < System.currentTimeMillis()) {\n              MySession s = (MySession) m_sessions.get(entry.getKey());\n              if (M_log.isDebugEnabled()) M_log.debug(\"checking session \" + s.getId());\n              if (s.isInactive()) {\n                if (M_log.isDebugEnabled()) M_log.debug(\"invalidating session \" + s.getId());\n                synchronized (s) {\n                  s.invalidate();\n                }\n              }\n            }\n          }\n        } catch (Exception e) {\n          M_log.warn(\"run(): exception: \" + e);\n        }\n\n        // cycle every REFRESH seconds\n        if (!m_maintenanceCheckerStop) {\n          try {\n            Thread.sleep(m_checkEvery * 1000L);\n          } catch (Exception ignore) {\n          }\n        }\n      }\n    }\n"}, {"dataset": "sleep", "exampleID": 9499, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["getMessage()", "new TTransportException(*,*)"], "tryExpressionStart": 901, "tryExpressionEnd": 905, "tryBlockStart": 901, "tryBlockEnd": 1008, "catchExpressionStart": 1217, "catchExpressionEnd": 1241, "catchBlockStart": 1217, "catchBlockEnd": 1308, "exceptionHandlingCallStart": [1279, 1255], "exceptionHandlingCallEnd": [1295, 1301], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 921, "focalAPIEnd": 946, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rdio/thrift-public/tree/master/lib/java/src/org/apache/thrift/transport/TFileTransport.java", "rawCode": "  /**\n   * Read (potentially tailing) an input stream\n   *\n   * @param is InputStream to read from\n   * @param buf Buffer to read into\n   * @param off Offset in buffer to read into\n   * @param len Number of bytes to read\n   * @param tp policy to use if we hit EOF\n   * @return number of bytes read\n   */\n  private int tailRead(InputStream is, byte[] buf, int off, int len, tailPolicy tp)\n      throws TTransportException {\n    int orig_len = len;\n    try {\n      int retries = 0;\n      while (len > 0) {\n        int cnt = is.read(buf, off, len);\n        if (cnt > 0) {\n          off += cnt;\n          len -= cnt;\n          retries = 0;\n          cs.skip(cnt); // remember that we read so many bytes\n        } else if (cnt == -1) {\n          // EOF\n          retries++;\n\n          if ((tp.retries_ != -1) && tp.retries_ < retries) return (orig_len - len);\n\n          if (tp.timeout_ > 0) {\n            try {\n              Thread.sleep(tp.timeout_);\n            } catch (InterruptedException e) {\n            }\n          }\n        } else {\n          // either non-zero or -1 is what the contract says!\n          throw new TTransportException(\"Unexpected return from InputStream.read = \" + cnt);\n        }\n      }\n    } catch (IOException iox) {\n      throw new TTransportException(iox.getMessage(), iox);\n    }\n\n    return (orig_len - len);\n  }\n"}, {"dataset": "sleep", "exampleID": 9500, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = thread.sleep(miliseconds)", "focalAPIStart": 323, "focalAPIEnd": 346, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/teropa/stem/tree/master/org.eclipse.stem.ui.ge/src/org/eclipse/stem/ui/ge/kml/BBoxInfo.java", "rawCode": "  /**\n   * This thread will sit in a loop and every N seconds it will send a request to the\n   * SlideShowServlet to give it the latest BBox info that was sent from GoogleEarth\n   */\n  public void run() {\n\n    while (true) {\n      try {\n        Rectangle bbox = readBBox();\n        if (bbox != null) setBBox(bbox);\n        Thread.sleep(SLEEPTIME);\n      } catch (InterruptedException e) {\n\n      }\n    }\n  }\n"}]