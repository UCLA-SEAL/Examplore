[{"dataset": "parseInt", "exampleID": 2701, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(*)"], "tryExpressionStart": 221, "tryExpressionEnd": 225, "tryBlockStart": 221, "tryBlockEnd": 335, "catchExpressionStart": 279, "catchExpressionEnd": 299, "catchBlockStart": 279, "catchBlockEnd": 335, "exceptionHandlingCallStart": [307], "exceptionHandlingCallEnd": [328], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 248, "focalAPIEnd": 271, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.3.3/kernel-impl/src/main/java/org/sakaiproject/tool/impl/SessionComponent.java", "rawCode": "  /**\n   * Configuration: set how often to check for inactive sessions (seconds).\n   *\n   * @param value The how often to check for inactive sessions (seconds) value.\n   */\n  public void setCheckEvery(String value) {\n    try {\n      m_checkEvery = Integer.parseInt(value);\n    } catch (Exception t) {\n      System.out.println(t);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2702, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 361, "focalAPIEnd": 386, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Socket(*,val)"], "useStart": [476], "useEnd": [527], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nloreti/ProtoProxyHTTP/tree/master/IlMarseProxy/src/main/java/filterManager/FilterManager.java", "rawCode": "  public static void main(String[] args) throws IOException {\n\n    // args\n    if (args.length != 2) // Test for correct # of\n    throw new IllegalArgumentException(\"Parameter(s): <Server> [<Port>]\");\n\n    // Server name or IP address\n    String server = args[0];\n\n    // Convert argument String to bytes using the default character encoding\n    int servPort = Integer.parseInt(args[1]);\n\n    // Create socket that is connected to server on specified port\n    Socket socket = new Socket(InetAddress.getByName(server), servPort);\n    System.out.println(\"Connected to server...\");\n\n    // InputStream in = socket.getInputStream();\n    // OutputStream out = socket.getOutputStream();\n    BufferedReader fromServer = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n    PrintWriter toServer = new PrintWriter(socket.getOutputStream(), true);\n    String curLine = \"\"; // Line read from standard in\n    System.out.println(\"Enter a line of text (type 'quit' to exit): \");\n    InputStreamReader converter = new InputStreamReader(System.in);\n    BufferedReader termIn = new BufferedReader(converter);\n    while (!curLine.equals(\"EXIT\")) {\n      curLine = termIn.readLine();\n      toServer.println(curLine);\n      // // Send the encoded string to the server\n      // out.write(curLine.getBytes(\"UTF-16LE\"));\n      //\n      // // Receive the response from the server\n      // byte[] data = new byte[50];\n      // // Bytes received in last read\n      // System.out.println(\"readin\");\n      // if (in.read(data) == -1)\n      // throw new SocketException(\"Connection closed prematurely\");\n      System.out.print(fromServer.readLine().replace('\\64', '\\n'));\n      System.out.println();\n    }\n    // Close the socket and its streams\n    socket.close();\n  }\n"}, {"dataset": "parseInt", "exampleID": 2703, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["getStackTrace()", "d(String,String)"], "tryExpressionStart": 313, "tryExpressionEnd": 317, "tryBlockStart": 313, "tryBlockEnd": 1822, "catchExpressionStart": 1496, "catchExpressionEnd": 1528, "catchBlockStart": 1496, "catchBlockEnd": 1606, "exceptionHandlingCallStart": [1581, 1536], "exceptionHandlingCallEnd": [1598, 1599], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 1154, "focalAPIEnd": 1179, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setDeviceRemoteCmdPort(val)", "integer.parseInt(*)", "integer.parseInt(*)"], "useStart": [1124, 1222, 1290], "useEnd": [1180, 1247, 1315], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1664, "finallyExpressionEnd": 1672, "finallyBlockStart": 1664, "finallyBlockEnd": 1822, "cleanUpCallStart": [1722], "cleanUpCallEnd": [1732], "url": "https://github.com/dalvik/WebCam/tree/master/src/com/iped/ipcam/utils/FileUtil.java", "rawCode": "  public static List<Device> fetchDeviceFromFile(Context context) {\n    List<Device> deviceList = new ArrayList<Device>();\n    File file = new File(context.getFilesDir().getPath() + File.separator + Constants.DEVICELIST);\n    if (!file.exists()) {\n      return deviceList;\n    }\n    BufferedReader br = null;\n    try {\n      br = new BufferedReader(new FileReader(file));\n      String str = null;\n      while ((str = br.readLine()) != null) {\n        String[] info = str.split(\"&\");\n        int l = info.length;\n        /// System.out.println(\"device info str=\" + str + \" length=\" + l);\n        if (l < 8) {\n          continue;\n        }\n        Device device = new Device();\n        device.setDeviceName(info[0]);\n        device.setDeviceID(info[1]);\n        device.setUnDefine1(info[2]);\n        if (\"true\".equals(info[3])) {\n          device.setDeviceNetType(true);\n          device.setDeviceEthIp(info[4]);\n          device.setDeviceEthGateWay(info[5]);\n        } else {\n          device.setDeviceNetType(false);\n          device.setDeviceEthIp(info[4]);\n          device.setDeviceEthGateWay(info[5]);\n        }\n        device.setDeviceRemoteCmdPort(Integer.parseInt(info[6]));\n        device.setDeviceRemoteVideoPort(Integer.parseInt(info[7]));\n        device.setDeviceRemoteAudioPort(Integer.parseInt(info[8]));\n        device.setUnDefine2(info[9].equals(\"null\") ? null : info[9]);\n        if (!checkDeviceId(deviceList, device)) {\n          deviceList.add(device);\n        }\n      }\n    } catch (FileNotFoundException e) {\n      Log.d(TAG, \"FileUtil fetchDeviceFromFile \" + e.getStackTrace());\n    } catch (IOException e) {\n      e.printStackTrace();\n    } finally {\n      if (br != null) {\n        try {\n          br.close();\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n    }\n    return deviceList;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2704, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 479, "focalAPIEnd": 500, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(*,val)"], "useStart": [450], "useEnd": [501], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/libcore/sqlite/OldFunctionContextTest.java", "rawCode": "  public void testSet_resultInt() throws Exception {\n    TestFCInt testInt = new TestFCInt();\n    db.exec(\n        \"insert into \" + DatabaseCreator.SIMPLE_TABLE1 + \" values (1,'\" + testInt.intVal + \"',3)\",\n        null);\n    db.create_function(\"testInt\", 1, testInt);\n    TableResult res = db.get_table(\"select testInt(speed) from \" + DatabaseCreator.SIMPLE_TABLE1);\n    String row[] = (String[]) res.rows.elementAt(0);\n    String val = row[0];\n\n    assertEquals(testInt.intVal, Integer.parseInt(val));\n  }\n"}, {"dataset": "parseInt", "exampleID": 2705, "initialization": ["String s = substring(int,*)"], "initializationStart": [280], "initializationEnd": [310], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 320, "tryExpressionEnd": 324, "tryBlockStart": 320, "tryBlockEnd": 519, "catchExpressionStart": 441, "catchExpressionEnd": 475, "catchBlockStart": 441, "catchBlockEnd": 519, "exceptionHandlingCallStart": [487], "exceptionHandlingCallEnd": [508], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 347, "focalAPIEnd": 375, "followUpCheck": "val > this.val", "checkType": "IF", "followUpCheckExpressionStart": 387, "followUpCheckExpressionEnd": 408, "followUpCheckBlockStart": 387, "followUpCheckBlockEnd": 430, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/GamesCrafters/GamesmanJava/tree/master/GamesmanJava-oldHadoop/src/main/java/edu/berkeley/gamesman/parallel/tier/HadoopTierMapper.java", "rawCode": "  private void clearLastTier() {\n    String foldUri = conf.getProperty(\"gamesman.hadoop.dbfolder\");\n    File folder = new File(foldUri);\n    String[] fList = folder.list();\n    for (String f : fList) {\n      if (f.startsWith(\"s\") && f.contains(\"_\")) {\n        String tierString = f.substring(1, f.indexOf(\"_\"));\n        try {\n          int tier = Integer.parseInt(tierString);\n          if (tier > this.tier) new File(f).delete();\n        } catch (NumberFormatException nfe) {\n          nfe.printStackTrace();\n        }\n      }\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2706, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 248, "focalAPIEnd": 276, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Manufacturer(val,String)"], "useStart": [323], "useEnd": [355], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justin808/dof/tree/master/dof_junit/src/org/doframework/sample/persistence/jdbc_persistence/JdbcManufacturerPersistence.java", "rawCode": "  public Manufacturer getById(int id) {\n    String sql = \"select * from manufacturer where id = \" + id;\n    String[][] rows = JdbcDbUtil.executeMultiColumnQuery(sql);\n    if (rows.length == 0) {\n      return null;\n    } else {\n      int idFromDb = Integer.parseInt(rows[0][0]);\n      String name = rows[0][1];\n      return new Manufacturer(idFromDb, name);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2707, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 118, "focalAPIEnd": 143, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(*)", "new PngSplitter(File,val,int,String,int)"], "useStart": [163, 319], "useEnd": [188, 352], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7934/src/net/sourceforge/plantuml/png/PngSplitter.java", "rawCode": "  public static void main(String[] args) throws IOException {\n    final File f = new File(args[0]);\n    final int x = Integer.parseInt(args[1]);\n    final int y = Integer.parseInt(args[2]);\n    final File cp = new File(f.getParent(), f.getName().replaceAll(\"\\\\.png$\", \"_000.png\"));\n    FileUtils.copyToFile(f, cp);\n    new PngSplitter(cp, x, y, \"\", 96);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2708, "initialization": ["String s = getValue(String)"], "initializationStart": [65], "initializationEnd": [99], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s!=null&&s.matches(\"\\\\d+\",)", "guardType": "IF {", "guardExpressionStart": 105, "guardExpressionEnd": 148, "guardBlockStart": 105, "guardBlockEnd": 194, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 164, "focalAPIEnd": 187, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7941/src/net/sourceforge/plantuml/SkinParam.java", "rawCode": "  public int classAttributeIconSize() {\n    final String value = getValue(\"classAttributeIconSize\");\n    if (value != null && value.matches(\"\\\\d+\")) {\n      return Integer.parseInt(value);\n    }\n    return 10;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2709, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 58, "focalAPIEnd": 81, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/faberchri/tree-builder-2/tree/master/TreeBuilder/lib/rapidminer/src/com/rapidminer/parameter/value/ParameterValueGrid.java", "rawCode": "  @Override\n  public int getNumberOfValues() {\n    return Integer.parseInt(steps) + 1;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2710, "initialization": ["String s = SettingsFacade.getProperty(String)"], "initializationStart": [76], "initializationEnd": [106], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 139, "focalAPIEnd": 162, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/motech/motech-server-pillreminder/tree/master/modules/sms/api/src/main/java/org/motechproject/sms/api/service/SmsServiceImpl.java", "rawCode": "  private int getIntegerPropertyValue(String property) {\n    String value = settings.getProperty(property);\n    return value == null ? 0 : Integer.parseInt(value);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2711, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 567, "focalAPIEnd": 590, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/milanaleksic/baobab/tree/master/baobab-core/src/main/java/net/milanaleksic/baobab/converters/typed/IntegerConverter.java", "rawCode": "  public Integer getValueFromString(String input) {\n    checkNotNull(input);\n    String[] values = input.split(\"\\\\|\");\n    int ofTheJedi = 0;\n    for (String value : values) {\n      Matcher matcher = magicConstantsValue.matcher(value);\n      if (matcher.matches()) {\n        Integer matchedMagicConstantValue = magicConstants.get(matcher.group(1));\n        if (matchedMagicConstantValue == null)\n          throw new TransformerException(\"Magic constant does not exist - \" + matcher.group(1));\n        ofTheJedi |= matchedMagicConstantValue;\n      } else ofTheJedi |= Integer.parseInt(value);\n    }\n    return ofTheJedi;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2712, "initialization": ["String s = HttpServletRequest.getParameter(String)"], "initializationStart": [543], "initializationEnd": [583], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage(String,String,Locale)", "setAttribute(String,*)"], "tryExpressionStart": 1255, "tryExpressionEnd": 1259, "tryBlockStart": 1255, "tryBlockEnd": 1611, "catchExpressionStart": 1331, "catchExpressionEnd": 1351, "catchBlockStart": 1331, "catchBlockEnd": 1611, "exceptionHandlingCallStart": [1420, 1359], "exceptionHandlingCallEnd": [1581, 1582], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(UtilValidate.isEmpty(s,))", "guardType": "IF {", "guardExpressionStart": 949, "guardExpressionEnd": 995, "guardBlockStart": 949, "guardBlockEnd": 1219, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 1286, "focalAPIEnd": 1323, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["ShoppingCart.findCartItem(val)"], "useStart": [1645], "useEnd": [1680], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/QADM/SCG/tree/master/opentaps-1.5/applications/order/src/org/ofbiz/order/shoppingcart/ShoppingCartEvents.java", "rawCode": "  /** For GWP Promotions with multiple alternatives, selects an alternative to the current GWP */\n  public static String setDesiredAlternateGwpProductId(\n      HttpServletRequest request, HttpServletResponse response) {\n    ShoppingCart cart = getCartObject(request);\n    Delegator delegator = (Delegator) request.getAttribute(\"delegator\");\n    LocalDispatcher dispatcher = (LocalDispatcher) request.getAttribute(\"dispatcher\");\n    String alternateGwpProductId = request.getParameter(\"alternateGwpProductId\");\n    String alternateGwpLineStr = request.getParameter(\"alternateGwpLine\");\n    Locale locale = UtilHttp.getLocale(request);\n\n    if (UtilValidate.isEmpty(alternateGwpProductId)) {\n      request.setAttribute(\n          \"_ERROR_MESSAGE_\",\n          UtilProperties.getMessage(\n              resource_error,\n              \"OrderCouldNotSelectAlternateGiftNoAlternateGwpProductIdPassed\",\n              locale));\n      return \"error\";\n    }\n    if (UtilValidate.isEmpty(alternateGwpLineStr)) {\n      request.setAttribute(\n          \"_ERROR_MESSAGE_\",\n          UtilProperties.getMessage(\n              resource_error, \"OrderCouldNotSelectAlternateGiftNoAlternateGwpLinePassed\", locale));\n      return \"error\";\n    }\n\n    int alternateGwpLine = 0;\n    try {\n      alternateGwpLine = Integer.parseInt(alternateGwpLineStr);\n    } catch (Exception e) {\n      request.setAttribute(\n          \"_ERROR_MESSAGE_\",\n          UtilProperties.getMessage(\n              resource_error,\n              \"OrderCouldNotSelectAlternateGiftAlternateGwpLineIsNotAValidNumber\",\n              locale));\n      return \"error\";\n    }\n\n    ShoppingCartItem cartLine = cart.findCartItem(alternateGwpLine);\n    if (cartLine == null) {\n      request.setAttribute(\n          \"_ERROR_MESSAGE_\",\n          \"Could not select alternate gift, no cart line item found for #\"\n              + alternateGwpLine\n              + \".\");\n      return \"error\";\n    }\n\n    if (cartLine.getIsPromo()) {\n      // note that there should just be one promo adjustment, the reversal of the GWP, so use that\n      // to get the promo action key\n      Iterator checkOrderAdjustments = UtilMisc.toIterator(cartLine.getAdjustments());\n      while (checkOrderAdjustments != null && checkOrderAdjustments.hasNext()) {\n        GenericValue checkOrderAdjustment = (GenericValue) checkOrderAdjustments.next();\n        if (UtilValidate.isNotEmpty(checkOrderAdjustment.getString(\"productPromoId\"))\n            && UtilValidate.isNotEmpty(checkOrderAdjustment.getString(\"productPromoRuleId\"))\n            && UtilValidate.isNotEmpty(checkOrderAdjustment.getString(\"productPromoActionSeqId\"))) {\n          GenericPK productPromoActionPk =\n              delegator.makeValidValue(\"ProductPromoAction\", checkOrderAdjustment).getPrimaryKey();\n          cart.setDesiredAlternateGiftByAction(productPromoActionPk, alternateGwpProductId);\n          if (cart.getOrderType().equals(\"SALES_ORDER\")) {\n            org.ofbiz.order.shoppingcart.product.ProductPromoWorker.doPromotions(cart, dispatcher);\n          }\n          return \"success\";\n        }\n      }\n    }\n\n    request.setAttribute(\n        \"_ERROR_MESSAGE_\",\n        \"Could not select alternate gift, cart line item found for #\"\n            + alternateGwpLine\n            + \" does not appear to be a valid promotional gift.\");\n    return \"error\";\n  }\n"}, {"dataset": "parseInt", "exampleID": 2713, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 252, "focalAPIEnd": 274, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/titokone/kohahdus/tree/master/EAssari/WEB-INF/src/fi/helsinki/cs/kohahdus/criteria/VariableCriterion.java", "rawCode": "  /**\n   * Set the value the student's answer will be compared to when using constant test (the value will\n   * be ignore when using model answer).\n   */\n  @Override\n  public void setAcceptanceTestValue(String test) {\n    try {\n      comparisonValue = Integer.parseInt(test);\n    } catch (Exception e) { // NumberFormatException, NullPointerException\n      comparisonValue = UNDEFINED;\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2714, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 3042, "focalAPIEnd": 3073, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PUSH(ConstantPoolGen,val)"], "useStart": [3028], "useEnd": [3074], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/xena/ext/src/xalan-j_2_7_1/src/org/apache/xalan/xsltc/compiler/Output.java", "rawCode": "  /**\n   * Compile code that passes the information in this <xsl:output> element to the appropriate fields\n   * in the translet\n   */\n  public void translate(ClassGenerator classGen, MethodGenerator methodGen) {\n\n    // Do nothing if other <xsl:output> element has higher precedence\n    if (_disabled) return;\n\n    ConstantPoolGen cpg = classGen.getConstantPool();\n    InstructionList il = methodGen.getInstructionList();\n\n    int field = 0;\n    il.append(classGen.loadTranslet());\n\n    // Only update _version field if set and different from default\n    if ((_version != null) && (!_version.equals(XML_VERSION))) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_version\", STRING_SIG);\n      il.append(DUP);\n      il.append(new PUSH(cpg, _version));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Only update _method field if \"method\" attribute used\n    if (_method != null) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_method\", STRING_SIG);\n      il.append(DUP);\n      il.append(new PUSH(cpg, _method));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Only update if _encoding field is \"encoding\" attribute used\n    if (_encoding != null) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_encoding\", STRING_SIG);\n      il.append(DUP);\n      il.append(new PUSH(cpg, _encoding));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Only update if \"omit-xml-declaration\" used and set to 'yes'\n    if (_omitHeader) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_omitHeader\", \"Z\");\n      il.append(DUP);\n      il.append(new PUSH(cpg, _omitHeader));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Add 'standalone' decaration to output - use text as is\n    if (_standalone != null) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_standalone\", STRING_SIG);\n      il.append(DUP);\n      il.append(new PUSH(cpg, _standalone));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Set system/public doctype only if both are set\n    field = cpg.addFieldref(TRANSLET_CLASS, \"_doctypeSystem\", STRING_SIG);\n    il.append(DUP);\n    il.append(new PUSH(cpg, _doctypeSystem));\n    il.append(new PUTFIELD(field));\n    field = cpg.addFieldref(TRANSLET_CLASS, \"_doctypePublic\", STRING_SIG);\n    il.append(DUP);\n    il.append(new PUSH(cpg, _doctypePublic));\n    il.append(new PUTFIELD(field));\n\n    // Add 'medye-type' decaration to output - if used\n    if (_mediaType != null) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_mediaType\", STRING_SIG);\n      il.append(DUP);\n      il.append(new PUSH(cpg, _mediaType));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Compile code to set output indentation on/off\n    if (_indent) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_indent\", \"Z\");\n      il.append(DUP);\n      il.append(new PUSH(cpg, _indent));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Compile code to set indent amount.\n    if (_indentamount != null && !_indentamount.equals(EMPTYSTRING)) {\n      field = cpg.addFieldref(TRANSLET_CLASS, \"_indentamount\", \"I\");\n      il.append(DUP);\n      il.append(new PUSH(cpg, Integer.parseInt(_indentamount)));\n      il.append(new PUTFIELD(field));\n    }\n\n    // Forward to the translet any elements that should be output as CDATA\n    if (_cdata != null) {\n      int index = cpg.addMethodref(TRANSLET_CLASS, \"addCdataElement\", \"(Ljava/lang/String;)V\");\n\n      StringTokenizer tokens = new StringTokenizer(_cdata);\n      while (tokens.hasMoreTokens()) {\n        il.append(DUP);\n        il.append(new PUSH(cpg, tokens.nextToken()));\n        il.append(new INVOKEVIRTUAL(index));\n      }\n    }\n    il.append(POP); // Cleanup - pop last translet reference off stack\n  }\n"}, {"dataset": "parseInt", "exampleID": 2715, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 809, "focalAPIEnd": 842, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getInstance(String,val,Properties,*,String)"], "useStart": [743], "useEnd": [1020], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fyp09008/E-HospitalS/tree/master/lib/mysql-connector-java-5.1.12/src/com/mysql/jdbc/LoadBalancingConnectionProxy.java", "rawCode": "  /**\n   * Creates a new physical connection for the given host:port and updates required internal\n   * mappings and statistics for that connection.\n   *\n   * @param hostPortSpec\n   * @return\n   * @throws SQLException\n   */\n  public synchronized Connection createConnectionForHost(String hostPortSpec) throws SQLException {\n    Properties connProps = (Properties) this.localProps.clone();\n\n    String[] hostPortPair = NonRegisteringDriver.parseHostPortPair(hostPortSpec);\n\n    if (hostPortPair[1] == null) {\n      hostPortPair[1] = \"3306\";\n    }\n\n    connProps.setProperty(NonRegisteringDriver.HOST_PROPERTY_KEY, hostPortSpec);\n    connProps.setProperty(NonRegisteringDriver.PORT_PROPERTY_KEY, hostPortPair[1]);\n\n    Connection conn =\n        ConnectionImpl.getInstance(\n            hostPortSpec,\n            Integer.parseInt(hostPortPair[1]),\n            connProps,\n            connProps.getProperty(NonRegisteringDriver.DBNAME_PROPERTY_KEY),\n            \"jdbc:mysql://\" + hostPortPair[0] + \":\" + hostPortPair[1] + \"/\");\n\n    this.liveConnections.put(hostPortSpec, conn);\n    this.connectionsToHostsMap.put(conn, hostPortSpec);\n\n    return conn;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2716, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["Logger.severe(String)"], "tryExpressionStart": 65, "tryExpressionEnd": 69, "tryBlockStart": 65, "tryBlockEnd": 270, "catchExpressionStart": 122, "catchExpressionEnd": 154, "catchBlockStart": 122, "catchBlockEnd": 270, "exceptionHandlingCallStart": [164], "exceptionHandlingCallEnd": [239], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 89, "focalAPIEnd": 112, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/prsebastian/gwt-issue8215/tree/master/user/src/com/google/gwt/junit/remote/BrowserManagerServerLauncher.java", "rawCode": "    @Override\n    public boolean setString(String value) {\n      try {\n        portArg = Integer.parseInt(value);\n      } catch (NumberFormatException e) {\n        logger.severe(\"The -port argument must be an integer value. Got: \" + value);\n        return false;\n      }\n      return true;\n    }\n"}, {"dataset": "parseInt", "exampleID": 2717, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 218, "focalAPIEnd": 251, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getCipherSpec(val)"], "useStart": [283], "useEnd": [322], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/binwiederhier/syncany/tree/master/syncany-lib/src/main/java/org/syncany/chunk/CipherTransformer.java", "rawCode": "  private void initCipherSpecs(String cipherSpecListStr) throws Exception {\n    String[] cipherSpecIdStrs = cipherSpecListStr.split(\",\");\n\n    for (String cipherSpecIdStr : cipherSpecIdStrs) {\n      int cipherSpecId = Integer.parseInt(cipherSpecIdStr);\n      CipherSpec cipherSpec = CipherSpecs.getCipherSpec(cipherSpecId);\n\n      if (cipherSpec == null) {\n        throw new Exception(\"Cannot find cipher suite with ID '\" + cipherSpecId + \"'\");\n      }\n\n      cipherSpecs.add(cipherSpec);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2718, "initialization": ["String s = queryTable(String)"], "initializationStart": [1093], "initializationEnd": [1111], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 1123, "focalAPIEnd": 1144, "followUpCheck": "val > 0", "checkType": "IF", "followUpCheckExpressionStart": 1193, "followUpCheckExpressionEnd": 1205, "followUpCheckBlockStart": 1193, "followUpCheckBlockEnd": 2134, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/marytts/marytts/tree/master/marytts-builder/src/main/java/marytts/tools/dbselection/DBHandler.java", "rawCode": "  /**\n   * * Get a list of id's\n   *\n   * @param table cleanText, wordList, dbselection (no need to add locale) (NOTE: this function does\n   *     not work for the selectedSentences table, for this table use the function\n   *     getIdListOfSelectedSentences ).\n   * @param condition reliable, unknownWords, strangeSymbols, selected, unwanted = true/false\n   *     (combined are posible: \"reliable=true and unwanted=false\"); or condition=null for querying\n   *     without condition.\n   * @return int array or null if the list of id's is empty.\n   */\n  public int[] getIdListOfType(String table, String condition) {\n    int num, i, j;\n    int idSet[] = null;\n    int maxNum = 500000;\n    String getNum, getIds, getIdsShort;\n\n    if (condition != null) {\n      getNum = \"SELECT count(id) FROM \" + locale + \"_\" + table + \" where \" + condition + \";\";\n      getIds = \"SELECT id FROM \" + locale + \"_\" + table + \" where \" + condition;\n    } else {\n      getNum = \"SELECT count(id) FROM \" + locale + \"_\" + table + \";\";\n      getIds = \"SELECT id FROM \" + locale + \"_\" + table;\n    }\n\n    String str = queryTable(getNum);\n    num = Integer.parseInt(str);\n    // System.out.println(\"num = \" + num);\n    if (num > 0) {\n      idSet = new int[num];\n      i = 0;\n      if (num > maxNum) {\n        for (j = 0; j < num; j += maxNum) {\n          try {\n            getIdsShort = getIds + \" limit \" + j + \",\" + maxNum;\n            // System.out.println(\"getIdsShort=\" + getIdsShort);\n\n            rs = st.executeQuery(getIdsShort);\n            while (rs.next()) {\n              idSet[i] = rs.getInt(1);\n              i++;\n            }\n            System.out.println(\" Num of ids retrieved = \" + i);\n            rs.close();\n\n          } catch (SQLException e) {\n            e.printStackTrace();\n          }\n        }\n      } else { // if num < maxNum\n        try {\n          rs = st.executeQuery(getIds);\n          while (rs.next()) {\n            idSet[i] = rs.getInt(1);\n            i++;\n          }\n        } catch (SQLException e) {\n          e.printStackTrace();\n        }\n      }\n\n    } else System.out.println(\"WARNING empty list for: \" + getIds);\n    // System.out.println(\"idSet.length=\" + idSet.length);\n    return idSet;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2719, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "StringUtils.hasText(s,)", "guardType": "IF {", "guardExpressionStart": 52, "guardExpressionEnd": 86, "guardBlockStart": 52, "guardBlockEnd": 148, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 114, "focalAPIEnd": 140, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["updateItemsPerPage(val)"], "useStart": [95], "useEnd": [141], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/se-inbelly-com/se-master/tree/master/src/main/java/com/megalogika/sv/service/SearchCriteria.java", "rawCode": "  public void updatePageSize(String pageSize) {\n    if (StringUtils.hasText(pageSize)) {\n      updateItemsPerPage(Integer.parseInt(pageSize));\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2720, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 166, "focalAPIEnd": 189, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yukoff/concourse-connect/tree/master/src/main/java/com/concursive/connect/web/modules/issues/dao/TicketList.java", "rawCode": "  /**\n   * Sets the OrgId attribute of the TicketList object\n   *\n   * @param orgId The new OrgId value\n   */\n  public void setOrgId(String orgId) {\n    this.orgId = Integer.parseInt(orgId);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2721, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 45, "focalAPIEnd": 69, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NF28Group/Vmote/tree/master/src/fr/nf28/vmote/play/classes/Media.java", "rawCode": "  public int getVolume() {\n    return (int) (Integer.parseInt(volume) / (2.56 * 2));\n  }\n"}, {"dataset": "parseInt", "exampleID": 2722, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 212, "focalAPIEnd": 235, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.18/kernel-impl/src/main/java/org/sakaiproject/db/impl/BasicSqlService.java", "rawCode": "  /**\n   * Configuration: number of on-deadlock retries for save.\n   *\n   * @param value the number of on-deadlock retries for save.\n   */\n  public void setDeadlockRetries(String value) {\n    m_deadlockRetries = Integer.parseInt(value);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2723, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["print(*,String)"], "tryExpressionStart": 248, "tryExpressionEnd": 252, "tryBlockStart": 248, "tryBlockEnd": 501, "catchExpressionStart": 354, "catchExpressionEnd": 406, "catchBlockStart": 354, "catchBlockEnd": 501, "exceptionHandlingCallStart": [418], "exceptionHandlingCallEnd": [490], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 307, "focalAPIEnd": 342, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(String)"], "useStart": [984], "useEnd": [1006], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kitskub/bSpace/tree/master/src/main/java/me/iffa/bspace/wgen/planets/PlanetsChunkGenerator.java", "rawCode": "  private static Set<MaterialData> toSet(String[] matList) {\n    Set<MaterialData> matDatas = new HashSet<MaterialData>();\n    for (String mat : matList) {\n      int data = 0;\n      String name = \"\";\n      if (mat.split(\":\").length == 2) {\n        try {\n          name = mat.split(\":\")[0];\n          data = Integer.parseInt(mat.split(\":\")[1]);\n        } catch (NumberFormatException numberFormatException) {\n          MessageHandler.print(Level.WARNING, \"Invalid core block in planets.yml\");\n        }\n      } else {\n        name = mat;\n      }\n      Material newMat = Material.matchMaterial(name);\n\n      if (newMat != null) { // Vanilla material\n        if (newMat.isBlock()) {\n          matDatas.add(new MaterialData(newMat, (byte) data));\n        } else {\n          MessageHandler.print(Level.WARNING, newMat.toString() + \" is not a block\");\n        }\n      } else {\n        // UNSAFE! Does not check if id represents a block\n        try {\n          matDatas.add(new MaterialData(Integer.parseInt(name), (byte) data));\n        } catch (NumberFormatException numberFormatException) {\n          MessageHandler.print(Level.WARNING, \"Unrecognized id (\" + name + \") in planets.yml\");\n        }\n      }\n    }\n    return matDatas;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2724, "initialization": ["String s = getProperty(String)"], "initializationStart": [671], "initializationEnd": [698], "hasTryCatch": 1, "exceptionType": "UnknownHostException", "exceptionHandlingCall": ["toString()", "new ServerException(*,*,*)"], "tryExpressionStart": 906, "tryExpressionEnd": 910, "tryBlockStart": 906, "tryBlockEnd": 1183, "catchExpressionStart": 1065, "catchExpressionEnd": 1097, "catchBlockStart": 1065, "catchBlockEnd": 1183, "exceptionHandlingCallStart": [1158, 1111], "exceptionHandlingCallEnd": [1171, 1176], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s==null)", "guardType": "IF {", "guardExpressionStart": 807, "guardExpressionEnd": 824, "guardBlockStart": 807, "guardBlockEnd": 901, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 985, "focalAPIEnd": 1007, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new InetSocketAddress(InetAddress,val)"], "useStart": [1022], "useEnd": [1057], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop_src/hadoop-2.0.5-alpha-src/hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/lib/servlet/ServerWebApp.java", "rawCode": "  /**\n   * Resolves the host & port InetSocketAddress the web server is listening to.\n   *\n   * <p>This implementation looks for the following 2 properties:\n   *\n   * <ul>\n   *   <li>#SERVER_NAME#.http.hostname\n   *   <li>#SERVER_NAME#.http.port\n   * </ul>\n   *\n   * @return the host & port InetSocketAddress the web server is listening to.\n   * @throws ServerException thrown if any of the above 2 properties is not defined.\n   */\n  protected InetSocketAddress resolveAuthority() throws ServerException {\n    String hostnameKey = getName() + HTTP_HOSTNAME;\n    String portKey = getName() + HTTP_PORT;\n    String host = System.getProperty(hostnameKey);\n    String port = System.getProperty(portKey);\n    if (host == null) {\n      throw new ServerException(ServerException.ERROR.S13, hostnameKey);\n    }\n    if (port == null) {\n      throw new ServerException(ServerException.ERROR.S13, portKey);\n    }\n    try {\n      InetAddress add = InetAddress.getByName(host);\n      int portNum = Integer.parseInt(port);\n      return new InetSocketAddress(add, portNum);\n    } catch (UnknownHostException ex) {\n      throw new ServerException(ServerException.ERROR.S14, ex.toString(), ex);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2725, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)", "println(String)", "printStackTrace(*)"], "tryExpressionStart": 47, "tryExpressionEnd": 51, "tryBlockStart": 47, "tryBlockEnd": 1423, "catchExpressionStart": 1215, "catchExpressionEnd": 1243, "catchBlockStart": 1215, "catchBlockEnd": 1423, "exceptionHandlingCallStart": [1171, 1287, 1379], "exceptionHandlingCallEnd": [1199, 1371, 1416], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 193, "focalAPIEnd": 232, "followUpCheck": "index < val", "checkType": "LOOP", "followUpCheckExpressionStart": 518, "followUpCheckExpressionEnd": 569, "followUpCheckBlockStart": 518, "followUpCheckBlockEnd": 622, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jbosstm/narayana/tree/master/qa/tests/src/org/jboss/jbossts/qa/PerfProfile01Clients/Client_ImplicitObject_NoTran_NoTranNullOper.java", "rawCode": "  public static void main(String[] args) {\n    try {\n      ORBInterface.initORB(args, null);\n      OAInterface.initOA();\n\n      String prefix = args[args.length - 3];\n      int numberOfCalls = Integer.parseInt(args[args.length - 2]);\n      String implicitObjectIOR = ServerIORStore.loadIOR(args[args.length - 1]);\n\n      ImplicitObject implicitObject =\n          ImplicitObjectHelper.narrow(ORBInterface.orb().string_to_object(implicitObjectIOR));\n\n      boolean correct = true;\n\n      Date start = new Date();\n\n      for (int index = 0; index < numberOfCalls; index++) {\n        implicitObject.no_tran_nulloper();\n      }\n\n      Date end = new Date();\n\n      float operationDuration =\n          ((float) (end.getTime() - start.getTime())) / ((float) numberOfCalls);\n\n      System.err.println(\"Operation duration : \" + operationDuration + \"ms\");\n      System.err.println(\"Test duration : \" + (end.getTime() - start.getTime()) + \"ms\");\n\n      correct =\n          PerformanceProfileStore.checkPerformance(\n              prefix + \"_ImplicitObject_NoTran_NoTranNullOper\", operationDuration);\n\n      if (correct) {\n        System.out.println(\"Passed\");\n      } else {\n        System.out.println(\"Failed\");\n      }\n    } catch (Exception exception) {\n      System.out.println(\"Failed\");\n      System.err.println(\"Client_ImplicitObject_NoTran_NoTranNullOper.main: \" + exception);\n      exception.printStackTrace(System.err);\n    }\n\n    try {\n      OAInterface.shutdownOA();\n      ORBInterface.shutdownORB();\n    } catch (Exception exception) {\n      System.err.println(\"Client_ImplicitObject_NoTran_NoTranNullOper.main: \" + exception);\n      exception.printStackTrace(System.err);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2726, "initialization": ["String s = getHeader(String)"], "initializationStart": [559], "initializationEnd": [573], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s==null)", "guardType": "IF {", "guardExpressionStart": 579, "guardExpressionEnd": 595, "guardBlockStart": 579, "guardBlockEnd": 636, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 648, "focalAPIEnd": 669, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zeph/grinder/tree/master/source/src/HTTPClient/HTTPResponse.java", "rawCode": "  /**\n   * Retrieves the value for a given header. The value is parsed as an int.\n   *\n   * @param hdr the header name.\n   * @return the value for the header if the header exists\n   * @exception NumberFormatException if the header's value is not a number or if the header does\n   *     not exist.\n   * @exception IOException if any exception occurs on the socket.\n   * @exception ModuleException if any module encounters an exception.\n   */\n  public int getHeaderAsInt(String hdr) throws IOException, ModuleException, NumberFormatException {\n    String val = getHeader(hdr);\n    if (val == null) throw new NumberFormatException(\"null\");\n    return Integer.parseInt(val);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2727, "initialization": ["String s = Map<String, String>.get(String)"], "initializationStart": [992], "initializationEnd": [1028], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s!=null", "guardType": "IF {", "guardExpressionStart": 1034, "guardExpressionEnd": 1058, "guardBlockStart": 1034, "guardBlockEnd": 1779, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 1206, "focalAPIEnd": 1235, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setPositionIncrementGap(val)", "integer.parseInt(String)", "setPositionIncrementGap(val)"], "useStart": [1156, 1537, 1487], "useEnd": [1236, 1566, 1567], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thihy/lucene/tree/master/solr/core/src/java/org/apache/solr/schema/FieldType.java", "rawCode": "  protected void setArgs(IndexSchema schema, Map<String, String> args) {\n    // default to STORED, INDEXED, OMIT_TF_POSITIONS and MULTIVALUED depending on schema version\n    properties = (STORED | INDEXED);\n    float schemaVersion = schema.getVersion();\n    if (schemaVersion < 1.1f) properties |= MULTIVALUED;\n    if (schemaVersion > 1.1f) properties |= OMIT_TF_POSITIONS;\n    if (schemaVersion < 1.3) {\n      args.remove(\"compressThreshold\");\n    }\n\n    this.args = Collections.unmodifiableMap(args);\n    Map<String, String> initArgs = new HashMap<String, String>(args);\n    initArgs.remove(CLASS_NAME); // consume the class arg\n\n    trueProperties = FieldProperties.parseProperties(initArgs, true, false);\n    falseProperties = FieldProperties.parseProperties(initArgs, false, false);\n\n    properties &= ~falseProperties;\n    properties |= trueProperties;\n\n    for (String prop : FieldProperties.propertyNames) initArgs.remove(prop);\n\n    init(schema, initArgs);\n\n    String positionInc = initArgs.get(POSITION_INCREMENT_GAP);\n    if (positionInc != null) {\n      Analyzer analyzer = getAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer) analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\n            \"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      analyzer = getQueryAnalyzer();\n      if (analyzer instanceof SolrAnalyzer) {\n        ((SolrAnalyzer) analyzer).setPositionIncrementGap(Integer.parseInt(positionInc));\n      } else {\n        throw new RuntimeException(\n            \"Can't set \" + POSITION_INCREMENT_GAP + \" on custom analyzer \" + analyzer.getClass());\n      }\n      initArgs.remove(POSITION_INCREMENT_GAP);\n    }\n\n    this.postingsFormat = initArgs.remove(POSTINGS_FORMAT);\n    this.docValuesFormat = initArgs.remove(DOC_VALUES_FORMAT);\n\n    if (initArgs.size() > 0) {\n      throw new RuntimeException(\n          \"schema fieldtype \"\n              + typeName\n              + \"(\"\n              + this.getClass().getName()\n              + \")\"\n              + \" invalid arguments:\"\n              + initArgs);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2728, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 216, "focalAPIEnd": 236, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openfaces/OpenFaces/tree/master/openFaces/source/org/openfaces/component/table/AbstractTable.java", "rawCode": "  /**\n   * This method is only for internal usage from within the OpenFaces library. It shouldn't be used\n   * explicitly by any application code.\n   */\n  public int getRowIndexByClientSuffix(String id) {\n    return Integer.parseInt(id);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2729, "initialization": ["String s = getParameter(Vector,int)"], "initializationStart": [447], "initializationEnd": [468], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 605, "focalAPIEnd": 627, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["checkLastSyncAlertedSyncMode(String,val,*)"], "useStart": [712], "useEnd": [788], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/funambol-mirror/funambol-client-sdk/tree/master/us8528/client/src/main/java/com/funambol/client/test/basic/BasicCommandRunner.java", "rawCode": "  /**\n   * Check that the latest sync request was requested with a specific sync alert mode\n   *\n   * @param command the check sync alert command related String formatted representation\n   * @param args the command's related String arguments.\n   * @throws Throwable if an error occurred\n   */\n  private void checkLastSyncAlertedSyncMode(String command, Vector args) throws Throwable {\n\n    String source = getParameter(args, 0);\n    String mode = getParameter(args, 1);\n\n    checkArgument(source, \"Missing source in \" + command);\n    checkArgument(mode, \"Missing mode in \" + command);\n    int modeValue = Integer.parseInt(mode);\n\n    checkObject(syncMonitor, \"Run StartMainApp before command: \" + command);\n\n    getBasicRobot().checkLastSyncAlertedSyncMode(source, modeValue, syncMonitor);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2730, "initialization": ["String s = String.substring(int,int)"], "initializationStart": [1260], "initializationEnd": [1293], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(i<s.length()) && s.length()>0", "guardType": "IF {", "guardExpressionStart": 1304, "guardExpressionEnd": 1329, "guardBlockStart": 1304, "guardBlockEnd": 1746, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 1621, "focalAPIEnd": 1646, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setPort(val)"], "useStart": [1785], "useEnd": [1798], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/plugins/html/ext/src/xalan-j_2_7_1/src/org/apache/xml/utils/URI.java", "rawCode": "  /**\n   * Initialize the authority (userinfo, host and port) for this URI from a URI string spec.\n   *\n   * @param p_uriSpec the URI specification (cannot be null)\n   * @throws MalformedURIException if p_uriSpec violates syntax rules\n   */\n  private void initializeAuthority(String p_uriSpec) throws MalformedURIException {\n\n    int index = 0;\n    int start = 0;\n    int end = p_uriSpec.length();\n    char testChar = '\\0';\n    String userinfo = null;\n\n    // userinfo is everything up @\n    if (p_uriSpec.indexOf('@', start) != -1) {\n      while (index < end) {\n        testChar = p_uriSpec.charAt(index);\n\n        if (testChar == '@') {\n          break;\n        }\n\n        index++;\n      }\n\n      userinfo = p_uriSpec.substring(start, index);\n\n      index++;\n    }\n\n    // host is everything up to ':'\n    String host = null;\n\n    start = index;\n\n    while (index < end) {\n      testChar = p_uriSpec.charAt(index);\n\n      if (testChar == ':') {\n        break;\n      }\n\n      index++;\n    }\n\n    host = p_uriSpec.substring(start, index);\n\n    int port = -1;\n\n    if (host.length() > 0) {\n\n      // port\n      if (testChar == ':') {\n        index++;\n\n        start = index;\n\n        while (index < end) {\n          index++;\n        }\n\n        String portStr = p_uriSpec.substring(start, index);\n\n        if (portStr.length() > 0) {\n          for (int i = 0; i < portStr.length(); i++) {\n            if (!isDigit(portStr.charAt(i))) {\n              throw new MalformedURIException(\n                  portStr + \" is invalid. Port should only contain digits!\");\n            }\n          }\n\n          try {\n            port = Integer.parseInt(portStr);\n          } catch (NumberFormatException nfe) {\n\n            // can't happen\n          }\n        }\n      }\n    }\n\n    setHost(host);\n    setPort(port);\n    setUserinfo(userinfo);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2731, "initialization": ["String s = GET_CONSOLE_INPUT(*)", "String s = String.toLowerCase()"], "initializationStart": [3669, 3730], "initializationEnd": [3707, 3750], "hasTryCatch": 1, "exceptionType": "PersistenceException", "exceptionHandlingCall": ["getName()", "new InitializationException(String)"], "tryExpressionStart": 5203, "tryExpressionEnd": 5207, "tryBlockStart": 5203, "tryBlockEnd": 6366, "catchExpressionStart": 7072, "catchExpressionEnd": 7103, "catchBlockStart": 7072, "catchBlockEnd": 7273, "exceptionHandlingCallStart": [5891, 7145], "exceptionHandlingCallEnd": [5900, 7260], "configuration": ["s.toLowerCase()"], "configurationStart": [3730], "configurationEnd": [3750], "guardCondition": "s==null &&  !(s.equals(\"0\",))", "guardType": "LOOP {", "guardExpressionStart": 3623, "guardExpressionEnd": 3645, "guardBlockStart": 3623, "guardBlockEnd": 6392, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 5242, "focalAPIEnd": 5266, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/posttool/PSWebV1.0/tree/master/src/com/pagesociety/web/module/persistence/DefaultPersistenceEvolver.java", "rawCode": "  @Override\n  public void evolveIndexes(\n      WebStoreModule.schema_receiver resolver,\n      String entity_name,\n      List<EntityIndex> existing_indices,\n      List<EntityIndex> proposed_indices)\n      throws SyncException {\n    List<EntityIndex> delete_indices = new ArrayList<EntityIndex>();\n    List<EntityIndex> add_indices = new ArrayList<EntityIndex>();\n    try {\n      calc_added_and_deleted_indices(\n          entity_name, existing_indices, proposed_indices, delete_indices, add_indices);\n      if (delete_indices.size() == 0) {\n        for (int i = 0; i < add_indices.size(); i++) {\n          EntityIndex idx;\n          idx = add_indices.get(i);\n          try {\n            boolean go_on =\n                confirm(\n                    \"ADD INDEX \"\n                        + idx.getName()\n                        + \" DECLARED BY \"\n                        + resolver.getDeclaringModuleForIndex(entity_name, idx.getName())\n                        + \" TO \"\n                        + entity_name\n                        + \"?\");\n            if (go_on) do_define_entity_index(entity_name, idx);\n            else continue;\n            INFO(getName() + \": ADDING INDEX \" + idx.getName() + \" TO \" + entity_name);\n          } catch (PersistenceException p) {\n            ERROR(p);\n            throw new SyncException(\n                getName() + \": FAILED ADDING INDEX \" + idx + \" TO \" + entity_name);\n          }\n        }\n      } else if (add_indices.size() == 0) {\n        for (int i = 0; i < delete_indices.size(); i++) {\n          EntityIndex idx;\n          idx = delete_indices.get(i);\n          try {\n            boolean go_on =\n                confirm(\n                    \"DELETE INDEX \"\n                        + idx.getName()\n                        + \" IN \"\n                        + resolver.getDeclaringModuleForEntity(entity_name)\n                        + \".\"\n                        + entity_name\n                        + \"?\");\n            if (go_on) store.deleteEntityIndex(entity_name, idx.getName());\n            else continue;\n            INFO(getName() + \": DELETING INDEX \" + idx.getName() + \" FROM \" + entity_name);\n          } catch (PersistenceException p) {\n            ERROR(p);\n            throw new SyncException(\n                getName() + \": FAILED DELETING INDEX \" + idx + \" TO \" + entity_name);\n          }\n        }\n      } else {\n\n        INFO(\n            \" WAS UNABLE TO AUTOMATICALLY RESOLVE THE EVOLUTION\\n OF THE \"\n                + entity_name\n                + \" ENTITY IN \"\n                + resolver.getDeclaringModuleForEntity(entity_name)\n                + \" PLEASE ASSIST.\");\n        for (int i = 0; i < add_indices.size(); i++) {\n\n          EntityIndex idx;\n          idx = add_indices.get(i);\n          StringBuilder question =\n              new StringBuilder(\n                  \"Do you mean to:\\n\\t[0] Add index \"\n                      + idx.getName()\n                      + \" to \"\n                      + resolver.getDeclaringModuleForEntity(entity_name)\n                      + \".\"\n                      + entity_name);\n          for (int j = 0; j < delete_indices.size(); j++) {\n            question.append(\n                \"\\n\\t[\"\n                    + (j + 1)\n                    + \"] Rename \"\n                    + delete_indices.get(j).getName()\n                    + \" to \"\n                    + idx.getName()\n                    + \" in \"\n                    + resolver.getDeclaringModuleForEntity(entity_name)\n                    + \".\"\n                    + entity_name);\n          }\n          question.append(\"?\\n\");\n          String answer = null;\n          while (answer == null) {\n            answer = GET_CONSOLE_INPUT(question.toString());\n            answer = answer.toLowerCase();\n            if (answer.equals(\"0\")) {\n              try {\n                boolean go_on =\n                    confirm(\n                        \"ADD INDEX \"\n                            + idx.getName()\n                            + \" DECLARED BY \"\n                            + resolver.getDeclaringModuleForIndex(entity_name, idx.getName())\n                            + \" TO \"\n                            + resolver.getDeclaringModuleForEntity(entity_name)\n                            + \".\"\n                            + entity_name\n                            + \"? \");\n                if (go_on) do_define_entity_index(entity_name, idx);\n                else continue;\n                INFO(\n                    getName()\n                        + \": ADDED INDEX \"\n                        + idx.getName()\n                        + \" TO \"\n                        + resolver.getDeclaringModuleForEntity(entity_name)\n                        + \".\"\n                        + entity_name);\n              } catch (PersistenceException p) {\n                ERROR(p);\n                throw new InitializationException(\n                    getName()\n                        + \": FAILED ADDING INDEX \"\n                        + idx\n                        + \" TO \"\n                        + resolver.getDeclaringModuleForEntity(entity_name)\n                        + \".\"\n                        + entity_name);\n              }\n            } else {\n              try {\n                int delete_idx = Integer.parseInt(answer) - 1;\n                EntityIndex renamed_index = delete_indices.get(delete_idx);\n                if (delete_idx > delete_indices.size() - 1) answer = null;\n                else {\n                  // rename field...update delete list.\n                  boolean go_on =\n                      confirm(\"RENAME INDEX \" + renamed_index + \" TO \" + idx.getName() + \"? \");\n                  if (go_on)\n                    store.renameEntityIndex(entity_name, renamed_index.getName(), idx.getName());\n                  else continue;\n                  delete_indices.remove(delete_idx);\n                  INFO(\n                      getName()\n                          + \": RENAMED INDEX \"\n                          + renamed_index.getName()\n                          + \" TO \"\n                          + idx.getName()\n                          + \" IN \"\n                          + resolver.getDeclaringModuleForEntity(entity_name)\n                          + \".\"\n                          + entity_name);\n                }\n              } catch (Exception e) {\n                answer = null;\n              }\n            }\n          }\n        }\n        for (int i = 0; i < delete_indices.size(); i++) {\n          EntityIndex idx = delete_indices.get(i);\n          try {\n            boolean go_on =\n                confirm(\n                    \"DELETE INDEX \"\n                        + idx.getName()\n                        + \" IN \"\n                        + resolver.getDeclaringModuleForEntity(entity_name)\n                        + \".\"\n                        + entity_name\n                        + \"?\");\n            if (go_on) store.deleteEntityIndex(entity_name, idx.getName());\n            else continue;\n            INFO(getName() + \": DELETED INDEX \" + idx.getName() + \" FROM \" + entity_name);\n          } catch (PersistenceException p) {\n            ERROR(p);\n            throw new InitializationException(\n                getName() + \": FAILED DELETING INDEX \" + idx + \" FROM \" + entity_name);\n          }\n        }\n      }\n\n    } catch (SyncException se) {\n      throw se;\n    } catch (Exception e) {\n      System.out.println(\"@@@@@@@@@@@@BAH!!!\");\n      e.printStackTrace();\n      ERROR(e);\n      throw new SyncException(\"FAILED EVOLVING ENTITY INDEXES FOR \" + entity_name);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2732, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(NULL_VALUE.equals(s.toLowerCase(),))", "guardType": "IF {", "guardExpressionStart": 112, "guardExpressionEnd": 155, "guardBlockStart": 112, "guardBlockEnd": 401, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 545, "focalAPIEnd": 568, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Integer(val)"], "useStart": [533], "useEnd": [569], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ludovicc/testng-debian/tree/master/src/main/org/testng/internal/Parameters.java", "rawCode": "  public static Object convertType(Class type, String value, String paramName) {\n    Object result = null;\n\n    if (NULL_VALUE.equals(value.toLowerCase())) {\n      if (type.isPrimitive()) {\n        Utils.log(\n            \"Parameters\",\n            2,\n            \"Attempt to pass null value to primitive type parameter '\" + paramName + \"'\");\n      }\n\n      return null; // null value must be used\n    }\n\n    if (type == String.class) {\n      result = value;\n    } else if (type == int.class || type == Integer.class) {\n      result = new Integer(Integer.parseInt(value));\n    } else if (type == boolean.class || type == Boolean.class) {\n      result = Boolean.valueOf(value);\n    } else if (type == byte.class || type == Byte.class) {\n      result = new Byte(Byte.parseByte(value));\n    } else if (type == char.class || type == Character.class) {\n      result = new Character(value.charAt(0));\n    } else if (type == double.class || type == Double.class) {\n      result = new Double(Double.parseDouble(value));\n    } else if (type == float.class || type == Float.class) {\n      result = new Float(Float.parseFloat(value));\n    } else if (type == long.class || type == Long.class) {\n      result = new Long(Long.parseLong(value));\n    } else if (type == short.class || type == Short.class) {\n      result = new Short(Short.parseShort(value));\n    } else {\n      assert false : \"Unsupported type parameter : \" + type;\n    }\n\n    return result;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2733, "initialization": ["String s = substring(*)"], "initializationStart": [339], "initializationEnd": [370], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 386, "focalAPIEnd": 411, "followUpCheck": "val >= 0", "checkType": "IF", "followUpCheckExpressionStart": 467, "followUpCheckExpressionEnd": 478, "followUpCheckBlockStart": 467, "followUpCheckBlockEnd": 858, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/visda/tree/master/visda/VISDA-Developer/Month-5-yr1/visdaDev-V0.1/src/edu/vt/cbil/visda/view/Plot.java", "rawCode": "  protected static String offsetString(double offset) {\n    String stroffset = String.valueOf(offset);\n    String substr1 = \"\", substr2 = \"\", substr3 = \"\";\n    String zero = \"0\";\n    int posdot = stroffset.indexOf('.');\n    int posexp = stroffset.indexOf('E');\n\n    if (posexp == -1) {\n      return stroffset;\n    } else {\n      substr1 = stroffset.substring(posexp + 1);\n      int n = Integer.parseInt(substr1);\n      substr1 = stroffset.substring(0, posexp);\n      if (n >= 0) {\n        for (int i = 0; i < n; i++) {\n          substr1 = substr1 + zero;\n        }\n        return substr1;\n      } else {\n        substr2 = substr1.substring(0, posdot + 1);\n        substr3 = substr1.substring(posdot + 1);\n        for (int i = 0; i < -n; i++) {\n          substr2 = substr1 + zero;\n        }\n        substr2 = substr2 + substr3;\n        return substr2;\n      }\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2734, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 569, "focalAPIEnd": 591, "followUpCheck": "pager.getModel().getRowCount() >= val", "checkType": "IF", "followUpCheckExpressionStart": 603, "followUpCheckExpressionEnd": 650, "followUpCheckBlockStart": 603, "followUpCheckBlockEnd": 752, "use": ["valueOf(val)", "getPageSizeLink(Pager,val,*)"], "useStart": [713, 680], "useEnd": [737, 738], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MiniSEC/adito_reload/tree/master/adito/branches/nonembedded/webapp/src/main/java/com/adito/table/tags/PageSizeTag.java", "rawCode": "  public int doEndTag() throws JspException {\n    StringBuilder results = new StringBuilder();\n    Pager pager =\n        (Pager) TagUtils.getInstance().lookup(pageContext, pagerName, pagerProperty, null);\n    if (pager != null && pager.getModel().getRowCount() >= Integer.parseInt(PAGE_SIZES[0])) {\n\n      // Start of table\n      results.append(\"<ul>\");\n      for (String page : PAGE_SIZES) {\n        if (page.equals(\"*\")) {\n          if (allowShowAll) {\n            results.append(getPageSizeLink(pager, 0, \"*\"));\n          }\n        } else {\n          int pageSize = Integer.parseInt(page);\n          if (pager.getModel().getRowCount() >= pageSize) {\n            results.append(getPageSizeLink(pager, pageSize, String.valueOf(pageSize)));\n          }\n        }\n      }\n      results.append(\"</ul>\");\n    } else {\n      results.append(\"&nbsp;\");\n    }\n\n    TagUtils.getInstance().write(pageContext, results.toString());\n    return (EVAL_PAGE);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2735, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": [], "tryExpressionStart": 676, "tryExpressionEnd": 680, "tryBlockStart": 676, "tryBlockEnd": 1004, "catchExpressionStart": 934, "catchExpressionEnd": 966, "catchBlockStart": 934, "catchBlockEnd": 1004, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s.equals(\"\",)||s.equals(\"0\",)) && s!=null", "guardType": "IF {", "guardExpressionStart": 502, "guardExpressionEnd": 524, "guardBlockStart": 502, "guardBlockEnd": 1010, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 716, "focalAPIEnd": 743, "followUpCheck": "val < 0", "checkType": "IF", "followUpCheckExpressionStart": 818, "followUpCheckExpressionEnd": 846, "followUpCheckBlockStart": 818, "followUpCheckBlockEnd": 889, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jenkinsci/jacoco-plugin/tree/master/src/main/java/hudson/plugins/jacoco/portlet/utils/Utils.java", "rawCode": "  /**\n   * Validate chart attributes returning a valid value to the object.\n   *\n   * @param attribute the attribute: width, height, number of days\n   * @param defaultValue default value for the attribute\n   * @return int attribute valid value\n   */\n  public static int validateChartAttributes(String attribute, int defaultValue) {\n\n    // If user fills the attributes with negative, empty or not number\n    // values, Hudson will not show an invalid message, it will assume\n    // default values\n\n    if (attribute != null) {\n      if (attribute.equals(\"\") || attribute.equals(\"0\")) {\n        return defaultValue;\n      }\n\n      // Check if attribute value is a number\n      try {\n        int validAttributeValue = Integer.parseInt(attribute);\n        // Attribute value is a number - check if it is negative\n        if (validAttributeValue < 0) {\n          return defaultValue;\n        }\n        return validAttributeValue;\n      } catch (NumberFormatException e) {\n        return defaultValue;\n      }\n    }\n\n    return defaultValue;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2736, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 863, "focalAPIEnd": 888, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(*)", "new Interval(val,Integer)"], "useStart": [918, 979], "useEnd": [943, 1003], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ARUP-NGS/Pipeline/tree/master/src/main/java/buffer/BEDFile.java", "rawCode": "  /**\n   * Construct/initialize a map which allows us to easily look up which sites are in the intervals\n   * described by this BED file. If arg is true, strip chr from all contig labels\n   *\n   * @throws IOException\n   */\n  public void buildIntervalsMap(boolean stripChr) throws IOException {\n    BufferedReader reader = new BufferedReader(new FileReader(getAbsolutePath()));\n    String line = reader.readLine();\n    intervals = new HashMap<String, List<Interval>>();\n    while (line != null) {\n      if (line.startsWith(\"#\")) {\n        line = reader.readLine();\n        continue;\n      }\n      if (line.length() > 0) {\n        String[] toks = line.split(\"\\\\s\");\n        String contig = toks[0];\n        if (stripChr) contig = contig.replace(\"chr\", \"\");\n        toks[1] = toks[1].trim();\n        toks[2] = toks[2].trim();\n        try {\n          Integer begin = Integer.parseInt(toks[1]) + 1;\n          Integer end = Integer.parseInt(toks[2]) + 1;\n          Interval interval = new Interval(begin, end);\n\n          List<Interval> contigIntervals = intervals.get(contig);\n          if (contigIntervals == null) {\n            contigIntervals = new ArrayList<Interval>(1024);\n            intervals.put(contig, contigIntervals);\n            // System.out.println(\"BED file adding contig: \" + contig);\n          }\n          contigIntervals.add(interval);\n        } catch (Exception ex) {\n          Logger.getLogger(Pipeline.primaryLoggerName)\n              .warning(\"Skipping invalid line in bed file: \" + line);\n        }\n      }\n      line = reader.readLine();\n    }\n\n    reader.close();\n    sortAllContigs();\n  }\n"}, {"dataset": "parseInt", "exampleID": 2737, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 222, "focalAPIEnd": 248, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(*)", "integer.parseInt(*)"], "useStart": [272, 321], "useEnd": [298, 347], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Data2Semantics/d2s-tools/tree/master/RDFmodel/src/main/java/org/data2semantics/RDFmodel/RDFGraph.java", "rawCode": "      @Override\n      public List<Integer> next() {\n        String line = _line;\n        cache_line();\n        String[] parts = line.split(\"\\\\s+\");\n        assert parts.length == 3 : \"Not a triple!\";\n        int subj_id = Integer.parseInt(parts[0]);\n        int pred_id = Integer.parseInt(parts[1]);\n        int obj_id = Integer.parseInt(parts[2]);\n        return Arrays.asList(subj_id, pred_id, obj_id);\n      }\n"}, {"dataset": "parseInt", "exampleID": 2738, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 2254, "focalAPIEnd": 2281, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setXPosition(val)", "integer.parseInt(*)", "integer.parseInt(*)"], "useStart": [2231, 2321, 2573], "useEnd": [2282, 2348, 2600], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jak786/VASE/tree/master/editor/server/src/de/hpi/xforms/rdf/XFormsRDFImporter.java", "rawCode": "  private void handleAttributes(Node node, XFormsElement element, String prefix, ImportContext c) {\n    if (node.hasChildNodes()) {\n      Node n = node.getFirstChild();\n      while ((n = n.getNextSibling()) != null) {\n        if (n instanceof Text) continue;\n\n        String content = null;\n        if (getContent(n) != null) content = StringEscapeUtils.unescapeXml(getContent(n));\n\n        String attribute = n.getNodeName().substring(n.getNodeName().indexOf(':') + 1);\n\n        if (attribute.startsWith(\"xf_\")) {\n          // handle attributes of xforms namespace\n\n          attribute = attribute.substring(3);\n\n          if ((prefix != null) && (attribute.startsWith(prefix)))\n            attribute = attribute.substring(prefix.length());\n\n          if (element.getAttributes().containsKey(attribute)) {\n            element.getAttributes().put(attribute, content);\n          } else {\n            if (element instanceof Submit) {\n              handleSubmissionProperty(attribute, content, (Submit) element, c);\n            } else if ((element instanceof XForm) && attribute.equals(\"head\")) {\n              if (content != null) addHead(content, c);\n            } else if ((element instanceof XForm) && attribute.equals(\"nsdeclarations\")) {\n              if (content != null) addNSDeclarations(content, c);\n            } else {\n              handleModelItemProperty(attribute, content, element, c);\n            }\n          }\n        } else if (attribute.startsWith(\"ev_\")) {\n          // handle attributes of xml events namespace\n          attribute = \"ev:\" + attribute.substring(3);\n          if (element.getAttributes().containsKey(attribute)) {\n            element.getAttributes().put(attribute, content);\n          } else {\n            if (element instanceof Submit)\n              handleSubmissionProperty(attribute, content, (Submit) element, c);\n            else handleModelItemProperty(attribute, content, element, c);\n          }\n        } else {\n          // handle oryx attributes\n\n          if (attribute.equals(\"bounds\")) {\n            if (element instanceof XFormsUIElement) {\n              XFormsUIElement uiElement = (XFormsUIElement) element;\n              String[] bounds = getContent(n).split(\",\");\n              uiElement.setXPosition(Integer.parseInt(bounds[0]));\n              uiElement.setYPosition(Integer.parseInt(bounds[1]));\n            } else if (element instanceof ListUICommon) {\n              ListUICommon listUICommon = (ListUICommon) element;\n              String[] bounds = getContent(n).split(\",\");\n              listUICommon.setYPosition(Integer.parseInt(bounds[1]));\n            }\n          }\n          if (attribute.equals(\"parent\")) {\n            c.parentRelationships.put(element, getResourceId(getAttributeValue(n, \"rdf:resource\")));\n          }\n          if (attribute.equals(\"nodeset\") && prefix == null) {\n            try {\n              String path = generateCodeTable(c, content, element);\n              element.getAttributes().put(attribute, path);\n            } catch (JSONException e) {\n              element.getAttributes().put(attribute, content);\n            }\n          }\n        }\n      }\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2739, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 197, "focalAPIEnd": 256, "followUpCheck": "pageSize + (pageSize + val - 1) < maxSize", "checkType": "IF", "followUpCheckExpressionStart": 861, "followUpCheckExpressionEnd": 910, "followUpCheckBlockStart": 861, "followUpCheckBlockEnd": 1010, "use": ["integer.parseInt(*)", "integer.parseInt(*)"], "useStart": [277, 360], "useEnd": [340, 421], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thelabtech/staffsite-java/tree/master/common-src/source/org/alt60m/html/Formatter.java", "rawCode": "  public String displaySmallPager(\n      String offsetString, String pageSizeString, String maxSizeString, String name, String self) {\n    StringBuffer pager = new StringBuffer();\n    int offset = Integer.parseInt(offsetString != null ? offsetString : \"1\");\n    int pageSize = Integer.parseInt(pageSizeString != null ? pageSizeString : \"1\");\n    int maxSize = Integer.parseInt(maxSizeString != null ? maxSizeString : \"1\");\n    int nextOffset, lastOffset, lastPageEnd, nextSize, lastSize;\n\n    offset = (offset <= maxSize) ? offset : maxSize;\n    offset = (offset >= 1) ? offset : 1;\n\n    // The start/end page of the next views\n    nextOffset = pageSize + offset;\n\n    lastOffset = ((offset - pageSize) > 0) ? (offset - pageSize) : 1;\n    lastPageEnd = ((offset - 1) > pageSize) ? (offset - 1) : offset - 1;\n\n    // How many we'll display in the next view\n\n    if (pageSize + (pageSize + offset - 1) < maxSize) {\n      nextSize = pageSize;\n    } else {\n      nextSize = maxSize - (pageSize + offset - 1);\n    }\n\n    if (lastPageEnd > pageSize) {\n      lastSize = pageSize;\n    } else {\n      lastSize = lastPageEnd;\n    }\n\n    pager.append(\"<A NAME='pager_\" + name + \"'>\");\n    pager.append(\"<TABLE BORDER='0' CELLSPACING='0' WIDTH='100%'>\");\n    pager.append(\"<TR>\");\n    pager.append(\"<TD \");\n    pager.append(\"CLASS='button' \");\n    pager.append(\"WIDTH='50%' \");\n    pager.append(\"ALIGN='LEFT' \");\n    pager.append(\">\");\n    if (offset > 1) {\n      pager.append(\"<A HREF='\" + self + \"&offset=\" + lastOffset + \"&size=\" + pageSize + \"' \");\n      pager.append(\"CLASS='button' \");\n      pager.append(\">\");\n      pager.append(\"&lt;&lt; Last \" + lastSize + \" \" + name);\n      pager.append(\"</A>\");\n    } else pager.append(\"&nbsp;\");\n    pager.append(\"</TD>\");\n    pager.append(\"<TD \");\n    pager.append(\"CLASS='button' \");\n    pager.append(\"WIDTH='50%' \");\n    pager.append(\"ALIGN='RIGHT' \");\n    pager.append(\">\");\n    if (offset + pageSize <= maxSize) {\n      pager.append(\"<A HREF='\" + self + \"&offset=\" + nextOffset + \"&size=\" + pageSize + \"' \");\n      pager.append(\"CLASS='button' \");\n      pager.append(\">\");\n      pager.append(\"Next \" + nextSize + \" \" + name + \" &gt;&gt;\");\n      pager.append(\"</A>\");\n    } else pager.append(\"&nbsp;\");\n    pager.append(\"</TD>\");\n    pager.append(\"</TR>\");\n    pager.append(\"</TABLE>\");\n    return pager.toString();\n  }\n"}, {"dataset": "parseInt", "exampleID": 2740, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 366, "focalAPIEnd": 389, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ARUP-NGS/Pipeline/tree/master/src/main/java/util/VCFLineParser.java", "rawCode": "  /**\n   * Depth may appear in format OR INFO fields, this searches the latter for depth\n   *\n   * @return\n   */\n  public Integer getDepthFromInfo() {\n    updateFormatIfNeeded();\n\n    if (formatToks == null) return 1;\n\n    if (dpCol < 0) return null;\n\n    String[] formatValues = lineToks[sampleColumn].split(\":\");\n    String dpStr = formatValues[dpCol];\n    return Integer.parseInt(dpStr);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2741, "initialization": ["String s = getenv(String)"], "initializationStart": [83], "initializationEnd": [107], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s!=null", "guardType": "IF {", "guardExpressionStart": 113, "guardExpressionEnd": 133, "guardBlockStart": 113, "guardBlockEnd": 245, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 163, "focalAPIEnd": 188, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lenik/jazz/tree/master/bas/layer-3/bas-log/src/main/java/net/bodz/bas/log/AbstractStatusSink.java", "rawCode": "  protected int getScreenColumns() {\n    // System.console();\n    String columns = System.getenv(\"COLUMNS\");\n    if (columns != null) {\n      try {\n        return Integer.parseInt(columns);\n      } catch (NumberFormatException e) {\n      }\n    }\n    return DEFAULT_COLUMNS;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2742, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(isEmpty(s,))", "guardType": "IF {", "guardExpressionStart": 115, "guardExpressionEnd": 130, "guardBlockStart": 115, "guardBlockEnd": 153, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 182, "focalAPIEnd": 201, "followUpCheck": "val <= 0", "checkType": "IF", "followUpCheckExpressionStart": 210, "followUpCheckExpressionEnd": 224, "followUpCheckBlockStart": 210, "followUpCheckBlockEnd": 237, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/QADM/SCG/tree/master/opentaps-1.5/framework/base/src/org/ofbiz/base/util/UtilValidate.java", "rawCode": "  /** Returns true if string s is an integer <= 0. */\n  public static boolean isNonpositiveInteger(String s) {\n    if (isEmpty(s)) return defaultEmptyOK;\n\n    try {\n      int temp = Integer.parseInt(s);\n\n      if (temp <= 0) return true;\n      return false;\n    } catch (Exception e) {\n      return false;\n    }\n\n    // return(isSignedInteger(s, secondArg)\n    // &&((isEmpty(s) && secondArg) ||(parseInt(s) <= 0)));\n  }\n"}, {"dataset": "parseInt", "exampleID": 2743, "initialization": ["String s = new String(byte[],int,*,Charset)"], "initializationStart": [2206], "initializationEnd": [2255], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s,radix)", "focalAPIStart": 2304, "focalAPIEnd": 2331, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(String,int)", "integer.parseInt(String,int)", "integer.parseInt(String,int)", "new MLPFileEntry(val,int,int,int,String)"], "useStart": [2654, 3001, 3348, 3845], "useEnd": [2681, 3028, 3375, 3932], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jpfx1342/mlparch/tree/master/src/mlparch/MLPArch.java", "rawCode": "  public void loadIndexFromArchive() throws FileNotFoundException {\n    prepareRead();\n\n    // The index is a series of file entries, separated by newlines.\n    // There is no file count, so you just have to keep reading until you\n    // reach the end.\n    // note that we expect the index to end with a newline.\n    index = new ArrayList<MLPFileEntry>();\n    byte[] line = new byte[compatMaxLineLength];\n    try {\n      // first seek to the index\n      archRead.seek(indexOffset);\n\n      while (true) {\n        // System.out.println(\"Reading index \"+index.size()+\" at\n        // \"+archAcc.getFilePointer()+\"/\"+archAcc.length());\n        // an index entry is composed of 5 parts, separated by spaces.\n        // an index entry has no size field so you just have to read\n        // until you hit a newline. Here are the parts of an index.\n        // - The Start Offset - This is the beginning of the file, as\n        // measured from the beginning of the archive.\n        // - The End Offset - This is the end of the file, as\n        // measured from the beginning of the archive.\n        // - The Magic 0 - This field is unknown.\n        // - The Magic 1 - This field is unknown, but always seems to be\n        // equal to the start offset.\n        // - The Path - This field indicated the full path to the file\n        // in the archive.\n\n        boolean eof = false;\n        // copy to our line buffer\n        int pos0 = 0;\n        while (true) {\n          try {\n            byte b = archRead.readByte();\n            if (b == compatNewLineChar) break;\n            line[pos0++] = b;\n          } catch (IOException e) {\n            eof = true;\n            break;\n          }\n        }\n        int len = pos0;\n        int pos1 = -1;\n        String field = null;\n        if (len < 1) break;\n\n        // prepare all the fields\n        int fieldStartOffset = 0;\n        int fieldEndOffset = 0;\n        int fieldMagic0 = 0;\n        int fieldMagic1 = 0;\n        String fieldPath = null;\n\n        // read the first field\n        // feel it out\n        pos0 = ++pos1; // pos0 = start of field, pos1 = end of field\n        while (pos1 < compatMaxLineLength && line[pos1] != compatFieldChar) pos1++;\n        field = new String(line, pos0, pos1 - pos0, indexCharset);\n        // parse it\n        fieldStartOffset = Integer.parseInt(field, 10);\n\n        // read the first field\n        // feel it out\n        pos0 = ++pos1; // pos0 = start of field, pos1 = end of field\n        while (pos1 < compatMaxLineLength && line[pos1] != compatFieldChar) pos1++;\n        field = new String(line, pos0, pos1 - pos0, indexCharset);\n        // parse it\n        fieldEndOffset = Integer.parseInt(field, 10);\n\n        // read the first field\n        // feel it out\n        pos0 = ++pos1; // pos0 = start of field, pos1 = end of field\n        while (pos1 < compatMaxLineLength && line[pos1] != compatFieldChar) pos1++;\n        field = new String(line, pos0, pos1 - pos0, indexCharset);\n        // parse it\n        fieldMagic0 = Integer.parseInt(field, 10);\n\n        // read the first field\n        // feel it out\n        pos0 = ++pos1; // pos0 = start of field, pos1 = end of field\n        while (pos1 < compatMaxLineLength && line[pos1] != compatFieldChar) pos1++;\n        field = new String(line, pos0, pos1 - pos0, indexCharset);\n        // parse it\n        fieldMagic1 = Integer.parseInt(field, 10);\n\n        // everything else is the last field.\n        pos0 = ++pos1; // pos0 = start of field, pos1 = end of field\n        pos1 = len;\n        field = new String(line, pos0, pos1 - pos0, indexCharset);\n        // parse it\n        fieldPath = field;\n\n        // if (fieldStartOffset != fieldMagic1)\n        // printlnout(\"startOffset/magic2 field mismatch? \"+index.size()+\": \"+fieldStartOffset+\" !=\n        // \"+fieldMagic1);\n\n        MLPFileEntry entry =\n            new MLPFileEntry(fieldStartOffset, fieldEndOffset, fieldMagic0, fieldMagic1, fieldPath);\n        // printlnout(\"\"+entry.size()+\" / \"+entry.magic0+\" = \"+((float)entry.size()/entry.magic0));\n        index.add(entry);\n\n        if (eof) break;\n      }\n    } catch (IOException ex) {\n      // we reached the end of file. probably.\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2744, "initialization": ["String s = HttpServletRequest.getParameter(String)"], "initializationStart": [154], "initializationEnd": [185], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 215, "focalAPIEnd": 239, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rnewson/couchdb-lucene/tree/master/src/main/java/com/github/rnewson/couchdb/lucene/DatabaseIndexer.java", "rawCode": "  private static int getIntParameter(\n      final HttpServletRequest req, final String parameterName, final int defaultValue) {\n    final String result = req.getParameter(parameterName);\n    return result != null ? Integer.parseInt(result) : defaultValue;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2745, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 356, "tryExpressionEnd": 360, "tryBlockStart": 356, "tryBlockEnd": 1744, "catchExpressionStart": 1551, "catchExpressionEnd": 1573, "catchBlockStart": 1551, "catchBlockEnd": 1607, "exceptionHandlingCallStart": [1581], "exceptionHandlingCallEnd": [1600], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 1124, "focalAPIEnd": 1156, "followUpCheck": "textualWeight.containsKey(val)", "checkType": "IF", "followUpCheckExpressionStart": 1171, "followUpCheckExpressionEnd": 1210, "followUpCheckBlockStart": 1171, "followUpCheckBlockEnd": 1474, "use": ["Map<Integer, List<FlickrData>>.get(val)", "new Integer(val)"], "useStart": [1228, 1426], "useEnd": [1254, 1446], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 1608, "finallyExpressionEnd": 1616, "finallyBlockStart": 1608, "finallyBlockEnd": 1744, "cleanUpCallStart": [1529], "cleanUpCallEnd": [1543], "url": "https://github.com/wjcquking/fuzzyJoin/tree/master/WordCount/src/org/macau/local/sample/SpatialBlackBoxWR2.java", "rawCode": "  /**\n   * @param fileName\n   * @return statistic of the data Using the Account as the weight\n   */\n  public static Map<Integer, List<FlickrData>> getTextualListData(String fileName) {\n\n    File file = new File(fileName);\n\n    BufferedReader reader = null;\n\n    Map<Integer, List<FlickrData>> textualWeight = new HashMap<Integer, List<FlickrData>>();\n\n    try {\n      reader = new BufferedReader(new FileReader(file));\n      String tempString = null;\n      int line = 1;\n\n      // Read One line one time until the null\n      while ((tempString = reader.readLine()) != null) {\n\n        String textual = tempString.toString().split(\":\")[5];\n\n        System.out.println(line);\n        if (!textual.equals(\"null\")) {\n\n          String[] textualList = textual.split(\";\");\n\n          FlickrData fd = FlickrSimilarityUtil.getFlickrDataFromString(tempString);\n          // get the prefix values\n          int prefixLength =\n              SimilarityUtil.getPrefixLength(\n                  textualList.length, FlickrSimilarityUtil.TEXTUAL_THRESHOLD);\n\n          for (int i = 0; i < prefixLength; i++) {\n\n            Integer tokenID = Integer.parseInt(textualList[i]);\n\n            if (textualWeight.containsKey(tokenID)) {\n\n              textualWeight.get(tokenID).add(fd);\n\n            } else {\n\n              List<FlickrData> recordList = new ArrayList<FlickrData>();\n              recordList.add(fd);\n              textualWeight.put(new Integer(tokenID), recordList);\n            }\n          }\n        }\n\n        line++;\n      }\n\n      reader.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    } finally {\n      if (reader != null) {\n        try {\n          reader.close();\n        } catch (IOException e1) {\n        }\n      }\n    }\n    return textualWeight;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2746, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 189, "focalAPIEnd": 216, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(*)", "integer.parseInt(*)"], "useStart": [237, 278], "useEnd": [264, 305], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/edaniels/Seminole_Tix/tree/master/src/com/dunksoftware/seminoletix/ListActivity.java", "rawCode": "  @SuppressWarnings(\"deprecation\")\n  String FormatDate(String Date) {\n    String[] splits = Date.split(\"T\");\n\n    splits = splits[0].split(\"-\");\n\n    Date d =\n        new Date(\n            Integer.parseInt(splits[0]) - 1900,\n            Integer.parseInt(splits[1]),\n            Integer.parseInt(splits[2]));\n    DateFormat newDate = DateFormat.getDateInstance(DateFormat.LONG);\n    newDate.format(d);\n\n    return DateFormat.getDateInstance(DateFormat.LONG).format(d);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2747, "initialization": ["String s = getProperty(String)"], "initializationStart": [523], "initializationEnd": [567], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s!=null", "guardType": "IF {", "guardExpressionStart": 573, "guardExpressionEnd": 597, "guardBlockStart": 573, "guardBlockEnd": 864, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 640, "focalAPIEnd": 669, "followUpCheck": "((val != 80) && (true)) || ((val != 443) )", "checkType": "IF", "followUpCheckExpressionStart": 1002, "followUpCheckExpressionEnd": 1063, "followUpCheckBlockStart": 1002, "followUpCheckBlockEnd": 1118, "use": ["StringBuilder.append(val)"], "useStart": [1095], "useEnd": [1111], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.13/kernel-util/src/main/java/org/sakaiproject/util/Web.java", "rawCode": "  /**\n   * Compute the URL that would return to this server based on the current request. Note: this\n   * method is duplicated in the kernel/request RequestFilter.java\n   *\n   * @param req The request.\n   * @return The URL back to this server based on the current request.\n   */\n  public static String serverUrl(HttpServletRequest req) {\n    String transport = null;\n    int port = 0;\n    boolean secure = false;\n\n    // if force.url.secure is set (to a https port number), use https and this port\n    String forceSecure = System.getProperty(\"sakai.force.url.secure\");\n    if (forceSecure != null) {\n      transport = \"https\";\n      port = Integer.parseInt(forceSecure);\n      secure = true;\n    }\n\n    // otherwise use the request scheme and port\n    else {\n      transport = req.getScheme();\n      port = req.getServerPort();\n      secure = req.isSecure();\n    }\n\n    StringBuilder url = new StringBuilder();\n    url.append(transport);\n    url.append(\"://\");\n    url.append(req.getServerName());\n    if (((port != 80) && (!secure)) || ((port != 443) && secure)) {\n      url.append(\":\");\n      url.append(port);\n    }\n\n    return url.toString();\n  }\n"}, {"dataset": "parseInt", "exampleID": 2748, "initialization": ["String s = getText()"], "initializationStart": [641], "initializationEnd": [655], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "s.length()>0", "guardType": "IF {", "guardExpressionStart": 699, "guardExpressionEnd": 726, "guardBlockStart": 699, "guardBlockEnd": 1003, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 833, "focalAPIEnd": 860, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["SeekBar.setProgress(val)"], "useStart": [870], "useEnd": [894], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/milneti/PayBack/tree/master/PayBack/src/com/example/payback/Transaction4_listview_adapter.java", "rawCode": "  @SuppressWarnings(\"unchecked\")\n  @Override\n  public View getView(final int position, View convertView, ViewGroup parent) {\n    View view = super.getView(position, convertView, parent);\n    EditText text = (EditText) view.findViewById(R.id.borroweramount);\n    SeekBar sb = (SeekBar) view.findViewById(R.id.sliderthing); // the seek bar\n    sb.setMax(maxSeekBar); // sets the max as the max amount anyone can borrow\n    text.setRawInputType(Configuration.KEYBOARD_12KEY);\n\n    if (!(((Map<String, String>) getItem(position)).get(\"data\").startsWith(\"$\"))) {\n      DecimalFormat dec = new DecimalFormat(\"0.00\");\n      String userInput = \"\" + text.getText().toString().replaceAll(\"[^\\\\d]\", \"\");\n      if (userInput.length() > 0) {\n        Float in = Float.parseFloat(userInput);\n        float percen = in / 100;\n        int progress = Integer.parseInt(userInput);\n        sb.setProgress(progress);\n        text.setText(\"$\" + dec.format(percen));\n        text.setSelection(text.getText().length());\n      }\n    }\n\n    final View view2 = view;\n    text.addTextChangedListener(\n        new TextWatcher() {\n          DecimalFormat dec = new DecimalFormat(\"0.00\");\n\n          public void afterTextChanged(Editable arg0) {}\n\n          public void beforeTextChanged(CharSequence s, int start, int count, int after) {}\n\n          public void onTextChanged(\n              CharSequence s,\n              int start,\n              int before,\n              int count) // when text is changed, this is what happens\n              {\n            if (!s.toString().matches(\"^\\\\$(\\\\d{1,3}(\\\\,\\\\d{3})*|(\\\\d+))(\\\\.\\\\d{2})?$\")) {\n              String userInput = \"\" + s.toString().replaceAll(\"[^\\\\d]\", \"\");\n              if (userInput.length() > 0) {\n                EditText text = (EditText) view2.findViewById(R.id.borroweramount);\n                Float in = Float.parseFloat(userInput);\n                float percen = in / 100;\n                text.setText(\"$\" + dec.format(percen));\n                text.setSelection(text.getText().length());\n\n                int index = -1;\n                TextView text2 = (TextView) view2.findViewById(R.id.borrowername);\n                for (int i = 0; i < data.size(); i++) // iterate through ArrayList data to find a\n                { // friend whose entered value is not the same\n                  if (data.get(i).get(\"friendname\")\n                      == text2.getText().toString()) // as the default value\n                  {\n                    index = i; // Set index to that friend's location in data\n                  }\n                }\n\n                data.get(index).put(\"data\", userInput); // update data with new borrowerShare\n              }\n            }\n          }\n        });\n\n    sb.setOnSeekBarChangeListener(\n        new OnSeekBarChangeListener() // listens for changes in seek bar\n        {\n          // when progress changes\n          @Override\n          public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n            EditText text = (EditText) view2.findViewById(R.id.borroweramount);\n            // gets the EditText box which holds a borrower's amount\n            text.setText(Integer.toString(progress));\n            // sets the progress amount as the EditText value\n          }\n\n          @Override\n          public void onStartTrackingTouch(SeekBar seekBar) {}\n\n          @Override\n          public void onStopTrackingTouch(SeekBar seekBar) {}\n        });\n\n    return view;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2749, "initialization": ["String s = String.substring(int,int)"], "initializationStart": [880], "initializationEnd": [902], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 955, "tryExpressionEnd": 959, "tryBlockStart": 955, "tryBlockEnd": 1152, "catchExpressionStart": 1041, "catchExpressionEnd": 1073, "catchBlockStart": 1041, "catchBlockEnd": 1152, "exceptionHandlingCallStart": [1083], "exceptionHandlingCallEnd": [1127], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 973, "focalAPIEnd": 995, "followUpCheck": "val >= 0", "checkType": "IF", "followUpCheckExpressionStart": 1176, "followUpCheckExpressionEnd": 1197, "followUpCheckBlockStart": 1176, "followUpCheckBlockEnd": 1430, "use": ["integer.parseInt(String)", "setForcedDisplaySize(*,val,int)"], "useStart": [1009, 1290], "useEnd": [1031, 1345], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kitkatandroid/JLS36G_base/tree/master/cmds/wm/src/com/android/commands/wm/Wm.java", "rawCode": "  private void runDisplaySize() throws Exception {\n    String size = nextArg();\n    int w, h;\n    if (size == null) {\n      Point initialSize = new Point();\n      Point baseSize = new Point();\n      try {\n        mWm.getInitialDisplaySize(Display.DEFAULT_DISPLAY, initialSize);\n        mWm.getBaseDisplaySize(Display.DEFAULT_DISPLAY, baseSize);\n        System.out.println(\"Physical size: \" + initialSize.x + \"x\" + initialSize.y);\n        if (!initialSize.equals(baseSize)) {\n          System.out.println(\"Override size: \" + baseSize.x + \"x\" + baseSize.y);\n        }\n      } catch (RemoteException e) {\n      }\n      return;\n    } else if (\"reset\".equals(size)) {\n      w = h = -1;\n    } else {\n      int div = size.indexOf('x');\n      if (div <= 0 || div >= (size.length() - 1)) {\n        System.err.println(\"Error: bad size \" + size);\n        return;\n      }\n      String wstr = size.substring(0, div);\n      String hstr = size.substring(div + 1);\n      try {\n        w = Integer.parseInt(wstr);\n        h = Integer.parseInt(hstr);\n      } catch (NumberFormatException e) {\n        System.err.println(\"Error: bad number \" + e);\n        return;\n      }\n    }\n\n    try {\n      if (w >= 0 && h >= 0) {\n        // TODO(multidisplay): For now Configuration only applies to main screen.\n        mWm.setForcedDisplaySize(Display.DEFAULT_DISPLAY, w, h);\n      } else {\n        mWm.clearForcedDisplaySize(Display.DEFAULT_DISPLAY);\n      }\n    } catch (RemoteException e) {\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2750, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 1526, "focalAPIEnd": 1555, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(*)"], "useStart": [1890], "useEnd": [1921], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yeyue910107/MR-Packer/tree/master/src/testquery2.java", "rawCode": "    public void reduce(IntWritable key, Iterable<Text> v, Context context)\n        throws IOException, InterruptedException {\n      Iterator values = v.iterator();\n      ArrayList[] tmp_output = new ArrayList[3];\n      for (int i = 0; i < 3; i++) {\n        tmp_output[i] = new ArrayList();\n      }\n      String tmp = \"\";\n      Double[] result_0 = new Double[1];\n      ArrayList[] d_count_buf_0 = new ArrayList[1];\n      int al_line_0 = 0;\n      for (int i = 0; i < 1; i++) {\n        result_0[i] = 0.0;\n        d_count_buf_0[i] = new ArrayList();\n      }\n\n      ArrayList al_left_1 = new ArrayList();\n      ArrayList al_right_1 = new ArrayList();\n      ArrayList al_left_2 = new ArrayList();\n      ArrayList al_right_2 = new ArrayList();\n      while (values.hasNext()) {\n        String line = values.next().toString();\n        String dispatch = line.split(\"\\\\|\")[1];\n        tmp = line.substring(2 + dispatch.length() + 1);\n        String[] line_buf = tmp.split(\"\\\\|\");\n        if (line.charAt(0) == '2' && (dispatch.length() == 0 || dispatch.indexOf('0') == -1)) {\n          result_0[0] += Double.parseDouble(line_buf[1]);\n          al_line_0++;\n        }\n        if (line.charAt(0) == '2' && (dispatch.length() == 0 || dispatch.indexOf(\"1\") == -1))\n          al_left_1.add(tmp);\n        if (line.charAt(0) == '1' && (dispatch.length() == 0 || dispatch.indexOf(\"1\") == -1))\n          al_right_1.add(tmp);\n      }\n      String[] line_buf = tmp.split(\"\\\\|\");\n      result_0[0] = result_0[0] / al_line_0;\n      tmp_output[0].add(Integer.parseInt(line_buf[0]) + \"|\" + (0.2 * (result_0[0])) + \"|\");\n      for (int i = 0; i < al_left_1.size(); i++) {\n        String[] left_buf_1 = ((String) al_left_1.get(i)).split(\"\\\\|\");\n        for (int j = 0; j < al_right_1.size(); j++) {\n          String[] right_buf_1 = ((String) al_right_1.get(j)).split(\"\\\\|\");\n          tmp_output[1].add(\n              Integer.parseInt(left_buf_1[0])\n                  + \"|\"\n                  + Double.parseDouble(left_buf_1[1])\n                  + \"|\"\n                  + Double.parseDouble(left_buf_1[2])\n                  + \"|\");\n        }\n      }\n      for (int i = 0; i < tmp_output[1].size(); i++) {\n        String[] left_buf_2 = ((String) tmp_output[1].get(i)).split(\"\\\\|\");\n        for (int j = 0; j < tmp_output[0].size(); j++) {\n          String[] right_buf_2 = ((String) tmp_output[0].get(j)).split(\"\\\\|\");\n          if (Double.parseDouble(left_buf_2[1]) < Double.parseDouble(right_buf_2[1])) {\n            tmp_output[2].add(1 + \"|\" + Double.parseDouble(left_buf_2[2]) + \"|\");\n          }\n        }\n      }\n      NullWritable key_op = NullWritable.get();\n      for (int i = 0; i < tmp_output[2].size(); i++) {\n        String result = (String) tmp_output[2].get(i);\n        context.write(key_op, new Text(result));\n      }\n    }\n"}, {"dataset": "parseInt", "exampleID": 2751, "initialization": ["String s = ServiceConfig.getValue(String,String)"], "initializationStart": [122], "initializationEnd": [155], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 173, "focalAPIEnd": 200, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(String)"], "useStart": [306], "useEnd": [343], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/georchestra/geonetwork/tree/master/web/src/main/java/org/fao/geonet/guiservices/metadata/GetRandom.java", "rawCode": "  public void init(String appPath, ServiceConfig config) throws Exception {\n    _config = config;\n\n    String sMaxItems = config.getValue(\"maxItems\", \"10\");\n    _maxItems = Integer.parseInt(sMaxItems);\n    String sTimeBetweenUpdates = config.getValue(\"timeBetweenUpdates\", \"60\");\n    _timeBetweenUpdates = Integer.parseInt(sTimeBetweenUpdates) * 1000;\n\n    // Allow the random search to be restricted to a geographic region\n    _relation = config.getValue(\"relation\", \"overlaps\");\n    _northBL = config.getValue(\"northBL\", \"90\");\n    _southBL = config.getValue(\"southBL\", \"-90\");\n    _eastBL = config.getValue(\"eastBL\", \"180\");\n    _westBL = config.getValue(\"westBL\", \"-180\");\n  }\n"}, {"dataset": "parseInt", "exampleID": 2752, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["new IllegalArgumentException(String)"], "tryExpressionStart": 560, "tryExpressionEnd": 564, "tryBlockStart": 560, "tryBlockEnd": 1196, "catchExpressionStart": 1006, "catchExpressionEnd": 1038, "catchBlockStart": 1006, "catchBlockEnd": 1196, "exceptionHandlingCallStart": [1104], "exceptionHandlingCallEnd": [1187], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(DIFF_SERV_NAMES.containsKey(s,))", "guardType": "IF {", "guardExpressionStart": 454, "guardExpressionEnd": 493, "guardBlockStart": 454, "guardBlockEnd": 1202, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 585, "focalAPIEnd": 608, "followUpCheck": "val > MAX_DIFF_SERV || val < MIN_DIFF_SERV", "checkType": "IF", "followUpCheckExpressionStart": 618, "followUpCheckExpressionEnd": 675, "followUpCheckBlockStart": 618, "followUpCheckBlockEnd": 997, "use": ["adjustDSCPForECN(val)"], "useStart": [1215], "useEnd": [1241], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/activemq/tree/master/activemq-client/src/main/java/org/apache/activemq/transport/tcp/QualityOfServiceUtils.java", "rawCode": "  /**\n   * @param value A potential value to be used for Differentiated Services.\n   * @return The corresponding Differentiated Services Code Point (DSCP).\n   * @throws IllegalArgumentException if the value does not correspond to a Differentiated Services\n   *     Code Point or setting the DSCP is not supported.\n   */\n  public static int getDSCP(String value) throws IllegalArgumentException {\n    int intValue = -1;\n\n    // Check the names first.\n    if (DIFF_SERV_NAMES.containsKey(value)) {\n      intValue = DIFF_SERV_NAMES.get(value);\n    } else {\n      try {\n        intValue = Integer.parseInt(value);\n        if (intValue > MAX_DIFF_SERV || intValue < MIN_DIFF_SERV) {\n          throw new IllegalArgumentException(\n              \"Differentiated Services\"\n                  + \" value: \"\n                  + intValue\n                  + \" not in legal range [\"\n                  + MIN_DIFF_SERV\n                  + \", \"\n                  + MAX_DIFF_SERV\n                  + \"].\");\n        }\n      } catch (NumberFormatException e) {\n        // value must have been a malformed name.\n        throw new IllegalArgumentException(\"No such Differentiated \" + \"Services name: \" + value);\n      }\n    }\n\n    return adjustDSCPForECN(intValue);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2753, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 697, "focalAPIEnd": 722, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wubs/485-Project/tree/master/pa6/hadoop/src/contrib/data_join/src/test/org/apache/hadoop/contrib/utils/join/TestDataJoin.java", "rawCode": "  private static void confirmOutput(Path out, JobConf job, int srcs) throws IOException {\n    FileSystem fs = out.getFileSystem(job);\n    FileStatus[] outlist = fs.listStatus(out);\n    assertEquals(1, outlist.length);\n    assertTrue(0 < outlist[0].getLen());\n    FSDataInputStream in = fs.open(outlist[0].getPath());\n    LineRecordReader rr = new LineRecordReader(in, 0, Integer.MAX_VALUE, job);\n    LongWritable k = new LongWritable();\n    Text v = new Text();\n    int count = 0;\n    while (rr.next(k, v)) {\n      String[] vals = v.toString().split(\"\\t\");\n      assertEquals(srcs + 1, vals.length);\n      int[] ivals = new int[vals.length];\n      for (int i = 0; i < vals.length; ++i) ivals[i] = Integer.parseInt(vals[i]);\n      assertEquals(0, ivals[0] % (srcs * srcs));\n      for (int i = 1; i < vals.length; ++i) {\n        assertEquals((ivals[i] - (i - 1)) * srcs, 10 * ivals[0]);\n      }\n      ++count;\n    }\n    assertEquals(4, count);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2754, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IllegalArgumentException", "exceptionHandlingCall": ["getMessage()", "format(String,int,String,*)", "warn(*)"], "tryExpressionStart": 460, "tryExpressionEnd": 464, "tryBlockStart": 460, "tryBlockEnd": 1610, "catchExpressionStart": 1246, "catchExpressionEnd": 1281, "catchBlockStart": 1246, "catchBlockEnd": 1437, "exceptionHandlingCallStart": [1410, 1321, 1293], "exceptionHandlingCallEnd": [1424, 1425, 1426], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 705, "focalAPIEnd": 732, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(*)", "new GenomeKeywordEntry(String,String,*,val,int)"], "useStart": [754, 1011], "useEnd": [781, 1071], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/utgenome/utgb/tree/master/utgb-core/src/main/java/org/utgenome/format/keyword/KeywordDB.java", "rawCode": "  public void importFromTAB(String ref, Reader tabFileReader) throws UTGBException {\n\n    int entryCount = 0;\n    int lineCount = 1;\n    try {\n      initDB();\n      db.update(\"pragma synchronous = off\");\n      db.setAutoCommit(false);\n\n      BufferedReader input = new BufferedReader(tabFileReader);\n      for (String line; (line = input.readLine()) != null; lineCount++) {\n        // skip the comment line\n        if (line.startsWith(\"#\")) continue;\n\n        try {\n          String[] column = line.split(\"\\t\");\n          if (column.length < 4) {\n            throw new IllegalArgumentException();\n          }\n          // chr, start, end, text ....\n          String chr = column[0];\n          int start = Integer.parseInt(column[1]);\n          int end = Integer.parseInt(column[2]);\n          StringBuilder buf = new StringBuilder();\n          for (int i = 3; i < column.length; ++i) {\n            if (i != 3) buf.append(\" \");\n            buf.append(column[i]);\n          }\n          GenomeKeywordEntry entry = new GenomeKeywordEntry(ref, chr, buf.toString(), start, end);\n\n          if (entryCount > 0 && (entryCount % 10000 == 0))\n            _logger.info(\"num entries: \" + entryCount);\n          entryCount++;\n\n          add(entry);\n        } catch (IllegalArgumentException e) {\n          _logger.warn(\n              String.format(\n                  \"line %d has invalid format: %s (%s)\", lineCount, line, e.getMessage()));\n        } catch (DBException e) {\n          _logger.error(String.format(\"line %d: insertion error %s\", lineCount, e.getMessage()));\n          e.printStackTrace(System.err);\n        }\n      }\n\n      db.update(\"commit\");\n    } catch (DBException e) {\n      _logger.error(\"error at line \" + lineCount);\n      throw new UTGBException(UTGBErrorCode.DatabaseError, e);\n    } catch (IOException e) {\n      throw new UTGBException(UTGBErrorCode.IO_ERROR, e);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2755, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 81, "focalAPIEnd": 111, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fullwall/Citizens/tree/master/src/core/net/citizensnpcs/utils/ConversationUtils.java", "rawCode": "    public int getInteger(int index) throws NumberFormatException {\n      return Integer.parseInt(split[index]);\n    }\n"}, {"dataset": "parseInt", "exampleID": 2756, "initialization": ["String s = Properties.getProperty(String,String)"], "initializationStart": [169], "initializationEnd": [234], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 291, "focalAPIEnd": 340, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bj0rn/Gruppe34/tree/master/Code/lib/mysql-connector-java-5.1.18/src/com/mysql/jdbc/LoadBalancedAutoCommitInterceptor.java", "rawCode": "  public void init(Connection conn, Properties props) throws SQLException {\n    this.conn = (ConnectionImpl) conn;\n\n    String autoCommitSwapThresholdAsString =\n        props.getProperty(\"loadBalanceAutoCommitStatementThreshold\", \"0\");\n    try {\n      this.matchingAfterStatementThreshold = Integer.parseInt(autoCommitSwapThresholdAsString);\n    } catch (NumberFormatException nfe) {\n      // nothing here, being handled in LoadBalancingConnectionProxy.\n    }\n    String autoCommitSwapRegex = props.getProperty(\"loadBalanceAutoCommitStatementRegex\", \"\");\n    if (\"\".equals(autoCommitSwapRegex)) {\n      return;\n    }\n    this.matchingAfterStatementRegex = autoCommitSwapRegex;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2757, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["printUsage()"], "tryExpressionStart": 511, "tryExpressionEnd": 515, "tryBlockStart": 511, "tryBlockEnd": 628, "catchExpressionStart": 569, "catchExpressionEnd": 601, "catchBlockStart": 569, "catchBlockEnd": 628, "exceptionHandlingCallStart": [609], "exceptionHandlingCallEnd": [621], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 536, "focalAPIEnd": 561, "followUpCheck": "ii < val", "checkType": "LOOP", "followUpCheckExpressionStart": 705, "followUpCheckExpressionEnd": 744, "followUpCheckBlockStart": 705, "followUpCheckBlockEnd": 4683, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mhaas/distributed-crawl/tree/master/src/main/java/de/hd/cl/haas/distributedcrawl/App.java", "rawCode": "  public static void main(String[] args)\n      throws IOException, InterruptedException, ClassNotFoundException {\n\n    Configuration conf = new Configuration();\n    FileSystem fs = FileSystem.get(URI.create(WEBDB_DIR), conf);\n\n    Path freshURLs = new Path(FRESHURLS_DIR);\n    Path rawIndex = new Path(INDEX_RAW_DIR);\n\n    Path webdb;\n    Path webdbMerged;\n    Path sortedIndex;\n    Path oldIndex;\n\n    if (args.length < 1) {\n      printUsage();\n    }\n\n    Date start = new Date();\n    int iterations = -1;\n    try {\n      iterations = Integer.parseInt(args[0]);\n    } catch (NumberFormatException e) {\n      printUsage();\n    }\n    System.err.println(\"User requested \" + iterations + \" iterations\");\n    for (int ii = 0; ii < iterations; ii++) {\n      System.err.println(\"Now running iteration \" + ii);\n      Date iterStart = new Date();\n\n      // Indexer:\n      // - reads from WEBDB_DIR\n      // - writes into INDEX_RAW_DIR and FRESH_URLS_DIR\n      // IndexMerger:\n      // - reads from INDEX_RAW_DIR and INDEX_OLD_DIR\n      // - writes into INDEX_SORTED_DIR\n      // WebDBMerger\n      // - reads from WEBDB_DIR and FRESH_URLS_DIR\n      // - writes into WEB_MERGED_DIR\n\n      // flip-flop input and output directories on every run\n      if (ii % 2 == 0) {\n        System.err.println(\"Flipping directories in iteration \" + ii);\n        webdb = new Path(WEBDB_DIR);\n        webdbMerged = new Path(WEBDB_MERGED_DIR);\n        sortedIndex = new Path(INDEX_SORTED_DIR);\n        oldIndex = new Path(INDEX_OLD_DIR);\n\n      } else {\n        System.err.println(\"Flipping directories in iteration \" + ii);\n        webdb = new Path(WEBDB_MERGED_DIR);\n        webdbMerged = new Path(WEBDB_DIR);\n        sortedIndex = new Path(INDEX_OLD_DIR);\n        oldIndex = new Path(INDEX_SORTED_DIR);\n      }\n      // oldIndex always is a pointer to the input directory for IndexMerger\n      // We need to make sure it exists in the first iteration or\n      // Hadoop will error out\n      if (!fs.exists(oldIndex)) {\n        fs.mkdirs(oldIndex);\n      }\n\n      fs.delete(freshURLs, true);\n      fs.mkdirs(freshURLs);\n      fs.delete(rawIndex, true);\n      // fs.mkdirs(rawIndex);\n\n      // delete old stuff, we have data of previous run in oldIndex\n      fs.delete(sortedIndex, true);\n      // delete old stuff, we have data of previous run (webdbMerged + freshurls) in webdb\n      fs.delete(webdbMerged, true);\n\n      Job indexerJob = new IndexerApp().getJob();\n\n      conf.setInt(\"mapred.map.tasks\", 10);\n      // TODO: for multiple mappers, it's probably inefficient to copy everything\n      // to a single reducer (?), so having multiple reducers might speed things up\n      // this doesn't break our data model as the next stop, the\n      // indexMerger, can work just fine with multiple input files\n      // in fact, that might speed up the indexMerger a bit\n      // indexerJob.setNumReduceTasks(30);\n\n      // indexerJob.setMapperClass(MultithreadedMapper.class);\n      // conf.set(\"mapred.map.multithreadedrunner.class\", IndexerMap.class.getCanonicalName());\n      // conf.set(\"mapred.map.multithreadedrunner.threads\", \"8\");\n      FileInputFormat.addInputPath(indexerJob, webdb);\n      FileOutputFormat.setOutputPath(indexerJob, rawIndex);\n\n      boolean success = indexerJob.waitForCompletion(true);\n      handleStatus(indexerJob.getJobName(), success, ii);\n\n      Job indexMergerJob = new IndexMergerApp().getJob();\n      FileInputFormat.addInputPath(indexMergerJob, rawIndex);\n      FileInputFormat.addInputPath(indexMergerJob, oldIndex);\n\n      FileOutputFormat.setOutputPath(indexMergerJob, sortedIndex);\n\n      success = indexMergerJob.waitForCompletion(true);\n      handleStatus(indexMergerJob.getJobName(), success, ii);\n\n      Job webDBMergerJob = new WebDBMergerApp().getJob();\n      // specifies the number of reducers, thus the number\n      // of output files, which should result in an increased\n      // number of indexer mappers\n      // so in pipelined job environments, configuring the number\n      // of reducers may have a positive performance impact\n      // for the following map tasks\n      // especially in our case with small input files and a huge\n      // processing cost for value.\n      webDBMergerJob.setNumReduceTasks(40);\n      FileInputFormat.addInputPath(webDBMergerJob, webdb);\n      FileInputFormat.addInputPath(webDBMergerJob, freshURLs);\n      FileOutputFormat.setOutputPath(webDBMergerJob, webdbMerged);\n      success = webDBMergerJob.waitForCompletion(true);\n      handleStatus(webDBMergerJob.getJobName(), success, ii);\n      Date iterStop = new Date();\n      System.err.println(\"Iteration took \" + (iterStop.getTime() - iterStart.getTime()) / 1024);\n    }\n\n    Date end = new Date();\n    System.err.println(\n        \"Crawling \" + iterations + \" took \" + ((end.getTime() - start.getTime()) / 1000) + \"s\");\n  }\n"}, {"dataset": "parseInt", "exampleID": 2758, "initialization": ["String s = substring(*)"], "initializationStart": [264], "initializationEnd": [309], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 343, "focalAPIEnd": 376, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/choreos/future_market_choreography/tree/master/webServices/tests/src/test/java/br/usp/ime/futuremarket/tests/acceptance/AbstractAcceptanceTest.java", "rawCode": "  protected String getShipper(final String seller) throws IOException {\n    final String noEndSlash = seller.substring(0, seller.length() - 1);\n    final String sellerName = noEndSlash.substring(noEndSlash.lastIndexOf('/') + 1);\n    final String sellerNumberStr = sellerName.substring(sellerName.length() - 1);\n    final int sellerNumberInt = Integer.parseInt(sellerNumberStr);\n\n    final String shipperNumber = (sellerNumberInt % 2 == 0) ? \"2\" : \"1\";\n    final String shipperName = \"shipper\" + shipperNumber;\n\n    return market.getBaseAddress(shipperName);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2759, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s==null||s.isEmpty())", "guardType": "IF {", "guardExpressionStart": 46, "guardExpressionEnd": 75, "guardBlockStart": 46, "guardBlockEnd": 100, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 124, "focalAPIEnd": 143, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/subgraph/Vega/tree/master/platform/com.subgraph.vega.http.proxy/src/com/subgraph/vega/internal/http/proxy/VegaHttpService.java", "rawCode": "  private int stringToSSLPort(String s) {\n    if (s == null || s.isEmpty()) return DEFAULT_SSL_PORT;\n    try {\n      return Integer.parseInt(s);\n    } catch (NumberFormatException e) {\n      return DEFAULT_SSL_PORT;\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2760, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)", "println(String)"], "tryExpressionStart": 55, "tryExpressionEnd": 59, "tryBlockStart": 55, "tryBlockEnd": 656, "catchExpressionStart": 439, "catchExpressionEnd": 459, "catchBlockStart": 439, "catchBlockEnd": 656, "exceptionHandlingCallStart": [467, 545], "exceptionHandlingCallEnd": [537, 606], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 137, "focalAPIEnd": 165, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["connect(val,*)", "integer.parseInt(*)", "disconnect(val)"], "useStart": [119, 327, 306], "useEnd": [178, 355, 356], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/WebDevGirl/VMRouter/tree/master/src/Router.java", "rawCode": "  private static void connect(String[] command) {\n\n    try {\n      switch (command[1]) {\n        case \"add\":\n          portAdmin.connect(Integer.parseInt(command[2]), command[3]);\n          break;\n        case \"del\":\n          if (command[2].trim().equals(\"all\")) portAdmin.disconnectAll();\n          else portAdmin.disconnect(Integer.parseInt(command[2]));\n          break;\n        default:\n          throw new Exception();\n      }\n    } catch (Exception e) {\n      System.out.println(\"usage: connect add <local port> <remote IP:port>\");\n      System.out.println(\"usage: connect del [<local port> | all]\");\n      // System.out.println(e.toString());\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2761, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 182, "focalAPIEnd": 230, "followUpCheck": "LBArray[val][i] < distance", "checkType": "IF", "followUpCheckExpressionStart": 1289, "followUpCheckExpressionEnd": 1320, "followUpCheckBlockStart": 1289, "followUpCheckBlockEnd": 1528, "use": ["integer.parseInt(*)", "FlickrPartitionValue.setPid(val)", "FlickrPartitionValue.setPid(val)", "IntWritable.set(val)"], "useStart": [268, 611, 754, 1005], "useEnd": [316, 626, 777, 1023], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wjcquking/fuzzyJoin/tree/master/WordCount/src/org/macau/flickr/knn/exact/second/kNNJoinMapper.java", "rawCode": "  public void map(Object key, Text value, Context context)\n      throws IOException, InterruptedException {\n\n    FlickrPartitionValue fpv = new FlickrPartitionValue();\n    int pid = Integer.parseInt(value.toString().split(\";\")[0]);\n\n    // R: 0; S:1\n    int dataset = Integer.parseInt(value.toString().split(\";\")[1]);\n    double distance = Double.parseDouble(value.toString().split(\";\")[2]);\n    long id = Long.parseLong(value.toString().split(\";\")[3].trim());\n    double lat = Double.parseDouble(value.toString().split(\";\")[4]);\n    double lon = Double.parseDouble(value.toString().split(\";\")[5].trim());\n\n    fpv.setPid(pid);\n    fpv.setDataset(dataset);\n    fpv.setDistance(distance);\n    fpv.setId(id);\n    fpv.setLat(lat);\n    fpv.setLon(lon);\n\n    outputValue.setPid(pid);\n    outputValue.setDataset(dataset);\n    outputValue.setDistance(distance);\n    outputValue.setId(id);\n    outputValue.setLat(lat);\n    outputValue.setLon(lon);\n\n    // R\n    if (dataset == FlickrSimilarityUtil.R_tag) {\n      outputKey.set(pid);\n\n      context.write(outputKey, outputValue);\n\n    } else if (dataset == FlickrSimilarityUtil.S_tag) {\n\n      for (int i = 0; i < kNNUtil.REDUCER_NUMBER; i++) {\n        // System.out.println(pid + \"{\" + i + \"}\"+LBArray[pid][i] + \"Distance : \" + distance);\n        if (LBArray[pid][i] < distance) {\n          count[i]++;\n          // System.out.println(pid + \":\" + i + \":\"+LBArray[pid][i] + \"Distance : \" + distance);\n          outputKey.set(i);\n          context.write(outputKey, outputValue);\n        }\n      }\n    }\n    // System.out.println(outputKey + \":\" + outputValue);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2762, "initialization": ["String s = substring(*)"], "initializationStart": [293], "initializationEnd": [332], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["s.startsWith(String)"], "configurationStart": [365], "configurationEnd": [389], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 835, "focalAPIEnd": 861, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jonnyzzz/maragogype/tree/master/tags/v1.6/java/com/xerox/amazonws/sdb/DataUtils.java", "rawCode": "  public static String encodeDouble(double d) {\n    // todo: replace String manipulation with math\n    String decimalString = FULL_DECIMAL_FORMAT.format(d);\n    int splitPoint = decimalString.indexOf('E');\n    String significand = decimalString.substring(0, splitPoint);\n    String exponent = decimalString.substring(splitPoint + 1);\n    boolean negativeExponent = exponent.startsWith(\"-\");\n    String result;\n\n    if (significand.startsWith(\"-\")) {\n      // BigDecimal here preserves significand's last digit during add()\n      BigDecimal significandValue = new BigDecimal(significand);\n      BigDecimal collatedSignificand = significandValue.add(SIGNIFICAND_COLLATOR);\n      String formattedSignificand = SIGNIFICAND_FORMAT.format(collatedSignificand);\n\n      if (!negativeExponent) {\n        int exponentValue = EXPONENT_COLLATOR - Integer.parseInt(exponent);\n        result = \"1 \" + exponentValue + \" \" + formattedSignificand;\n      } else {\n        result = \"2 \" + exponent.substring(1) + \" \" + formattedSignificand;\n      }\n    } else {\n      if (d == 0.0D) {\n        result = \"3 000 0.0000000000000000\";\n      } else if (negativeExponent) {\n        int exponentValue = Integer.parseInt(exponent) + EXPONENT_COLLATOR;\n        result = \"4 \" + exponentValue + \" \" + significand;\n      } else {\n        result = \"5 \" + exponent + \" \" + significand;\n      }\n    }\n    return result;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2763, "initialization": ["String s = XPath.evaluate(String,Element)"], "initializationStart": [574], "initializationEnd": [619], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 264, "tryExpressionEnd": 268, "tryBlockStart": 264, "tryBlockEnd": 1005, "catchExpressionStart": 941, "catchExpressionEnd": 961, "catchBlockStart": 941, "catchBlockEnd": 1005, "exceptionHandlingCallStart": [975], "exceptionHandlingCallEnd": [998], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 636, "focalAPIEnd": 657, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Customer(val)"], "useStart": [820], "useEnd": [836], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justin808/dof/tree/master/workshop/Exercise3-AccountingDOF/junit/org/doframework/sample/jdbc_app/test/dof/CustomerDOFHandler.java", "rawCode": "  /**\n   * @param inputStream describing the customer record\n   * @return a Customer object with corresponding name and id\n   */\n  public Customer createCustomer(InputStream inputStream) {\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n    try {\n      DocumentBuilder documentBuilder = dbf.newDocumentBuilder();\n      Document document = documentBuilder.parse(inputStream);\n      XPathFactory pathFactory = XPathFactory.newInstance();\n      XPath xPath = pathFactory.newXPath();\n      Element item = document.getDocumentElement();\n      String sId = xPath.evaluate(\"/customer/customer_id\", item);\n      int id = Integer.parseInt(sId);\n      String name = xPath.evaluate(\"/customer/name\", item);\n      String phoneNumber = xPath.evaluate(\"/customer/phone_number\", item);\n      Customer customer = new Customer(id);\n      customer.setName(name);\n      customer.setPhoneNumber(phoneNumber);\n      return customer;\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2764, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 63, "focalAPIEnd": 82, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pimaster3141/CompleteChat/tree/master/src/server/Server.java", "rawCode": "  private static boolean isInteger(String s) {\n    try {\n      Integer.parseInt(s);\n    } catch (NumberFormatException e) {\n      return false;\n    }\n    return true;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2765, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 240, "focalAPIEnd": 272, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ekirkilevics/TestSSQL/tree/master/archive/thirdparty-non-maven/toniclf-1.0.5/src/com/digitprop/tonic/TonicUtils.java", "rawCode": "  static int getInt(Object key, int defaultValue) {\n    Object value = UIManager.get(key);\n\n    if (value instanceof Integer) {\n      return ((Integer) value).intValue();\n    }\n\n    if (value instanceof String) {\n      try {\n        return Integer.parseInt((String) value);\n      } catch (NumberFormatException nfe) {\n      }\n    }\n    return defaultValue;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2766, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 44, "focalAPIEnd": 78, "followUpCheck": "val == ExifInterface.ORIENTATION_NORMAL", "checkType": "IF", "followUpCheckExpressionStart": 85, "followUpCheckExpressionEnd": 127, "followUpCheckBlockStart": 85, "followUpCheckBlockEnd": 412, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gnuton/Playground/tree/master/HTML5/fleeingchick/platforms/android/CordovaLib/src/org/apache/cordova/ExifHelper.java", "rawCode": "  public int getOrientation() {\n    int o = Integer.parseInt(this.orientation);\n\n    if (o == ExifInterface.ORIENTATION_NORMAL) {\n      return 0;\n    } else if (o == ExifInterface.ORIENTATION_ROTATE_90) {\n      return 90;\n    } else if (o == ExifInterface.ORIENTATION_ROTATE_180) {\n      return 180;\n    } else if (o == ExifInterface.ORIENTATION_ROTATE_270) {\n      return 270;\n    } else {\n      return 0;\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2767, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 307, "tryExpressionEnd": 311, "tryBlockStart": 307, "tryBlockEnd": 573, "catchExpressionStart": 442, "catchExpressionEnd": 474, "catchBlockStart": 442, "catchBlockEnd": 573, "exceptionHandlingCallStart": [484], "exceptionHandlingCallEnd": [548], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 325, "focalAPIEnd": 352, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(*)", "new Coordinate(val,byte,int,Dimension)"], "useStart": [405, 864], "useEnd": [432, 898], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SimpleServer/SimpleServer/tree/master/src/simpleserver/config/LegacyChestList.java", "rawCode": "  @Override\n  protected void loadLine(String line) {\n    line = line.trim();\n    if (line.length() == 0) {\n      return;\n    }\n\n    String[] tokens = line.split(\",\");\n    if (tokens.length >= 5) {\n      int x;\n      byte y;\n      int z;\n      Dimension dimension = Dimension.EARTH;\n      String name;\n      try {\n        x = Integer.parseInt(tokens[2]);\n        y = Byte.parseByte(tokens[3]);\n        z = Integer.parseInt(tokens[4]);\n      } catch (NumberFormatException e) {\n        System.out.println(\"Skipping malformed chest metadata: \" + line);\n        return;\n      }\n\n      if (tokens.length == 6) {\n        name = tokens[5];\n      } else if (tokens.length >= 7) {\n        dimension = Dimension.get(tokens[5]);\n        name = tokens[6];\n      } else {\n        name = (tokens[0].equals(\"-\")) ? \"-\" : t(\"Locked Chest\");\n      }\n\n      Coordinate coordinate = new Coordinate(x, y, z, dimension);\n      locations.put(\n          coordinate, new Chest(tokens[0], coordinate, Boolean.parseBoolean(tokens[1]), name));\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2768, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(s)!=null", "guardType": "IF {", "guardExpressionStart": 356, "guardExpressionEnd": 395, "guardBlockStart": 356, "guardBlockEnd": 435, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 412, "focalAPIEnd": 434, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/edwardlzk/SearchEngine/tree/master/src/edu/nyu/cs/cs2580/hw2/IndexerInvertedOccurrence.java", "rawCode": "  @Override\n  public void loadIndex() throws IOException, ClassNotFoundException {\n    String indexFile = _options._indexPrefix + \"/statistics\";\n    String docFile = _options._indexPrefix + \"/\";\n\n    System.out.println(\"Load index from: \" + indexFile);\n    BufferedReader reader = new BufferedReader(new FileReader(indexFile));\n    String line = null;\n    if ((line = reader.readLine()) != null) this._numDocs = Integer.parseInt(line);\n    if ((line = reader.readLine()) != null) this._totalTermFrequency = Integer.parseInt(line);\n    reader.close();\n    System.out.println(\"Number of docs: \" + this._numDocs);\n    System.out.println(\"TotalTermFrequency: \" + this._totalTermFrequency);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2769, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 42, "focalAPIEnd": 64, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(String)", "integer.parseInt(String)", "integer.parseInt(String)", "integer.parseInt(String)"], "useStart": [277, 565, 1031, 1260], "useEnd": [302, 590, 1056, 1282], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/canlee/EmployeeSystem/tree/master/src/com/icss/employeeSystem/action/Authority/VerifyApplyAction.java", "rawCode": "  public String verify() {\n    int flag = Integer.parseInt(type);\n    Employee emp = null;\n    System.out.println(applyId);\n    try {\n      switch (flag) {\n        case 0:\n          {\n            ApplyHoliday ah =\n                (ApplyHoliday) baseDao.get(ApplyHoliday.class, Integer.parseInt(applyId));\n            ah.setStatus(status);\n            baseDao.update(ah);\n            break;\n          }\n        case 1:\n          {\n            ApplySalaryIncrease asi =\n                (ApplySalaryIncrease)\n                    baseDao.get(ApplySalaryIncrease.class, Integer.parseInt(applyId));\n            asi.setStatus(status);\n            baseDao.update(asi);\n            if (status.equals(\"1\")) {\n              emp = (Employee) baseDao.get(Employee.class, empId);\n              emp.setSalary(Double.parseDouble(salary));\n              baseDao.update(emp);\n            }\n            break;\n          }\n        case 2:\n          {\n            ApplyChangeDep acd =\n                (ApplyChangeDep) baseDao.get(ApplyChangeDep.class, Integer.parseInt(applyId));\n            acd.setStatus(status);\n            baseDao.update(acd);\n            if (status.equals(\"1\")) {\n              emp = (Employee) baseDao.get(Employee.class, empId);\n              emp.setPostId(Integer.parseInt(post));\n              baseDao.update(emp);\n            }\n            break;\n          }\n        default:\n          {\n            break;\n          }\n      }\n    } catch (Exception e) {\n      // TODO: handle exception\n      e.printStackTrace();\n      return \"fail\";\n    }\n    return \"success\";\n  }\n"}, {"dataset": "parseInt", "exampleID": 2770, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 408, "focalAPIEnd": 433, "followUpCheck": "val > 3", "checkType": "IF", "followUpCheckExpressionStart": 542, "followUpCheckExpressionEnd": 552, "followUpCheckBlockStart": 542, "followUpCheckBlockEnd": 559, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Holyvirus/Blacksmith/tree/master/src/com/github/Holyvirus/Blacksmith/BlackSmith.java", "rawCode": "  public boolean onCommand(CommandSender sender, Command cmd, String commandLabel, String[] args) {\n    if (cmd.getName().equalsIgnoreCase(\"BlackSmith\") || (cmd.getName().equalsIgnoreCase(\"bs\"))) {\n      if (args.length >= 1) {\n        if (args[0].equalsIgnoreCase(\"enchants\")) {\n          int p = 1;\n          if (args.length < 2) {\n            p = 1;\n          } else {\n            try {\n              p = Integer.parseInt(args[1]);\n            } catch (NumberFormatException ex) {\n              p = 1;\n            }\n          }\n\n          if (p > 3) p = 3;\n\n          if (p == 1) {\n            sender.sendMessage(\n                ChatColor.GOLD\n                    + \"=_=_=_=_=_=_=_=_=_=_={\"\n                    + ChatColor.DARK_GRAY\n                    + \"BlackSmith\"\n                    + ChatColor.GOLD\n                    + \"}=_=_=_=_=_=_=_=_=_=_=\");\n            sender.sendMessage(\n                ChatColor.GRAY\n                    + \"Here is the first page of the enchants, for the rest please type \\\"/bs enchants (pg)!\\\"\");\n            sender.sendMessage(\" -protection\");\n            sender.sendMessage(\" -fire_protection\");\n            sender.sendMessage(\" -feather_fall\");\n            sender.sendMessage(\" -blast_protection\");\n            sender.sendMessage(\" -projectile_protection\");\n            sender.sendMessage(\" -respiration\");\n            sender.sendMessage(\" -aqua_affinity\");\n          } else if (p == 2) {\n            sender.sendMessage(\n                ChatColor.GOLD\n                    + \"=_=_=_=_=_=_=_=_=_=_={\"\n                    + ChatColor.DARK_GRAY\n                    + \"BlackSmith\"\n                    + ChatColor.GOLD\n                    + \"}=_=_=_=_=_=_=_=_=_=_=\");\n            sender.sendMessage(\n                ChatColor.GRAY\n                    + \"Here is the second page of enchants, for the others please type \\\"/bs enchants (pg)!\\\"!\");\n            sender.sendMessage(\" -sharpness\");\n            sender.sendMessage(\" -smite\");\n            sender.sendMessage(\" -bane_of_arthropods\");\n            sender.sendMessage(\" -knockback\");\n            sender.sendMessage(\" -fire_aspect\");\n            sender.sendMessage(\" -looting\");\n            sender.sendMessage(\" -efficiency\");\n          } else if (p == 3) {\n            sender.sendMessage(\n                ChatColor.GOLD\n                    + \"=_=_=_=_=_=_=_=_=_=_={\"\n                    + ChatColor.DARK_GRAY\n                    + \"BlackSmith\"\n                    + ChatColor.GOLD\n                    + \"}=_=_=_=_=_=_=_=_=_=_=\");\n            sender.sendMessage(\n                ChatColor.GRAY\n                    + \"Here is the third page of enchants, for the others please type \\\"/bs enchants (pg)!\\\"!\");\n            sender.sendMessage(\" -silk touch\");\n            sender.sendMessage(\" -unbreaking\");\n            sender.sendMessage(\" -fortune\");\n            sender.sendMessage(\" -power\");\n            sender.sendMessage(\" -punch\");\n            sender.sendMessage(\" -flame\");\n            sender.sendMessage(\" -infinity\");\n          }\n        } else {\n          sender.sendMessage(\n              ChatColor.RED + \"You have entered an invlaid format, please type \\\"/bs enchants\\\"\");\n        }\n      } else {\n        sender.sendMessage(\n            ChatColor.RED + \"You have entered an invlaid format, please type \\\"/bs enchants\\\"\");\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2771, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 1060, "focalAPIEnd": 1085, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["drawChart(String,val)"], "useStart": [1091], "useEnd": [1114], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kazkus/noquarter/tree/master/src/main/java/us/kazk/noquarter/chart/SimpleChart.java", "rawCode": "  public static void main(String[] args) throws IOException {\n    if (args.length == 0) {\n      PrintWriter out =\n          new PrintWriter(\n              new OutputStreamWriter(new FileOutputStream(dir + \"/index.html\"), \"UTF-8\"));\n      out.println(\"<html>\");\n      out.println(\"<body>\");\n      out.println(\"<table>\");\n      for (String symbol : CSVDataManager.getManager().getAllSymbols()) {\n        if (symbol.equals(\"SPY\")) {\n          continue;\n        }\n        out.print(\"<tr>\");\n        out.print(\"<td>\" + symbol + \"</td>\");\n        for (int year = startYear; year <= endYear; year++) {\n          out.print(\"<td>\");\n          if (drawChart(symbol, year)) {\n            out.print(\"<img src=\\\"\" + symbol + \"-\" + year + \".png\\\">\");\n          } else {\n            out.print(\"&nbsp;\");\n          }\n          out.print(\"</td>\");\n        }\n        out.println(\"</tr>\");\n      }\n      out.println(\"</table>\");\n      out.println(\"</body>\");\n      out.println(\"</html>\");\n      out.flush();\n      return;\n    }\n    //\n    String symbol = args[0];\n    int year = Integer.parseInt(args[1]);\n    drawChart(symbol, year);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2772, "initialization": ["String s = getPageSessionAttribute(*)", "String s = getParameter(*)"], "initializationStart": [84, 301], "initializationEnd": [131, 341], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 481, "focalAPIEnd": 504, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setSelectedNode(val)"], "useStart": [536], "useEnd": [564], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aldaris/opensso/tree/master/products/amserver/source/com/sun/identity/console/agentconfig/GenericAgentProfileViewBean.java", "rawCode": "  protected void setSelectedTabNode(String realmName) {\n    String strID = (String) getPageSessionAttribute(getTrackingTabIDName());\n    int id = TAB_GENERAL_ID;\n\n    if ((strID == null) || (strID.trim().length() == 0)) {\n      HttpServletRequest req = getRequestContext().getRequest();\n      strID = req.getParameter(getTrackingTabIDName());\n      setPageSessionAttribute(getTrackingTabIDName(), strID);\n    }\n\n    if ((strID != null) && (strID.trim().length() > 0)) {\n      id = Integer.parseInt(strID);\n      tabModel.clear();\n      tabModel.setSelectedNode(id);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2773, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 89, "focalAPIEnd": 114, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["printHeader(int,int,val)", "new JGFLUFactBench(val)"], "useStart": [278, 349], "useEnd": [321, 377], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nikomatsakiseth/eth-intervals-java/tree/master/Intervals/test/jgfmt/section2/JGFLUFactBenchSizeC.java", "rawCode": "  public static void main(String argv[]) {\n\n    if (argv.length != 0) {\n      nthreads = Integer.parseInt(argv[0]);\n    } else {\n      System.out.println(\"The no of threads has not been specified, defaulting to 1\");\n      System.out.println(\" \");\n      nthreads = 1;\n    }\n\n    JGFInstrumentor.printHeader(2, 2, nthreads);\n\n    JGFLUFactBench lub = new JGFLUFactBench(nthreads);\n    lub.JGFrun(2);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2774, "initialization": ["String s = new String(char[],int,int)"], "initializationStart": [641], "initializationEnd": [670], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["Log.debug(String)"], "tryExpressionStart": 678, "tryExpressionEnd": 682, "tryBlockStart": 678, "tryBlockEnd": 854, "catchExpressionStart": 748, "catchExpressionEnd": 769, "catchBlockStart": 748, "catchBlockEnd": 854, "exceptionHandlingCallStart": [779], "exceptionHandlingCallEnd": [845], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 716, "focalAPIEnd": 738, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dukeboard/kevoree-extra/tree/master/org.kevoree.extra.freePastry/src/main/java/net/sbbi/upnp/messages/StateVariableResponseParser.java", "rawCode": "  public void characters(char[] ch, int start, int length) {\n    if (parseStateVar) {\n      String origChars = result.stateVariableValue;\n      String newChars = new String(ch, start, length);\n      if (origChars == null) {\n        result.stateVariableValue = newChars;\n      } else {\n        result.stateVariableValue = origChars + newChars;\n      }\n    } else if (readFaultCode) {\n      msgEx.faultCode = new String(ch, start, length);\n      readFaultCode = false;\n    } else if (readFaultString) {\n      msgEx.faultString = new String(ch, start, length);\n      readFaultString = false;\n    } else if (readErrorCode) {\n      String code = new String(ch, start, length);\n      try {\n        msgEx.detailErrorCode = Integer.parseInt(code);\n      } catch (Throwable ex) {\n        log.debug(\"Error during returned error code \" + code + \" parsing\");\n      }\n      readErrorCode = false;\n    } else if (readErrorDescription) {\n      msgEx.detailErrorDescription = new String(ch, start, length);\n      readErrorDescription = false;\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2775, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["toString()", "append(*)"], "tryExpressionStart": 166, "tryExpressionEnd": 170, "tryBlockStart": 166, "tryBlockEnd": 1625, "catchExpressionStart": 1361, "catchExpressionEnd": 1383, "catchBlockStart": 1361, "catchBlockEnd": 1447, "exceptionHandlingCallStart": [1413, 1391], "exceptionHandlingCallEnd": [1425, 1426], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 424, "focalAPIEnd": 447, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/raptium/coursework/tree/master/CSC3170/s05569511/javanetprobe/Administrator.java", "rawCode": "  public void read_books() {\n    Books books = new Books();\n    String[] ss = new String[10];\n    SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm\");\n    try {\n      FileReader fr = new FileReader(\"Books.txt\");\n      BufferedReader br = new BufferedReader(fr);\n      String line = br.readLine();\n      while (line != null) {\n        ss = line.split(\"\\t\", 8); // split s by the seperator \"\\t\"\n        books.bid = Integer.parseInt(ss[0]);\n        books.fid = Integer.parseInt(ss[1]);\n        books.issue_time =\n            (df.parse(ss[2]))\n                .getTime(); // parse ss[4] into a Date object, which is then converted into\n                            // milliseconds using getTime()\n        books.fee = Float.parseFloat(ss[3]);\n\n        // (bid integer, fid integer, iusse_time number(20,0), fee float)\");//Insert books into\n        // DB...\n        PreparedStatement updateSales =\n            conncetobject.con.prepareStatement(\"insert into books values(?,?,?,?)\");\n        updateSales.setInt(1, books.bid);\n        updateSales.setInt(2, books.fid);\n\n        updateSales.setLong(3, books.issue_time);\n        updateSales.setFloat(4, books.fee);\n        updateSales.executeUpdate();\n        // System.out.println(books.toString());\n        line = br.readLine();\n        updateSales.close();\n      }\n      br.close();\n      fr.close();\n    } catch (IOException e) {\n      this.jtextarea.append(e.toString());\n      return;\n    } catch (ParseException e) {\n      this.jtextarea.append(e.toString());\n      return;\n    } catch (SQLException e) {\n      this.jtextarea.append(e.toString());\n      return;\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2776, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 238, "focalAPIEnd": 270, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SnakeDoc/Spark/tree/master/src/jtattoo/src/com/jtattoo/plaf/BaseTitlePane.java", "rawCode": "  static int getInt(Object key, int defaultValue) {\n    Object value = UIManager.get(key);\n    if (value instanceof Integer) {\n      return ((Integer) value).intValue();\n    }\n    if (value instanceof String) {\n      try {\n        return Integer.parseInt((String) value);\n      } catch (NumberFormatException nfe) {\n      }\n    }\n    return defaultValue;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2777, "initialization": ["String s = String.substring(int,char)"], "initializationStart": [958], "initializationEnd": [996], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 1005, "tryExpressionEnd": 1009, "tryBlockStart": 1005, "tryBlockEnd": 1673, "catchExpressionStart": 1599, "catchExpressionEnd": 1627, "catchBlockStart": 1599, "catchBlockEnd": 1673, "exceptionHandlingCallStart": [1637], "exceptionHandlingCallEnd": [1664], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 1027, "focalAPIEnd": 1056, "followUpCheck": "val < inputFields.size()", "checkType": "IF", "followUpCheckExpressionStart": 1066, "followUpCheckExpressionEnd": 1097, "followUpCheckBlockStart": 1066, "followUpCheckBlockEnd": 1590, "use": ["Vector.elementAt(val)", "integer.parseInt(String)", "Vector.elementAt(val)"], "useStart": [1537, 1921, 2581], "useEnd": [1565, 1950, 2609], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jponge/izpack-full-svn-history-copy/tree/master/izpack-src/tags/release-3-6-0/src/lib/com/izforge/izpack/panels/RuleInputField.java", "rawCode": "  /**\n   * Sets each field to a pre-defined value.\n   *\n   * @param data a <code>String</code> containing the preset values for each field. The format of\n   *     the string is as follows: The content for the individuals fields must be separated by\n   *     whitespace. Each data block is preceeded by the index of the field to set (counting starts\n   *     at 0) followed by a colon ':'and after that the actual data for the field.\n   */\n  /*--------------------------------------------------------------------------*/\n  private void setFields(String data) {\n    StringTokenizer tokenizer = new StringTokenizer(data);\n    StringTokenizer tokenizer1 = null;\n    String token;\n    String indexString;\n    String processorClass;\n    int index;\n    boolean process = false;\n    String[] vals = null;\n    int i = 0;\n\n    vals = new String[tokenizer.countTokens()];\n    while (tokenizer.hasMoreTokens()) {\n      token = tokenizer.nextToken();\n      indexString = token.substring(0, token.indexOf(':'));\n\n      try {\n        index = Integer.parseInt(indexString);\n        if (index < inputFields.size()) {\n          String val = token.substring((token.indexOf(':') + 1), token.length());\n          String className = \"\";\n          if (val.indexOf(\":\") > -1) {\n            className = val.substring(val.indexOf(\":\") + 1);\n            val = val.substring(0, val.indexOf(\":\"));\n          }\n\n          if (!className.equals(\"\") && !process) {\n            process = true;\n          }\n          vals[i] = val;\n          i++;\n          ((JTextField) inputFields.elementAt(index)).setText(val);\n        }\n      } catch (Throwable exception) {\n        exception.printStackTrace();\n      }\n    }\n\n    if (process) {\n      tokenizer = new StringTokenizer(data);\n      while (tokenizer.hasMoreTokens()) {\n        token = tokenizer.nextToken();\n        indexString = token.substring(0, token.indexOf(':'));\n\n        try {\n          index = Integer.parseInt(indexString);\n          if (index < inputFields.size()) {\n            String val = token.substring((token.indexOf(':') + 1), token.length());\n            String className = \"\";\n            String presult = \"\";\n            if (val.indexOf(\":\") > -1) {\n              className = val.substring(val.indexOf(\":\") + 1);\n              val = val.substring(0, val.indexOf(\":\"));\n            }\n\n            if (!className.equals(\"\")) {\n              Processor p = (Processor) Class.forName(className).newInstance();\n              presult = p.process(this);\n            }\n            String[] td = new RE(\"\\\\*\").split(presult);\n            ((JTextField) inputFields.elementAt(index)).setText(td[index]);\n          }\n        } catch (Throwable exception) {;\n        }\n      }\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2778, "initialization": ["String s = String.substring(int,int)"], "initializationStart": [488], "initializationEnd": [513], "hasTryCatch": 1, "exceptionType": "NullPointerException", "exceptionHandlingCall": ["getMessage()", "new ParseException(*,int)"], "tryExpressionStart": 666, "tryExpressionEnd": 670, "tryBlockStart": 666, "tryBlockEnd": 989, "catchExpressionStart": 797, "catchExpressionEnd": 831, "catchBlockStart": 797, "catchBlockEnd": 892, "exceptionHandlingCallStart": [864, 845], "exceptionHandlingCallEnd": [881, 885], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 687, "focalAPIEnd": 711, "followUpCheck": "val < 0 || val > 11", "checkType": "IF", "followUpCheckExpressionStart": 1009, "followUpCheckExpressionEnd": 1039, "followUpCheckBlockStart": 1009, "followUpCheckBlockEnd": 1122, "use": ["integer.parseInt(String)", "integer.parseInt(String)", "new ParseException(String,val)", "getDaysInMonth(int,val)", "Calendar.set(int,val,int)"], "useStart": [727, 766, 1052, 1139, 1701], "useEnd": [750, 789, 1121, 1168, 1732], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hcix/CSC531/tree/master/Project/src/utilities/dateAndTime/JDateTextField.java", "rawCode": "  private void validateUSShortDate(String text) throws ParseException {\n    int iFirst = -1, iLast = -1, tokens = 0;\n    for (int i = 0; i < text.length(); i++) {\n      char c = text.charAt(i);\n      if (c == FW_SLASH) {\n        tokens++;\n        if (iFirst == -1) iFirst = i;\n        else iLast = i;\n      }\n    }\n\n    if (tokens != 2)\n      throw new ParseException(\n          \"Insufficient fields (\" + text + \"), need 3 fields in format: \" + FM_US_SHORT_DATE, 0);\n\n    String sMonth = text.substring(0, iFirst);\n    String sDate = text.substring(iFirst + 1, iLast);\n    String sYear = text.substring(iLast + 1);\n\n    int iMonth = -1, iDate = -1, iYear = -1;\n\n    try {\n      iMonth = Integer.parseInt(sMonth);\n      iDate = Integer.parseInt(sDate);\n      iYear = Integer.parseInt(sYear);\n    } catch (NullPointerException npEx) {\n      throw new ParseException(npEx.getMessage(), 0);\n    } catch (NumberFormatException nfEx) {\n      throw new ParseException(nfEx.getMessage(), 0);\n    }\n\n    iMonth--;\n    if (iMonth < 0 || iMonth > 11)\n      throw new ParseException(\"Month field should be between 1 and 12.\", iMonth);\n\n    int days = getDaysInMonth(iYear, iMonth);\n    if (iDate < 1 || iDate > days)\n      throw new ParseException(\"Date field should be between 1 and \" + days + \".\", iDate);\n\n    if (iYear < 0) throw new ParseException(\"Year field can't be negative.\", iYear);\n\n    // If only two digits of year are specified ...\n    if (iYear < 100) {\n      // Use the current year ...\n      iYear += Calendar.getInstance().get(Calendar.YEAR) / 100 * 100;\n    }\n\n    // Create the Calendar object with the converted values ...\n    Calendar cDate = Calendar.getInstance();\n    cDate.clear();\n    cDate.set(iYear, iMonth, iDate);\n\n    this.date = cDate;\n    super.setText(formateDate(cDate, format));\n  }\n"}, {"dataset": "parseInt", "exampleID": 2779, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 498, "focalAPIEnd": 524, "followUpCheck": "val != i2", "checkType": "IF", "followUpCheckExpressionStart": 743, "followUpCheckExpressionEnd": 756, "followUpCheckBlockStart": 743, "followUpCheckBlockEnd": 794, "use": ["integer.parseInt(*)"], "useStart": [631], "useEnd": [657], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ariesteam/thinklab/tree/master/plugins/org.integratedmodelling.thinklab.core/src/org/integratedmodelling/utils/VersionString.java", "rawCode": "    public int compare(String s1, String s2) {\n      if (s1 == null && s2 == null) return 0;\n      else if (s1 == null) return -1;\n      else if (s2 == null) return 1;\n      String[] arr1 = s1.split(\"[^a-zA-Z0-9]+\"), arr2 = s2.split(\"[^a-zA-Z0-9]+\");\n      int i1, i2, i3;\n      for (int ii = 0, max = Math.min(arr1.length, arr2.length); ii <= max; ii++) {\n        if (ii == arr1.length) return ii == arr2.length ? 0 : -1;\n        else if (ii == arr2.length) return 1;\n        try {\n          i1 = Integer.parseInt(arr1[ii]);\n        } catch (Exception x) {\n          i1 = Integer.MAX_VALUE;\n        }\n        try {\n          i2 = Integer.parseInt(arr2[ii]);\n        } catch (Exception x) {\n          i2 = Integer.MAX_VALUE;\n        }\n        if (i1 != i2) {\n          return i1 - i2;\n        }\n        i3 = arr1[ii].compareTo(arr2[ii]);\n        if (i3 != 0) return i3;\n      }\n      return 0;\n    }\n"}, {"dataset": "parseInt", "exampleID": 2780, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["new StringTokenizer(String,String)", "StringTokenizer.nextToken()", "trim()", "toLowerCase()", "String.length()", "substring(int,*)"], "tryExpressionStart": 837, "tryExpressionEnd": 841, "tryBlockStart": 837, "tryBlockEnd": 1855, "catchExpressionStart": 947, "catchExpressionEnd": 981, "catchBlockStart": 947, "catchBlockEnd": 1855, "exceptionHandlingCallStart": [1036, 1135, 1135, 1135, 1253, 1234], "exceptionHandlingCallEnd": [1070, 1149, 1156, 1170, 1267, 1272], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 866, "focalAPIEnd": 892, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/GDI-Vlaanderen/geonetwork/tree/master/jeeves/src/main/java/jeeves/utils/QuartzSchedulerUtils.java", "rawCode": "  /**\n   * Parse string and create a trigger with provided id and group name.\n   *\n   * <p>Formats are cron format ({@link CronExpression}, integer representing period in minutes or\n   * format like 10 hours, 5 minutes, 30 seconds, which will be parsed to create a period.\n   *\n   * @param id id of trigger\n   * @param groupName groupName to assign to trigger\n   * @param schedule the schedule string that needs to be parsed.\n   * @param maxEvery the maximum period to permit\n   * @return trigger object\n   */\n  public static Trigger getTrigger(String id, String groupName, String schedule, long maxEvery) {\n    TriggerBuilder<Trigger> trigger = newTrigger().withIdentity(id, groupName);\n    try {\n      trigger.withSchedule(cronSchedule(new CronExpression(schedule)));\n    } catch (ParseException e) {\n      int periodMillis = 0;\n      try {\n        int everyMin = Integer.parseInt(schedule);\n        periodMillis = everyMin * 1000 * 60;\n      } catch (NumberFormatException nfe) {\n\n        int mult = 0;\n\n        StringTokenizer st = new StringTokenizer(schedule, \",\");\n\n        while (st.hasMoreTokens()) {\n          String token = st.nextToken().trim().toLowerCase();\n\n          if (token.endsWith(\" hour\")) {\n            token = token.substring(0, token.length() - 5);\n            mult = 3600;\n          } else if (token.endsWith(\" hours\")) {\n            token = token.substring(0, token.length() - 6);\n            mult = 3600;\n          } else if (token.endsWith(\" min\")) {\n            token = token.substring(0, token.length() - 4);\n            mult = 60;\n          } else if (token.endsWith(\" sec\")) {\n            token = token.substring(0, token.length() - 4);\n            mult = 1;\n          } else throw new IllegalArgumentException(\"Bad period format :\" + schedule);\n\n          periodMillis += mult * Integer.parseInt(token);\n        }\n      }\n      if (periodMillis < 1 || periodMillis > maxEvery)\n        throw new IllegalArgumentException(\n            schedule + \" is an illegal value, it must be between 1 and \" + maxEvery);\n\n      trigger\n          .withSchedule(\n              simpleSchedule()\n                  .withIntervalInMilliseconds(periodMillis)\n                  .repeatForever()\n                  .withMisfireHandlingInstructionFireNow())\n          .startAt(DateBuilder.futureDate(periodMillis, IntervalUnit.MILLISECOND));\n    }\n\n    return trigger.build();\n  }\n"}, {"dataset": "parseInt", "exampleID": 2781, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 319, "focalAPIEnd": 351, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(*)", "new Voice(String,String,val,int)"], "useStart": [375, 435], "useEnd": [407, 475], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RudolfWeeber/eyes-free/tree/master/trunk/tts/espeak-tts/src/com/googlecode/eyesfree/espeak/SpeechSynthesis.java", "rawCode": "  public List<Voice> getAvailableVoices() {\n    final List<Voice> voices = new LinkedList<Voice>();\n    final String[] results = nativeGetAvailableVoices();\n\n    for (int i = 0; i < results.length; i += 4) {\n      final String name = results[i];\n      final String identifier = results[i + 1];\n      final int gender = Integer.parseInt(results[i + 2]);\n      final int age = Integer.parseInt(results[i + 3]);\n      final Voice voice = new Voice(name, identifier, gender, age);\n\n      voices.add(voice);\n    }\n\n    return voices;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2782, "initialization": ["String s = getIdentifierFromParameters(Element,ServiceContext)"], "initializationStart": [443], "initializationEnd": [493], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 539, "focalAPIEnd": 559, "followUpCheck": "!dataMan.existsMetadata(dbms,val)", "checkType": "IF", "followUpCheckExpressionStart": 565, "followUpCheckExpressionEnd": 609, "followUpCheckBlockStart": 565, "followUpCheckBlockEnd": 683, "use": ["Set<Integer>.add(val)"], "useStart": [1473], "useEnd": [1498], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eea/geonetwork-eea/tree/master/web/src/main/java/org/fao/geonet/services/metadata/UpdateStatus.java", "rawCode": "  /**\n   * @param params\n   * @param context\n   * @return\n   * @throws Exception\n   */\n  public Element exec(Element params, ServiceContext context) throws Exception {\n    GeonetContext gc = (GeonetContext) context.getHandlerContext(Geonet.CONTEXT_NAME);\n\n    DataManager dataMan = gc.getDataManager();\n    AccessManager am = gc.getAccessManager();\n    Dbms dbms = (Dbms) context.getResourceManager().open(Geonet.Res.MAIN_DB);\n    String id = Utils.getIdentifierFromParameters(params, context);\n\n    // --- check access\n    int iLocalId = Integer.parseInt(id);\n    if (!dataMan.existsMetadata(dbms, iLocalId))\n      throw new IllegalArgumentException(\"Metadata not found --> \" + id);\n\n    // --- only allow the owner of the record to set its status\n    if (!am.isOwner(context, id)) {\n      throw new UnAuthorizedException(\n          \"Only the owner of the metadata can set the status. User is not the owner of the metadata\",\n          null);\n    }\n\n    String status = Util.getParam(params, Params.STATUS);\n    String changeMessage = Util.getParam(params, Params.CHANGE_MESSAGE);\n    String changeDate = new ISODate().toString();\n\n    // --- use StatusActionsFactory and StatusActions class to\n    // --- change status and carry out behaviours for status changes\n    StatusActionsFactory saf = new StatusActionsFactory(gc.getStatusActionsClass());\n\n    StatusActions sa = saf.createStatusActions(context, dbms);\n\n    Set<Integer> metadataIds = new HashSet<Integer>();\n    metadataIds.add(iLocalId);\n\n    Set<Integer> unchanged = saf.statusChange(sa, status, metadataIds, changeDate, changeMessage);\n\n    // --- reindex metadata\n    dataMan.indexMetadata(dbms, id, false);\n\n    // --- return id for showing\n    return new Element(Jeeves.Elem.RESPONSE).addContent(new Element(Geonet.Elem.ID).setText(id));\n  }\n"}, {"dataset": "parseInt", "exampleID": 2783, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 172, "focalAPIEnd": 198, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["org.jclouds.rackspace.cloudloadbalancers.v1.CloudLoadBalancersApi.get(val)"], "useStart": [227], "useEnd": [277], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jclouds/legacy-jclouds/tree/master/apis/rackspace-cloudloadbalancers/src/main/java/org/jclouds/rackspace/cloudloadbalancers/v1/loadbalancer/strategy/CloudLoadBalancersGetLoadBalancerMetadataStrategy.java", "rawCode": "  @Override\n  public LoadBalancerMetadata getLoadBalancer(String id) {\n    String[] parts = checkNotNull(id, \"id\").split(\"/\");\n    String region = parts[0];\n    int lbId = Integer.parseInt(parts[1]);\n    return converter.apply(client.getLoadBalancerApiForZone(region).get(lbId));\n  }\n"}, {"dataset": "parseInt", "exampleID": 2784, "initialization": ["String s = new String(char[],int,int)"], "initializationStart": [621], "initializationEnd": [651], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 671, "focalAPIEnd": 690, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lemmy/dnsjava/tree/master/tags/dnsjava-0-6/org/xbill/DNS/utils/MyStringTokenizer.java", "rawCode": "  public String nextToken() {\n    if (putBack != null) {\n      String s = putBack;\n      putBack = null;\n      return s;\n    }\n    int start = current;\n    if (isDelim(current)) {\n      /* This is whitespace */\n      while (current < string.length && isDelim(current)) current++;\n      if (returnTokens) return new String(string, start, current - start);\n    }\n    boolean quoted = false;\n    boolean escaped = false;\n    StringBuffer sb = new StringBuffer();\n    while (true) {\n      if (current == string.length) break;\n      if (escaped) {\n        if (Character.digit(string[current], 10) >= 0) {\n          String s = new String(string, current, 3);\n          int i = Integer.parseInt(s);\n          sb.append((char) i);\n          current += 2;\n        } else sb.append(string[current]);\n        escaped = false;\n      } else if (quoted) {\n        if (string[current] == '\"') {\n          current++;\n          break;\n        } else sb.append(string[current]);\n      } else {\n        if (string[current] == '\"') quoted = true;\n        else if (string[current] == '\\\\') escaped = true;\n        else if (isDelim(current)) {\n          break;\n        } else sb.append(string[current]);\n      }\n      current++;\n    }\n    return sb.toString();\n  }\n"}, {"dataset": "parseInt", "exampleID": 2785, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 817, "focalAPIEnd": 844, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BrandiATMuhkuh/prore2012gp3/tree/master/android/src/at/ac/tuwien/sportmate/DBHandler.java", "rawCode": "  public static ArrayList<BoCategory> getCategories() {\n\n    boolean ok = true;\n\n    ArrayList<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>();\n    nameValuePairs.add(new BasicNameValuePair(\"method\", \"getCategories\"));\n\n    String serverResponse = DBHandler.sendRequestToServer(serviceName, nameValuePairs);\n\n    if (serverResponse == null || serverResponse.equals(\"nok\")) {\n      ok = false;\n    }\n\n    Scanner sc = new Scanner(serverResponse);\n    sc.useDelimiter(ServerResponseHandler.instance().getLineDelimiter());\n    String line = \"\";\n\n    ArrayList<BoCategory> result = new ArrayList<BoCategory>();\n\n    while (sc.hasNext()) {\n      line = sc.next();\n      // Log.d(\"ServerResponse\", line);\n      String[] values = line.split(\"-!-\");\n\n      BoCategory c = new BoCategory();\n\n      int cat_id = Integer.parseInt(values[0]);\n      String category_name = values[1];\n      double category_intensity = Double.parseDouble(values[2]);\n\n      c.category_id = cat_id;\n      c.category_name = category_name;\n      c.category_intensity = category_intensity;\n\n      result.add(c);\n    }\n\n    if (ok) return result;\n    return null;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2786, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 109, "focalAPIEnd": 154, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["increment(val)"], "useStart": [93], "useEnd": [155], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RomRaider/original.flat/tree/master/tags/0.2.5/src/Enginuity/SwingComponents/TableToolBar.java", "rawCode": "  public void mouseClicked(MouseEvent e) {\n    if (e.getSource() == incrementCoarse) {\n      table.increment(Integer.parseInt(incrementBy.getValue() + \"\"));\n    } else if (e.getSource() == decrementCoarse) {\n      table.increment(0 - Integer.parseInt(incrementBy.getValue() + \"\"));\n    } else if (e.getSource() == incrementFine) {\n      if (table.getScale().getIncrement() > 0) table.increment(1);\n      else table.increment(-1);\n    } else if (e.getSource() == decrementFine) {\n      if (table.getScale().getIncrement() > 0) table.increment(-1);\n      else table.increment(1);\n    } else if (e.getSource() == setValue) {\n      table.setRealValue(setValueText.getValue() + \"\");\n    }\n    table.colorize();\n  }\n"}, {"dataset": "parseInt", "exampleID": 2787, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "TwitterException", "exceptionHandlingCall": ["printStackTrace()", "getMessage()", "println(String)", "exit(int)"], "tryExpressionStart": 344, "tryExpressionEnd": 348, "tryBlockStart": 344, "tryBlockEnd": 774, "catchExpressionStart": 617, "catchExpressionEnd": 645, "catchBlockStart": 617, "catchBlockEnd": 774, "exceptionHandlingCallStart": [653, 728, 681, 752], "exceptionHandlingCallEnd": [673, 743, 744, 767], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 446, "focalAPIEnd": 471, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.parseInt(*)", "destroyUserListMember(val,*)"], "useStart": [473, 416], "useEnd": [498, 499], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/decamun/personalitweet/tree/master/twitter4j-3.0.3/twitter4j-examples/src/main/java/twitter4j/examples/list/DeleteUserListMember.java", "rawCode": "  /**\n   * Usage: java twitter4j.examples.list.DeleteUserListMember [list id] [user id]\n   *\n   * @param args message\n   */\n  public static void main(String[] args) {\n    if (args.length < 2) {\n      System.out.println(\n          \"Usage: java twitter4j.examples.list.DeleteUserListMember [list id] [user id]\");\n      System.exit(-1);\n    }\n    try {\n      Twitter twitter = new TwitterFactory().getInstance();\n      twitter.destroyUserListMember(Integer.parseInt(args[0]), Integer.parseInt(args[1]));\n      System.out.println(\"Successfully deleted user [\" + args[1] + \"] from the list.\");\n      System.exit(0);\n    } catch (TwitterException te) {\n      te.printStackTrace();\n      System.out.println(\"Failed to delete user: \" + te.getMessage());\n      System.exit(-1);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2788, "initialization": ["String s = getString(String)"], "initializationStart": [70], "initializationEnd": [84], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 114, "focalAPIEnd": 146, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thecarlhall/follow/tree/master/src/main/java/ghm/follow/config/FollowAppAttributes.java", "rawCode": "  private int getInt(String key) {\n    int retval = 0;\n    String s = getString(key);\n    if (s != null) retval = Integer.parseInt(getString(key));\n    return retval;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2789, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 200, "focalAPIEnd": 221, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yukoff/concourse-connect/tree/master/src/main/java/com/concursive/connect/web/modules/documents/dao/FileItemList.java", "rawCode": "  /**\n   * Sets the forProjectUser attribute of the FileItemList object\n   *\n   * @param tmp The new forProjectUser value\n   */\n  public void setForProjectUser(String tmp) {\n    this.forProjectUser = Integer.parseInt(tmp);\n  }\n"}, {"dataset": "parseInt", "exampleID": 2790, "initialization": ["String s = normalizeInteger(*)"], "initializationStart": [1701], "initializationEnd": [1744], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["getMessage()", "new RuntimeException(String)"], "tryExpressionStart": 3871, "tryExpressionEnd": 3875, "tryBlockStart": 3871, "tryBlockEnd": 4100, "catchExpressionStart": 3979, "catchExpressionEnd": 4011, "catchBlockStart": 3979, "catchBlockEnd": 4100, "exceptionHandlingCallStart": [4076, 4027], "exceptionHandlingCallEnd": [4090, 4091], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 3895, "focalAPIEnd": 3921, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ansell/openrdf-sesame/tree/master/core/model/src/main/java/org/openrdf/model/datatypes/XMLDatatypeUtil.java", "rawCode": "  /**\n   * Normalizes a floating point lexical value to its canonical representation.\n   *\n   * @param value The lexical value to normalize.\n   * @param minMantissa A normalized decimal indicating the lowest value that the mantissa may have.\n   * @param maxMantissa A normalized decimal indicating the highest value that the mantissa may\n   *     have.\n   * @param minExponent A normalized integer indicating the lowest value that the exponent may have.\n   * @param maxExponent A normalized integer indicating the highest value that the exponent may\n   *     have.\n   * @return The canonical representation of <tt>value</tt>.\n   * @throws IllegalArgumentException If the supplied value is not a legal floating point lexical\n   *     value.\n   */\n  private static String normalizeFPNumber(\n      String value,\n      String minMantissa,\n      String maxMantissa,\n      String minExponent,\n      String maxExponent) {\n    value = collapseWhiteSpace(value);\n\n    if (value.contains(\" \")) {\n      // floating point lexical value can not contain spaces after collapse\n      throwIAE(\"No space allowed in floating point lexical value (\" + value + \")\");\n    }\n\n    // handle special values\n    if (value.equals(\"INF\") || value.equals(\"-INF\") || value.equals(\"NaN\")) {\n      return value;\n    }\n\n    // Search for the exponent character E or e\n    int eIdx = value.indexOf('E');\n    if (eIdx == -1) {\n      // try lower case\n      eIdx = value.indexOf('e');\n    }\n\n    // Extract mantissa and exponent\n    String mantissa, exponent;\n    if (eIdx == -1) {\n      mantissa = normalizeDecimal(value);\n      exponent = \"0\";\n    } else {\n      mantissa = normalizeDecimal(value.substring(0, eIdx));\n      exponent = normalizeInteger(value.substring(eIdx + 1));\n    }\n\n    // Normalize mantissa to one non-zero digit before the dot\n    int shift = 0;\n\n    int dotIdx = mantissa.indexOf('.');\n    int digitCount = dotIdx;\n    if (mantissa.charAt(0) == '-') {\n      digitCount--;\n    }\n\n    if (digitCount > 1) {\n      // more than one digit before the dot, e.g 123.45, -10.0 or 100.0\n      StringBuilder sb = new StringBuilder(mantissa.length());\n      int firstDigitIdx = 0;\n      if (mantissa.charAt(0) == '-') {\n        sb.append('-');\n        firstDigitIdx = 1;\n      }\n      sb.append(mantissa.charAt(firstDigitIdx));\n      sb.append('.');\n      sb.append(mantissa.substring(firstDigitIdx + 1, dotIdx));\n      sb.append(mantissa.substring(dotIdx + 1));\n\n      mantissa = sb.toString();\n\n      // Check if the mantissa has excessive trailing zeros.\n      // For example, 100.0 will be normalize to 1.000 and\n      // -10.0 to -1.00.\n      int nonZeroIdx = mantissa.length() - 1;\n      while (nonZeroIdx >= 3 && mantissa.charAt(nonZeroIdx) == '0') {\n        nonZeroIdx--;\n      }\n\n      if (nonZeroIdx < 3 && mantissa.charAt(0) == '-') {\n        nonZeroIdx++;\n      }\n\n      if (nonZeroIdx < mantissa.length() - 1) {\n        mantissa = mantissa.substring(0, nonZeroIdx + 1);\n      }\n\n      shift = 1 - digitCount;\n    } else if (mantissa.startsWith(\"0.\") || mantissa.startsWith(\"-0.\")) {\n      // Example mantissas: 0.0, -0.1, 0.00345 and 0.09\n      // search first non-zero digit\n      int nonZeroIdx = 2;\n      while (nonZeroIdx < mantissa.length() && mantissa.charAt(nonZeroIdx) == '0') {\n        nonZeroIdx++;\n      }\n\n      // 0.0 does not need any normalization:\n      if (nonZeroIdx < mantissa.length()) {\n        StringBuilder sb = new StringBuilder(mantissa.length());\n        sb.append(mantissa.charAt(nonZeroIdx));\n        sb.append('.');\n        if (nonZeroIdx == mantissa.length() - 1) {\n          // There was only one non-zero digit, e.g. as in 0.09\n          sb.append('0');\n        } else {\n          sb.append(mantissa.substring(nonZeroIdx + 1));\n        }\n\n        mantissa = sb.toString();\n        shift = nonZeroIdx - 1;\n      }\n    }\n\n    if (shift != 0) {\n      try {\n        int exp = Integer.parseInt(exponent);\n        exponent = String.valueOf(exp - shift);\n      } catch (NumberFormatException e) {\n        throw new RuntimeException(\"NumberFormatException: \" + e.getMessage());\n      }\n    }\n\n    // Check lower and upper bounds of canonicalized representation, if\n    // applicable\n    if (minMantissa != null) {\n      if (compareCanonicalDecimals(mantissa, minMantissa) < 0) {\n        throwIAE(\"Mantissa smaller than minimum value (\" + minMantissa + \")\");\n      }\n    }\n    if (maxMantissa != null) {\n      if (compareCanonicalDecimals(mantissa, maxMantissa) > 0) {\n        throwIAE(\"Mantissa larger than maximum value (\" + maxMantissa + \")\");\n      }\n    }\n    if (minExponent != null) {\n      if (compareCanonicalIntegers(exponent, minExponent) < 0) {\n        throwIAE(\"Exponent smaller than minimum value (\" + minExponent + \")\");\n      }\n    }\n    if (maxExponent != null) {\n      if (compareCanonicalIntegers(exponent, maxExponent) > 0) {\n        throwIAE(\"Exponent larger than maximum value (\" + maxExponent + \")\");\n      }\n    }\n\n    return mantissa + \"E\" + exponent;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2791, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": ["emptyList()"], "tryExpressionStart": 106, "tryExpressionEnd": 110, "tryBlockStart": 106, "tryBlockEnd": 236, "catchExpressionStart": 159, "catchExpressionEnd": 191, "catchBlockStart": 159, "catchBlockEnd": 236, "exceptionHandlingCallStart": [206], "exceptionHandlingCallEnd": [229], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 129, "focalAPIEnd": 151, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/gmf-tooling.uml2tools/tree/master/plugins/org.eclipse.uml2.diagram.profile/src/org/eclipse/uml2/diagram/profile/part/VisualIDRegistryExtension.java", "rawCode": "  /** @generated */\n  public List<MenuTypeHint> getMenuTypeHints(String type) {\n    int visualId = 0;\n    try {\n      visualId = Integer.parseInt(type);\n    } catch (NumberFormatException e) {\n      return Collections.emptyList();\n    }\n\n    switch (visualId) {\n      default:\n        List<MenuTypeHint> hints = new LinkedList<MenuTypeHint>();\n        hints.add(new MenuTypeHint(\"\", type));\n        return hints;\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2792, "initialization": ["String s = substring(int,*)"], "initializationStart": [1214], "initializationEnd": [1241], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s,radix)", "focalAPIStart": 1311, "focalAPIEnd": 1345, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/DevBoost/EMFText/tree/master/Deprecated/org.emftext.sdk.antlr3_3_0/src-sdk/org/antlr/tool/Grammar.java", "rawCode": "  /**\n   * ANTLR does not convert escape sequences during the parse phase because it could not know how to\n   * print String/char literals back out when printing grammars etc... Someone in China might use\n   * the real unicode char in a literal as it will display on their screen; when printing back out,\n   * I could not know whether to display or use a unicode escape.\n   *\n   * <p>This routine converts a string literal with possible escape sequences into a pure string of\n   * 16-bit char values. Escapes and unicode \\u0000 specs are converted to pure chars. return in a\n   * buffer; people may want to walk/manipulate further.\n   *\n   * <p>The NFA construction routine must know the actual char values.\n   */\n  public static StringBuffer getUnescapedStringFromGrammarStringLiteral(String literal) {\n    // System.out.println(\"escape: [\"+literal+\"]\");\n    StringBuffer buf = new StringBuffer();\n    int last = literal.length() - 1; // skip quotes on outside\n    for (int i = 1; i < last; i++) {\n      char c = literal.charAt(i);\n      if (c == '\\\\') {\n        i++;\n        c = literal.charAt(i);\n        if (Character.toUpperCase(c) == 'U') {\n          // \\u0000\n          i++;\n          String unicodeChars = literal.substring(i, i + 4);\n          // parse the unicode 16 bit hex value\n          int val = Integer.parseInt(unicodeChars, 16);\n          i += 4 - 1; // loop will inc by 1; only jump 3 then\n          buf.append((char) val);\n        } else if (Character.isDigit(c)) {\n          ErrorManager.error(ErrorManager.MSG_SYNTAX_ERROR, \"invalid char literal: \" + literal);\n          buf.append(\"\\\\\" + (char) c);\n        } else {\n          buf.append((char) ANTLRLiteralEscapedCharValue[c]); // normal \\x escape\n        }\n      } else {\n        buf.append(c); // simple char x\n      }\n    }\n    // System.out.println(\"string: [\"+buf.toString()+\"]\");\n    return buf;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2793, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 636, "focalAPIEnd": 679, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setDifficulty(val)"], "useStart": [613], "useEnd": [680], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/shallada/ChessExtended/tree/master/src/AIClient.java", "rawCode": "  public static void main(String[] args) {\n    BoardDisplay.setSHOW_ALERT(false);\n    final int argumentsLength = args.length;\n    boolean giveInfo = true;\n\n    if (argumentsLength > 1 && argumentsLength <= 6) {\n      giveInfo = false;\n      try {\n        if (argumentsLength >= 5) {\n          white = GameController.PlayerType.valueOf(args[2]);\n          black = GameController.PlayerType.valueOf(args[3]);\n        } else {\n          white = GameController.PlayerType.AI;\n          black = GameController.PlayerType.LearningServer;\n        }\n        if (argumentsLength == 4 || argumentsLength == 6) {\n          AIPlayer.setDifficulty(Integer.parseInt(args[argumentsLength - 2]));\n        }\n        if (argumentsLength >= 3) {\n          GameController.setShowBoard(Boolean.parseBoolean(args[1]));\n        } else {\n          GameController.setShowBoard(true);\n        }\n        final long iterations = Long.parseLong(args[0]);\n        for (int j = 0; j < Integer.parseInt(args[args.length - 1]); j++) {\n          new Thread() {\n            @Override\n            public void run() {\n              for (int i = 0; i < iterations; i++) {\n                setupRunClose();\n              }\n            }\n          }.start();\n        }\n      } catch (IllegalArgumentException e) {\n        giveInfo = true;\n      }\n    }\n    if (giveInfo) {\n      System.out.println();\n      System.out.println(\"param set 1 [2 param]\");\n      System.out.println(\"AIClient (# of iterations) (number of threads)\");\n      System.out.println();\n      System.out.println(\"param set 2 [3 params]\");\n      System.out.println(\"AIClient (# of iterations) (visable) (number of threads)\");\n      System.out.println();\n      System.out.println(\"param set 3 [4 params]\");\n      System.out.println(\n          \"AIClient (# of iterations) (visable) (AI Difficulty) (number of threads)\");\n      System.out.println();\n      System.out.println(\"param set 4 [5 params]\");\n      System.out.println(\n          \"AIClient (# of iterations) (visable) (white Player Type) (black Player Type) (number of threads)\");\n      System.out.println();\n      System.out.println(\"param set 5 [6 params]\");\n      System.out.println(\n          \"AIClient (# of iterations) (visable) (white Player Type) (black Player Type) (AI Difficulty) (number of threads)\");\n      System.out.println();\n      System.out.println(\"Player Types:\");\n      System.out.println(\"\\t \" + GameController.PlayerType.AI);\n      System.out.println(\"\\t \" + GameController.PlayerType.LearningServer);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2794, "initialization": ["String s = Matcher.group(int)"], "initializationStart": [177], "initializationEnd": [187], "hasTryCatch": 1, "exceptionType": "NumberFormatException", "exceptionHandlingCall": [], "tryExpressionStart": 217, "tryExpressionEnd": 221, "tryBlockStart": 217, "tryBlockEnd": 399, "catchExpressionStart": 267, "catchExpressionEnd": 299, "catchBlockStart": 267, "catchBlockEnd": 399, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 238, "focalAPIEnd": 257, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new NetworkCodeQualifier(val)"], "useStart": [440], "useEnd": [470], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Cyberspice/platform_tools_base/tree/master/sdk-common/src/main/java/com/android/ide/common/resources/configuration/NetworkCodeQualifier.java", "rawCode": "  @Override\n  public boolean checkAndSet(String value, FolderConfiguration config) {\n    Matcher m = sNetworkCodePattern.matcher(value);\n    if (m.matches()) {\n      String v = m.group(1);\n\n      int code = -1;\n      try {\n        code = Integer.parseInt(v);\n      } catch (NumberFormatException e) {\n        // looks like the string we extracted wasn't a valid number.\n        return false;\n      }\n\n      NetworkCodeQualifier qualifier = new NetworkCodeQualifier(code);\n      config.setNetworkCodeQualifier(qualifier);\n      return true;\n    }\n\n    return false;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2795, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 399, "focalAPIEnd": 424, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/teropa/stem/tree/master/org.eclipse.stem.utility/src/org/eclipse/stem/utility/generators/AttenuateLogFile.java", "rawCode": "  /** @param args */\n  @SuppressWarnings(\"nls\")\n  public static void main(String[] args) {\n    if (args.length < 4) {\n      System.err.println(\n          \"Usage: AttenuateLogFile <log file> <cycle period> <start offset> <signal1> <signal2> ... <signal n>\"); // $NON-NLS-1$\n      System.exit(-1);\n    }\n\n    String logFile = args[0];\n    double period = Double.parseDouble(args[1]);\n    int offset = Integer.parseInt(args[2]);\n    double damp = Double.parseDouble(args[3]);\n\n    int[] signal = new int[args.length - 4];\n    for (int i = 4; i < args.length; ++i) signal[i - 4] = Integer.parseInt(args[i]);\n\n    ArrayList<String> headers = new ArrayList<String>();\n    ArrayList<ArrayList<String>> logText = new ArrayList<ArrayList<String>>();\n    ArrayList<ArrayList<Double>> logData = new ArrayList<ArrayList<Double>>();\n\n    try {\n      // Read infectious file\n      FileInputStream ifile = new FileInputStream(logFile);\n      BufferedReader ireader = new BufferedReader(new InputStreamReader(ifile));\n      String header = null;\n      header = ireader.readLine();\n      if (header == null) {\n        System.err.println(\"Error, \" + args[0] + \" file is empty!\"); // $NON-NLS-1$//$NON-NLS-2$\n        System.exit(-2);\n      }\n      StringTokenizer st = new StringTokenizer(header, \",\"); // $NON-NLS-1$\n      int column = 0;\n      while (st.hasMoreTokens()) {\n        String val = st.nextToken();\n        headers.add(val.trim());\n        ++column;\n      }\n\n      String data = null;\n      data = ireader.readLine();\n      if (data == null) {\n        System.err.println(\"Error, \" + args[0] + \" file has no data!\"); // $NON-NLS-1$//$NON-NLS-2$\n        System.exit(-2);\n      }\n\n      while (data != null && data.trim().length() > 0) {\n\n        st = new StringTokenizer(data, \",\"); // $NON-NLS-1$\n        column = 0;\n        ArrayList<String> txtlist = new ArrayList<String>();\n        ArrayList<Double> datalist = new ArrayList<Double>();\n        while (st.hasMoreTokens()) {\n          String val = st.nextToken().trim();\n          if (column < 2) txtlist.add(val);\n          else datalist.add(Double.parseDouble(val));\n          ++column;\n        } // read tokens\n        logText.add(txtlist);\n        logData.add(datalist);\n        data = ireader.readLine();\n      }\n      ireader.close();\n\n      // Process the data\n\n      int day = offset;\n      int year = 0;\n      double startNewYear = period;\n      System.out.println(\"signal: \" + signal);\n      for (int i = 0; i < logText.size(); ++i) {\n        int sig = signal[year];\n        ArrayList<Double> infdata = logData.get(i);\n        if (sig == 0)\n          for (int j = 0; j < infdata.size(); ++j) infdata.set(j, infdata.get(j) * damp);\n\n        day += 1;\n        if (day > startNewYear) {\n          startNewYear += period;\n          ++year;\n        }\n        System.out.println(\"iteration \" + i + \" signal: \" + sig);\n      }\n\n      FileWriter outfw = new FileWriter(logFile + \".new.csv\");\n      for (int i = 0; i < headers.size(); ++i) {\n        outfw.write(headers.get(i));\n        if (i < headers.size() - 1) outfw.write(\",\");\n      }\n      outfw.write(LS);\n\n      for (int i = 0; i < logText.size(); ++i) {\n        ArrayList<String> txtlist = logText.get(i);\n        ArrayList<Double> datalist = logData.get(i);\n        for (String t : txtlist) outfw.write(t + \",\");\n        for (int j = 0; j < datalist.size(); ++j) {\n          outfw.write(datalist.get(j) + \"\");\n          if (j < datalist.size() - 1) outfw.write(\",\");\n        }\n        outfw.write(LS);\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2796, "initialization": ["String s = getStringPropertyValue(InjectionPoint)"], "initializationStart": [169], "initializationEnd": [207], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(s==null||s.length()==0)", "guardType": "IF {", "guardExpressionStart": 214, "guardExpressionEnd": 275, "guardBlockStart": 214, "guardBlockEnd": 299, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 322, "focalAPIEnd": 355, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/LightGuard/incubator-deltaspike/tree/master/deltaspike/core/impl/src/test/java/org/apache/deltaspike/test/core/api/config/injectable/CustomConfigAnnotationWithMetaDataProducer.java", "rawCode": "  @Produces\n  @Dependent\n  @CustomConfigAnnotationWithMetaData\n  public Integer produceIntegerCustomConfig(InjectionPoint injectionPoint) {\n    String configuredValue = getStringPropertyValue(injectionPoint);\n\n    if (configuredValue == null || configuredValue.length() == 0) {\n      return 0;\n    }\n\n    Integer result = Integer.parseInt(configuredValue);\n\n    CustomConfigAnnotationWithMetaData metaData =\n        getAnnotation(injectionPoint, CustomConfigAnnotationWithMetaData.class);\n\n    if (metaData != null && metaData.inverseConvert()) {\n      return result * -1;\n    }\n\n    return result;\n  }\n"}, {"dataset": "parseInt", "exampleID": 2797, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "NullPointerException", "exceptionHandlingCall": ["new IllegalArgumentException(*)"], "tryExpressionStart": 222, "tryExpressionEnd": 226, "tryBlockStart": 222, "tryBlockEnd": 593, "catchExpressionStart": 364, "catchExpressionEnd": 395, "catchBlockStart": 364, "catchBlockEnd": 490, "exceptionHandlingCallStart": [452], "exceptionHandlingCallEnd": [483], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 327, "focalAPIEnd": 354, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["integer.toString(*)"], "useStart": [310], "useEnd": [355], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pruiz/signserver/tree/master/signserver/modules/SignServer-Lib-ODFDOM/src/main/java/org/odftoolkit/odfdom/dom/attribute/presentation/PresentationVerbAttribute.java", "rawCode": "  /**\n   * @param attrValue The <code>String</code> value of the attribute.\n   * @throws IllegalArgumentException If the provided attribute value is invalid\n   */\n  @Override\n  public void setValue(String attrValue) {\n    try {\n      // 2DO: need validate value against NonNegativeInteger\n      super.setValue(Integer.toString(Integer.parseInt(attrValue)));\n    } catch (NullPointerException e) {\n      // TODO: validation handling/logging\n      throw new IllegalArgumentException(e);\n    } catch (IllegalArgumentException e) {\n      // TODO: validation handling/logging\n      throw (e);\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2798, "initialization": ["String s = split(String)"], "initializationStart": [397], "initializationEnd": [412], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 437, "focalAPIEnd": 463, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JonKjaersgaard/alt-ussr/tree/master/src/ussr/samples/atron/network/ATRONCarControllerMC.java", "rawCode": "  public void doProgeam(int program, int value, int channel) {\n    switch (Programs.decode(program)) {\n      case MOVE_FORWARD_CONTINUOUS:\n        if (true) ;\n        int i = 0;\n        int[] cs = new int[3];\n\n        for (int c = 0; c < 7; c++)\n          if (this.isConnected(c)) {\n            cs[i] = c;\n            i++;\n          }\n        if (i == 1) {\n          String idString = ((String[]) name.split(\",\"))[1];\n          int id = Integer.parseInt(idString);\n\n          doBasicProgram((id % 2 == 0 ? 1 : 6), value);\n        }\n\n        // for(int m=0; m)\n        String st = \"-21,1,\" + program + \",\" + value;\n        System.out.println(\"Module \" + name + \" sends message:\" + st);\n        for (int c = 0; c < 7; c++)\n          if (this.isConnected(c) && c != channel)\n            this.sendMessage(st.getBytes(), (byte) st.getBytes().length, (byte) c);\n\n        break;\n      case MOVE_FORWARD_RADIAN:\n        break;\n      case MOVE_BACKWARD_CONTINUOUS:\n        this.rotate(value);\n        break;\n      case MOVE_BACKWARD_RADIAN:\n        break;\n      case STOP_MOVE:\n        this.rotate(0);\n        break;\n      case STOP_EMERGENCY:\n        this.rotate(0);\n        break;\n      default:\n        doBasicProgram(program, value);\n        break;\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2799, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 671, "focalAPIEnd": 698, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["generate(val)"], "useStart": [1321], "useEnd": [1336], "hasFinally": 1, "cleanUpCall": ["FileSystem.close()"], "finallyExpressionStart": 1506, "finallyExpressionEnd": 1514, "finallyBlockStart": 1506, "finallyBlockEnd": 1539, "cleanUpCallStart": [1522], "cleanUpCallEnd": [1532], "url": "https://github.com/nourlcn/yarn-comment/tree/master/hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/io/TestSetFile.java", "rawCode": "  /** For debugging and testing. */\n  public static void main(String[] args) throws Exception {\n    int count = 1024 * 1024;\n    boolean create = true;\n    boolean check = true;\n    String file = FILE;\n    String compress = \"NONE\";\n\n    String usage = \"Usage: TestSetFile [-count N] [-nocreate] [-nocheck] [-compress type] file\";\n\n    if (args.length == 0) {\n      System.err.println(usage);\n      System.exit(-1);\n    }\n\n    int i = 0;\n    Path fpath = null;\n    FileSystem fs = null;\n    try {\n      for (; i < args.length; i++) { // parse command line\n        if (args[i] == null) {\n          continue;\n        } else if (args[i].equals(\"-count\")) {\n          count = Integer.parseInt(args[++i]);\n        } else if (args[i].equals(\"-nocreate\")) {\n          create = false;\n        } else if (args[i].equals(\"-nocheck\")) {\n          check = false;\n        } else if (args[i].equals(\"-compress\")) {\n          compress = args[++i];\n        } else {\n          // file is required parameter\n          file = args[i];\n          fpath = new Path(file);\n        }\n      }\n\n      fs = fpath.getFileSystem(conf);\n\n      LOG.info(\"count = \" + count);\n      LOG.info(\"create = \" + create);\n      LOG.info(\"check = \" + check);\n      LOG.info(\"compress = \" + compress);\n      LOG.info(\"file = \" + file);\n\n      RandomDatum[] data = generate(count);\n\n      if (create) {\n        writeTest(fs, data, file, CompressionType.valueOf(compress));\n      }\n\n      if (check) {\n        readTest(fs, data, file);\n      }\n\n    } finally {\n      fs.close();\n    }\n  }\n"}, {"dataset": "parseInt", "exampleID": 2800, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "val = integer.parseInt(s)", "focalAPIStart": 2348, "focalAPIEnd": 2375, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/funambol-mirror/funambol-client-sdk/tree/master/us8294/examples/jsync/src/com/funambol/jsync/JSync.java", "rawCode": "  private void parseArgs() {\n    int i = 0;\n    while (i < args.length) {\n      String arg = args[i];\n      if (arg.equals(\"--user\")) {\n        if (i + 1 < args.length) {\n          username = args[++i];\n        } else {\n          System.err.println(\"Missing username\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--pwd\")) {\n        if (i + 1 < args.length) {\n          password = args[++i];\n        } else {\n          System.err.println(\"Missing password\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--url\")) {\n        if (i + 1 < args.length) {\n          url = args[++i];\n        } else {\n          System.err.println(\"Missing url\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--log\")) {\n        if (i + 1 < args.length) {\n          parseLogLevel(args[++i]);\n        } else {\n          System.err.println(\"Missing log level\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--mode\")) {\n        if (i + 1 < args.length) {\n          parseSyncMode(args[++i]);\n        } else {\n          System.err.println(\"Missing sync mode\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--uri\")) {\n        if (i + 1 < args.length) {\n          remoteUri = args[++i];\n        } else {\n          System.err.println(\"Missing remote uri\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--raw\")) {\n        raw = true;\n      } else if (arg.equals(\"--type\")) {\n        if (i + 1 < args.length) {\n          sourceType = args[++i];\n        } else {\n          System.err.println(\"Missing type\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--encoding\")) {\n        if (i + 1 < args.length) {\n          sourceEncoding = args[++i];\n        } else {\n          System.err.println(\"Missing encoding\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--devid\")) {\n        if (i + 1 < args.length) {\n          customDeviceId = args[++i];\n        } else {\n          System.err.println(\"Missing device id\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--maxmsgsize\")) {\n        if (i + 1 < args.length) {\n          customMsgSize = Integer.parseInt(args[++i]);\n        } else {\n          System.err.println(\"Missing max msg size\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--md5\")) {\n        md5 = true;\n      } else if (arg.equals(\"--wbxml\")) {\n        wbxml = true;\n      } else if (arg.equals(\"--config\")) {\n        // Ignore the next param (file name)\n        ++i;\n      } else if (arg.equals(\"--dir\")) {\n        if (i + 1 < args.length) {\n          dir = args[++i];\n        } else {\n          System.err.println(\"Missing directory\");\n          usage();\n          System.exit(1);\n        }\n      } else if (arg.equals(\"--media\")) {\n        mediaEngine = true;\n      } else {\n        System.err.println(\"Invalid option: \" + arg);\n        usage();\n        System.exit(1);\n      }\n      ++i;\n    }\n\n    if (username == null || password == null || url == null) {\n      usage();\n      System.exit(2);\n    }\n  }\n"}]