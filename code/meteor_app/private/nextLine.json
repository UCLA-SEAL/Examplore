[{"dataset": "nextLine", "exampleID": 7101, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [99], "initializationEnd": [130], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 163, "guardExpressionEnd": 188, "guardBlockStart": 163, "guardBlockEnd": 257, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 231, "focalAPIEnd": 249, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["format(String,line)", "scanner.close()"], "useStart": [209, 263], "useEnd": [250, 278], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/software-engineering-amsterdam/sea-of-ql/tree/master/LE-Blythe/QLJava/src/org/uva/sea/ql/main/QLProgramBase.java", "rawCode": "  protected String readFile(String filename) throws FileNotFoundException {\n\n    Scanner scanner = new Scanner(new File(filename));\n    String contents = \"\";\n\n    while (scanner.hasNext()) {\n      contents += String.format(\"%s\\n\", scanner.nextLine());\n    }\n\n    scanner.close();\n    return contents;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7102, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [179], "initializationEnd": [215], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 223, "guardExpressionEnd": 252, "guardBlockStart": 223, "guardBlockEnd": 298, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 270, "focalAPIEnd": 288, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(line)"], "useStart": [263], "useEnd": [289], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/imr/Electric-VLSI/tree/master/electric/electric-core/src/main/java/com/sun/electric/tool/placement/forceDirected2/utils/output/GenerateCSV.java", "rawCode": "  public synchronized void appendToFile() throws IOException {\n\n    List<String> in = new ArrayList<String>();\n    if (new File(this.fileName).exists()) {\n      Scanner scanner = new Scanner(new File(this.fileName));\n      while (scanner.hasNextLine()) {\n        in.add(scanner.nextLine());\n      }\n    }\n\n    List<List<String>> out = new ArrayList<List<String>>();\n    for (String s : in) {\n      List<String> tmp = new ArrayList<String>();\n      tmp.add(s);\n      out.add(tmp);\n    }\n\n    out.addAll(this.data);\n\n    this.data = out;\n\n    this.writeToFile();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7103, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 71, "focalAPIEnd": 85, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jamie-bates-8/Mario-Kart-GL/tree/master/Mario-Kart-OpenGL-Demo/src/bates/jamie/graphics/io/Console.java", "rawCode": "  private void parseGenerate(Scanner cmd) {\n    scene.terrainCommand = cmd.nextLine();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7104, "initialization": ["Scanner scanner = new Scanner(*,String)"], "initializationStart": [140], "initializationEnd": [180], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 263, "guardExpressionEnd": 292, "guardBlockStart": 263, "guardBlockEnd": 367, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 323, "focalAPIEnd": 341, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.close()"], "useStart": [428], "useEnd": [443], "hasFinally": 1, "cleanUpCall": ["Scanner.close()"], "finallyExpressionStart": 412, "finallyExpressionEnd": 420, "finallyBlockStart": 412, "finallyBlockEnd": 450, "cleanUpCallStart": [428], "cleanUpCallEnd": [443], "url": "https://github.com/droolsjbpm/jbpm-designer/tree/master/jbpm-designer-backend/src/main/java/org/jbpm/designer/server/EditorHandler.java", "rawCode": "  private String readFile(String pathname) throws IOException {\n    StringBuilder fileContents = new StringBuilder();\n    Scanner scanner = new Scanner(new File(pathname), \"UTF-8\");\n    String lineSeparator = System.getProperty(\"line.separator\");\n    try {\n      while (scanner.hasNextLine()) {\n        fileContents.append(scanner.nextLine() + lineSeparator);\n      }\n      return fileContents.toString();\n    } finally {\n      scanner.close();\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7105, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [398], "initializationEnd": [447], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 369, "tryExpressionEnd": 373, "tryBlockStart": 369, "tryBlockEnd": 1005, "catchExpressionStart": 908, "catchExpressionEnd": 930, "catchBlockStart": 908, "catchBlockEnd": 1005, "exceptionHandlingCallStart": [938], "exceptionHandlingCallEnd": [979], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 455, "guardExpressionEnd": 483, "guardBlockStart": 455, "guardBlockEnd": 860, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 516, "focalAPIEnd": 533, "followUpCheck": "line[0].equals(username)", "checkType": "IF", "followUpCheckExpressionStart": 554, "followUpCheckExpressionEnd": 589, "followUpCheckBlockStart": 554, "followUpCheckBlockEnd": 852, "use": ["scanner.close()"], "useStart": [867], "useEnd": [881], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gforgues/JackGivesBack/tree/master/src/storage/BlackjackStorage.java", "rawCode": "  /**\n   * loadHand loads a player's hand from a gameID file\n   *\n   * @param username String of the playername to save\n   * @param gameID Integer representing the game to save\n   * @return A Hand object containing the cards associated with the player in the saved game\n   */\n  public static Hand loadHand(String username, int gameID) {\n    Hand hand = new Hand();\n    try {\n      Scanner reader = new Scanner(new File(\"saves/\" + gameID + \".csv\"));\n      while (reader.hasNextLine()) {\n        String[] parsedLine = reader.nextLine().split(\",\");\n        if (parsedLine[0].equals(username)) {\n          String[] cardsList = parsedLine[1].split(\":\");\n          for (String UnparsedCard : cardsList) {\n            String parsedCard[] = UnparsedCard.split(\" \");\n            hand.addCard(Card.fromString(parsedCard[0], parsedCard[2]));\n          }\n        }\n      }\n      reader.close();\n      return hand;\n    } catch (IOException e) {\n      System.out.println(\"Could not load hand\");\n      return hand;\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7106, "initialization": ["Scanner scanner = new Scanner(Readable)"], "initializationStart": [112], "initializationEnd": [131], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["scanner.findInLine(Pattern)"], "configurationStart": [336], "configurationEnd": [354], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 289, "guardExpressionEnd": 313, "guardBlockStart": 289, "guardBlockEnd": 687, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 579, "focalAPIEnd": 592, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.ioException()"], "useStart": [710], "useEnd": [726], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hoshino0318/JAVA_TRAINING/tree/master/JPL/ch22/ex22_07/ReadCSV.java", "rawCode": "  public static List<String[]> readCSVTable(Readable source, int cellNum) throws IOException {\n    Scanner in = new Scanner(source);\n    List<String[]> vals = new ArrayList<String[]>();\n    String exp = createCSVExp(cellNum);\n    Pattern pat = Pattern.compile(exp, Pattern.MULTILINE);\n    while (in.hasNextLine()) {\n      String line = in.findInLine(pat);\n      if (line != null) {\n        String[] cells = new String[cellNum];\n        MatchResult match = in.match();\n        for (int i = 0; i < cells.length; ++i) cells[i] = match.group(i + 1);\n        vals.add(cells);\n        in.nextLine(); // 改行を読み飛ばし\n      } else {\n        throw new IOException(\"input format error\");\n      }\n    }\n\n    IOException ex = in.ioException();\n    if (ex != null) throw ex;\n\n    return vals;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7107, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [145], "initializationEnd": [166], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 249, "guardExpressionEnd": 278, "guardBlockStart": 249, "guardBlockEnd": 353, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 309, "focalAPIEnd": 327, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.close()"], "useStart": [414], "useEnd": [429], "hasFinally": 1, "cleanUpCall": ["Scanner.close()"], "finallyExpressionStart": 398, "finallyExpressionEnd": 406, "finallyBlockStart": 398, "finallyBlockEnd": 436, "cleanUpCallStart": [414], "cleanUpCallEnd": [429], "url": "https://github.com/conxgit/conxlogistics-gerrit4/tree/master/com.conx.logistics.kernel/com.conx.logistics.kernel.bpm/jbpm/jbpm.core.mock/src/main/java/com/conx/logistics/kernel/bpm/impl/jbpm/core/mock/BPMGuvnorUtil.java", "rawCode": "  private String readFile(InputStream inStream) throws IOException {\n    StringBuilder fileContents = new StringBuilder();\n    Scanner scanner = new Scanner(inStream);\n    String lineSeparator = System.getProperty(\"line.separator\");\n    try {\n      while (scanner.hasNextLine()) {\n        fileContents.append(scanner.nextLine() + lineSeparator);\n      }\n      return fileContents.toString();\n    } finally {\n      scanner.close();\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7108, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 47, "guardExpressionEnd": 67, "guardBlockStart": 47, "guardBlockEnd": 906, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 90, "focalAPIEnd": 103, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["line.trim()"], "useStart": [129], "useEnd": [140], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AlexBarnes86/uva-java/tree/master/ProgrammingChallenges/src/chapter2/Problem10038.java", "rawCode": "  public static void main(String[] args) {\n    while (sc.hasNext()) {\n      String line = sc.nextLine();\n      String[] tokens = line.trim().split(\"\\\\s+\");\n\n      int n = Integer.parseInt(tokens[0]); // problem implies n > 0, could be trouble\n      boolean[] appear = new boolean[n - 1];\n\n      if (n == 1) {\n        System.out.println(\"Jolly\");\n        continue;\n      }\n\n      long prev = Long.parseLong(tokens[1]);\n      for (int i = 2; i < tokens.length; ++i) {\n        long val = Long.parseLong(tokens[i]);\n        long diff = Math.abs(val - prev);\n        if (diff < n && diff != 0) {\n          appear[(int) diff - 1] = true;\n        }\n        prev = val;\n      }\n\n      boolean jolly = true;\n      for (int i = 0; i < appear.length; ++i) {\n        if (appear[i] == false) {\n          jolly = false;\n          break;\n        }\n      }\n\n      System.out.println((jolly ? \"Jolly\" : \"Not jolly\"));\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7109, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 220, "focalAPIEnd": 237, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(String,line)", "scanner.nextLine()", "assertEquals(String,line)", "scanner.nextLine()", "assertEquals(String,line)", "scanner.nextLine()", "assertEquals(String,line)", "scanner.nextLine()", "assertEquals(String,line)", "scanner.nextLine()", "assertEquals(String,line)", "scanner.nextLine()", "assertEquals(String,line)", "scanner.nextLine()", "assertEquals(String,line)", "scanner.nextLine()", "assertEquals(String,line)"], "useStart": [243, 288, 311, 383, 406, 468, 491, 562, 585, 634, 657, 711, 734, 825, 848, 902, 925], "useEnd": [275, 305, 370, 400, 455, 485, 549, 579, 621, 651, 698, 728, 812, 842, 889, 919, 948], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tanelvir/pro-ada/tree/master/OhtuServletM/src/test/java/BibtexGeneratorTest.java", "rawCode": "  @Test\n  public void testAakkosetBibtex() throws FileNotFoundException, Exception {\n    ArrayList<String[]> pt = new ArrayList<String[]>();\n    pt.add(ääkkösetParametrit);\n    alustaTestejaVarten(pt);\n    String rivi = lukija.nextLine();\n    assertEquals(\"@book{124,\", rivi);\n    rivi = lukija.nextLine();\n    assertEquals(\"author = {Kalle P\\\\\\\"{a}\\\\\\\"{a}talo},\", rivi);\n    rivi = lukija.nextLine();\n    assertEquals(\"editor = {Kallekallekalle},\", rivi);\n    rivi = lukija.nextLine();\n    assertEquals(\"title = {H\\\\\\\"{o}ylin Miehen Syksy},\", rivi);\n    rivi = lukija.nextLine();\n    assertEquals(\"year = {1970},\", rivi);\n    rivi = lukija.nextLine();\n    assertEquals(\"publisher = {WSOY},\", rivi);\n    rivi = lukija.nextLine();\n    assertEquals(\"edition = {\\\\\\\"{A}mp\\\\\\\"{a}ri \\\\\\\"{O}ljy \\\\\\\"{a}iti :D},\", rivi);\n    rivi = lukija.nextLine();\n    assertEquals(\"month = {February},\", rivi);\n    rivi = lukija.nextLine();\n    assertEquals(\"}\", rivi);\n  }\n"}, {"dataset": "nextLine", "exampleID": 7110, "initialization": ["Scanner scanner = new Scanner(*,String)"], "initializationStart": [198], "initializationEnd": [251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 269, "guardExpressionEnd": 298, "guardBlockStart": 269, "guardBlockEnd": 360, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 321, "focalAPIEnd": 339, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(line)", "scanner.close()"], "useStart": [309, 383], "useEnd": [340, 398], "hasFinally": 1, "cleanUpCall": ["Scanner.close()"], "finallyExpressionStart": 367, "finallyExpressionEnd": 375, "finallyBlockStart": 367, "finallyBlockEnd": 405, "cleanUpCallStart": [383], "cleanUpCallEnd": [398], "url": "https://github.com/SynBioDex-archive/libSBOLj/tree/master/example/libSBOLjUseExample/FileUtil.java", "rawCode": "  static String readFile(String infilename) throws FileNotFoundException {\n\n    StringBuilder text = new StringBuilder();\n    String NL = System.getProperty(\"line.separator\");\n    Scanner scanner = new Scanner(new FileInputStream(infilename), \"UTF-8\");\n    try {\n      while (scanner.hasNextLine()) {\n        text.append(scanner.nextLine()).append(NL);\n      }\n    } finally {\n      scanner.close();\n    }\n    return text.toString();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7111, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [58], "initializationEnd": [80], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 176, "focalAPIEnd": 190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.nextLine()"], "useStart": [237], "useEnd": [251], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cielavenir/procon/tree/master/tyama_PKU2141.java", "rawCode": "  public static void main(String[] z) {\n    Scanner cin = new Scanner(System.in);\n    String enc = \"abcdefghijklmnopqrstuvwxyz\";\n    enc += enc.toUpperCase();\n    String dec = cin.nextLine();\n    dec += dec.toUpperCase();\n    char[] s = cin.nextLine().toCharArray();\n    int i = 0, j;\n    for (; i < s.length; i++) if ((j = enc.indexOf(s[i])) != -1) s[i] = dec.charAt(j);\n    System.out.print(s);\n  }\n"}, {"dataset": "nextLine", "exampleID": 7112, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 96, "focalAPIEnd": 114, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/OKullmann/CS-M41-Programming-in-Java/tree/master/Courseworks/201112/Two/StdIn.java", "rawCode": "  /** Return rest of line from standard input */\n  public static String readLine() {\n    return scanner.nextLine();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7113, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 100, "focalAPIEnd": 113, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["tokenizeToStringArray(line,String)"], "useStart": [65], "useEnd": [119], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lazyman/rapid-framework/tree/master/rapid-generator/rapid-generator/src/main/java/cn/org/rapid_framework/generator/ext/CommandLine.java", "rawCode": "  private static String[] nextArguments(Scanner sc) {\n    return StringHelper.tokenizeToStringArray(sc.nextLine(), \" \");\n  }\n"}, {"dataset": "nextLine", "exampleID": 7114, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [432], "initializationEnd": [487], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["new IllegalArgumentException(String)"], "tryExpressionStart": 403, "tryExpressionEnd": 407, "tryBlockStart": 403, "tryBlockEnd": 1814, "catchExpressionStart": 1707, "catchExpressionEnd": 1739, "catchBlockStart": 1707, "catchBlockEnd": 1814, "exceptionHandlingCallStart": [1753], "exceptionHandlingCallEnd": [1807], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 561, "focalAPIEnd": 578, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.close()"], "useStart": [1510], "useEnd": [1524], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gforgues/JackGivesBack/tree/master/src/storage/Storage.java", "rawCode": "  /**\n   * Loads a player's profile if its name and password are valid\n   *\n   * @param inputName - String of the user's name\n   * @param inputPassword - String of the user's password\n   * @return a Storage object containing a player's statistics\n   */\n  public static Statistics loadPlayer(String inputName, String inputPassword) {\n    inputName = inputName.toLowerCase();\n    String[] parsedLine;\n    try {\n      Scanner reader = new Scanner(new File(\"profiles/\" + inputName + \".csv\"));\n\n      // Split line from file into different fields\n      parsedLine = reader.nextLine().split(\",\");\n\n      // load variables from the parsed line\n      String password = parsedLine[0];\n      String realName = parsedLine[1];\n      int age = Integer.parseInt(parsedLine[2]);\n      int numChips = Integer.parseInt(parsedLine[3]);\n      int totalMoneyWon = Integer.parseInt(parsedLine[4]);\n      int maxWinStreak = Integer.parseInt(parsedLine[5]);\n      int maxChipsWinStreak = Integer.parseInt(parsedLine[6]);\n      int maxLossStreak = Integer.parseInt(parsedLine[7]);\n      int maxChipsLossStreak = Integer.parseInt(parsedLine[8]);\n\n      // Instantiate player with the loaded variables\n      Statistics loadedPlayer =\n          new Statistics(\n              inputName,\n              password,\n              realName,\n              age,\n              numChips,\n              totalMoneyWon,\n              maxWinStreak,\n              maxChipsWinStreak,\n              maxLossStreak,\n              maxChipsLossStreak);\n      reader.close();\n\n      if (loadedPlayer.validatePassword(inputPassword)) {\n        return loadedPlayer;\n      } else {\n        throw new IllegalArgumentException(\"Invalid password\");\n      }\n    } catch (FileNotFoundException e) {\n      throw new IllegalArgumentException(\"Player does not exist.\");\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7115, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [239], "initializationEnd": [282], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 307, "focalAPIEnd": 325, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertThat(line)", "assertThat(line)", "assertThat(line)", "assertThat(line)"], "useStart": [332, 395, 444, 494], "useEnd": [353, 416, 465, 515], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dandelion/dandelion-datatables/tree/master/datatables-core/src/test/java/com/github/dandelion/datatables/core/export/XmlExportTest.java", "rawCode": "  @Test\n  public void should_generate_full_table() {\n\n    initDefaultTable();\n    configureExport(new ExportConf.Builder(\"xml\").header(true).build());\n    processExport(new XmlExport());\n\n    // The header must exist\n    Scanner scanner = new Scanner(new String(baos.toByteArray()));\n    String firstLine = scanner.nextLine();\n\n    assertThat(firstLine).contains(\"<?xml version=\\\"1.0\\\"?>\");\n    assertThat(firstLine).contains(\"<persons>\");\n    assertThat(firstLine).contains(\"</persons>\");\n    assertThat(firstLine)\n        .contains(\n            \"<person id=\\\"1\\\" firstName=\\\"Selma\\\" lastName=\\\"Maldonado\\\" city=\\\"\\\" mail=\\\"venenatis@Duisvolutpat.com\\\"></person><person id=\\\"2\\\" firstName=\\\"Vanna\\\" lastName=\\\"Salas\\\" city=\\\"Denny\\\" mail=\\\"bibendum.fermentum.metus@ante.ca\\\"></person>\");\n  }\n"}, {"dataset": "nextLine", "exampleID": 7116, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 156, "focalAPIEnd": 172, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["DataOutputStream.writeUTF(line)"], "useStart": [247], "useEnd": [263], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bj0rn/Gruppe34/tree/master/Code/src/no/ntnu/fp/net/network/TestCommunicationClient.java", "rawCode": "  @Override\n  public void run() {\n    // TODO Auto-generated method stub\n    while (true) {\n      System.out.println(\"Enter message: \");\n      String msg = input.nextLine();\n      System.out.println(\"Message entered: \" + msg);\n      try {\n        os.writeUTF(msg);\n      } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n      }\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7117, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 342, "focalAPIEnd": 355, "followUpCheck": "line.equalsIgnoreCase(attack.getTitle())", "checkType": "IF", "followUpCheckExpressionStart": 458, "followUpCheckExpressionEnd": 565, "followUpCheckBlockStart": 458, "followUpCheckBlockEnd": 608, "use": ["line.toLowerCase()", "makeAttack(line)"], "useStart": [373, 578], "useEnd": [394, 597], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Linok75/Hackers/tree/master/src/model/Game.java", "rawCode": "  public void play() {\n    this.PLAY = true;\n\n    System.out.println(\"Début de la partie !\");\n    System.out.println(\n        \"\\n**************** MAP ****************\\n\"\n            + this.level.getMap()\n            + \"************************************\\n\");\n\n    // Test Console\n    String request;\n    while (this.PLAY) {\n      request = sc.nextLine();\n      request = request.toLowerCase();\n\n      for (Attack attack : player.getAttackList()) {\n        if (!attack.getTitle().equalsIgnoreCase(\"ddos\")\n            && request.equalsIgnoreCase(attack.getTitle())) {\n          makeAttack(request);\n        }\n      }\n\n      if (request.equals(\"player\")) {\n        System.out.println(\n            \"\\n**************** PLAYER ****************\\n\"\n                + this.player\n                + \"************************************\\n\");\n\n      } else if (request.equals(\"level\")) {\n        System.out.println(\n            \"\\n**************** LEVEL ****************\\n\"\n                + this.level\n                + \"************************************\\n\");\n\n      } else if (request.equals(\"map\")) {\n        System.out.println(\n            \"\\n**************** MAP ****************\\n\"\n                + this.level.getMap()\n                + \"************************************\\n\");\n        /*\n         * } else if (request.equals(\"phishing\")) {\n         * makeAttack(\"Phishing\"); } else if (request.equals(\"virus\")) {\n         * makeAttack(\"Virus\");\n         */ } else if (request.equals(\"ddos\")) {\n        try {\n          player.ddos(this.level.getMap().countAllNodesHack(), (Target) this.level.getTarget());\n\n          if (this.level.getTarget().isHack()) { // TODO\n            System.out.println(\"Mission Accomplie !\");\n\n            // Vous avez terminé le jeu ...\n            // Crédits ... (lol)\n            // Retour au menu principal\n            // Il peut toujours charger sa partie, mais cette fois ci, avoir accès au niveau qu'il\n            // désire\n\n            // System.exit(0);\n          } else {\n            System.out.println(\n                \"L'attaque DDoS n'a pas été suffisante pour faire tomber le serveur ...\");\n          }\n          // System.out.println(\"DDoS OK !\");\n        } catch (NoSuffisantPA ex) {\n          System.out.println(\"DDoS KO !\");\n          // Logger.getLogger(Game.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n      } else if (request.equals(\"help\")) {\n        printCommands();\n      } else if (request.equals(\"exit\")) {\n        System.exit(0);\n      } else {\n        System.out.println(\n            \"Commande introuvable ... (taper 'help' pour afficher la liste des commandes)\");\n      }\n\n      // Ne pas mettre 10 en dur : TODO\n      if (this.player.getPower() < 10) {\n        System.out.println(\n            \"Vous ne disposez plus de suffisament de 'ressources' pour continuer :\\n\\n\\tGAME OVER\");\n\n        // Recommencer le niveau\n        // Retour au menu\n\n        System.exit(0);\n      }\n\n      if (this.level.completed()) {\n        System.out.println(\"Bravo ! Vous avez réussi le niveau\");\n        this.PLAY = false;\n        // System.exit(0);\n      }\n    }\n\n    // System.out.println(\"**************** END OF GAME ****************\");\n\n  }\n"}, {"dataset": "nextLine", "exampleID": 7118, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 449, "guardExpressionEnd": 478, "guardBlockStart": 449, "guardBlockEnd": 2225, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 549, "focalAPIEnd": 567, "followUpCheck": "line != null && !line.isEmpty()", "checkType": "IF", "followUpCheckExpressionStart": 577, "followUpCheckExpressionEnd": 613, "followUpCheckBlockStart": 577, "followUpCheckBlockEnd": 2217, "use": ["line.split(String,int)"], "useStart": [667], "useEnd": [685], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MrColeC/Truss/tree/master/src/Main/JobManagement.java", "rawCode": "  /**\n   * Reads a list of jobs (one per line) from a file\n   *\n   * @param filepath\n   * @throws IOException\n   */\n  public int Load(String filepath) throws IOException {\n    // Setup\n    int AddedCounter = 0;\n    boolean LoadJob = true;\n\n    // Open the file and parse it\n    Path path = Paths.get(filepath);\n    try (Scanner scanner = new Scanner(path, ENCODING.name())) {\n      System.out.printf(\"%8s|%6s|%-50s%n\", \"OS\", \"SecLev\", \"Job\");\n      while (scanner.hasNextLine()) {\n        // Read each line into the array list\n        String line = scanner.nextLine();\n        if (line != null && !line.isEmpty()) {\n          // Parse line\n          String[] parse = line.split(\" \", 3);\n\n          // Validate OS\n          String parsedOS = parse[0];\n          if (!((parsedOS.equalsIgnoreCase(\"any\"))\n              || (parsedOS.equalsIgnoreCase(\"windows\"))\n              || (parsedOS.equalsIgnoreCase(\"linux\")))) {\n            // If the OS is NOT \"any\", \"windows\" or \"linux\"...\n            System.out.println(\n                \"\\tOS improperly defined (needs to be \\\"any\\\", \\\"windows\\\" or \\\"linux\\\" (\"\n                    + line\n                    + \")\");\n            LoadJob = false;\n          }\n\n          // Validate SecLev\n          int parsedSecLev = -1;\n          try {\n            parsedSecLev = Integer.parseInt(parse[1]);\n          } catch (NumberFormatException e) {\n            // Do not display a stack trace\n          }\n          if (parsedSecLev < 0) {\n            System.out.println(\"\\tSecurity level improperly formated (\" + line + \")\");\n            LoadJob = false;\n          }\n\n          // Validate the job\n          String parsedJob = parse[2];\n          if (parsedJob.length() <= 0) {\n            System.out.println(\"\\tNo job was provided (\" + line + \")\");\n            LoadJob = false;\n          }\n\n          if (LoadJob) {\n            // Display\n            System.out.printf(\"%8s|%6s|%-50s%n\", parsedOS, parsedSecLev, parsedJob);\n\n            // Load\n            Jobs jobUnit = new Jobs(parsedJob, parsedOS, parsedSecLev);\n            jobqueue.add(jobUnit);\n            AddedCounter++;\n          } else {\n            // Reset for the next line\n            LoadJob = true;\n          }\n        }\n      }\n    }\n    return AddedCounter;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7119, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 169, "focalAPIEnd": 186, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(line)"], "useStart": [152], "useEnd": [187], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NeoLehtola/Tiralabra/tree/master/Tiralabra/src/kayttoliittyma/Tekstikayttoliittyma.java", "rawCode": "  private int kysyLeveys() {\n    System.out.print(\n        \"Anna siirrettävän leveys: (0 - \" + (peli.getPelilauta().getLeveys() - 1) + \")\");\n    return Integer.parseInt(lukija.nextLine());\n  }\n"}, {"dataset": "nextLine", "exampleID": 7120, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["scanner.next()", "scanner.next()", "scanner.nextInt()"], "configurationStart": [65, 101, 129], "configurationEnd": [76, 112, 143], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 149, "focalAPIEnd": 164, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/baronfel/Emulator/tree/master/src/utility/InstructionParser.java", "rawCode": "  private static void ADDIUInstruction() {\n    int rd = getValue(file.next());\n    int rs = getValue(file.next());\n    int imm = file.nextInt();\n    file.nextLine();\n    String opc = \"ADDIU\";\n    // if(imm < 0)\n    // invalid instruction\n    ilist.add((IInstruction) new ITypeInstruction(opc, rd, rs, imm, lineCounter));\n  }\n"}, {"dataset": "nextLine", "exampleID": 7121, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [142], "initializationEnd": [164], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 358, "focalAPIEnd": 376, "followUpCheck": "0 != line.trim().indexOf(\"quit\")", "checkType": "LOOP {", "followUpCheckExpressionStart": 383, "followUpCheckExpressionEnd": 424, "followUpCheckBlockStart": 383, "followUpCheckBlockEnd": 566, "use": ["UserInterface.addInput(line)", "scanner.nextLine()"], "useStart": [433, 541], "useEnd": [451, 559], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ajh17/PintoSim/tree/master/src/pintosim/PintoSim.java", "rawCode": "  public static void showCommandLineInterface(Properties props) throws Exception {\n    UserInterface ui = build(props);\n    Scanner scanner = new Scanner(System.in);\n    String input = null;\n    System.out.print(\"Welcome to the 'My Friendly Pintos' assistive Robot system!\\n\");\n    System.out.print(\"Enter a command, type help, or type quit: \");\n    input = scanner.nextLine();\n\n    while (0 != input.trim().indexOf(\"quit\")) {\n      ui.addInput(input);\n      System.out.print(\"\\n\\nEnter a command, type help, or type quit: \");\n      input = scanner.nextLine();\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7122, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [307], "initializationEnd": [329], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 335, "focalAPIEnd": 348, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ajorgesantosp/EAPLI_PL_2DB/tree/master/eapli.expensemanager/src/Presentation/ExpensesUI.java", "rawCode": "  public void lastMonthExpensesLoop() {\n\n    List<Expense> l = ec.getLastMonthExpenses();\n\n    System.out.println(\"* * * Show Last Month Expense * * *\\n\");\n\n    for (int i = 0; i < l.size(); i++) {\n      l.get(i).expenseToString();\n    }\n    System.out.println(\"Press Enter to continue.\");\n    Scanner sc = new Scanner(System.in);\n    sc.nextLine();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7123, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [1746], "initializationEnd": [1801], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 1809, "guardExpressionEnd": 1845, "guardBlockStart": 1809, "guardBlockEnd": 2703, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 1876, "focalAPIEnd": 1901, "followUpCheck": "line.isEmpty()", "checkType": "IF", "followUpCheckExpressionStart": 1911, "followUpCheckExpressionEnd": 1930, "followUpCheckBlockStart": 1911, "followUpCheckBlockEnd": 2682, "use": ["log(*,String,line)", "PrintWriter.println(line)", "scanner.close()"], "useStart": [2096, 2275, 2710], "useEnd": [2171, 2292, 2732], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zenjiro/gdd11jp/tree/master/com/wordpress/zenjiro/slidingpuzzle/Check.java", "rawCode": "  /**\n   * メインメソッド\n   *\n   * @param args コマンドラン引数\n   * @throws FileNotFoundException ファイル未検出例外\n   */\n  public static void main(final String[] args) throws FileNotFoundException {\n    final String inputFile = \"merged.txt\";\n    final String outputFile = \"checked.txt\";\n    final int pathLimit = 215000;\n    final List<Board> problems = new ArrayList<Board>();\n    final int[][] counts = new int[7][7];\n    final Scanner problemsScanner = new Scanner(Check.class.getResourceAsStream(\"problems.txt\"));\n    problemsScanner.useDelimiter(\"[\\\\s,]\");\n    final int lx = problemsScanner.nextInt();\n    final int rx = problemsScanner.nextInt();\n    final int ux = problemsScanner.nextInt();\n    final int dx = problemsScanner.nextInt();\n    final int n = problemsScanner.nextInt();\n    Logger.getLogger(Check.class.getName())\n        .log(\n            Level.INFO,\n            \"lx = {0}, rx = {1}, ux = {2}, dx = {3}, n = {4}\",\n            new Integer[] {lx, rx, ux, dx, n});\n    while (problemsScanner.hasNext()) {\n      final int w = problemsScanner.nextInt();\n      final int h = problemsScanner.nextInt();\n      final String b = problemsScanner.next();\n      final Board board = new Board(w, h, b);\n      Logger.getLogger(Check.class.getName()).log(Level.INFO, \"board = {0}\", board);\n      problems.add(board);\n      counts[h][w]++;\n    }\n    problemsScanner.close();\n    int ok = 0;\n    int failed = 0;\n    int skipped = 0;\n    int cut = 0;\n    int l = 0;\n    int r = 0;\n    int u = 0;\n    int d = 0;\n    final int[][] oks = new int[7][7];\n    {\n      final PrintWriter out =\n          new PrintWriter(\n              SlidingPuzzle.class.getPackage().getName().replace(\".\", \"/\") + \"/\" + outputFile);\n      int i = 0;\n      final Scanner resultsScanner = new Scanner(Check.class.getResourceAsStream(inputFile));\n      while (resultsScanner.hasNextLine()) {\n        final String path = resultsScanner.nextLine();\n        if (path.isEmpty()) {\n          out.println();\n          skipped++;\n        } else if (path.length() > pathLimit) {\n          out.println();\n          cut++;\n        } else {\n          Logger.getLogger(Check.class.getName()).log(Level.INFO, \"path = {0}\", path);\n          if (Util.isOk(path, problems.get(i).w, problems.get(i).h, problems.get(i).b)) {\n            out.println(path);\n            ok++;\n            oks[problems.get(i).h][problems.get(i).w]++;\n            l += path.replaceAll(\"[^L]+\", \"\").length();\n            r += path.replaceAll(\"[^R]+\", \"\").length();\n            u += path.replaceAll(\"[^U]+\", \"\").length();\n            d += path.replaceAll(\"[^D]+\", \"\").length();\n          } else {\n            out.println();\n            failed++;\n          }\n        }\n        i++;\n      }\n      resultsScanner.close();\n      out.close();\n    }\n    System.out.printf(\n        \"ok : failed : skipped : cut = %d : %d : %d : %d = %.1f%% : %.1f%% : %.1f%% : %.1f%%\\n\",\n        ok,\n        failed,\n        skipped,\n        cut,\n        ok / 5000.0 * 100,\n        failed / 5000.0 * 100,\n        skipped / 5000.0 * 100,\n        cut / 5000.0);\n    System.out.printf(\n        \"解答：%d/%d（%.1f%%）L：%d/%d（%.1f%%）R：%d/%d（%.1f%%）U：%d/%d（%.1f%%）D：%d/%d（%.1f%%）\\n\",\n        ok,\n        n,\n        (double) ok / n * 100,\n        l,\n        lx,\n        (double) l / lx * 100,\n        r,\n        rx,\n        (double) r / rx * 100,\n        u,\n        ux,\n        (double) u / ux * 100,\n        d,\n        dx,\n        (double) d / dx * 100);\n    System.out.println(\"h, w\\t3\\t\\t4\\t\\t5\\t\\t6\");\n    for (int i = 3; i < 7; i++) {\n      System.out.print(i);\n      for (int j = 3; j < 7; j++) {\n        System.out.printf(\"\\t%d/%d\", oks[i][j], counts[i][j]);\n      }\n      System.out.println();\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7124, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 391, "focalAPIEnd": 436, "followUpCheck": "mManager.checkUserNameAndPassword(MemberID,line) == true", "checkType": "IF", "followUpCheckExpressionStart": 1245, "followUpCheckExpressionEnd": 1311, "followUpCheckBlockStart": 1245, "followUpCheckBlockEnd": 1693, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Chrisbh/Tie-Break/tree/master/Tie-Break/src/GUI/Login.java", "rawCode": "  /** Checks whether the entered username and password matches with a user in the database */\n  public void LoginCheck() {\n    if (txtMemberNr.getText().length() != 0 && txtPassword.getText().length() != 0) {\n      Scanner MemberNrSC = new Scanner(txtMemberNr.getText());\n      checkInt(MemberNrSC);\n      int MemberID = new Scanner(txtMemberNr.getText()).nextInt();\n      String Password = new Scanner(txtPassword.getText()).nextLine();\n\n      if (!MemberNrCancelled) {\n        MemberNrSC = new Scanner(txtMemberNr.getText());\n        int lengthMember = String.valueOf(MemberNrSC.nextInt()).length();\n        while (lengthMember < 1) {\n          String correctedMemberNr =\n              JOptionPane.showInputDialog(null, \"Medlemsnummer skal være tal og minimum ét tal\");\n          if (correctedMemberNr == null) {\n            MemberNrCancelled = true;\n            break;\n          }\n          txtMemberNr.setText(correctedMemberNr);\n\n          MemberNrSC = new Scanner(txtMemberNr.getText());\n          checkInt(MemberNrSC);\n          MemberNrSC = new Scanner(txtMemberNr.getText());\n          lengthMember = String.valueOf(MemberNrSC.nextInt()).length();\n        }\n      } else {\n        MemberNrCancelled = false;\n      }\n      try {\n        if (mManager.checkUserNameAndPassword(MemberID, Password) == true) {\n          MainMenu.getInstance().setVisible(true);\n          this.setVisible(false);\n          MemberManager.getInstance().setLoggedIn(MemberID);\n        } else {\n          JOptionPane.showMessageDialog(\n              null,\n              \"Indtastede medlemdsoplysninger er forkerte, prøv igen!\",\n              \"Advarsel\",\n              JOptionPane.INFORMATION_MESSAGE);\n        }\n      } catch (Exception ex) {\n        System.out.println(\"ERROR\" + ex);\n      }\n    } else {\n      JOptionPane.showMessageDialog(\n          null, \"Alle felter skal udfyldes!\", \"Advarsel\", JOptionPane.INFORMATION_MESSAGE);\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7125, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [60], "initializationEnd": [82], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["scanner.nextInt()"], "configurationStart": [96], "configurationEnd": [108], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 114, "focalAPIEnd": 127, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.nextLine()", "scanner.nextLine()", "getDistance(line,*)"], "useStart": [221, 236, 209], "useEnd": [234, 249, 250], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ferhatelmas/algo/tree/master/eolimp/page11/q1080/Main.java", "rawCode": "  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    in.nextLine();\n    for (int i = 0; i < n; )\n      System.out.println(\"Case #\" + (++i) + \": \" + getDistance(in.nextLine(), in.nextLine()));\n  }\n"}, {"dataset": "nextLine", "exampleID": 7126, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [1146], "initializationEnd": [1161], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 104, "tryExpressionEnd": 108, "tryBlockStart": 104, "tryBlockEnd": 2042, "catchExpressionStart": 1979, "catchExpressionEnd": 2001, "catchBlockStart": 1979, "catchBlockEnd": 2042, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 1171, "guardExpressionEnd": 1195, "guardBlockStart": 1171, "guardBlockEnd": 1950, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 1219, "focalAPIEnd": 1232, "followUpCheck": "line.startsWith(\"<div class='lyricbox'\")", "checkType": "IF", "followUpCheckExpressionStart": 1244, "followUpCheckExpressionEnd": 1286, "followUpCheckBlockStart": 1244, "followUpCheckBlockEnd": 1940, "use": ["line.lastIndexOf(String)", "line.substring(int)", "line.replaceAll(String,String)", "line.replaceAll(String,String)", "matcher(line)", "scanner.close()"], "useStart": [1313, 1387, 1423, 1469, 1529, 1959], "useEnd": [1336, 1405, 1451, 1503, 1568, 1969], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tulskiy/musique/tree/master/musique-core/src/main/java/com/tulskiy/musique/gui/LyricsPanel.java", "rawCode": "    private void searchLyrics(String artist, String title, StringBuilder sb) throws IOException {\n      try {\n        // String search = \"http://lyrics.wikia.com/Special:Search?search=\";\n        // search += URLEncoder.encode(artist, \"utf-8\");\n        // search += \"+\";\n        // search += URLEncoder.encode(title, \"utf-8\");\n        //\n        // URL searchURL = new URL(search);\n        // Scanner scan = new Scanner(searchURL.openStream());\n        // StringBuilder content = new StringBuilder();\n        // while (scan.hasNextLine())\n        // content.append(scan.nextLine());\n        //\n        // Matcher matcher =\n        // Pattern.compile(\"http://lyrics.wikia.com/wiki/[^\\\"]*\").matcher(content);\n        // if (!matcher.find()) {\n        // return;\n        // }\n        String search = \"http://lyrics.wikia.com/\";\n        artist = Util.capitalize(artist, \"_\");\n        title = Util.capitalize(title, \"_\");\n        search += URLEncoder.encode(artist, \"utf-8\");\n        search += \":\";\n        search += URLEncoder.encode(title, \"utf-8\");\n\n        URL url = new URL(search);\n        InputStream is = url.openStream();\n        Scanner fi = new Scanner(is);\n        while (fi.hasNextLine()) {\n          String s = fi.nextLine();\n          if (s.startsWith(\"<div class='lyricbox'\")) {\n            int index = s.lastIndexOf(\"</div>\");\n            if (index > 0 && s.length() > 6) s = s.substring(index);\n            s = s.replaceAll(\"<br />\", \"\\n\");\n            s = s.replaceAll(\"(<!--)|(<.*?>)\", \"\");\n            Matcher m = Pattern.compile(\"&#(\\\\d+);\").matcher(s);\n            m.reset();\n            StringBuffer buffer = new StringBuffer();\n            while (m.find()) {\n              String group = m.group(1);\n              char ch = (char) Integer.valueOf(group).shortValue();\n              m.appendReplacement(buffer, String.valueOf(ch));\n            }\n            m.appendTail(buffer);\n            sb.append(buffer);\n          }\n        }\n        fi.close();\n      } catch (IOException e) {\n        // e.printStackTrace();\n      }\n    }\n"}, {"dataset": "nextLine", "exampleID": 7127, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [65], "initializationEnd": [87], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 104, "focalAPIEnd": 122, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["suffixes(line)"], "useStart": [143], "useEnd": [154], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kframework/java-semantics/tree/master/external-programs/javaprecisely_2002/Example33.java/Example33.java", "rawCode": "  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String s = scanner.nextLine();\n    Iterator seq = suffixes(s);\n    while (seq.hasNext()) System.out.println(seq.next());\n  }\n"}, {"dataset": "nextLine", "exampleID": 7128, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [160], "initializationEnd": [179], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 198, "guardExpressionEnd": 227, "guardBlockStart": 198, "guardBlockEnd": 366, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 252, "focalAPIEnd": 270, "followUpCheck": "line.equals(\"EOF\") || line.trim().startsWith(\"NODE_COORD_SECTION\")", "checkType": "IF", "followUpCheckExpressionStart": 280, "followUpCheckExpressionEnd": 351, "followUpCheckBlockStart": 280, "followUpCheckBlockEnd": 358, "use": ["scanner.nextLine()", "readLine(line)", "scanner.close()"], "useStart": [428, 515, 696], "useEnd": [446, 529, 711], "hasFinally": 1, "cleanUpCall": ["Scanner.close()"], "finallyExpressionStart": 625, "finallyExpressionEnd": 633, "finallyBlockStart": 625, "finallyBlockEnd": 718, "cleanUpCallStart": [696], "cleanUpCallEnd": [711], "url": "https://github.com/seage/seage/tree/master/seage-problems/discrete/tsp/src/main/java/org/seage/problem/tsp/CityProvider.java", "rawCode": "  public static synchronized City[] readCities(InputStream stream) throws Exception {\n    ArrayList<City> result = new ArrayList<City>();\n    Scanner scanner = new Scanner(stream);\n    try {\n\n      while (scanner.hasNextLine()) {\n        String line = scanner.nextLine();\n        if (line.equals(\"EOF\") || line.trim().startsWith(\"NODE_COORD_SECTION\")) break;\n      }\n\n      while (scanner.hasNextLine()) {\n        String line = scanner.nextLine();\n        if (line.equals(\"EOF\")) break;\n        Double[] dataLine = readLine(line);\n        result.add(new City(dataLine[0].intValue(), dataLine[1], dataLine[2]));\n      }\n    } finally {\n      // ensure the underlying stream is always closed\n      scanner.close();\n    }\n    return result.toArray(new City[0]);\n  }\n"}, {"dataset": "nextLine", "exampleID": 7129, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [308], "initializationEnd": [330], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 408, "focalAPIEnd": 421, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.nextLine()", "send(line,String)", "scanner.nextLine()", "scanner.nextLine()", "scanner.nextLine()", "scanner.next()", "scanner.nextInt()", "scanner.next()"], "useStart": [497, 519, 995, 1679, 2509, 2586, 3012, 3088], "useEnd": [510, 543, 1008, 1692, 2522, 2595, 3024, 3097], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Projektgrupp3/projekt.java/tree/master/projekt.java/src/tddd36/grupp3/server/CommandThread.java", "rawCode": "  /**\n   * Undersöker vad det är för kommando som matats in\n   *\n   * @param input - det angivna kommandot\n   * @throws UnknownHostException\n   * @throws JSONException\n   */\n  public void evalutate(String input) throws UnknownHostException, JSONException {\n    if (input.equals(\"/msg\")) {\n      Scanner in = new Scanner(System.in);\n      System.out.println(\"Message?\");\n      String message;\n      message = in.nextLine();\n\n      System.out.println(\"Till vilket ip?\");\n      String ip;\n      ip = in.nextLine();\n\n      Sender.send(message, ip);\n    }\n\n    if (input.equals(\"/createuser\")) {\n      User u = new User();\n      u.createUser();\n      MySQLDatabase.addUser(u);\n    }\n    if (input.equals(\"/createunit\")) {\n      Unit u = new Unit();\n      MySQLDatabase.addUnit(u);\n    }\n    if (input.equals(\"/createevent\")) {\n      Event a = new Event();\n      a.createTestEvent();\n\n      Scanner in = new Scanner(System.in);\n      System.out.println(\"Till vilket ip?\");\n      String ip;\n      ip = in.nextLine();\n\n      String unitID = MySQLDatabase.getUsersUnit(Association.getUser(ip));\n      a.setUnitID(unitID);\n\n      // MySQLDatabase.addAlarm(a); L�gg in alarm i Databas\n      // Sender.broadcastEvent(a,ip);\n\n      Sender.send(a.getJSON(), ip);\n      Sender.broadcastEvent(a, ip);\n      // Runnable EventTimerRunnable = new EventTimer(CommandThread.this);\n      // Thread t = new Thread(EventTimerRunnable);\n      // t.start();\n\n      MySQLDatabase.setEvent(a);\n    }\n    if (input.equals(\"/sendevent\")) {\n      Event e = new Event();\n      e.createEvent();\n\n      Scanner in = new Scanner(System.in);\n      System.out.println(\"Till vilket ip?\");\n      String ip;\n      ip = in.nextLine();\n\n      String unitID = MySQLDatabase.getUsersUnit(Association.getUser(ip));\n      e.setUnitID(unitID);\n\n      // MySQLDatabase.addAlarm(a); Lägg in alarm i Databas\n      Sender.send(e.getJSON(), ip);\n      Sender.broadcastEvent(e, ip);\n\n      // Runnable EventTimerRunnable = new EventTimer(CommandThread.this);\n      // Thread t = new Thread(EventTimerRunnable);\n      // t.start();\n      MySQLDatabase.setEvent(e);\n    }\n    if (input.equals(\"/print\")) {\n      System.out.println(MySQLDatabase.printAllUsers());\n      System.out.println(MySQLDatabase.printAllUnits());\n      // MySQLDatabase.printAllAlarms();\n    }\n    if (input.equals(\"/mapuserunit\")) {\n      Scanner in = new Scanner(System.in);\n      String name;\n      String unitId;\n\n      do {\n        System.out.println(\"username to map\");\n        name = in.nextLine();\n        System.out.println(\"unitId to map\");\n        unitId = in.next();\n      } while (!(MySQLDatabase.checkUser(name)) && !(MySQLDatabase.checkUnit(unitId)));\n\n      User user = MySQLDatabase.getUser(name);\n      user.setUnitID(unitId);\n      System.out.println(\"map completed\");\n    }\n    if (input.equals(\"/mapalarmunit\")) {\n      Scanner in = new Scanner(System.in);\n      int alarmId;\n      String unitId;\n\n      do {\n        System.out.println(\"alarmId to map\");\n        alarmId = in.nextInt();\n        System.out.println(\"unitId to map\");\n        unitId = in.next();\n      } while (!(MySQLDatabase.checkAlarm(alarmId)) && !(MySQLDatabase.checkUnit(unitId)));\n\n      Event alarm = MySQLDatabase.getAlarm(alarmId);\n      alarm.setUnitID(unitId);\n      System.out.println(\"map completed\");\n    }\n    if (input.equals(\"/sendcontacts\")) {\n      ArrayList<Contact> hej = MySQLDatabase.getAllContacts();\n      HashMap<String, String> testing = Association.getUserIpAssociations();\n\n      Object[] users;\n      Object[] userip;\n\n      users = testing.keySet().toArray();\n      userip = testing.values().toArray();\n\n      for (int i = 0; i < users.length; i++) {\n        Sender.sendContacts(hej, userip[i].toString());\n      }\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7130, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 109, "focalAPIEnd": 124, "followUpCheck": "line.length != 3", "checkType": "IF", "followUpCheckExpressionStart": 141, "followUpCheckExpressionEnd": 162, "followUpCheckBlockStart": 141, "followUpCheckBlockEnd": 286, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/greneholt/csci306clue/tree/master/src/clueGame/Board.java", "rawCode": "  private void loadPlayer(Player player, Scanner scan) throws BadConfigFormatException {\n    String[] line = scan.nextLine().split(\",\");\n    if (line.length != 3) {\n      throw new BadConfigFormatException(\n          \"Wrong number of values in line \" + line + \" of players file\");\n    }\n    player.setName(line[0]);\n    player.setPieceColor(Color.decode(line[1]));\n    player.setCellIndex(Integer.parseInt(line[2]));\n  }\n"}, {"dataset": "nextLine", "exampleID": 7131, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [236], "initializationEnd": [251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 257, "guardExpressionEnd": 279, "guardBlockStart": 257, "guardBlockEnd": 344, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 298, "focalAPIEnd": 313, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(line)", "scanner.close()"], "useStart": [288, 349], "useEnd": [314, 361], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/drmercer/Schooner-3D/tree/master/Schooner 3D/src/com/supermercerbros/gameengine/render/Compositor.java", "rawCode": "  /** @return The vertex shader source */\n  protected String getVertexShader() {\n    StringBuilder sb = new StringBuilder();\n\n    InputStream in = Compositor.class.getResourceAsStream(\"compositor_vertex_shader.txt\");\n    Scanner scan = new Scanner(in);\n    while (scan.hasNext()) {\n      sb.append(scan.nextLine());\n      sb.append(\"\\n\");\n    }\n    scan.close();\n\n    return sb.toString();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7132, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 309, "focalAPIEnd": 331, "followUpCheck": "line.equals(\"quit\")", "checkType": "IF", "followUpCheckExpressionStart": 365, "followUpCheckExpressionEnd": 393, "followUpCheckBlockStart": 365, "followUpCheckBlockEnd": 503, "use": ["scanner.close()", "new File(line)"], "useStart": [456, 520], "useEnd": [475, 538], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ErikaNana/ICS-311/tree/master/Project 1/src/UserDriver.java", "rawCode": "  /**\n   * Reads in the file and generates the input array and the array of random values.\n   *\n   * @return The status of the driver\n   */\n  public static String loadFile() {\n    String fileName;\n    System.out.println(PURPLE + \"\\nPlease type in file name to read, or quit to exit:\" + RESET);\n    fileName = inputReader.nextLine();\n    // check if file exists\n    if (fileName.equals(\"quit\")) {\n      System.out.println(GREEN + \"Goodbye!\" + RESET);\n      inputReader.close();\n      return \"quit\";\n    }\n    File file = new File(fileName);\n    int index = 0;\n    try {\n      // create an array based on the file name\n      if (fileName.matches(\".*100\\\\.txt\")) {\n        size = 100;\n        array = new String[100];\n      } else if (fileName.matches(\".*1000\\\\.txt\")) {\n        size = 1000;\n        array = new String[1000];\n      } else if (fileName.matches(\".*10000\\\\.txt\")) {\n        size = 10000;\n        array = new String[10000];\n      } else if (fileName.matches(\".*100000\\\\.txt\")) {\n        size = 100000;\n        array = new String[100000];\n      } else if (fileName.matches(\".*1000000\\\\.txt\")) {\n        size = 1000000;\n        array = new String[1000000];\n      }\n\n      BufferedReader br = new BufferedReader(new FileReader(file));\n\n      // read file in line by line\n      Scanner fileReader = new Scanner(br);\n      fileReader.useDelimiter(\"(\\n)\");\n\n      while (fileReader.hasNext()) {\n        array[index] = fileReader.next();\n        index++;\n      }\n      fileReader.close();\n      // generate an array of random strings\n      for (int i = 0; i < 10; i++) {\n        int random = new Random().nextInt(array.length);\n        randomValues[i] = array[random];\n      }\n      return \"continue\";\n    } catch (FileNotFoundException e) {\n      System.out.println(RED + \"File not found. Please try again.\");\n      return \"error\";\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7133, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [234], "initializationEnd": [268], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 332, "guardExpressionEnd": 361, "guardBlockStart": 332, "guardBlockEnd": 549, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 384, "focalAPIEnd": 402, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["processLine(line)", "scanner.close()"], "useStart": [372, 767], "useEnd": [403, 782], "hasFinally": 1, "cleanUpCall": ["Scanner.close()"], "finallyExpressionStart": 556, "finallyExpressionEnd": 564, "finallyBlockStart": 556, "finallyBlockEnd": 789, "cleanUpCallStart": [767], "cleanUpCallEnd": [782], "url": "https://github.com/GlobalsDB/Challenges/tree/master/2/Gloveny/log_src/LogFeeder.java", "rawCode": "  /** Template method that calls {@link #processLine(String)}. */\n  public final void processLineByLine() throws FileNotFoundException {\n    // Note that FileReader is used, not File, since File is not Closeable\n    Scanner scanner = new Scanner(new FileReader(fFile));\n    try {\n      // first use a Scanner to get each line\n      while (scanner.hasNextLine()) {\n        processLine(scanner.nextLine());\n        try {\n          sleep(); // give the impresseion that this is a live feed.\n        } catch (InterruptedException ie) {\n        }\n      }\n    } finally {\n      // ensure the underlying stream is always closed\n      // this only has any effect if the item passed to the Scanner\n      // constructor implements Closeable (which it does in this case).\n      scanner.close();\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7134, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["scanner.next()", "scanner.next()", "scanner.next()"], "configurationStart": [63, 99, 135], "configurationEnd": [74, 110, 146], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 153, "focalAPIEnd": 168, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/baronfel/Emulator/tree/master/src/utility/InstructionParser.java", "rawCode": "  private static void ADDInstruction() {\n    int rd = getValue(file.next());\n    int rs = getValue(file.next());\n    int rt = getValue(file.next());\n    file.nextLine();\n    int funct = 100000;\n    int sa = 0;\n    String opc = \"ADD\";\n    ilist.add((IInstruction) new RTypeInstruction(opc, rd, rs, rt, sa, funct, lineCounter));\n  }\n"}, {"dataset": "nextLine", "exampleID": 7135, "initialization": ["Scanner scanner = new Scanner(File)"], "initializationStart": [546], "initializationEnd": [575], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["fatal(String,*)"], "tryExpressionStart": 512, "tryExpressionEnd": 516, "tryBlockStart": 512, "tryBlockEnd": 1158, "catchExpressionStart": 1044, "catchExpressionEnd": 1065, "catchBlockStart": 1044, "catchBlockEnd": 1158, "exceptionHandlingCallStart": [1073], "exceptionHandlingCallEnd": [1151], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 613, "focalAPIEnd": 635, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.nextLine()", "line.trim()"], "useStart": [710, 710], "useEnd": [732, 739], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eriq-augustine/jocr/tree/master/src/com/eriqaugustine/ocr/utils/FileUtils.java", "rawCode": "  public static BubbleTrainingSet loadBubbleTrainingSet(String baseDir) {\n    File base = new File(baseDir + File.separator + BUBBLE_TRAINING_IMAGES_DIR);\n    assert (base.exists() && base.isDirectory());\n\n    File[] imageFiles = base.listFiles();\n    Arrays.sort(imageFiles);\n    BubbleTrainingSet training = new BubbleTrainingSet(imageFiles);\n\n    File trainingDataFile = new File(baseDir + File.separator + BUBBLE_TRAINING_DATA_FILE);\n    assert (trainingDataFile.exists() && trainingDataFile.isFile());\n\n    try {\n      Scanner fileScanner = new Scanner(trainingDataFile);\n      // Eat the header line.\n      fileScanner.nextLine();\n\n      while (fileScanner.hasNextLine()) {\n        String[] attributes = fileScanner.nextLine().trim().split(\";\");\n        training.addBubble(\n            attributes[0],\n            new Point[] {\n              new Point(Integer.parseInt(attributes[1]), Integer.parseInt(attributes[2])),\n              new Point(Integer.parseInt(attributes[3]), Integer.parseInt(attributes[4]))\n            });\n      }\n    } catch (Exception ex) {\n      logger.fatal(\"Bubble training directory file is not formatted correctly.\", ex);\n    }\n\n    return training;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7136, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 173, "focalAPIEnd": 191, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["convertString(line,String)", "scanner.nextLine()", "convertString(line,String)", "readAndSetAddress(scanner,Person)"], "useStart": [159, 282, 268, 367], "useEnd": [196, 300, 305, 396], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/drepshas/hib-core/tree/master/hibernate-envers/src/demo/java/org/hibernate/envers/demo/TestConsole.java", "rawCode": "  private Person readNewPerson(PrintStream out, Scanner scanner) {\n    Person p = new Person();\n\n    out.print(\"Person name (NULL for null): \");\n    p.setName(convertString(scanner.nextLine(), \"\"));\n\n    out.print(\"Person surname (NULL for null): \");\n    p.setSurname(convertString(scanner.nextLine(), \"\"));\n\n    out.print(\"Person address id (NULL for null): \");\n    readAndSetAddress(scanner, p);\n\n    return p;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7137, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 31, "tryExpressionEnd": 35, "tryBlockStart": 31, "tryBlockEnd": 299, "catchExpressionStart": 233, "catchExpressionEnd": 265, "catchBlockStart": 233, "catchBlockEnd": 299, "exceptionHandlingCallStart": [273], "exceptionHandlingCallEnd": [292], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 175, "focalAPIEnd": 190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NSolberg/Project-Galvatron/tree/master/src/CompleteServer/RiskCore.java", "rawCode": "  private void initMap() {\n    try {\n      Scanner scan = new Scanner(new File(\"Maps/\" + this.worldFile + \".txt\"));\n      String out = \"\";\n      while (scan.hasNext()) out += scan.nextLine() + \"\\n\";\n      world = new Map(out);\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7138, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [1518], "initializationEnd": [1540], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 1622, "focalAPIEnd": 1635, "followUpCheck": "!line.equals(\"q\")", "checkType": "LOOP {", "followUpCheckExpressionStart": 1642, "followUpCheckExpressionEnd": 1668, "followUpCheckBlockStart": 1642, "followUpCheckBlockEnd": 2050, "use": ["CheckDocument.setText(line)", "scanner.nextLine()"], "useStart": [1730, 2030], "useEnd": [1753, 2043], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cogroo/cogroo4/tree/master/cogroo-gc/src/main/java/org/cogroo/gc/cmdline/grammarchecker/GrammarCheckerTool.java", "rawCode": "  public void run(String[] args) {\n    Params params = validateAndParseParams(args, Params.class);\n\n    String lang = params.getLang();\n    CmdLineUtil.checkLanguageCode(lang);\n\n    String country = params.getCountry();\n    if (StringsUtil.isNullOrEmpty(country)) {\n      throw new TerminateToolException(1, \"Country cannot be empty. Example country: BR\");\n    }\n\n    File rulesFile = params.getRulesFile();\n    if (rulesFile != null) {\n      CmdLineUtil.checkInputFile(\"Rules file\", rulesFile);\n    }\n\n    long start = System.nanoTime();\n\n    ComponentFactory factory;\n    try {\n      factory = ComponentFactory.create(new Locale(lang, country));\n    } catch (InitializationException e) {\n      e.printStackTrace();\n      throw new TerminateToolException(\n          1,\n          \"Could not find configuration for \"\n              + lang\n              + \". Only \"\n              + new Locale(\"pt\", \"BR\")\n              + \" might be supported for now.\");\n    }\n    GrammarChecker cogroo;\n    try {\n      if (rulesFile == null) {\n        cogroo = new GrammarChecker(factory.createPipe());\n      } else {\n        String serializedRules = FileUtils.readFile(rulesFile, StandardCharsets.UTF_8);\n        cogroo = new GrammarChecker(factory.createPipe(), serializedRules);\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      throw new TerminateToolException(1, \"Could not create pipeline!\");\n    }\n\n    System.out.println(\"Loading time [\" + ((System.nanoTime() - start) / 1000000) + \"ms]\");\n\n    Scanner kb = new Scanner(System.in);\n    System.out.print(\"Enter the sentence or 'q' to quit: \");\n    String input = kb.nextLine();\n\n    while (!input.equals(\"q\")) {\n\n      CheckDocument document = new CheckDocument();\n      document.setText(input);\n      cogroo.analyze(document);\n\n      if (params.getShowAnalysis()) {\n        System.out.println(TextUtils.nicePrint(document));\n      }\n\n      System.out.println(document.getMistakesAsString());\n\n      System.out.print(\"Enter the sentence or 'q' to quit: \");\n      input = kb.nextLine();\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7139, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 79, "guardExpressionEnd": 103, "guardBlockStart": 79, "guardBlockEnd": 979, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 126, "focalAPIEnd": 139, "followUpCheck": "start < line.length()", "checkType": "LOOP", "followUpCheckExpressionStart": 228, "followUpCheckExpressionEnd": 275, "followUpCheckBlockStart": 228, "followUpCheckBlockEnd": 331, "use": ["line.split(String)"], "useStart": [405], "useEnd": [420], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/miorel/prmf/tree/master/needs_attention/trunk/mafiabot/src/com/googlecode/prmf/corleone/connection/SettingsFileParser.java", "rawCode": "  public void parseFile() throws ParseException {\n    int numSettings = 0;\n    while (in.hasNextLine()) {\n      String line = in.nextLine();\n\n      // TODO do the following using a regular expression!\n      int start = 0;\n      for (start = 0; start < line.length(); ++start) {\n        if (line.charAt(start) != ' ') break;\n      }\n      if (line.charAt(start) == '#') continue;\n\n      String setting[] = line.split(\"=\");\n      for (int i = 0; i < setting.length; ++i) setting[i] = setting[i].trim();\n\n      if (setting[0].equalsIgnoreCase(\"server\")) {\n        server = setting[1];\n      } else if (setting[0].equalsIgnoreCase(\"nick\")) {\n        botName = setting[1];\n      } else if (setting[0].equalsIgnoreCase(\"port\")) {\n        port = Integer.parseInt(setting[1]);\n      } else if (setting[0].equalsIgnoreCase(\"channel\")) {\n        channel = setting[1];\n      } else {\n        throw new ParseException(\"Settings file corrupt\", numSettings);\n      }\n      ++numSettings;\n    }\n    if (numSettings != 4) {\n      throw new ParseException(\"Settings file corrupt\", numSettings);\n    }\n    // System.err.println(botName + \" \" + channel + \" \" + port + \" \" + server);\n  }\n"}, {"dataset": "nextLine", "exampleID": 7140, "initialization": ["Scanner scanner = new Scanner(File)"], "initializationStart": [114], "initializationEnd": [135], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "IF {", "guardExpressionStart": 402, "guardExpressionEnd": 432, "guardBlockStart": 402, "guardBlockEnd": 895, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 500, "focalAPIEnd": 522, "followUpCheck": "rowData.length != line.length", "checkType": "IF", "followUpCheckExpressionStart": 1215, "followUpCheckExpressionEnd": 1251, "followUpCheckBlockStart": 1215, "followUpCheckBlockEnd": 1657, "use": ["scanner.close()", "scanner.nextLine()", "scanner.close()", "new DemographicTableModel(line,Object[][])"], "useStart": [659, 1101, 1676, 2218], "useEnd": [678, 1123, 1695, 2257], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/QingpingMeng/DeID/tree/master/src/dit/TextviewFrame.java", "rawCode": "  private void ReadDemographicFile(File demoFile) {\n    Scanner inputStream = null;\n    try {\n      inputStream = new Scanner(demoFile);\n    } catch (FileNotFoundException ex) {\n      JOptionPane.showMessageDialog(\n          this,\n          \"This file could not \" + \"be opened.\",\n          \"Invalid Demographic File\",\n          JOptionPane.ERROR_MESSAGE);\n      return;\n    }\n\n    String[] fields;\n    if (inputStream.hasNextLine()) {\n      // Read data field headings from first line\n      fields = inputStream.nextLine().split(\"\\t\");\n      // DITGUI.log(\"Demographic header row: \" + StringUtils.join(fields, ','));\n    } else {\n      // File is empty\n      inputStream.close();\n      JOptionPane.showMessageDialog(\n          this,\n          \"This file does not contain \" + \"any demographic data.\",\n          \"Invalid Demographic File\",\n          JOptionPane.ERROR_MESSAGE);\n      return;\n    }\n\n    // Read the data and fill a 2D array\n    ArrayList<Object[]> rowList = new ArrayList<Object[]>();\n    int lineIndex = 1;\n    while (inputStream.hasNextLine()) {\n      lineIndex++;\n      String line = inputStream.nextLine().trim();\n      if (!line.isEmpty()) {\n        Object[] rowData = line.split(\"\\t\");\n\n        if (rowData.length != fields.length) {\n          DEIDGUI.log(\n              \"Mismatched data in demographic file line \"\n                  + lineIndex\n                  + \" (\"\n                  + rowData.length\n                  + \"/\"\n                  + fields.length\n                  + \"), some data \"\n                  + \"may be missing\",\n              DEIDGUI.LOG_LEVEL.WARNING);\n        } else {\n          rowList.add(rowData);\n        }\n      }\n    }\n    inputStream.close();\n\n    if (rowList.isEmpty()) {\n      JOptionPane.showMessageDialog(\n          this,\n          \"This file does not contain \" + \"any demographic data.\",\n          \"Invalid Demographic File\",\n          JOptionPane.ERROR_MESSAGE);\n      return;\n    }\n\n    // Sort the data by ID\n    // The data may be alphanumeric, and the user may change the ID data later.\n    Collections.sort(rowList, new DemoRowComparator());\n\n    Object[][] rows = new Object[rowList.size()][];\n    rowList.toArray(rows);\n    DeidData.demographicData = new DemographicTableModel(fields, rows);\n    jTable1.setModel(DeidData.demographicData);\n    DEIDGUI.continueButton.setEnabled(true);\n    int idColumn = DeidData.demographicData.getColumnNdx(\"id\");\n    if (idColumn < 0) {\n      idColumn = 0;\n    }\n    DeidData.IdColumn = idColumn;\n    jTable1.setColumnSelectionInterval(idColumn, idColumn);\n    DeidData.selectedIdentifyingFields = null;\n    DeidData.deselectedIdentifyingFields = null;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7141, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [609], "initializationEnd": [631], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 637, "focalAPIEnd": 650, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ajorgesantosp/EAPLI_PL_2DB/tree/master/eapli.expensemanager/src/Presentation/ExpensesUI.java", "rawCode": "  public void ListExpenditures() {\n    System.out.println(\"* * * SHOW LIST EXPENDITURES * * *\\n\");\n\n    List<Expense> aExp = ec.getListExpenditures();\n\n    for (int i = 0; i < aExp.size(); i++) {\n\n      System.out.println(\"<--- \" + (i + 1) + \"º Expense --->\");\n      aExp.get(i).expenseToString();\n      /*System.out.println(\"Amount : \" + aExp.get(i).getAmount().doubleValue() + \"\");\n      System.out.println(\"Description : \" + aExp.get(i).getDescription() + \"\");\n      System.out.println(\"Date : \" + aExp.get(i).getDate()+ \"\\n\");*/\n    }\n\n    System.out.println(\"Press Enter to continue.\");\n    Scanner sc = new Scanner(System.in);\n    sc.nextLine();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7142, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [1284], "initializationEnd": [1306], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 2057, "guardExpressionEnd": 2085, "guardBlockStart": 2057, "guardBlockEnd": 3608, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 2114, "focalAPIEnd": 2131, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["line.trim()"], "useStart": [2598], "useEnd": [2609], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/monnetproject/translation/tree/master/controller/src/main/java/eu/monnetproject/translation/controller/RTPL.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    final List<String> argsList = new LinkedList<String>(Arrays.asList(args));\n    String namePrefix = null;\n    int nBest = 1;\n    String[] scopeStrs = new String[] {};\n    boolean verbose = false;\n    for (int i = 0; i < argsList.size(); i++) {\n      if (argsList.get(i).equals(\"-namePrefix\")) {\n        namePrefix = argsList.get(i + 1);\n        argsList.remove(i);\n        argsList.remove(i);\n        i--;\n      } else if (argsList.get(i).equals(\"-nBest\")) {\n        nBest = Integer.parseInt(argsList.get(i + 1));\n        argsList.remove(i);\n        argsList.remove(i);\n        i--;\n      } else if (argsList.get(i).equals(\"-scope\")) {\n        scopeStrs = argsList.get(i).split(\",\");\n        for (int j = 0; j < scopeStrs.length; j++) {\n          scopeStrs[j] = scopeStrs[j].trim();\n        }\n        argsList.remove(i);\n        argsList.remove(i);\n        i--;\n      } else if (argsList.get(i).equals(\"-verbose\")) {\n        verbose = true;\n        argsList.remove(i);\n      }\n    }\n    if (argsList.size() != 2) {\n      System.err.println(\n          \"Usage:\\n\\ttranslate [-namePrefix prefix] [-nBest n] [-scope uri1,uri2,uri3...] sourceLanguage targetLanguage\");\n      System.exit(-1);\n    }\n\n    final Scanner lineIn = new Scanner(System.in);\n    final OntologySerializer ontoSerializer = Services.get(OntologySerializer.class);\n\n    final TranslationController controller =\n        new TranslationController(\n            Services.getAll(LanguageModelFactory.class),\n            Services.get(DecoderFactory.class),\n            Services.getAll(TranslationPhraseChunkerFactory.class),\n            Services.getAll(TranslationSourceFactory.class),\n            Services.getAll(TranslationFeaturizerFactory.class),\n            Services.getFactory(TokenizerFactory.class),\n            Services.getAll(TranslationConfidenceFactory.class));\n    final Language sourceLanguage = Language.get(argsList.get(0));\n    final Language targetLanguage = Language.get(argsList.get(1));\n\n    int lineNo = 0;\n\n    while (lineIn.hasNextLine()) {\n      final String line = lineIn.nextLine();\n      final Ontology ontology =\n          ontoSerializer.create(URI.create(\"file:test#ontology\" + (lineNo++)));\n      final OntologyFactory factory = ontology.getFactory();\n      final AnnotationProperty rdfsLabel =\n          factory.makeAnnotationProperty(URI.create(\"http://www.w3.org/2000/01/rdf-schema#label\"));\n      final Class c = factory.makeClass(URI.create(\"file:test#class1\"));\n      c.addAnnotation(\n          rdfsLabel, factory.makeLiteralWithLanguage(line.trim(), sourceLanguage.toString()));\n      ontology.addClass(c);\n      final SimpleLexicalizer lexicalizer =\n          new SimpleLexicalizer(Services.get(LabelExtractorFactory.class));\n      final Collection<Lexicon> sourceLexica = lexicalizer.lexicalize(ontology);\n      final Lexicon targetLexicon = lexicalizer.getBlankLexicon(ontology, targetLanguage);\n      final ArrayList<URI> scopes = new ArrayList<URI>();\n      for (String scopeStr : scopeStrs) {\n        final URI scope = URI.create(scopeStr);\n        if (scope == null) {\n          throw new IllegalArgumentException(scopeStr + \" is not a valid URI\");\n        }\n        scopes.add(scope);\n      }\n\n      controller.setVerbose(verbose);\n\n      controller.translate(ontology, sourceLexica, targetLexicon, scopes, namePrefix, nBest);\n\n      for (LexicalEntry entry : targetLexicon.getEntrys()) {\n        for (LexicalSense sense : entry.getSenses()) {\n          System.out.println(entry.getCanonicalForm().getWrittenRep());\n        }\n      }\n    }\n    System.exit(0);\n  }\n"}, {"dataset": "nextLine", "exampleID": 7143, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 804, "focalAPIEnd": 817, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["appointmentDeleter(line)"], "useStart": [823], "useEnd": [847], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mollersilje/su4/tree/master/su4/src/fellesp/CalandarHandler.java", "rawCode": "  public static void giveCancellation() throws ClassNotFoundException, SQLException {\n    // KRAV 9\n    ArrayList<Integer> listWhereOwner = AppointmentFactory.getMeetingWhereOwner(username);\n    ArrayList<Integer> meetings = InviteFactory.getAcceptedInvitesForThisUse(username);\n    ArrayList<Integer> acceptedMeetings = new ArrayList<Integer>();\n    for (int i : meetings) {\n      if (!listWhereOwner.contains(i)) {\n        acceptedMeetings.add(i);\n      }\n    }\n    if (acceptedMeetings.isEmpty()) {\n      System.out.println(\"Du er ikke deltaker på noen møter. \\n\");\n      return;\n    }\n    System.out.println(\"Du skal på disse møtene:\");\n    for (int i : acceptedMeetings) {\n      System.out.println(\"ID: \" + i);\n    }\n    System.out.println(\"Hvilket møte vil du melde avbud for?\");\n    String svar = sc.nextLine();\n    appointmentDeleter(svar);\n  }\n"}, {"dataset": "nextLine", "exampleID": 7144, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [65], "initializationEnd": [83], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 89, "guardExpressionEnd": 118, "guardBlockStart": 89, "guardBlockEnd": 198, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 141, "focalAPIEnd": 159, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["println(line)"], "useStart": [167], "useEnd": [191], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/charles-ma/Java_em/tree/master/Make/Make.java", "rawCode": "  public void display(InputStream input) {\n    Scanner scanner = new Scanner(input);\n    while (scanner.hasNextLine()) {\n      String line = scanner.nextLine();\n      System.out.println(line);\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7145, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine() && !(scanner==null)", "guardType": "IF {", "guardExpressionStart": 36, "guardExpressionEnd": 53, "guardBlockStart": 36, "guardBlockEnd": 80, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 134, "focalAPIEnd": 149, "followUpCheck": "line.equals(\"\")", "checkType": "IF", "followUpCheckExpressionStart": 157, "followUpCheckExpressionEnd": 177, "followUpCheckBlockStart": 157, "followUpCheckBlockEnd": 205, "use": ["parse(line)"], "useStart": [242], "useEnd": [263], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aljoscha/presslufthammer/tree/master/src/main/java/de/tuberlin/dima/presslufthammer/data/hierarchical/json/JSONRecordFileIterator.java", "rawCode": "  public RecordDecoder next() {\n    if (scan == null) {\n      return null;\n    }\n    while (scan.hasNextLine()) {\n      String line = scan.nextLine();\n      if (line.equals(\"\")) {\n        continue;\n      }\n      JSONObject job = (JSONObject) JSONValue.parse(line);\n      RecordDecoder decoder = new JSONRecordDecoder(schema, job);\n      return decoder;\n    }\n    return null;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7146, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [713], "initializationEnd": [764], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 887, "focalAPIEnd": 905, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(line)", "scanner.close()"], "useStart": [856, 933], "useEnd": [906, 948], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/deafro5/AMProgram/tree/master/src/FileReader.java", "rawCode": "  /**\n   * This method reads a list of classes from a .txt file and saves it to an array of Strings\n   *\n   * @param someHashedUser: The user's hashed name\n   * @return String[]: A String array of all the classes the student has taken\n   * @throws FileNotFoundException\n   */\n  public String[] readLoadClasses(String someHashedUser) throws FileNotFoundException {\n    String fileReadLoadName2 = relation + \"\\\\Saves\\\\\" + someHashedUser + \".txt\";\n    File f = new File(fileReadLoadName2);\n\n    // Checks to see if a save file exists first\n    // If it does, read the file and store it in an array\n    if (f.exists()) {\n      String[] loadClass = new String[lengthOfTask(fileReadLoadName2)];\n      Scanner scanner = new Scanner(new FileInputStream(fileReadLoadName2));\n\n      for (int i = 0; i < lengthOfTask(fileReadLoadName2); i++) {\n        loadClass[i] = (new StringBuilder(\"\")).append(scanner.nextLine()).toString();\n      }\n      scanner.close();\n      return loadClass;\n    } else { // If the file does not exist, return a blank array\n      String[] loadClass = new String[0];\n      return loadClass;\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7147, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [65], "initializationEnd": [87], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 125, "focalAPIEnd": 143, "followUpCheck": "line.equals(\"quit\")", "checkType": "IF", "followUpCheckExpressionStart": 151, "followUpCheckExpressionEnd": 172, "followUpCheckBlockStart": 151, "followUpCheckBlockEnd": 179, "use": ["isUnique(line)"], "useStart": [205], "useEnd": [229], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/charles-ma/Java_em/tree/master/UniqueString.java", "rawCode": "  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    while (true) {\n      String s = scanner.nextLine();\n      if (s.equals(\"quit\")) break;\n      System.out.println(UniqueString.isUnique(s));\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7148, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [353], "initializationEnd": [375], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 977, "focalAPIEnd": 990, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Verifier(line)"], "useStart": [964], "useEnd": [991], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/KodeSeeker/GmailRcptScanv1/tree/master/src/test/java/org/scribe/examples/ImgUrExample.java", "rawCode": "  public static void main(String[] args) {\n    // Replace these with your own api key and secret (you'll need an read/write api key)\n    String apiKey = \"your_app_id\";\n    String apiSecret = \"your_api_secret\";\n    OAuthService service =\n        new ServiceBuilder().provider(ImgUrApi.class).apiKey(apiKey).apiSecret(apiSecret).build();\n    Scanner in = new Scanner(System.in);\n\n    System.out.println(\"=== ImgUr's OAuth Workflow ===\");\n    System.out.println();\n\n    // Obtain the Request Token\n    System.out.println(\"Fetching the Request Token...\");\n    Token requestToken = service.getRequestToken();\n    System.out.println(\"Got the Request Token!\");\n    System.out.println();\n\n    System.out.println(\"Now go and authorize Scribe here:\");\n    String authorizationUrl = service.getAuthorizationUrl(requestToken);\n    System.out.println(authorizationUrl);\n    System.out.println(\"And paste the verifier here\");\n    System.out.print(\">>\");\n    Verifier verifier = new Verifier(in.nextLine());\n    System.out.println();\n\n    // Trade the Request Token and Verfier for the Access Token\n    System.out.println(\"Trading the Request Token for an Access Token...\");\n    Token accessToken = service.getAccessToken(requestToken, verifier);\n    System.out.println(\"Got the Access Token!\");\n    System.out.println(\"(if your curious it looks like this: \" + accessToken + \" )\");\n    System.out.println();\n\n    // Now let's go and ask for a protected resource!\n    System.out.println(\"Now we're going to access a protected resource...\");\n    OAuthRequest request = new OAuthRequest(Verb.GET, PROTECTED_RESOURCE_URL);\n    service.signRequest(accessToken, request);\n    Response response = request.send();\n    System.out.println(\"Got it! Lets see what we found...\");\n    System.out.println();\n    System.out.println(response.getBody());\n\n    System.out.println();\n    System.out.println(\"Thats it man! Go and build something awesome with Scribe! :)\");\n  }\n"}, {"dataset": "nextLine", "exampleID": 7149, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["new PicardException(String,*)"], "tryExpressionStart": 251, "tryExpressionEnd": 255, "tryBlockStart": 251, "tryBlockEnd": 1577, "catchExpressionStart": 1441, "catchExpressionEnd": 1473, "catchBlockStart": 1441, "catchBlockEnd": 1577, "exceptionHandlingCallStart": [1487], "exceptionHandlingCallEnd": [1570], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 612, "focalAPIEnd": 630, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new PicardException(line)", "scanner.nextLine()", "new PicardException(line)"], "useStart": [554, 791, 733], "useEnd": [631, 809, 810], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iansealy/picard-detct/tree/master/src/java/net/sf/picard/reference/FastaSequenceIndex.java", "rawCode": "  /**\n   * Parse the contents of an index file, caching the results internally.\n   *\n   * @param indexFile File to parse.\n   * @throws FileNotFoundException Thrown if file could not be opened.\n   */\n  private void parseIndexFile(File indexFile) {\n    try {\n      Scanner scanner = new Scanner(indexFile);\n\n      int sequenceIndex = 0;\n      while (scanner.hasNext()) {\n        // Tokenize and validate the index line.\n        String result = scanner.findInLine(\"(.+)\\\\t+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\");\n        if (result == null)\n          throw new PicardException(\"Found invalid line in index file:\" + scanner.nextLine());\n        MatchResult tokens = scanner.match();\n        if (tokens.groupCount() != 5)\n          throw new PicardException(\"Found invalid line in index file:\" + scanner.nextLine());\n\n        // Skip past the line separator\n        scanner.nextLine();\n\n        // Parse the index line.\n        String contig = tokens.group(1);\n        long size = Long.valueOf(tokens.group(2));\n        long location = Long.valueOf(tokens.group(3));\n        int basesPerLine = Integer.valueOf(tokens.group(4));\n        int bytesPerLine = Integer.valueOf(tokens.group(5));\n\n        contig = SAMSequenceRecord.truncateSequenceName(contig);\n        // Build sequence structure\n        add(\n            new FastaSequenceIndexEntry(\n                contig, location, size, basesPerLine, bytesPerLine, sequenceIndex++));\n      }\n    } catch (FileNotFoundException e) {\n      throw new PicardException(\"Fasta index file should be found but is not: \" + indexFile, e);\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7150, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [240], "initializationEnd": [315], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 742, "focalAPIEnd": 758, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new InstructionText(*,int,line,TrueTypeFont)", "scanner.nextLine()"], "useStart": [708, 1114], "useEnd": [762, 1130], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aschearer/shade/tree/master/src/com/shade/states/SelectState.java", "rawCode": "  private void initLevels(TrueTypeFont f) throws SlickException {\n    Scanner hints = new Scanner(ResourceLoader.getResourceAsStream(\"states/select/hints.txt\"));\n    Image locked = new Image(\"states/select/locked.png\");\n    Scanner names = new Scanner(ResourceLoader.getResourceAsStream(\"states/select/levels.txt\"));\n    Image unlocked = new Image(\"states/select/unlocked.png\");\n\n    levels = new LevelSet();\n    float x = 90;\n    int n = 0;\n    while (hints.hasNextLine()) {\n      InstructionImage i = null;\n      InstructionText t = null;\n      if (master.levelsLock.isUnlocked(n)) {\n        i = new InstructionImage(x, 425, unlocked);\n        i.setTimer(LEVEL_STATE_DELAY + n * LEVEL_BUFFER);\n        t = new InstructionText(x + 100, 445, names.nextLine(), f);\n        t.setTimer(LEVEL_STATE_DELAY + n * LEVEL_BUFFER);\n        hints.nextLine();\n      } else {\n        i = new InstructionImage(x - 6, 425 + 11, locked);\n        i.setTimer(LEVEL_STATE_DELAY + n * LEVEL_BUFFER);\n        t = new InstructionText(x + 100, 445, hints.nextLine(), f);\n        t.setTimer(LEVEL_STATE_DELAY + n * LEVEL_BUFFER);\n        names.nextLine();\n      }\n      levels.add(i, t);\n      n++;\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7151, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [313], "initializationEnd": [327], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 335, "guardExpressionEnd": 364, "guardBlockStart": 335, "guardBlockEnd": 981, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 409, "focalAPIEnd": 427, "followUpCheck": "line.isEmpty()", "checkType": "IF", "followUpCheckExpressionStart": 465, "followUpCheckExpressionEnd": 484, "followUpCheckBlockStart": 465, "followUpCheckBlockEnd": 494, "use": ["line.trim()", "line.split(String)", "scanner.close()"], "useStart": [444, 659, 1025], "useEnd": [455, 682, 1040], "hasFinally": 1, "cleanUpCall": ["Scanner.close()"], "finallyExpressionStart": 988, "finallyExpressionEnd": 996, "finallyBlockStart": 988, "finallyBlockEnd": 1047, "cleanUpCallStart": [1025], "cleanUpCallEnd": [1040], "url": "https://github.com/sylvainhalle/TraceAdapter/tree/master/TraceLogic/src/ca/uqac/info/trace/CsvTraceReader.java", "rawCode": "  public EventTrace parseEventTrace(InputStream f) {\n    Scanner scanner = null;\n    Vector<String> param_names = new Vector<String>();\n    ;\n    Document doc = super.getEmptyDomDocument();\n    if (doc == null) return null;\n    EventTrace trace = new EventTrace();\n    int num_line = 0;\n    try {\n      scanner = new Scanner(f);\n      while (scanner.hasNextLine()) {\n        num_line++;\n        String line = scanner.nextLine();\n        line = line.trim();\n        if (line.isEmpty()) continue;\n        if (line.startsWith(m_commentChar)) continue;\n        if (m_ignoreLinesWithoutSeparator && !line.contains(m_separator)) continue;\n        String[] params = line.split(m_separator);\n        if (num_line == 1 && m_paramNamesOnFirstLine) {\n          // If first line contains parameter names, store those names\n          for (String p : params) param_names.add(p);\n          continue;\n        }\n        Event e = lineToEvent(doc, params, param_names);\n        trace.add(e);\n      }\n    } finally {\n      if (scanner != null) scanner.close();\n    }\n    return trace;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7152, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [274], "initializationEnd": [296], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 316, "focalAPIEnd": 334, "followUpCheck": "line.equalsIgnoreCase(\"quit\")", "checkType": "IF", "followUpCheckExpressionStart": 346, "followUpCheckExpressionEnd": 385, "followUpCheckBlockStart": 346, "followUpCheckBlockEnd": 431, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thusoy/Fellesprosjektet/tree/master/Fellesprosjektet/src/client/helpers/IO.java", "rawCode": "  public static String getString(String display) throws UserAbortException {\n    String userInput;\n    if (useGUI) {\n      SimpleTextGUI.setInputText(display);\n      userInput = SimpleTextGUI.getInput();\n    } else {\n      System.out.print(display);\n      Scanner scanner = new Scanner(System.in);\n      userInput = scanner.nextLine();\n    }\n    if (userInput.equalsIgnoreCase(\"quit\")) {\n      throw new UserAbortException();\n    }\n    if (useGUI) {\n      SimpleTextGUI.setInputText(\"\");\n    }\n    return userInput;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7153, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [276], "initializationEnd": [298], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 323, "focalAPIEnd": 340, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.close()"], "useStart": [346], "useEnd": [360], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/djmailhot/CSE461projects/tree/master/Net/src/edu/uw/cs/cse461/Net/Base/_SocketThreadTest.java", "rawCode": "  public static void main(String args[]) throws InterruptedException {\n    DataThreadInterface t = new UDPDataThread(11111, 1000000, 500);\n\n    new Thread(t).start();\n\n    Thread.sleep(500);\n    System.out.println(\"<<<<Press any key to kill server>>>>\");\n    Scanner scanIn = new Scanner(System.in);\n    String sWhatever = scanIn.nextLine();\n    scanIn.close();\n    t.end();\n    System.out.println(\"It done been killed.\");\n  }\n"}, {"dataset": "nextLine", "exampleID": 7154, "initialization": ["Scanner scanner = new Scanner(File)"], "initializationStart": [180], "initializationEnd": [197], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 207, "guardExpressionEnd": 236, "guardBlockStart": 207, "guardBlockEnd": 365, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 263, "focalAPIEnd": 281, "followUpCheck": "line.contains(loc)", "checkType": "IF", "followUpCheckExpressionStart": 293, "followUpCheckExpressionEnd": 316, "followUpCheckBlockStart": 293, "followUpCheckBlockEnd": 355, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/felixvelasco/test/tree/master/maven/dsl-builder/src/main/java/com/isb/jVoice/dsl/builder/PrepareWSDLSourcesMojo.java", "rawCode": "  private boolean containsLocationsInFile(List<String> locations, File file) {\n    try {\n      boolean cons = false;\n      for (String loc : locations) {\n        Scanner scanner = new Scanner(file);\n        while (scanner.hasNextLine()) {\n          String line = scanner.nextLine();\n          if (line.contains(loc)) {\n            cons = true;\n          }\n        }\n        if (!cons) {\n          return false;\n        }\n        cons = false;\n      }\n    } catch (FileNotFoundException e) {\n      return false;\n    }\n    return true;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7155, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [336], "initializationEnd": [367], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 258, "tryExpressionEnd": 262, "tryBlockStart": 258, "tryBlockEnd": 589, "catchExpressionStart": 521, "catchExpressionEnd": 554, "catchBlockStart": 521, "catchBlockEnd": 589, "exceptionHandlingCallStart": [562], "exceptionHandlingCallEnd": [582], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 375, "guardExpressionEnd": 399, "guardBlockStart": 375, "guardBlockEnd": 452, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 425, "focalAPIEnd": 442, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(line)", "scanner.close()"], "useStart": [410, 459], "useEnd": [443, 473], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sreeprasad/TodayILearntTo/tree/master/Concordance.java", "rawCode": "  /**\n   * fileToString uses Scanner class to read a file line by line and stores the string\n   * representation of each line in fileContent.\n   *\n   * @params(String (name of file to be read))\n   */\n  private static void fileToString(String fileName) {\n    try {\n      StringBuffer content = new StringBuffer();\n      Scanner reader = new Scanner(new File(fileName));\n      while (reader.hasNext()) {\n        content.append(reader.nextLine());\n      }\n      reader.close();\n      fileContent = content.toString();\n    } catch (FileNotFoundException ex) {\n      ex.printStackTrace();\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7156, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 142, "focalAPIEnd": 159, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/KarleeBronson/Memory/tree/master/Memory2/src/memory2/Player.java", "rawCode": "  public String getName() {\n    Scanner inFile = Memory2.getInputFile();\n    System.out.println(\"Enter your name Player A:\");\n    this.name = inFile.nextLine();\n    return name;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7157, "initialization": ["Scanner scanner = new Scanner(File)"], "initializationStart": [473], "initializationEnd": [496], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 726, "guardExpressionEnd": 756, "guardBlockStart": 726, "guardBlockEnd": 2101, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 783, "focalAPIEnd": 802, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["line.split(String)", "scanner.close()"], "useStart": [871, 2111], "useEnd": [887, 2127], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bryanjimenez/empanada/tree/master/cache/cache/src/cache_controller/FileReader.java", "rawCode": "  public void run() {\n    runThread = true;\n\n    while (runThread) {\n      // Sleep on every iteration\n      try {\n\n        Thread.sleep(SLEEP_TIME);\n      } catch (InterruptedException e) {\n        // Should never happen\n        e.printStackTrace();\n      }\n\n      // Read file\n      File outputFile = new File(OUTPUT_FILE_LOCATION);\n\n      if (outputFile.exists()) {\n        // Get scanner for the file\n        Scanner filescan = null;\n        try {\n          filescan = new Scanner(outputFile);\n        } catch (FileNotFoundException e) {\n          // File was just deleted\n          e.printStackTrace();\n          continue;\n        }\n\n        Map<String, String[]> parsedTweets = new HashMap<String, String[]>();\n\n        while (filescan.hasNextLine()) {\n          String line = filescan.nextLine();\n\n          // Get values from tweet\n          String[] lineSplit = line.split(\"\\t\");\n          String tweetFilter = lineSplit[FILE_FILTER_INDEX];\n          String tweetStr = lineSplit[FILE_JSON_INDEX];\n          String tweetRating = lineSplit[FILE_RATING_INDEX];\n\n          JSONObject tweetJson = null;\n          String tweetID = null;\n          String tweetLat = null;\n          String tweetLng = null;\n\n          try {\n            tweetJson = new JSONObject(tweetStr);\n\n            // Get coordinates\n            if (tweetStr.indexOf(\"\\\"geo\\\": null\") == -1) {\n\n              JSONObject geo = tweetJson.getJSONObject(\"geo\");\n\n              JSONArray coordinates = geo.getJSONArray(\"coordinates\");\n              tweetLat = Double.toString(coordinates.getDouble(JSON_LAT_INDEX)); // Latitude\n              tweetLng = Double.toString(coordinates.getDouble(JSON_LONG_INDEX)); // Longitude\n\n              // Get tweet ID\n              tweetID = tweetJson.getString(\"id_str\"); // ID\n\n              String[] columns = {tweetFilter, tweetStr, tweetLat, tweetLng, tweetRating};\n              parsedTweets.put(tweetID, columns);\n            }\n          } catch (JSONException e) {\n            // json not formatted properly, skip\n            e.printStackTrace();\n            continue;\n          }\n        }\n\n        filescan.close();\n\n        // Add to HBase\n        HBaseConnection hbase = new HBaseConnection();\n\n        try {\n          hbase.put(parsedTweets);\n        } catch (IOException e) {\n          // Not written to HBase, don't delete the file\n          e.printStackTrace();\n          continue;\n        }\n\n        // Erase file\n        outputFile.setWritable(true);\n        outputFile.delete();\n      }\n    }\n\n    threadFinished = true;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7158, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [156], "initializationEnd": [184], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 455, "guardExpressionEnd": 543, "guardBlockStart": 455, "guardBlockEnd": 652, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 628, "focalAPIEnd": 641, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new LineCoverageRecord(int,*,line)", "scanner.nextLine()", "scanner.nextLine()", "new LineCoverageRecord(int,*,line)"], "useStart": [578, 765, 1349, 1299], "useEnd": [642, 778, 1362, 1363], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/timurstrekalov/saga/tree/master/saga-core/src/main/java/com/github/timurstrekalov/saga/core/model/ScriptData.java", "rawCode": "  public ScriptCoverageStatistics generateScriptCoverageStatistics(\n      final URI baseUri, final Map<String, Long> coverageData) {\n    final Scanner in = new Scanner(getSourceCode());\n\n    final List<LineCoverageRecord> lineCoverageRecords = Lists.newArrayList();\n\n    if (!linesWithStatements.isEmpty()) {\n      // pad with extra line coverage records if first executable statement is not the first line\n      // (comments at the start of files)\n      for (int lineNr = 1; lineNr < getLineNumberOfFirstStatement() && in.hasNext(); lineNr++) {\n        lineCoverageRecords.add(new LineCoverageRecord(lineNr, LINE_NO_STATEMENT, in.nextLine()));\n      }\n\n      for (int lineNr = getLineNumberOfFirstStatement(); in.hasNext(); lineNr++) {\n        final String line = in.nextLine();\n\n        final Long coverageEntry = coverageData.get(String.valueOf(lineNr));\n        final int timesLineExecuted;\n\n        if (coverageEntry == null) {\n          timesLineExecuted = hasStatement(lineNr) ? LINE_MISSED : LINE_NO_STATEMENT;\n        } else {\n          timesLineExecuted = coverageEntry.intValue();\n        }\n\n        lineCoverageRecords.add(new LineCoverageRecord(lineNr, timesLineExecuted, line));\n      }\n    } else {\n      for (int lineNr = 1; in.hasNext(); lineNr++) {\n        lineCoverageRecords.add(new LineCoverageRecord(lineNr, LINE_NO_STATEMENT, in.nextLine()));\n      }\n    }\n\n    return new ScriptCoverageStatistics(\n        baseUri, getSourceUri(), lineCoverageRecords, isSeparateFile());\n  }\n"}, {"dataset": "nextLine", "exampleID": 7159, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 151, "focalAPIEnd": 169, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseInt(line)"], "useStart": [134], "useEnd": [170], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/masterjc/ecosystemguard/tree/master/client/pc/src/java/com/ecosystem/guard/pc/VideoManager.java", "rawCode": "  private int requestVideoLength() {\n    System.out.println();\n    System.out.print(\"-> Enter video length in seconds: \");\n    return Integer.parseInt(scanner.nextLine());\n  }\n"}, {"dataset": "nextLine", "exampleID": 7160, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [178], "initializationEnd": [202], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 432, "focalAPIEnd": 450, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.next()", "scanner.next()", "scanner.next()", "scanner.next()", "scanner.next()"], "useStart": [500, 533, 574, 617, 661], "useEnd": [514, 547, 588, 631, 675], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jmchilton/TINT/tree/master/projects/TropixProteomicsCore/src/test/edu/umn/msi/tropix/proteomics/itraqquantitation/impl/VarianceTest.java", "rawCode": "  @Test(groups = \"unit\")\n  public void compareToRResults() {\n    final InputStream inputStream = getClass().getResourceAsStream(\"training_data.txt\");\n    final Scanner scanner = new Scanner(inputStream);\n\n    final int numValues = 523;\n    final double[] i114 = new double[numValues],\n        i115 = new double[numValues],\n        i116 = new double[numValues],\n        i117 = new double[numValues];\n\n    // Drop the header line\n    scanner.nextLine();\n    for (int i = 0; i < numValues; i++) {\n      scanner.next(); // drop id\n      scanner.next(); // drop short name\n      scanner.next(); // ignore protein id\n      scanner.next(); // ignore peptide seq\n      scanner.next(); // ignore peptide prob\n\n      i114[i] = scanner.nextDouble();\n      i115[i] = scanner.nextDouble();\n      i116[i] = scanner.nextDouble();\n      i117[i] = scanner.nextDouble();\n    }\n\n    final double[][] result = new double[31][2];\n    final InputStream matrixInputStream = getClass().getResourceAsStream(\"weight_matrix.txt\");\n    final Scanner matrixScanner = new Scanner(matrixInputStream);\n    // Drop the header line\n    matrixScanner.nextLine();\n    for (int i = 0; i < 31; i++) {\n      matrixScanner.next(); // ignore row name\n\n      result[i][0] = matrixScanner.nextDouble();\n      result[i][1] = matrixScanner.nextDouble();\n    }\n    final List<ITraqLabel> labels = ITraqLabels.get4PlexLabels();\n    final Map<ITraqLabel, double[]> intensities =\n        ImmutableMap.<ITraqLabel, double[]>builder()\n            .put(labels.get(0), i114)\n            .put(labels.get(1), i115)\n            .put(labels.get(2), i116)\n            .put(labels.get(3), i117)\n            .build();\n    final double[][] actualResults =\n        Variance.createVarianceMatrix(labels, intensities, new double[] {10, 5, 2, 1}, 100);\n    assert actualResults.length == 31;\n    for (int i = 0; i < 31; i++) {\n      MathAsserts.assertWithin(result[i], actualResults[i], .0001);\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7161, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 115, "guardExpressionEnd": 135, "guardBlockStart": 115, "guardBlockEnd": 518, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 151, "focalAPIEnd": 164, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new StringTokenizer(line)"], "useStart": [193], "useEnd": [218], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AlexBarnes86/uva-java/tree/master/ProgrammingChallenges/src/chapter7/Problem10104.java", "rawCode": "  public static void main(String[] args) {\n    String line;\n    PrintWriter pw = new PrintWriter(System.out);\n\n    while (sc.hasNext()) {\n      line = sc.nextLine();\n      StringTokenizer st = new StringTokenizer(line);\n      long a = Long.valueOf(st.nextToken().replace(\",\", \"\").trim());\n      long b = Long.valueOf(st.nextToken().replace(\",\", \"\").trim());\n      MutableLong x = new MutableLong();\n      MutableLong y = new MutableLong();\n      long g = gcd(a, b, x, y);\n      pw.println(x + \" \" + y + \" \" + g);\n    }\n    pw.flush();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7162, "initialization": ["Scanner scanner = new Scanner(String)"], "initializationStart": [168], "initializationEnd": [197], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 215, "guardExpressionEnd": 244, "guardBlockStart": 215, "guardBlockEnd": 594, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 269, "focalAPIEnd": 287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["substringBefore(line,String)", "trimToNull(line)", "substringBefore(line,String)", "substringAfter(line,String)", "scanner.close()"], "useStart": [304, 359, 410, 473, 617], "useEnd": [342, 387, 448, 510, 632], "hasFinally": 1, "cleanUpCall": ["Scanner.close()"], "finallyExpressionStart": 601, "finallyExpressionEnd": 609, "finallyBlockStart": 601, "finallyBlockEnd": 639, "cleanUpCallStart": [617], "cleanUpCallEnd": [632], "url": "https://github.com/3wks/thundr/tree/master/src/main/java/com/threewks/thundr/configuration/PropertiesLoader.java", "rawCode": "  private Map<String, String> readProperties(String resourceAsString) {\n    Map<String, String> properties = new LinkedHashMap<String, String>();\n    Scanner scanner = new Scanner(resourceAsString);\n    try {\n      while (scanner.hasNextLine()) {\n        String line = scanner.nextLine();\n        line = StringUtils.substringBefore(line, \"#\");\n        line = StringUtils.trimToNull(line);\n        String key = StringUtils.substringBefore(line, \"=\");\n        String value = StringUtils.substringAfter(line, \"=\");\n        if (key != null) {\n          properties.put(key, value);\n        }\n      }\n    } finally {\n      scanner.close();\n    }\n    return properties;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7163, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [607], "initializationEnd": [640], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 716, "guardExpressionEnd": 745, "guardBlockStart": 716, "guardBlockEnd": 1126, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 774, "focalAPIEnd": 792, "followUpCheck": "line.contains(\"(VER_ADL_VERSION)\")", "checkType": "IF", "followUpCheckExpressionStart": 806, "followUpCheckExpressionEnd": 845, "followUpCheckBlockStart": 806, "followUpCheckBlockEnd": 1114, "use": ["getLineVal(line)", "getLineVal(line)", "getLineVal(line)", "scanner.close()"], "useStart": [875, 977, 1083, 1216], "useEnd": [891, 993, 1099, 1231], "hasFinally": 1, "cleanUpCall": ["Scanner.close()"], "finallyExpressionStart": 1137, "finallyExpressionEnd": 1145, "finallyBlockStart": 1137, "finallyBlockEnd": 1242, "cleanUpCallStart": [1216], "cleanUpCallEnd": [1231], "url": "https://github.com/berkmancenter/zone1/tree/master/bin/fits-0.6.0/src/edu/harvard/hul/ois/fits/tools/oisfileinfo/ADLTool.java", "rawCode": "  private Document createXml(File file) throws FitsToolException {\n\n    Element root = new Element(\"fits\", fitsNS);\n    root.setAttribute(\n        new Attribute(\n            \"schemaLocation\",\n            \"http://hul.harvard.edu/ois/xml/ns/fits/fits_output \" + Fits.externalOutputSchema,\n            xsiNS));\n\n    if (file.getPath().toLowerCase().endsWith(\".adl\")) {\n\n      String adlVersion = null;\n      String adlCreator = null;\n      String adlCreatorVersion = null;\n\n      try {\n        // creating an ADL objecte should be enough to validate it as ADL\n        new ADL(file);\n\n        Scanner scanner = new Scanner(new FileReader(file));\n        try {\n          // first use a Scanner to get each line\n          while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (line.contains(\"(VER_ADL_VERSION)\")) {\n              adlVersion = getLineVal(line);\n            } else if (line.contains(\"(VER_CREATOR)\")) {\n              adlCreator = getLineVal(line);\n            } else if (line.contains(\"(VER_CRTR)\")) {\n              adlCreatorVersion = getLineVal(line);\n            }\n          }\n        } finally {\n          // ensure the underlying stream is always closed\n          scanner.close();\n        }\n      } catch (Exception e) {\n        throw new FitsToolException(\"Error parsing ADL file\", e);\n      }\n\n      Element identification = new Element(\"identification\", fitsNS);\n      Element identity = new Element(\"identity\", fitsNS);\n      identity.setAttribute(\"format\", \"Audio Decision List\");\n      identity.setAttribute(\"mimetype\", \"text/x-adl\");\n      Element version = new Element(\"version\", fitsNS);\n      version.addContent(adlVersion);\n      identity.addContent(version);\n      // add identity to identification section\n      identification.addContent(identity);\n      // add identification section to root\n      root.addContent(identification);\n\n      Element fileInfo = new Element(\"fileinfo\", fitsNS);\n      Element metadata = new Element(\"metadata\", fitsNS);\n      Element textMetadata = new Element(\"text\", fitsNS);\n\n      Element markupLanguage = new Element(\"markupLanguage\", fitsNS);\n      markupLanguage.addContent(\"EDML\");\n      textMetadata.addContent(markupLanguage);\n\n      if (adlVersion != null) {\n        Element markupLanguageVer = new Element(\"markupLanguageVersion\", fitsNS);\n        markupLanguageVer.addContent(adlVersion);\n        textMetadata.addContent(markupLanguageVer);\n      }\n      if (adlCreator != null) {\n        Element elem = new Element(\"creatingApplicationName\", fitsNS);\n        elem.addContent(adlCreator);\n        fileInfo.addContent(elem);\n      }\n\n      if (adlCreatorVersion != null) {\n        Element elem = new Element(\"creatingApplicationVersion\", fitsNS);\n        elem.addContent(adlCreatorVersion);\n        fileInfo.addContent(elem);\n      }\n\n      // add file info section to root\n      root.addContent(fileInfo);\n      // add to metadata section\n      metadata.addContent(textMetadata);\n      // add metadata section to root\n      root.addContent(metadata);\n    }\n\n    return new Document(root);\n  }\n"}, {"dataset": "nextLine", "exampleID": 7164, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [605], "initializationEnd": [627], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 1451, "focalAPIEnd": 1469, "followUpCheck": "\"q\".equals(line.trim())", "checkType": "IF", "followUpCheckExpressionStart": 1478, "followUpCheckExpressionEnd": 1507, "followUpCheckBlockStart": 1478, "followUpCheckBlockEnd": 2950, "use": ["valueOf(line)"], "useStart": [1630], "useEnd": [1652], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spring-projects/spring-integration-samples/tree/master/intermediate/travel/src/main/java/org/springframework/integration/samples/travel/Main.java", "rawCode": "  /** @param args Not used. */\n  public static void main(String... args) throws Exception {\n\n    final GenericXmlApplicationContext context = new GenericXmlApplicationContext();\n\n    final ConfigurableEnvironment env = context.getEnvironment();\n    boolean mapQuestApiKeyDefined = env.containsProperty(\"mapquest.apikey\");\n\n    if (mapQuestApiKeyDefined) {\n      env.setActiveProfiles(\"mapquest\");\n    }\n\n    context.load(\"classpath:META-INF/spring/*.xml\");\n    context.refresh();\n\n    final TravelGateway travelGateway = context.getBean(\"travelGateway\", TravelGateway.class);\n\n    final Scanner scanner = new Scanner(System.in);\n\n    System.out.println(\n        \"\\n=========================================================\"\n            + \"\\n \"\n            + \"\\n Welcome to the Spring Integration Travel App! \"\n            + \"\\n \"\n            + \"\\n For more information please visit: \"\n            + \"\\n https://www.springsource.org/spring-integration/ \"\n            + \"\\n \"\n            + \"\\n=========================================================\");\n\n    System.out.println(\n        \"Please select the city, for which you would like to get traffic and weather information:\");\n\n    for (City city : City.values()) {\n      System.out.println(String.format(\"\\t%s. %s\", city.getId(), city.getName()));\n    }\n    System.out.println(\"\\tq. Quit the application\");\n    System.out.print(\"Enter your choice: \");\n\n    while (true) {\n      final String input = scanner.nextLine();\n\n      if (\"q\".equals(input.trim())) {\n        System.out.println(\"Exiting application...bye.\");\n        break;\n      } else {\n\n        final Integer cityId = Integer.valueOf(input);\n        final City city = City.getCityForId(cityId);\n\n        final String weatherReply = travelGateway.getWeatherByCity(city);\n\n        System.out.println(\n            \"\\n=========================================================\"\n                + \"\\n Weather:\"\n                + \"\\n=========================================================\");\n        System.out.println(weatherReply);\n\n        if (mapQuestApiKeyDefined) {\n          final String trafficReply = travelGateway.getTrafficByCity(city);\n\n          System.out.println(\n              \"\\n=========================================================\"\n                  + \"\\n Traffic:\"\n                  + \"\\n=========================================================\");\n          System.out.println(trafficReply);\n        } else {\n          LOGGER.warn(\n              \"Skipping Traffic Information call. Did you setup your MapQuest API Key? \"\n                  + \"e.g. by calling:\\n\\n $ mvn exec:java -Dmapquest.apikey=\\\"your_mapquest_api_key_url_decoded\\\"\");\n        }\n\n        System.out.println(\n            \"\\n=========================================================\"\n                + \"\\n Done.\"\n                + \"\\n=========================================================\");\n        System.out.print(\"Enter your choice: \");\n      }\n    }\n\n    scanner.close();\n    context.close();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7165, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [125], "initializationEnd": [149], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 156, "guardExpressionEnd": 185, "guardBlockStart": 156, "guardBlockEnd": 230, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 204, "focalAPIEnd": 222, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(line)", "scanner.close()"], "useStart": [194, 235], "useEnd": [223, 250], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Arolition/iteration5/tree/master/Objectron - Iteration 5/src/model/factory/grid/full/FileInternGridFactory.java", "rawCode": "  private List<String> getLines(InputStream inputstream) {\n    List<String> lines = new ArrayList<>();\n    Scanner scanner = new Scanner(inputstream);\n\n    while (scanner.hasNextLine()) {\n      lines.add(scanner.nextLine());\n    }\n    scanner.close();\n\n    return lines;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7166, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 130, "focalAPIEnd": 143, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseLong(line)", "scanner.nextLine()", "parseLong(line)"], "useStart": [115, 182, 167], "useEnd": [144, 195, 196], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sinjax/trendminer-java/tree/master/hadoop/tools/HadoopTwitterTokenTool/src/main/java/org/openimaj/hadoop/tools/twitter/token/mode/pointwisemi/count/TokenPairUnaryCount.java", "rawCode": "  @Override\n  public void readASCII(Scanner in) throws IOException {\n    super.readASCII(in);\n    this.tok1count = Long.parseLong(in.nextLine());\n    this.tok2count = Long.parseLong(in.nextLine());\n  }\n"}, {"dataset": "nextLine", "exampleID": 7167, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 187, "focalAPIEnd": 205, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bedditor/ohtu-Alarmclock/tree/master/beddit_alarm/src/ohtu/beddit/web/BedditConnectorImpl.java", "rawCode": "  private String readFromStream(InputStream inputStream) {\n    String response = \"\";\n    Scanner scanner = new Scanner(inputStream);\n    while (scanner.hasNextLine()) {\n      response += scanner.nextLine();\n    }\n    return response;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7168, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 26, "guardExpressionEnd": 52, "guardBlockStart": 26, "guardBlockEnd": 80, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 59, "focalAPIEnd": 78, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["error(line)", "scanner.close()"], "useStart": [53, 85], "useEnd": [79, 101], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/GamesCrafters/GamesmanJava/tree/master/GamesmanJava-core/src/main/java/edu/berkeley/gamesman/util/ErrorThread.java", "rawCode": "  public void run() {\n    while (myErrors.hasNext()) error(myErrors.nextLine());\n    myErrors.close();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7169, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [177], "initializationEnd": [199], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 205, "guardExpressionEnd": 228, "guardBlockStart": 205, "guardBlockEnd": 285, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 262, "focalAPIEnd": 276, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["solve(line)"], "useStart": [256], "useEnd": [277], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cielavenir/procon/tree/master/hackerrank/java-stack.java", "rawCode": "  public static void main(String[] args) {\n    tbl = new HashMap<Character, Character>();\n    tbl.put('[', ']');\n    tbl.put('{', '}');\n    tbl.put('(', ')');\n    Scanner cin = new Scanner(System.in);\n    for (; cin.hasNext(); ) {\n      System.out.println(solve(cin.nextLine()));\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7170, "initialization": ["Scanner scanner = new Scanner(File)"], "initializationStart": [174], "initializationEnd": [192], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 152, "tryExpressionEnd": 156, "tryBlockStart": 152, "tryBlockEnd": 347, "catchExpressionStart": 281, "catchExpressionEnd": 313, "catchBlockStart": 281, "catchBlockEnd": 347, "exceptionHandlingCallStart": [321], "exceptionHandlingCallEnd": [340], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 200, "guardExpressionEnd": 225, "guardBlockStart": 200, "guardBlockEnd": 274, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 246, "focalAPIEnd": 264, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(line)"], "useStart": [236], "useEnd": [265], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/angievelinska/Tag-Cloud-Summarizer/tree/master/summarizer/src/main/java/edu/tuhh/summarizer/tagcloud/TagCloud.java", "rawCode": "  public Cloud getExampleCloud() {\n    File input = new File(\"C:/tmp/input.dat\");\n    StringBuilder sb = new StringBuilder();\n    Scanner scanner;\n\n    try {\n      scanner = new Scanner(input);\n      while (scanner.hasNext()) {\n        sb.append(scanner.nextLine());\n      }\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    }\n\n    log.info(sb.toString());\n\n    String[] words = sb.toString().split(\"\\\\s+\");\n    List<String> tags = Arrays.asList(words);\n\n    return generateCloud(40, 20, tags, 10.0);\n  }\n"}, {"dataset": "nextLine", "exampleID": 7171, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [129], "initializationEnd": [151], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["scanner.nextInt()"], "configurationStart": [170], "configurationEnd": [184], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 190, "focalAPIEnd": 205, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SergeStinckwich/AlgoProgS2-Caen/tree/master/Semaine5/InterestsCalculation.java", "rawCode": "  public static BankAccount editBankAccount() {\n    System.out.print(\"1) BankAccount 2) SavingBankAccount=\");\n    Scanner scan = new Scanner(System.in);\n    int result = scan.nextInt();\n    scan.nextLine();\n    if (result == 1) return BankAccount.edit();\n    return SavingsBankAccount.edit();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7172, "initialization": ["Scanner scanner = new Scanner(String)"], "initializationStart": [74], "initializationEnd": [93], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["scanner.nextInt()", "scanner.next()", "scanner.next()", "scanner.nextInt()", "scanner.nextBoolean()", "scanner.nextInt()", "scanner.next()", "scanner.next()"], "configurationStart": [140, 175, 458, 588, 1389, 1728, 2469, 2639], "configurationEnd": [154, 186, 469, 602, 1407, 1742, 2480, 2650], "guardCondition": "!(scanner.hasNextInt())", "guardType": "IF {", "guardExpressionStart": 99, "guardExpressionEnd": 121, "guardBlockStart": 99, "guardBlockEnd": 3219, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 2822, "focalAPIEnd": 2837, "followUpCheck": "line.equals(\"start\")", "checkType": "IF", "followUpCheckExpressionStart": 2921, "followUpCheckExpressionEnd": 2945, "followUpCheckBlockStart": 2921, "followUpCheckBlockEnd": 3213, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NSolberg/Project-Galvatron/tree/master/src/CompleteClient/GUILobby.java", "rawCode": "  @Override\n  public void displayData(String string) {\n    Scanner scan = new Scanner(string);\n    if (scan.hasNextInt()) {\n      int num = scan.nextInt();\n      String cmd = scan.next();\n      if (cmd.equals(\"remove\")) {\n        if (pNames[num].equals(app.userName)) start.setEnabled(false);\n        pNames[num].setText(\"\");\n        pColor[num].setEnabled(false);\n        pConfirm[num].setEnabled(false);\n      } else if (cmd.equals(\"add\")) {\n        cmd = scan.next();\n        pNames[num].setText(cmd);\n        if (pNames[num].getText().equals(app.userName)) pos = num;\n        int c = scan.nextInt();\n        pC[num] = c;\n        switch (c) {\n          case 0:\n            pColor[num].setBackground(Color.RED);\n            break;\n          case 1:\n            pColor[num].setBackground(Color.ORANGE);\n            break;\n          case 2:\n            pColor[num].setBackground(Color.YELLOW);\n            break;\n          case 3:\n            pColor[num].setBackground(Color.GREEN);\n            break;\n          case 4:\n            pColor[num].setBackground(Color.BLUE);\n            break;\n          case 5:\n            pColor[num].setBackground(new Color(143, 0, 255));\n            break;\n          case 6:\n            pColor[num].setBackground(Color.BLACK);\n            break;\n        }\n        pColor[num].setEnabled(true);\n        pConfirm[num].setEnabled(true);\n        boolean val = scan.nextBoolean();\n        if (val) pConfirm[num].setIcon(yes);\n        else pConfirm[num].setIcon(no);\n        leave.setEnabled(true);\n      } else if (cmd.equals(\"rdy\")) {\n        pConfirm[num].setIcon(yes);\n      } else if (cmd.equals(\"nrdy\")) {\n        pConfirm[num].setIcon(no);\n      } else if (cmd.equals(\"col\")) {\n        int c = scan.nextInt();\n        pC[num] = c;\n        switch (c) {\n          case 0:\n            pColor[num].setBackground(Color.RED);\n            break;\n          case 1:\n            pColor[num].setBackground(Color.ORANGE);\n            break;\n          case 2:\n            pColor[num].setBackground(Color.YELLOW);\n            break;\n          case 3:\n            pColor[num].setBackground(Color.GREEN);\n            break;\n          case 4:\n            pColor[num].setBackground(Color.BLUE);\n            break;\n          case 5:\n            pColor[num].setBackground(new Color(143, 0, 255));\n            break;\n          case 6:\n            pColor[num].setBackground(Color.BLACK);\n            break;\n        }\n      }\n    } else {\n      String cmd = scan.next();\n      if (cmd.equals(\"leave\")) app.switchView(1);\n      else if (cmd.equals(\"goodbye\")) app.switchView(0);\n      else if (cmd.equals(\"map\")) {\n        map = scan.next();\n        this.lblMapName.setText(map);\n      } else if (cmd.equals(\"master\")) {\n        this.start.setEnabled(true);\n      } else if (cmd.equals(\"Alert\")) {\n        cmd = scan.nextLine();\n        // JOptionPane.showMessageDialog(null, cmd, \"Alert\", ERROR);\n      } else if (cmd.equals(\"start\")) {\n        app.gameFile = map;\n        String[] names = new String[pNames.length];\n        for (int i = 0; i < 6; i++) {\n          names[i] = pNames[i].getText();\n        }\n        app.switchView(4);\n        ((MapLoader) app.panels[4]).loadMap(map, names, pC);\n      }\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7173, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 223, "focalAPIEnd": 241, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/paul-g/protrade/tree/master/src/org/ic/protrade/score/StatisticsPanel.java", "rawCode": "  private static String getTestString(String filename) {\n\n    Scanner scanner;\n    String test = \"\";\n\n    try {\n      scanner = new Scanner(new FileInputStream(filename));\n\n      while (scanner.hasNext()) {\n        test += scanner.nextLine() + \"\\n\";\n      }\n    } catch (FileNotFoundException e) {\n      // log.error(e.getMessage());\n    }\n\n    return test;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7174, "initialization": ["Scanner scanner = new Scanner(String)"], "initializationStart": [396], "initializationEnd": [420], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 443, "guardExpressionEnd": 472, "guardBlockStart": 443, "guardBlockEnd": 666, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 501, "focalAPIEnd": 519, "followUpCheck": "x < line.length()", "checkType": "LOOP", "followUpCheckExpressionStart": 527, "followUpCheckExpressionEnd": 572, "followUpCheckBlockStart": 527, "followUpCheckBlockEnd": 649, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Kauhsa/javalabra-sokoban/tree/master/project/src/main/java/kauhsa/sokoban/level/yaml/YAMLLevelWorldCreator.java", "rawCode": "  /**\n   * Create new World from String.\n   *\n   * @param worldString String representation of World.\n   * @return fresh copy of World that worldString represents.\n   * @throws InvalidYAMLLevelException if worldString is invalid.\n   */\n  public static World createWorld(String worldString) throws InvalidYAMLLevelException {\n    World world = createEmptyWorld(worldString);\n    Scanner scanner = new Scanner(worldString);\n\n    int y = 0;\n\n    while (scanner.hasNextLine()) {\n      String currentRow = scanner.nextLine();\n      for (int x = 0; x < currentRow.length(); x++) {\n        handlePoint(world, new Point(x, y), currentRow.charAt(x));\n      }\n      y++;\n    }\n\n    if (world.getWorldObjectsOfType(WorldObjectType.PLAYER).isEmpty()) {\n      throw new InvalidYAMLLevelException(\"No players in level\");\n    }\n\n    return world;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7175, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [60], "initializationEnd": [82], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 124, "focalAPIEnd": 137, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["reverse(line)"], "useStart": [164], "useEnd": [178], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/railgunlv5/Poly_Thinking/tree/master/careercup/z/ReverseInWord.java", "rawCode": "  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    while (true) {\n      String input = in.nextLine();\n      System.out.println(reverse(input).toString());\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7176, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 109, "focalAPIEnd": 127, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/msf/configs/tree/master/code/algos2/In.java", "rawCode": "  /** Read and return the next line. */\n  public String readLine() {\n    String line;\n    try {\n      line = scanner.nextLine();\n    } catch (Exception e) {\n      line = null;\n    }\n    return line;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7177, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [3939], "initializationEnd": [3961], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 3973, "focalAPIEnd": 3991, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.nextLine()"], "useStart": [4200], "useEnd": [4218], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kidul/dameproject/tree/master/DameGui/src/de/claussen/gui/GameWindow.java", "rawCode": "  /** startet das Spiel */\n  public void run() {\n    // …ffnet zwei File-Dialoge, um Jars auszuwŠhlen. In diesen Jars wird\n    // dynamisch nach Klassen gesucht, die unsere abstrakte Klasse\n    // Player extended\n    // firstPlayer = Helper.getInstance().loadKI(shell);\n    // secondPlayer = Helper.getInstance().loadKI(shell);\n    firstPlayer = new HumanPlayer();\n    secondPlayer = new HumanPlayer();\n\n    // Per \"Zufall\" bestimmen wer anfŠngt\n    Player temp;\n    int glaskugel = (int) (Math.random() * 2);\n    if (glaskugel == 1) {\n      System.out.println(\"Switching Player\");\n      temp = firstPlayer;\n      firstPlayer = secondPlayer;\n      secondPlayer = temp;\n    }\n\n    firstPlayer.setColor(Player.WHITE);\n    secondPlayer.setColor(Player.BLACK);\n\n    // Style fŸr den ersten Spieler (wei§)\n    StyledText pl1 = new StyledText(statusBar, SWT.NONE);\n    pl1.setText(\"First Player\");\n    StyleRange style1 = new StyleRange();\n    style1.start = 0;\n    style1.length = pl1.getText().length();\n    style1.fontStyle = SWT.BOLD;\n    style1.background = display.getSystemColor(SWT.COLOR_BLACK);\n    style1.foreground = display.getSystemColor(SWT.COLOR_WHITE);\n    pl1.setStyleRange(style1);\n\n    // Versus Label\n    StyledText vs = new StyledText(statusBar, SWT.NONE);\n    // vs.setBackground(display.getSystemColor(SWT.COLOR_WHITE));\n    vs.setForeground(display.getSystemColor(SWT.COLOR_GREEN));\n    vs.setText(\"VS\");\n\n    // Style fŸr den zweiten Player\n    StyledText player2 = new StyledText(statusBar, SWT.NONE);\n    player2.setText(\"Second Player\");\n    StyleRange style2 = new StyleRange();\n    style2.start = 0;\n    style2.length = player2.getText().length();\n    style2.fontStyle = SWT.BOLD;\n    style2.foreground = new Color(display, new RGB(135, 116, 72));\n    style2.background = display.getSystemColor(SWT.COLOR_BLACK);\n    player2.setStyleRange(style2);\n\n    playerMap.put(PlayerColor.WHITE, firstPlayer);\n    playerMap.put(PlayerColor.BLACK, secondPlayer);\n\n    Vector<Turn> oldTurn = null;\n    PlayerColor actualPlayer = PlayerColor.WHITE;\n    boolean win = false;\n\n    // SpielzŸge solange bis jemand gewinnt\n    while (!win) {\n      try {\n\n        /**\n         * NŠchsten Spielerzug berechnen, die AusfŸhrungszeit wird begrenzt, Variable siehe\n         * Helper-Klasse\n         */\n        ExecutorService pool = Executors.newSingleThreadExecutor();\n        TurnCalculator tc = new TurnCalculator(oldTurn, playerMap.get(actualPlayer));\n\n        Future<Vector<Turn>> future = pool.submit(tc);\n        oldTurn =\n            future.get(Helper.getInstance().TIME_TO_CALCULATE, Helper.getInstance().TIME_UNIT);\n\n        // StringBuilder sb = new StringBuilder();\n        // sb.append(\"Turn: \");\n        // if (oldTurn == null) {\n        // // stopping game\n        // // ToDo\n        // }\n        // if (oldTurn.getSource() != null) {\n        // sb.append(oldTurn.getSource().getColumn());\n        // sb.append(oldTurn.getSource().getLine());\n        // }\n        // sb.append(oldTurn.getDestination().getColumn());\n        // sb.append(oldTurn.getDestination().getLine());\n        // if (oldTurn.getRemovedStone() != null) {\n        // sb.append(oldTurn.getRemovedStone().getColumn());\n        // sb.append(oldTurn.getRemovedStone().getLine());\n        // }\n        // System.out.println(sb.toString());\n        // NŠchsten Zug auf dem Spielfeld anzeigen\n        performTurn(oldTurn, actualPlayer);\n        // Spielerwechsel\n        actualPlayer = actualPlayer.toggle();\n      } catch (InterruptedException e) {\n        // tritt niemals ein -.-\n        e.printStackTrace();\n      } catch (ExecutionException e) {\n        if (e.getCause() instanceof InvalidTurnException) {\n          // Spieler behauptet, dass der Zug ungŸltig war\n          System.out.println(actualPlayer + \" says Turn was invalid\");\n          shell.setText(actualPlayer + \" says Turn was invalid\");\n          shell.update();\n          Scanner scanner = new Scanner(System.in);\n          scanner.nextLine();\n          win = true;\n        }\n      } catch (TimeoutException e) {\n        // Spieler hat zu lange Ÿberlegt\n        System.out.println(\"TIME UP\");\n        Scanner scanner = new Scanner(System.in);\n        scanner.nextLine();\n        win = true;\n      }\n    }\n    System.out.println(\"Game Ended\");\n  }\n"}, {"dataset": "nextLine", "exampleID": 7178, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 198, "focalAPIEnd": 216, "followUpCheck": "line.equals(\"1\")", "checkType": "IF", "followUpCheckExpressionStart": 224, "followUpCheckExpressionEnd": 252, "followUpCheckBlockStart": 224, "followUpCheckBlockEnd": 604, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benzeph/rich-man/tree/master/main/java/org/thoughtworks/zeph/rich/map/unit/ToolRoom.java", "rawCode": "  @Override\n  public void doesWhatItNeedToDo(Player player) {\n    Printer.welcomeToToolRoom();\n    while (player.getGamePoint() >= BOTTOM_PRICE && !player.isYourToolBagFull()) {\n      instruction = scanner.nextLine();\n      if (instruction.equals(\"1\")) {\n        player.subtractGamePoint(new Block().getPrice());\n        player.addProp(1);\n      } else if (instruction.equals(\"2\")) {\n        player.subtractGamePoint(new Robot().getPrice());\n        player.addProp(2);\n      } else if (instruction.equals(\"3\")) {\n        player.subtractGamePoint(new Bomb().getPrice());\n        player.addProp(3);\n      }\n    }\n    Printer.youHaveExitToolRoom();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7179, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [194], "initializationEnd": [231], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["println(String)", "exit(int)"], "tryExpressionStart": 90, "tryExpressionEnd": 94, "tryBlockStart": 90, "tryBlockEnd": 1059, "catchExpressionStart": 947, "catchExpressionEnd": 982, "catchBlockStart": 947, "catchBlockEnd": 1059, "exceptionHandlingCallStart": [990, 1038], "exceptionHandlingCallEnd": [1030, 1052], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 336, "focalAPIEnd": 351, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["line.indexOf(String)", "line.substring(int)"], "useStart": [398, 445], "useEnd": [421, 466], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/carmi/rsa/tree/master/code/data/FormatNewData.java", "rawCode": "  public static void main(String[] args) {\n\n    String[] lines = new String[125723];\n\n    try {\n      // Getting the file\n      String fileName = \"formatted-certs-all.csv\";\n      Scanner file = new Scanner(new FileReader(fileName));\n      // Looping through the file\n      for (int i = 0; i < lines.length; i++) {\n        String line = file.nextLine();\n        String add = \"\";\n        int start = line.indexOf(\"Modulus\");\n        String rest = line.substring(start);\n        start = rest.indexOf(\":\");\n        rest = rest.substring(start);\n        String modulus = (rest.split(\",\")[0]).replaceAll(\":\", \"\");\n        String[] splits = line.split(\",\");\n        add = add + splits[0] + \",\";\n        add = add + splits[2] + \",\";\n        add = add + modulus + \"\\n\";\n        lines[i] = add;\n      }\n\n      for (int i = 0; i < lines.length; i++) {\n        System.out.print(lines[i]);\n      }\n\n    }\n\n    // Catching a FileNotFoundException exception\n    catch (FileNotFoundException fnfe) {\n      System.out.println(\"File was not found\");\n      System.exit(0);\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7180, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 454, "focalAPIEnd": 467, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.nextLine()"], "useStart": [473], "useEnd": [486], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yetanotherbadboyz/fullydressed/tree/master/theoverlookhotel/src/UnitTypes/Sistem.java", "rawCode": "  public boolean menuOtelListele(Sistem sistem) {\n    for (Integer i : sistem.otelListesi) {\n      System.out.println(\n          \"\\nOtel Adı: \"\n              + ((Otel) Facade.getInstance().get(i, Otel.class)).isimGetir()\n              + \"\\nOtel Adresi: \"\n              + ((Otel) Facade.getInstance().get(i, Otel.class)).adresGetir()\n              + \"\\nOtel ID: \"\n              + ((Otel) Facade.getInstance().get(i, Otel.class)).otelIDGetir());\n    }\n    in.nextLine();\n    in.nextLine();\n\n    return true;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7181, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 173, "focalAPIEnd": 191, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["convertString(line,String)", "scanner.nextLine()", "convertString(line,String)", "readAndSetAddress(scanner,Person)"], "useStart": [159, 282, 268, 367], "useEnd": [196, 300, 305, 396], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/amorfis/hibernate/tree/master/hibernate-envers/src/demo/java/org/hibernate/envers/demo/TestConsole.java", "rawCode": "  private Person readNewPerson(PrintStream out, Scanner scanner) {\n    Person p = new Person();\n\n    out.print(\"Person name (NULL for null): \");\n    p.setName(convertString(scanner.nextLine(), \"\"));\n\n    out.print(\"Person surname (NULL for null): \");\n    p.setSurname(convertString(scanner.nextLine(), \"\"));\n\n    out.print(\"Person address id (NULL for null): \");\n    readAndSetAddress(scanner, p);\n\n    return p;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7182, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 113, "focalAPIEnd": 128, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["List<String>.add(line)"], "useStart": [134], "useEnd": [155], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/baronfel/Emulator/tree/master/src/utility/InstructionParser.java", "rawCode": "  private static void InvalidInstruction(String name) {\n    String body = \"Line: \" + lineCounter + \"\\t\" + name + file.nextLine();\n    invalidlist.add(body);\n    invalidFlag = true;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7183, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [1405], "initializationEnd": [1427], "hasTryCatch": 1, "exceptionType": "ParserConfigurationException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 245, "tryExpressionEnd": 249, "tryBlockStart": 245, "tryBlockEnd": 3853, "catchExpressionStart": 3518, "catchExpressionEnd": 3557, "catchBlockStart": 3518, "catchBlockEnd": 3611, "exceptionHandlingCallStart": [3565], "exceptionHandlingCallEnd": [3584], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 1539, "focalAPIEnd": 1557, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Document.createTextNode(line)", "setNodeValue(line)", "initCurrentClient(String,line,String,String,String)"], "useStart": [1592, 1639, 2628], "useEnd": [1620, 1682, 2687], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/haijunq/dblike/tree/master/src/dblike/client/service/ClientConfig.java", "rawCode": "  /**\n   * This is to load the information of the current user from the xml file.\n   *\n   * @return\n   */\n  public static boolean loadCurrentUser() throws Exception {\n    DocumentBuilderFactory domfac = DocumentBuilderFactory.newInstance();\n    try {\n      DocumentBuilder dombuilder = domfac.newDocumentBuilder();\n      System.out.println(\"ClientCfg/users/\" + getCurrentClient().getClientID() + \"/user.xml\");\n      InputStream fis =\n          new FileInputStream(\"ClientCfg/users/\" + getCurrentClient().getClientID() + \"/user.xml\");\n      System.out.println(fis);\n      Document doc = dombuilder.parse(fis);\n      Element root = doc.getDocumentElement();\n      Node user = root.getFirstChild();\n      if (user != null) {\n        String username = \"\";\n        String folderPath = \"\";\n        String deviceID = \"\";\n        String ip = \"\";\n        String port = \"\";\n        for (Node node = user; node != null; node = node.getNextSibling()) {\n          if (node.getNodeType() == Node.ELEMENT_NODE) {\n            if (node.getNodeName().equals(\"username\")) {\n              username = node.getFirstChild().getNodeValue();\n              System.out.println(username);\n            }\n            if (node.getNodeName().equals(\"deviceID\")) {\n              deviceID = node.getFirstChild() == null ? \"\" : node.getFirstChild().getNodeValue();\n              if (deviceID.equals(\"\")) {\n                Scanner scanDID = new Scanner(System.in);\n                System.out.println(\"First time login, must input the Device ID:\");\n                deviceID = scanDID.nextLine();\n                node.appendChild(doc.createTextNode(deviceID));\n                node.getFirstChild().setNodeValue(deviceID);\n              }\n            }\n            if (node.getNodeName().equals(\"folderPath\")) {\n              folderPath = node.getFirstChild() == null ? \"\" : node.getFirstChild().getNodeValue();\n              if (folderPath.equals(\"\")) {\n                Scanner scanFP = new Scanner(System.in);\n                System.out.println(\"First time login, must specify a sync Folder:\");\n                folderPath = scanFP.nextLine();\n                folderPath = FileInfoService.getAbsolutePathName(folderPath) + \"/\";\n                node.appendChild(doc.createTextNode(folderPath));\n                node.getFirstChild().setNodeValue(folderPath);\n              }\n            }\n\n            if (node.getNodeName().equals(\"IP\")) {\n              ip = node.getFirstChild().getNodeValue();\n            }\n\n            if (node.getNodeName().equals(\"port\")) {\n              port = node.getFirstChild().getNodeValue();\n            }\n          }\n        }\n\n        initCurrentClient(username, deviceID, folderPath, ip, port);\n\n        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n        Transformer transformer = null;\n        try {\n          transformer = transformerFactory.newTransformer();\n        } catch (TransformerConfigurationException ex) {\n          Logger.getLogger(ClientConfig.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        DOMSource source = new DOMSource(doc);\n        StreamResult result =\n            new StreamResult(\n                new File(\"ClientCfg/users/\" + getCurrentClient().getClientID() + \"/user.xml\"));\n        try {\n          transformer.transform(source, result);\n        } catch (TransformerException ex) {\n          Logger.getLogger(ClientConfig.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return true;\n      } else {\n        return false;\n      }\n    } catch (ParserConfigurationException e) {\n      e.printStackTrace();\n      return false;\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n      return false;\n    } catch (SAXException e) {\n      e.printStackTrace();\n      return false;\n    } catch (IOException e) {\n      e.printStackTrace();\n      return false;\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7184, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 52, "focalAPIEnd": 65, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.nextLine()", "scanner.nextLine()", "scanner.nextLine()", "scanner.nextLine()", "scanner.nextInt()", "scanner.nextInt()"], "useStart": [183, 348, 439, 612, 693, 855], "useEnd": [196, 361, 452, 625, 705, 867], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yetanotherbadboyz/fullydressed/tree/master/theoverlookhotel/src/UnitTypes/Sistem.java", "rawCode": "  public boolean menuOtelYarat(Sistem sistem) {\n    in.nextLine();\n    Otel _otel = sistem.otelEklemeIsleminiBaslat();\n    System.out.println(\"Otel Adı giriniz: \");\n    String __ad = in.nextLine();\n    while (sistem.otelGetirIsim(__ad) != null) {\n      System.err.println(\"Aynı isimde kayıtlı otel adı var, başka bir tane giriniz: \");\n      __ad = in.nextLine();\n    }\n    System.out.println(\"Odel Adresi giriniz: \");\n    String __adres = in.nextLine();\n    while (sistem.otelGetirAdres(__adres) != null) {\n      System.err.println(\"Aynı adreste kayıtlı otel adı var, başka bir tane giriniz: \");\n      __adres = in.nextLine();\n    }\n    System.out.println(\"Otel ID giriniz: \");\n    int __id = in.nextInt();\n\n    while (sistem.otelGetirID(__id) != null) {\n      System.err.println(\"Aynı ID'de kayıtlı otel adı var, başka bir tane giriniz: \");\n      __id = in.nextInt();\n    }\n    sistem.otelOzellikleriniGir(_otel, __ad, __adres, __id);\n    return true;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7185, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 186, "focalAPIEnd": 201, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brunnurs/reutersMahout/tree/master/reutersStorm/src/main/java/com/zuehlke/reuters/storm/KeyboardSpout.java", "rawCode": "  public void nextTuple() {\n    Scanner scan = new Scanner(System.in);\n    while (scan.hasNext()) {\n      collector.emit(\n          new Values(Long.toString(System.currentTimeMillis()), scan.nextLine(), \"manual\"));\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7186, "initialization": ["Scanner scanner = new Scanner(*,String)"], "initializationStart": [235], "initializationEnd": [303], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 362, "guardExpressionEnd": 382, "guardBlockStart": 362, "guardBlockEnd": 440, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 418, "focalAPIEnd": 431, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["valueOf(line)", "scanner.close()"], "useStart": [405, 445], "useEnd": [432, 455], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/analyticsUfcg/recEventos/tree/master/src/javaCode/collection/util/IOManager.java", "rawCode": "  /**\n   * Read the file with all ids of the given object\n   *\n   * @param objectType\n   * @return\n   * @throws IOException\n   */\n  public static TreeSet<Long> readObjectAllIds(String objectType) throws IOException {\n\n    Scanner in = new Scanner(new File(getObjectAllIdsFilename(objectType)), CHAR_SET);\n\n    TreeSet<Long> objectIds = new TreeSet<Long>();\n\n    while (in.hasNext()) {\n      objectIds.add(Long.valueOf(in.nextLine()));\n    }\n    in.close();\n\n    return objectIds;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7187, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 453, "focalAPIEnd": 469, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["split(line)", "scanner.nextLine()", "split(line)", "scanner.nextLine()", "split(line)"], "useStart": [447, 696, 690, 1007, 1001], "useEnd": [470, 712, 713, 1023, 1024], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/efruchter/GATECH/tree/master/CS3240/MiniRE/src/project/phase2/ll1parsergenerator/dfastuff/Parser.java", "rawCode": "  /**\n   * Generates a NFA that detects tokens as defined in the input stream.\n   *\n   * @param input A scanner containing the input stream\n   * @return The NFA generated from the scanner\n   */\n  public static NFA parseNFA(Scanner input) {\n    NFA sum = null;\n    String[] s = null;\n    NFA identifier;\n    CharacterClass def;\n    predefined = new LinkedList<CharacterClass>();\n\n    // finding the first predefined class\n    while (s == null) s = split(input.nextLine());\n\n    // generating the predefined character classes\n    while (input.hasNext() && s != null) {\n      line = s[1];\n      index = 0;\n      def = charClass();\n      def.setName(s[0]);\n      predefined.add(def);\n      s = split(input.nextLine());\n    }\n\n    // printing out predefined character classes\n    if (DEBUG)\n      for (CharacterClass c : predefined)\n        System.out.println(c.getName() + \" \" + c.getClassDescriptor());\n\n    // Generating the NFA for each token and unioning them.\n    while (input.hasNext()) {\n      s = split(input.nextLine());\n      if (s != null) {\n        line = s[1];\n        index = 0;\n        identifier = regEx();\n        identifier.setGoalLabels(s[0]);\n        if (sum == null) sum = identifier;\n        else sum = (NFA) sum.union(identifier);\n      }\n    }\n    return sum;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7188, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 140, "focalAPIEnd": 153, "followUpCheck": "line.charAt(j) == ' '", "checkType": "IF", "followUpCheckExpressionStart": 200, "followUpCheckExpressionEnd": 226, "followUpCheckBlockStart": 200, "followUpCheckBlockEnd": 329, "use": ["scanner.nextLine()", "line.split(String)"], "useStart": [417, 452], "useEnd": [430, 467], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/abunyea/robotdowneyjr/tree/master/server/Board.java", "rawCode": "  public boolean readConfig(Scanner sc) {\n    for (int i = 0; i < 17; i++) {\n      if (!sc.hasNextLine()) return false;\n      String line = sc.nextLine();\n      for (int j = 0; j < 25; j++) {\n        if (line.charAt(j) == ' ') {\n          board[i][j] = -1;\n        } else {\n          board[i][j] = line.charAt(j) - '0';\n        }\n      }\n    }\n    if (!sc.hasNextLine()) {\n      return false;\n    }\n    String line = sc.nextLine();\n    String[] part = line.split(\" \");\n    if (part.length != 5) {\n      return false;\n    }\n    try {\n      timeLimit[0] = Integer.parseInt(part[0]);\n      timeLimit[1] = Integer.parseInt(part[1]);\n      specialsLeft[0] = Integer.parseInt(part[2]);\n      specialsLeft[1] = Integer.parseInt(part[3]);\n      turn = Integer.parseInt(part[4]);\n      if (turn < 1 || turn > 2) return false;\n    } catch (Exception e) {\n      return false;\n    }\n    return true;\n  }\n"}, {"dataset": "nextLine", "exampleID": 7189, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["scanner.nextInt()"], "configurationStart": [417], "configurationEnd": [432], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 440, "focalAPIEnd": 456, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/einar90/fellesprosjekt/tree/master/src/no/ntnu/gruppe47/CalendarSystem.java", "rawCode": "  private void deleteAppointment() {\n    ArrayList<Appointment> appointments = Appointment.getAllFor(user);\n    System.out.println(\"Please select the appointment you want to delete:\");\n    for (int i = 0; i < appointments.size(); i++) {\n      System.out.println(i + \": \" + appointments.get(i));\n    }\n    int valg = -1;\n    while (valg < 0 || valg >= appointments.size()) {\n      System.out.print(\"> \");\n      valg = input.nextInt();\n      input.nextLine();\n      if (valg < 0 || valg >= appointments.size())\n        System.out.println(\"Your choise was invalid. Pease try again.\");\n    }\n    user.deleteAppointment(appointments.get(valg));\n    System.out.println(\"Successfully deleted appointment!\");\n    appointmentManager();\n  }\n"}, {"dataset": "nextLine", "exampleID": 7190, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [278], "initializationEnd": [299], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 305, "guardExpressionEnd": 367, "guardBlockStart": 305, "guardBlockEnd": 401, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 376, "focalAPIEnd": 394, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.hasNext()"], "useStart": [413], "useEnd": [430], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/erikw/cs142a_labs/tree/master/src/test/TestFiles.java", "rawCode": "  /**\n   * Read the contents from a stream to a string\n   *\n   * @param inStream The stream to read from.\n   * @param skipLines Number of lines to skip.\n   * @return The read string.\n   */\n  public String slurpStream(InputStream inStream, int skipLines) {\n    Scanner scanner = new Scanner(inStream);\n    for (int i = 0; scanner.hasNextLine() && (i < skipLines); ++i) {\n      scanner.nextLine();\n    }\n    return scanner.hasNext() ? scanner.useDelimiter(\"\\\\Z\").next() : \"\";\n  }\n"}, {"dataset": "nextLine", "exampleID": 7191, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 877, "focalAPIEnd": 890, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["MonopVars.setVersion(line)", "scanner.nextLine()", "scanner.nextInt()", "scanner.nextInt()", "scanner.nextInt()", "scanner.nextInt()", "scanner.nextLine()", "scanner.nextLine()"], "useStart": [897, 1027, 1195, 1379, 1578, 1755, 1815, 2069], "useEnd": [921, 1040, 1207, 1391, 1590, 1767, 1828, 2082], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bcapps/ap-computer-science/tree/master/projects/monopoly_v2/MonopolyDataReader.java", "rawCode": "  /**\n   * Reads the set of data for the MonopVars object<br>\n   *\n   * <p>Format for a MonopVars data should appear as follows:<br>\n   * *game name* - String<br>\n   * *currency symbol* - String<br>\n   * (All the following ints appear on the same line)<br>\n   * *go amount* *starting money amount* *jail bail fee* *number of dice sides* - all ints<br>\n   * *monopoly color #1* - String<br>\n   * *monopoly color #2* - String<br>\n   * ...<br>\n   * *monopoly color #8* - String\n   *\n   * @param in the scanner that scans the data\n   * @param vars the MonopVars object\n   */\n  public void readVarsData(Scanner in, MonopVars vars) throws BadDataException {\n    String version, curSymbol;\n    int goAmount, startAmount, jailBailFee, numDiceSides;\n    String[] colors = new String[8];\n\n    if (!in.hasNextLine()) throw new BadDataException(\"Missing version name\");\n    else version = in.nextLine();\n\n    vars.setVersion(version);\n\n    if (!in.hasNextLine()) throw new BadDataException(\"Missing currency symbol\");\n    else curSymbol = in.nextLine();\n\n    vars.setCurrencySymbol(curSymbol);\n\n    if (!in.hasNextInt()) throw new BadDataException(\"Missing the amount for passing go.\");\n    else goAmount = in.nextInt();\n\n    vars.setGoAmount(goAmount);\n\n    if (!in.hasNextInt())\n      throw new BadDataException(\"Missing the amount of money a player starts with.\");\n    else startAmount = in.nextInt();\n\n    vars.setStartingMoneyAmount(startAmount);\n\n    if (!in.hasNextInt())\n      throw new BadDataException(\"Missing the amount for the fee to get out of jail.\");\n    else jailBailFee = in.nextInt();\n\n    vars.setJailBailFee(jailBailFee);\n\n    if (!in.hasNextInt()) throw new BadDataException(\"Missing the number of sides for the dice.\");\n    else numDiceSides = in.nextInt();\n\n    vars.setNumDiceSides(numDiceSides);\n\n    in.nextLine();\n\n    for (int i = 0; i < colors.length; i++) {\n      if (!in.hasNextLine())\n        throw new BadDataException(\n            \"Missing the \" + (i + 1) + \"\" + Monopoly.getSuffix(i + 1) + \" Monopoly color.\");\n      else colors[i] = new String(in.nextLine());\n    } // end for\n\n    vars.setMonopolyColors(colors);\n  } // end readVarsData method\n"}, {"dataset": "nextLine", "exampleID": 7192, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [421], "initializationEnd": [443], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 994, "focalAPIEnd": 1007, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Verifier(line)"], "useStart": [981], "useEnd": [1008], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tcz001/SNSCrawlerOSGiFramework/tree/master/ScribeOAuthAPIBundle/src/main/java/org/scribe/examples/LiveExample.java", "rawCode": "  public static void main(String[] args) {\n    // Replace these with your own api key and secret\n    String apiKey = \"\";\n    String apiSecret = \"\";\n    OAuthService service =\n        new ServiceBuilder()\n            .provider(LiveApi.class)\n            .apiKey(apiKey)\n            .apiSecret(apiSecret)\n            .scope(\"wl.basic\")\n            .callback(\"http://localhost:9000/\")\n            .build();\n    Scanner in = new Scanner(System.in);\n\n    System.out.println(\"=== Windows Live's OAuth Workflow ===\");\n    System.out.println();\n\n    // Obtain the Authorization URL\n    System.out.println(\"Fetching the Authorization URL...\");\n    String authorizationUrl = service.getAuthorizationUrl(EMPTY_TOKEN);\n    System.out.println(\"Got the Authorization URL!\");\n    System.out.println(\"Now go and authorize Scribe here:\");\n    System.out.println(authorizationUrl);\n    System.out.println(\"And paste the authorization code here\");\n    System.out.print(\">>\");\n    Verifier verifier = new Verifier(in.nextLine());\n    System.out.println();\n\n    // Trade the Request Token and Verfier for the Access Token\n    System.out.println(\"Trading the Request Token for an Access Token...\");\n    Token accessToken = service.getAccessToken(EMPTY_TOKEN, verifier);\n    System.out.println(\"Got the Access Token!\");\n    System.out.println(\"(if your curious it looks like this: \" + accessToken + \" )\");\n    System.out.println();\n\n    // Now let's go and ask for a protected resource!\n    System.out.println(\"Now we're going to access a protected resource...\");\n    OAuthRequest request =\n        new OAuthRequest(Verb.GET, PROTECTED_RESOURCE_URL + accessToken.getToken());\n    service.signRequest(accessToken, request);\n    Response response = request.send();\n    System.out.println(\"Got it! Lets see what we found...\");\n    System.out.println();\n    System.out.println(response.getCode());\n    System.out.println(response.getBody());\n\n    System.out.println();\n    System.out.println(\"Thats it man! Go and build something awesome with Scribe! :)\");\n  }\n"}, {"dataset": "nextLine", "exampleID": 7193, "initialization": ["Scanner scanner = new Scanner(String)"], "initializationStart": [901], "initializationEnd": [921], "hasTryCatch": 1, "exceptionType": "CoreException", "exceptionHandlingCall": ["log(*,boolean)"], "tryExpressionStart": 483, "tryExpressionEnd": 487, "tryBlockStart": 483, "tryBlockEnd": 3178, "catchExpressionStart": 3108, "catchExpressionEnd": 3132, "catchBlockStart": 3108, "catchBlockEnd": 3178, "exceptionHandlingCallStart": [3140], "exceptionHandlingCallEnd": [3171], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 933, "guardExpressionEnd": 962, "guardBlockStart": 933, "guardBlockEnd": 1366, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 991, "focalAPIEnd": 1009, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["line.indexOf(*)", "line.substring(*)", "scanner.close()"], "useStart": [1072, 1210, 1377], "useEnd": [1122, 1279, 1392], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/acceleo/tree/master/plugins/org.eclipse.acceleo.ide.ui/src/org/eclipse/acceleo/internal/ide/ui/editors/template/utils/JavaServicesUtils.java", "rawCode": "  /**\n   * Generates an Acceleo module for a given compilation unit.\n   *\n   * @param iCompilationUnit The compilation unit\n   * @param monitor The progress monitor\n   */\n  public static void generateAcceleoServicesModule(\n      ICompilationUnit iCompilationUnit, IProgressMonitor monitor) {\n    monitor.subTask(\n        AcceleoUIMessages.getString(\n            \"JavaServiceUtils.GenerateAcceleoModuleWrapper\")); // $NON-NLS-1$\n    List<String> nsURIs = new ArrayList<String>();\n    try {\n      IType[] types = iCompilationUnit.getTypes();\n      for (IType iType : types) {\n        ISourceRange javadocRange = iType.getJavadocRange();\n        if (javadocRange != null) {\n          String javadoc =\n              iCompilationUnit\n                  .getOpenable()\n                  .getBuffer()\n                  .getText(javadocRange.getOffset(), javadocRange.getLength());\n          Scanner scanner = new Scanner(javadoc);\n          while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (javadoc != null) {\n              int index = line.indexOf(IAcceleoConstants.JAVADOC_TAG_NS_URI);\n              if (index != -1) {\n                String trimmed =\n                    line.substring(index + IAcceleoConstants.JAVADOC_TAG_NS_URI.length()).trim();\n                nsURIs.add(trimmed);\n              }\n            }\n          }\n          scanner.close();\n        }\n      }\n\n      // Write the file\n      IResource resource = iCompilationUnit.getResource();\n      if (resource instanceof IFile) {\n        IFile javaFile = (IFile) resource;\n        String moduleName = javaFile.getName();\n        if (moduleName.endsWith(\".java\")) { // $NON-NLS-1$\n          moduleName =\n              moduleName.substring(0, moduleName.length() - \".java\".length()); // $NON-NLS-1$\n        }\n        String fileName = moduleName;\n        moduleName = moduleName + '.' + IAcceleoConstants.MTL_FILE_EXTENSION;\n        IContainer parent = javaFile.getParent();\n        IFile file =\n            parent.getFile(\n                new Path(moduleName.substring(0, 1).toLowerCase() + moduleName.substring(1)));\n\n        String content = JavaServicesUtils.getFileContent(iCompilationUnit, fileName, nsURIs);\n\n        ByteArrayInputStream source = new ByteArrayInputStream(content.getBytes());\n        if (file.exists()) {\n          InputStream prevVersionStream = file.getContents();\n          boolean sameContent = false;\n          byte[] oldContent;\n          try {\n            oldContent = ByteStreams.toByteArray(prevVersionStream);\n            sameContent = Arrays.equals(content.getBytes(), oldContent);\n          } catch (IOException e) {\n            /*\n             * If we have an IOException we'll consider the content is not the same.\n             */\n          } finally {\n            Closeables.closeQuietly(prevVersionStream);\n          }\n          if (!sameContent) {\n            file.setContents(source, true, false, monitor);\n          }\n        } else {\n          file.create(source, true, monitor);\n        }\n      }\n    } catch (JavaModelException e) {\n      // do not log\n    } catch (CoreException e) {\n      AcceleoUIActivator.log(e, true);\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7194, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["save()"], "tryExpressionStart": 121, "tryExpressionEnd": 161, "tryBlockStart": 121, "tryBlockEnd": 430, "catchExpressionStart": 487, "catchExpressionEnd": 520, "catchBlockStart": 487, "catchBlockEnd": 545, "exceptionHandlingCallStart": [471], "exceptionHandlingCallEnd": [477], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 173, "guardExpressionEnd": 200, "guardBlockStart": 173, "guardBlockEnd": 420, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 229, "focalAPIEnd": 245, "followUpCheck": "line.length() > 0", "checkType": "IF", "followUpCheckExpressionStart": 280, "followUpCheckExpressionEnd": 302, "followUpCheckBlockStart": 280, "followUpCheckBlockEnd": 408, "use": ["ArrayList<String>.add(line)"], "useStart": [363], "useEnd": [377], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SpoutDev/Spout/tree/master/api/src/main/java/org/spout/api/util/ListFile.java", "rawCode": "  /** Reloads from the file. */\n  public void load() {\n    synchronized (list) {\n      list.clear();\n      try {\n        try (Scanner input = new Scanner(file)) {\n          while (input.hasNextLine()) {\n            String line = input.nextLine().trim().toLowerCase();\n            if (line.length() > 0) {\n              if (!list.contains(line)) {\n                list.add(line);\n              }\n            }\n          }\n        }\n        Collections.sort(list);\n        save();\n      } catch (FileNotFoundException ex) {\n        save();\n      }\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7195, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [1298], "initializationEnd": [1313], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 1355, "guardExpressionEnd": 1390, "guardBlockStart": 1355, "guardBlockEnd": 1529, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 1414, "focalAPIEnd": 1427, "followUpCheck": "line.equals(\"level\" + level)", "checkType": "IF", "followUpCheckExpressionStart": 1468, "followUpCheckExpressionEnd": 1500, "followUpCheckBlockStart": 1468, "followUpCheckBlockEnd": 1521, "use": ["scanner.nextLine()", "scanner.close()"], "useStart": [1746, 1899], "useEnd": [1759, 1909], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/withtwist/TheAdventure/tree/master/TheAdventure/src/se/chalmers/kangaroo/io/Highscore.java", "rawCode": "  /**\n   * When a level is finished this should be called. Will automatically add the player to the\n   * highscore if the time is low enough.\n   *\n   * @param playerName , the name appearing on the highscore\n   * @param level , the number of the level\n   * @param time , the time in millis\n   */\n  public void setHighscore(String playerName, int level, int time, int nbrOfDeaths) {\n    int[] times = getTimes(level);\n    String[] names = getNames(level);\n    int[] deaths = getDeaths(level);\n\n    if (times[nbrOfScores - 1] > time) {\n      times[nbrOfScores - 1] = time;\n      names[nbrOfScores - 1] = playerName;\n      deaths[nbrOfScores - 1] = nbrOfDeaths;\n    }\n    /*\n     * Since it already should be sorted I only need to make one bubbleSort\n     * move\n     */\n    for (int i = times.length - 1; i > 0; i--) {\n      if (times[i] < times[i - 1]) {\n        int tmpTime = times[i];\n        times[i] = times[i - 1];\n        times[i - 1] = tmpTime;\n\n        String tmpName = names[i];\n        names[i] = names[i - 1];\n        names[i - 1] = tmpName;\n\n        int tmpDeath = deaths[i];\n        deaths[i] = deaths[i - 1];\n        deaths[i - 1] = tmpDeath;\n      }\n    }\n    StringBuilder sb = new StringBuilder();\n    try {\n      InputStream in = new FileInputStream(FILE_NAME);\n      Scanner sc = new Scanner(in);\n      boolean jumpToLevel = true;\n      while (sc.hasNext() && jumpToLevel) {\n        String tmp = sc.nextLine();\n        sb.append(tmp + \"\\n\");\n        if (tmp.equals(\"level\" + level)) jumpToLevel = false;\n      }\n      for (int i = 0; i < names.length; i++) {\n        sb.append(names[i] + \" \" + times[i] + \" \" + deaths[i] + \" \");\n      }\n      jumpToLevel = true;\n      while (sc.hasNext() && jumpToLevel)\n        jumpToLevel = !sc.nextLine().equals(\"level\" + (level + 1));\n      sb.append(\"\\nlevel\" + (level + 1));\n      while (sc.hasNext()) sb.append(\"\\n\" + sc.nextLine());\n      sc.close();\n      in.close();\n\n      /* Write the modified String to the file*/\n      Writer w = new FileWriter(FILE_NAME);\n      w.write(sb.toString());\n      w.close();\n    } catch (IOException io) {\n\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7196, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [529], "initializationEnd": [566], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 499, "tryExpressionEnd": 503, "tryBlockStart": 499, "tryBlockEnd": 951, "catchExpressionStart": 861, "catchExpressionEnd": 881, "catchBlockStart": 861, "catchBlockEnd": 951, "exceptionHandlingCallStart": [925], "exceptionHandlingCallEnd": [944], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNext()", "guardType": "LOOP {", "guardExpressionStart": 574, "guardExpressionEnd": 599, "guardBlockStart": 574, "guardBlockEnd": 854, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 624, "focalAPIEnd": 642, "followUpCheck": "line.startsWith(\"/dev/block/vold/\")", "checkType": "IF", "followUpCheckExpressionStart": 653, "followUpCheckExpressionEnd": 693, "followUpCheckBlockStart": 653, "followUpCheckBlockEnd": 846, "use": ["line.split(String)"], "useStart": [730], "useEnd": [745], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fraggel/RecoveryExecuter/tree/master/src/com/fraggel/recoveryexecuter/pro/StorageOptions.java", "rawCode": "  private static void readMountsFile() {\n    /*\n     * Scan the /proc/mounts file and look for lines like this:\n     * /dev/block/vold/179:1 /mnt/sdcard vfat rw,dirsync,nosuid,nodev,noexec,relatime,uid=1000,gid=1015,fmask=0602,dmask=0602,allow_utime=0020,codepage=cp437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-ro 0 0\n     *\n     * When one is found, split it into its elements\n     * and then pull out the path to the that mount point\n     * and add it to the arraylist\n     */\n\n    try {\n      Scanner scanner = new Scanner(new File(\"/proc/mounts\"));\n      while (scanner.hasNext()) {\n        String line = scanner.nextLine();\n\n        if (line.startsWith(\"/dev/block/vold/\")) {\n          String[] lineElements = line.split(\" \");\n          lineElements[1].replaceAll(\":.*$\", \"\");\n          mMounts.add(lineElements[1]);\n        }\n      }\n    } catch (Exception e) {\n      // Auto-generated catch block\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7197, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 99, "focalAPIEnd": 117, "followUpCheck": "line.equals(\"add\")", "checkType": "IF", "followUpCheckExpressionStart": 126, "followUpCheckExpressionEnd": 152, "followUpCheckBlockStart": 126, "followUpCheckBlockEnd": 610, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eomjinyoung/Java41/tree/master/java01/src/net/bitacademy/java41/step07/RedApp01.java", "rawCode": "  public void execute() {\n    while (true) {\n      System.out.print(\"명령>\");\n      String command = scanner.nextLine();\n\n      if (command.equals(\"add\")) {\n\n        add();\n      } else if (command.equals(\"list\")) {\n        System.out.println(\"멤버 목록 출력!\");\n      } else if (command.equals(\"view\")) {\n        System.out.println(\"멤버 상세정보 출력!\");\n      } else if (command.equals(\"update\")) {\n        System.out.println(\"멤버 정보 변경!\");\n      } else if (command.equals(\"delete\")) {\n        System.out.println(\"멤버 삭제!\");\n      } else if (command.equals(\"quit\")) {\n        System.out.println(\"안녕!\");\n        break;\n      }\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7198, "initialization": ["Scanner scanner = new Scanner(*)"], "initializationStart": [375], "initializationEnd": [436], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "scanner.hasNextLine()", "guardType": "LOOP {", "guardExpressionStart": 690, "guardExpressionEnd": 730, "guardBlockStart": 690, "guardBlockEnd": 1016, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 746, "focalAPIEnd": 761, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.nextLine()"], "useStart": [1064], "useEnd": [1079], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gufi/OpenLogViewer/tree/master/src/main/java/org/diyefi/openlogviewer/decoder/CSVTypeLog.java", "rawCode": "  /**\n   * Decodes a CSV type of text file, the first ten lines are parsed individually to detect the\n   * delimiter type\n   *\n   * <p>accepted types of delimiters are TAB, comma, ; , : and \\ this decoder does not yet support\n   * markers, it will skip them\n   *\n   * @throws IOException\n   */\n  protected final void decodeLog() throws IOException {\n    final Scanner scan = new Scanner(new BufferedReader(new FileReader(getLogFile())));\n    final String delimiter = scanForDelimiter();\n\n    String[] splitLine;\n    String[] headers = new String[1];\n\n    int finalAndInitialLength = Utilities.countBytes(getLogFile(), (byte) '\\n');\n\n    String line = \"\";\n    boolean headerSet = false;\n    while (scan.hasNextLine() && !headerSet) {\n      line = scan.nextLine();\n      splitLine = line.split(delimiter);\n\n      if (splitLine.length == fieldCount) {\n        headers = splitLine;\n        this.setDecodedLog(new GenericLog(splitLine, finalAndInitialLength, LOAD_FACTOR, labels));\n        headerSet = true;\n      }\n    }\n\n    while (scan.hasNextLine()) {\n      line = scan.nextLine();\n      splitLine = line.split(delimiter);\n      this.getDecodedLog().incrementPosition();\n      if (splitLine.length == fieldCount) {\n        for (int x = 0; x < splitLine.length; x++) {\n          this.getDecodedLog().addValue(headers[x], Double.parseDouble(splitLine[x]));\n        }\n      }\n    }\n  }\n"}, {"dataset": "nextLine", "exampleID": 7199, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 117, "focalAPIEnd": 130, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.nextLine()", "scanner.nextLine()", "ListExpensesController.getExpensesBetweenDates(line,String)", "ListIncomeController.getExpensesBetweenDates(line,String)", "escrita(line,String,List<Expense>,List<Income>,String)"], "useStart": [199, 270, 313, 380, 425], "useEnd": [212, 283, 351, 419, 479], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ajorgesantosp/EAPLI_PL_2DB/tree/master/eapli.expensemanager/src/Presentation/ExporImportUI.java", "rawCode": "  private void ExportXML() throws Exception {\n    System.out.println(\"Begin Date (dd-mm-yyyy):\");\n    String begin = in.nextLine();\n    System.out.println(\"End Date (dd-mm-yyyy):\");\n    String end = in.nextLine();\n    System.out.println(\"File name:\");\n    String file = in.nextLine();\n    List<Expense> listExp = ec.getExpensesBetweenDates(begin, end);\n    List<Income> listInc = inc.getExpensesBetweenDates(begin, end);\n    XML_Export.escrita(begin, end, listExp, listInc, file);\n  }\n"}, {"dataset": "nextLine", "exampleID": 7200, "initialization": ["Scanner scanner = new Scanner(InputStream)"], "initializationStart": [451], "initializationEnd": [467], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "line = scanner.nextLine()", "focalAPIStart": 583, "focalAPIEnd": 595, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["scanner.nextLine()"], "useStart": [703], "useEnd": [715], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FBergeron/AriadneRepository/tree/master/src/org/ariadne_eu/utils/rest/SearchNode.java", "rawCode": "  /**\n   * PRECONDITION loadTerms must be run first in order to set nrOfFiles\n   *\n   * @param inFileNam\n   * @throws Exception\n   */\n  public void loadPointers(String inDir, String fileNam) throws Exception {\n    cmrPointer = new long[nrOfFiles * 4 + 1];\n    InputStream fis = new FileInputStream(inDir + \"pre_point/\" + fileNam + \".txt\");\n    // Reader isr = new InputStreamReader (fis, \"UTF-8\");\n    // Scanner s = new Scanner(isr);\n    Scanner s = new Scanner(fis);\n    // Get rid of possible garbage in the beginning. Sometimes UTF-8 has this problem\n    while (!s.hasNextInt()) s.nextLine();\n    int k = 0;\n    while (s.hasNextInt()) {\n      cmrPointer[k] = s.nextInt();\n      if (s.hasNextLine()) s.nextLine();\n      k++;\n    }\n    System.out.println(k);\n    // cmrFile = new InputStreamReader (new FileInputStream (inFileNam+\"pre/part\"+nod+\".txt\"),\n    // \"UTF-8\");\n\n    // fcData = new RandomAccessFile(inFileNam+\"pre/part\"+nod+\".data\", \"r\").getChannel();\n    fcData = new RandomAccessFile(inDir + \"pre/\" + fileNam + \".data\", \"r\");\n    // fcData.read(ByteBuffer dst, long position)\n  }\n"}]