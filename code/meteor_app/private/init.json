[{"dataset": "init", "exampleID": 1001, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 190, "tryExpressionEnd": 194, "tryBlockStart": 190, "tryBlockEnd": 354, "catchExpressionStart": 290, "catchExpressionEnd": 310, "catchBlockStart": 290, "catchBlockEnd": 354, "exceptionHandlingCallStart": [324], "exceptionHandlingCallEnd": [347], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 202, "focalAPIEnd": 250, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [265], "useEnd": [282], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fhdragon/dragon/tree/master/dragon-commons/src/main/java/org/apache/dragon/commons/crypto/DESByte.java", "rawCode": "  /**\n   * encrytor t\n   *\n   * @param t\n   * @return\n   * @see org.apache.dragon.commons.crypto.Crypto#encrytor(java.lang.Object)\n   */\n  @Override\n  public byte[] encrytor(byte[] t) {\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\n      return cipher.doFinal(t);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1002, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(String)"], "initializationStart": [986, 1025], "initializationEnd": [1002, 1050], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["cipher.getProvider()"], "configurationStart": [1074], "configurationEnd": [1094], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 1110, "focalAPIEnd": 1147, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new SealedObject(String,cipher)", "cipher.init(int,Key)"], "useStart": [1209, 1248], "useEnd": [1241, 1285], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/SealedObjectTest.java", "rawCode": "  /**\n   * getObject(Key key, String provider) method testing. Tests if the proper exception is thrown in\n   * the case of incorrect input parameters and if the object sealed with encryption algorithm can\n   * be retrieved by specifying the cryptographic key and provider name.\n   */\n  public void testGetObject3() throws Exception {\n    try {\n      new SealedObject(\"secret string\", new NullCipher())\n          .getObject(new SecretKeySpec(new byte[] {0, 0, 0}, \"algorithm\"), null);\n      fail(\"IllegalArgumentException should be thrown in the case of \" + \"null provider.\");\n    } catch (IllegalArgumentException e) {\n    }\n\n    try {\n      new SealedObject(\"secret string\", new NullCipher())\n          .getObject(new SecretKeySpec(new byte[] {0, 0, 0}, \"algorithm\"), \"\");\n      fail(\"IllegalArgumentException should be thrown in the case of \" + \"empty provider.\");\n    } catch (IllegalArgumentException e) {\n    }\n\n    KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n    Key key = kg.generateKey();\n\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    String provider = cipher.getProvider().getName();\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n\n    String secret = \"secret string\";\n    SealedObject so = new SealedObject(secret, cipher);\n\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    assertEquals(\n        \"The returned object does not equals to the \" + \"original object.\",\n        secret,\n        so.getObject(key, provider));\n\n    kg = KeyGenerator.getInstance(\"DESede\");\n    key = kg.generateKey();\n\n    try {\n      so.getObject(key, provider);\n      fail(\"InvalidKeyException expected\");\n    } catch (InvalidKeyException e) {\n      // expected\n    }\n\n    try {\n      so.getObject(key, \"Wrong provider name\");\n      fail(\"NoSuchProviderException expected\");\n    } catch (NoSuchProviderException e) {\n      // expected\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1003, "initialization": ["Key key = createDESKey(byte[],int)", "Cipher cipher = getInstance(String)"], "initializationStart": [523, 678], "initializationEnd": [548, 717], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "new NTLMEngineException(*,*)"], "tryExpressionStart": 274, "tryExpressionEnd": 278, "tryBlockStart": 274, "tryBlockEnd": 1160, "catchExpressionStart": 1077, "catchExpressionEnd": 1097, "catchBlockStart": 1077, "catchBlockEnd": 1160, "exceptionHandlingCallStart": [1135, 1111], "exceptionHandlingCallEnd": [1149, 1153], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 725, "focalAPIEnd": 762, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])"], "useStart": [787, 821, 885], "useEnd": [813, 859, 911], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mmoutenot/SandFox/tree/master/mobile/android/base/httpclientandroidlib/impl/auth/NTLMEngineImpl.java", "rawCode": "  /**\n   * Creates the LM Hash of the user's password.\n   *\n   * @param password The password.\n   * @return The LM Hash of the given password, used in the calculation of the LM Response.\n   */\n  private static byte[] lmHash(String password) throws NTLMEngineException {\n    try {\n      byte[] oemPassword = password.toUpperCase().getBytes(\"US-ASCII\");\n      int length = Math.min(oemPassword.length, 14);\n      byte[] keyBytes = new byte[14];\n      System.arraycopy(oemPassword, 0, keyBytes, 0, length);\n      Key lowKey = createDESKey(keyBytes, 0);\n      Key highKey = createDESKey(keyBytes, 7);\n      byte[] magicConstant = \"KGS!@#$%\".getBytes(\"US-ASCII\");\n      Cipher des = Cipher.getInstance(\"DES/ECB/NoPadding\");\n      des.init(Cipher.ENCRYPT_MODE, lowKey);\n      byte[] lowHash = des.doFinal(magicConstant);\n      des.init(Cipher.ENCRYPT_MODE, highKey);\n      byte[] highHash = des.doFinal(magicConstant);\n      byte[] lmHash = new byte[16];\n      System.arraycopy(lowHash, 0, lmHash, 0, 8);\n      System.arraycopy(highHash, 0, lmHash, 8, 8);\n      return lmHash;\n    } catch (Exception e) {\n      throw new NTLMEngineException(e.getMessage(), e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1004, "initialization": ["Key key = createDESKey(byte[],int)", "Cipher cipher = getInstance(String)"], "initializationStart": [493, 582], "initializationEnd": [518, 621], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 627, "focalAPIEnd": 664, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])"], "useStart": [687, 728, 790], "useEnd": [722, 766, 825], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/safuus/MobX/tree/master/mobxserver/apache-mina-2.0.4/src/mina-core/src/main/java/org/apache/mina/proxy/handlers/http/ntlm/NTLMResponses.java", "rawCode": "  /**\n   * Creates the LM Hash of the user's password.\n   *\n   * @param password The password.\n   * @return The LM Hash of the given password, used in the calculation of the LM Response.\n   */\n  private static byte[] lmHash(String password) throws Exception {\n    byte[] oemPassword = password.toUpperCase().getBytes(\"US-ASCII\");\n    int length = Math.min(oemPassword.length, 14);\n    byte[] keyBytes = new byte[14];\n    System.arraycopy(oemPassword, 0, keyBytes, 0, length);\n    Key lowKey = createDESKey(keyBytes, 0);\n    Key highKey = createDESKey(keyBytes, 7);\n    Cipher des = Cipher.getInstance(\"DES/ECB/NoPadding\");\n    des.init(Cipher.ENCRYPT_MODE, lowKey);\n    byte[] lowHash = des.doFinal(LM_HASH_MAGIC_CONSTANT);\n    des.init(Cipher.ENCRYPT_MODE, highKey);\n    byte[] highHash = des.doFinal(LM_HASH_MAGIC_CONSTANT);\n    byte[] lmHash = new byte[16];\n    System.arraycopy(lowHash, 0, lmHash, 0, 8);\n    System.arraycopy(highHash, 0, lmHash, 8, 8);\n    return lmHash;\n  }\n"}, {"dataset": "init", "exampleID": 1005, "initialization": ["SecureRandom random = new SecureRandom()", "Cipher cipher = getInstance(String)"], "initializationStart": [126, 166], "initializationEnd": [144, 217], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["cipher.getOutputSize(int)"], "configurationStart": [236], "configurationEnd": [260], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,random)", "focalAPIStart": 334, "focalAPIEnd": 381, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.getOutputSize(int)", "cipher.getOutputSize(int)"], "useStart": [465, 614], "useEnd": [489, 637], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  /** javax.crypto.Cipher#getOutputSize(int) */\n  public void test_getOutputSizeI() throws Exception {\n\n    SecureRandom sr = new SecureRandom();\n    Cipher cipher = Cipher.getInstance(algorithm + \"/ECB/PKCS5Padding\");\n\n    try {\n      cipher.getOutputSize(25);\n      fail();\n    } catch (IllegalStateException expected) {\n    }\n\n    cipher.init(Cipher.ENCRYPT_MODE, cipherKey, sr);\n\n    // A 25-byte input could result in at least 4 8-byte blocks\n    int result = cipher.getOutputSize(25);\n    assertTrue(\"Output size too small\", result > 31);\n\n    // A 8-byte input should result in 2 8-byte blocks\n    result = cipher.getOutputSize(8);\n    assertTrue(\"Output size too small\", result > 15);\n  }\n"}, {"dataset": "init", "exampleID": 1006, "initialization": ["Cipher cipher = getInstance(String,String)"], "initializationStart": [278], "initializationEnd": [308], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["fail(String,*,boolean,boolean)"], "tryExpressionStart": 194, "tryExpressionEnd": 198, "tryBlockStart": 194, "tryBlockEnd": 1523, "catchExpressionStart": 1427, "catchExpressionEnd": 1447, "catchBlockStart": 1427, "catchBlockEnd": 1523, "exceptionHandlingCallStart": [1455], "exceptionHandlingCallEnd": [1516], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 316, "focalAPIEnd": 354, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.getIV()", "createOutputStream(ByteArrayOutputStream,cipher,boolean)"], "useStart": [366, 577], "useEnd": [381, 617], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bcgit/bc-java/tree/master/prov/src/test/java/org/bouncycastle/jce/provider/test/CipherStreamTest2.java", "rawCode": "  private void testWriteRead(\n      String name, Key key, boolean authenticated, boolean useBc, boolean blocks, byte[] data) {\n    ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n\n    try {\n      Cipher encrypt = Cipher.getInstance(name, \"BC\");\n      Cipher decrypt = Cipher.getInstance(name, \"BC\");\n      encrypt.init(Cipher.ENCRYPT_MODE, key);\n      if (encrypt.getIV() != null) {\n        decrypt.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(encrypt.getIV()));\n      } else {\n        decrypt.init(Cipher.DECRYPT_MODE, key);\n      }\n\n      OutputStream cOut = createOutputStream(bOut, encrypt, useBc);\n      if (blocks) {\n        int chunkSize = Math.max(1, data.length / 8);\n        for (int i = 0; i < data.length; i += chunkSize) {\n          cOut.write(data, i, Math.min(chunkSize, data.length - i));\n        }\n      } else {\n        for (int i = 0; i < data.length; i++) {\n          cOut.write(data[i]);\n        }\n      }\n      cOut.close();\n\n      byte[] cipherText = bOut.toByteArray();\n      bOut.reset();\n      InputStream cIn = createInputStream(cipherText, decrypt, useBc);\n\n      if (blocks) {\n        byte[] block = new byte[encrypt.getBlockSize() + 1];\n        int c;\n        while ((c = cIn.read(block)) >= 0) {\n          bOut.write(block, 0, c);\n        }\n      } else {\n        int c;\n        while ((c = cIn.read()) >= 0) {\n          bOut.write(c);\n        }\n      }\n      cIn.close();\n\n    } catch (Exception e) {\n      fail(\"Unexpected exception \" + name, e, authenticated, useBc);\n    }\n\n    byte[] decrypted = bOut.toByteArray();\n    if (!Arrays.areEqual(data, decrypted)) {\n      fail(\"Failed - decrypted data doesn't match: \" + name, authenticated, useBc);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1007, "initialization": ["Cipher cipher = getInstance(*)"], "initializationStart": [171], "initializationEnd": [209], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["key.getAlgorithm()"], "configurationStart": [190], "configurationEnd": [208], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 326, "focalAPIEnd": 363, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new CipherInputStream(InputStream,cipher)"], "useStart": [604], "useEnd": [638], "hasFinally": 1, "cleanUpCall": ["ObjectInputStream.close()"], "finallyExpressionStart": 723, "finallyExpressionEnd": 731, "finallyBlockStart": 723, "finallyBlockEnd": 951, "cleanUpCallStart": [753], "cleanUpCallEnd": [764], "url": "https://github.com/236371/ewolf-webgui/tree/master/src/il/technion/ewolf/stash/crypto/EncryptedObject.java", "rawCode": "  @SuppressWarnings(\"unchecked\")\n  public T decrypt(Key key) throws IOException, InvalidKeyException, ClassNotFoundException {\n    Cipher cipher;\n    try {\n      cipher = Cipher.getInstance(key.getAlgorithm());\n    } catch (Exception e) {\n      e.printStackTrace();\n      throw new RuntimeException(e.getMessage());\n    }\n    cipher.init(Cipher.DECRYPT_MODE, key);\n\n    InputStream bin = null;\n    CipherInputStream cin = null;\n    ObjectInputStream oin = null;\n    try {\n      // System.out.println(\"decrypt: \"+Base64.encodeBase64String(bytes));\n      bin = new ByteArrayInputStream(bytes);\n      cin = new CipherInputStream(bin, cipher);\n      oin = new ObjectInputStream(cin);\n\n      return (T) oin.readObject();\n\n    } finally {\n      try {\n        oin.close();\n      } catch (Exception e) {\n      }\n      try {\n        cin.close();\n      } catch (Exception e) {\n      }\n      try {\n        bin.close();\n      } catch (Exception e) {\n      }\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1008, "initialization": ["AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [201, 242], "initializationEnd": [224, 281], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 287, "focalAPIEnd": 334, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.update(byte[],int,int)", "cipher.doFinal(byte[],int)", "cipher.doFinal(byte[],int)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.update(byte[],int,int)", "cipher.doFinal(byte[],int)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.update(byte[],int,int)", "cipher.doFinal(byte[],int)", "cipher.init(int,Key)", "cipher.update(byte[],int,int)", "cipher.doFinal(byte[],int)"], "useStart": [340, 376, 531, 670, 723, 756, 857, 910, 947, 1094, 1144, 1179], "useEnd": [358, 392, 547, 717, 740, 772, 904, 929, 962, 1138, 1161, 1195], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codefireX/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void test_doFinal$BI() throws Exception {\n    byte[] b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n    byte[] b1 = new byte[30];\n    AlgorithmParameterSpec ap = new IvParameterSpec(IV);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    c.update(b, 0, 10);\n    try {\n      c.doFinal(b1, 5);\n      fail();\n    } catch (IllegalBlockSizeException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      c.doFinal(b1, 5);\n      fail();\n    } catch (IllegalStateException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    c.update(b, 3, 8);\n    int len = c.doFinal(b1, 0);\n    assertEquals(0, len);\n\n    c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, ap);\n    c.update(b1, 0, 24);\n    try {\n      c.doFinal(b, 0);\n      fail();\n    } catch (BadPaddingException expected) {\n    }\n\n    b1 = new byte[6];\n    c = Cipher.getInstance(\"DESede\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_3DES);\n    c.update(b, 3, 6);\n    try {\n      c.doFinal(b1, 5);\n      fail();\n    } catch (ShortBufferException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1009, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [575], "initializationEnd": [604], "hasTryCatch": 1, "exceptionType": "GeneralSecurityException", "exceptionHandlingCall": ["new IllegalArgumentException(String,*)"], "tryExpressionStart": 482, "tryExpressionEnd": 486, "tryBlockStart": 482, "tryBlockEnd": 895, "catchExpressionStart": 739, "catchExpressionEnd": 774, "catchBlockStart": 739, "catchBlockEnd": 895, "exceptionHandlingCallStart": [788], "exceptionHandlingCallEnd": [888], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 612, "focalAPIEnd": 649, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [919], "useEnd": [939], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openengsb/openengsb/tree/master/components/util/src/main/java/org/openengsb/core/util/CipherUtils.java", "rawCode": "  /**\n   * Decrypts the given data using the given key using the given algorithm. If you are decrypting\n   * data that is supposed to be a string, consider that it might be Base64-encoded.\n   *\n   * @throws DecryptionException if the string cannot be decrypted with the given key\n   * @throws IllegalArgumentException if the algorithm is not supported.\n   */\n  public static byte[] decrypt(byte[] text, Key key, String algorithm) throws DecryptionException {\n    Cipher cipher;\n    try {\n      LOGGER.trace(\"start decrypting text using {} cipher\", algorithm);\n      cipher = Cipher.getInstance(algorithm);\n      cipher.init(Cipher.DECRYPT_MODE, key);\n      LOGGER.trace(\"initialized decryption with key of type {}\", key.getClass());\n    } catch (GeneralSecurityException e) {\n      throw new IllegalArgumentException(\n          \"unable to initialize cipher for algorithm \" + algorithm, e);\n    }\n    try {\n      return cipher.doFinal(text);\n    } catch (GeneralSecurityException e) {\n      throw new DecryptionException(\"unable to decrypt data using algorithm \" + algorithm, e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1010, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [110], "initializationEnd": [141], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["getMessage()", "new CipherException(String)"], "tryExpressionStart": 82, "tryExpressionEnd": 86, "tryBlockStart": 82, "tryBlockEnd": 1033, "catchExpressionStart": 440, "catchExpressionEnd": 475, "catchBlockStart": 440, "catchBlockEnd": 560, "exceptionHandlingCallStart": [538, 489], "exceptionHandlingCallEnd": [552, 553], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 149, "focalAPIEnd": 186, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [216], "useEnd": [247], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aborg0/rapidminer-vega/tree/master/src/com/rapidminer/tools/cipher/CipherTools.java", "rawCode": "  public static String encrypt(String text, Key key) throws CipherException {\n    try {\n      Cipher cipher = Cipher.getInstance(CIPHER_TYPE);\n      cipher.init(Cipher.ENCRYPT_MODE, key);\n\n      byte[] outputBytes = cipher.doFinal(text.getBytes());\n\n      // BASE64Encoder encoder = new BASE64Encoder();\n      // String base64 = encoder.encode(outputBytes);\n      String base64 = Base64.encodeBytes(outputBytes);\n      return base64;\n    } catch (NoSuchAlgorithmException e) {\n      throw new CipherException(\"Failed to encrypt text: \" + e.getMessage());\n    } catch (NoSuchPaddingException e) {\n      throw new CipherException(\"Failed to encrypt text: \" + e.getMessage());\n    } catch (InvalidKeyException e) {\n      throw new CipherException(\"Failed to encrypt text: \" + e.getMessage());\n    } catch (IllegalBlockSizeException e) {\n      throw new CipherException(\"Failed to encrypt text: \" + e.getMessage());\n    } catch (BadPaddingException e) {\n      throw new CipherException(\"Failed to encrypt text: \" + e.getMessage());\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1011, "initialization": ["AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [103, 144], "initializationEnd": [126, 186], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 192, "focalAPIEnd": 239, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.getParameters()", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.init(int,Key,AlgorithmParameterSpec)"], "useStart": [259, 296, 428], "useEnd": [276, 344, 499], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wsot/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void test_initWithKeyAlgorithmParameters() throws Exception {\n    AlgorithmParameterSpec ap = new IvParameterSpec(IV);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, ap);\n    assertNotNull(c.getParameters());\n\n    try {\n      c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_3DES, ap);\n      fail();\n    } catch (InvalidKeyException expected) {\n    }\n\n    try {\n      c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, (AlgorithmParameters) null);\n      fail();\n    } catch (InvalidAlgorithmParameterException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1012, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(String)"], "initializationStart": [196, 361], "initializationEnd": [219, 395], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 401, "focalAPIEnd": 450, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(*,Key,AlgorithmParameters)", "cipher.doFinal(byte[])"], "useStart": [468, 511, 585], "useEnd": [504, 560, 603], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MIPS/libcore/tree/master/support/src/test/java/tests/security/AlgorithmParameterSymmetricHelper.java", "rawCode": "  @Override\n  public void test(AlgorithmParameters parameters) throws Exception {\n    KeyGenerator generator = KeyGenerator.getInstance(algorithmName);\n    generator.init(keySize);\n\n    Key key = generator.generateKey();\n    String transformation = algorithmName;\n    if (blockmode != null) {\n      transformation += \"/\" + blockmode;\n    }\n\n    Cipher cipher = Cipher.getInstance(transformation);\n    cipher.init(Cipher.ENCRYPT_MODE, key, parameters);\n    byte[] bs = cipher.doFinal(plainData.getBytes());\n\n    cipher.init(Cipher.DECRYPT_MODE, key, parameters);\n    byte[] decrypted = cipher.doFinal(bs);\n\n    Assert.assertTrue(Arrays.equals(plainData.getBytes(), decrypted));\n  }\n"}, {"dataset": "init", "exampleID": 1013, "initialization": ["AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [307, 348], "initializationEnd": [330, 387], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 393, "focalAPIEnd": 440, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.init(int,Key)", "cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.init(int,Key)", "cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.init(int,Key)", "cipher.doFinal(ByteBuffer,ByteBuffer)"], "useStart": [484, 649, 798, 925, 1036, 1139, 1286, 1373, 1524, 1611, 1855, 1917], "useEnd": [510, 675, 845, 951, 1083, 1165, 1329, 1398, 1567, 1656, 1899, 1943], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codefireX/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void test_doFinalLjava_nio_ByteBufferLjava_nio_ByteBuffer() throws Exception {\n    byte[] b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n    ByteBuffer bInput = ByteBuffer.allocate(64);\n    ByteBuffer bOutput = ByteBuffer.allocate(64);\n    AlgorithmParameterSpec ap = new IvParameterSpec(IV);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    bInput.put(b, 0, 10);\n    try {\n      c.doFinal(bInput, bOutput);\n      fail();\n    } catch (IllegalBlockSizeException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      c.doFinal(bInput, bOutput);\n      fail();\n    } catch (IllegalStateException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    bInput = ByteBuffer.allocate(16);\n    bInput.put(b, 0, 16);\n    int len = c.doFinal(bInput, bOutput);\n    assertEquals(0, len);\n\n    c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, ap);\n    bInput = ByteBuffer.allocate(64);\n    try {\n      c.doFinal(bOutput, bInput);\n      fail();\n    } catch (BadPaddingException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES);\n    bInput.put(b, 0, 16);\n    try {\n      c.doFinal(bInput, bInput);\n      fail();\n    } catch (IllegalArgumentException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES);\n    bInput.put(b, 0, 16);\n    try {\n      c.doFinal(bInput, bOutput.asReadOnlyBuffer());\n      fail();\n    } catch (ReadOnlyBufferException expected) {\n    }\n\n    bInput.rewind();\n    bInput.put(b, 0, 16);\n    bOutput = ByteBuffer.allocate(8);\n    c = Cipher.getInstance(\"DESede\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_3DES);\n    try {\n      c.doFinal(bInput, bOutput);\n      fail();\n    } catch (ShortBufferException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1014, "initialization": ["Cipher cipher = getInstance(String,String)", "Key key = new PublicKey()"], "initializationStart": [1772, 1833], "initializationEnd": [1802, 2134], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["fail(String,*)"], "tryExpressionStart": 1747, "tryExpressionEnd": 1751, "tryBlockStart": 1747, "tryBlockEnd": 2327, "catchExpressionStart": 2924, "catchExpressionEnd": 2944, "catchBlockStart": 2924, "catchBlockEnd": 2991, "exceptionHandlingCallStart": [2952], "exceptionHandlingCallEnd": [2984], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 2145, "focalAPIEnd": 2175, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(int,Key)"], "useStart": [2734], "useEnd": [2764], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bcgit/bc-java/tree/master/prov/src/test/java/org/bouncycastle/jce/provider/test/CipherStreamTest.java", "rawCode": "  private void testException(String name) {\n    try {\n      byte[] key128 = {\n        (byte) 128, (byte) 131, (byte) 133, (byte) 134,\n        (byte) 137, (byte) 138, (byte) 140, (byte) 143,\n        (byte) 128, (byte) 131, (byte) 133, (byte) 134,\n        (byte) 137, (byte) 138, (byte) 140, (byte) 143\n      };\n\n      byte[] key256 = {\n        (byte) 128, (byte) 131, (byte) 133, (byte) 134,\n        (byte) 137, (byte) 138, (byte) 140, (byte) 143,\n        (byte) 128, (byte) 131, (byte) 133, (byte) 134,\n        (byte) 137, (byte) 138, (byte) 140, (byte) 143,\n        (byte) 128, (byte) 131, (byte) 133, (byte) 134,\n        (byte) 137, (byte) 138, (byte) 140, (byte) 143,\n        (byte) 128, (byte) 131, (byte) 133, (byte) 134,\n        (byte) 137, (byte) 138, (byte) 140, (byte) 143\n      };\n\n      byte[] keyBytes;\n      if (name.equals(\"HC256\")\n          || name.equals(\"XSalsa20\")\n          || name.equals(\"ChaCha7539\")\n          || name.equals(\"ChaCha20\")) {\n        keyBytes = key256;\n      } else {\n        keyBytes = key128;\n      }\n\n      SecretKeySpec cipherKey = new SecretKeySpec(keyBytes, name);\n      Cipher ecipher = Cipher.getInstance(name, \"BC\");\n      ecipher.init(Cipher.ENCRYPT_MODE, cipherKey);\n\n      byte[] cipherText = new byte[0];\n      try {\n        // According specification Method engineUpdate(byte[] input,\n        // int inputOffset, int inputLen, byte[] output, int\n        // outputOffset)\n        // throws ShortBufferException - if the given output buffer is\n        // too\n        // small to hold the result\n        ecipher.update(new byte[20], 0, 20, cipherText);\n\n        fail(\"failed exception test - no ShortBufferException thrown\");\n      } catch (ShortBufferException e) {\n        // ignore\n      }\n\n      try {\n        Cipher c = Cipher.getInstance(name, \"BC\");\n\n        Key k =\n            new PublicKey() {\n\n              public String getAlgorithm() {\n                return \"STUB\";\n              }\n\n              public String getFormat() {\n                return null;\n              }\n\n              public byte[] getEncoded() {\n                return null;\n              }\n            };\n\n        c.init(Cipher.ENCRYPT_MODE, k);\n\n        fail(\"failed exception test - no InvalidKeyException thrown for public key\");\n      } catch (InvalidKeyException e) {\n        // okay\n      }\n\n      try {\n        Cipher c = Cipher.getInstance(name, \"BC\");\n\n        Key k =\n            new PrivateKey() {\n\n              public String getAlgorithm() {\n                return \"STUB\";\n              }\n\n              public String getFormat() {\n                return null;\n              }\n\n              public byte[] getEncoded() {\n                return null;\n              }\n            };\n\n        c.init(Cipher.DECRYPT_MODE, k);\n\n        fail(\"failed exception test - no InvalidKeyException thrown for private key\");\n      } catch (InvalidKeyException e) {\n        // okay\n      }\n    } catch (Exception e) {\n      fail(\"unexpected exception.\", e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1015, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 190, "tryExpressionEnd": 194, "tryBlockStart": 190, "tryBlockEnd": 354, "catchExpressionStart": 290, "catchExpressionEnd": 310, "catchBlockStart": 290, "catchBlockEnd": 354, "exceptionHandlingCallStart": [324], "exceptionHandlingCallEnd": [347], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 202, "focalAPIEnd": 250, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [265], "useEnd": [282], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fhdragon/dragon/tree/master/dragon-commons/src/main/java/org/apache/dragon/commons/crypto/DESByte.java", "rawCode": "  /**\n   * decrytor t\n   *\n   * @param t\n   * @return\n   * @see org.apache.dragon.commons.crypto.Crypto#decrytor(java.lang.Object)\n   */\n  @Override\n  public byte[] decrytor(byte[] t) {\n    try {\n      cipher.init(Cipher.DECRYPT_MODE, this.secretKey);\n      return cipher.doFinal(t);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1016, "initialization": ["Key key = new SecretKeySpec(byte[],String)", "Cipher cipher = getInstance(String,String)"], "initializationStart": [260, 371], "initializationEnd": [298, 420], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "fail(String,*)"], "tryExpressionStart": 427, "tryExpressionEnd": 431, "tryBlockStart": 427, "tryBlockEnd": 574, "catchExpressionStart": 481, "catchExpressionEnd": 501, "catchBlockStart": 481, "catchBlockEnd": 574, "exceptionHandlingCallStart": [551, 509], "exceptionHandlingCallEnd": [563, 567], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 439, "focalAPIEnd": 473, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new CipherOutputStream(ByteArrayOutputStream,cipher)"], "useStart": [818], "useEnd": [851], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bcgit/bc-java/tree/master/prov/src/test/java/org/bouncycastle/jce/provider/test/NoekeonTest.java", "rawCode": "  public void test(int strength, byte[] keyBytes, byte[] input, byte[] output) throws Exception {\n    Key key;\n    Cipher in, out;\n    CipherInputStream cIn;\n    CipherOutputStream cOut;\n    ByteArrayInputStream bIn;\n    ByteArrayOutputStream bOut;\n\n    key = new SecretKeySpec(keyBytes, \"Noekeon\");\n\n    in = Cipher.getInstance(\"Noekeon/ECB/NoPadding\", \"BC\");\n    out = Cipher.getInstance(\"Noekeon/ECB/NoPadding\", \"BC\");\n\n    try {\n      out.init(Cipher.ENCRYPT_MODE, key);\n    } catch (Exception e) {\n      fail(\"Noekeon failed initialisation - \" + e.toString(), e);\n    }\n\n    try {\n      in.init(Cipher.DECRYPT_MODE, key);\n    } catch (Exception e) {\n      fail(\"Noekeoen failed initialisation - \" + e.toString(), e);\n    }\n\n    //\n    // encryption pass\n    //\n    bOut = new ByteArrayOutputStream();\n\n    cOut = new CipherOutputStream(bOut, out);\n\n    try {\n      for (int i = 0; i != input.length / 2; i++) {\n        cOut.write(input[i]);\n      }\n      cOut.write(input, input.length / 2, input.length - input.length / 2);\n      cOut.close();\n    } catch (IOException e) {\n      fail(\"Noekeon failed encryption - \" + e.toString(), e);\n    }\n\n    byte[] bytes;\n\n    bytes = bOut.toByteArray();\n\n    if (!areEqual(bytes, output)) {\n      fail(\n          \"Noekeon failed encryption - expected \"\n              + new String(Hex.encode(output))\n              + \" got \"\n              + new String(Hex.encode(bytes)));\n    }\n\n    //\n    // decryption pass\n    //\n    bIn = new ByteArrayInputStream(bytes);\n\n    cIn = new CipherInputStream(bIn, in);\n\n    try {\n      DataInputStream dIn = new DataInputStream(cIn);\n\n      bytes = new byte[input.length];\n\n      for (int i = 0; i != input.length / 2; i++) {\n        bytes[i] = (byte) dIn.read();\n      }\n      dIn.readFully(bytes, input.length / 2, bytes.length - input.length / 2);\n    } catch (Exception e) {\n      fail(\"Noekeon failed encryption - \" + e.toString(), e);\n    }\n\n    if (!areEqual(bytes, input)) {\n      fail(\n          \"Noekeon failed decryption - expected \"\n              + new String(Hex.encode(input))\n              + \" got \"\n              + new String(Hex.encode(bytes)));\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1017, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(String)"], "initializationStart": [299, 503], "initializationEnd": [322, 537], "hasTryCatch": 1, "exceptionType": "InvalidKeyException", "exceptionHandlingCall": ["getMessage()", "fail(*)"], "tryExpressionStart": 704, "tryExpressionEnd": 708, "tryBlockStart": 704, "tryBlockEnd": 933, "catchExpressionStart": 773, "catchExpressionEnd": 803, "catchBlockStart": 773, "catchBlockEnd": 845, "exceptionHandlingCallStart": [823, 811], "exceptionHandlingCallEnd": [837, 838], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 716, "focalAPIEnd": 765, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(*,Key,AlgorithmParameters)", "cipher.doFinal(byte[])"], "useStart": [978, 1191, 1467], "useEnd": [1014, 1240, 1485], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TaintDroid/android_platform_libcore/tree/master/support/src/test/java/tests/security/AlgorithmParameterSymmetricHelper.java", "rawCode": "  @Override\n  public void test(AlgorithmParameters parameters) {\n\n    KeyGenerator generator = null;\n    try {\n      generator = KeyGenerator.getInstance(algorithmName);\n    } catch (NoSuchAlgorithmException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    generator.init(keySize);\n\n    Key key = generator.generateKey();\n\n    Cipher cipher = null;\n    try {\n      String transformation = algorithmName;\n      if (blockmode != null) {\n        transformation += \"/\" + blockmode;\n      }\n      cipher = Cipher.getInstance(transformation);\n    } catch (NoSuchAlgorithmException e) {\n      Assert.fail(e.getMessage());\n    } catch (NoSuchPaddingException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, key, parameters);\n    } catch (InvalidKeyException e) {\n      Assert.fail(e.getMessage());\n    } catch (InvalidAlgorithmParameterException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    byte[] bs = null;\n    try {\n      bs = cipher.doFinal(plainData.getBytes());\n    } catch (IllegalBlockSizeException e) {\n      Assert.fail(e.getMessage());\n    } catch (BadPaddingException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    try {\n      cipher.init(Cipher.DECRYPT_MODE, key, parameters);\n    } catch (InvalidKeyException e) {\n      Assert.fail(e.getMessage());\n    } catch (InvalidAlgorithmParameterException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    byte[] decrypted = null;\n    try {\n      decrypted = cipher.doFinal(bs);\n    } catch (IllegalBlockSizeException e) {\n      Assert.fail(e.getMessage());\n    } catch (BadPaddingException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    Assert.assertTrue(Arrays.equals(plainData.getBytes(), decrypted));\n  }\n"}, {"dataset": "init", "exampleID": 1018, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [774], "initializationEnd": [813], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 820, "focalAPIEnd": 909, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/opentree/aionj-hungary/tree/master/LoginServer/src/main/java/com/aionemu/loginserver/network/ncrypt/KeyGen.java", "rawCode": "  /**\n   * Initialize Key Generator (Blowfish keygen and RSA keygen)\n   *\n   * @throws GeneralSecurityException\n   */\n  public static void init() throws GeneralSecurityException {\n    log.info(\"Initializing Key Generator...\");\n\n    blowfishKeyGen = KeyGenerator.getInstance(\"Blowfish\");\n\n    KeyPairGenerator rsaKeyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n\n    RSAKeyGenParameterSpec spec = new RSAKeyGenParameterSpec(1024, RSAKeyGenParameterSpec.F4);\n\n    rsaKeyPairGenerator.initialize(spec);\n\n    encryptedRSAKeyPairs = new EncryptedRSAKeyPair[10];\n\n    for (int i = 0; i < 10; i++) {\n      encryptedRSAKeyPairs[i] = new EncryptedRSAKeyPair(rsaKeyPairGenerator.generateKeyPair());\n    }\n\n    // Pre-init RSA cipher.. saving about 300ms\n    Cipher rsaCipher = Cipher.getInstance(\"RSA/ECB/nopadding\");\n\n    rsaCipher.init(Cipher.DECRYPT_MODE, encryptedRSAKeyPairs[0].getRSAKeyPair().getPrivate());\n  }\n"}, {"dataset": "init", "exampleID": 1019, "initialization": ["SecureRandom random = new SecureRandom()", "AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [250, 411, 450], "initializationEnd": [268, 434, 501], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["random.nextBytes(byte[])"], "configurationStart": [384], "configurationEnd": [400], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params,random)", "focalAPIStart": 508, "focalAPIEnd": 559, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.getIV()", "cipher.init(*,Key,AlgorithmParameterSpec,SecureRandom)", "cipher.init(*,Key,AlgorithmParameterSpec,SecureRandom)"], "useStart": [584, 730, 983], "useEnd": [598, 781, 1037], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  /**\n   * javax.crypto.Cipher#init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec,\n   * java.security.SecureRandom)\n   */\n  public void test_initWithKeyAlgorithmParameterSpecSecureRandom() throws Exception {\n    SecureRandom sr = new SecureRandom();\n    Cipher cipher = null;\n\n    byte[] iv = null;\n    AlgorithmParameterSpec ap = null;\n\n    iv = new byte[8];\n    sr.nextBytes(iv);\n    ap = new IvParameterSpec(iv);\n\n    cipher = Cipher.getInstance(algorithm + \"/CBC/PKCS5Padding\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, cipherKey, ap, sr);\n\n    byte[] cipherIV = cipher.getIV();\n\n    assertTrue(\"IVs differ\", Arrays.equals(cipherIV, iv));\n    cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, cipherKey, ap, sr);\n      fail();\n    } catch (InvalidKeyException expected) {\n    }\n\n    cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    ap = new RSAKeyGenParameterSpec(10, new BigInteger(\"10\"));\n\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, cipherKeyDES, ap, sr);\n      fail();\n    } catch (InvalidAlgorithmParameterException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1020, "initialization": ["Cipher cipher = getInstance(String)", "Cipher cipher = getInstance(String)"], "initializationStart": [265, 1907], "initializationEnd": [310, 1946], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["cipher.init(*,Key,byte[])", "cipher.update(byte[],int,int)", "cipher.doFinal()"], "configurationStart": [725, 1222, 1397], "configurationEnd": [759, 1251, 1408], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 1952, "focalAPIEnd": 1993, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.update(byte[],int,int,byte[],int)", "cipher.doFinal()", "cipher.doFinal()", "cipher.init(int,Key)", "cipher.doFinal(byte[],int,int,byte[],int)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.update(byte[],int,int,byte[],int)", "cipher.doFinal()"], "useStart": [1999, 2042, 2239, 2416, 2463, 2699, 2751, 2794], "useEnd": [2024, 2053, 2250, 2457, 2489, 2744, 2776, 2805], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/crypto/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  /** @tests javax.crypto.Cipher#doFinal() */\n  @TestTargetNew(\n    level = TestLevel.COMPLETE,\n    notes = \"\",\n    method = \"doFinal\",\n    args = {}\n  )\n  public void test_doFinal() throws Exception {\n    for (int index = 1; index < 4; index++) {\n      Cipher c = Cipher.getInstance(\"DESEDE/CBC/PKCS5Padding\");\n\n      byte[] keyMaterial = loadBytes(\"hyts_\" + \"des-ede3-cbc.test\" + index + \".key\");\n      DESedeKeySpec keySpec = new DESedeKeySpec(keyMaterial);\n      SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DESEDE\");\n      Key k = skf.generateSecret(keySpec);\n\n      byte[] ivMaterial = loadBytes(\"hyts_\" + \"des-ede3-cbc.test\" + index + \".iv\");\n      IvParameterSpec iv = new IvParameterSpec(ivMaterial);\n\n      c.init(Cipher.ENCRYPT_MODE, k, iv);\n\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      byte[] input = new byte[256];\n      String resPath = \"hyts_\" + \"des-ede3-cbc.test\" + index + \".plaintext\";\n      File resources = Support_Resources.createTempFolder();\n      Support_Resources.copyFile(resources, null, resPath);\n      InputStream is = Support_Resources.getStream(resPath);\n\n      int bytesRead = is.read(input, 0, 256);\n      while (bytesRead > 0) {\n        byte[] output = c.update(input, 0, bytesRead);\n        if (output != null) {\n          baos.write(output);\n        }\n        bytesRead = is.read(input, 0, 256);\n      }\n      byte[] output = c.doFinal();\n      if (output != null) {\n        baos.write(output);\n      }\n      byte[] encryptedPlaintext = baos.toByteArray();\n      is.close();\n\n      byte[] cipherText = loadBytes(\"hyts_\" + \"des-ede3-cbc.test\" + index + \".ciphertext\");\n      assertTrue(\n          \"Operation produced incorrect results\", Arrays.equals(encryptedPlaintext, cipherText));\n    } // end for\n\n    byte[] b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n    byte[] b1 = new byte[30];\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, cipherKeyDES);\n    c.update(b, 0, 10, b1, 5);\n    try {\n      c.doFinal();\n      fail(\"IllegalBlockSizeException expected\");\n    } catch (IllegalBlockSizeException e) {\n      // expected\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      c.doFinal();\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n      // expected\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, cipherKeyDES);\n    c.doFinal(b, 0, 16, b1, 0);\n\n    SecureRandom sr = new SecureRandom();\n    byte[] iv = new byte[8];\n    sr.nextBytes(iv);\n    AlgorithmParameterSpec ap = new IvParameterSpec(iv);\n\n    c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, cipherKeyDES, ap);\n\n    c.update(b1, 0, 24, b, 0);\n    try {\n      c.doFinal();\n      fail(\"BadPaddingException expected\");\n    } catch (BadPaddingException e) {\n      // expected\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1021, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [288], "initializationEnd": [339], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 345, "focalAPIEnd": 388, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(int,Key)"], "useStart": [461], "useEnd": [504], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/crypto/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  /** @tests javax.crypto.Cipher#init(int, java.security.Key) */\n  @TestTargetNew(\n    level = TestLevel.COMPLETE,\n    notes = \"\",\n    method = \"init\",\n    args = {int.class, java.security.Key.class}\n  )\n  public void test_initILjava_security_Key() throws Exception {\n    Cipher cipher = Cipher.getInstance(algorithm + \"/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, cipherKey);\n\n    cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, cipherKey);\n      fail(\"InvalidKeyException expected\");\n    } catch (InvalidKeyException e) {\n      // expected\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1022, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [143], "initializationEnd": [168], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,certificate)", "focalAPIStart": 197, "focalAPIEnd": 227, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(int,Certificate)"], "useStart": [262], "useEnd": [292], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/libcore/javax/crypto/CipherTest.java", "rawCode": "  private void assertCipherInitWithKeyUsage(Certificate certificate, boolean allowMode, int mode)\n      throws Exception {\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    if (allowMode) {\n      cipher.init(mode, certificate);\n    } else {\n      try {\n        cipher.init(mode, certificate);\n        String modeString;\n        switch (mode) {\n          case Cipher.ENCRYPT_MODE:\n            modeString = \"ENCRYPT_MODE\";\n            break;\n          case Cipher.DECRYPT_MODE:\n            modeString = \"DECRYPT_MODE\";\n            break;\n          case Cipher.WRAP_MODE:\n            modeString = \"WRAP_MODE\";\n            break;\n          case Cipher.UNWRAP_MODE:\n            modeString = \"UNWRAP_MODE\";\n            break;\n          default:\n            throw new AssertionError(\"Unknown Cipher.*_MODE \" + mode);\n        }\n        fail(\"Should have had InvalidKeyException for \" + modeString + \" for \" + certificate);\n      } catch (InvalidKeyException expected) {\n      }\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1023, "initialization": ["SecureRandom random = new SecureRandom()", "Cipher cipher = getInstance(String)"], "initializationStart": [463, 503], "initializationEnd": [481, 554], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["cipher.getOutputSize(int)"], "configurationStart": [573], "configurationEnd": [597], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,random)", "focalAPIStart": 714, "focalAPIEnd": 761, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.getOutputSize(int)", "cipher.getOutputSize(int)"], "useStart": [845, 994], "useEnd": [869, 1017], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benjaminvm/vm/tree/master/libcore/crypto/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  /** @tests javax.crypto.Cipher#getOutputSize(int) */\n  @TestTargets({\n    @TestTargetNew(\n      level = TestLevel.COMPLETE,\n      notes = \"\",\n      method = \"getOutputSize\",\n      args = {int.class}\n    ),\n    @TestTargetNew(\n      level = TestLevel.COMPLETE,\n      notes = \"\",\n      clazz = CipherSpi.class,\n      method = \"engineGetOutputSize\",\n      args = {int.class}\n    )\n  })\n  public void test_getOutputSizeI() throws Exception {\n\n    SecureRandom sr = new SecureRandom();\n    Cipher cipher = Cipher.getInstance(algorithm + \"/ECB/PKCS5Padding\");\n\n    try {\n      cipher.getOutputSize(25);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n      // expected\n    }\n\n    cipher.init(Cipher.ENCRYPT_MODE, cipherKey, sr);\n\n    // A 25-byte input could result in at least 4 8-byte blocks\n    int result = cipher.getOutputSize(25);\n    assertTrue(\"Output size too small\", result > 31);\n\n    // A 8-byte input should result in 2 8-byte blocks\n    result = cipher.getOutputSize(8);\n    assertTrue(\"Output size too small\", result > 15);\n  }\n"}, {"dataset": "init", "exampleID": 1024, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)", "printStackTrace()"], "tryExpressionStart": 67, "tryExpressionEnd": 71, "tryBlockStart": 67, "tryBlockEnd": 316, "catchExpressionStart": 203, "catchExpressionEnd": 223, "catchBlockStart": 203, "catchBlockEnd": 316, "exceptionHandlingCallStart": [231, 290], "exceptionHandlingCallEnd": [282, 309], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,random)", "focalAPIStart": 79, "focalAPIEnd": 138, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new SealedObject(Serializable,cipher)"], "useStart": [154], "useEnd": [195], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/acontes/programming/tree/master/src/Core/org/objectweb/proactive/core/security/crypto/EncryptionEngine.java", "rawCode": "  public Object encrypt(Serializable object, Key sessionKey) {\n    try {\n      symmetricCipher.init(Cipher.ENCRYPT_MODE, sessionKey, rand);\n\n      return new SealedObject(object, symmetricCipher);\n    } catch (Exception e) {\n      System.out.println(\"Exception in encryption :\" + e);\n      e.printStackTrace();\n    }\n\n    return null;\n  }\n"}, {"dataset": "init", "exampleID": 1025, "initialization": ["Key key = createDESKey(byte[],int)", "Cipher cipher = getInstance(String)"], "initializationStart": [532, 687], "initializationEnd": [557, 726], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "new NTLMEngineException(*,*)"], "tryExpressionStart": 274, "tryExpressionEnd": 278, "tryBlockStart": 274, "tryBlockEnd": 1169, "catchExpressionStart": 1086, "catchExpressionEnd": 1106, "catchBlockStart": 1086, "catchBlockEnd": 1169, "exceptionHandlingCallStart": [1144, 1120], "exceptionHandlingCallEnd": [1158, 1162], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 734, "focalAPIEnd": 771, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])"], "useStart": [796, 830, 894], "useEnd": [822, 868, 920], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/androidquery/androidquery/tree/master/tests/src/com/androidquery/test/NTLMEngineImpl.java", "rawCode": "  /**\n   * Creates the LM Hash of the user's password.\n   *\n   * @param password The password.\n   * @return The LM Hash of the given password, used in the calculation of the LM Response.\n   */\n  private static byte[] lmHash(String password) throws NTLMEngineException {\n    try {\n      byte[] oemPassword = password.toUpperCase(Locale.US).getBytes(\"US-ASCII\");\n      int length = Math.min(oemPassword.length, 14);\n      byte[] keyBytes = new byte[14];\n      System.arraycopy(oemPassword, 0, keyBytes, 0, length);\n      Key lowKey = createDESKey(keyBytes, 0);\n      Key highKey = createDESKey(keyBytes, 7);\n      byte[] magicConstant = \"KGS!@#$%\".getBytes(\"US-ASCII\");\n      Cipher des = Cipher.getInstance(\"DES/ECB/NoPadding\");\n      des.init(Cipher.ENCRYPT_MODE, lowKey);\n      byte[] lowHash = des.doFinal(magicConstant);\n      des.init(Cipher.ENCRYPT_MODE, highKey);\n      byte[] highHash = des.doFinal(magicConstant);\n      byte[] lmHash = new byte[16];\n      System.arraycopy(lowHash, 0, lmHash, 0, 8);\n      System.arraycopy(highHash, 0, lmHash, 8, 8);\n      return lmHash;\n    } catch (Exception e) {\n      throw new NTLMEngineException(e.getMessage(), e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1026, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [104], "initializationEnd": [129], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 135, "focalAPIEnd": 172, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [185], "useEnd": [202], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SpigotMC/BungeeCord/tree/master/proxy/src/main/java/net/md_5/bungee/EncryptionUtil.java", "rawCode": "  public static byte[] encrypt(Key key, byte[] b) throws GeneralSecurityException {\n    Cipher hasher = Cipher.getInstance(\"RSA\");\n    hasher.init(Cipher.ENCRYPT_MODE, key);\n    return hasher.doFinal(b);\n  }\n"}, {"dataset": "init", "exampleID": 1027, "initialization": ["SecureRandom random = new SecureRandom()", "Cipher cipher = getInstance(String)"], "initializationStart": [169, 209], "initializationEnd": [187, 260], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,random)", "focalAPIStart": 266, "focalAPIEnd": 313, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(int,Key,SecureRandom)"], "useStart": [386], "useEnd": [433], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  /** javax.crypto.Cipher#init(int, java.security.Key, java.security.SecureRandom) */\n  public void test_initWithSecureRandom() throws Exception {\n    SecureRandom sr = new SecureRandom();\n    Cipher cipher = Cipher.getInstance(algorithm + \"/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, cipherKey, sr);\n\n    cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, cipherKey, sr);\n      fail();\n    } catch (InvalidKeyException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1028, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [146], "initializationEnd": [177], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new RuntimeException(String,*)"], "tryExpressionStart": 56, "tryExpressionEnd": 60, "tryBlockStart": 56, "tryBlockEnd": 440, "catchExpressionStart": 346, "catchExpressionEnd": 366, "catchBlockStart": 346, "catchBlockEnd": 440, "exceptionHandlingCallStart": [380], "exceptionHandlingCallEnd": [433], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 185, "focalAPIEnd": 222, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [251], "useEnd": [276], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dzonekl/netxstudio/tree/master/plugins/com.netxforge.base/src/com/netxforge/base/security/JCAService.java", "rawCode": "  public String decrypt(String password, Key key) {\n    try {\n      byte encrypted[] = this.hexStringToByteArray(password);\n      Cipher cipher = Cipher.getInstance(CIPHER_TYPE);\n      cipher.init(Cipher.DECRYPT_MODE, key);\n      byte[] outputBytes = cipher.doFinal(encrypted);\n      String ret = new String(outputBytes);\n      return ret;\n    } catch (Exception e) {\n      throw new RuntimeException(\"Failed to decrypt password\", e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1029, "initialization": ["Cipher cipher = getCipher(String)"], "initializationStart": [257], "initializationEnd": [280], "hasTryCatch": 1, "exceptionType": "GeneralSecurityException", "exceptionHandlingCall": ["new IOException2(*)"], "tryExpressionStart": 122, "tryExpressionEnd": 126, "tryBlockStart": 122, "tryBlockEnd": 1182, "catchExpressionStart": 984, "catchExpressionEnd": 1019, "catchBlockStart": 984, "catchBlockEnd": 1059, "exceptionHandlingCallStart": [1033], "exceptionHandlingCallEnd": [1052], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 290, "focalAPIEnd": 364, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new CipherInputStream(*,cipher)"], "useStart": [475], "useEnd": [581], "hasFinally": 1, "cleanUpCall": ["closeQuietly(ObjectInputStream)"], "finallyExpressionStart": 1134, "finallyExpressionEnd": 1142, "finallyBlockStart": 1134, "finallyBlockEnd": 1182, "cleanUpCallStart": [1150], "cleanUpCallEnd": [1175], "url": "https://github.com/eclipse/hudson.core/tree/master/hudson-core/src/main/java/hudson/console/AnnotatedLargeText.java", "rawCode": "  private ConsoleAnnotator createAnnotator(StaplerRequest req) throws IOException {\n    ObjectInputStream ois = null;\n    try {\n      String base64 = req != null ? req.getHeader(\"X-ConsoleAnnotator\") : null;\n      if (base64 != null) {\n        Cipher sym = Secret.getCipher(\"AES\");\n        sym.init(Cipher.DECRYPT_MODE, Hudson.getInstance().getSecretKeyAsAES128());\n\n        ois =\n            new ObjectInputStreamEx(\n                new GZIPInputStream(\n                    new CipherInputStream(\n                        new ByteArrayInputStream(Base64.decodeBase64(base64)), sym)),\n                Hudson.getInstance().pluginManager.uberClassLoader);\n        long timestamp = ois.readLong();\n        if (TimeUnit2.HOURS.toMillis(1)\n            > abs(\n                System.currentTimeMillis()\n                    - timestamp)) // don't deserialize something too old to prevent a replay attack\n        {\n          return (ConsoleAnnotator) ois.readObject();\n        }\n      }\n    } catch (GeneralSecurityException e) {\n      throw new IOException2(e);\n    } catch (ClassNotFoundException e) {\n      throw new IOException2(e);\n    } finally {\n      IOUtils.closeQuietly(ois);\n    }\n    // start from scratch\n    return ConsoleAnnotator.initial(context == null ? null : context.getClass());\n  }\n"}, {"dataset": "init", "exampleID": 1030, "initialization": ["SecureRandom random = new SecureRandom()", "AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [620, 723, 764], "initializationEnd": [638, 746, 806], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["random.nextBytes(byte[])"], "configurationStart": [673], "configurationEnd": [689], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params,random)", "focalAPIStart": 813, "focalAPIEnd": 859, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.wrap(Key)", "cipher.wrap(Key)", "cipher.unwrap(byte[],String,int)", "cipher.init(*,Key,AlgorithmParameterSpec,SecureRandom)", "cipher.unwrap(byte[],String,int)", "cipher.unwrap(byte[],String,int)", "cipher.unwrap(byte[],String,int)", "cipher.init(*,Key,AlgorithmParameterSpec,SecureRandom)", "cipher.unwrap(byte[],String,int)"], "useStart": [880, 918, 954, 1112, 1197, 1278, 1337, 1558, 1621], "useEnd": [900, 935, 995, 1160, 1238, 1316, 1380, 1603, 1665], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/crypto/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  @TestTargets({\n    @TestTargetNew(\n      level = TestLevel.COMPLETE,\n      notes = \"\",\n      method = \"unwrap\",\n      args = {byte[].class, java.lang.String.class, int.class}\n    ),\n    @TestTargetNew(\n      level = TestLevel.COMPLETE,\n      notes = \"\",\n      clazz = CipherSpi.class,\n      method = \"engineUnwrap\",\n      args = {byte[].class, java.lang.String.class, int.class}\n    )\n  })\n  public void test_unwrap$BLjava_lang_StringI()\n      throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n          InvalidAlgorithmParameterException, IllegalBlockSizeException {\n    SecureRandom sr = new SecureRandom();\n    byte[] iv = new byte[8];\n    sr.nextBytes(iv);\n    AlgorithmParameterSpec ap = new IvParameterSpec(iv);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n    c.init(Cipher.WRAP_MODE, cipherKeyDES, ap, sr);\n    byte[] arDES = c.wrap(cipherKeyDES);\n    byte[] ar = c.wrap(cipherKey);\n\n    try {\n      c.unwrap(arDES, \"DES\", Cipher.SECRET_KEY);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n      // expected\n    }\n\n    c.init(Cipher.UNWRAP_MODE, cipherKeyDES, ap, sr);\n    assertTrue(cipherKeyDES.equals(c.unwrap(arDES, \"DES\", Cipher.SECRET_KEY)));\n    assertFalse(cipherKeyDES.equals(c.unwrap(ar, \"DES\", Cipher.SECRET_KEY)));\n\n    try {\n      c.unwrap(arDES, \"RSA38\", Cipher.PUBLIC_KEY);\n      fail(\"NoSuchAlgorithmException expected\");\n    } catch (NoSuchAlgorithmException e) {\n      // expected\n    }\n\n    c = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n    c.init(Cipher.UNWRAP_MODE, cipherKey, ap, sr);\n    try {\n      c.unwrap(arDES, \"DESede\", Cipher.SECRET_KEY);\n      fail(\"InvalidKeyException expected\");\n    } catch (InvalidKeyException e) {\n      // expected\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1031, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [96], "initializationEnd": [138], "hasTryCatch": 1, "exceptionType": "BadPaddingException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 75, "tryExpressionEnd": 79, "tryBlockStart": 75, "tryBlockEnd": 811, "catchExpressionStart": 333, "catchExpressionEnd": 363, "catchBlockStart": 333, "catchBlockEnd": 408, "exceptionHandlingCallStart": [382], "exceptionHandlingCallEnd": [401], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 146, "focalAPIEnd": 183, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.getIV()", "cipher.doFinal(byte[])"], "useStart": [210, 252], "useEnd": [224, 288], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ms969/ChenSun/tree/master/CS5430/src/crypto/SharedKeyCrypto.java", "rawCode": "  public static String encrypt(String txt) {\n    Cipher cipher = null;\n    try {\n      cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n      cipher.init(Cipher.ENCRYPT_MODE, key);\n      String iv = encode(cipher.getIV());\n      byte[] encrypted = cipher.doFinal(txt.getBytes(\"UTF8\"));\n      return iv + encode(encrypted);\n    } catch (BadPaddingException e) {\n      if (DEBUG) e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n      if (DEBUG) e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n      if (DEBUG) e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n      if (DEBUG) e.printStackTrace();\n    } catch (InvalidKeyException e) {\n      if (DEBUG) e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n      if (DEBUG) e.printStackTrace();\n    }\n    return null;\n  }\n"}, {"dataset": "init", "exampleID": 1032, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(String)"], "initializationStart": [325, 364], "initializationEnd": [341, 393], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 399, "focalAPIEnd": 436, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new SealedObject(String,cipher)"], "useStart": [460], "useEnd": [492], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wsot/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/SealedObjectTest.java", "rawCode": "  /**\n   * getAlgorithm() method testing. Tests if the returned value equals to the corresponding value of\n   * Cipher object.\n   */\n  public void testGetAlgorithm() throws Exception {\n    String secret = \"secret string\";\n    String algorithm = \"DES\";\n    KeyGenerator kg = KeyGenerator.getInstance(algorithm);\n    Key key = kg.generateKey();\n\n    Cipher cipher = Cipher.getInstance(algorithm);\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    SealedObject so = new SealedObject(secret, cipher);\n\n    assertEquals(\n        \"The algorithm name should be the same as used \" + \"in cipher.\",\n        algorithm,\n        so.getAlgorithm());\n  }\n"}, {"dataset": "init", "exampleID": 1033, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [279], "initializationEnd": [304], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "new CryptoException(String)"], "tryExpressionStart": 251, "tryExpressionEnd": 255, "tryBlockStart": 251, "tryBlockEnd": 488, "catchExpressionStart": 380, "catchExpressionEnd": 400, "catchBlockStart": 380, "catchBlockEnd": 488, "exceptionHandlingCallStart": [466, 414], "exceptionHandlingCallEnd": [480, 481], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 312, "focalAPIEnd": 334, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [349], "useEnd": [372], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SSilence/scotty/tree/master/scotty-commons/src/main/java/scotty/crypto/RSAEncryption.java", "rawCode": "  /**\n   * Encrypt or decrypt with AES\n   *\n   * @param content\n   * @param key\n   * @param decrypt\n   * @return\n   * @throws CryptoException\n   */\n  private static byte[] encryptDecrypt(byte[] content, Key key, int mode) throws CryptoException {\n    try {\n      Cipher cipher = Cipher.getInstance(\"RSA\");\n      cipher.init(mode, key);\n      return cipher.doFinal(content);\n    } catch (Exception e) {\n      throw new CryptoException(\"error decrypting with RSA: \" + e.getMessage());\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1034, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [130], "initializationEnd": [186], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 192, "focalAPIEnd": 241, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(int,Key)"], "useStart": [314], "useEnd": [363], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wsot/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  /** javax.crypto.Cipher#init(int, java.security.Key) */\n  public void test_initWithKey() throws Exception {\n    Cipher cipher = Cipher.getInstance(ALGORITHM_3DES + \"/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_3DES);\n\n    cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_3DES);\n      fail();\n    } catch (InvalidKeyException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1035, "initialization": ["Cipher cipher = getInstance(String,Provider)", "Key key = new SecretKeySpec(byte[],String)"], "initializationStart": [316, 595], "initializationEnd": [361, 624], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 630, "focalAPIEnd": 686, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[])"], "useStart": [701, 918, 991], "useEnd": [720, 974, 1010], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/CryptoJS/tree/master/tags/2.5.3/test/DesTestValues.java", "rawCode": "  /**\n   * @param args\n   * @throws NoSuchPaddingException\n   * @throws NoSuchAlgorithmException\n   * @throws GeneralSecurityException\n   */\n  public static void main(String[] args) throws GeneralSecurityException {\n    Provider prov = new BouncyCastleProvider();\n    Security.addProvider(prov);\n    Cipher cipher = Cipher.getInstance(\"DES/ECB/NoPadding\", prov);\n\n    Random rand = new Random(1234567890123457890l);\n    List<byte[]> data = new ArrayList<byte[]>(100);\n\n    byte[] key = new byte[8];\n    byte[] inp = new byte[8];\n    data.add(key.clone());\n    data.add(inp.clone());\n    Key k = new SecretKeySpec(key, \"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, k, (SecureRandom) null);\n    data.add(cipher.doFinal(inp));\n\n    for (int i = 0; i < 50; i++) {\n      rand.nextBytes(key);\n      rand.nextBytes(inp);\n      data.add(key.clone());\n      data.add(inp.clone());\n      k = new SecretKeySpec(key, \"DES\");\n      cipher.init(Cipher.ENCRYPT_MODE, k, (SecureRandom) null);\n      data.add(cipher.doFinal(inp));\n    }\n\n    for (byte[] d : data) {\n      System.out.println(\" \\\"\" + encode(d) + \"\\\",\");\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1036, "initialization": ["Cipher cipher = getCipher(Key)"], "initializationStart": [80], "initializationEnd": [94], "hasTryCatch": 1, "exceptionType": "InvalidKeyException", "exceptionHandlingCall": ["new IllegalArgumentException(String,*)"], "tryExpressionStart": 101, "tryExpressionEnd": 105, "tryBlockStart": 101, "tryBlockEnd": 255, "catchExpressionStart": 158, "catchExpressionEnd": 188, "catchBlockStart": 158, "catchBlockEnd": 255, "exceptionHandlingCallStart": [202], "exceptionHandlingCallEnd": [248], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 113, "focalAPIEnd": 150, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [309], "useEnd": [334], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fathomdb/cloud/tree/master/fathomcloud-client/src/main/java/io/fathom/cloud/openstack/client/identity/ChallengeResponses.java", "rawCode": "  public static byte[] encrypt(Key key, byte[] plaintext) {\n    Cipher cipher = getCipher(key);\n\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, key);\n    } catch (InvalidKeyException e) {\n      throw new IllegalArgumentException(\"Invalid key\", e);\n    }\n\n    byte[] ciphertext;\n    try {\n      ciphertext = cipher.doFinal(plaintext);\n    } catch (IllegalBlockSizeException e) {\n      throw new IllegalArgumentException(\"Error in encryption\", e);\n    } catch (BadPaddingException e) {\n      throw new IllegalArgumentException(\"Error in encryption\", e);\n    }\n    return ciphertext;\n  }\n"}, {"dataset": "init", "exampleID": 1037, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(*)"], "initializationStart": [198, 265], "initializationEnd": [214, 297], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 304, "focalAPIEnd": 335, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.wrap(Key)", "cipher.init(int,Key)", "cipher.unwrap(byte[],String,int)"], "useStart": [357, 376, 431], "useEnd": [370, 409, 482], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/func/CipherWrapThread.java", "rawCode": "  @Override\n  public void crypt() throws Exception {\n    KeyGenerator kg = KeyGenerator.getInstance(getAlgName().replace(\"Wrap\", \"\"));\n    kg.init(getKeyLength(), new SecureRandom());\n    Key key = kg.generateKey();\n\n    // ignore mode and padding\n    Cipher cip = Cipher.getInstance(getAlgName());\n\n    cip.init(Cipher.WRAP_MODE, key);\n    byte[] output = cip.wrap(key);\n    cip.init(Cipher.UNWRAP_MODE, key);\n    Key decrypted = cip.unwrap(output, getAlgName(), Cipher.SECRET_KEY);\n\n    checkEncodedData(key.getFormat().getBytes(), decrypted.getFormat().getBytes());\n    checkEncodedData(key.getEncoded(), decrypted.getEncoded());\n  }\n"}, {"dataset": "init", "exampleID": 1038, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(String)"], "initializationStart": [289, 332], "initializationEnd": [309, 374], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 380, "focalAPIEnd": 417, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(String)"], "useStart": [424], "useEnd": [464], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/javax/crypto/JceSecurity/SunJCE_BC_LoadOrdering.java", "rawCode": "  public static void main(String args[]) throws Exception {\n    /*\n     * Generate a random key, and encrypt the data\n     */\n    Security.insertProviderAt(new MyProvider(), 1);\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n    keyGen.init(new SecureRandom());\n\n    Key key = keyGen.generateKey();\n\n    Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n\n    cipher.doFinal(\"some string\".getBytes());\n  }\n"}, {"dataset": "init", "exampleID": 1039, "initialization": ["Key key = createDESKey(byte[],int)", "Cipher cipher = getInstance(String)"], "initializationStart": [459, 596], "initializationEnd": [484, 635], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 641, "focalAPIEnd": 678, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])"], "useStart": [705, 733, 803, 831, 897], "useEnd": [727, 773, 825, 869, 919], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/safuus/MobX/tree/master/mobxserver/apache-mina-2.0.4/src/mina-core/src/main/java/org/apache/mina/proxy/handlers/http/ntlm/NTLMResponses.java", "rawCode": "  /**\n   * Creates the LM Response from the given hash and Type 2 challenge.\n   *\n   * @param hash The LM or NTLM Hash.\n   * @param challenge The server challenge from the Type 2 message.\n   * @return The response (either LM or NTLM, depending on the provided hash).\n   */\n  private static byte[] lmResponse(byte[] hash, byte[] challenge) throws Exception {\n    byte[] keyBytes = new byte[21];\n    System.arraycopy(hash, 0, keyBytes, 0, 16);\n    Key lowKey = createDESKey(keyBytes, 0);\n    Key middleKey = createDESKey(keyBytes, 7);\n    Key highKey = createDESKey(keyBytes, 14);\n    Cipher des = Cipher.getInstance(\"DES/ECB/NoPadding\");\n    des.init(Cipher.ENCRYPT_MODE, lowKey);\n    byte[] lowResponse = des.doFinal(challenge);\n    des.init(Cipher.ENCRYPT_MODE, middleKey);\n    byte[] middleResponse = des.doFinal(challenge);\n    des.init(Cipher.ENCRYPT_MODE, highKey);\n    byte[] highResponse = des.doFinal(challenge);\n    byte[] lmResponse = new byte[24];\n    System.arraycopy(lowResponse, 0, lmResponse, 0, 8);\n    System.arraycopy(middleResponse, 0, lmResponse, 8, 8);\n    System.arraycopy(highResponse, 0, lmResponse, 16, 8);\n    return lmResponse;\n  }\n"}, {"dataset": "init", "exampleID": 1040, "initialization": ["Cipher cipher = getInstance(String)", "AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [150, 1857, 1898], "initializationEnd": [195, 1880, 1937], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["cipher.init(int,Key,IvParameterSpec)", "cipher.update(byte[],int,int)", "cipher.doFinal()"], "configurationStart": [610, 1107, 1282], "configurationEnd": [644, 1136, 1293], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 1943, "focalAPIEnd": 1990, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.update(byte[],int,int,byte[],int)", "cipher.doFinal()", "cipher.doFinal()", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[],int,int,byte[],int)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.getIV()", "cipher.update(byte[],int,int,byte[],int)", "cipher.doFinal()"], "useStart": [1996, 2039, 2189, 2323, 2386, 2498, 2576, 2598, 2641], "useEnd": [2021, 2050, 2200, 2370, 2412, 2545, 2585, 2623, 2652], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  /** javax.crypto.Cipher#doFinal() */\n  public void test_doFinal() throws Exception {\n    for (int index = 1; index < 4; index++) {\n      Cipher c = Cipher.getInstance(\"DESEDE/CBC/PKCS5Padding\");\n\n      byte[] keyMaterial = loadBytes(\"hyts_\" + \"des-ede3-cbc.test\" + index + \".key\");\n      DESedeKeySpec keySpec = new DESedeKeySpec(keyMaterial);\n      SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DESEDE\");\n      Key k = skf.generateSecret(keySpec);\n\n      byte[] ivMaterial = loadBytes(\"hyts_\" + \"des-ede3-cbc.test\" + index + \".iv\");\n      IvParameterSpec iv = new IvParameterSpec(ivMaterial);\n\n      c.init(Cipher.ENCRYPT_MODE, k, iv);\n\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      byte[] input = new byte[256];\n      String resPath = \"hyts_\" + \"des-ede3-cbc.test\" + index + \".plaintext\";\n      File resources = Support_Resources.createTempFolder();\n      Support_Resources.copyFile(resources, null, resPath);\n      InputStream is = Support_Resources.getStream(resPath);\n\n      int bytesRead = is.read(input, 0, 256);\n      while (bytesRead > 0) {\n        byte[] output = c.update(input, 0, bytesRead);\n        if (output != null) {\n          baos.write(output);\n        }\n        bytesRead = is.read(input, 0, 256);\n      }\n      byte[] output = c.doFinal();\n      if (output != null) {\n        baos.write(output);\n      }\n      byte[] encryptedPlaintext = baos.toByteArray();\n      is.close();\n\n      byte[] cipherText = loadBytes(\"hyts_\" + \"des-ede3-cbc.test\" + index + \".ciphertext\");\n      assertEquals(\n          \"Operation produced incorrect results for index \" + index,\n          Arrays.toString(cipherText),\n          Arrays.toString(encryptedPlaintext));\n    }\n\n    byte[] b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n    byte[] b1 = new byte[30];\n    AlgorithmParameterSpec ap = new IvParameterSpec(IV);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    c.update(b, 0, 10, b1, 5);\n    try {\n      c.doFinal();\n      fail();\n    } catch (IllegalBlockSizeException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      c.doFinal();\n      fail();\n    } catch (IllegalStateException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    int len = c.doFinal(b, 0, 16, b1, 0);\n    assertEquals(16, len);\n\n    c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, ap);\n    assertTrue(Arrays.equals(c.getIV(), IV));\n\n    c.update(b1, 0, 24, b, 0);\n    try {\n      c.doFinal();\n      fail();\n    } catch (BadPaddingException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1041, "initialization": ["Cipher cipher = getInstance(String)", "AlgorithmParameters params = getInstance(String)"], "initializationStart": [725, 853], "initializationEnd": [752, 895], "hasTryCatch": 1, "exceptionType": "NoSuchPaddingException", "exceptionHandlingCall": ["toString()", "new NoSuchAlgorithmException(*)"], "tryExpressionStart": 697, "tryExpressionEnd": 701, "tryBlockStart": 697, "tryBlockEnd": 2159, "catchExpressionStart": 1246, "catchExpressionEnd": 1279, "catchBlockStart": 1246, "catchBlockEnd": 1432, "exceptionHandlingCallStart": [1412, 1383], "exceptionHandlingCallEnd": [1424, 1425], "configuration": ["params.init(byte[])"], "configurationStart": [905], "configurationEnd": [931], "guardCondition": "!(key==null)", "guardType": "IF {", "guardExpressionStart": 616, "guardExpressionEnd": 632, "guardBlockStart": 616, "guardBlockEnd": 692, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 941, "focalAPIEnd": 986, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(int,Key)", "cipher.doFinal(byte[])"], "useStart": [1011, 1084], "useEnd": [1048, 1116], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/main/java/javax/crypto/SealedObject.java", "rawCode": "  /**\n   * Returns the wrapped object, decrypting it using the specified key.\n   *\n   * @param key the key to decrypt the data with.\n   * @return the encapsulated object.\n   * @throws IOException if deserialization fails.\n   * @throws ClassNotFoundException if deserialization fails.\n   * @throws NoSuchAlgorithmException if the algorithm to decrypt the data is not available.\n   * @throws InvalidKeyException if the specified key cannot be used to decrypt the data.\n   */\n  public final Object getObject(Key key)\n      throws IOException, ClassNotFoundException, NoSuchAlgorithmException, InvalidKeyException {\n    if (key == null) {\n      throw new InvalidKeyException(\"key == null\");\n    }\n    try {\n      Cipher cipher = Cipher.getInstance(sealAlg);\n      if ((paramsAlg != null) && (paramsAlg.length() != 0)) {\n        AlgorithmParameters params = AlgorithmParameters.getInstance(paramsAlg);\n        params.init(encodedParams);\n        cipher.init(Cipher.DECRYPT_MODE, key, params);\n      } else {\n        cipher.init(Cipher.DECRYPT_MODE, key);\n      }\n      byte[] serialized = cipher.doFinal(encryptedContent);\n      ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serialized));\n      return ois.readObject();\n    } catch (NoSuchPaddingException e) {\n      // should not be thrown because cipher text was made\n      // with existing padding\n      throw new NoSuchAlgorithmException(e.toString());\n    } catch (InvalidAlgorithmParameterException e) {\n      // should not be thrown because cipher text was made\n      // with correct algorithm parameters\n      throw new NoSuchAlgorithmException(e.toString());\n    } catch (IllegalBlockSizeException e) {\n      // should not be thrown because the cipher text\n      // was correctly made\n      throw new NoSuchAlgorithmException(e.toString());\n    } catch (BadPaddingException e) {\n      // should not be thrown because the cipher text\n      // was correctly made\n      throw new NoSuchAlgorithmException(e.toString());\n    } catch (IllegalStateException e) {\n      // should never be thrown because cipher is initialized\n      throw new NoSuchAlgorithmException(e.toString());\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1042, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [369], "initializationEnd": [394], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 400, "focalAPIEnd": 437, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/europeana/contrib/tree/master/ait/trunk/yuma/src/test/java/at/ait/dme/yuma/server/test/AuthenticationTest.java", "rawCode": "  private String encrypt(String plainText, Key key)\n      throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n          ShortBufferException, IllegalBlockSizeException, BadPaddingException {\n\n    byte[] plainTextBytes = plainText.getBytes();\n    byte[] encText = new byte[(((plainTextBytes.length - 1) / 100 + 1)) * 128];\n\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    for (int inOffset = 0, outOffset = 0, inLen = 0;\n        (inLen = plainTextBytes.length - inOffset) > 0;\n        inOffset += 100) {\n      outOffset +=\n          cipher.doFinal(plainTextBytes, inOffset, Math.min(100, inLen), encText, outOffset);\n    }\n\n    // also test serialization\n    BigInteger bi = new BigInteger(encText);\n    return bi.toString(16);\n  }\n"}, {"dataset": "init", "exampleID": 1043, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "InvalidKeyException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 28, "tryExpressionEnd": 32, "tryBlockStart": 28, "tryBlockEnd": 544, "catchExpressionStart": 336, "catchExpressionEnd": 367, "catchBlockStart": 336, "catchBlockEnd": 402, "exceptionHandlingCallStart": [375], "exceptionHandlingCallEnd": [395], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 116, "focalAPIEnd": 179, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gissolutions/jsimpleutils/tree/master/src/main/java/org/gissolutions/jsimpleutils/admin/Encryptor.java", "rawCode": "  private void init() {\n    try {\n      this._EcryptionCipher = Cipher.getInstance(this.algorithm.getName());\n      this._EcryptionCipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\n      this._DecryptionCipher = Cipher.getInstance(this.algorithm.getName());\n      this._DecryptionCipher.init(Cipher.DECRYPT_MODE, this.secretKey);\n    } catch (InvalidKeyException ex) {\n      ex.printStackTrace();\n    } catch (NoSuchAlgorithmException ex) {\n      ex.printStackTrace();\n    } catch (NoSuchPaddingException ex) {\n      ex.printStackTrace();\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1044, "initialization": ["Cipher cipher = length()"], "initializationStart": [533], "initializationEnd": [550], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new AsymmetricEncryptionException(String,*)"], "tryExpressionStart": 464, "tryExpressionEnd": 468, "tryBlockStart": 464, "tryBlockEnd": 1324, "catchExpressionStart": 1183, "catchExpressionEnd": 1203, "catchBlockStart": 1183, "catchBlockEnd": 1324, "exceptionHandlingCallStart": [1217], "exceptionHandlingCallEnd": [1317], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 791, "focalAPIEnd": 828, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])"], "useStart": [873, 1014, 1081], "useEnd": [907, 1051, 1113], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mcaserta/spring-crypto-utils/tree/master/src/main/java/com/springcryptoutils/core/cipher/asymmetric/Base64EncodedCiphererImpl.java", "rawCode": "  /**\n   * Encrypts/decrypts a message based on the underlying mode of operation.\n   *\n   * @param message if in encryption mode, the clear-text message, otherwise the base64 encoded\n   *     message to decrypt\n   * @return if in encryption mode, the base64 encoded encrypted message, otherwise the decrypted\n   *     message\n   * @throws AsymmetricEncryptionException on runtime errors\n   * @see #setMode(Mode)\n   */\n  public String encrypt(String message) {\n    try {\n      final Cipher cipher =\n          (((provider == null) || (provider.length() == 0))\n              ? Cipher.getInstance(algorithm)\n              : Cipher.getInstance(algorithm, provider));\n      switch (mode) {\n        case ENCRYPT:\n          final byte[] messageAsByteArray = message.getBytes(charsetName);\n          cipher.init(Cipher.ENCRYPT_MODE, key);\n          return Base64.encodeBase64String(cipher.doFinal(messageAsByteArray));\n        case DECRYPT:\n          final byte[] encryptedMessage = Base64.decodeBase64(message);\n          cipher.init(Cipher.DECRYPT_MODE, key);\n          return new String(cipher.doFinal(encryptedMessage), charsetName);\n        default:\n          return null;\n      }\n    } catch (Exception e) {\n      throw new AsymmetricEncryptionException(\n          \"error encrypting/decrypting message; mode=\" + mode, e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1045, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [135], "initializationEnd": [164], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 115, "tryExpressionEnd": 119, "tryBlockStart": 115, "tryBlockEnd": 713, "catchExpressionStart": 253, "catchExpressionEnd": 288, "catchBlockStart": 253, "catchBlockEnd": 350, "exceptionHandlingCallStart": [296], "exceptionHandlingCallEnd": [343], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 172, "focalAPIEnd": 208, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [225], "useEnd": [245], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rczerny/vs2012-13/tree/master/src/test/SuperSecureSocketTest.java", "rawCode": "  public byte[] encrypt(byte[] input, String algorithm, Key key) {\n    byte[] output = null;\n    Cipher crypt;\n    try {\n      crypt = Cipher.getInstance(algorithm);\n      crypt.init(Cipher.ENCRYPT_MODE, key);\n      output = crypt.doFinal(input);\n    } catch (NoSuchAlgorithmException e) {\n      System.err.println(\"ERROR: Algorithm unknown!\");\n    } catch (NoSuchPaddingException e) {\n      System.err.println(\"ERROR: No padding!\");\n    } catch (IllegalBlockSizeException e) {\n      System.err.println(\"ERROR: Illegal block size!\");\n    } catch (BadPaddingException e) {\n      System.err.println(\"ERROR: Bad padding!\");\n    } catch (InvalidKeyException e) {\n      System.err.println(\"ERROR: Invalid key!\");\n    }\n    return output;\n  }\n"}, {"dataset": "init", "exampleID": 1046, "initialization": ["Key key = getSecretKeySpec()"], "initializationStart": [384], "initializationEnd": [402], "hasTryCatch": 1, "exceptionType": "InvalidKeyException", "exceptionHandlingCall": ["new EncryptionException(*)"], "tryExpressionStart": 408, "tryExpressionEnd": 412, "tryBlockStart": 408, "tryBlockEnd": 549, "catchExpressionStart": 472, "catchExpressionEnd": 502, "catchBlockStart": 472, "catchBlockEnd": 549, "exceptionHandlingCallStart": [516], "exceptionHandlingCallEnd": [542], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 420, "focalAPIEnd": 464, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kwatson7/Tools3/tree/master/src/com/tools/encryption/CipherStore.java", "rawCode": "  /**\n   * Grab the encryption cipher. If it is null, will generate a new one with fresh encryption\n   * initialization\n   *\n   * @return\n   * @throws EncryptionException\n   */\n  public Cipher getEncryptCipher() throws EncryptionException {\n    // if null, then creat a new one\n    if (encryptCipher == null) initializeEncryptCipher();\n\n    // initialize it to be fresh\n    Key sks = getSecretKeySpec();\n    try {\n      encryptCipher.init(Cipher.ENCRYPT_MODE, sks);\n    } catch (InvalidKeyException e) {\n      throw new EncryptionException(e);\n    }\n\n    // return it\n    return encryptCipher;\n  }\n"}, {"dataset": "init", "exampleID": 1047, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "new Exception(String)"], "tryExpressionStart": 149, "tryExpressionEnd": 153, "tryBlockStart": 149, "tryBlockEnd": 413, "catchExpressionStart": 318, "catchExpressionEnd": 341, "catchBlockStart": 318, "catchBlockEnd": 413, "exceptionHandlingCallStart": [386, 357], "exceptionHandlingCallEnd": [403, 404], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 163, "focalAPIEnd": 209, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [231], "useEnd": [282], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Top-Cat/MineCod/tree/master/src/main/java/uk/co/thomasc/codmw/util/MCrypt.java", "rawCode": "  public byte[] decrypt(String code) throws Exception {\n    if (code != null && code.length() != 0) {\n      byte[] decrypted = (byte[]) null;\n\n      try {\n        this.cipher.init(2, this.keyspec, this.ivspec);\n        decrypted = this.cipher.doFinal(hexToBytes(code.toCharArray()));\n        return decrypted;\n      } catch (Exception var4) {\n        throw new Exception(\"[decrypt] \" + var4.getMessage());\n      }\n    } else {\n      throw new Exception(\"Empty string\");\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1048, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [444], "initializationEnd": [483], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 406, "tryExpressionEnd": 410, "tryBlockStart": 406, "tryBlockEnd": 1554, "catchExpressionStart": 1480, "catchExpressionEnd": 1500, "catchBlockStart": 1480, "catchBlockEnd": 1554, "exceptionHandlingCallStart": [1518], "exceptionHandlingCallEnd": [1537], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 528, "focalAPIEnd": 575, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[],int,int)", "cipher.init(int,Key)", "cipher.doFinal(byte[],int,int)", "cipher.init(int,Key)", "cipher.doFinal(byte[],int,int)", "cipher.init(int,Key)", "cipher.doFinal(byte[],int,int)"], "useStart": [605, 682, 759, 984, 1061, 1138, 1215], "useEnd": [637, 729, 791, 1031, 1093, 1185, 1247], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cathyjf/PokemonLabClient/tree/master/src/shoddybattleclient/network/ServerLink.java", "rawCode": "            public void handle(ServerLink link, DataInputStream is) throws IOException {\n              byte[] challenge = new byte[16];\n              is.readFully(challenge);\n              int style = is.readUnsignedByte();\n              String salt = is.readUTF();\n\n              link.createKeySpec(style, salt);\n              link.m_password = null;\n\n              // decrypt the challenge\n              try {\n                Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n\n                // pass 1\n                cipher.init(Cipher.DECRYPT_MODE, link.m_key[1]);\n                challenge = cipher.doFinal(challenge, 0, 16);\n\n                // pass 2\n                cipher.init(Cipher.DECRYPT_MODE, link.m_key[0]);\n                challenge = cipher.doFinal(challenge, 0, 16);\n\n                ByteBuffer buffer = ByteBuffer.wrap(challenge);\n                int r = buffer.getInt(0) + 1;\n                buffer.putInt(0, r);\n\n                // pass 1\n                cipher.init(Cipher.ENCRYPT_MODE, link.m_key[0]);\n                challenge = cipher.doFinal(challenge, 0, 16);\n\n                // pass 2\n                cipher.init(Cipher.ENCRYPT_MODE, link.m_key[1]);\n                challenge = cipher.doFinal(challenge, 0, 16);\n\n                link.sendMessage(new ChallengeResponseMessage(challenge));\n\n                // don't keep the keys in memory indefinitely\n                link.m_key[0] = null;\n                link.m_key[1] = null;\n              } catch (Exception e) {\n                e.printStackTrace();\n              }\n            }\n"}, {"dataset": "init", "exampleID": 1049, "initialization": ["AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [354, 395], "initializationEnd": [377, 434], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 440, "focalAPIEnd": 487, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.doFinal(byte[])", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[])", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[],int,int,byte[],int)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[])"], "useStart": [505, 658, 795, 859, 914, 978, 1093, 1158], "useEnd": [519, 672, 842, 873, 961, 1006, 1140, 1171], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void test_doFinal$B() throws Exception {\n    byte[] b1 = new byte[32];\n    byte[] bI1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    byte[] bI2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n    byte[] bI3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n    byte[] bI4 = {1, 2, 3};\n    AlgorithmParameterSpec ap = new IvParameterSpec(IV);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    try {\n      c.doFinal(bI1);\n      fail();\n    } catch (IllegalBlockSizeException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      c.doFinal(bI1);\n      fail();\n    } catch (IllegalStateException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    int len1 = c.doFinal(bI2).length;\n    assertEquals(16, len1);\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    int len2 = c.doFinal(bI3, 0, 16, b1, 0);\n    assertEquals(16, len2);\n\n    c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, ap);\n    try {\n      c.doFinal(b1);\n      fail();\n    } catch (BadPaddingException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1050, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IllegalBlockSizeException", "exceptionHandlingCall": ["getMessage()", "new InternalServerErrorException(String)"], "tryExpressionStart": 483, "tryExpressionEnd": 487, "tryBlockStart": 483, "tryBlockEnd": 976, "catchExpressionStart": 581, "catchExpressionEnd": 618, "catchBlockStart": 581, "catchBlockEnd": 720, "exceptionHandlingCallStart": [697, 632], "exceptionHandlingCallEnd": [712, 713], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 495, "focalAPIEnd": 535, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [550], "useEnd": [573], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NoNSAChat/Server/tree/master/src/RMIChatServer/CommonFunctions/CommonFunctions.java", "rawCode": "  /**\n   * Diese Funktion ENTschlüsselt ein Byte-Array. Methode: AES\n   *\n   * @param code Das ist der zu entschlüsselnde Text.\n   * @param key Mit dem symmetrischen Key wird der Code entschlüsselt.\n   * @return Die Funktion gibt ein byte-Array zurück.\n   * @throws InvalidKeyException\n   * @throws IllegalBlockSizeException\n   * @throws BadPaddingException\n   * @author Pascal Lacmann\n   */\n  public byte[] AESDecrypt(byte[] code, Key key) throws InternalServerErrorException {\n    try {\n      AESCipher.init(Cipher.DECRYPT_MODE, key);\n      return AESCipher.doFinal(code);\n    } catch (IllegalBlockSizeException ex) {\n      throw new InternalServerErrorException(\"IllegalBlockSizeException: \" + ex.getMessage());\n    } catch (BadPaddingException ex) {\n      throw new InternalServerErrorException(\"BadPaddingException: \" + ex.getMessage());\n    } catch (InvalidKeyException ex) {\n      throw new InternalServerErrorException(\"InvalidKeyException: \" + ex.getMessage());\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1051, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 57, "tryExpressionEnd": 61, "tryBlockStart": 57, "tryBlockEnd": 239, "catchExpressionStart": 175, "catchExpressionEnd": 195, "catchBlockStart": 175, "catchBlockEnd": 239, "exceptionHandlingCallStart": [209], "exceptionHandlingCallEnd": [232], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 69, "focalAPIEnd": 99, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [127], "useEnd": [166], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ixcode/platform/tree/master/core/src/main/java/ixcode/platform/cryptography/AesEncryption.java", "rawCode": "  @Override\n  public String encrypt(String source) {\n    try {\n      cipher.init(ENCRYPT_MODE, key);\n      return base64Encode(cipher.doFinal(source.getBytes(\"UTF8\")));\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1052, "initialization": ["Key key = new SecretKeySpec(byte[],String)", "Cipher cipher = getInstance(String,String)"], "initializationStart": [263, 378], "initializationEnd": [303, 429], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 435, "focalAPIEnd": 469, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new CipherOutputStream(ByteArrayOutputStream,cipher)"], "useStart": [600], "useEnd": [633], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bcgit/bc-java/tree/master/prov/src/test/java/org/bouncycastle/jce/provider/test/GOST28147Test.java", "rawCode": "  public void testECB(int strength, byte[] keyBytes, byte[] input, byte[] output) throws Exception {\n    Key key;\n    Cipher in, out;\n    CipherInputStream cIn;\n    CipherOutputStream cOut;\n    ByteArrayInputStream bIn;\n    ByteArrayOutputStream bOut;\n\n    key = new SecretKeySpec(keyBytes, \"GOST28147\");\n\n    in = Cipher.getInstance(\"GOST28147/ECB/NoPadding\", \"BC\");\n    out = Cipher.getInstance(\"GOST28147/ECB/NoPadding\", \"BC\");\n    out.init(Cipher.ENCRYPT_MODE, key);\n    in.init(Cipher.DECRYPT_MODE, key);\n\n    //\n    // encryption pass\n    //\n    bOut = new ByteArrayOutputStream();\n\n    cOut = new CipherOutputStream(bOut, out);\n\n    for (int i = 0; i != input.length / 2; i++) {\n      cOut.write(input[i]);\n    }\n    cOut.write(input, input.length / 2, input.length - input.length / 2);\n    cOut.close();\n\n    byte[] bytes;\n\n    bytes = bOut.toByteArray();\n\n    if (!areEqual(bytes, output)) {\n      fail(\n          \"GOST28147 failed encryption - expected \"\n              + new String(Hex.encode(output))\n              + \" got \"\n              + new String(Hex.encode(bytes)));\n    }\n\n    //\n    // decryption pass\n    //\n    bIn = new ByteArrayInputStream(bytes);\n\n    cIn = new CipherInputStream(bIn, in);\n\n    DataInputStream dIn = new DataInputStream(cIn);\n\n    bytes = new byte[input.length];\n\n    for (int i = 0; i != input.length / 2; i++) {\n      bytes[i] = (byte) dIn.read();\n    }\n    dIn.readFully(bytes, input.length / 2, bytes.length - input.length / 2);\n\n    if (!areEqual(bytes, input)) {\n      fail(\n          \"GOST28147 failed decryption - expected \"\n              + new String(Hex.encode(input))\n              + \" got \"\n              + new String(Hex.encode(bytes)));\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1053, "initialization": ["AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [103, 144], "initializationEnd": [126, 186], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 192, "focalAPIEnd": 239, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.getParameters()", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.init(int,Key,AlgorithmParameterSpec)"], "useStart": [259, 296, 428], "useEnd": [276, 344, 499], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void test_initWithKeyAlgorithmParameters() throws Exception {\n    AlgorithmParameterSpec ap = new IvParameterSpec(IV);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, ap);\n    assertNotNull(c.getParameters());\n\n    try {\n      c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_3DES, ap);\n      fail();\n    } catch (InvalidKeyException expected) {\n    }\n\n    try {\n      c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, (AlgorithmParameters) null);\n      fail();\n    } catch (InvalidAlgorithmParameterException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1054, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(null==key||true)", "guardType": "IF {", "guardExpressionStart": 402, "guardExpressionEnd": 472, "guardBlockStart": 402, "guardBlockEnd": 520, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 1489, "focalAPIEnd": 1526, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new CipherOutputStream(*,cipher)"], "useStart": [1656], "useEnd": [1716], "hasFinally": 1, "cleanUpCall": ["InputStream.close()"], "finallyExpressionStart": 1955, "finallyExpressionEnd": 1963, "finallyBlockStart": 1955, "finallyBlockEnd": 2080, "cleanUpCallStart": [2103], "cleanUpCallEnd": [2119], "url": "https://github.com/raykroeker/thinkparity/tree/master/common/codebase/src/main/java/com/thinkparity/codebase/crypto/EncryptFile.java", "rawCode": "  /**\n   * Encrypt a file.\n   *\n   * @param key A <code>Key</code>.\n   * @param source A <code>File</code>.\n   * @param target A <code>File</code>.\n   * @param buffer A <code>byte[]</code>.\n   * @throws InvalidKeyException\n   * @throws IOException\n   */\n  public void encrypt(final Key key, final File source, final File target, final byte[] buffer)\n      throws InvalidKeyException, IOException {\n    if (null == key || null == source || null == target || null == buffer) {\n      throw new NullPointerException();\n    }\n    if (!source.exists()) {\n      throw new IllegalArgumentException(\"Source \" + source.getAbsolutePath() + \" does not exist.\");\n    }\n    if (!source.isFile()) {\n      throw new IllegalArgumentException(\"Source \" + source.getAbsolutePath() + \" is not a file.\");\n    }\n    if (!source.canRead()) {\n      throw new IllegalArgumentException(\"Source \" + source.getAbsolutePath() + \" cannot be read.\");\n    }\n    if (!target.exists()) {\n      throw new IllegalArgumentException(\"Target \" + target.getAbsolutePath() + \" does not exist.\");\n    }\n    if (!target.isFile()) {\n      throw new IllegalArgumentException(\"Target \" + target.getAbsolutePath() + \" is not a file.\");\n    }\n    if (!target.canRead()) {\n      throw new IllegalArgumentException(\"Target \" + target.getAbsolutePath() + \" cannot be read.\");\n    }\n    if (!target.canWrite()) {\n      throw new IllegalArgumentException(\n          \"Target \" + target.getAbsolutePath() + \" cannot be written to.\");\n    }\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    final InputStream inStream = new FileInputStream(source);\n    try {\n      final CipherOutputStream cipherStream =\n          new CipherOutputStream(new FileOutputStream(target), cipher);\n      try {\n        int bytesRead;\n        while (true) {\n          bytesRead = inStream.read(buffer);\n          if (-1 == bytesRead) {\n            break;\n          }\n          cipherStream.write(buffer, 0, bytesRead);\n        }\n      } finally {\n        try {\n          cipherStream.flush();\n        } finally {\n          cipherStream.close();\n        }\n      }\n    } finally {\n      inStream.close();\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1055, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [140], "initializationEnd": [179], "hasTryCatch": 1, "exceptionType": "GeneralSecurityException", "exceptionHandlingCall": ["warn(String,*)", "new SM_LOGIN_FAIL(*)", "sendPacket(*)"], "tryExpressionStart": 109, "tryExpressionEnd": 113, "tryBlockStart": 109, "tryBlockEnd": 509, "catchExpressionStart": 317, "catchExpressionEnd": 352, "catchBlockStart": 317, "catchBlockEnd": 509, "exceptionHandlingCallStart": [360, 439, 428], "exceptionHandlingCallEnd": [420, 487, 488], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 187, "focalAPIEnd": 258, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[],int,int)"], "useStart": [278], "useEnd": [309], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/xtnm/Aion-Unique-API-Server/tree/master/AE-go_LoginServer/src/com/aionemu/loginserver/network/aion/clientpackets/CM_LOGIN.java", "rawCode": "  /** {@inheritDoc} */\n  protected void runImpl() {\n    if (data == null) return;\n\n    byte[] decrypted;\n    try {\n      Cipher rsaCipher = Cipher.getInstance(\"RSA/ECB/nopadding\");\n      rsaCipher.init(Cipher.DECRYPT_MODE, getConnection().getRSAPrivateKey());\n      decrypted = rsaCipher.doFinal(data, 0, 128);\n    } catch (GeneralSecurityException e) {\n      log.warn(\"Error while decripting data on user auth.\" + e, e);\n      sendPacket(new SM_LOGIN_FAIL(AionAuthResponse.SYSTEM_ERROR));\n      return;\n    }\n    String user = new String(decrypted, 64, 32).trim().toLowerCase();\n    String password = new String(decrypted, 96, 32).trim();\n\n    int ncotp = decrypted[0x7c];\n    ncotp |= decrypted[0x7d] << 8;\n    ncotp |= decrypted[0x7e] << 16;\n    ncotp |= decrypted[0x7f] << 24;\n\n    log.debug(\"AuthLogin: \" + user + \" pass: \" + password + \" ncotp: \" + ncotp);\n\n    AionConnection client = getConnection();\n    AionAuthResponse response = AccountController.login(user, password, client);\n    switch (response) {\n      case AUTHED:\n        client.setState(State.AUTHED_LOGIN);\n        client.setSessionKey(new SessionKey(client.getAccount()));\n        client.sendPacket(new SM_LOGIN_OK(client.getSessionKey()));\n        break;\n\n      default:\n        client.close(new SM_LOGIN_FAIL(response), true);\n        break;\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1056, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [130], "initializationEnd": [186], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 192, "focalAPIEnd": 241, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(int,Key)"], "useStart": [314], "useEnd": [363], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  /** javax.crypto.Cipher#init(int, java.security.Key) */\n  public void test_initWithKey() throws Exception {\n    Cipher cipher = Cipher.getInstance(ALGORITHM_3DES + \"/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_3DES);\n\n    cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_3DES);\n      fail();\n    } catch (InvalidKeyException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1057, "initialization": ["Key key = getKey()", "Cipher cipher = getInstance(String)"], "initializationStart": [102, 165], "initializationEnd": [110, 207], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "error(*)"], "tryExpressionStart": 52, "tryExpressionEnd": 56, "tryBlockStart": 52, "tryBlockEnd": 611, "catchExpressionStart": 548, "catchExpressionEnd": 569, "catchBlockStart": 548, "catchBlockEnd": 611, "exceptionHandlingCallStart": [590, 577], "exceptionHandlingCallEnd": [603, 604], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 343, "focalAPIEnd": 383, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [443], "useEnd": [472], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/martinb3/egonet/tree/master/src/main/java/org/egonet/util/SymmetricKeyEncryption.java", "rawCode": "  public static String decrypt(String source) {\n    try {\n      // Get our secret key\n      Key key = getKey();\n\n      // Create the cipher\n      Cipher desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n\n      // Encrypt the cleartext\n      byte[] ciphertext = getBytes(source);\n\n      // Initialize the same cipher for decryption\n      desCipher.init(Cipher.DECRYPT_MODE, key);\n\n      // Decrypt the ciphertext\n      byte[] cleartext = desCipher.doFinal(ciphertext);\n\n      // Return the clear text\n      return new String(cleartext);\n    } catch (Exception ex) {\n      logger.error(ex.toString());\n    }\n    return null;\n  }\n"}, {"dataset": "init", "exampleID": 1058, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(String)"], "initializationStart": [299, 503], "initializationEnd": [322, 537], "hasTryCatch": 1, "exceptionType": "InvalidKeyException", "exceptionHandlingCall": ["getMessage()", "fail(*)"], "tryExpressionStart": 704, "tryExpressionEnd": 708, "tryBlockStart": 704, "tryBlockEnd": 933, "catchExpressionStart": 773, "catchExpressionEnd": 803, "catchBlockStart": 773, "catchBlockEnd": 845, "exceptionHandlingCallStart": [823, 811], "exceptionHandlingCallEnd": [837, 838], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 716, "focalAPIEnd": 765, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(*,Key,AlgorithmParameters)", "cipher.doFinal(byte[])"], "useStart": [978, 1191, 1467], "useEnd": [1014, 1240, 1485], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/support/src/test/java/tests/security/AlgorithmParameterSymmetricHelper.java", "rawCode": "  @Override\n  public void test(AlgorithmParameters parameters) {\n\n    KeyGenerator generator = null;\n    try {\n      generator = KeyGenerator.getInstance(algorithmName);\n    } catch (NoSuchAlgorithmException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    generator.init(keySize);\n\n    Key key = generator.generateKey();\n\n    Cipher cipher = null;\n    try {\n      String transformation = algorithmName;\n      if (blockmode != null) {\n        transformation += \"/\" + blockmode;\n      }\n      cipher = Cipher.getInstance(transformation);\n    } catch (NoSuchAlgorithmException e) {\n      Assert.fail(e.getMessage());\n    } catch (NoSuchPaddingException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, key, parameters);\n    } catch (InvalidKeyException e) {\n      Assert.fail(e.getMessage());\n    } catch (InvalidAlgorithmParameterException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    byte[] bs = null;\n    try {\n      bs = cipher.doFinal(plainData.getBytes());\n    } catch (IllegalBlockSizeException e) {\n      Assert.fail(e.getMessage());\n    } catch (BadPaddingException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    try {\n      cipher.init(Cipher.DECRYPT_MODE, key, parameters);\n    } catch (InvalidKeyException e) {\n      Assert.fail(e.getMessage());\n    } catch (InvalidAlgorithmParameterException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    byte[] decrypted = null;\n    try {\n      decrypted = cipher.doFinal(bs);\n    } catch (IllegalBlockSizeException e) {\n      Assert.fail(e.getMessage());\n    } catch (BadPaddingException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    Assert.assertTrue(Arrays.equals(plainData.getBytes(), decrypted));\n  }\n"}, {"dataset": "init", "exampleID": 1059, "initialization": ["Key key = createDESKey(byte[],int)", "Cipher cipher = getInstance(String)"], "initializationStart": [485, 628], "initializationEnd": [510, 667], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "new NTLMEngineException(*,*)"], "tryExpressionStart": 372, "tryExpressionEnd": 376, "tryBlockStart": 372, "tryBlockEnd": 1298, "catchExpressionStart": 1215, "catchExpressionEnd": 1235, "catchBlockStart": 1215, "catchBlockEnd": 1298, "exceptionHandlingCallStart": [1273, 1249], "exceptionHandlingCallEnd": [1287, 1291], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 675, "focalAPIEnd": 712, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])"], "useStart": [741, 771, 843, 873, 941], "useEnd": [763, 811, 865, 911, 963], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/esgott/szoft_arch_hazi/tree/master/lib/src/httpclient/org/apache/http/impl/auth/NTLMEngineImpl.java", "rawCode": "  /**\n   * Creates the LM Response from the given hash and Type 2 challenge.\n   *\n   * @param hash The LM or NTLM Hash.\n   * @param challenge The server challenge from the Type 2 message.\n   * @return The response (either LM or NTLM, depending on the provided hash).\n   */\n  private static byte[] lmResponse(byte[] hash, byte[] challenge) throws NTLMEngineException {\n    try {\n      byte[] keyBytes = new byte[21];\n      System.arraycopy(hash, 0, keyBytes, 0, 16);\n      Key lowKey = createDESKey(keyBytes, 0);\n      Key middleKey = createDESKey(keyBytes, 7);\n      Key highKey = createDESKey(keyBytes, 14);\n      Cipher des = Cipher.getInstance(\"DES/ECB/NoPadding\");\n      des.init(Cipher.ENCRYPT_MODE, lowKey);\n      byte[] lowResponse = des.doFinal(challenge);\n      des.init(Cipher.ENCRYPT_MODE, middleKey);\n      byte[] middleResponse = des.doFinal(challenge);\n      des.init(Cipher.ENCRYPT_MODE, highKey);\n      byte[] highResponse = des.doFinal(challenge);\n      byte[] lmResponse = new byte[24];\n      System.arraycopy(lowResponse, 0, lmResponse, 0, 8);\n      System.arraycopy(middleResponse, 0, lmResponse, 8, 8);\n      System.arraycopy(highResponse, 0, lmResponse, 16, 8);\n      return lmResponse;\n    } catch (Exception e) {\n      throw new NTLMEngineException(e.getMessage(), e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1060, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [165], "initializationEnd": [193], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["cipher.update(byte[],int,int,byte[],int)"], "configurationStart": [212], "configurationEnd": [237], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 311, "focalAPIEnd": 355, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.update(byte[],int,int,byte[],int)", "cipher.update(byte[],int,int,byte[],int)"], "useStart": [373, 494], "useEnd": [398, 519], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void testUpdatebyteArrayintintbyteArrayint() throws Exception {\n    byte[] b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    byte[] b1 = new byte[6];\n    Cipher c = Cipher.getInstance(\"DESede\");\n\n    try {\n      c.update(b, 0, 10, b1, 5);\n      fail();\n    } catch (IllegalStateException expected) {\n    }\n\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_3DES);\n    try {\n      c.update(b, 0, 10, b1, 5);\n      fail();\n    } catch (ShortBufferException expected) {\n    }\n\n    b1 = new byte[30];\n    c.update(b, 0, 10, b1, 5);\n  }\n"}, {"dataset": "init", "exampleID": 1061, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [104], "initializationEnd": [137], "hasTryCatch": 1, "exceptionType": "InvalidKeyException", "exceptionHandlingCall": ["getMessage()", "fail(*)"], "tryExpressionStart": 303, "tryExpressionEnd": 307, "tryBlockStart": 303, "tryBlockEnd": 425, "catchExpressionStart": 353, "catchExpressionEnd": 383, "catchBlockStart": 353, "catchBlockEnd": 425, "exceptionHandlingCallStart": [403, 391], "exceptionHandlingCallEnd": [417, 418], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 315, "focalAPIEnd": 345, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["crypt(cipher,*)", "cipher.init(int,Key)", "crypt(cipher,byte[])"], "useStart": [450, 504, 639], "useEnd": [485, 534, 663], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wsot/platform_libcore/tree/master/support/src/test/java/tests/security/CipherHelper.java", "rawCode": "  public void test(Key encryptKey, Key decryptKey) {\n    Cipher cipher = null;\n    try {\n      cipher = Cipher.getInstance(algorithmName);\n    } catch (NoSuchAlgorithmException e) {\n      Assert.fail(e.getMessage());\n    } catch (NoSuchPaddingException e) {\n      Assert.fail(e.getMessage());\n    }\n    try {\n      cipher.init(mode1, encryptKey);\n    } catch (InvalidKeyException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    byte[] encrypted = crypt(cipher, plainData.getBytes());\n\n    try {\n      cipher.init(mode2, decryptKey);\n    } catch (InvalidKeyException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    byte[] decrypted = crypt(cipher, encrypted);\n\n    String decryptedString = new String(decrypted);\n\n    Assert.assertEquals(\"transformed data does not match\", plainData, decryptedString);\n  }\n"}, {"dataset": "init", "exampleID": 1062, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(*)"], "initializationStart": [198, 265], "initializationEnd": [214, 297], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 304, "focalAPIEnd": 335, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.wrap(Key)", "cipher.init(int,Key)", "cipher.unwrap(byte[],String,int)"], "useStart": [357, 376, 431], "useEnd": [370, 409, 482], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/InsomniaAOSP/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/func/CipherWrapThread.java", "rawCode": "  @Override\n  public void crypt() throws Exception {\n    KeyGenerator kg = KeyGenerator.getInstance(getAlgName().replace(\"Wrap\", \"\"));\n    kg.init(getKeyLength(), new SecureRandom());\n    Key key = kg.generateKey();\n\n    // ignore mode and padding\n    Cipher cip = Cipher.getInstance(getAlgName());\n\n    cip.init(Cipher.WRAP_MODE, key);\n    byte[] output = cip.wrap(key);\n    cip.init(Cipher.UNWRAP_MODE, key);\n    Key decrypted = cip.unwrap(output, getAlgName(), Cipher.SECRET_KEY);\n\n    checkEncodedData(key.getFormat().getBytes(), decrypted.getFormat().getBytes());\n    checkEncodedData(key.getEncoded(), decrypted.getEncoded());\n  }\n"}, {"dataset": "init", "exampleID": 1063, "initialization": ["AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [307, 348], "initializationEnd": [330, 387], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 393, "focalAPIEnd": 440, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.init(int,Key)", "cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.init(int,Key)", "cipher.doFinal(ByteBuffer,ByteBuffer)", "cipher.init(int,Key)", "cipher.doFinal(ByteBuffer,ByteBuffer)"], "useStart": [484, 649, 798, 925, 1036, 1139, 1286, 1373, 1524, 1611, 1855, 1917], "useEnd": [510, 675, 845, 951, 1083, 1165, 1329, 1398, 1567, 1656, 1899, 1943], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void test_doFinalLjava_nio_ByteBufferLjava_nio_ByteBuffer() throws Exception {\n    byte[] b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n    ByteBuffer bInput = ByteBuffer.allocate(64);\n    ByteBuffer bOutput = ByteBuffer.allocate(64);\n    AlgorithmParameterSpec ap = new IvParameterSpec(IV);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    bInput.put(b, 0, 10);\n    try {\n      c.doFinal(bInput, bOutput);\n      fail();\n    } catch (IllegalBlockSizeException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      c.doFinal(bInput, bOutput);\n      fail();\n    } catch (IllegalStateException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    bInput = ByteBuffer.allocate(16);\n    bInput.put(b, 0, 16);\n    int len = c.doFinal(bInput, bOutput);\n    assertEquals(0, len);\n\n    c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, ap);\n    bInput = ByteBuffer.allocate(64);\n    try {\n      c.doFinal(bOutput, bInput);\n      fail();\n    } catch (BadPaddingException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES);\n    bInput.put(b, 0, 16);\n    try {\n      c.doFinal(bInput, bInput);\n      fail();\n    } catch (IllegalArgumentException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES);\n    bInput.put(b, 0, 16);\n    try {\n      c.doFinal(bInput, bOutput.asReadOnlyBuffer());\n      fail();\n    } catch (ReadOnlyBufferException expected) {\n    }\n\n    bInput.rewind();\n    bInput.put(b, 0, 16);\n    bOutput = ByteBuffer.allocate(8);\n    c = Cipher.getInstance(\"DESede\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_3DES);\n    try {\n      c.doFinal(bInput, bOutput);\n      fail();\n    } catch (ShortBufferException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1064, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [97], "initializationEnd": [130], "hasTryCatch": 1, "exceptionType": "InvalidKeyException", "exceptionHandlingCall": ["getMessage()", "fail(*)"], "tryExpressionStart": 296, "tryExpressionEnd": 300, "tryBlockStart": 296, "tryBlockEnd": 418, "catchExpressionStart": 346, "catchExpressionEnd": 376, "catchBlockStart": 346, "catchBlockEnd": 418, "exceptionHandlingCallStart": [396, 384], "exceptionHandlingCallEnd": [410, 411], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 308, "focalAPIEnd": 338, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["crypt(cipher,*)", "cipher.init(int,Key)", "crypt(cipher,byte[])"], "useStart": [443, 497, 632], "useEnd": [478, 527, 656], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benjaminvm/vm/tree/master/libcore/security/src/test/java/tests/targets/security/CipherHelper.java", "rawCode": "  void test(Key encryptKey, Key decryptKey) {\n    Cipher cipher = null;\n    try {\n      cipher = Cipher.getInstance(algorithmName);\n    } catch (NoSuchAlgorithmException e) {\n      Assert.fail(e.getMessage());\n    } catch (NoSuchPaddingException e) {\n      Assert.fail(e.getMessage());\n    }\n    try {\n      cipher.init(mode1, encryptKey);\n    } catch (InvalidKeyException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    byte[] encrypted = crypt(cipher, plainData.getBytes());\n\n    try {\n      cipher.init(mode2, decryptKey);\n    } catch (InvalidKeyException e) {\n      Assert.fail(e.getMessage());\n    }\n\n    byte[] decrypted = crypt(cipher, encrypted);\n\n    String decryptedString = new String(decrypted);\n\n    Assert.assertEquals(\"transformed data does not match\", plainData, decryptedString);\n  }\n"}, {"dataset": "init", "exampleID": 1065, "initialization": ["Key key = new SecretKeySpec(byte[],String)", "Cipher cipher = getInstance(String,String)"], "initializationStart": [260, 365], "initializationEnd": [295, 411], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "fail(String,*)"], "tryExpressionStart": 418, "tryExpressionEnd": 422, "tryBlockStart": 418, "tryBlockEnd": 562, "catchExpressionStart": 472, "catchExpressionEnd": 492, "catchBlockStart": 472, "catchBlockEnd": 562, "exceptionHandlingCallStart": [539, 500], "exceptionHandlingCallEnd": [551, 555], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 430, "focalAPIEnd": 464, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new CipherOutputStream(ByteArrayOutputStream,cipher)"], "useStart": [802], "useEnd": [835], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bcgit/bc-java/tree/master/prov/src/test/java/org/bouncycastle/jce/provider/test/SEEDTest.java", "rawCode": "  public void test(int strength, byte[] keyBytes, byte[] input, byte[] output) throws Exception {\n    Key key;\n    Cipher in, out;\n    CipherInputStream cIn;\n    CipherOutputStream cOut;\n    ByteArrayInputStream bIn;\n    ByteArrayOutputStream bOut;\n\n    key = new SecretKeySpec(keyBytes, \"SEED\");\n\n    in = Cipher.getInstance(\"SEED/ECB/NoPadding\", \"BC\");\n    out = Cipher.getInstance(\"SEED/ECB/NoPadding\", \"BC\");\n\n    try {\n      out.init(Cipher.ENCRYPT_MODE, key);\n    } catch (Exception e) {\n      fail(\"SEED failed initialisation - \" + e.toString(), e);\n    }\n\n    try {\n      in.init(Cipher.DECRYPT_MODE, key);\n    } catch (Exception e) {\n      fail(\"SEED failed initialisation - \" + e.toString(), e);\n    }\n\n    //\n    // encryption pass\n    //\n    bOut = new ByteArrayOutputStream();\n\n    cOut = new CipherOutputStream(bOut, out);\n\n    try {\n      for (int i = 0; i != input.length / 2; i++) {\n        cOut.write(input[i]);\n      }\n      cOut.write(input, input.length / 2, input.length - input.length / 2);\n      cOut.close();\n    } catch (IOException e) {\n      fail(\"SEED failed encryption - \" + e.toString(), e);\n    }\n\n    byte[] bytes;\n\n    bytes = bOut.toByteArray();\n\n    if (!areEqual(bytes, output)) {\n      fail(\n          \"SEED failed encryption - expected \"\n              + new String(Hex.encode(output))\n              + \" got \"\n              + new String(Hex.encode(bytes)));\n    }\n\n    //\n    // decryption pass\n    //\n    bIn = new ByteArrayInputStream(bytes);\n\n    cIn = new CipherInputStream(bIn, in);\n\n    try {\n      DataInputStream dIn = new DataInputStream(cIn);\n\n      bytes = new byte[input.length];\n\n      for (int i = 0; i != input.length / 2; i++) {\n        bytes[i] = (byte) dIn.read();\n      }\n      dIn.readFully(bytes, input.length / 2, bytes.length - input.length / 2);\n    } catch (Exception e) {\n      fail(\"SEED failed encryption - \" + e.toString(), e);\n    }\n\n    if (!areEqual(bytes, input)) {\n      fail(\n          \"SEED failed decryption - expected \"\n              + new String(Hex.encode(input))\n              + \" got \"\n              + new String(Hex.encode(bytes)));\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1066, "initialization": ["Cipher cipher = newRC4Cipher()", "Key key = new SecretKeySpec(byte[],String)"], "initializationStart": [437, 523], "initializationEnd": [451, 562], "hasTryCatch": 1, "exceptionType": "InvalidKeyException", "exceptionHandlingCall": ["new CryptographyException(*)"], "tryExpressionStart": 571, "tryExpressionEnd": 575, "tryBlockStart": 571, "tryBlockEnd": 965, "catchExpressionStart": 690, "catchExpressionEnd": 726, "catchBlockStart": 690, "catchBlockEnd": 779, "exceptionHandlingCallStart": [742], "exceptionHandlingCallEnd": [770], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 585, "focalAPIEnd": 628, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])"], "useStart": [646, 1719, 1792], "useEnd": [680, 1768, 1817], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zregvart/with-aes/tree/master/pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/BaseEncryptionImplementation.java", "rawCode": "  public byte[] computeUserKey(\n      final byte[] password,\n      final byte[] o,\n      final int permissions,\n      final byte[] id,\n      final int encRevision,\n      final int length,\n      final boolean encryptMetadata)\n      throws CryptographyException {\n    // STEP 1\n    final byte[] encryptionKey =\n        computeEncryptionKey(password, o, permissions, id, encRevision, length, encryptMetadata);\n\n    final Cipher rc4Cipher = newRC4Cipher();\n\n    if (encRevision == 2) {\n      // STEP 2\n      final Key rc4Key = new SecretKeySpec(encryptionKey, \"RC4\");\n\n      try {\n        rc4Cipher.init(Cipher.ENCRYPT_MODE, rc4Key);\n\n        return rc4Cipher.doFinal(ENCRYPT_PADDING);\n      } catch (final InvalidKeyException e) {\n        throw new CryptographyException(e);\n      } catch (final IllegalBlockSizeException e) {\n        throw new CryptographyException(e);\n      } catch (final BadPaddingException e) {\n        throw new CryptographyException(e);\n      }\n    } else if (encRevision == 3 || encRevision == 4) {\n      try {\n        // STEP 2\n        final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(ENCRYPT_PADDING);\n\n        // STEP 3\n        md.update(id);\n        byte[] cipher = md.digest();\n\n        // STEP 4 and 5\n        final byte[] iterationKeyBytes = new byte[encryptionKey.length];\n        for (int i = 0; i < 20; i++) {\n          System.arraycopy(encryptionKey, 0, iterationKeyBytes, 0, iterationKeyBytes.length);\n          for (int j = 0; j < iterationKeyBytes.length; j++) {\n            iterationKeyBytes[j] = (byte) (iterationKeyBytes[j] ^ i);\n          }\n\n          final Key iterationKey = new SecretKeySpec(iterationKeyBytes, \"RC4\");\n\n          try {\n            rc4Cipher.init(Cipher.ENCRYPT_MODE, iterationKey);\n\n            cipher = rc4Cipher.doFinal(cipher);\n          } catch (final InvalidKeyException e) {\n            throw new CryptographyException(e);\n          } catch (final IllegalBlockSizeException e) {\n            throw new CryptographyException(e);\n          } catch (final BadPaddingException e) {\n            throw new CryptographyException(e);\n          }\n        }\n\n        // step 6\n        final byte[] finalResult = new byte[32];\n        System.arraycopy(cipher, 0, finalResult, 0, 16);\n        System.arraycopy(ENCRYPT_PADDING, 0, finalResult, 16, 16);\n\n        return finalResult;\n      } catch (final NoSuchAlgorithmException e) {\n        throw new CryptographyException(e);\n      }\n    }\n\n    throw new IllegalStateException(\"unsupported revision: \" + encRevision);\n  }\n"}, {"dataset": "init", "exampleID": 1067, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [806], "initializationEnd": [833], "hasTryCatch": 1, "exceptionType": "NoSuchPaddingException", "exceptionHandlingCall": ["getMessage()", "new NoSuchAlgorithmException(*)"], "tryExpressionStart": 778, "tryExpressionEnd": 782, "tryBlockStart": 778, "tryBlockEnd": 1815, "catchExpressionStart": 1325, "catchExpressionEnd": 1358, "catchBlockStart": 1325, "catchBlockEnd": 1423, "exceptionHandlingCallStart": [1401, 1372], "exceptionHandlingCallEnd": [1415, 1416], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(key==null)", "guardType": "IF {", "guardExpressionStart": 656, "guardExpressionEnd": 679, "guardBlockStart": 656, "guardBlockEnd": 773, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 878, "focalAPIEnd": 922, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(*,Key,AlgorithmParameters)", "cipher.doFinal(byte[])"], "useStart": [947, 1045], "useEnd": [1006, 1074], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benjaminvm/vm/tree/master/libcore/crypto/src/main/java/javax/crypto/EncryptedPrivateKeyInfo.java", "rawCode": "  /**\n   * Returns the {@code PKCS8EncodedKeySpec} object extracted from the encrypted data.\n   *\n   * @param decryptKey the key to decrypt the encrypted data with.\n   * @return the extracted {@code PKCS8EncodedKeySpec}.\n   * @throws NoSuchAlgorithmException if no usable cipher can be found to decrypt the encrypted\n   *     data.\n   * @throws InvalidKeyException if {@code decryptKey} is not usable to decrypt the encrypted data.\n   * @throws NullPointerException if {@code decryptKey} is {@code null}.\n   * @since Android 1.0\n   */\n  public PKCS8EncodedKeySpec getKeySpec(Key decryptKey)\n      throws NoSuchAlgorithmException, InvalidKeyException {\n    if (decryptKey == null) {\n      throw new NullPointerException(Messages.getString(\"crypto.2A\")); // $NON-NLS-1$\n    }\n    try {\n      Cipher cipher = Cipher.getInstance(algName);\n      if (algParameters == null) {\n        cipher.init(Cipher.DECRYPT_MODE, decryptKey);\n      } else {\n        cipher.init(Cipher.DECRYPT_MODE, decryptKey, algParameters);\n      }\n      byte[] decryptedData = cipher.doFinal(encryptedData);\n      try {\n        ASN1PrivateKeyInfo.verify(decryptedData);\n      } catch (IOException e1) {\n        throw new InvalidKeyException(Messages.getString(\"crypto.29\")); // $NON-NLS-1$\n      }\n      return new PKCS8EncodedKeySpec(decryptedData);\n    } catch (NoSuchPaddingException e) {\n      throw new NoSuchAlgorithmException(e.getMessage());\n    } catch (InvalidAlgorithmParameterException e) {\n      throw new NoSuchAlgorithmException(e.getMessage());\n    } catch (IllegalStateException e) {\n      throw new InvalidKeyException(e.getMessage());\n    } catch (IllegalBlockSizeException e) {\n      throw new InvalidKeyException(e.getMessage());\n    } catch (BadPaddingException e) {\n      throw new InvalidKeyException(e.getMessage());\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1068, "initialization": ["Key key = new SecretKeySpec(String,String)", "Cipher cipher = getInstance(String)"], "initializationStart": [551, 623], "initializationEnd": [606, 648], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 654, "focalAPIEnd": 686, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [710], "useEnd": [756], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lyhcode/codecanaan/tree/master/client/webstart/src/main/java/com/codecanaan/ScriptLoader.java", "rawCode": "  public void load(String scriptType, String scriptURL) throws Exception {\n    // 從網址取得 Scripting 資料\n    URL url = new URL(scriptURL);\n    URLConnection conn = url.openConnection();\n    BufferedReader reader =\n        new BufferedReader(new InputStreamReader(conn.getInputStream(), \"UTF-8\"));\n\n    // 讀取成字串\n    StringBuilder builder = new StringBuilder();\n    String line;\n    while ((line = reader.readLine()) != null) {\n      builder.append(line);\n    }\n    reader.close();\n    String script = builder.toString();\n\n    // 使用 AES 演算法解密\n    Key key = new SecretKeySpec(\"thebestsecretkey\".getBytes(), \"AES\");\n    Cipher c = Cipher.getInstance(\"AES\");\n    c.init(Cipher.DECRYPT_MODE, key);\n    byte[] decValue = c.doFinal(Hex.decodeHex(script.toCharArray()));\n    script = new String(decValue, \"UTF-8\");\n\n    ScriptEngineManager factory = new ScriptEngineManager();\n    ScriptEngine engine = factory.getEngineByName(scriptType);\n    engine.put(\"loader\", this);\n    engine.put(\"engine\", engine);\n    engine.eval(script);\n  }\n"}, {"dataset": "init", "exampleID": 1069, "initialization": ["Key key = getUserKey()", "Cipher cipher = getInstance(String)"], "initializationStart": [111, 431], "initializationEnd": [140, 462], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["getMessage()", "new CipherException(String)"], "tryExpressionStart": 298, "tryExpressionEnd": 302, "tryBlockStart": 298, "tryBlockEnd": 1333, "catchExpressionStart": 632, "catchExpressionEnd": 667, "catchBlockStart": 632, "catchBlockEnd": 752, "exceptionHandlingCallStart": [730, 681], "exceptionHandlingCallEnd": [744, 745], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 470, "focalAPIEnd": 507, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [537], "useEnd": [562], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ntj/ComplexRapidMiner/tree/master/src/com/rapidminer/tools/cipher/CipherTools.java", "rawCode": "  public static String decrypt(String text) throws CipherException {\n    Key key = null;\n    try {\n      key = KeyGeneratorTool.getUserKey();\n    } catch (IOException e) {\n      throw new CipherException(\n          \"Cannot retrieve key, probably no one was created: \" + e.getMessage());\n    }\n\n    try {\n      BASE64Decoder decoder = new BASE64Decoder();\n      byte[] encrypted = decoder.decodeBuffer(text);\n\n      Cipher cipher = Cipher.getInstance(CIPHER_TYPE);\n      cipher.init(Cipher.DECRYPT_MODE, key);\n\n      byte[] outputBytes = cipher.doFinal(encrypted);\n      String ret = new String(outputBytes);\n      return ret;\n    } catch (NoSuchAlgorithmException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    } catch (NoSuchPaddingException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    } catch (IOException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    } catch (InvalidKeyException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    } catch (IllegalBlockSizeException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    } catch (BadPaddingException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1070, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [581], "initializationEnd": [609], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["cipher.update(byte[],int,int,byte[],int)"], "configurationStart": [628], "configurationEnd": [653], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 770, "focalAPIEnd": 808, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.update(byte[],int,int,byte[],int)", "cipher.update(byte[],int,int,byte[],int)"], "useStart": [826, 989], "useEnd": [851, 1014], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bluespark80/example/tree/master/crypto/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  @TestTargets({\n    @TestTargetNew(\n      level = TestLevel.COMPLETE,\n      notes = \"\",\n      method = \"update\",\n      args = {byte[].class, int.class, int.class, byte[].class, int.class}\n    ),\n    @TestTargetNew(\n      level = TestLevel.COMPLETE,\n      notes = \"\",\n      clazz = CipherSpi.class,\n      method = \"engineUpdate\",\n      args = {byte[].class, int.class, int.class, byte[].class, int.class}\n    )\n  })\n  public void testUpdatebyteArrayintintbyteArrayint() throws Exception {\n    byte[] b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    byte[] b1 = new byte[6];\n    Cipher c = Cipher.getInstance(\"DESede\");\n\n    try {\n      c.update(b, 0, 10, b1, 5);\n      fail(\"IllegalStateException expected\");\n    } catch (IllegalStateException e) {\n      // expected\n    }\n\n    c.init(Cipher.ENCRYPT_MODE, cipherKey);\n    try {\n      c.update(b, 0, 10, b1, 5);\n      fail(\"ShortBufferException expected\");\n    } catch (ShortBufferException e) {\n      // expected\n    }\n\n    b1 = new byte[30];\n    c.update(b, 0, 10, b1, 5);\n  }\n"}, {"dataset": "init", "exampleID": 1071, "initialization": ["Cipher cipher = getInstance(String,Provider)", "Key key = new SecretKeySpec(byte[],String)"], "initializationStart": [316, 595], "initializationEnd": [361, 624], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 630, "focalAPIEnd": 686, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[])"], "useStart": [701, 918, 991], "useEnd": [720, 974, 1010], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/CryptoJS/tree/master/tags/2.5/test/DesTestValues.java", "rawCode": "  /**\n   * @param args\n   * @throws NoSuchPaddingException\n   * @throws NoSuchAlgorithmException\n   * @throws GeneralSecurityException\n   */\n  public static void main(String[] args) throws GeneralSecurityException {\n    Provider prov = new BouncyCastleProvider();\n    Security.addProvider(prov);\n    Cipher cipher = Cipher.getInstance(\"DES/ECB/NoPadding\", prov);\n\n    Random rand = new Random(1234567890123457890l);\n    List<byte[]> data = new ArrayList<byte[]>(100);\n\n    byte[] key = new byte[8];\n    byte[] inp = new byte[8];\n    data.add(key.clone());\n    data.add(inp.clone());\n    Key k = new SecretKeySpec(key, \"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, k, (SecureRandom) null);\n    data.add(cipher.doFinal(inp));\n\n    for (int i = 0; i < 50; i++) {\n      rand.nextBytes(key);\n      rand.nextBytes(inp);\n      data.add(key.clone());\n      data.add(inp.clone());\n      k = new SecretKeySpec(key, \"DES\");\n      cipher.init(Cipher.ENCRYPT_MODE, k, (SecureRandom) null);\n      data.add(cipher.doFinal(inp));\n    }\n\n    for (byte[] d : data) {\n      System.out.println(\" \\\"\" + encode(d) + \"\\\",\");\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1072, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [77], "initializationEnd": [119], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 125, "focalAPIEnd": 168, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [191], "useEnd": [228], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/feuyeux/quiland/tree/master/java/air-security/src/main/java/creative/air/security/base64/DECTools.java", "rawCode": "  public String decode(String data) throws Exception {\n    Cipher deCipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    deCipher.init(Cipher.DECRYPT_MODE, key, iv);\n    byte[] pasByte = deCipher.doFinal(Base64.decode(data));\n    return new String(pasByte, \"UTF-8\");\n  }\n"}, {"dataset": "init", "exampleID": 1073, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)", "printStackTrace()"], "tryExpressionStart": 67, "tryExpressionEnd": 71, "tryBlockStart": 67, "tryBlockEnd": 316, "catchExpressionStart": 203, "catchExpressionEnd": 223, "catchBlockStart": 203, "catchBlockEnd": 316, "exceptionHandlingCallStart": [231, 290], "exceptionHandlingCallEnd": [282, 309], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,random)", "focalAPIStart": 79, "focalAPIEnd": 138, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new SealedObject(Serializable,cipher)"], "useStart": [154], "useEnd": [195], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mnip91/proactive-component-monitoring/tree/master/src/Core/org/objectweb/proactive/core/security/crypto/EncryptionEngine.java", "rawCode": "  public Object encrypt(Serializable object, Key sessionKey) {\n    try {\n      symmetricCipher.init(Cipher.ENCRYPT_MODE, sessionKey, rand);\n\n      return new SealedObject(object, symmetricCipher);\n    } catch (Exception e) {\n      System.out.println(\"Exception in encryption :\" + e);\n      e.printStackTrace();\n    }\n\n    return null;\n  }\n"}, {"dataset": "init", "exampleID": 1074, "initialization": ["Cipher cipher = getInstance(String,String)", "Cipher cipher = getInstance(String)"], "initializationStart": [1521, 1592], "initializationEnd": [1558, 1619], "hasTryCatch": 1, "exceptionType": "InvalidAlgorithmParameterException", "exceptionHandlingCall": ["getMessage()", "new IOException(*)"], "tryExpressionStart": 1468, "tryExpressionEnd": 1472, "tryBlockStart": 1468, "tryBlockEnd": 1733, "catchExpressionStart": 2020, "catchExpressionEnd": 2065, "catchBlockStart": 2020, "catchBlockEnd": 2121, "exceptionHandlingCallStart": [2097, 2081], "exceptionHandlingCallEnd": [2111, 2112], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(key==null)", "guardType": "IF {", "guardExpressionStart": 1347, "guardExpressionEnd": 1363, "guardBlockStart": 1347, "guardBlockEnd": 1436, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 1770, "focalAPIEnd": 1807, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(*,Key,AlgorithmParameters)", "getObject(cipher)"], "useStart": [1962, 2152], "useEnd": [2010, 2169], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sake/bouncycastle-java/tree/master/jce/src/javax/crypto/SealedObject.java", "rawCode": "  /**\n   * Retrieves the original (encapsulated) object.\n   *\n   * <p>This method creates a cipher for the algorithm that had been used in the sealing operation,\n   * using an implementation of that algorithm from the given <code>provider</code>. The Cipher\n   * object is initialized for decryption, using the given <code>key</code> and the parameters (if\n   * any) that had been used in the sealing operation.\n   *\n   * <p>The encapsulated object is unsealed and de-serialized, before it is returned.\n   *\n   * @param key the key used to unseal the object.\n   * @param provider the name of the provider of the algorithm to unseal the object.\n   * @return the original object.\n   * @exception IOException if an error occurs during de-serialiazation.\n   * @exception ClassNotFoundException if an error occurs during de-serialization.\n   * @exception NoSuchAlgorithmException if the algorithm to unseal the object is not available.\n   * @exception NoSuchProviderException if the given provider is not configured.\n   * @exception InvalidKeyException if the given key cannot be used to unseal the object (e.g., it\n   *     has the wrong algorithm).\n   */\n  public final Object getObject(Key key, String provider)\n      throws IOException, ClassNotFoundException, NoSuchAlgorithmException, NoSuchProviderException,\n          InvalidKeyException {\n    if (key == null) {\n      throw new IllegalArgumentException(\"key object is null!\");\n    }\n\n    Cipher cipher = null;\n    try {\n      if (provider != null) {\n        cipher = Cipher.getInstance(sealAlg, provider);\n      } else {\n        cipher = Cipher.getInstance(sealAlg);\n      }\n    } catch (NoSuchPaddingException e) {\n      throw new NoSuchAlgorithmException(e.getMessage());\n    }\n\n    if (paramsAlg == null) {\n      cipher.init(Cipher.DECRYPT_MODE, key);\n    } else {\n      AlgorithmParameters algParams = AlgorithmParameters.getInstance(paramsAlg);\n      algParams.init(encodedParams);\n\n      try {\n        cipher.init(Cipher.DECRYPT_MODE, key, algParams);\n      } catch (InvalidAlgorithmParameterException e) {\n        throw new IOException(e.getMessage());\n      }\n    }\n\n    try {\n      return getObject(cipher);\n    } catch (BadPaddingException e) {\n      throw new IOException(e.getMessage());\n    } catch (IllegalBlockSizeException e2) {\n      throw new IOException(e2.getMessage());\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1075, "initialization": ["AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [204, 250], "initializationEnd": [227, 306], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 312, "focalAPIEnd": 365, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.getIV()", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.init(int,Key,AlgorithmParameterSpec)"], "useStart": [389, 535, 789], "useEnd": [403, 588, 841], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codefireX/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  /** javax.crypto.Cipher#init(int, java.security.Key, java.security.spec.AlgorithmParameterSpec) */\n  public void test_initWithAlgorithmParameterSpec() throws Exception {\n    AlgorithmParameterSpec ap = new IvParameterSpec(IV);\n\n    Cipher cipher = Cipher.getInstance(ALGORITHM_3DES + \"/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_3DES, ap);\n    byte[] cipherIV = cipher.getIV();\n    assertTrue(\"IVs differ\", Arrays.equals(cipherIV, IV));\n\n    cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_3DES, ap);\n      fail();\n    } catch (InvalidKeyException expected) {\n    }\n\n    cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    ap = new RSAKeyGenParameterSpec(10, new BigInteger(\"10\"));\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n      fail();\n    } catch (InvalidAlgorithmParameterException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1076, "initialization": ["Key key = getKey()", "Cipher cipher = getInstance(String)"], "initializationStart": [90, 121], "initializationEnd": [98, 157], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 163, "focalAPIEnd": 200, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [297], "useEnd": [322], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/crow-misia/ermaster.old/tree/master/org.insightech.er/src/org/insightech/er/util/PasswordCrypt.java", "rawCode": "  public static String decrypt(String encryptedPassword) throws Exception {\n    Key key = getKey();\n\n    Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n    cipher.init(Cipher.DECRYPT_MODE, key);\n\n    byte[] encrypted = Base64.decodeBase64(encryptedPassword.getBytes());\n    byte[] output = cipher.doFinal(encrypted);\n\n    return new String(output);\n  }\n"}, {"dataset": "init", "exampleID": 1077, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(*)"], "initializationStart": [198, 265], "initializationEnd": [214, 297], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 304, "focalAPIEnd": 335, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.wrap(Key)", "cipher.init(int,Key)", "cipher.unwrap(byte[],String,int)"], "useStart": [357, 376, 431], "useEnd": [370, 409, 482], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/codefireX/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/func/CipherWrapThread.java", "rawCode": "  @Override\n  public void crypt() throws Exception {\n    KeyGenerator kg = KeyGenerator.getInstance(getAlgName().replace(\"Wrap\", \"\"));\n    kg.init(getKeyLength(), new SecureRandom());\n    Key key = kg.generateKey();\n\n    // ignore mode and padding\n    Cipher cip = Cipher.getInstance(getAlgName());\n\n    cip.init(Cipher.WRAP_MODE, key);\n    byte[] output = cip.wrap(key);\n    cip.init(Cipher.UNWRAP_MODE, key);\n    Key decrypted = cip.unwrap(output, getAlgName(), Cipher.SECRET_KEY);\n\n    checkEncodedData(key.getFormat().getBytes(), decrypted.getFormat().getBytes());\n    checkEncodedData(key.getEncoded(), decrypted.getEncoded());\n  }\n"}, {"dataset": "init", "exampleID": 1078, "initialization": ["SecureRandom random = new SecureRandom()", "AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [105, 208, 249], "initializationEnd": [123, 231, 291], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["random.nextBytes(byte[])"], "configurationStart": [158], "configurationEnd": [174], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params,random)", "focalAPIStart": 297, "focalAPIEnd": 346, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.getParameters()", "cipher.init(*,Key,AlgorithmParameterSpec,*)", "cipher.init(int,Key,GCMParameterSpec,SecureRandom)", "cipher.init(*,Key,AlgorithmParameterSpec,*)", "cipher.getParameters()"], "useStart": [366, 403, 549, 709, 795], "useEnd": [383, 465, 622, 775, 812], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SVMP/android_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void test_initWithKeyAlgorithmParametersSecureRandom() throws Exception {\n    SecureRandom sr = new SecureRandom();\n    byte[] iv = new byte[8];\n    sr.nextBytes(iv);\n    AlgorithmParameterSpec ap = new IvParameterSpec(iv);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, cipherKeyDES, ap, sr);\n    assertNotNull(c.getParameters());\n\n    try {\n      c.init(Cipher.DECRYPT_MODE, cipherKey, ap, new SecureRandom());\n      fail();\n    } catch (InvalidKeyException expected) {\n    }\n\n    try {\n      c.init(Cipher.DECRYPT_MODE, cipherKeyDES, (AlgorithmParameters) null, sr);\n      fail();\n    } catch (InvalidAlgorithmParameterException expected) {\n    }\n\n    c.init(Cipher.DECRYPT_MODE, cipherKeyDES, ap, (SecureRandom) null);\n    assertNotNull(c.getParameters());\n  }\n"}, {"dataset": "init", "exampleID": 1079, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [234], "initializationEnd": [259], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["printStackTrace()", "getMessage()", "log(String,String)"], "tryExpressionStart": 195, "tryExpressionEnd": 199, "tryBlockStart": 195, "tryBlockEnd": 4307, "catchExpressionStart": 3282, "catchExpressionEnd": 3305, "catchBlockStart": 3282, "catchBlockEnd": 3477, "exceptionHandlingCallStart": [3321, 3423, 3356], "exceptionHandlingCallEnd": [3340, 3437, 3438], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 299, "focalAPIEnd": 349, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])", "cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])", "cipher.doFinal(byte[])"], "useStart": [368, 683, 761, 812, 883, 957, 1008], "useEnd": [387, 733, 785, 835, 929, 981, 1031], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fyp09008/E-HospitalS/tree/master/src/ehospital/server/remote/impl/EmergencyAccessHandlerImpl.java", "rawCode": "  public int emergencyAccess(\n      byte[] username, byte[] emergencyUser, byte[] emergencyPwd, int tmpCardNum)\n      throws RemoteException {\n    String clientIP = Utility.getClientHost();\n\n    try {\n      Cipher c = null;\n      c = Cipher.getInstance(\"aes\");\n      // decrypt in program key\n      c.init(Cipher.DECRYPT_MODE, RMIConsole.ProgramKey);\n      username = c.doFinal(username);\n      String strUsername = new String(username);\n\n      Session s = ehospital.server.SessionList.findClient(strUsername);\n      if (s == null) {\n        return 1;\n      } else {\n        DBManager dbm = new DBManager();\n        if (dbm.connect()) {\n          // decrypt in program key\n          c.init(Cipher.DECRYPT_MODE, RMIConsole.ProgramKey);\n          emergencyUser = c.doFinal(emergencyUser);\n          emergencyPwd = c.doFinal(emergencyPwd);\n          // decrypt in session key\n          c.init(Cipher.DECRYPT_MODE, s.getSessionKey());\n          emergencyUser = c.doFinal(emergencyUser);\n          emergencyPwd = c.doFinal(emergencyPwd);\n\n          String strEmergencyUser = new String(emergencyUser);\n          ResultSet emergencyUserData = dbm.isUserExist(strEmergencyUser);\n          if (dbm.isUserExist(strUsername) != null && emergencyUserData != null) {\n            try {\n              String strEmergencyPwd = Utility.byteArrayToString(emergencyPwd);\n              if (!emergencyUserData.getString(\"pwd\").equals(strEmergencyPwd)) {\n                Logger.log(\n                    clientIP,\n                    \"failed to authorize a temp card due to incorrect password from the temp card user.\");\n                return 1;\n              }\n              ResultSet tmpUser =\n                  dbm.query(\n                      \"select * from `tmp_user` where `isTaken` = 0 AND `id` = \" + tmpCardNum,\n                      null);\n              if (tmpUser.first()) {\n                dbm.update(\n                    \"update `tmp_user` set `isTaken` = 1 where `id` = \" + tmpUser.getString(1));\n              } else {\n                Logger.log(\n                    clientIP,\n                    \"failed to authorize a temp card due to the temp card is authorized to other users.\");\n                return 4;\n              }\n              // record swapping in DB\n              String[] n = {\n                emergencyUserData.getString(\"uid\"),\n                emergencyUserData.getString(\"pub_key\"),\n                emergencyUserData.getString(\"mod\"),\n                Integer.toString(tmpCardNum)\n              };\n              dbm.update(\n                  \"insert into `swapped_user` (`user_id`, `ori_pub_key`, `ori_mod`, `tmp_card_num`) VALUE (?,?,?,?)\",\n                  n);\n              // swap key pair\n              String[] o = {\n                tmpUser.getString(\"pub_key\"),\n                tmpUser.getString(\"mod\"),\n                emergencyUserData.getString(\"uid\")\n              };\n              dbm.update(\"update `user` set `pub_key` = ?, `mod` = ? where `uid` = ?\", o);\n              System.out.println(\n                  strUsername + \" is authorizing \" + strEmergencyUser + \" in \" + clientIP);\n              System.out.print(\"~>\");\n              Logger.log(clientIP, \" successfully authorized temp card no.\" + tmpCardNum + \".\");\n              return 0;\n            } catch (SQLException e) {\n              e.printStackTrace();\n              Logger.log(clientIP, \" failed to authorize temp card due to: \\n\" + e.getMessage());\n              return 2;\n            }\n          } else {\n            Logger.log(clientIP, \" failed to authorize temp card due to no such user.\");\n            return 1;\n          }\n        }\n      }\n      return 0;\n    } catch (NoSuchAlgorithmException e) {\n\n      return 1024;\n    } catch (NoSuchPaddingException e) {\n      Logger.log(clientIP, \" failed to authorize temp card due to: \\n\" + e.getMessage());\n      return 8;\n    } catch (InvalidKeyException e) {\n      Logger.log(clientIP, \" failed to authorize temp card due to: \\n\" + e.getMessage());\n      return 8;\n    } catch (IllegalBlockSizeException e) {\n      Logger.log(clientIP, \" failed to authorize temp card due to: \\n\" + e.getMessage());\n      return 4;\n    } catch (BadPaddingException e) {\n      Logger.log(clientIP, \" failed to authorize temp card due to: \\n\" + e.getMessage());\n      return 4;\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1080, "initialization": ["AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [354, 395], "initializationEnd": [377, 434], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 440, "focalAPIEnd": 487, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.doFinal(byte[])", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[])", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[],int,int,byte[],int)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[])"], "useStart": [505, 658, 795, 859, 914, 978, 1093, 1158], "useEnd": [519, 672, 842, 873, 961, 1006, 1140, 1171], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TaintDroid/android_platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void test_doFinal$B() throws Exception {\n    byte[] b1 = new byte[32];\n    byte[] bI1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    byte[] bI2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n    byte[] bI3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n    byte[] bI4 = {1, 2, 3};\n    AlgorithmParameterSpec ap = new IvParameterSpec(IV);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    try {\n      c.doFinal(bI1);\n      fail();\n    } catch (IllegalBlockSizeException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      c.doFinal(bI1);\n      fail();\n    } catch (IllegalStateException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    int len1 = c.doFinal(bI2).length;\n    assertEquals(16, len1);\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    int len2 = c.doFinal(bI3, 0, 16, b1, 0);\n    assertEquals(16, len2);\n\n    c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, ap);\n    try {\n      c.doFinal(b1);\n      fail();\n    } catch (BadPaddingException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1081, "initialization": ["Key key = getKey(String,*)", "Cipher cipher = getInstance(String)"], "initializationStart": [774, 879], "initializationEnd": [855, 904], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "debug(*,*)"], "tryExpressionStart": 125, "tryExpressionEnd": 129, "tryBlockStart": 125, "tryBlockEnd": 1091, "catchExpressionStart": 1028, "catchExpressionEnd": 1048, "catchBlockStart": 1028, "catchBlockEnd": 1091, "exceptionHandlingCallStart": [1066, 1056], "exceptionHandlingCallEnd": [1080, 1084], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 912, "focalAPIEnd": 956, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [982], "useEnd": [1019], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/auxgroup-sanxing/Sesame/tree/master/sesame-core/src/main/java/com/sanxing/sesame/pwd/PasswordTool.java", "rawCode": "  public static String decrypt(String passwd) {\n    if (passwd == null || passwd.isEmpty()) {\n      return passwd;\n    }\n    try {\n      String serverDir = System.getProperty(\"SESAME_HOME\");\n      Document doc = new SAXBuilder().build(serverDir + \"/security/license.sesame\");\n      Element serials = doc.getRootElement().getChild(\"serials\");\n      String storePasswd = serials.getChildText(\"serial-1\");\n      String keyPasswd = serials.getChildText(\"serial-2\");\n      FileInputStream fis1 = new FileInputStream(serverDir + \"/security/sesame-server.jks\");\n      KeyStore ks1 = KeyStore.getInstance(\"jks\");\n      PasswordCipher tool = PasswordCipher.getInstance();\n      ks1.load(fis1, tool.decrypt(Base64.decode(storePasswd)).toCharArray());\n      Key privateKey =\n          ks1.getKey(\"sesame-server\", tool.decrypt(Base64.decode(keyPasswd)).toCharArray());\n      Cipher cipher = Cipher.getInstance(\"RSA\");\n      cipher.init(Cipher.DECRYPT_MODE, privateKey);\n      return new String(cipher.doFinal(Base64.decode(passwd)));\n    } catch (Exception e) {\n      LOG.debug(e.getMessage(), e);\n    }\n    return passwd;\n  }\n"}, {"dataset": "init", "exampleID": 1082, "initialization": ["Cipher cipher = getInstance(String)", "Cipher cipher = getInstance(String)"], "initializationStart": [175, 333], "initializationEnd": [214, 372], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["cipher.update(byte[],int,int,byte[])"], "configurationStart": [233], "configurationEnd": [255], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 378, "focalAPIEnd": 419, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.update(byte[],int,int,byte[])", "cipher.update(byte[],int,int,byte[])"], "useStart": [425, 489], "useEnd": [447, 511], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void test_() throws Exception {\n    byte[] b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n    byte[] b1 = new byte[30];\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n\n    try {\n      c.update(b, 0, 10, b1);\n      fail();\n    } catch (IllegalStateException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, cipherKeyDES);\n    c.update(b, 0, 16, b1);\n\n    b1 = new byte[3];\n\n    try {\n      c.update(b, 3, 15, b1);\n      fail();\n    } catch (ShortBufferException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1083, "initialization": ["AlgorithmParameterSpec params = new IvParameterSpec(byte[])", "Cipher cipher = getInstance(String)"], "initializationStart": [202, 243], "initializationEnd": [225, 282], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key,params)", "focalAPIStart": 288, "focalAPIEnd": 335, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[],int,int)", "cipher.doFinal(byte[],int,int)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[],int,int)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[],int,int,byte[],int)", "cipher.init(int,Key,AlgorithmParameterSpec)", "cipher.doFinal(byte[],int,int)"], "useStart": [353, 511, 653, 717, 777, 841, 954, 1019], "useEnd": [372, 530, 700, 736, 824, 867, 1001, 1039], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/CipherTest.java", "rawCode": "  public void test_doFinal$BII() throws Exception {\n    byte[] b = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n    byte[] b1 = new byte[30];\n    AlgorithmParameterSpec ap = new IvParameterSpec(IV);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    try {\n      c.doFinal(b, 0, 10);\n      fail();\n    } catch (IllegalBlockSizeException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    try {\n      c.doFinal(b, 0, 10);\n      fail();\n    } catch (IllegalStateException expected) {\n    }\n\n    c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    int len1 = c.doFinal(b, 0, 16).length;\n    assertEquals(16, len1);\n    c.init(Cipher.ENCRYPT_MODE, CIPHER_KEY_DES, ap);\n    int len2 = c.doFinal(b, 0, 16, b1, 0);\n    assertEquals(16, len2);\n\n    c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    c.init(Cipher.DECRYPT_MODE, CIPHER_KEY_DES, ap);\n    try {\n      c.doFinal(b1, 0, 24);\n      fail();\n    } catch (BadPaddingException expected) {\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1084, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(*)"], "initializationStart": [198, 265], "initializationEnd": [214, 297], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 304, "focalAPIEnd": 335, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.wrap(Key)", "cipher.init(int,Key)", "cipher.unwrap(byte[],String,int)"], "useStart": [357, 376, 431], "useEnd": [370, 409, 482], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/func/CipherWrapThread.java", "rawCode": "  @Override\n  public void crypt() throws Exception {\n    KeyGenerator kg = KeyGenerator.getInstance(getAlgName().replace(\"Wrap\", \"\"));\n    kg.init(getKeyLength(), new SecureRandom());\n    Key key = kg.generateKey();\n\n    // ignore mode and padding\n    Cipher cip = Cipher.getInstance(getAlgName());\n\n    cip.init(Cipher.WRAP_MODE, key);\n    byte[] output = cip.wrap(key);\n    cip.init(Cipher.UNWRAP_MODE, key);\n    Key decrypted = cip.unwrap(output, getAlgName(), Cipher.SECRET_KEY);\n\n    checkEncodedData(key.getFormat().getBytes(), decrypted.getFormat().getBytes());\n    checkEncodedData(key.getEncoded(), decrypted.getEncoded());\n  }\n"}, {"dataset": "init", "exampleID": 1085, "initialization": ["Key key = generateAESKey(String)", "Cipher cipher = getInstance(String)"], "initializationStart": [257, 298], "initializationEnd": [279, 321], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "error(*,*)"], "tryExpressionStart": 235, "tryExpressionEnd": 239, "tryBlockStart": 235, "tryBlockEnd": 558, "catchExpressionStart": 473, "catchExpressionEnd": 494, "catchBlockStart": 473, "catchBlockEnd": 558, "exceptionHandlingCallStart": [512, 502], "exceptionHandlingCallEnd": [527, 532], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 329, "focalAPIEnd": 361, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [385], "useEnd": [411], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mjeanroy/springhub/tree/master/springhub-web/src/main/java/com/mjeanroy/springhub/commons/crypto/Crypto.java", "rawCode": "  /**\n   * Encrypt string with AES encryption.\n   *\n   * @param data Data to encrypt.\n   * @param secret Secret use for encryption.\n   * @return Encrypted data.\n   */\n  public static String encryptAES(String data, String secret) {\n    try {\n      Key key = generateAESKey(secret);\n      Cipher c = Cipher.getInstance(AES);\n      c.init(Cipher.ENCRYPT_MODE, key);\n      byte[] encVal = c.doFinal(data.getBytes());\n      return new String(Base64.encodeBase64(encVal));\n    } catch (Exception ex) {\n      log.error(ex.getMessage(), ex);\n      return data;\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1086, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [267], "initializationEnd": [298], "hasTryCatch": 1, "exceptionType": "NoSuchAlgorithmException", "exceptionHandlingCall": ["getMessage()", "new CipherException(String)"], "tryExpressionStart": 82, "tryExpressionEnd": 86, "tryBlockStart": 82, "tryBlockEnd": 1169, "catchExpressionStart": 468, "catchExpressionEnd": 503, "catchBlockStart": 468, "catchBlockEnd": 588, "exceptionHandlingCallStart": [566, 517], "exceptionHandlingCallEnd": [580, 581], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 306, "focalAPIEnd": 343, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [373], "useEnd": [398], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/faberchri/tree-builder-2/tree/master/TreeBuilder/lib/rapidminer/src/com/rapidminer/tools/cipher/CipherTools.java", "rawCode": "  public static String decrypt(String text, Key key) throws CipherException {\n    try {\n      // BASE64Decoder decoder = new BASE64Decoder();\n      // byte[] encrypted = decoder.decodeBuffer(text);\n      byte[] encrypted = Base64.decode(text);\n\n      Cipher cipher = Cipher.getInstance(CIPHER_TYPE);\n      cipher.init(Cipher.DECRYPT_MODE, key);\n\n      byte[] outputBytes = cipher.doFinal(encrypted);\n      String ret = new String(outputBytes);\n      return ret;\n    } catch (NoSuchAlgorithmException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    } catch (NoSuchPaddingException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    } catch (IOException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    } catch (InvalidKeyException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    } catch (IllegalBlockSizeException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    } catch (BadPaddingException e) {\n      throw new CipherException(\"Failed to decrypt text: \" + e.getMessage());\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1087, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 190, "tryExpressionEnd": 194, "tryBlockStart": 190, "tryBlockEnd": 351, "catchExpressionStart": 287, "catchExpressionEnd": 307, "catchBlockStart": 287, "catchBlockEnd": 351, "exceptionHandlingCallStart": [321], "exceptionHandlingCallEnd": [344], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 202, "focalAPIEnd": 247, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [262], "useEnd": [279], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fhdragon/dragon/tree/master/dragon-commons/src/main/java/org/apache/dragon/commons/crypto/RSAByte.java", "rawCode": "  /**\n   * encrytor t\n   *\n   * @param t\n   * @return\n   * @see org.apache.dragon.commons.crypto.Crypto#encrytor(java.lang.Object)\n   */\n  @Override\n  public byte[] encrytor(byte[] t) {\n    try {\n      cipher.init(Cipher.ENCRYPT_MODE, this.pubKey);\n      return cipher.doFinal(t);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1088, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 345, "focalAPIEnd": 398, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [425], "useEnd": [458], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/petalslink/petals-studio/tree/master/plugins/com.ebmwebsourcing.petals.studio/src/com/ebmwebsourcing/petals/studio/welcome/RegistrationManager.java", "rawCode": "  /**\n   * Encodes user information using the Blowfish encryption algorithm and a Base64.\n   *\n   * @param s the string to encode\n   * @return the encoded string\n   * @throws Exception if something went wrong\n   */\n  public String encode(String s) throws Exception {\n\n    String result = \"\";\n    if (s != null && s.trim().length() > 0) {\n\n      this.cipher.init(Cipher.ENCRYPT_MODE, this.secretKey);\n      byte[] encrypted = this.cipher.doFinal(s.getBytes());\n\n      encrypted = Base64.encode(encrypted);\n      result = new String(encrypted);\n    }\n\n    return result;\n  }\n"}, {"dataset": "init", "exampleID": 1089, "initialization": ["Cipher cipher = getInstance(String,Provider)"], "initializationStart": [203], "initializationEnd": [255], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "error(*,*)", "createFaultException(*,String)", "getMessage()", "addMessage(CertificateAuthorityException,*)"], "tryExpressionStart": 84, "tryExpressionEnd": 88, "tryBlockStart": 84, "tryBlockEnd": 766, "catchExpressionStart": 440, "catchExpressionEnd": 460, "catchBlockStart": 440, "catchBlockEnd": 766, "exceptionHandlingCallStart": [481, 468, 555, 725, 695], "exceptionHandlingCallEnd": [495, 499, 687, 739, 740], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 263, "focalAPIEnd": 304, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.getIV()"], "useStart": [332, 373], "useEnd": [353, 387], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/cagrid2/tree/master/cagrid-dorian/cagrid-dorian-service/src/main/java/org/cagrid/dorian/service/ca/EracomCertificateAuthority.java", "rawCode": "  public WrappedKey wrap(PrivateKey key) throws CertificateAuthorityException {\n    try {\n      init();\n      byte[] input = KeyUtil.writePrivateKey(key, (String) null).getBytes();\n      Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", provider);\n      cipher.init(Cipher.ENCRYPT_MODE, wrapper);\n      byte[] wrappedKey = cipher.doFinal(input);\n      byte[] iv = cipher.getIV();\n      return new WrappedKey(wrappedKey, iv);\n    } catch (Exception e) {\n      logger.error(e.getMessage(), e);\n      CertificateAuthorityException fault =\n          FaultHelper.createFaultException(\n              CertificateAuthorityException.class, \"An unexpected error occurred wrapping a key.\");\n      FaultHelper.addMessage(fault, e.getMessage());\n      throw fault;\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1090, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [175], "initializationEnd": [217], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 225, "focalAPIEnd": 262, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [302], "useEnd": [322], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ysc/APDPlat/tree/master/APDPlat_Core/src/main/java/org/apdplat/platform/util/PKIUtils.java", "rawCode": "  /**\n   * 解密数据\n   *\n   * @param key 公钥或私钥\n   * @param data 待解密数据\n   * @return 明文\n   */\n  public static byte[] decrypt(Key key, byte[] data) {\n    try {\n      Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n      cipher.init(Cipher.DECRYPT_MODE, key);\n      // 解密后的数据\n      byte[] result = cipher.doFinal(data);\n      return result;\n    } catch (NoSuchAlgorithmException\n        | NoSuchPaddingException\n        | InvalidKeyException\n        | IllegalBlockSizeException\n        | BadPaddingException ex) {\n      LOG.error(\"解密数据失败\", ex);\n    }\n    return null;\n  }\n"}, {"dataset": "init", "exampleID": 1091, "initialization": ["Key key = new SecretKeySpec(byte[],String)", "Cipher cipher = getInstance(String,String)"], "initializationStart": [261, 364], "initializationEnd": [295, 409], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "fail(String,*)"], "tryExpressionStart": 416, "tryExpressionEnd": 420, "tryBlockStart": 416, "tryBlockEnd": 559, "catchExpressionStart": 470, "catchExpressionEnd": 490, "catchBlockStart": 470, "catchBlockEnd": 559, "exceptionHandlingCallStart": [536, 498], "exceptionHandlingCallEnd": [548, 552], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 428, "focalAPIEnd": 462, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new CipherOutputStream(ByteArrayOutputStream,cipher)"], "useStart": [798], "useEnd": [831], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sake/bouncycastle-java/tree/master/test/src/org/bouncycastle/jce/provider/test/AESTest.java", "rawCode": "  private void test(int strength, byte[] keyBytes, byte[] input, byte[] output) throws Exception {\n    Key key;\n    Cipher in, out;\n    CipherInputStream cIn;\n    CipherOutputStream cOut;\n    ByteArrayInputStream bIn;\n    ByteArrayOutputStream bOut;\n\n    key = new SecretKeySpec(keyBytes, \"AES\");\n\n    in = Cipher.getInstance(\"AES/ECB/NoPadding\", \"BC\");\n    out = Cipher.getInstance(\"AES/ECB/NoPadding\", \"BC\");\n\n    try {\n      out.init(Cipher.ENCRYPT_MODE, key);\n    } catch (Exception e) {\n      fail(\"AES failed initialisation - \" + e.toString(), e);\n    }\n\n    try {\n      in.init(Cipher.DECRYPT_MODE, key);\n    } catch (Exception e) {\n      fail(\"AES failed initialisation - \" + e.toString(), e);\n    }\n\n    //\n    // encryption pass\n    //\n    bOut = new ByteArrayOutputStream();\n\n    cOut = new CipherOutputStream(bOut, out);\n\n    try {\n      for (int i = 0; i != input.length / 2; i++) {\n        cOut.write(input[i]);\n      }\n      cOut.write(input, input.length / 2, input.length - input.length / 2);\n      cOut.close();\n    } catch (IOException e) {\n      fail(\"AES failed encryption - \" + e.toString(), e);\n    }\n\n    byte[] bytes;\n\n    bytes = bOut.toByteArray();\n\n    if (!areEqual(bytes, output)) {\n      fail(\n          \"AES failed encryption - expected \"\n              + new String(Hex.encode(output))\n              + \" got \"\n              + new String(Hex.encode(bytes)));\n    }\n\n    //\n    // decryption pass\n    //\n    bIn = new ByteArrayInputStream(bytes);\n\n    cIn = new CipherInputStream(bIn, in);\n\n    try {\n      DataInputStream dIn = new DataInputStream(cIn);\n\n      bytes = new byte[input.length];\n\n      for (int i = 0; i != input.length / 2; i++) {\n        bytes[i] = (byte) dIn.read();\n      }\n      dIn.readFully(bytes, input.length / 2, bytes.length - input.length / 2);\n    } catch (Exception e) {\n      fail(\"AES failed encryption - \" + e.toString(), e);\n    }\n\n    if (!areEqual(bytes, input)) {\n      fail(\n          \"AES failed decryption - expected \"\n              + new String(Hex.encode(input))\n              + \" got \"\n              + new String(Hex.encode(bytes)));\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1092, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [625], "initializationEnd": [648], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 654, "focalAPIEnd": 705, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [718], "useEnd": [743], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cbsa-informatik-uni-siegen/gtitool/tree/master/de.unisiegen.gtitool.ui/source/de/unisiegen/gtitool/ui/exchange/Connection.java", "rawCode": "  /**\n   * Encryptes a byte array with the {@link PublicKey}.\n   *\n   * @param plainText The plaintext.\n   * @return The encrypted plaintext.\n   * @throws NoSuchPaddingException Padding wrong.\n   * @throws NoSuchAlgorithmException Algorithm not found.\n   * @throws InvalidKeyException Key wrong.\n   * @throws BadPaddingException Padding wrong.\n   * @throws IllegalBlockSizeException Block size is wrong.\n   */\n  private final byte[] encryptRSA(byte[] plainText)\n      throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n          IllegalBlockSizeException, BadPaddingException {\n    Cipher cipher = Cipher.getInstance(RSA);\n    cipher.init(Cipher.ENCRYPT_MODE, this.rsaPublicKey);\n    return cipher.doFinal(plainText);\n  }\n"}, {"dataset": "init", "exampleID": 1093, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [80], "initializationEnd": [104], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 110, "focalAPIEnd": 142, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [242], "useEnd": [266], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jerep6/ogi/tree/master/ogi-parent/ogi-services/src/main/java/fr/jerep6/ogi/framework/security/CryptageAES.java", "rawCode": "  public String decrypt(String encryptedData) throws Exception {\n    Cipher c = Cipher.getInstance(ALGO);\n    c.init(Cipher.DECRYPT_MODE, key);\n    byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n    byte[] decValue = c.doFinal(decordedValue);\n    String decryptedValue = new String(decValue);\n    return decryptedValue;\n  }\n"}, {"dataset": "init", "exampleID": 1094, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [143], "initializationEnd": [168], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,certificate)", "focalAPIStart": 197, "focalAPIEnd": 227, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(int,Certificate)"], "useStart": [262], "useEnd": [292], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robovm/robovm/tree/master/tests/libcore/luni/src/test/java/libcore/javax/crypto/CipherTest.java", "rawCode": "  private void assertCipherInitWithKeyUsage(Certificate certificate, boolean allowMode, int mode)\n      throws Exception {\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    if (allowMode) {\n      cipher.init(mode, certificate);\n    } else {\n      try {\n        cipher.init(mode, certificate);\n        String modeString;\n        switch (mode) {\n          case Cipher.ENCRYPT_MODE:\n            modeString = \"ENCRYPT_MODE\";\n            break;\n          case Cipher.DECRYPT_MODE:\n            modeString = \"DECRYPT_MODE\";\n            break;\n          case Cipher.WRAP_MODE:\n            modeString = \"WRAP_MODE\";\n            break;\n          case Cipher.UNWRAP_MODE:\n            modeString = \"UNWRAP_MODE\";\n            break;\n          default:\n            throw new AssertionError(\"Unknown Cipher.*_MODE \" + mode);\n        }\n        fail(\"Should have had InvalidKeyException for \" + modeString + \" for \" + certificate);\n      } catch (InvalidKeyException expected) {\n      }\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1095, "initialization": ["Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(String)"], "initializationStart": [986, 1025], "initializationEnd": [1002, 1050], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["cipher.getProvider()"], "configurationStart": [1074], "configurationEnd": [1094], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 1110, "focalAPIEnd": 1147, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new SealedObject(String,cipher)", "cipher.init(int,Key)"], "useStart": [1209, 1248], "useEnd": [1241, 1285], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/TaintDroid/android_platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/crypto/tests/javax/crypto/SealedObjectTest.java", "rawCode": "  /**\n   * getObject(Key key, String provider) method testing. Tests if the proper exception is thrown in\n   * the case of incorrect input parameters and if the object sealed with encryption algorithm can\n   * be retrieved by specifying the cryptographic key and provider name.\n   */\n  public void testGetObject3() throws Exception {\n    try {\n      new SealedObject(\"secret string\", new NullCipher())\n          .getObject(new SecretKeySpec(new byte[] {0, 0, 0}, \"algorithm\"), null);\n      fail(\"IllegalArgumentException should be thrown in the case of \" + \"null provider.\");\n    } catch (IllegalArgumentException e) {\n    }\n\n    try {\n      new SealedObject(\"secret string\", new NullCipher())\n          .getObject(new SecretKeySpec(new byte[] {0, 0, 0}, \"algorithm\"), \"\");\n      fail(\"IllegalArgumentException should be thrown in the case of \" + \"empty provider.\");\n    } catch (IllegalArgumentException e) {\n    }\n\n    KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n    Key key = kg.generateKey();\n\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    String provider = cipher.getProvider().getName();\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n\n    String secret = \"secret string\";\n    SealedObject so = new SealedObject(secret, cipher);\n\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    assertEquals(\n        \"The returned object does not equals to the \" + \"original object.\",\n        secret,\n        so.getObject(key, provider));\n\n    kg = KeyGenerator.getInstance(\"DESede\");\n    key = kg.generateKey();\n\n    try {\n      so.getObject(key, provider);\n      fail(\"InvalidKeyException expected\");\n    } catch (InvalidKeyException e) {\n      // expected\n    }\n\n    try {\n      so.getObject(key, \"Wrong provider name\");\n      fail(\"NoSuchProviderException expected\");\n    } catch (NoSuchProviderException e) {\n      // expected\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1096, "initialization": ["SecureRandom random = new FixedSecureRandom()", "Key key = KeyGenerator.generateKey()", "Cipher cipher = getInstance(String,String)"], "initializationStart": [311, 846, 929], "initializationEnd": [334, 866, 964], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "fail(String,*)"], "tryExpressionStart": 341, "tryExpressionEnd": 345, "tryBlockStart": 341, "tryBlockEnd": 1601, "catchExpressionStart": 1498, "catchExpressionEnd": 1518, "catchBlockStart": 1498, "catchBlockEnd": 1601, "exceptionHandlingCallStart": [1578, 1526], "exceptionHandlingCallEnd": [1590, 1594], "configuration": ["cipher.init(*,Key,RC2ParameterSpec,SecureRandom)", "cipher.init(*,Key,RC5ParameterSpec,SecureRandom)", "cipher.init(*,Key,RC5ParameterSpec,SecureRandom)"], "configurationStart": [1123, 1278, 1358], "configurationEnd": [1172, 1329, 1407], "guardCondition": "bitwise", "guardType": "IF {", "guardExpressionStart": 561, "guardExpressionEnd": 605, "guardBlockStart": 561, "guardBlockEnd": 631, "focalAPI": " = cipher.init(opmode,key,random)", "focalAPIStart": 1442, "focalAPIEnd": 1482, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.getIV()", "new CipherOutputStream(ByteArrayOutputStream,cipher)"], "useStart": [2046, 2797], "useEnd": [2057, 2830], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rtyley/test-bc-java-cvsimport/tree/master/crypto/jdk1.1/org/bouncycastle/jce/provider/test/BlockCipherTest.java", "rawCode": "  public void test(String algorithm, byte[] input, byte[] output) {\n    Key key = null;\n    KeyGenerator keyGen;\n    SecureRandom rand;\n    Cipher in = null;\n    Cipher out = null;\n    CipherInputStream cIn;\n    CipherOutputStream cOut;\n    ByteArrayInputStream bIn;\n    ByteArrayOutputStream bOut;\n\n    rand = new FixedSecureRandom();\n\n    try {\n      String baseAlgorithm;\n      int index = algorithm.indexOf('/');\n\n      if (index > 0) {\n        baseAlgorithm = algorithm.substring(0, index);\n      } else {\n        baseAlgorithm = algorithm;\n      }\n\n      if (baseAlgorithm.equals(\"IDEA\") & noIDEA()) {\n        return;\n      }\n\n      keyGen = KeyGenerator.getInstance(baseAlgorithm, \"BC\");\n      if (!keyGen.getAlgorithm().equals(baseAlgorithm)) {\n        fail(\"wrong key generator returned!\");\n      }\n      keyGen.init(rand);\n\n      key = keyGen.generateKey();\n\n      in = Cipher.getInstance(algorithm, \"BC\");\n      out = Cipher.getInstance(algorithm, \"BC\");\n\n      if (!in.getAlgorithm().startsWith(baseAlgorithm)) {\n        fail(\"wrong cipher returned!\");\n      }\n\n      if (algorithm.startsWith(\"RC2\")) {\n        out.init(Cipher.ENCRYPT_MODE, key, rc2Spec, rand);\n      } else if (algorithm.startsWith(\"RC5\")) {\n        if (algorithm.startsWith(\"RC5-64\")) {\n          out.init(Cipher.ENCRYPT_MODE, key, rc564Spec, rand);\n        } else {\n          out.init(Cipher.ENCRYPT_MODE, key, rc5Spec, rand);\n        }\n      } else {\n        out.init(Cipher.ENCRYPT_MODE, key, rand);\n      }\n    } catch (Exception e) {\n      fail(\"\" + algorithm + \" failed initialisation - \" + e.toString(), e);\n    }\n\n    //\n    // grab the iv if there is one\n    //\n    try {\n      if (algorithm.startsWith(\"RC2\")) {\n        in.init(Cipher.DECRYPT_MODE, key, rc2Spec);\n      } else if (algorithm.startsWith(\"RC5\")) {\n        if (algorithm.startsWith(\"RC5-64\")) {\n          in.init(Cipher.DECRYPT_MODE, key, rc564Spec, rand);\n        } else {\n          in.init(Cipher.DECRYPT_MODE, key, rc5Spec, rand);\n        }\n      } else {\n        byte[] iv;\n\n        iv = out.getIV();\n        if (iv != null) {\n          try {\n            byte[] nIv = new byte[iv.length - 1];\n\n            in.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(nIv));\n            fail(\"failed to pick up short IV\");\n          } catch (InvalidAlgorithmParameterException e) {\n            // ignore - this is what we want...\n          }\n\n          IvParameterSpec spec;\n\n          spec = new IvParameterSpec(iv);\n\n          in.init(Cipher.DECRYPT_MODE, key, spec);\n        } else {\n          in.init(Cipher.DECRYPT_MODE, key);\n        }\n      }\n    } catch (Exception e) {\n      fail(\"\" + algorithm + \" failed initialisation - \" + e.toString());\n    }\n\n    //\n    // encryption pass\n    //\n    bOut = new ByteArrayOutputStream();\n\n    cOut = new CipherOutputStream(bOut, out);\n\n    try {\n      for (int i = 0; i != input.length / 2; i++) {\n        cOut.write(input[i]);\n      }\n      cOut.write(input, input.length / 2, input.length - input.length / 2);\n      cOut.close();\n    } catch (IOException e) {\n      fail(\"\" + algorithm + \" failed encryption - \" + e.toString());\n    }\n\n    byte[] bytes;\n\n    bytes = bOut.toByteArray();\n\n    if (!areEqual(bytes, output)) {\n      fail(\n          \"\"\n              + algorithm\n              + \" failed encryption - expected \"\n              + new String(Hex.encode(output))\n              + \" got \"\n              + new String(Hex.encode(bytes)));\n    }\n\n    //\n    // decryption pass\n    //\n    bIn = new ByteArrayInputStream(bytes);\n\n    cIn = new CipherInputStream(bIn, in);\n\n    try {\n      DataInputStream dIn = new DataInputStream(cIn);\n\n      bytes = new byte[input.length];\n\n      for (int i = 0; i != input.length / 2; i++) {\n        bytes[i] = (byte) dIn.read();\n      }\n      dIn.readFully(bytes, input.length / 2, bytes.length - input.length / 2);\n    } catch (Exception e) {\n      fail(\"\" + algorithm + \" failed decryption - \" + e.toString());\n    }\n\n    if (!areEqual(bytes, input)) {\n      fail(\n          \"\"\n              + algorithm\n              + \" failed decryption - expected \"\n              + new String(Hex.encode(input))\n              + \" got \"\n              + new String(Hex.encode(bytes)));\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1097, "initialization": ["Key key = ObjectInputStream.readObject()", "Cipher cipher = getInstance(String)"], "initializationStart": [993, 1061], "initializationEnd": [1011, 1086], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 47, "tryExpressionEnd": 51, "tryBlockStart": 47, "tryBlockEnd": 2585, "catchExpressionStart": 2391, "catchExpressionEnd": 2413, "catchBlockStart": 2391, "catchBlockEnd": 2447, "exceptionHandlingCallStart": [2421], "exceptionHandlingCallEnd": [2440], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 1096, "focalAPIEnd": 1136, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.init(int,Key)", "crypt(DataInputStream,OutputStream,cipher)", "cipher.init(int,Key)", "cipher.unwrap(byte[],String,int)", "cipher.init(int,Key)", "crypt(DataInputStream,OutputStream,cipher)"], "useStart": [1448, 1495, 2037, 2100, 2264, 2312], "useEnd": [1485, 1517, 2080, 2151, 2301, 2334], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/loveingenioustech/Study/tree/master/java-demo/src/security/RSADemo.java", "rawCode": "  public static void main(String[] args) {\n    try {\n      if (args[0].equals(\"-genkey\")) {\n        KeyPairGenerator pairgen = KeyPairGenerator.getInstance(\"RSA\");\n        SecureRandom random = new SecureRandom();\n        pairgen.initialize(KEYSIZE, random);\n        KeyPair keyPair = pairgen.generateKeyPair();\n        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(args[1]));\n        out.writeObject(keyPair.getPublic());\n        out.close();\n        out = new ObjectOutputStream(new FileOutputStream(args[2]));\n        out.writeObject(keyPair.getPrivate());\n        out.close();\n      } else if (args[0].equals(\"-encrypt\")) {\n        KeyGenerator keygen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom random = new SecureRandom();\n        keygen.init(random);\n        SecretKey key = keygen.generateKey();\n\n        // wrap with RSA public key\n        ObjectInputStream keyIn = new ObjectInputStream(new FileInputStream(args[3]));\n        Key publicKey = (Key) keyIn.readObject();\n        keyIn.close();\n\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.WRAP_MODE, publicKey);\n        byte[] wrappedKey = cipher.wrap(key);\n        DataOutputStream out = new DataOutputStream(new FileOutputStream(args[2]));\n        out.writeInt(wrappedKey.length);\n        out.write(wrappedKey);\n\n        InputStream in = new FileInputStream(args[1]);\n        cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        crypt(in, out, cipher);\n        in.close();\n        out.close();\n      } else {\n        DataInputStream in = new DataInputStream(new FileInputStream(args[1]));\n        int length = in.readInt();\n        byte[] wrappedKey = new byte[length];\n        in.read(wrappedKey, 0, length);\n\n        // unwrap with RSA private key\n        ObjectInputStream keyIn = new ObjectInputStream(new FileInputStream(args[3]));\n        Key privateKey = (Key) keyIn.readObject();\n        keyIn.close();\n\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.UNWRAP_MODE, privateKey);\n        Key key = cipher.unwrap(wrappedKey, \"AES\", Cipher.SECRET_KEY);\n\n        OutputStream out = new FileOutputStream(args[2]);\n        cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n\n        crypt(in, out, cipher);\n        in.close();\n        out.close();\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    } catch (GeneralSecurityException e) {\n      e.printStackTrace();\n    } catch (ClassNotFoundException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1098, "initialization": ["Key key = createDESKey(byte[],int)", "Cipher cipher = getInstance(String)"], "initializationStart": [485, 628], "initializationEnd": [510, 667], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "new NTLMEngineException(*,*)"], "tryExpressionStart": 372, "tryExpressionEnd": 376, "tryBlockStart": 372, "tryBlockEnd": 1298, "catchExpressionStart": 1215, "catchExpressionEnd": 1235, "catchBlockStart": 1215, "catchBlockEnd": 1298, "exceptionHandlingCallStart": [1273, 1249], "exceptionHandlingCallEnd": [1287, 1291], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 675, "focalAPIEnd": 712, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])"], "useStart": [741, 771, 843, 873, 941], "useEnd": [763, 811, 865, 911, 963], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mxro/osgi-maven/tree/master/thrdAsyncHttpClient17/src/main/java/com/ning/http/client/ntlm/NTLMEngine.java", "rawCode": "  /**\n   * Creates the LM Response from the given hash and Type 2 challenge.\n   *\n   * @param hash The LM or NTLM Hash.\n   * @param challenge The server challenge from the Type 2 message.\n   * @return The response (either LM or NTLM, depending on the provided hash).\n   */\n  private static byte[] lmResponse(byte[] hash, byte[] challenge) throws NTLMEngineException {\n    try {\n      byte[] keyBytes = new byte[21];\n      System.arraycopy(hash, 0, keyBytes, 0, 16);\n      Key lowKey = createDESKey(keyBytes, 0);\n      Key middleKey = createDESKey(keyBytes, 7);\n      Key highKey = createDESKey(keyBytes, 14);\n      Cipher des = Cipher.getInstance(\"DES/ECB/NoPadding\");\n      des.init(Cipher.ENCRYPT_MODE, lowKey);\n      byte[] lowResponse = des.doFinal(challenge);\n      des.init(Cipher.ENCRYPT_MODE, middleKey);\n      byte[] middleResponse = des.doFinal(challenge);\n      des.init(Cipher.ENCRYPT_MODE, highKey);\n      byte[] highResponse = des.doFinal(challenge);\n      byte[] lmResponse = new byte[24];\n      System.arraycopy(lowResponse, 0, lmResponse, 0, 8);\n      System.arraycopy(middleResponse, 0, lmResponse, 8, 8);\n      System.arraycopy(highResponse, 0, lmResponse, 16, 8);\n      return lmResponse;\n    } catch (Exception e) {\n      throw new NTLMEngineException(e.getMessage(), e);\n    }\n  }\n"}, {"dataset": "init", "exampleID": 1099, "initialization": ["Cipher cipher = getInstance(String)"], "initializationStart": [299], "initializationEnd": [323], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 329, "focalAPIEnd": 363, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])"], "useStart": [389], "useEnd": [413], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Dhandapani/gluster-ovirt/tree/master/backend/manager/modules/engineencryptutils/src/main/java/org/ovirt/engine/core/engineencryptutils/EncryptionUtils.java", "rawCode": "  private static String decrypt(String source, Key key)\n      throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n          IllegalBlockSizeException, BadPaddingException {\n    String result = \"\";\n    byte[] cipherbytes = Encoding.Base64.getBytes(source);\n    Cipher rsa = Cipher.getInstance(algo);\n    rsa.init(Cipher.DECRYPT_MODE, key);\n    byte[] plainbytes = rsa.doFinal(cipherbytes);\n    result = Encoding.UTF8.getString(plainbytes);\n    return result;\n  }\n"}, {"dataset": "init", "exampleID": 1100, "initialization": ["Key key = createDESKey(byte[],int)", "Cipher cipher = getInstance(String)"], "initializationStart": [537, 692], "initializationEnd": [562, 731], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getMessage()", "new NTLMEngineException(*,*)"], "tryExpressionStart": 274, "tryExpressionEnd": 278, "tryBlockStart": 274, "tryBlockEnd": 1174, "catchExpressionStart": 1091, "catchExpressionEnd": 1111, "catchBlockStart": 1091, "catchBlockEnd": 1174, "exceptionHandlingCallStart": [1149, 1125], "exceptionHandlingCallEnd": [1163, 1167], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = cipher.init(opmode,key)", "focalAPIStart": 739, "focalAPIEnd": 776, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["cipher.doFinal(byte[])", "cipher.init(int,Key)", "cipher.doFinal(byte[])"], "useStart": [801, 835, 899], "useEnd": [827, 873, 925], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mxro/osgi-maven/tree/master/thrdAsyncHttpClient17/src/main/java/com/ning/http/client/ntlm/NTLMEngine.java", "rawCode": "  /**\n   * Creates the LM Hash of the user's password.\n   *\n   * @param password The password.\n   * @return The LM Hash of the given password, used in the calculation of the LM Response.\n   */\n  private static byte[] lmHash(String password) throws NTLMEngineException {\n    try {\n      byte[] oemPassword = password.toUpperCase(Locale.ENGLISH).getBytes(\"US-ASCII\");\n      int length = Math.min(oemPassword.length, 14);\n      byte[] keyBytes = new byte[14];\n      System.arraycopy(oemPassword, 0, keyBytes, 0, length);\n      Key lowKey = createDESKey(keyBytes, 0);\n      Key highKey = createDESKey(keyBytes, 7);\n      byte[] magicConstant = \"KGS!@#$%\".getBytes(\"US-ASCII\");\n      Cipher des = Cipher.getInstance(\"DES/ECB/NoPadding\");\n      des.init(Cipher.ENCRYPT_MODE, lowKey);\n      byte[] lowHash = des.doFinal(magicConstant);\n      des.init(Cipher.ENCRYPT_MODE, highKey);\n      byte[] highHash = des.doFinal(magicConstant);\n      byte[] lmHash = new byte[16];\n      System.arraycopy(lowHash, 0, lmHash, 0, 8);\n      System.arraycopy(highHash, 0, lmHash, 8, 8);\n      return lmHash;\n    } catch (Exception e) {\n      throw new NTLMEngineException(e.getMessage(), e);\n    }\n  }\n"}]