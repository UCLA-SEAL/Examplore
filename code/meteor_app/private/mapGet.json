[{"dataset": "mapGet", "exampleID": 5401, "initialization": ["Object key = Iterator.next()"], "initializationStart": [552], "initializationEnd": [563], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new JSONException(*)"], "tryExpressionStart": 336, "tryExpressionEnd": 340, "tryBlockStart": 336, "tryBlockEnd": 1100, "catchExpressionStart": 1021, "catchExpressionEnd": 1051, "catchBlockStart": 1021, "catchBlockEnd": 1100, "exceptionHandlingCallStart": [1065], "exceptionHandlingCallEnd": [1093], "configuration": ["key.toString()"], "configurationStart": [592], "configurationEnd": [606], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 660, "focalAPIEnd": 677, "followUpCheck": "value instanceof JSONObject", "checkType": "IF", "followUpCheckExpressionStart": 687, "followUpCheckExpressionEnd": 719, "followUpCheckBlockStart": 687, "followUpCheckBlockEnd": 934, "use": ["value.write(Writer)", "value.write(Writer)", "valueToString(value)"], "useStart": [732, 827, 902], "useEnd": [766, 860, 922], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fanlu/MyApp/tree/master/modules/qqapi/src/main/java/org/json/JSONObject.java", "rawCode": "  /**\n   * Write the contents of the JSONObject as JSON text to a writer. For compactness, no whitespace\n   * is added.\n   *\n   * <p>Warning: This method assumes that the data structure is acyclical.\n   *\n   * @return The writer.\n   * @throws org.json.JSONException\n   */\n  public Writer write(Writer writer) throws JSONException {\n    try {\n      boolean commanate = false;\n      Iterator keys = this.keys();\n      writer.write('{');\n\n      while (keys.hasNext()) {\n        if (commanate) {\n          writer.write(',');\n        }\n        Object key = keys.next();\n        writer.write(quote(key.toString()));\n        writer.write(':');\n        Object value = this.map.get(key);\n        if (value instanceof JSONObject) {\n          ((JSONObject) value).write(writer);\n        } else if (value instanceof JSONArray) {\n          ((JSONArray) value).write(writer);\n        } else {\n          writer.write(valueToString(value));\n        }\n        commanate = true;\n      }\n      writer.write('}');\n      return writer;\n    } catch (IOException exception) {\n      throw new JSONException(exception);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5402, "initialization": ["Object key = Iterator.next()"], "initializationStart": [231], "initializationEnd": [246], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [120], "configurationEnd": [134], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 277, "focalAPIEnd": 291, "followUpCheck": "value == PackInfo.GREY", "checkType": "IF", "followUpCheckExpressionStart": 311, "followUpCheckExpressionEnd": 338, "followUpCheckBlockStart": 311, "followUpCheckBlockEnd": 367, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jponge/izpack-full-svn-history-copy/tree/master/izpack-src/tags/last-gpl-version-before-asl-switch/src/lib/com/izforge/izpack/compiler/Compiler.java", "rawCode": "  /** This function checks for the existence of back edges. */\n  private int checkBackEdges(Map edges) {\n    Set keys = edges.keySet();\n    for (Iterator iterator = keys.iterator(); iterator.hasNext(); ) {\n      final Object key = iterator.next();\n      int color = ((Integer) edges.get(key)).intValue();\n      if (color == PackInfo.GREY) {\n        return -2;\n      }\n    }\n    return 0;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5403, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 389, "focalAPIEnd": 417, "followUpCheck": "value != null", "checkType": "IF", "followUpCheckExpressionStart": 423, "followUpCheckExpressionEnd": 440, "followUpCheckBlockStart": 423, "followUpCheckBlockEnd": 471, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/eclipse.platform.text/tree/master/org.eclipse.ui.workbench.texteditor/src/org/eclipse/ui/texteditor/AbstractDocumentProvider.java", "rawCode": "  /**\n   * Returns whether <code>validateState</code> has been called for the given element since the\n   * element's state has potentially been invalidated.\n   *\n   * @param element the element\n   * @return whether <code>validateState</code> has been called for the given element\n   * @since 2.0\n   */\n  @Override\n  public boolean isStateValidated(Object element) {\n    ElementInfo info = fElementInfoMap.get(element);\n    if (info != null) return info.fIsStateValidated;\n    return false;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5404, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 190, "focalAPIEnd": 203, "followUpCheck": "value instanceof List", "checkType": "IF", "followUpCheckExpressionStart": 209, "followUpCheckExpressionEnd": 235, "followUpCheckBlockStart": 209, "followUpCheckBlockEnd": 451, "use": ["List.add(value)", "map.put(Object,List)"], "useStart": [375, 406], "useEnd": [390, 425], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dancres/blitzjavaspaces/tree/master/src/main/java/com/go/trove/net/HttpHeaderMap.java", "rawCode": "  /**\n   * Returns all the values associated with the given key. Changes to the returned list will be\n   * reflected in this map.\n   */\n  public List getAll(Object key) {\n    Object value = mMap.get(key);\n    if (value instanceof List) {\n      return ((List) value);\n    } else {\n      List list = new ArrayList();\n      if (value != null || mMap.containsKey(key)) {\n        list.add(value);\n      }\n      mMap.put(key, list);\n      return list;\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5405, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 508, "focalAPIEnd": 520, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 526, "followUpCheckExpressionEnd": 540, "followUpCheckBlockStart": 526, "followUpCheckBlockEnd": 615, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/plugins/image/ext/src/batik-1.7/sources/org/apache/batik/util/SoftReferenceCache.java", "rawCode": "  /**\n   * Check if <tt>request(key)</tt> will return with an Object (not putting you on the hook for it).\n   * Note that it is possible that this will return true but between this call and the call to\n   * request the soft-reference will be cleared. So it is still possible for request to return NULL,\n   * just much less likely (you can always call 'clear' in that case).\n   */\n  protected final synchronized boolean isPresentImpl(Object key) {\n    if (!map.containsKey(key)) return false;\n\n    Object o = map.get(key);\n    if (o == null)\n      // It's been requested but hasn't been 'put' yet.\n      return true;\n\n    // It's been put let's make sure the soft reference hasn't\n    // been cleared.\n    SoftReference sr = (SoftReference) o;\n    o = sr.get();\n    if (o != null) return true;\n\n    // Soft reference was cleared, so remove our record of key.\n    clearImpl(key);\n    return false;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5406, "initialization": ["Map map = IEditPartIdentifier.getConnectionAnchors()", "Object key = Iterator.next()"], "initializationStart": [520, 716], "initializationEnd": [561, 727], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [625], "configurationEnd": [643], "guardCondition": "map!=null", "guardType": "IF {", "guardExpressionStart": 571, "guardExpressionEnd": 593, "guardBlockStart": 571, "guardBlockEnd": 1325, "focalAPI": "value = map.get(key)", "focalAPIStart": 756, "focalAPIEnd": 774, "followUpCheck": "key instanceof String && value instanceof ConnectionAnchor", "checkType": "IF", "followUpCheckExpressionStart": 788, "followUpCheckExpressionEnd": 851, "followUpCheckBlockStart": 788, "followUpCheckBlockEnd": 1303, "use": ["value.getReferencePoint()"], "useStart": [885], "useEnd": [931], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/jubula.core/tree/master/org.eclipse.jubula.rc.rcp.e3/src/org/eclipse/jubula/rc/rcp/e3/gef/inspector/GefInspectorListenerAppender.java", "rawCode": "    /**\n     * @param editPartIdentifier Provides connection anchor IDs and locations.\n     * @param cursorLocation The location at which to search for an anchor point.\n     * @return the ID of the connection anchor at the given location, or <code>null</code> if there\n     *     is no connection anchor at the given location.\n     */\n    private String getConnectionAnchorId(\n        IEditPartIdentifier editPartIdentifier, Point cursorLocation) {\n\n      if (editPartIdentifier != null) {\n        Map<?, ?> anchorMap = editPartIdentifier.getConnectionAnchors();\n        if (anchorMap != null) {\n          Iterator<?> iter = anchorMap.keySet().iterator();\n          while (iter.hasNext()) {\n            Object key = iter.next();\n            Object value = anchorMap.get(key);\n            if (key instanceof String && value instanceof ConnectionAnchor) {\n              Point refPoint = ((ConnectionAnchor) value).getReferencePoint();\n\n              // A click is recognized as being \"within the\n              // bounds\" of an anchor if it is within 3 pixels\n              // in any direction.\n              Rectangle refBounds = new Rectangle(refPoint.x - 3, refPoint.y - 3, 7, 7);\n              if (refBounds.contains(cursorLocation)) {\n                return (String) key;\n              }\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n"}, {"dataset": "mapGet", "exampleID": 5407, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "map!=null", "guardType": "IF {", "guardExpressionStart": 697, "guardExpressionEnd": 713, "guardBlockStart": 697, "guardBlockEnd": 1129, "focalAPI": "value = map.get(key)", "focalAPIStart": 738, "focalAPIEnd": 750, "followUpCheck": "value != null", "checkType": "IF", "followUpCheckExpressionStart": 758, "followUpCheckExpressionEnd": 777, "followUpCheckBlockStart": 758, "followUpCheckBlockEnd": 1123, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/concord-consortium/geogebra/tree/master/geogebra/org/apache/commons/collections15/MapUtils.java", "rawCode": "  /**\n   * Gets a Boolean from a Map in a null-safe manner.\n   *\n   * <p>If the value is a <code>Boolean</code> it is returned directly. If the value is a <code>\n   * String</code> and it equals 'true' ignoring case then <code>true</code> is returned, otherwise\n   * <code>false</code>. If the value is a <code>Number</code> an integer zero value returns <code>\n   * false</code> and non-zero returns <code>true</code>. Otherwise, <code>null</code> is returned.\n   *\n   * @param map the map to use\n   * @param key the key to look up\n   * @return the value in the Map as a Boolean, <code>null</code> if null map input\n   */\n  public static Boolean getBoolean(final Map map, final Object key) {\n    if (map != null) {\n      Object answer = map.get(key);\n      if (answer != null) {\n        if (answer instanceof Boolean) {\n          return (Boolean) answer;\n\n        } else if (answer instanceof String) {\n          return new Boolean((String) answer);\n\n        } else if (answer instanceof Number) {\n          Number n = (Number) answer;\n          return (n.intValue() != 0) ? Boolean.TRUE : Boolean.FALSE;\n        }\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5408, "initialization": ["Map map = new HashMap()"], "initializationStart": [103], "initializationEnd": [116], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 155, "focalAPIEnd": 182, "followUpCheck": "value != null", "checkType": "IF", "followUpCheckExpressionStart": 188, "followUpCheckExpressionEnd": 207, "followUpCheckBlockStart": 188, "followUpCheckBlockEnd": 247, "use": ["value.intValue()", "map.put(Object,Object)"], "useStart": [223, 279], "useEnd": [240, 323], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/DevBoost/EMFText/tree/master/Deprecated/org.emftext.sdk.antlr/src-runtime/org/antlr/runtime/tree/BaseTreeAdaptor.java", "rawCode": "  public int getUniqueID(Object node) {\n    if (treeToUniqueIDMap == null) {\n      treeToUniqueIDMap = new HashMap();\n    }\n    Integer prevID = (Integer) treeToUniqueIDMap.get(node);\n    if (prevID != null) {\n      return prevID.intValue();\n    }\n    int ID = uniqueNodeID;\n    treeToUniqueIDMap.put(node, new Integer(ID));\n    uniqueNodeID++;\n    return ID;\n    // GC makes these nonunique:\n    // return System.identityHashCode(node);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5409, "initialization": ["Object key = getAdapter(*)", "Map map = new IdentityHashMap()"], "initializationStart": [177, 259], "initializationEnd": [212, 280], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)", "map.put(IHintedType,*)"], "configurationStart": [289, 359, 437, 501, 585, 673, 765, 837, 970, 1054, 1191, 1275, 1363, 1455, 1588, 1672, 1809], "configurationEnd": [350, 428, 492, 576, 664, 756, 828, 961, 1045, 1182, 1266, 1354, 1446, 1579, 1663, 1800, 1870], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 1905, "focalAPIEnd": 1923, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/gmf-tooling.uml2tools/tree/master/plugins/experimental/org.eclipse.uml2.diagram.sequence/src/org/eclipse/uml2/diagram/sequence/providers/UMLElementTypes.java", "rawCode": "  /**\n   * Returns 'type' of the ecore object associated with the hint.\n   *\n   * @generated\n   */\n  public static ENamedElement getElement(IAdaptable hint) {\n    Object type = hint.getAdapter(IElementType.class);\n    if (elements == null) {\n      elements = new IdentityHashMap();\n\n      elements.put(Package_1000, UMLPackage.eINSTANCE.getPackage());\n\n      elements.put(Interaction_2001, UMLPackage.eINSTANCE.getInteraction());\n\n      elements.put(Gate_3005, UMLPackage.eINSTANCE.getGate());\n\n      elements.put(InteractionUse_3007, UMLPackage.eINSTANCE.getInteractionUse());\n\n      elements.put(CombinedFragment_3008, UMLPackage.eINSTANCE.getCombinedFragment());\n\n      elements.put(InteractionOperand_3009, UMLPackage.eINSTANCE.getInteractionOperand());\n\n      elements.put(Lifeline_3001, UMLPackage.eINSTANCE.getLifeline());\n\n      elements.put(\n          ActionExecutionSpecification_3002,\n          UMLPackage.eINSTANCE.getActionExecutionSpecification());\n\n      elements.put(StateInvariant_3003, UMLPackage.eINSTANCE.getStateInvariant());\n\n      elements.put(\n          BehaviorExecutionSpecification_3004,\n          UMLPackage.eINSTANCE.getBehaviorExecutionSpecification());\n\n      elements.put(InteractionUse_3006, UMLPackage.eINSTANCE.getInteractionUse());\n\n      elements.put(CombinedFragment_3010, UMLPackage.eINSTANCE.getCombinedFragment());\n\n      elements.put(InteractionOperand_3011, UMLPackage.eINSTANCE.getInteractionOperand());\n\n      elements.put(\n          ActionExecutionSpecification_3012,\n          UMLPackage.eINSTANCE.getActionExecutionSpecification());\n\n      elements.put(StateInvariant_3013, UMLPackage.eINSTANCE.getStateInvariant());\n\n      elements.put(\n          BehaviorExecutionSpecification_3014,\n          UMLPackage.eINSTANCE.getBehaviorExecutionSpecification());\n\n      elements.put(Message_4001, UMLPackage.eINSTANCE.getMessage());\n    }\n    return (ENamedElement) elements.get(type);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5410, "initialization": ["Object key = PropertyDifference.getNewValue()"], "initializationStart": [1251], "initializationEnd": [1273], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 1811, "focalAPIEnd": 1856, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 2049, "followUpCheckExpressionEnd": 2078, "followUpCheckBlockStart": 2049, "followUpCheckBlockEnd": 2248, "use": ["EObject.eSet(EStructuralFeature,value)"], "useStart": [2192], "useEnd": [2233], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Teiid-Designer/teiid-designer/tree/master/plugins/org.teiid.designer.compare/src/org/teiid/designer/compare/processor/MergeProcessorImpl.java", "rawCode": "  /**\n   * Method the perform the 'change' operation defined by the supplied descriptor and mapping.\n   *\n   * @param mapping\n   * @param diffDesc\n   */\n  protected void doChange(final Mapping mapping, final DifferenceDescriptor diffDesc) {\n    // There should both one input and one output ...\n    final List inputs = mapping.getInputs();\n    final EObject oldObject = (EObject) inputs.get(0);\n    // final List outputs = mapping.getOutputs();\n    // final EObject newObject = (EObject)outputs.get(0);\n    if (computeTasks) {\n      final String path = computeSubtaskPath(oldObject);\n      final Object[] params = new Object[] {path};\n      final String loadingSubTask =\n          ModelerComparePlugin.Util.getString(\n              \"MergeProcessorImpl.ChangingSubTask\", params); // $NON-NLS-1$\n      this.monitor.subTask(loadingSubTask);\n    }\n    // Go through all of the property differences ...\n    final List propDiffs = diffDesc.getPropertyDifferences();\n    final Iterator iter = propDiffs.iterator();\n    while (iter.hasNext()) {\n      final PropertyDifference propDiff = (PropertyDifference) iter.next();\n      if (!propDiff.isSkip()) {\n        final EStructuralFeature feature = propDiff.getAffectedFeature();\n        final Object newValue = propDiff.getNewValue();\n        final Object oldValue = propDiff.getOldValue();\n        // Set the new (result) values onto the old (source) object\n        if (feature.isMany()) {\n          final EList newValues = (EList) newValue;\n          final EList oldValues = (EList) oldValue;\n          final List newValuesInSource = convertFromResultsToSource(newValues);\n          ECollections.setEList(oldValues, newValuesInSource);\n        } else {\n          if (newValue instanceof EObject) {\n            final EObject newValueInSource =\n                (EObject) this.resultObjectToSourceObject.get(newValue);\n            // The new value may be null (e.g., if the new value is an object outside of the model\n            // being merged/updated); in such cases, use the original value ...\n            if (newValueInSource == null) {\n              oldObject.eSet(feature, newValue); // newValue is never null!\n            } else {\n              oldObject.eSet(feature, newValueInSource);\n            }\n          } else {\n            oldObject.eSet(feature, newValue);\n          }\n        }\n      }\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5411, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 116, "focalAPIEnd": 130, "followUpCheck": "value != null", "checkType": "IF", "followUpCheckExpressionStart": 138, "followUpCheckExpressionEnd": 155, "followUpCheckBlockStart": 138, "followUpCheckBlockEnd": 206, "use": ["value.getHoldCount()"], "useStart": [173], "useEnd": [192], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/geotools/geotools/tree/master/modules/library/metadata/src/main/java/org/geotools/util/WeakObjectCache.java", "rawCode": "  boolean holdsLock(final Object key) {\n    synchronized (locks) {\n      final ReentrantLock lock = (ReentrantLock) locks.get(key);\n      if (lock != null) {\n        return lock.getHoldCount() != 0;\n      }\n    }\n    return false;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5412, "initialization": ["Object key = Iterator.next()"], "initializationStart": [258], "initializationEnd": [267], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [183], "configurationEnd": [195], "guardCondition": "map!=null", "guardType": "IF {", "guardExpressionStart": 144, "guardExpressionEnd": 160, "guardBlockStart": 144, "guardBlockEnd": 348, "focalAPI": "value = map.get(key)", "focalAPIStart": 292, "focalAPIEnd": 304, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["HashMap.put(Object,value)"], "useStart": [314], "useEnd": [333], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/viccuad/ISplayer/tree/master/src/javazoom/jlgui/basicplayer/BasicPlayer.java", "rawCode": "  /**\n   * Deep copy of a Map.\n   *\n   * @param src\n   * @return\n   */\n  protected Map deepCopy(Map src) {\n    HashMap map = new HashMap();\n    if (src != null) {\n      Iterator it = src.keySet().iterator();\n      while (it.hasNext()) {\n        Object key = it.next();\n        Object value = src.get(key);\n        map.put(key, value);\n      }\n    }\n    return map;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5413, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 462, "focalAPIEnd": 474, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["map.get(Object)"], "useStart": [533], "useEnd": [545], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/saces/milton/tree/master/src/org/apache/commons/beanutils/WeakFastHashMap.java", "rawCode": "  /**\n   * Return the value to which this map maps the specified key. Returns <code>null</code> if the map\n   * contains no mapping for this key, or if there is a mapping with a value of <code>null</code>.\n   * Use the <code>containsKey()</code> method to disambiguate these cases.\n   *\n   * @param key the key whose value is to be returned\n   * @return the value mapped to that key, or null\n   */\n  public Object get(Object key) {\n    if (fast) {\n      return (map.get(key));\n    } else {\n      synchronized (map) {\n        return (map.get(key));\n      }\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5414, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 207, "focalAPIEnd": 232, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["value.intValue()"], "useStart": [196], "useEnd": [244], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stuartwdouglas/jacorb/tree/master/src/org/jacorb/orb/typecode/DelegatingTypeCodeWriter.java", "rawCode": "  private final void writeIndirectionMarker(\n      final CDROutputStream out, final Object key, final Map indirectionTCMap) {\n    out.write_long(-1); // recursion marker\n    int negative_offset = ((Integer) indirectionTCMap.get(key)).intValue() - out.get_pos() - 4;\n\n    out.write_long(negative_offset);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5415, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 74, "focalAPIEnd": 86, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kai23/Gestionnaire-de-serie/tree/master/apache-log4j-1.2.17/src/main/java/org/apache/log4j/pattern/PatternParser.java", "rawCode": "    /** {@inheritDoc} */\n    public Object get(Object key) {\n      return map.get(key);\n    }\n"}, {"dataset": "mapGet", "exampleID": 5416, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 799, "focalAPIEnd": 839, "followUpCheck": "value != null && !value.isEmpty()", "checkType": "IF", "followUpCheckExpressionStart": 845, "followUpCheckExpressionEnd": 887, "followUpCheckBlockStart": 845, "followUpCheckBlockEnd": 900, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/petalslink/petals-studio/tree/master/plugins/com.ebmwebsourcing.petals.common/src/com/ebmwebsourcing/petals/common/internal/provisional/ui/jdt/CheckboxTreeAndListGroup.java", "rawCode": "  /**\n   * Returns a boolean indicating whether the passed tree element should be at LEAST gray-checked.\n   * Note that this method does not consider whether it should be white-checked, so a specified tree\n   * item which should be white-checked will result in a <code>true</code> answer from this method.\n   * To determine whether a tree item should be white-checked use method\n   * #determineShouldBeWhiteChecked(Object).\n   *\n   * @param treeElement java.lang.Object\n   * @return boolean\n   * @see #determineShouldBeWhiteChecked(java.lang.Object)\n   */\n  protected boolean determineShouldBeAtLeastGrayChecked(Object treeElement) {\n    // if any list items associated with treeElement are checked then it\n    // retains its gray-checked status regardless of its children\n    List checked = (List) this.fCheckedStateStore.get(treeElement);\n    if (checked != null && !checked.isEmpty()) return true;\n\n    // if any children of treeElement are still gray-checked then treeElement\n    // must remain gray-checked as well\n    Object[] children = getTreeChildren(treeElement);\n    for (int i = 0; i < children.length; ++i) {\n      if (this.fCheckedStateStore.containsKey(children[i])) return true;\n    }\n\n    return false;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5417, "initialization": ["Object key = Map.Entry.getKey()"], "initializationStart": [264], "initializationEnd": [278], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 457, "focalAPIEnd": 470, "followUpCheck": "value1.equals(value)", "checkType": "IF", "followUpCheckExpressionStart": 709, "followUpCheckExpressionEnd": 735, "followUpCheckBlockStart": 709, "followUpCheckBlockEnd": 763, "use": ["map.get(Object)"], "useStart": [591], "useEnd": [604], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bj0rn/IT1901/tree/master/PizzaPlace/lib/mysql-connector-java-5.1.17/src/com/mysql/jdbc/Util.java", "rawCode": "  public static Map calculateDifferences(Map map1, Map map2) {\n    Map diffMap = new HashMap();\n\n    Iterator map1Entries = map1.entrySet().iterator();\n\n    while (map1Entries.hasNext()) {\n      Map.Entry entry = (Map.Entry) map1Entries.next();\n      Object key = entry.getKey();\n\n      Number value1 = null;\n      Number value2 = null;\n\n      if (entry.getValue() instanceof Number) {\n\n        value1 = (Number) entry.getValue();\n        value2 = (Number) map2.get(key);\n      } else {\n        try {\n          value1 = new Double(entry.getValue().toString());\n          value2 = new Double(map2.get(key).toString());\n        } catch (NumberFormatException nfe) {\n          continue;\n        }\n      }\n\n      if (value1.equals(value2)) {\n        continue;\n      }\n\n      if (value1 instanceof Byte) {\n        diffMap.put(\n            key, Byte.valueOf((byte) (((Byte) value2).byteValue() - ((Byte) value1).byteValue())));\n      } else if (value1 instanceof Short) {\n        diffMap.put(\n            key,\n            Short.valueOf((short) (((Short) value2).shortValue() - ((Short) value1).shortValue())));\n      } else if (value1 instanceof Integer) {\n        diffMap.put(\n            key, Integer.valueOf((((Integer) value2).intValue() - ((Integer) value1).intValue())));\n      } else if (value1 instanceof Long) {\n        diffMap.put(key, Long.valueOf((((Long) value2).longValue() - ((Long) value1).longValue())));\n      } else if (value1 instanceof Float) {\n        diffMap.put(\n            key, Float.valueOf(((Float) value2).floatValue() - ((Float) value1).floatValue()));\n      } else if (value1 instanceof Double) {\n        diffMap.put(\n            key, Double.valueOf((((Double) value2).shortValue() - ((Double) value1).shortValue())));\n      } else if (value1 instanceof BigDecimal) {\n        diffMap.put(key, ((BigDecimal) value2).subtract((BigDecimal) value1));\n      } else if (value1 instanceof BigInteger) {\n        diffMap.put(key, ((BigInteger) value2).subtract((BigInteger) value1));\n      }\n    }\n\n    return diffMap;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5418, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [195], "configurationEnd": [211], "guardCondition": "j<map.size()", "guardType": "LOOP {", "guardExpressionStart": 227, "guardExpressionEnd": 275, "guardBlockStart": 227, "guardBlockEnd": 1021, "focalAPI": "value = map.get(key)", "focalAPIStart": 575, "focalAPIEnd": 597, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["mergeMergeInfos(Map,value)", "map.get(Object)", "dupMergeInfo(value,*)", "Map.put(Object,value)", "map.get(Object)", "dupMergeInfo(value,*)", "Map.put(Object,value)"], "useStart": [630, 856, 907, 953, 1136, 1185, 1229], "useEnd": [681, 878, 943, 993, 1158, 1221, 1269], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jenkinsci/svnkit/tree/master/svnkit/src/main/java/org/tmatesoft/svn/core/internal/util/SVNMergeInfoUtil.java", "rawCode": "  public static void mergeCatalog(Map catalog, Map changes) throws SVNException {\n    int i = 0;\n    int j = 0;\n\n    Object[] catalogKeys = catalog.keySet().toArray();\n    Object[] changesKeys = changes.keySet().toArray();\n    while (i < catalog.size() && j < changes.size()) {\n      Comparable catalogKey = (Comparable) catalogKeys[i];\n      Comparable changeKey = (Comparable) changesKeys[j];\n\n      int compare = catalogKey.compareTo(changeKey);\n\n      if (compare == 0) {\n        Map catalogMergeinfo = (Map) catalog.get(catalogKey);\n        Map changesMergeinfo = (Map) changes.get(changeKey);\n\n        Map mergedMergeinfo = mergeMergeInfos(catalogMergeinfo, changesMergeinfo);\n        catalog.put(catalogKey, mergedMergeinfo);\n        i++;\n        j++;\n      } else if (compare < 0) {\n        i++;\n      } else {\n        Map changesMergeinfo = (Map) changes.get(changeKey);\n        changesMergeinfo = dupMergeInfo(changesMergeinfo, null);\n        catalog.put(changeKey, changesMergeinfo);\n        j++;\n      }\n    }\n    for (; j < changes.size(); j++) {\n      Object changeKey = changesKeys[j];\n      Map changesMergeinfo = (Map) changes.get(changeKey);\n      changesMergeinfo = dupMergeInfo(changesMergeinfo, null);\n      catalog.put(changeKey, changesMergeinfo);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5419, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 45, "focalAPIEnd": 62, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/simonjarcher/rt.equinox.bundles/tree/master/bundles/org.eclipse.equinox.ds/src/org/eclipse/equinox/internal/ds/impl/ReadOnlyDictionary.java", "rawCode": "  public Object get(Object key) {\n    return delegate.get(key);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5420, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 287, "focalAPIEnd": 299, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nickveys/statcvs-xml/tree/master/statcvs-xml2/src/net/sf/statcvs/util/IntegerMap.java", "rawCode": "  /**\n   * Same as {@link #get(Object)}, but returns an <code>Integer</code>, not an <code>int</code>.\n   *\n   * @param key the key to get the value for\n   * @return the value wrapped in an <code>Integer</code> object\n   */\n  public Integer getInteger(Object key) {\n    return (Integer) map.get(key);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5421, "initialization": ["Object key = Edge.getOther(Object)"], "initializationStart": [435], "initializationEnd": [454], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 483, "focalAPIEnd": 503, "followUpCheck": "value.color == NodeInfo.COLOR_WHITE", "checkType": "IF", "followUpCheckExpressionStart": 511, "followUpCheckExpressionEnd": 555, "followUpCheckBlockStart": 511, "followUpCheckBlockEnd": 1307, "use": ["visit(Graph,Object,value,int,List)"], "useStart": [648], "useEnd": [690], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/openjpa/tree/master/openjpa-lib/src/main/java/org/apache/openjpa/lib/graph/DepthFirstAnalysis.java", "rawCode": "  /** Visit a node. See Introduction to Algorithms book for details. */\n  private int visit(Graph graph, Object node, NodeInfo info, int time, List<Edge> path) {\n    // discover node\n    info.color = NodeInfo.COLOR_GRAY;\n\n    // explore all vertices from that node depth first\n    Collection<Edge> edges = graph.getEdgesFrom(node);\n    int maxChildTime = time - 1;\n    int childTime;\n    for (Edge edge : edges) {\n      Object other = edge.getOther(node);\n      NodeInfo otherInfo = _nodeInfo.get(other);\n      if (otherInfo.color == NodeInfo.COLOR_WHITE) {\n        // undiscovered node; recurse into it\n        path.add(edge);\n        childTime = visit(graph, other, otherInfo, time, path);\n        path.remove(edge);\n        edge.setType(Edge.TYPE_TREE);\n      } else if (otherInfo.color == NodeInfo.COLOR_GRAY) {\n        childTime = -1;\n        edge.setType(Edge.TYPE_BACK);\n        // calculate the cycle including this edge\n        edge.setCycle(cycleForBackEdge(edge, path));\n      } else {\n        childTime = otherInfo.finished;\n        edge.setType(Edge.TYPE_FORWARD);\n        // find the cycle including this edge\n        List<Edge> cycle = new LinkedList<>();\n        cycle.add(edge);\n        if (cycleForForwardEdge(graph, other, node, cycle)) {\n          edge.setCycle(cycle);\n        }\n      }\n      maxChildTime = Math.max(maxChildTime, childTime);\n    }\n\n    // finished with node\n    info.color = NodeInfo.COLOR_BLACK;\n    info.finished = maxChildTime + 1;\n    return info.finished;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5422, "initialization": ["Object key = Iterator.next()"], "initializationStart": [520], "initializationEnd": [531], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new JSONException(*)"], "tryExpressionStart": 327, "tryExpressionEnd": 331, "tryBlockStart": 327, "tryBlockEnd": 1032, "catchExpressionStart": 953, "catchExpressionEnd": 983, "catchBlockStart": 953, "catchBlockEnd": 1032, "exceptionHandlingCallStart": [997], "exceptionHandlingCallEnd": [1025], "configuration": ["key.toString()"], "configurationStart": [560], "configurationEnd": [572], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 622, "focalAPIEnd": 637, "followUpCheck": "value instanceof JSONObject", "checkType": "IF", "followUpCheckExpressionStart": 647, "followUpCheckExpressionEnd": 675, "followUpCheckBlockStart": 647, "followUpCheckBlockEnd": 874, "use": ["value.write(Writer)", "value.write(Writer)", "valueToString(value)"], "useStart": [688, 775, 846], "useEnd": [718, 804, 862], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yingchauhuang/keepwin/tree/master/skins/common/media/filemanager/connectors/jsp/libraries/java/src/org/json/JSONObject.java", "rawCode": "  /**\n   * Write the contents of the JSONObject as JSON text to a writer. For compactness, no whitespace\n   * is added.\n   *\n   * <p>Warning: This method assumes that the data structure is acyclical.\n   *\n   * @return The writer.\n   * @throws JSONException\n   */\n  public Writer write(Writer writer) throws JSONException {\n    try {\n      boolean b = false;\n      Iterator keys = keys();\n      writer.write('{');\n\n      while (keys.hasNext()) {\n        if (b) {\n          writer.write(',');\n        }\n        Object k = keys.next();\n        writer.write(quote(k.toString()));\n        writer.write(':');\n        Object v = this.map.get(k);\n        if (v instanceof JSONObject) {\n          ((JSONObject) v).write(writer);\n        } else if (v instanceof JSONArray) {\n          ((JSONArray) v).write(writer);\n        } else {\n          writer.write(valueToString(v));\n        }\n        b = true;\n      }\n      writer.write('}');\n      return writer;\n    } catch (IOException exception) {\n      throw new JSONException(exception);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5423, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 478, "focalAPIEnd": 496, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["map.get(Object)", "DigraphNode.removeEdge(value)", "value.addEdge(DigraphNode)"], "useStart": [543, 569, 618], "useEnd": [562, 605, 651], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dvn/dvn-svn-import-test4/tree/master/dvn-app/tags/v2.2/src/DVN-ingest/src/edu/harvard/iq/dvn/ingest/org/thedata/statdataio/spi/PartiallyOrderedSet.java", "rawCode": "  /**\n   * Sets an ordering between two nodes. When an iterator is requested, the first node will appear\n   * earlier in the sequence than the second node. If a prior ordering existed between the nodes in\n   * the opposite order, it is removed.\n   *\n   * @return <code>true</code> if no prior ordering existed between the nodes, <code>false</code>\n   *     otherwise.\n   */\n  public boolean setOrdering(Object first, Object second) {\n    DigraphNode firstPONode = (DigraphNode) poNodes.get(first);\n    DigraphNode secondPONode = (DigraphNode) poNodes.get(second);\n\n    secondPONode.removeEdge(firstPONode);\n    return firstPONode.addEdge(secondPONode);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5424, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 113, "focalAPIEnd": 128, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["value.setPropertyValue(Object,Object)"], "useStart": [134], "useEnd": [176], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/gmf-runtime/tree/master/org.eclipse.gmf.runtime.diagram.ui.properties/src/org/eclipse/gmf/runtime/diagram/ui/properties/descriptors/FlattenedContainmentListPropertyValue.java", "rawCode": "  public void setPropertyValue(Object id, Object value) {\n    IPropertySource propertySource = (IPropertySource) sources.get(id);\n    propertySource.setPropertyValue(id, value);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5425, "initialization": ["Object key = Iterator<Object>.next()"], "initializationStart": [732], "initializationEnd": [743], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()", "key.toString()"], "configurationStart": [657, 781], "configurationEnd": [671, 795], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 863, "focalAPIEnd": 877, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setValue(Object,Field,value)"], "useStart": [839], "useEnd": [878], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/exoplatform/aio-portal/tree/master/component/web/src/main/java/org/exoplatform/web/command/CommandHandler.java", "rawCode": "  /**\n   * This method should use the java reflection to create the command object according to the\n   * command type, then populate the command properties\n   *\n   * @param type The command class type\n   * @param props list of the properties that should be set in the command object\n   * @return The command object instance\n   * @throws Exception\n   */\n  @SuppressWarnings(\"unchecked\")\n  public Command createCommand(String type, Map props) throws Exception {\n    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n    Class<?> clazz = classLoader.loadClass(type);\n    Object object = clazz.newInstance();\n    Iterator<Object> iter = props.keySet().iterator();\n    while (iter.hasNext()) {\n      Object key = iter.next();\n      Field field = getField(clazz, key.toString());\n      if (field == null) continue;\n      setValue(object, field, props.get(key));\n    }\n    return (Command) object;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5426, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "map.containsKey(key,)", "guardType": "IF {", "guardExpressionStart": 217, "guardExpressionEnd": 240, "guardBlockStart": 217, "guardBlockEnd": 278, "focalAPI": "value = map.get(key)", "focalAPIStart": 266, "focalAPIEnd": 276, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new MapEntry(Object,value)"], "useStart": [248], "useEnd": [277], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/videlalvaro/clochure/tree/master/src/jvm/clojure/lang/RT.java", "rawCode": "  public static Object find(Object coll, Object key) {\n    if (coll == null) return null;\n    else if (coll instanceof Associative) return ((Associative) coll).entryAt(key);\n    else {\n      Map m = (Map) coll;\n      if (m.containsKey(key)) return new MapEntry(key, m.get(key));\n      return null;\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5427, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 94, "focalAPIEnd": 109, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 115, "followUpCheckExpressionEnd": 136, "followUpCheckBlockStart": 115, "followUpCheckBlockEnd": 209, "use": ["map.put(Object,Set)", "value.add(Object)"], "useStart": [177, 221], "useEnd": [202, 240], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/impulse-org/imp.xform/tree/master/src/org/eclipse/imp/xform/search/ASTSearchTreeContentProvider.java", "rawCode": "  private boolean insertInto(Object parent, Object child, Map map) {\n    Set children = (Set) map.get(parent);\n    if (children == null) {\n      children = new HashSet();\n      map.put(parent, children);\n    }\n    return children.add(child);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5428, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 303, "focalAPIEnd": 337, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 343, "followUpCheckExpressionEnd": 371, "followUpCheckBlockStart": 343, "followUpCheckBlockEnd": 399, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MarkBennett/dart/tree/master/editor/tools/plugins/com.google.dart.tools.ui/src/com/google/dart/tools/ui/internal/dialogs/CheckboxTreeAndListGroup.java", "rawCode": "  /**\n   * Return a boolean indicating whether all list elements associated with the passed tree element\n   * are currently checked\n   *\n   * @return boolean\n   * @param treeElement java.lang.Object\n   */\n  protected boolean areAllElementsChecked(Object treeElement) {\n    List checkedElements = (List) checkedStateStore.get(treeElement);\n    if (checkedElements == null) {\n      return false;\n    }\n\n    return getListItemsSize(treeElement) == checkedElements.size();\n  }\n"}, {"dataset": "mapGet", "exampleID": 5429, "initialization": ["Object key = Iterator.next()"], "initializationStart": [185], "initializationEnd": [196], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [121], "configurationEnd": [133], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 240, "focalAPIEnd": 252, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(value)"], "useStart": [204], "useEnd": [253], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/neuro4j/nms/tree/master/neuro4j-nms-server/src/main/vlh/net/mlw/vlh/web/util/JspUtils.java", "rawCode": "  public static String toAttributesString(Map map) {\n    StringBuffer sb = new StringBuffer();\n\n    for (Iterator iter = map.keySet().iterator(); iter.hasNext(); ) {\n      Object key = iter.next();\n      sb.append(key).append(\"=\\\"\").append(map.get(key)).append(\"\\\" \");\n    }\n\n    return sb.toString();\n  }\n"}, {"dataset": "mapGet", "exampleID": 5430, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 66, "focalAPIEnd": 86, "followUpCheck": "value != null", "checkType": "IF", "followUpCheckExpressionStart": 92, "followUpCheckExpressionEnd": 108, "followUpCheckBlockStart": 92, "followUpCheckBlockEnd": 172, "use": ["value.get()"], "useStart": [124], "useEnd": [133], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/biojava/biojava-legacy/tree/master/core/src/main/java/org/biojava/utils/cache/WeakValueHashMap.java", "rawCode": "  public Object get(Object key) {\n    Reference ref = (Reference) keyToRefMap.get(key);\n    if (ref != null) {\n      return ref.get();\n    } else {\n      return null;\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5431, "initialization": ["Object key = Iterator.next()"], "initializationStart": [673], "initializationEnd": [685], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.remove(String)", "map.keySet()"], "configurationStart": [87, 599], "configurationEnd": [121, 620], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 708, "focalAPIEnd": 729, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setUserDatum(Object,value,*)"], "useStart": [737], "useEnd": [785], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/markus1978/clickwatch/tree/master/external/edu.uci.ics.jung/src/edu/uci/ics/jung/io/GraphMLFileHandler.java", "rawCode": "  protected void createGraph(Map attributeMap) {\n    String edgeDefaultType = (String) attributeMap.remove(\"edgedefault\");\n    mGraph = new SparseGraph();\n    if (edgeDefaultType.equals(\"directed\")) {\n      default_directed = true;\n      // mGraph = new DirectedSparseGraph();\n    } else if (edgeDefaultType.equals(\"undirected\")) {\n      default_directed = false;\n      // mGraph = new UndirectedSparseGraph();\n    } else {\n      throw new FatalException(\"Error parsing graph. Edge default type not specified.\");\n    }\n\n    mLabeller = StringLabeller.getLabeller(mGraph);\n\n    for (Iterator keyIt = attributeMap.keySet().iterator(); keyIt.hasNext(); ) {\n      Object key = keyIt.next();\n      Object value = attributeMap.get(key);\n      mGraph.setUserDatum(key, value, UserData.SHARED);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5432, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 251, "focalAPIEnd": 278, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 286, "followUpCheckExpressionEnd": 315, "followUpCheckBlockStart": 286, "followUpCheckBlockEnd": 422, "use": ["map.put(Object,Collection)", "value.add(IJobBusyListener)"], "useStart": [368, 429], "useEnd": [413, 459], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/rap/tree/master/bundles/org.eclipse.rap.ui.workbench/Eclipse UI/org/eclipse/ui/internal/progress/ProgressManager.java", "rawCode": "  /**\n   * Add the listener to the family.\n   *\n   * @param family\n   * @param listener\n   */\n  void addListenerToFamily(Object family, IJobBusyListener listener) {\n    synchronized (familyListeners) {\n      Collection currentListeners = (Collection) familyListeners.get(family);\n      if (currentListeners == null) {\n        currentListeners = new HashSet();\n        familyListeners.put(family, currentListeners);\n      }\n      currentListeners.add(listener);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5433, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 208, "focalAPIEnd": 224, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/czarneckid/blojsom-sourceforge/tree/master/branches/blojsom-1_9_2-final/blojsom/plugins/src/org/ignition/blojsom/plugin/referer/BlogRefererGroup.java", "rawCode": "  /**\n   * Get a referer from the group for a given key (URL)\n   *\n   * @param key Referer key\n   * @return <code>BlogReferer</code> for the given key (URL)\n   */\n  public Object get(Object key) {\n    return _groups.get(key);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5434, "initialization": ["Map map = getProperties()"], "initializationStart": [122], "initializationEnd": [137], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "map.containsKey(key,)", "guardType": "IF {", "guardExpressionStart": 145, "guardExpressionEnd": 171, "guardBlockStart": 145, "guardBlockEnd": 211, "focalAPI": "value = map.get(key)", "focalAPIStart": 189, "focalAPIEnd": 202, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/biojava/biojava-legacy/tree/master/core/src/main/java/org/biojava/bio/AbstractAnnotation.java", "rawCode": "  public Object getProperty(Object key) throws NoSuchElementException {\n    if (propertiesAllocated()) {\n      Map prop = getProperties();\n      if (prop.containsKey(key)) {\n        return prop.get(key);\n      }\n    }\n    throw new NoSuchElementException(\"Property \" + key + \" unknown\");\n  }\n"}, {"dataset": "mapGet", "exampleID": 5435, "initialization": ["Object key = Iterator.next()"], "initializationStart": [446], "initializationEnd": [455], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [362], "configurationEnd": [383], "guardCondition": "map!=null", "guardType": "IF {", "guardExpressionStart": 276, "guardExpressionEnd": 301, "guardBlockStart": 276, "guardBlockEnd": 568, "focalAPI": "value = map.get(key)", "focalAPIStart": 494, "focalAPIEnd": 515, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["value.clone()"], "useStart": [542], "useEnd": [552], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AllBinary/phoneme-components-cdc/tree/master/src/share/classes/sun/net/www/protocol/jar/URLJarFile.java", "rawCode": "  public Manifest getManifest() throws IOException {\n\n    if (!isSuperMan()) {\n      return null;\n    }\n\n    Manifest man = new Manifest();\n    Attributes attr = man.getMainAttributes();\n    attr.putAll((Map) superAttr.clone());\n\n    // now deep copy the manifest entries\n    if (superEntries != null) {\n      Map entries = man.getEntries();\n      Iterator it = superEntries.keySet().iterator();\n      while (it.hasNext()) {\n        Object key = it.next();\n        Attributes at = (Attributes) superEntries.get(key);\n        entries.put(key, at.clone());\n      }\n    }\n\n    return man;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5436, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 95, "focalAPIEnd": 107, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ramesesinc/incubation/tree/master/rameses-client-mobile/src/com/rameses/util/MapProxy.java", "rawCode": "  private String getStringImpl(Map map, Object key) {\n    Object value = (map == null ? null : map.get(key));\n    return (value == null ? null : value.toString());\n  }\n"}, {"dataset": "mapGet", "exampleID": 5437, "initialization": ["Object key = intern(Object)"], "initializationStart": [472], "initializationEnd": [489], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 616, "focalAPIEnd": 636, "followUpCheck": "value != null", "checkType": "IF", "followUpCheckExpressionStart": 644, "followUpCheckExpressionEnd": 658, "followUpCheckBlockStart": 644, "followUpCheckBlockEnd": 796, "use": ["value.bypassValue(Object)"], "useStart": [767], "useEnd": [787], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dancres/blitzjavaspaces/tree/master/src/main/java/com/go/trove/util/Depot.java", "rawCode": "  /**\n   * Put a value into the Depot, bypassing the factory. Invalidating an object and relying on the\n   * factory to produce a new value is generally preferred. This method will notify any threads\n   * waiting on a factory to produce a value, but it will not disrupt the behavior of the factory.\n   *\n   * @param key key with which to associate the value.\n   * @param value value to be associated with key.\n   */\n  public void put(Object key, Object value) {\n    key = Utils.intern(key);\n    synchronized (key) {\n      mInvalidCache.remove(key);\n      mValidCache.put(key, value);\n      Retriever r = (Retriever) mRetrievers.get(key);\n      if (r != null) {\n        // Bypass the factory produced value so that any waiting\n        // threads are notified.\n        r.bypassValue(value);\n      }\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5438, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 91, "focalAPIEnd": 112, "followUpCheck": "value instanceof List", "checkType": "IF", "followUpCheckExpressionStart": 119, "followUpCheckExpressionEnd": 148, "followUpCheckBlockStart": 119, "followUpCheckBlockEnd": 262, "use": ["map.remove(Object)"], "useStart": [231], "useEnd": [255], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iBot/HAW_SS13_AI/tree/master/code/HES/lib/dom4j-1.6.1/src/java/org/dom4j/util/IndexedElement.java", "rawCode": "  protected void removeFromElementIndex(Object key, Element value) {\n    Object oldValue = elementIndex.get(key);\n\n    if (oldValue instanceof List) {\n      List list = (List) oldValue;\n      list.remove(value);\n    } else {\n      elementIndex.remove(key);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5439, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 49, "focalAPIEnd": 61, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/8nevil8/xstream/tree/master/xstream/src/test/com/thoughtworks/xstream/persistence/XmlArrayListTest.java", "rawCode": "    public Object get(Object key) {\n      return map.get(key);\n    }\n"}, {"dataset": "mapGet", "exampleID": 5440, "initialization": ["Object key = Iterator.next()"], "initializationStart": [568], "initializationEnd": [579], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [403], "configurationEnd": [421], "guardCondition": "!(true||map==null||map.isEmpty())", "guardType": "IF {", "guardExpressionStart": 312, "guardExpressionEnd": 376, "guardBlockStart": 312, "guardBlockEnd": 390, "focalAPI": "value = map.get(key)", "focalAPIStart": 605, "focalAPIEnd": 624, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Map.put(Object,value)"], "useStart": [587], "useEnd": [625], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/KNL-635/kernel-util/src/main/java/org/sakaiproject/util/MapUtil.java", "rawCode": "  /**\n   * Copies elements from a map to another map (similar to putall)\n   *\n   * @param destMap The Map to add the key/value pairs to.\n   * @param sourceMap The Map to add the key/value pairs from\n   * @return true if there were keys copied\n   */\n  public static boolean copy(Map destMap, Map sourceMap) {\n    if (destMap == null || sourceMap == null || sourceMap.isEmpty()) return false;\n    Set s = sourceMap.keySet();\n    if (s == null) return false;\n    Iterator iSet = s.iterator();\n\n    boolean retval = false;\n    while (iSet.hasNext()) {\n      Object item = iSet.next();\n      destMap.put(item, sourceMap.get(item));\n      // System.out.println(\"Copying \"+item+\" =\"+sourceMap.get(item));\n      retval = true;\n    }\n    return retval;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5441, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 184, "focalAPIEnd": 196, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 202, "followUpCheckExpressionEnd": 218, "followUpCheckBlockStart": 202, "followUpCheckBlockEnd": 278, "use": ["map.put(Object,HashSet)", "value.add(Object)"], "useStart": [254, 283], "useEnd": [271, 297], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/antlr/stringtemplate3/tree/master/src/org/antlr/stringtemplate/StringTemplate.java", "rawCode": "  /** Manage a hash table like it has multiple unique values. Map<Object,Set>. */\n  protected void putToMultiValuedMap(Map map, Object key, Object value) {\n    HashSet bag = (HashSet) map.get(key);\n    if (bag == null) {\n      bag = new HashSet();\n      map.put(key, bag);\n    }\n    bag.add(value);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5442, "initialization": ["Object key = Iterator.next()"], "initializationStart": [2387], "initializationEnd": [2399], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["toString()", "new RuntimeException(*)"], "tryExpressionStart": 171, "tryExpressionEnd": 175, "tryBlockStart": 171, "tryBlockEnd": 2619, "catchExpressionStart": 2542, "catchExpressionEnd": 2564, "catchBlockStart": 2542, "catchBlockEnd": 2619, "exceptionHandlingCallStart": [2599, 2578], "exceptionHandlingCallEnd": [2611, 2612], "configuration": ["map.keySet()"], "configurationStart": [2299], "configurationEnd": [2317], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 2431, "focalAPIEnd": 2449, "followUpCheck": "pos[value.intValue()]", "checkType": "IF", "followUpCheckExpressionStart": 2459, "followUpCheckExpressionEnd": 2481, "followUpCheckBlockStart": 2459, "followUpCheckBlockEnd": 2500, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Sable/jedd/tree/master/translator/src/polyglot/ext/jedd/types/PhysDom.java", "rawCode": "  public void runSat() throws SemanticException {\n    int numvars = ordMap.size() + (arrMap.size() + setMap.size() + litMap.size()) / 2;\n    if (numvars == 0) return;\n    try {\n      File tmpFile = File.createTempFile(\"domainassign\", \".cnf\");\n      PrintWriter file = new PrintWriter(new FileOutputStream(tmpFile));\n      file.println(\"p cnf \" + numvars + \" \" + cnf.size());\n      for (Iterator clauseIt = cnf.iterator(); clauseIt.hasNext(); ) {\n        final Clause clause = (Clause) clauseIt.next();\n        file.println(clause.toString());\n      }\n      file.close();\n      Process p = Runtime.getRuntime().exec(satSolver + \" \" + tmpFile.getAbsolutePath());\n      BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));\n      String str;\n      String soln = null;\n      while ((str = br.readLine()) != null) {\n        if (STATS) if (str.length() < 1000) System.out.println(str);\n        boolean hasNum = false;\n        boolean hasBad = false;\n        for (int i = 0; i < str.length(); i++) {\n          if (str.charAt(i) == ' ') continue;\n          if (str.charAt(i) == '\\t') continue;\n          if (str.charAt(i) == '-') continue;\n          if (str.charAt(i) >= '0' && str.charAt(i) <= '9') {\n            hasNum = true;\n            continue;\n          }\n          hasBad = true;\n        }\n        if (hasNum && !hasBad) {\n          // this looks like the solution\n          if (soln != null)\n            throw new RuntimeException(\"old solution was \" + soln + \"; now we got \" + str);\n          soln = str;\n        }\n      }\n      boolean pos[] = new boolean[numvars + 1];\n      boolean neg[] = new boolean[numvars + 1];\n      if (soln == null) {\n        unsatCore(tmpFile);\n        throw new SemanticException(\"SAT solver couldn't assign physical domains.\");\n      }\n      StringTokenizer st = new StringTokenizer(soln);\n      while (st.hasMoreTokens()) {\n        String tok = st.nextToken();\n        int i = Integer.parseInt(tok);\n        if (i < 0) neg[-i] = true;\n        else pos[i] = true;\n      }\n      for (int i = 1; i <= numvars; i++) {\n        if (neg[i] && pos[i]) throw new RuntimeException(\"both for \" + i);\n        if (!neg[i] && !pos[i]) throw new RuntimeException(\"neither for \" + i);\n      }\n      solution = new HashSet();\n      for (Iterator litIt = litNumMap.keySet().iterator(); litIt.hasNext(); ) {\n        final Object lit = (Object) litIt.next();\n        Integer i = (Integer) litNumMap.get(lit);\n        if (pos[i.intValue()]) solution.add(lit);\n      }\n      // tmpFile.delete();\n    } catch (IOException e) {\n      throw new RuntimeException(e.toString());\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5443, "initialization": ["Object key = Iterator.next()"], "initializationStart": [270], "initializationEnd": [278], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [203], "configurationEnd": [215], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 307, "focalAPIEnd": 319, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["serializeObject(value)"], "useStart": [384], "useEnd": [406], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bogeblad/infoglue2/tree/master/src/java/org/infoglue/deliver/util/webservices/DynamicWebserviceSerializer.java", "rawCode": "  /** */\n  public List serializeMap(final Map map) {\n    final Map m = (map == null) ? new HashMap() : map;\n\n    final List result = createResultList(m.getClass(), m.size());\n    for (final Iterator i = map.keySet().iterator(); i.hasNext(); ) {\n      final Object key = i.next();\n      final Object value = map.get(key);\n      result.addAll(serializeObject(key));\n      result.addAll(serializeObject(value));\n    }\n    return result;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5444, "initialization": ["Object key = Iterator.next()"], "initializationStart": [272], "initializationEnd": [281], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 368, "focalAPIEnd": 376, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/saschaiseli/opentrainingcenter/tree/master/mockito/org/mockito/cglib/beans/BeanMap.java", "rawCode": "  public boolean equals(Object o) {\n    if (o == null || !(o instanceof Map)) {\n      return false;\n    }\n    Map other = (Map) o;\n    if (size() != other.size()) {\n      return false;\n    }\n    for (Iterator it = keySet().iterator(); it.hasNext(); ) {\n      Object key = it.next();\n      if (!other.containsKey(key)) {\n        return false;\n      }\n      Object v1 = get(key);\n      Object v2 = other.get(key);\n      if (!((v1 == null) ? v2 == null : v1.equals(v2))) {\n        return false;\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5445, "initialization": ["Object key = Iterator.next()"], "initializationStart": [910], "initializationEnd": [922], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [836], "configurationEnd": [850], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 949, "focalAPIEnd": 961, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["value.clone()"], "useStart": [989], "useEnd": [1001], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aldaris/opensso/tree/master/products/amserver/source/com/sun/identity/policy/Policy.java", "rawCode": "  /**\n   * Creates and returns a copy of this object. The returned <code>Policy</code> object will have\n   * the same policy name, rules, subjects, referrals and conditions such that <code>\n   * x.clone().equals(x)</code> will be <code>true</code>. However <code>x.clone()</code> will not\n   * be the same as <code>x</code>, i.e., <code>x.clone() != x</code>.\n   *\n   * @return a copy of this object\n   */\n  public Object clone() {\n    Policy answer = null;\n    try {\n      answer = (Policy) super.clone();\n    } catch (CloneNotSupportedException se) {\n      answer = new Policy();\n    }\n    // Copy state variables\n    answer.origPolicyName = origPolicyName;\n    answer.policyName = policyName;\n    answer.description = description;\n    answer.active = active;\n\n    // Copy rules\n    answer.rules = new HashMap();\n    Iterator items = rules.keySet().iterator();\n    while (items.hasNext()) {\n      Object o = items.next();\n      Rule rule = (Rule) rules.get(o);\n      answer.rules.put(o, rule.clone());\n    }\n\n    // Copy subjects\n    answer.users = (Subjects) users.clone();\n\n    // Copy referrals\n    answer.referrals = (Referrals) referrals.clone();\n\n    // Copy responseProviders\n    answer.respProviders = (ResponseProviders) respProviders.clone();\n\n    // Copy conditions\n    answer.conditions = (Conditions) conditions.clone();\n\n    return (answer);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5446, "initialization": ["Object key = Iterator.next()"], "initializationStart": [585], "initializationEnd": [593], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [522], "configurationEnd": [534], "guardCondition": "map!=null", "guardType": "IF {", "guardExpressionStart": 457, "guardExpressionEnd": 473, "guardBlockStart": 457, "guardBlockEnd": 1118, "focalAPI": "value = map.get(key)", "focalAPIStart": 666, "focalAPIEnd": 678, "followUpCheck": "value instanceof Collection", "checkType": "IF", "followUpCheckExpressionStart": 688, "followUpCheckExpressionEnd": 720, "followUpCheckBlockStart": 688, "followUpCheckBlockEnd": 1015, "use": ["StringBuilder.append(value)"], "useStart": [988], "useEnd": [1004], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.15/kernel-impl/src/main/java/org/sakaiproject/email/impl/BasicEmailService.java", "rawCode": "  /**\n   * Flatten a {@link java.util.Map} to a String\n   *\n   * @param map\n   * @return A string representation of the {@link java.util.Map}. Examples of results include:\n   *     Standard key/value pairs: [[key1:value1], [key2:value2]] List values: [[key1:value1,\n   *     value2], [key2:value3, value4]] Map values: [[key1:[key2:value1]], [key3:[key4:value2]]]\n   */\n  protected String mapToStr(Map map) {\n    StringBuilder sb = new StringBuilder();\n    if (map != null) {\n      sb.append(\"[\");\n      for (Iterator i = map.keySet().iterator(); i.hasNext(); ) {\n        Object key = i.next();\n        sb.append(\"[\").append(key).append(\":\");\n        Object value = map.get(key);\n        if (value instanceof Collection) {\n          sb.append(listToStr((Collection) value));\n        } else if (value instanceof Object[]) {\n          sb.append(arrayToStr((Object[]) value));\n        } else if (value instanceof Map) {\n          sb.append(mapToStr((Map) value));\n        } else {\n          sb.append(value);\n        }\n        sb.append(\"]\");\n\n        if (i.hasNext()) sb.append(\", \");\n      }\n      sb.append(\"]\");\n    }\n    return sb.toString();\n  }\n"}, {"dataset": "mapGet", "exampleID": 5447, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 74, "focalAPIEnd": 86, "followUpCheck": "value instanceof List", "checkType": "IF", "followUpCheckExpressionStart": 94, "followUpCheckExpressionEnd": 118, "followUpCheckBlockStart": 94, "followUpCheckBlockEnd": 137, "use": ["List.add(value)"], "useStart": [236], "useEnd": [251], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/dltk.core/tree/master/core/plugins/org.eclipse.dltk.ui/src/org/eclipse/dltk/internal/ui/workingsets/WorkingSetModel.java", "rawCode": "    private List getAllElements(Map map, Object key) {\n      Object obj = map.get(key);\n      if (obj instanceof List) return (List) obj;\n      if (obj == null) return Collections.EMPTY_LIST;\n      List result = new ArrayList(1);\n      result.add(obj);\n      return result;\n    }\n"}, {"dataset": "mapGet", "exampleID": 5448, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 81, "focalAPIEnd": 112, "followUpCheck": "value != newValue", "checkType": "IF", "followUpCheckExpressionStart": 184, "followUpCheckExpressionEnd": 209, "followUpCheckBlockStart": 184, "followUpCheckBlockEnd": 332, "use": ["map.put(Object,Object)", "handleValueChange(Object,value,Object)"], "useStart": [220, 271], "useEnd": [261, 323], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tomsontom/emf-databinding-example/tree/master/org.eclipse.core.databinding/src/org/eclipse/core/internal/databinding/property/value/DelegatingCache.java", "rawCode": "    private void notifyIfChanged(Object masterElement) {\n      Object oldValue = cachedValues.get(masterElement);\n      Object newValue = masterElementValues.get(masterElement);\n      if (oldValue != newValue) {\n        cachedValues.put(masterElement, newValue);\n        handleValueChange(masterElement, oldValue, newValue);\n      }\n    }\n"}, {"dataset": "mapGet", "exampleID": 5449, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "map.containsKey(key,)", "guardType": "IF {", "guardExpressionStart": 825, "guardExpressionEnd": 858, "guardBlockStart": 825, "guardBlockEnd": 1498, "focalAPI": "value = map.get(key)", "focalAPIStart": 891, "focalAPIEnd": 911, "followUpCheck": "state == value", "checkType": "IF", "followUpCheckExpressionStart": 920, "followUpCheckExpressionEnd": 941, "followUpCheckBlockStart": 920, "followUpCheckBlockEnd": 1380, "use": ["map.put(Object,State)"], "useStart": [1400], "useEnd": [1427], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/boundlessgeo/geotools-2.7.x/tree/master/modules/library/main/src/main/java/org/geotools/data/DefaultTransaction.java", "rawCode": "  /**\n   * Remembers Externalized State for a DataSource.\n   *\n   * <p>This is the GOF Momento pattern: a SimpleFeatureSource is able to externalize its internal\n   * State required for Transaction support and have this class manage it. It may retrieve this\n   * State with getState( key ).\n   *\n   * <p>In addition several SimpleFeatureSource implementations may share State, a common example is\n   * JDBCDataSources keeping a shared JDBC connection using the JDBC URL as a key.\n   *\n   * @param key Key used to externalize State\n   * @param state Externalized State (Momeneto)\n   * @throws IllegalArgumentException When Transaction already using key\n   * @see org.geotools.data.Transaction#putState(java.lang.Object,\n   *     org.geotools.data.Transaction.State)\n   */\n  public void putState(Object key, State state) {\n    if (stateLookup.containsKey(key)) {\n      State current = (State) stateLookup.get(key);\n\n      if (state == current) {\n        throw new IllegalArgumentException(\n            \"Transaction already has an this State for key: \"\n                + key\n                + \". Please check for existing State before creating your own.\");\n      } else {\n        throw new IllegalArgumentException(\n            \"Transaction already has an entry for key:\"\n                + key\n                + \". Please check for existing State before creating your own.\");\n      }\n    } else {\n      stateLookup.put(key, state);\n\n      // allow configuration\n      state.setTransaction(this);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5450, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 45, "focalAPIEnd": 57, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/library/xml/src/main/java/org/geotools/xml/XMLHandlerHints.java", "rawCode": "  public Object get(Object key) {\n    return map.get(key);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5451, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 393, "focalAPIEnd": 416, "followUpCheck": "value != null", "checkType": "IF", "followUpCheckExpressionStart": 422, "followUpCheckExpressionEnd": 447, "followUpCheckBlockStart": 422, "followUpCheckBlockEnd": 649, "use": ["value.waitForLoadAttempt()"], "useStart": [478], "useEnd": [511], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FrecherxDachs/eclipse-sse-modifications/tree/master/bundles/org.eclipse.wst.sse.core/src/org/eclipse/wst/sse/core/internal/model/ModelManagerImpl.java", "rawCode": "  /**\n   * This function returns the reference count of underlying model.\n   *\n   * @param id Object The id of the model TODO: try to refine the design not to use this function\n   */\n  public int getReferenceCountForEdit(Object id) {\n    Assert.isNotNull(id, \"id parameter can not be null\"); // $NON-NLS-1$\n    int count = 0;\n    SYNC.acquire();\n    SharedObject sharedObject = (SharedObject) fManagedObjects.get(id);\n    if (sharedObject != null) {\n      SYNC.release();\n      sharedObject.waitForLoadAttempt();\n      synchronized (sharedObject) {\n        count = sharedObject.referenceCountForEdit;\n      }\n    } else {\n      SYNC.release();\n    }\n    return count;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5452, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 203, "focalAPIEnd": 224, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["value.containsKey(String)"], "useStart": [196], "useEnd": [243], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/markus1978/clickwatch/tree/master/external/edu.uci.ics.jung/src/edu/uci/ics/jung/utils/UnifiedUserData.java", "rawCode": "  /** @see UserDataContainer#containsUserDatumKey(Object) */\n  public boolean containsUserDatumKey(Object key) {\n    // return ((Map)key_meta_map.get(key)).containsKey(getObjectKey());\n    return ((Map) key_meta_map.get(key)).containsKey(this);\n    // return getStorage().containsKey(key);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5453, "initialization": ["Object key = Iterator.next()"], "initializationStart": [536], "initializationEnd": [547], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new JSONException(*)"], "tryExpressionStart": 350, "tryExpressionEnd": 354, "tryBlockStart": 350, "tryBlockEnd": 1608, "catchExpressionStart": 1529, "catchExpressionEnd": 1559, "catchBlockStart": 1529, "catchBlockEnd": 1608, "exceptionHandlingCallStart": [1573], "exceptionHandlingCallEnd": [1601], "configuration": ["key.toString()"], "configurationStart": [576], "configurationEnd": [590], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 719, "focalAPIEnd": 736, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["writeValue(Writer,value,int,int)", "map.get(Object)", "writeValue(Writer,value,int,int)"], "useStart": [700, 1282, 1263], "useEnd": [759, 1299, 1325], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/demonixis/AtlantisEngine.java/tree/master/Engine/src/org/json/JSONObject.java", "rawCode": "  /**\n   * Write the contents of the JSONObject as JSON text to a writer. For compactness, no whitespace\n   * is added.\n   *\n   * <p>Warning: This method assumes that the data structure is acyclical.\n   *\n   * @return The writer.\n   * @throws JSONException\n   */\n  Writer write(Writer writer, int indentFactor, int indent) throws JSONException {\n    try {\n      boolean commanate = false;\n      final int length = this.length();\n      Iterator keys = this.keys();\n      writer.write('{');\n\n      if (length == 1) {\n        Object key = keys.next();\n        writer.write(quote(key.toString()));\n        writer.write(':');\n        if (indentFactor > 0) {\n          writer.write(' ');\n        }\n        writeValue(writer, this.map.get(key), indentFactor, indent);\n      } else if (length != 0) {\n        final int newindent = indent + indentFactor;\n        while (keys.hasNext()) {\n          Object key = keys.next();\n          if (commanate) {\n            writer.write(',');\n          }\n          if (indentFactor > 0) {\n            writer.write('\\n');\n          }\n          indent(writer, newindent);\n          writer.write(quote(key.toString()));\n          writer.write(':');\n          if (indentFactor > 0) {\n            writer.write(' ');\n          }\n          writeValue(writer, this.map.get(key), indentFactor, newindent);\n          commanate = true;\n        }\n        if (indentFactor > 0) {\n          writer.write('\\n');\n        }\n        indent(writer, indent);\n      }\n      writer.write('}');\n      return writer;\n    } catch (IOException exception) {\n      throw new JSONException(exception);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5454, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 84, "focalAPIEnd": 94, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 100, "followUpCheckExpressionEnd": 114, "followUpCheckBlockStart": 100, "followUpCheckBlockEnd": 170, "use": ["map.put(Object,List)", "value.add(Object)"], "useStart": [150, 175], "useEnd": [163, 183], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mz2/nmica-extra/tree/master/src/biobits/utils/MapUtils.java", "rawCode": "  public static void pushMapping(Map map, Object a, Object b) {\n    List l = (List) map.get(a);\n    if (l == null) {\n      l = new ArrayList();\n      map.put(a, l);\n    }\n    l.add(b);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5455, "initialization": ["Map map = fetchObject(*)", "Object key = Iterator.next()"], "initializationStart": [200, 1444], "initializationEnd": [232, 1454], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 1478, "focalAPIEnd": 1491, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 1501, "followUpCheckExpressionEnd": 1518, "followUpCheckBlockStart": 1501, "followUpCheckBlockEnd": 1707, "use": ["map.entrySet()", "getStateManager(value,StoreContext)", "map.get(Object)", "map.entrySet()", "getStateManager(value,StoreContext)", "map.get(Object)", "map.entrySet()", "getStateManager(value,StoreContext)"], "useStart": [1556, 1823, 3959, 4037, 4304, 5051, 5133, 5414], "useEnd": [1570, 1868, 3972, 4051, 4349, 5064, 5147, 5459], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/openjpa/tree/master/openjpa-jdbc/src/main/java/org/apache/openjpa/jdbc/meta/strats/RelationRelationMapTableFieldStrategy.java", "rawCode": "  @Override\n  public void update(OpenJPAStateManager sm, JDBCStore store, RowManager rm) throws SQLException {\n    if (field.getMappedBy() != null && !field.isBiMTo1JT()) return;\n\n    Map map = (Map) sm.fetchObject(field.getIndex());\n    ChangeTracker ct = null;\n    if (map instanceof Proxy) {\n      Proxy proxy = (Proxy) map;\n      if (Proxies.isOwner(proxy, sm, field.getIndex())) ct = proxy.getChangeTracker();\n    }\n\n    // if no fine-grained change tracking then just delete and reinsert\n    if (ct == null || !ct.isTracking()) {\n      delete(sm, store, rm);\n      insert(sm, rm, map, store);\n      return;\n    }\n\n    ValueMapping key = field.getKeyMapping();\n    ValueMapping val = field.getElementMapping();\n    StoreContext ctx = store.getContext();\n    OpenJPAStateManager keysm, valsm;\n\n    // update the changes; note that we have to model changes as\n    // delete-then-insert if we have a foreign key action, because\n    // secondary row updates aren't part of the constraint graph\n    Collection change = ct.getChanged();\n    boolean canChange = val.getForeignKey().isLogical();\n    Object mkey;\n    if (canChange && !change.isEmpty()) {\n      Row changeRow = null;\n      if (!field.isUni1ToMFK()) {\n        changeRow = rm.getSecondaryRow(field.getTable(), Row.ACTION_UPDATE);\n        changeRow.whereForeignKey(field.getJoinForeignKey(), sm);\n      }\n      for (Iterator itr = change.iterator(); itr.hasNext(); ) {\n        mkey = itr.next();\n        Object mval = map.get(mkey);\n        if (mval == null) {\n          Set<Map.Entry> entries = map.entrySet();\n          for (Map.Entry entry : entries) {\n            if (entry.getKey().equals(mkey)) mval = entry.getValue();\n          }\n        }\n        if (mval == null) continue;\n        keysm = RelationStrategies.getStateManager(mkey, ctx);\n        valsm = RelationStrategies.getStateManager(mval, ctx);\n        key.whereForeignKey(changeRow, keysm);\n        if (field.isUni1ToMFK()) {\n          changeRow =\n              rm.getRow(\n                  field.getElementMapping().getDeclaredTypeMapping().getTable(),\n                  Row.ACTION_UPDATE,\n                  valsm,\n                  true);\n          changeRow.wherePrimaryKey(valsm);\n          val.setForeignKey(changeRow, sm);\n        } else {\n          val.setForeignKey(changeRow, valsm);\n          rm.flushSecondaryRow(changeRow);\n        }\n      }\n    }\n\n    // delete the removes\n    Collection rem = ct.getRemoved();\n    if (!rem.isEmpty() || (!canChange && !change.isEmpty())) {\n      Row delRow = null;\n      if (!field.isUni1ToMFK()) {\n        delRow = rm.getSecondaryRow(field.getTable(), Row.ACTION_DELETE);\n        delRow.whereForeignKey(field.getJoinForeignKey(), sm);\n      }\n\n      for (Iterator itr = rem.iterator(); itr.hasNext(); ) {\n        Object pc = itr.next();\n        if (field.isUni1ToMFK()) {\n          updateSetNull(sm, rm, pc);\n        } else {\n          keysm = RelationStrategies.getStateManager(pc, ctx);\n          key.whereForeignKey(delRow, keysm);\n          rm.flushSecondaryRow(delRow);\n        }\n      }\n      if (!canChange && !change.isEmpty()) {\n        for (Iterator itr = change.iterator(); itr.hasNext(); ) {\n          Object pc = itr.next();\n          if (field.isUni1ToMFK()) {\n            updateSetNull(sm, rm, pc);\n          } else {\n            keysm = RelationStrategies.getStateManager(pc, ctx);\n            key.whereForeignKey(delRow, keysm);\n            rm.flushSecondaryRow(delRow);\n          }\n        }\n      }\n    }\n\n    // insert the adds\n    Collection add = ct.getAdded();\n    if (!add.isEmpty() || (!canChange && !change.isEmpty())) {\n      Row addRow = null;\n      if (!field.isUni1ToMFK()) {\n        addRow = rm.getSecondaryRow(field.getTable(), Row.ACTION_INSERT);\n        addRow.setForeignKey(field.getJoinForeignKey(), field.getJoinColumnIO(), sm);\n      }\n      for (Iterator itr = add.iterator(); itr.hasNext(); ) {\n        mkey = itr.next();\n        Object mval = map.get(mkey);\n        if (mval == null) {\n          Set<Map.Entry> entries = map.entrySet();\n          for (Map.Entry entry : entries) {\n            if (entry.getKey().equals(mkey)) mval = entry.getValue();\n          }\n        }\n        if (mval == null) continue;\n        keysm = RelationStrategies.getStateManager(mkey, ctx);\n        valsm = RelationStrategies.getStateManager(mval, ctx);\n        if (field.isUni1ToMFK()) {\n          addRow =\n              rm.getRow(\n                  field.getElementMapping().getDeclaredTypeMapping().getTable(),\n                  Row.ACTION_UPDATE,\n                  valsm,\n                  true);\n          addRow.wherePrimaryKey(valsm);\n          key.setForeignKey(addRow, keysm);\n          val.setForeignKey(addRow, sm);\n        } else {\n          key.setForeignKey(addRow, keysm);\n          val.setForeignKey(addRow, valsm);\n          rm.flushSecondaryRow(addRow);\n        }\n      }\n      if (!canChange && !change.isEmpty()) {\n        for (Iterator itr = change.iterator(); itr.hasNext(); ) {\n          mkey = itr.next();\n          Object mval = map.get(mkey);\n          if (mval == null) {\n            Set<Map.Entry> entries = map.entrySet();\n            for (Map.Entry entry : entries) {\n              if (entry.getKey().equals(mkey)) mval = entry.getValue();\n            }\n          }\n          if (mval == null) continue;\n          keysm = RelationStrategies.getStateManager(mkey, ctx);\n          valsm = RelationStrategies.getStateManager(mval, ctx);\n          if (field.isUni1ToMFK()) {\n            addRow =\n                rm.getRow(\n                    field.getElementMapping().getDeclaredTypeMapping().getTable(),\n                    Row.ACTION_UPDATE,\n                    valsm,\n                    true);\n            addRow.wherePrimaryKey(valsm);\n            key.setForeignKey(addRow, keysm);\n            val.setForeignKey(addRow, sm);\n          } else {\n            key.setForeignKey(addRow, keysm);\n            val.setForeignKey(addRow, valsm);\n            rm.flushSecondaryRow(addRow);\n          }\n        }\n      }\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5456, "initialization": ["Object key = Iterator.next()"], "initializationStart": [457], "initializationEnd": [466], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 519, "focalAPIEnd": 541, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["value.getDigest()"], "useStart": [499], "useEnd": [554], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rtyley/test-bc-java-cvsimport/tree/master/crypto/j2me/org/bouncycastle/cms/CMSSignedDataParser.java", "rawCode": "  /**\n   * return the collection of signers that are associated with the signatures for the message.\n   *\n   * @throws CMSException\n   */\n  public SignerInformationStore getSignerInfos() throws CMSException {\n    if (_signerInfoStore == null) {\n      populateCertCrlSets();\n\n      List signerInfos = new ArrayList();\n      Map hashes = new HashMap();\n\n      Iterator it = digests.keySet().iterator();\n      while (it.hasNext()) {\n        Object digestKey = it.next();\n\n        hashes.put(digestKey, ((DigestCalculator) digests.get(digestKey)).getDigest());\n      }\n\n      try {\n        ASN1SetParser s = _signedData.getSignerInfos();\n        ASN1Encodable o;\n\n        while ((o = s.readObject()) != null) {\n          SignerInfo info = SignerInfo.getInstance(o.toASN1Primitive());\n\n          byte[] hash = (byte[]) hashes.get(info.getDigestAlgorithm().getAlgorithm());\n\n          signerInfos.add(new SignerInformation(info, _signedContentType, null, hash));\n        }\n      } catch (IOException e) {\n        throw new CMSException(\"io exception: \" + e.getMessage(), e);\n      }\n\n      _signerInfoStore = new SignerInformationStore(signerInfos);\n    }\n\n    return _signerInfoStore;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5457, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 74, "focalAPIEnd": 91, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["map.get(Object)", "value.compareTo(*)"], "useStart": [103, 60], "useEnd": [120, 121], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/markus1978/clickwatch/tree/master/external/edu.uci.ics.jung/src/edu/uci/ics/jung/algorithms/shortestpath/DijkstraDistance.java", "rawCode": "    public int compare(Object o1, Object o2) {\n      return ((Comparable) distances.get(o1)).compareTo(distances.get(o2));\n    }\n"}, {"dataset": "mapGet", "exampleID": 5458, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 55, "focalAPIEnd": 76, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/SpagoBI-V4x/tree/master/SpagoBIUtils/src/it/eng/spagobi/utilities/engines/EngineAnalysisState.java", "rawCode": "  public Object getProperty(Object pName) {\n    return properties.get(pName);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5459, "initialization": ["Object key = Iterator.next()"], "initializationStart": [191], "initializationEnd": [199], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 229, "focalAPIEnd": 242, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(value)"], "useStart": [207], "useEnd": [243], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/biojava/biojava-legacy/tree/master/core/src/main/java/org/biojava/bio/AbstractAnnotation.java", "rawCode": "  public String toString() {\n    StringBuffer sb = new StringBuffer(\"{\");\n    Map prop = getProperties();\n    Iterator i = prop.keySet().iterator();\n    if (i.hasNext()) {\n      Object key = i.next();\n      sb.append(key + \"=\" + prop.get(key));\n    }\n    while (i.hasNext()) {\n      Object key = i.next();\n      sb.append(\",\" + key + \"=\" + prop.get(key));\n    }\n    sb.append(\"}\");\n    return sb.substring(0);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5460, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 113, "focalAPIEnd": 141, "followUpCheck": "value != null", "checkType": "IF", "followUpCheckExpressionStart": 147, "followUpCheckExpressionEnd": 164, "followUpCheckBlockStart": 147, "followUpCheckBlockEnd": 415, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/gmf-runtime/tree/master/org.eclipse.gmf.runtime.diagram.ui.resources.editor/src/org/eclipse/gmf/runtime/diagram/ui/resources/editor/document/AbstractDocumentProvider.java", "rawCode": "  public final void updateStateCache(Object element) throws CoreException {\n    ElementInfo info = (ElementInfo) fElementInfoMap.get(element);\n    if (info != null) {\n      boolean wasReadOnly = isReadOnly(element);\n      doUpdateStateCache(element);\n      if (invalidatesState(element, wasReadOnly)) {\n        info.fIsStateValidated = false;\n        fireElementStateValidationChanged(element, false);\n      }\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5461, "initialization": ["Object key = Iterator.next()"], "initializationStart": [364], "initializationEnd": [373], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [299], "configurationEnd": [314], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 523, "focalAPIEnd": 538, "followUpCheck": "value instanceof String", "checkType": "IF", "followUpCheckExpressionStart": 546, "followUpCheckExpressionEnd": 574, "followUpCheckBlockStart": 546, "followUpCheckBlockEnd": 966, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jiongs/cocit/tree/master/src/core/com/kmetop/demsy/util/mock/MockHttpServletRequest.java", "rawCode": "  /**\n   * Adds all provided parameters <emphasis>without</emphasis> replacing any existing values. To\n   * replace existing values, use {@link #setParameters(Map)}.\n   */\n  public void addParameters(Map params) {\n    Assert.notNull(params, \"Parameter map must not be null\");\n    for (Iterator it = params.keySet().iterator(); it.hasNext(); ) {\n      Object key = it.next();\n      Assert.isInstanceOf(\n          String.class, key, \"Parameter map key must be of type [\" + String.class.getName() + \"]\");\n      Object value = params.get(key);\n      if (value instanceof String) {\n        this.addParameter((String) key, (String) value);\n      } else if (value instanceof String[]) {\n        this.addParameter((String) key, (String[]) value);\n      } else {\n        throw new IllegalArgumentException(\n            \"Parameter map value must be single value \"\n                + \" or array of type [\"\n                + String.class.getName()\n                + \"]\");\n      }\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5462, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 206, "focalAPIEnd": 224, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 230, "followUpCheckExpressionEnd": 246, "followUpCheckBlockStart": 230, "followUpCheckBlockEnd": 270, "use": ["value.addRef()"], "useStart": [282], "useEnd": [294], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/maihde/org.eclipse.rap/tree/master/bundles/org.eclipse.rap.ui.workbench/Eclipse UI/org/eclipse/ui/internal/ReferenceCounter.java", "rawCode": "  /**\n   * Adds one reference to an object in the counter.\n   *\n   * @param id is a unique ID for the object.\n   * @return the new ref count\n   */\n  public int addRef(Object id) {\n    RefRec rec = (RefRec) mapIdToRec.get(id);\n    if (rec == null) {\n      return 0;\n    }\n    return rec.addRef();\n  }\n"}, {"dataset": "mapGet", "exampleID": 5463, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 208, "focalAPIEnd": 224, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/czarneckid/blojsom-sourceforge/tree/master/branches/blojsom-2_31-final/blojsom-2.0/plugins/src/org/blojsom/plugin/referer/BlogRefererGroup.java", "rawCode": "  /**\n   * Get a referer from the group for a given key (URL)\n   *\n   * @param key Referer key\n   * @return <code>BlogReferer</code> for the given key (URL)\n   */\n  public Object get(Object key) {\n    return _groups.get(key);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5464, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "map.containsKey(key,)", "guardType": "IF {", "guardExpressionStart": 825, "guardExpressionEnd": 858, "guardBlockStart": 825, "guardBlockEnd": 1498, "focalAPI": "value = map.get(key)", "focalAPIStart": 891, "focalAPIEnd": 911, "followUpCheck": "state == value", "checkType": "IF", "followUpCheckExpressionStart": 920, "followUpCheckExpressionEnd": 941, "followUpCheckBlockStart": 920, "followUpCheckBlockEnd": 1380, "use": ["map.put(Object,State)"], "useStart": [1400], "useEnd": [1427], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdeolive/geotools-old/tree/master/modules/library/main/src/main/java/org/geotools/data/DefaultTransaction.java", "rawCode": "  /**\n   * Remembers Externalized State for a DataSource.\n   *\n   * <p>This is the GOF Momento pattern: a SimpleFeatureSource is able to externalize its internal\n   * State required for Transaction support and have this class manage it. It may retrieve this\n   * State with getState( key ).\n   *\n   * <p>In addition several SimpleFeatureSource implementations may share State, a common example is\n   * JDBCDataSources keeping a shared JDBC connection using the JDBC URL as a key.\n   *\n   * @param key Key used to externalize State\n   * @param state Externalized State (Momeneto)\n   * @throws IllegalArgumentException When Transaction already using key\n   * @see org.geotools.data.Transaction#putState(java.lang.Object,\n   *     org.geotools.data.Transaction.State)\n   */\n  public void putState(Object key, State state) {\n    if (stateLookup.containsKey(key)) {\n      State current = (State) stateLookup.get(key);\n\n      if (state == current) {\n        throw new IllegalArgumentException(\n            \"Transaction already has an this State for key: \"\n                + key\n                + \". Please check for existing State before creating your own.\");\n      } else {\n        throw new IllegalArgumentException(\n            \"Transaction already has an entry for key:\"\n                + key\n                + \". Please check for existing State before creating your own.\");\n      }\n    } else {\n      stateLookup.put(key, state);\n\n      // allow configuration\n      state.setTransaction(this);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5465, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 77, "focalAPIEnd": 94, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 102, "followUpCheckExpressionEnd": 118, "followUpCheckBlockStart": 102, "followUpCheckBlockEnd": 187, "use": ["map.put(Object,Label)"], "useStart": [156], "useEnd": [178], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/redstar3894/android-gcc/tree/master/libjava/classpath/tools/external/asm/org/objectweb/asm/xml/ASMContentHandler.java", "rawCode": "    protected final Label getLabel(Object label) {\n      Label lbl = (Label) labels.get(label);\n      if (lbl == null) {\n        lbl = new Label();\n        labels.put(label, lbl);\n      }\n      return lbl;\n    }\n"}, {"dataset": "mapGet", "exampleID": 5466, "initialization": ["Object key = new Pair(Object,TimeZone)", "Object key = new Pair(Object,Locale)"], "initializationStart": [424, 493], "initializationEnd": [447, 514], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 568, "focalAPIEnd": 595, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 602, "followUpCheckExpressionEnd": 621, "followUpCheckBlockStart": 602, "followUpCheckBlockEnd": 1241, "use": ["map.put(Object,FastDateFormat)"], "useStart": [1067], "useEnd": [1102], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/teatrove/teatrove/tree/master/trove/src/main/java/org/teatrove/trove/util/FastDateFormat.java", "rawCode": "  /**\n   * @param style date style: FULL, LONG, MEDIUM, or SHORT\n   * @param timeZone optional time zone, overrides time zone of formatted date\n   * @param locale optional locale, overrides system locale\n   */\n  public static synchronized FastDateFormat getDateInstance(\n      Object style, TimeZone timeZone, Locale locale) throws IllegalArgumentException {\n    Object key = style;\n\n    if (timeZone != null) {\n      key = new Pair(key, timeZone);\n    }\n    if (locale == null) {\n      key = new Pair(key, locale);\n    }\n\n    FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n\n    if (format == null) {\n      int ds;\n      try {\n        ds = ((Integer) style).intValue();\n      } catch (ClassCastException e) {\n        throw new IllegalArgumentException(\"Illegal date style: \" + style);\n      }\n\n      if (locale == null) {\n        locale = Locale.getDefault();\n      }\n\n      try {\n        String pattern = ((SimpleDateFormat) DateFormat.getDateInstance(ds, locale)).toPattern();\n        format = getInstance(pattern, timeZone, locale);\n        cDateInstanceCache.put(key, format);\n      } catch (ClassCastException e) {\n        throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n      }\n    }\n\n    return format;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5467, "initialization": ["Map map = new Hashtable(Map)", "Object key = Iterator.next()"], "initializationStart": [118, 262], "initializationEnd": [140, 271], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [182], "configurationEnd": [201], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 309, "focalAPIEnd": 329, "followUpCheck": "roots.contains(value)", "checkType": "IF", "followUpCheckExpressionStart": 495, "followUpCheckExpressionEnd": 523, "followUpCheckBlockStart": 495, "followUpCheckBlockEnd": 546, "use": ["value.getAttributes()"], "useStart": [411], "useEnd": [434], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cytoscape/cytoscape2/tree/master/coreplugins/AutomaticLayout/src/main/java/org/jgraph/graph/GraphLayoutCache.java", "rawCode": "  /** DOCUMENT ME! */\n  public synchronized void reload() {\n    List newRoots = new ArrayList();\n    Map oldMapping = new Hashtable(mapping);\n    mapping.clear();\n\n    Iterator it = oldMapping.keySet().iterator();\n\n    while (it.hasNext()) {\n      Object cell = it.next();\n      CellView oldView = (CellView) oldMapping.get(cell);\n      CellView newView = getMapping(cell, true);\n      newView.changeAttributes(oldView.getAttributes());\n\n      // newView.refresh(getModel(), this, false);\n      if (roots.contains(oldView)) newRoots.add(newView);\n    }\n\n    // replace hidden\n    hiddenMapping.clear();\n    roots = newRoots;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5468, "initialization": ["Object key = getCookieForTab(*)"], "initializationStart": [63], "initializationEnd": [102], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "key!=null", "guardType": "IF {", "guardExpressionStart": 108, "guardExpressionEnd": 136, "guardBlockStart": 108, "guardBlockEnd": 1025, "focalAPI": "value = map.get(key)", "focalAPIStart": 191, "focalAPIEnd": 228, "followUpCheck": "value != null && !value.backwardEntries.isEmpty()", "checkType": "IF", "followUpCheckExpressionStart": 236, "followUpCheckExpressionEnd": 306, "followUpCheckBlockStart": 236, "followUpCheckBlockEnd": 1019, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/rap/tree/master/bundles/org.eclipse.rap.ui.workbench/Eclipse UI/org/eclipse/ui/internal/NavigationHistory.java", "rawCode": "  private void backwardForTab() {\n    Object editorTabCookie = getCookieForTab(page.getActiveEditor());\n    if (editorTabCookie != null) {\n      PerTabHistory perTabHistory = (PerTabHistory) perTabHistoryMap.get(editorTabCookie);\n      if (perTabHistory != null && !perTabHistory.backwardEntries.isEmpty()) {\n        NavigationHistoryEntry newCurrent =\n            (NavigationHistoryEntry) perTabHistory.backwardEntries.removeFirst();\n        if (perTabHistory.currentEntry != null) {\n          perTabHistory.currentEntry.location.update();\n          perTabHistory.forwardEntries.addFirst(perTabHistory.currentEntry);\n        }\n        perTabHistory.currentEntry = newCurrent;\n        try {\n          ignoreEntries++;\n          if (newCurrent.editorInfo.memento != null) {\n            newCurrent.editorInfo.restoreEditor();\n            checkDuplicates(newCurrent.editorInfo);\n          }\n          newCurrent.restoreLocation();\n          updateActions();\n        } finally {\n          ignoreEntries--;\n        }\n      }\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5469, "initialization": ["Map map = Map.get(String)", "Map map = List.get(int)"], "initializationStart": [532, 875], "initializationEnd": [553, 899], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.getParentName()", "map.setParent(*)", "map.setLocation(*)"], "configurationStart": [601, 657, 960], "configurationEnd": [625, 725, 986], "guardCondition": "map.getComponents().size()>0", "guardType": "IF {", "guardExpressionStart": 908, "guardExpressionEnd": 948, "guardBlockStart": 908, "guardBlockEnd": 1029, "focalAPI": "value = map.get(key)", "focalAPIStart": 996, "focalAPIEnd": 1020, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/firefoxmmx2/jdy/tree/master/src/com/aisino2/strutsmenu/StrutsDynamicMenu.java", "rawCode": "  private List buildMenuComponent(List menuNodeList) {\n    List menuComponentList = new ArrayList();\n    if (menuNodeList == null || menuNodeList.size() == 0) return menuComponentList;\n    String[] index = new String[menuNodeList.size()];\n    Map nodeMap = new HashMap();\n    for (int i = 0; i < menuNodeList.size(); i++) {\n      MenuNode mc = (MenuNode) menuNodeList.get(i);\n      nodeMap.put(mc.getName(), mc);\n      index[i] = mc.getName();\n    }\n    for (int i = 0; i < index.length; i++) {\n      MenuNode menuNode = (MenuNode) nodeMap.get(index[i]);\n      if (menuNode.getParentName() != null && menuNode.getParentName().trim().length() > 0) {\n        menuNode.setParent((MenuNode) nodeMap.get(menuNode.getParentName()));\n      }\n\n      menuComponentList.add(menuNode);\n    }\n    for (int i = 0; i < menuComponentList.size(); i++) {\n      MenuNode menuNode = (MenuNode) menuComponentList.get(i);\n\n      if (menuNode.getComponents().size() > 0) {\n\n        menuNode.setLocation(null);\n        menuNode.setTarget(null);\n      }\n    }\n    return menuComponentList;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5470, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 94, "focalAPIEnd": 109, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 115, "followUpCheckExpressionEnd": 136, "followUpCheckBlockStart": 115, "followUpCheckBlockEnd": 209, "use": ["map.put(Object,Set)", "value.add(Object)"], "useStart": [177, 221], "useEnd": [202, 240], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/akosicki/org.eclipse.dltk.core/tree/master/core/plugins/org.eclipse.dltk.ui/src/org/eclipse/dltk/internal/ui/search/LevelTreeContentProvider.java", "rawCode": "  private boolean insertInto(Object parent, Object child, Map map) {\n    Set children = (Set) map.get(parent);\n    if (children == null) {\n      children = new HashSet();\n      map.put(parent, children);\n    }\n    return children.add(child);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5471, "initialization": ["Object key = arrayToKey(byte[],int,int)"], "initializationStart": [110], "initializationEnd": [142], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 159, "focalAPIEnd": 171, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 177, "followUpCheckExpressionEnd": 191, "followUpCheckBlockStart": 177, "followUpCheckBlockEnd": 232, "use": ["value.intValue()"], "useStart": [244], "useEnd": [268], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/srnsw/xena/tree/master/plugins/image/ext/src/sanselan-0.97-incubator/src/main/java/org/apache/sanselan/common/mylzw/MyLZWCompressor.java", "rawCode": "  private final int codeFromString(byte bytes[], int start, int length) throws IOException {\n    Object key = arrayToKey(bytes, start, length);\n    Object o = map.get(key);\n    if (o == null) throw new IOException(\"CodeFromString\");\n    return ((Integer) o).intValue();\n  }\n"}, {"dataset": "mapGet", "exampleID": 5472, "initialization": ["Object key = Map.remove(String)"], "initializationStart": [645], "initializationEnd": [696], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "key!=null&&map.containsKey(key,)", "guardType": "IF {", "guardExpressionStart": 704, "guardExpressionEnd": 779, "guardBlockStart": 704, "guardBlockEnd": 1022, "focalAPI": "value = map.get(key)", "focalAPIStart": 817, "focalAPIEnd": 857, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fyp09008/E-HospitalS/tree/master/lib/mysql-connector-java-5.1.12/src/com/mysql/jdbc/LoadBalancingConnectionProxy.java", "rawCode": "  /**\n   * Closes current connection and removes it from required mappings.\n   *\n   * @throws SQLException\n   */\n  synchronized void invalidateCurrentConnection() throws SQLException {\n    try {\n      if (!this.currentConn.isClosed()) {\n        this.currentConn.close();\n      }\n\n    } finally {\n      // add host to the global blacklist, if enabled\n      if (this.isGlobalBlacklistEnabled()) {\n        this.addToGlobalBlacklist((String) this.connectionsToHostsMap.get(this.currentConn));\n      }\n      // remove from liveConnections\n      this.liveConnections.remove(this.connectionsToHostsMap.get(this.currentConn));\n      Object mappedHost = this.connectionsToHostsMap.remove(this.currentConn);\n      if (mappedHost != null && this.hostsToListIndexMap.containsKey(mappedHost)) {\n        int hostIndex = ((Integer) this.hostsToListIndexMap.get(mappedHost)).intValue();\n        // reset the statistics for the host\n        synchronized (this.responseTimes) {\n          this.responseTimes[hostIndex] = 0;\n        }\n      }\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5473, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 201, "focalAPIEnd": 216, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/emmanuelbernard/hibernate-core-ogm/tree/master/hibernate-core/src/main/java/org/hibernate/type/MetaType.java", "rawCode": "  public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session)\n      throws HibernateException, SQLException {\n    baseType.nullSafeSet(st, value == null ? null : keys.get(value), index, session);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5474, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 379, "focalAPIEnd": 389, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Logger.fine(value)"], "useStart": [347], "useEnd": [390], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jidesoft/jide-oss/tree/master/src/com/jidesoft/plaf/UIDefaultsLookup.java", "rawCode": "  public static Object get(Object key) {\n    Object value = UIManager.get(key);\n    log(value, key, null);\n    if (value instanceof Map && \"Theme.painter\".equals(key)) {\n      Map map = (Map) value;\n      if (LOGGER.isLoggable(Level.FINE)) {\n        LOGGER.fine(\"Getting \" + key + \" from a map\");\n        for (Object o : map.keySet()) {\n          LOGGER.fine(\"\\t\" + o + \" => \" + map.get(o));\n        }\n      }\n      try {\n        ClassLoader classLoader = getCallerClassLoader();\n        Object o = map.get(classLoader);\n        if (o != null) {\n          if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(\"\\tGetting \" + o + \" using CallerClassLoader\" + classLoader);\n          }\n        }\n        while (o == null && classLoader.getParent() != null) {\n          classLoader = classLoader.getParent();\n          o = map.get(classLoader);\n          if (o != null) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n              LOGGER.fine(\"\\tGetting \" + o + \" using one of the parent ClassLoader \" + classLoader);\n            }\n            break;\n          }\n        }\n        if (o != null) return o;\n      } catch (Exception e) {\n        // ignore\n      }\n      if (map.size() == 1) {\n        Object o = map.values().iterator().next();\n        if (LOGGER.isLoggable(Level.FINE)) {\n          LOGGER.fine(\"Failed...getting the only one \" + o);\n        }\n        return o;\n      } else {\n        Object o = map.get(LookAndFeelFactory.getUIManagerClassLoader());\n        if (LOGGER.isLoggable(Level.FINE)) {\n          LOGGER.fine(\n              \"Failed...getting \"\n                  + o\n                  + \" using UIManagerClassLoader \"\n                  + LookAndFeelFactory.getUIManagerClassLoader());\n        }\n        return o;\n      }\n    }\n    return value;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5475, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 132, "focalAPIEnd": 163, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 169, "followUpCheckExpressionEnd": 192, "followUpCheckBlockStart": 169, "followUpCheckBlockEnd": 296, "use": ["map.put(Object,TagOptionSingleton)"], "useStart": [246], "useEnd": [289], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lboynton/XMPP-Client/tree/master/lib/mp3tag/src/org/farng/mp3/TagOptionSingleton.java", "rawCode": "  public static TagOptionSingleton getInstance(final Object instanceKey) {\n    TagOptionSingleton tagOptions = (TagOptionSingleton) tagOptionTable.get(instanceKey);\n    if (tagOptions == null) {\n      tagOptions = new TagOptionSingleton();\n      tagOptionTable.put(instanceKey, tagOptions);\n    }\n    return tagOptions;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5476, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 53, "focalAPIEnd": 65, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 71, "followUpCheckExpressionEnd": 89, "followUpCheckBlockStart": 71, "followUpCheckBlockEnd": 144, "use": ["map.get(String)", "value.getValue()"], "useStart": [106, 207], "useEnd": [137, 243], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FDVSolutions/DynamicJasper/tree/master/src/main/java/ar/com/fdvs/dj/core/ParameterMapWrapper.java", "rawCode": "  public Object get(Object key) {\n    Object value = map.get(key);\n    if (value == null) {\n      value = map.get(reportName + \"_\" + key);\n    }\n    if (value == null) {\n      return null;\n    }\n\n    return ((JRFillParameter) value).getValue();\n  }\n"}, {"dataset": "mapGet", "exampleID": 5477, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 45, "focalAPIEnd": 61, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AdeleResearchGroup/Cilia/tree/master/examples/hello-world-example-annotations/hello-mediator/src/main/java/hello/world/example/data/MyData.java", "rawCode": "  public Object get(Object key) {\n    return content.get(key);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5478, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 184, "focalAPIEnd": 196, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 202, "followUpCheckExpressionEnd": 218, "followUpCheckBlockStart": 202, "followUpCheckBlockEnd": 278, "use": ["map.put(Object,HashSet)", "value.add(Object)"], "useStart": [254, 283], "useEnd": [271, 297], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/david-mcneil/stringtemplate/tree/master/java/release-3.0/src/org/antlr/stringtemplate/StringTemplate.java", "rawCode": "  /** Manage a hash table like it has multiple unique values. Map<Object,Set>. */\n  protected void putToMultiValuedMap(Map map, Object key, Object value) {\n    HashSet bag = (HashSet) map.get(key);\n    if (bag == null) {\n      bag = new HashSet();\n      map.put(key, bag);\n    }\n    bag.add(value);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5479, "initialization": ["Object key = Iterator.next()"], "initializationStart": [520], "initializationEnd": [531], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new JSONException(*)"], "tryExpressionStart": 327, "tryExpressionEnd": 331, "tryBlockStart": 327, "tryBlockEnd": 1016, "catchExpressionStart": 953, "catchExpressionEnd": 975, "catchBlockStart": 953, "catchBlockEnd": 1016, "exceptionHandlingCallStart": [989], "exceptionHandlingCallEnd": [1009], "configuration": ["key.toString()"], "configurationStart": [560], "configurationEnd": [572], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 622, "focalAPIEnd": 637, "followUpCheck": "value instanceof JSONObject", "checkType": "IF", "followUpCheckExpressionStart": 647, "followUpCheckExpressionEnd": 675, "followUpCheckBlockStart": 647, "followUpCheckBlockEnd": 874, "use": ["value.write(Writer)", "value.write(Writer)", "valueToString(value)"], "useStart": [688, 775, 846], "useEnd": [718, 804, 862], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/LuckyStars/nbc/tree/master/function-teachersignup/java/function-teacherSignup/src/main/com/nbcedu/function/teachersignup/core/util/jsons/JSONObject.java", "rawCode": "  /**\n   * Write the contents of the JSONObject as JSON text to a writer. For compactness, no whitespace\n   * is added.\n   *\n   * <p>Warning: This method assumes that the data structure is acyclical.\n   *\n   * @return The writer.\n   * @throws JSONException\n   */\n  public Writer write(Writer writer) throws JSONException {\n    try {\n      boolean b = false;\n      Iterator keys = keys();\n      writer.write('{');\n\n      while (keys.hasNext()) {\n        if (b) {\n          writer.write(',');\n        }\n        Object k = keys.next();\n        writer.write(quote(k.toString()));\n        writer.write(':');\n        Object v = this.map.get(k);\n        if (v instanceof JSONObject) {\n          ((JSONObject) v).write(writer);\n        } else if (v instanceof JSONArray) {\n          ((JSONArray) v).write(writer);\n        } else {\n          writer.write(valueToString(v));\n        }\n        b = true;\n      }\n      writer.write('}');\n      return writer;\n    } catch (IOException e) {\n      throw new JSONException(e);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5480, "initialization": ["Object key = Iterator.next()"], "initializationStart": [254], "initializationEnd": [266], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [187], "configurationEnd": [201], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 293, "focalAPIEnd": 307, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["value.iterator()", "value.iterator()", "Set.addAll(value)"], "useStart": [421, 604, 959], "useEnd": [438, 621, 980], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aldaris/opensso/tree/master/products/amserver/source/com/sun/identity/idm/plugins/files/FilesRepo.java", "rawCode": "  static Map processAttributes(Map attrs, Set hashAttrs, Set encAttrs) {\n    // Convert to CaseInsensitiveHashMap\n    Map answer = new CaseInsensitiveHashMap();\n    for (Iterator items = attrs.keySet().iterator(); items.hasNext(); ) {\n      Object key = items.next();\n      Set ovalue = (Set) attrs.get(key);\n      Set nvalue = new CaseInsensitiveHashSet();\n      if (hashAttrs.contains(key)) {\n        for (Iterator i = ovalue.iterator(); i.hasNext(); ) {\n          nvalue.add(Hash.hash((String) i.next()));\n        }\n      } else if (encAttrs.contains(key)) {\n        try {\n          for (Iterator i = ovalue.iterator(); i.hasNext(); ) {\n            nvalue.add((String) AccessController.doPrivileged(new EncodeAction((String) i.next())));\n          }\n        } catch (Throwable e) {\n          // Printing the attribute value could be security issue\n          debug.error(\"FilesRepo.processAttributes: unable to encode\", e);\n        }\n      } else {\n        nvalue.addAll(ovalue);\n      }\n      answer.put(key, nvalue);\n    }\n    return (answer);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5481, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 273, "focalAPIEnd": 298, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/emmanuelbernard/hibernate-core-ogm/tree/master/hibernate-core/src/main/java/org/hibernate/engine/internal/StatefulPersistenceContext.java", "rawCode": "  /**\n   * Retreive the EntityEntry representation of the given entity.\n   *\n   * @param entity The entity for which to locate the EntityEntry.\n   * @return The EntityEntry for the given entity.\n   */\n  public EntityEntry getEntry(Object entity) {\n    return (EntityEntry) entityEntries.get(entity);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5482, "initialization": ["Object key = asList(TypeDesc[])"], "initializationStart": [128], "initializationEnd": [148], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 177, "focalAPIEnd": 205, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 212, "followUpCheckExpressionEnd": 229, "followUpCheckBlockStart": 212, "followUpCheckBlockEnd": 672, "use": ["map.put(Object,String)", "StringBuffer.append(value)"], "useStart": [290, 391], "useEnd": [324, 407], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/teatrove/teatrove/tree/master/trove/src/main/java/org/teatrove/trove/classfile/CodeAssemblerPrinter.java", "rawCode": "  private String getTypeDescArrayName(TypeDesc[] types) {\n    if (types == null) {\n      return \"null\";\n    }\n\n    Object key = Arrays.asList(types);\n    String name = (String) mTypeDescArrayNames.get(key);\n\n    if (name == null) {\n      name = \"params_\" + (++mTypeDescArrayCounter);\n      mTypeDescArrayNames.put(key, name);\n\n      StringBuffer buf = new StringBuffer(\"TypeDesc[] \");\n      buf.append(name);\n      buf.append(\" = new TypeDesc[] {\");\n\n      for (int i = 0; i < types.length; i++) {\n        if (i > 0) {\n          buf.append(\", \");\n        }\n        buf.append(getTypeDescName(types[i]));\n      }\n\n      buf.append('}');\n      println(buf.toString());\n    }\n\n    return name;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5483, "initialization": ["Map map = new HashMap(*)", "Object key = Map.Entry.getKey()"], "initializationStart": [63, 357], "initializationEnd": [84, 371], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "map.containsKey(key,)", "guardType": "IF {", "guardExpressionStart": 421, "guardExpressionEnd": 446, "guardBlockStart": 421, "guardBlockEnd": 571, "focalAPI": "value = map.get(key)", "focalAPIStart": 506, "focalAPIEnd": 518, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Map.put(Object,value)", "map.put(Object,Object)", "SimpleMapProperty.setMap(Object,map,MapDiff)"], "useStart": [487, 578, 837], "useEnd": [519, 600, 871], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tomsontom/emf-databinding-example/tree/master/org.eclipse.core.databinding/src/org/eclipse/core/internal/databinding/property/map/SimplePropertyObservableMap.java", "rawCode": "  public void putAll(Map m) {\n    checkRealm();\n\n    Map map = new HashMap(getMap());\n\n    Map oldValues = new HashMap();\n    Map newValues = new HashMap();\n    Set changedKeys = new HashSet();\n    Set addedKeys = new HashSet();\n    for (Iterator it = m.entrySet().iterator(); it.hasNext(); ) {\n      Map.Entry entry = (Entry) it.next();\n      Object key = entry.getKey();\n      Object newValue = entry.getValue();\n      if (map.containsKey(key)) {\n        changedKeys.add(key);\n        oldValues.put(key, map.get(key));\n      } else {\n        addedKeys.add(key);\n      }\n      map.put(key, newValue);\n\n      newValues.put(key, newValue);\n    }\n\n    MapDiff diff =\n        Diffs.createMapDiff(addedKeys, Collections.EMPTY_SET, changedKeys, oldValues, newValues);\n\n    boolean wasUpdating = updating;\n    updating = true;\n    try {\n      property.setMap(source, map, diff);\n      modCount++;\n    } finally {\n      updating = wasUpdating;\n    }\n\n    notifyIfChanged(null);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5484, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 84, "focalAPIEnd": 112, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 119, "followUpCheckExpressionEnd": 136, "followUpCheckBlockStart": 119, "followUpCheckBlockEnd": 144, "use": ["map.remove(Object)", "removeUnchangedElementListeners(Object,value)", "disposeElementInfo(Object,value)"], "useStart": [181, 220, 274], "useEnd": [212, 266, 307], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/eclipse.platform.text/tree/master/org.eclipse.ui.workbench.texteditor/src/org/eclipse/ui/texteditor/AbstractDocumentProvider.java", "rawCode": "  @Override\n  public final void disconnect(Object element) {\n    ElementInfo info = fElementInfoMap.get(element);\n\n    if (info == null) return;\n\n    if (info.fCount == 1) {\n\n      fElementInfoMap.remove(element);\n      removeUnchangedElementListeners(element, info);\n      disposeElementInfo(element, info);\n\n      if (fElementInfoMap.isEmpty()) disconnected();\n\n    } else --info.fCount;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5485, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 107, "focalAPIEnd": 131, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 137, "followUpCheckExpressionEnd": 166, "followUpCheckBlockStart": 137, "followUpCheckBlockEnd": 265, "use": ["Map.get(value)"], "useStart": [306], "useEnd": [341], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/amegginson/jbpm-bpel-ftl/tree/master/jpdl/simulation/src/main/java/org/jbpm/sim/def/JbpmSimulationModel.java", "rawCode": "  protected SimTime getNextSimTimeWithDistributionMap(Object key) {\n    String distributionName = (String) distributionMap.get(key);\n    if (distributionName == null) {\n      log.warn(\"no distribution configured for element '\" + key + \"'\");\n      return null;\n    }\n\n    Distribution dist = (Distribution) distributions.get(distributionName);\n    if (dist == null)\n      throw new ExperimentConfigurationException(\n          \"Distribution with name '\"\n              + distributionName\n              + \"' configured as event distribution for element '\"\n              + key\n              + \"' is not defined.\");\n\n    SimTime result = getSimTimeFromDistribution(dist);\n    log.debug(\"generated sim time \" + result + \" with distribution for element '\" + key + \"'\");\n    return result;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5486, "initialization": ["Object key = Iterator.next()"], "initializationStart": [925], "initializationEnd": [939], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.getClass()", "map.keySet()"], "configurationStart": [585, 845], "configurationEnd": [602, 860], "guardCondition": "!(map==null)", "guardType": "IF {", "guardExpressionStart": 418, "guardExpressionEnd": 437, "guardBlockStart": 418, "guardBlockEnd": 464, "focalAPI": "value = map.get(key)", "focalAPIStart": 969, "focalAPIEnd": 984, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["clone(value)"], "useStart": [963], "useEnd": [985], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/boundlessgeo/geoserver-2.0.x/tree/master/legacy/main/src/main/java/org/vfny/geoserver/global/dto/CloneLibrary.java", "rawCode": "  /**\n   * clone purpose.\n   *\n   * <p>Clones a Map so that it matches the requirements that the returned object would be equal to\n   * the source.\n   *\n   * @param source The Map to be cloned.\n   * @return An exact clone of the list.\n   * @throws CloneNotSupportedException\n   * @see java.lang.Object#clone()\n   * @see java.util.Map\n   */\n  public static Map clone(Map source) throws CloneNotSupportedException {\n    if (source == null) {\n      return null;\n    }\n\n    Map result;\n\n    // to get an exact instance, need to match sub-types for .equals method\n    try {\n      Class c = source.getClass();\n      Constructor ct = c.getConstructor(new Class[0]);\n      result = (Map) ct.newInstance(new Object[0]);\n    } catch (Exception e) {\n      throw new CloneNotSupportedException();\n    }\n\n    // result.putAll(source);\n    Iterator keyIter = source.keySet().iterator();\n\n    while (keyIter.hasNext()) {\n      Object key = keyIter.next();\n      result.put(key, clone(source.get(key)));\n    }\n\n    return result;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5487, "initialization": ["Object key = JComboBox.getSelectedItem()"], "initializationStart": [194], "initializationEnd": [221], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 312, "focalAPIEnd": 335, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/caadapter/tree/master/software/caadapter/src/java/gov/nih/nci/caadapter/ui/common/functions/FunctionConstantDefinitionDialog.java", "rawCode": "  /** Invoked when an action occurs. */\n  public void actionPerformed(ActionEvent e) {\n    String command = e.getActionCommand();\n    if (OK_COMMAND.equals(command)) {\n      Object userSelect = typeField.getSelectedItem();\n      if (functionName.equalsIgnoreCase(\"constant\"))\n        constantTypeClass = (Class) typeMap.get(userSelect);\n      else constantTypeClass = null;\n      constantValue = valueField.getText();\n      if (constantValue == null) constantValue = \"\";\n      else constantValue = constantValue.trim();\n      if (constantValue.length() == 0) {\n        JOptionPane.showMessageDialog(\n            this,\n            \"Input the \" + valueLabel.getName() + \" value.\",\n            \"Missing Value\",\n            JOptionPane.ERROR_MESSAGE);\n        return;\n      }\n\n      try {\n        String type = \"\";\n        if (functionName.equalsIgnoreCase(\"constant\")) {\n          // if(constantTypeClass==java.lang.Integer.class) type = \"int\";\n          // else if(constantTypeClass==java.lang.String.class) type = \"String\";\n          type = DefaultSettings.getClassNameWithoutPackage(getConstantTypeClass());\n        } else type = functionName;\n        FunctionConstant constant = new FunctionConstant();\n        if (functionName.equalsIgnoreCase(constant.getFunctionNameArray()[0]))\n          new FunctionConstant(functionName, type, constantValue);\n        else if (functionName.equalsIgnoreCase(constant.getFunctionNameArray()[1]))\n          new FunctionConstant(functionName, type, constantValue + constant.getTestSuffix());\n        else new FunctionConstant(functionName, type, constantValue);\n      } catch (FunctionException fe) {\n        JOptionPane.showMessageDialog(\n            this, fe.getMessage(), \"Constant Value Validation Failed\", JOptionPane.ERROR_MESSAGE);\n        return;\n      }\n\n      /*\n      if(constantTypeClass==java.lang.Integer.class)\n      {//so far only know how to do validation on integers\n      IntegerValidator validator = new IntegerValidator(constantValue);\n      ValidatorResults result = validator.validate();\n      java.util.List msgList = result.getMessages(ValidatorResult.Level.ERROR);\n      if(msgList!=null && msgList.size()>0)\n      {\n      JOptionPane.showMessageDialog(this, msgList.toArray(new Object[0]), \"Validation Failed\", JOptionPane.ERROR_MESSAGE);\n      return;\n      }\n      }\n      */\n      okButtonClicked = true;\n    } else {\n      okButtonClicked = false;\n    }\n    setVisible(false);\n    dispose();\n  }\n"}, {"dataset": "mapGet", "exampleID": 5488, "initialization": ["Object key = Iterator.next()"], "initializationStart": [413], "initializationEnd": [421], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 445, "focalAPIEnd": 454, "followUpCheck": "value != null", "checkType": "IF", "followUpCheckExpressionStart": 466, "followUpCheckExpressionEnd": 481, "followUpCheckBlockStart": 466, "followUpCheckBlockEnd": 498, "use": ["Collection.add(value)", "map.get(Object)"], "useStart": [482, 708], "useEnd": [497, 716], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/voberoi/jchord/tree/master/libsrc/bddbddb/src/net/sf/bddbddb/order/MapBasedTranslator.java", "rawCode": "  public Order translate(Order o) {\n    if (FindBestDomainOrder.TRACE > 3) System.out.print(\"Translating \" + o);\n    LinkedList result = new LinkedList();\n    for (Iterator i = o.iterator(); i.hasNext(); ) {\n      Object a = i.next();\n      if (a instanceof Collection) {\n        Collection result2 = new LinkedList();\n        for (Iterator j = ((Collection) a).iterator(); j.hasNext(); ) {\n          Object a2 = j.next();\n          Object b2 = m.get(a2);\n          if (b2 != null) result2.add(b2);\n        }\n        if (result2.size() > 1) {\n          result.add(result2);\n        } else if (!result2.isEmpty()) {\n          result.add(result2.iterator().next());\n        }\n      } else {\n        Object b = m.get(a);\n        if (b != null) result.add(b);\n      }\n    }\n    if (FindBestDomainOrder.TRACE > 3) System.out.println(\" -> \" + result);\n    return new Order(result);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5489, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(key==null)", "guardType": "IF {", "guardExpressionStart": 57, "guardExpressionEnd": 77, "guardBlockStart": 57, "guardBlockEnd": 91, "focalAPI": "value = map.get(key)", "focalAPIStart": 130, "focalAPIEnd": 158, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/schmeedy/gmf/tree/master/org.eclipse.gmf.runtime/plugins/org.eclipse.gmf.runtime.diagram.ui.resources.editor/src/org/eclipse/gmf/runtime/diagram/ui/resources/editor/document/AbstractDocumentProvider.java", "rawCode": "  public boolean mustSaveDocument(Object element) {\n\n    if (element == null) return false;\n\n    ElementInfo info = (ElementInfo) fElementInfoMap.get(element);\n    return (info != null ? info.fCount == 1 && info.fCanBeSaved : false);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5490, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 112, "focalAPIEnd": 124, "followUpCheck": "value != null", "checkType": "IF", "followUpCheckExpressionStart": 130, "followUpCheckExpressionEnd": 148, "followUpCheckBlockStart": 130, "followUpCheckBlockEnd": 204, "use": ["map.remove(Object)", "Map.remove(value)"], "useStart": [157, 180], "useEnd": [172, 197], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nmacs/lm3s-uclinux/tree/master/lib/classpath/gnu/java/rmi/activation/BidiTable.java", "rawCode": "  /** Remove the key-value pair by key */\n  public synchronized void removeKey(Object key) {\n    Object value = k2v.get(key);\n    if (value != null) {\n      k2v.remove(key);\n      v2k.remove(value);\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5491, "initialization": ["Object key = Iterator.next()"], "initializationStart": [568], "initializationEnd": [579], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [403], "configurationEnd": [421], "guardCondition": "!(true||map==null||map.isEmpty())", "guardType": "IF {", "guardExpressionStart": 312, "guardExpressionEnd": 376, "guardBlockStart": 312, "guardBlockEnd": 390, "focalAPI": "value = map.get(key)", "focalAPIStart": 605, "focalAPIEnd": 624, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Map.put(Object,value)"], "useStart": [587], "useEnd": [625], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.0.8/kernel-util/src/main/java/org/sakaiproject/util/MapUtil.java", "rawCode": "  /**\n   * Copies elements from a map to another map (similar to putall)\n   *\n   * @param destMap The Map to add the key/value pairs to.\n   * @param sourceMap The Map to add the key/value pairs from\n   * @return true if there were keys copied\n   */\n  public static boolean copy(Map destMap, Map sourceMap) {\n    if (destMap == null || sourceMap == null || sourceMap.isEmpty()) return false;\n    Set s = sourceMap.keySet();\n    if (s == null) return false;\n    Iterator iSet = s.iterator();\n\n    boolean retval = false;\n    while (iSet.hasNext()) {\n      Object item = iSet.next();\n      destMap.put(item, sourceMap.get(item));\n      // System.out.println(\"Copying \"+item+\" =\"+sourceMap.get(item));\n      retval = true;\n    }\n    return retval;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5492, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(map==null)", "guardType": "IF {", "guardExpressionStart": 79, "guardExpressionEnd": 109, "guardBlockStart": 79, "guardBlockEnd": 117, "focalAPI": "value = map.get(key)", "focalAPIStart": 146, "focalAPIEnd": 178, "followUpCheck": "value == null", "checkType": "IF", "followUpCheckExpressionStart": 187, "followUpCheckExpressionEnd": 208, "followUpCheckBlockStart": 187, "followUpCheckBlockEnd": 216, "use": ["value.get(Object)", "value.remove(Object)"], "useStart": [302, 966], "useEnd": [323, 990], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/src/share/classes/java/beans/beancontext/BeanContextServicesSupport.java", "rawCode": "    synchronized void releaseService(Object requestor, Object service) {\n      if (serviceRequestors == null) return;\n\n      Map services = (Map) serviceRequestors.get(requestor);\n\n      if (services == null) return; // oops its not there anymore!\n\n      BCSSCServiceRef serviceRef = (BCSSCServiceRef) services.get(service);\n\n      if (serviceRef == null) return; // oops its not there anymore!\n\n      BCSSCServiceClassRef serviceClassRef = serviceRef.getServiceClassRef();\n      boolean isDelegated = serviceRef.isDelegated();\n      BeanContextServiceProvider bcsp =\n          isDelegated\n              ? serviceClassRef.getDelegateProvider()\n              : serviceClassRef.getServiceProvider();\n\n      bcsp.releaseService(\n          BeanContextServicesSupport.this.getBeanContextServicesPeer(), requestor, service);\n\n      serviceClassRef.releaseRef(isDelegated);\n      serviceClassRef.removeRequestor(requestor);\n\n      if (serviceRef.release() == 0) {\n\n        services.remove(service);\n\n        if (services.isEmpty()) {\n          serviceRequestors.remove(requestor);\n          serviceClassRef.removeRequestor(requestor);\n        }\n\n        if (serviceRequestors.isEmpty()) {\n          serviceRequestors = null;\n        }\n\n        if (serviceClassRef.isEmpty()) {\n          serviceClasses.remove(serviceClassRef.getServiceClass());\n        }\n\n        if (serviceClasses.isEmpty()) serviceClasses = null;\n      }\n    }\n"}, {"dataset": "mapGet", "exampleID": 5493, "initialization": ["Object key = Iterator.next()"], "initializationStart": [238], "initializationEnd": [253], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [166], "configurationEnd": [184], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 280, "focalAPIEnd": 296, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Map.put(Object,value)"], "useStart": [261], "useEnd": [297], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/vjet.all/tree/master/dltk/core/org.eclipse.dltk.mod.core/typeinference/org/eclipse/dltk/mod/ti/statistics/GoalEvalutationRecorder.java", "rawCode": "  public GoalEvalutationRecorder duplicate() {\n    GoalEvalutationRecorder n = new GoalEvalutationRecorder();\n    n.rootRoal = rootRoal;\n    for (Iterator iterator = goalStats.keySet().iterator(); iterator.hasNext(); ) {\n      Object k = iterator.next();\n      n.goalStats.put(k, goalStats.get(k));\n    }\n    return n;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5494, "initialization": ["Map map = ActivityContextImpl.getDataAttributes()", "Object key = Iterator<?>.next()"], "initializationStart": [2078, 2227], "initializationEnd": [2100, 2236], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [2143], "configurationEnd": [2153], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 2255, "focalAPIEnd": 2263, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Mobicents/jain-slee/tree/master/container/activities/src/main/java/org/mobicents/slee/container/management/jmx/ActivityManagementMBeanImpl.java", "rawCode": "  @SuppressWarnings(\"rawtypes\")\n  private Object[] getDetails(ActivityContextImpl ac) {\n\n    logger.debug(\"Retrieveing details for acID[\" + ac.getActivityContextHandle() + \"]\");\n    Object[] o = new Object[ARRAY_SIZE];\n\n    ActivityContextHandle achOrig = ac.getActivityContextHandle();\n    // JmxActivityContextHandle ach = ActivityContextHandleSerializer.encode(achOrig);\n    String acId = ac.getStringID();\n\n    o[ActivityManagementMBeanImplMBean.AC_ID] = acId;\n    logger.debug(\n        \"======[getDetails][\"\n            + o[ActivityManagementMBeanImplMBean.AC_ID]\n            + \"][\"\n            + ac.hashCode()\n            + \"]\");\n\n    if (achOrig.getActivityType() == ActivityType.RA) {\n      o[RA] = ((ResourceAdaptorActivityContextHandle) achOrig).getResourceAdaptorEntity().getName();\n    }\n\n    o[ACTIVITY_CLASS] = achOrig.getActivityObject().getClass().getName();\n    logger.debug(\"======[getDetails][ACTIVITY_CLASS][\" + o[ACTIVITY_CLASS] + \"]\");\n    // Date d = new Date(ac.getLastAccessTime());\n    // o[LAST_ACCESS_TIME] = d;\n    o[LAST_ACCESS_TIME] = ac.getLastAccessTime() + \"\";\n    logger.debug(\n        \"======[getDetails][LAST_ACCESS_TIME][\"\n            + o[LAST_ACCESS_TIME]\n            + \"][\"\n            + new Date(Long.parseLong((String) o[LAST_ACCESS_TIME]))\n            + \"]\");\n\n    Set<SbbEntityID> sbbAttachmentSet = ac.getSbbAttachmentSet();\n    String[] tmp = new String[sbbAttachmentSet.size()];\n    Iterator<?> it = sbbAttachmentSet.iterator();\n    int counter = 0;\n    while (it.hasNext()) {\n      tmp[counter++] = it.next().toString();\n    }\n    o[SBB_ATTACHMENTS] = tmp;\n\n    Set<String> nameBindindsSet = ac.getNamingBindings();\n    tmp = new String[nameBindindsSet.size()];\n    tmp = nameBindindsSet.toArray(tmp);\n    o[NAMES_BOUND_TO] = tmp;\n\n    Set<TimerID> attachedTimersSet = ac.getAttachedTimers();\n    tmp = new String[attachedTimersSet.size()];\n    it = attachedTimersSet.iterator();\n    counter = 0;\n    while (it.hasNext()) {\n      tmp[counter++] = ((TimerID) it.next()).toString();\n    }\n    o[TIMERS_ATTACHED] = tmp;\n\n    Map m = ac.getDataAttributes();\n    tmp = new String[m.size()];\n    it = m.keySet().iterator();\n    counter = 0;\n    while (it.hasNext()) {\n      Object k = it.next();\n      Object v = m.get(k);\n      tmp[counter++] = k + \"=\" + v;\n    }\n    o[DATA_PROPERTIES] = tmp;\n\n    return o;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5495, "initialization": ["Object key = getIndex()"], "initializationStart": [122], "initializationEnd": [132], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 432, "focalAPIEnd": 446, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dragonballs/killard/tree/master/server/src/parser/com/killard/board/parser/ArrayCall.java", "rawCode": "  public Object execute(Context context) throws ExecutionException {\n    Object owner = context.pop();\n    Object index = getIndex().execute(context);\n    if (owner.getClass().isArray()) {\n      return Array.get(owner, toInteger(index));\n    } else if (owner instanceof List) {\n      List list = (List) owner;\n      return list.get(toInteger(index));\n    } else if (owner instanceof Map) {\n      Map map = (Map) owner;\n      return map.get(index);\n    }\n    return null;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5496, "initialization": ["Object key = getAdapter(*)", "Map map = new IdentityHashMap()"], "initializationStart": [177, 259], "initializationEnd": [212, 280], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.put(IElementType,*)", "map.put(IElementType,*)", "map.put(IElementType,*)", "map.put(IElementType,*)", "map.put(IElementType,*)", "map.put(IElementType,*)", "map.put(IElementType,*)", "map.put(IElementType,*)", "map.put(IElementType,*)"], "configurationStart": [289, 355, 425, 501, 573, 653, 742, 826, 910], "configurationEnd": [346, 416, 492, 564, 644, 733, 817, 901, 985], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 1020, "focalAPIEnd": 1038, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/gmf-tooling/tree/master/examples/org.eclipse.gmf.examples.mindmap.rcp.diagram/src/org/eclipse/gmf/examples/mindmap/rcp/diagram/providers/MindmapElementTypes.java", "rawCode": "  /**\n   * Returns 'type' of the ecore object associated with the hint.\n   *\n   * @generated\n   */\n  public static ENamedElement getElement(IAdaptable hint) {\n    Object type = hint.getAdapter(IElementType.class);\n    if (elements == null) {\n      elements = new IdentityHashMap();\n\n      elements.put(Map_1000, MindmapPackage.eINSTANCE.getMap());\n\n      elements.put(Topic_2001, MindmapPackage.eINSTANCE.getTopic());\n\n      elements.put(Resource_2002, MindmapPackage.eINSTANCE.getResource());\n\n      elements.put(Thread_3001, MindmapPackage.eINSTANCE.getThread());\n\n      elements.put(ThreadItem_3002, MindmapPackage.eINSTANCE.getThreadItem());\n\n      elements.put(TopicSubtopics_4001, MindmapPackage.eINSTANCE.getTopic_Subtopics());\n\n      elements.put(Relationship_4002, MindmapPackage.eINSTANCE.getRelationship());\n\n      elements.put(Relationship_4003, MindmapPackage.eINSTANCE.getRelationship());\n\n      elements.put(Relationship_4004, MindmapPackage.eINSTANCE.getRelationship());\n    }\n    return (ENamedElement) elements.get(type);\n  }\n"}, {"dataset": "mapGet", "exampleID": 5497, "initialization": ["Map map = Definition.getPortTypes()", "Object key = Iterator.next()"], "initializationStart": [1688, 1809], "initializationEnd": [1706, 1818], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 223, "tryExpressionEnd": 227, "tryBlockStart": 223, "tryBlockEnd": 2051, "catchExpressionStart": 1997, "catchExpressionEnd": 2017, "catchBlockStart": 1997, "catchBlockEnd": 2051, "exceptionHandlingCallStart": [2025], "exceptionHandlingCallEnd": [2044], "configuration": ["map.keySet()"], "configurationStart": [1730], "configurationEnd": [1744], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 1843, "focalAPIEnd": 1855, "followUpCheck": "value instanceof PortType", "checkType": "IF", "followUpCheckExpressionStart": 1867, "followUpCheckExpressionEnd": 1895, "followUpCheckBlockStart": 1867, "followUpCheckBlockEnd": 1972, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/auxgroup-sanxing/Sesame/tree/master/sesame-studio/src/main/java/com/sanxing/studio/search/WSDLParser.java", "rawCode": "  public RecordCollector getWSDLRecords(File file) {\n    logger.debug(\"generate index for WSDL file \" + file.getAbsolutePath());\n    Definition definition = getDefinition(file);\n    RecordCollector recCollector = null;\n    try {\n      boolean hasImport = false;\n      if (definition.getImports().size() > 0) {\n        hasImport = true;\n      }\n      recCollector = new RecordCollector();\n\n      WSDLMerge wsdlMerge = new WSDLMerge();\n      Definition def = wsdlMerge.merge(definition);\n\n      loadSchemas(def);\n\n      String serviceUnitDesc = null;\n      if (def.getDocumentationElement() != null) {\n        serviceUnitDesc = def.getDocumentationElement().getTextContent();\n      }\n\n      Map services = def.getServices();\n      ServiceRecord srec;\n      if (services.size() > 0) {\n        for (Service service : (Collection<Service>) services.values()) {\n          logger.debug(\"service name: \" + service.getQName());\n\n          srec = new ServiceRecord(service, serviceUnitDesc);\n\n          recCollector.addRecord(srec);\n\n          Map ports = service.getPorts();\n          for (Port port : (Collection<Port>) ports.values()) {\n            Binding binding = port.getBinding();\n            PortType type = binding.getPortType();\n\n            InterfaceRecord intrec = new InterfaceRecord(port, binding, type);\n\n            recCollector.addRecord(intrec, srec);\n\n            if (hasImport) {\n              logger.debug(\"It's proxy service built from engine service!\");\n            }\n\n            portTypeIndex(type, intrec, recCollector);\n          }\n        }\n      } else {\n        srec = new ServiceRecord(\"\", serviceUnitDesc);\n        recCollector.addRecord(srec);\n        Map types = def.getPortTypes();\n        Iterator it = types.keySet().iterator();\n        while (it.hasNext()) {\n          Object o = it.next();\n          Object obj = types.get(o);\n          if (obj instanceof PortType) {\n            portTypeIndex((PortType) obj, srec, recCollector);\n          }\n        }\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n    return recCollector;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5498, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 219, "focalAPIEnd": 232, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/atgreen/moxiedev/tree/master/gcc/libjava/classpath/gnu/CORBA/CDR/gnuRuntime.java", "rawCode": "  /**\n   * Check if the object is already written.\n   *\n   * @return the position, at that the object is allready written or -1 if it is not yet written.\n   */\n  public int idWrittenAt(Object x) {\n    Entry e = (Entry) sh_ids.get(x);\n    return e == null ? -1 : e.at;\n  }\n"}, {"dataset": "mapGet", "exampleID": 5499, "initialization": ["Object key = Iterator.next()"], "initializationStart": [654], "initializationEnd": [672], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["map.keySet()"], "configurationStart": [471], "configurationEnd": [483], "guardCondition": "!(map==null)", "guardType": "IF {", "guardExpressionStart": 372, "guardExpressionEnd": 388, "guardBlockStart": 372, "guardBlockEnd": 797, "focalAPI": "value = map.get(key)", "focalAPIStart": 690, "focalAPIEnd": 702, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Properties.put(Object,value)"], "useStart": [712], "useEnd": [747], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/czarneckid/blojsom-sourceforge/tree/master/branches/blojsom-2_26-final/blojsom-2.0/src/org/blojsom/util/BlojsomUtils.java", "rawCode": "  /**\n   * Convert a {@link Map} to a {@link BlojsomProperties}. If the map is <code>null</code> an empty\n   * {@link BlojsomProperties} object is returned.\n   *\n   * @param map {@link Map}\n   * @return {@link BlojsomProperties} object containing keys and values from the map\n   * @since blojsom 2.23\n   */\n  public static Properties mapToBlojsomProperties(Map map) {\n    if (map == null) {\n      return new BlojsomProperties();\n    } else {\n      Iterator keyIterator = map.keySet().iterator();\n      Object key;\n      Object value;\n      Properties convertedProperties = new BlojsomProperties(true);\n      while (keyIterator.hasNext()) {\n        key = keyIterator.next();\n        value = map.get(key);\n        convertedProperties.put(key, value);\n      }\n\n      return convertedProperties;\n    }\n  }\n"}, {"dataset": "mapGet", "exampleID": 5500, "initialization": ["Object key = Iterator.next()"], "initializationStart": [543], "initializationEnd": [554], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new JSONException(*)"], "tryExpressionStart": 327, "tryExpressionEnd": 331, "tryBlockStart": 327, "tryBlockEnd": 1091, "catchExpressionStart": 1012, "catchExpressionEnd": 1042, "catchBlockStart": 1012, "catchBlockEnd": 1091, "exceptionHandlingCallStart": [1056], "exceptionHandlingCallEnd": [1084], "configuration": ["key.toString()"], "configurationStart": [583], "configurationEnd": [597], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "value = map.get(key)", "focalAPIStart": 651, "focalAPIEnd": 668, "followUpCheck": "value instanceof JSONObject", "checkType": "IF", "followUpCheckExpressionStart": 678, "followUpCheckExpressionEnd": 710, "followUpCheckBlockStart": 678, "followUpCheckBlockEnd": 925, "use": ["value.write(Writer)", "value.write(Writer)", "valueToString(value)"], "useStart": [723, 818, 893], "useEnd": [757, 851, 913], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yolo-hipster/yolo-hipster/tree/master/weha/tags/wikisym2011-draft/EditHistoryAnalysis/src/org/json/JSONObject.java", "rawCode": "  /**\n   * Write the contents of the JSONObject as JSON text to a writer. For compactness, no whitespace\n   * is added.\n   *\n   * <p>Warning: This method assumes that the data structure is acyclical.\n   *\n   * @return The writer.\n   * @throws JSONException\n   */\n  public Writer write(Writer writer) throws JSONException {\n    try {\n      boolean commanate = false;\n      Iterator keys = this.keys();\n      writer.write('{');\n\n      while (keys.hasNext()) {\n        if (commanate) {\n          writer.write(',');\n        }\n        Object key = keys.next();\n        writer.write(quote(key.toString()));\n        writer.write(':');\n        Object value = this.map.get(key);\n        if (value instanceof JSONObject) {\n          ((JSONObject) value).write(writer);\n        } else if (value instanceof JSONArray) {\n          ((JSONArray) value).write(writer);\n        } else {\n          writer.write(valueToString(value));\n        }\n        commanate = true;\n      }\n      writer.write('}');\n      return writer;\n    } catch (IOException exception) {\n      throw new JSONException(exception);\n    }\n  }\n"}]