[{"dataset": "matcher", "exampleID": 6001, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [1393], "initializationEnd": [1415], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["Editor.getMessage()", "toString()", "e(String,*)"], "tryExpressionStart": 661, "tryExpressionEnd": 665, "tryBlockStart": 661, "tryBlockEnd": 2000, "catchExpressionStart": 1923, "catchExpressionEnd": 1943, "catchBlockStart": 1923, "catchBlockEnd": 2000, "exceptionHandlingCallStart": [1967, 1967, 1951], "exceptionHandlingCallEnd": [1981, 1992, 1993], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 1517, "focalAPIEnd": 1534, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 1544, "followUpCheckExpressionEnd": 1557, "followUpCheckBlockStart": 1544, "followUpCheckBlockEnd": 1907, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yukkigogo/cyberhoodwatch/tree/master/src/com/sociam/android/message/MessageUpAsyncTask.java", "rawCode": "  @Override\n  protected Integer doInBackground(String... params) {\n\n    String user_id = params[0];\n    String user_id_code = params[1];\n    String lat = params[2];\n    String lon = params[3];\n    String date_time = params[4];\n    // Log.e(\"sociam\", \"result??\" + date_time);\n    String message = params[5];\n    String tags = params[6];\n\n    HttpClient client = new DefaultHttpClient();\n    HttpPost hpost = new HttpPost(\"http://sociamvm-yi1g09.ecs.soton.ac.uk/messageupandroid.php\");\n\n    ResponseHandler<String> responseHandler = new BasicResponseHandler();\n    MultipartEntity multipartEntity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n\n    try {\n      multipartEntity.addPart(\"user_id\", new StringBody(user_id));\n      multipartEntity.addPart(\"id_code\", new StringBody(user_id_code));\n      multipartEntity.addPart(\"lat\", new StringBody(lat));\n      multipartEntity.addPart(\"lon\", new StringBody(lon));\n      multipartEntity.addPart(\"date\", new StringBody(date_time));\n      multipartEntity.addPart(\"message\", new StringBody(message));\n      if (tags != \"\") multipartEntity.addPart(\"tags\", new StringBody(tags));\n\n      hpost.setEntity(multipartEntity);\n      String response = client.execute(hpost, responseHandler);\n      Log.v(\"sociam\", \"message response \" + response);\n\n      String[] str = response.split(\"\\n\");\n\n      String match = \"message_id\";\n\n      Pattern p = Pattern.compile(match);\n      for (int i = 0; i < str.length; i++) {\n        // Log.e(\"sociam\",str[i]);\n        Matcher m = p.matcher(str[i]);\n        if (m.find()) {\n          String[] str2 = str[i].split(\",\");\n\n          if (str2[1].equals(\"false\")) {\n            postSuccess = false;\n\n          } else {\n\n            String past_msg = sp.getString(\"message_id\", \"\");\n            Editor e = sp.edit();\n            e.putString(\"message_id\", past_msg + \",\" + str2[1]);\n            e.commit();\n          }\n        }\n      }\n\n    } catch (Exception e) {\n      Log.e(\"sociam\", e.getMessage().toString());\n    }\n\n    return 0;\n  }\n"}, {"dataset": "matcher", "exampleID": 6002, "initialization": ["Pattern pattern = compile(String,*)"], "initializationStart": [202], "initializationEnd": [251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 271, "focalAPIEnd": 288, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.replaceAll(String)"], "useStart": [305], "useEnd": [330], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/EsupPortail/esup-filemanager/tree/master/src/main/java/org/esupportail/portlet/filemanager/services/uri/RegUriManipulateService.java", "rawCode": "  public String manipulate(String uri) {\n    String outUri = \"\";\n    outUri = uri;\n    // we check if the path is a regular expression\n    if (regexp != null && replacement != null) {\n      Pattern p = Pattern.compile(regexp, Pattern.CASE_INSENSITIVE);\n      Matcher m = p.matcher(outUri);\n      outUri = m.replaceAll(replacement);\n    }\n    if (log.isDebugEnabled())\n      log.debug(\"RegUriManipulateService:: input uri :\" + uri + \" -- output uri : \" + outUri);\n\n    return outUri;\n  }\n"}, {"dataset": "matcher", "exampleID": 6003, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null)", "guardType": "IF {", "guardExpressionStart": 55, "guardExpressionEnd": 73, "guardBlockStart": 55, "guardBlockEnd": 86, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 103, "focalAPIEnd": 128, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 134, "followUpCheckExpressionEnd": 147, "followUpCheckBlockStart": 134, "followUpCheckBlockEnd": 189, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jersey/jersey-1.x/tree/master/jersey-core/src/main/java/com/sun/jersey/core/impl/provider/header/CacheControlProvider.java", "rawCode": "  private String quoteIfWhitespace(String value) {\n    if (value == null) return null;\n    Matcher m = WHITESPACE.matcher(value);\n    if (m.find()) {\n      return \"\\\"\" + value + \"\\\"\";\n    }\n    return value;\n  }\n"}, {"dataset": "matcher", "exampleID": 6004, "initialization": ["String input = CharSequence.toString()"], "initializationStart": [154], "initializationEnd": [169], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["input.substring(*)"], "configurationStart": [326], "configurationEnd": [367], "guardCondition": "!(input.startsWith(CONTROL_PREFIX,))", "guardType": "IF {", "guardExpressionStart": 175, "guardExpressionEnd": 213, "guardBlockStart": 175, "guardBlockEnd": 1288, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 564, "focalAPIEnd": 590, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 598, "followUpCheckExpressionEnd": 622, "followUpCheckBlockStart": 598, "followUpCheckBlockEnd": 901, "use": ["match.group(int)", "match.group(int)"], "useStart": [684, 861], "useEnd": [702, 879], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/smarr/caliper/tree/master/caliper/src/main/java/com/google/caliper/bridge/LogMessageParser.java", "rawCode": "  @Override\n  public LogMessage parse(CharSequence text) {\n    // TODO(gak): do this stuff in terms of CharSequence instead of String\n    String string = text.toString();\n    if (string.startsWith(CONTROL_PREFIX)) {\n      ImmutableList<String> parts =\n          ImmutableList.copyOf(\n              CONTROL_TYPE_SPLITTER.split(string.substring(CONTROL_PREFIX.length())));\n      Class<? extends CaliperControlLogMessage> messageType = typeMap.inverse().get(parts.get(0));\n      return gson.fromJson(parts.get(1), messageType);\n    } else {\n      Matcher gcMatcher = GC_PATTERN.matcher(string);\n      if (gcMatcher.matches()) {\n        return new GcLogMessage(\n            \"Full\".equals(gcMatcher.group(1))\n                ? GcLogMessage.Type.FULL\n                : GcLogMessage.Type.INCREMENTAL,\n            ShortDuration.of(BigDecimal.valueOf(Double.parseDouble(gcMatcher.group(2))), SECONDS));\n      }\n      Matcher jitMatcher = JIT_PATTERN.matcher(string);\n      if (jitMatcher.matches()) {\n        return new HotspotLogMessage();\n      }\n      Matcher vmOptionMatcher = VM_OPTION_PATTERN.matcher(string);\n      if (vmOptionMatcher.matches()) {\n        return new VmOptionLogMessage(vmOptionMatcher.group(2), vmOptionMatcher.group(3));\n      }\n      return new GenericLogMessage();\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6005, "initialization": ["Pattern pattern = compile(String,*)"], "initializationStart": [319], "initializationEnd": [386], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 530, "focalAPIEnd": 573, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 579, "followUpCheckExpressionEnd": 603, "followUpCheckBlockStart": 579, "followUpCheckBlockEnd": 1055, "use": ["match.group(int)"], "useStart": [645], "useEnd": [666], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/epabst/sonar-plugins/tree/master/dotnet/tools/dotnet-tools-commons/src/main/java/org/sonar/dotnet/tools/commons/visualstudio/ModelFactory.java", "rawCode": "  private static List<String> getBuildConfigurations(String solutionContent) {\n    // A pattern to extract the build configurations from a visual studio solution\n    String confExtractExp =\n        \"(\\tGlobalSection\\\\(SolutionConfigurationPlatforms\\\\).*?^\\tEndGlobalSection$)\";\n    Pattern confExtractPattern =\n        Pattern.compile(confExtractExp, Pattern.MULTILINE + Pattern.DOTALL);\n    List<String> buildConfigurations = new ArrayList<String>();\n    // Extracts all the projects from the solution\n    Matcher blockMatcher = confExtractPattern.matcher(solutionContent);\n    if (blockMatcher.find()) {\n      String buildConfigurationBlock = blockMatcher.group(1);\n      String buildConfExtractExp = \" = (.*)\\\\|\";\n      Pattern buildConfExtractPattern = Pattern.compile(buildConfExtractExp);\n      Matcher buildConfMatcher = buildConfExtractPattern.matcher(buildConfigurationBlock);\n      while (buildConfMatcher.find()) {\n        String buildConfiguration = buildConfMatcher.group(1);\n        buildConfigurations.add(buildConfiguration);\n      }\n    }\n    return buildConfigurations;\n  }\n"}, {"dataset": "matcher", "exampleID": 6006, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [82], "initializationEnd": [110], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 128, "focalAPIEnd": 147, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 153, "followUpCheckExpressionEnd": 169, "followUpCheckBlockStart": 153, "followUpCheckBlockEnd": 361, "use": ["match.group(int)"], "useStart": [205], "useEnd": [215], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/weissjeffm/webui-framework/tree/master/src/com/redhat/qe/auto/selenium/CombinedLocatorTemplate.java", "rawCode": "  protected static String increment(int count, String template) {\n    Pattern p = Pattern.compile(\"\\\\$(\\\\d+)\");\n    Matcher m = p.matcher(template);\n    while (m.find()) {\n      int num = Integer.parseInt(m.group(1));\n      int newNum = num + count;\n      template = template.replaceAll(\"\\\\$\" + num, \"\\\\$\" + newNum);\n      // System.out.println(template);\n    }\n    return template;\n  }\n"}, {"dataset": "matcher", "exampleID": 6007, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 60, "focalAPIEnd": 87, "followUpCheck": "match.find() == false", "checkType": "IF", "followUpCheckExpressionStart": 93, "followUpCheckExpressionEnd": 115, "followUpCheckBlockStart": 93, "followUpCheckBlockEnd": 139, "use": ["match.group(int)"], "useStart": [168], "useEnd": [178], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7931/src/net/sourceforge/plantuml/graphic/Img.java", "rawCode": "  static int getVspace(String html) {\n    final Matcher m = vspacePattern.matcher(html);\n    if (m.find() == false) {\n      return 0;\n    }\n    return Integer.parseInt(m.group(1));\n  }\n"}, {"dataset": "matcher", "exampleID": 6008, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 267, "focalAPIEnd": 297, "followUpCheck": "match != null", "checkType": "IF", "followUpCheckExpressionStart": 399, "followUpCheckExpressionEnd": 416, "followUpCheckBlockStart": 399, "followUpCheckBlockEnd": 1134, "use": ["Pattern.matcher(match)", "Matcher.reset(match)", "match.substring(int,*)", "match.substring(int)"], "useStart": [474, 593, 784, 978], "useEnd": [500, 606, 816, 1001], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/KNL-945/kernel-impl/src/main/java/org/sakaiproject/util/impl/FormattedTextImpl.java", "rawCode": "  private String processHtml(final String source, StringBuilder errorMessages) {\n    if (M_evilTags == null) init();\n\n    // normalize all variants of the \"<br>\" HTML tag to be \"<br />\\n\"\n    // TODO call a method to do this in each process routine\n    String Html = M_patternTagBr.matcher(source).replaceAll(\"<br />\");\n\n    // process text and tags\n    StringBuilder buf = new StringBuilder();\n    if (Html != null) {\n      try {\n        int start = 0;\n        Matcher m = M_patternTag.matcher(Html);\n\n        // if there are no tags, return as is\n        if (!m.find()) return Html;\n        m.reset(Html);\n\n        // if there are tags, make sure they are safe\n        while (m.find()) {\n          // append text that isn't part of a tag\n          if (m.start() > start) buf.append(Html.substring(start, m.start()));\n          start = m.end();\n\n          buf.append(checkTag(m.group(), errorMessages));\n        }\n\n        // tail\n        if (Html.length() > start) buf.append(Html.substring((start)));\n      } catch (Exception e) {\n        M_log.warn(\"FormattedText.processEscapedHtml M_patternTag.matcher(Html):\", e);\n      }\n    }\n    return String.valueOf(buf.toString());\n  }\n"}, {"dataset": "matcher", "exampleID": 6009, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 98, "focalAPIEnd": 119, "followUpCheck": "match.find() == false", "checkType": "IF", "followUpCheckExpressionStart": 125, "followUpCheckExpressionEnd": 147, "followUpCheckBlockStart": 125, "followUpCheckBlockEnd": 174, "use": ["match.group(int)"], "useStart": [297], "useEnd": [307], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7876/src/net/sourceforge/plantuml/StringUtils.java", "rawCode": "  public static final List<String> getSplit(Pattern pattern, String line) {\n    final Matcher m = pattern.matcher(line);\n    if (m.find() == false) {\n      return null;\n    }\n    final List<String> result = new ArrayList<String>();\n    for (int i = 1; i <= m.groupCount(); i++) {\n      result.add(m.group(i));\n    }\n    return result;\n  }\n"}, {"dataset": "matcher", "exampleID": 6010, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [439], "initializationEnd": [469], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 480, "focalAPIEnd": 498, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 504, "followUpCheckExpressionEnd": 518, "followUpCheckBlockStart": 504, "followUpCheckBlockEnd": 654, "use": ["match.start()"], "useStart": [568], "useEnd": [578], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Jelb/First-Year-Project-Group-5/tree/master/src/addressParser_2/AdresParser.java", "rawCode": "  /**\n   * Is used to search for building letters. If a building letter is found, it will be stored in the\n   * result array and then errased from the INPUT string. <br>\n   * After checking for the building letter the INPUT string is spiltted and each part is placed in\n   * the corresponding array index.\n   */\n  private void buildingLetter() {\n    sub[0] = sub[0].replaceAll(SAL, \"\");\n    sub[0] = sub[0].replaceAll(ETAGE, \"\");\n    p1 = Pattern.compile(\"[a-lA-L]{1}\");\n    m1 = p1.matcher(sub[0]);\n    if (m1.find()) { // CHECK 22\n      result[2] = sub[0].substring(m1.start(), m1.end());\n      sub[0] = sub[0].replaceFirst(result[2], \"\").trim();\n    }\n    sub = sub[0].trim().split(\" \");\n    if (sub.length == 1) { // CHECK 23\n      result[1] = sub[0];\n    } else if (sub.length == 2) { // CHECK 24\n      result[1] = sub[0];\n      result[3] = sub[1];\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6011, "initialization": ["String input = formatAccordingToFormats(String,List<NumberFormat>,PhoneNumberFormat,String)"], "initializationStart": [688], "initializationEnd": [765], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 852, "focalAPIEnd": 902, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/google-libphonenumber-mirror/tree/master/tags/libphonenumber-4.3/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java", "rawCode": "  private String formatNationalNumber(\n      String number, String regionCode, PhoneNumberFormat numberFormat, String carrierCode) {\n    PhoneMetadata metadata = getMetadataForRegion(regionCode);\n    List<NumberFormat> intlNumberFormats = metadata.intlNumberFormats();\n    // When the intlNumberFormats exists, we use that to format national number for the\n    // INTERNATIONAL format instead of using the numberDesc.numberFormats.\n    List<NumberFormat> availableFormats =\n        (intlNumberFormats.size() == 0 || numberFormat == PhoneNumberFormat.NATIONAL)\n            ? metadata.numberFormats()\n            : metadata.intlNumberFormats();\n    String formattedNationalNumber =\n        formatAccordingToFormats(number, availableFormats, numberFormat, carrierCode);\n    if (numberFormat == PhoneNumberFormat.RFC3966) {\n      formattedNationalNumber = SEPARATOR_PATTERN.matcher(formattedNationalNumber).replaceAll(\"-\");\n    }\n    return formattedNationalNumber;\n  }\n"}, {"dataset": "matcher", "exampleID": 6012, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [148], "initializationEnd": [254], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 272, "focalAPIEnd": 288, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.find()", "match.group()"], "useStart": [305, 333], "useEnd": [313, 342], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thesmith/eventhorizon/tree/master/src/test/java/thesmith/eventhorizon/service/SocialGraphApiServiceImplTest.java", "rawCode": "  @Test\n  public void shouldReplaceLink() throws Exception {\n    String tweet = \"Panic Status Board: http://bit.ly/aTs0uZ\";\n    Pattern p =\n        Pattern.compile(\n            \"\\\\b(https?|ftp|file)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]\");\n    Matcher m = p.matcher(tweet);\n    assertTrue(m.find());\n    String url = m.group();\n    int start = tweet.indexOf(url);\n    String replacement = String.format(\"<a href='%s'>%s</a>\", url, url);\n    String beginning = tweet.substring(0, start);\n    String end = tweet.substring(start + url.length());\n    tweet = beginning + replacement + end;\n\n    System.err.println(tweet);\n    assertTrue(tweet.contains(\"<a href\"));\n  }\n"}, {"dataset": "matcher", "exampleID": 6013, "initialization": ["String input = Subfield.getValue()", "Pattern pattern = Pattern.compile(String)"], "initializationStart": [90, 121], "initializationEnd": [103, 144], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 162, "focalAPIEnd": 178, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.replaceAll(String)"], "useStart": [202], "useEnd": [218], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/europeana/contrib/tree/master/repox2/repoxCore/branches/repoxCore_1.0/src/main/java/pt/utl/ist/marc/util/RemovePontuationFromAuthorityVisitor.java", "rawCode": "  protected static void removePontuation(Subfield sf, String regExp) {\n    String value = sf.getValue();\n    Pattern p = Pattern.compile(regExp);\n    Matcher m = p.matcher(value);\n    String newValue = m.replaceAll(\"\");\n    sf.setValue(newValue);\n  }\n"}, {"dataset": "matcher", "exampleID": 6014, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [586], "initializationEnd": [652], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 723, "focalAPIEnd": 748, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/moravianlibrary/xcncip2toolkit/tree/master/connectors/voyager/7.2/tags/1.1/src/main/java/org/extensiblecatalog/ncip/v2/voyager/util/RegexUtils.java", "rawCode": "  /**\n   * Given a String, returns a String identical to the provided String except that all regex special\n   * characters will be escaped for use in regular expressions.\n   *\n   * <p>For example, this method will return \"\\(hi\\)\" on input \"(hi)\"\n   *\n   * @param escapeMe The string to escape\n   * @return The escaped string\n   */\n  public String escapeRegexSpecialChars(String escapeMe) {\n    if (log.isDebugEnabled())\n      log.debug(\"Entering escapeRegexSpecialChars for the String: \" + escapeMe);\n\n    // Returns a pattern which matches all special characters\n    Pattern escaper = Pattern.compile(\"([\\\\(\\\\)\\\\.\\\\$\\\\^\\\\{\\\\}\\\\[\\\\]\\\\|\\\\*\\\\+\\\\?\\\\\\\\])\");\n\n    // Escape the special characters and return\n    String result = escaper.matcher(escapeMe).replaceAll(\"\\\\\\\\$1\");\n\n    if (log.isDebugEnabled()) log.debug(\"The escaped String is: \" + result);\n\n    return result;\n  }\n"}, {"dataset": "matcher", "exampleID": 6015, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null||input.length()==0)", "guardType": "IF {", "guardExpressionStart": 1077, "guardExpressionEnd": 1114, "guardBlockStart": 1077, "guardBlockEnd": 1126, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 1245, "focalAPIEnd": 1272, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["trimFormattedText(match,*,StringBuilder)"], "useStart": [1877], "useEnd": [1923], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.2/kernel-util/src/main/java/org/sakaiproject/util/FormattedText.java", "rawCode": "  /**\n   * Processes and validates HTML formatted text received from the web browser (from the WYSIWYG\n   * editor). Validates that the user input follows the Sakai formatted text specification; can\n   * disallow dangerous stuff such as &lt;SCRIPT&gt; JavaScript tags. Encodes the text according to\n   * the formatted text specification, for the rest of the system to use.\n   *\n   * @param strFromBrowser The formatted text as sent from the web browser (from the WYSIWYG editor)\n   * @param errorMessages User-readable error messages will be returned here.\n   * @param checkForEvilTags If true, check for tags and attributes that shouldn't be in formatted\n   *     text\n   * @param replaceWhitespaceTags If true, clean up line breaks to be like \"&lt;br /&gt;\".\n   * @return The validated processed HTML formatted text, ready for use by the system.\n   */\n  public static String processFormattedText(\n      final String strFromBrowser,\n      StringBuilder errorMessages,\n      boolean checkForEvilTags,\n      boolean replaceWhitespaceTags) {\n    String val = strFromBrowser;\n    if (val == null || val.length() == 0) return val;\n\n    if (replaceWhitespaceTags) {\n      // normalize all variants of the \"<br>\" HTML tag to be \"<br />\\n\"\n      val = M_patternTagBr.matcher(val).replaceAll(\"<br />\");\n\n      // replace \"<p>\" with nothing. Replace \"</p>\" and \"<p />\" HTML tags with \"<br />\"\n      // val = val.replaceAll(\"<p>\", \"\");\n      // val = val.replaceAll(\"</p>\", \"<br />\\n\");\n      // val = val.replaceAll(\"<p />\", \"<br />\\n\");\n    }\n\n    if (checkForEvilTags) {\n      val = processHtml(strFromBrowser, errorMessages);\n    }\n\n    // deal with hardcoded empty space character from Firefox 1.5\n    if (val.equals(\"&nbsp;\")) {\n      val = \"\";\n    }\n\n    // close any open HTML tags (that the user may have accidentally left open)\n    StringBuilder buf = new StringBuilder();\n    trimFormattedText(val, Integer.MAX_VALUE, buf);\n    val = buf.toString();\n\n    // TODO: Fully parse and validate the formatted text against\n    // the formatted text specification. Perhaps this could be\n    // done by treating the text as an XML document and validating\n    // the XML document against a Document-Type-Definition (DTD) for\n    // formatted text. This would allow for validating the\n    // attributes of allowed tags, for example.\n\n    return val;\n  }\n"}, {"dataset": "matcher", "exampleID": 6016, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [173], "initializationEnd": [224], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 242, "focalAPIEnd": 258, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.find()", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)"], "useStart": [332, 383, 414, 443, 469], "useEnd": [340, 393, 424, 453, 479], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CS340Group/hit/tree/master/src/common/util/QueryParser.java", "rawCode": "  /**\n   * Helper method to parse out the required fields in the query. Expects the query to look like:\n   * obj.attr = value\n   */\n  private void Parse() {\n    Pattern p = Pattern.compile(\"((\\\\w*)\\\\.)?(\\\\w*)\\\\s(.*)\\\\s(.*)\");\n    Matcher m = p.matcher(query);\n    OperatorFactory c = new OperatorFactory();\n    boolean matchFound = m.find();\n    if (matchFound) {\n      objectName = m.group(2);\n      objectAttr = m.group(3);\n      operator = m.group(4);\n      value = m.group(5);\n    } else {\n      // If match isn't found then the query is in the wrong form.\n      assert (matchFound == true);\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6017, "initialization": ["String input = NumberFormat.getPattern()"], "initializationStart": [93], "initializationEnd": [112], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "bitwise", "guardType": "IF {", "guardExpressionStart": 255, "guardExpressionEnd": 292, "guardBlockStart": 255, "guardBlockEnd": 320, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 394, "focalAPIEnd": 440, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Pattern.matcher(match)", "getFormattingTemplate(match,*)"], "useStart": [548, 680], "useEnd": [595, 736], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/google-libphonenumber-mirror/tree/master/tags/libphonenumber-6.2.2/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java", "rawCode": "  private boolean createFormattingTemplate(NumberFormat format) {\n    String numberPattern = format.getPattern();\n\n    // The formatter doesn't format numbers when numberPattern contains \"|\", e.g.\n    // (20|3)\\d{4}. In those cases we quickly return.\n    if (numberPattern.indexOf('|') != -1) {\n      return false;\n    }\n\n    // Replace anything in the form of [..] with \\d\n    numberPattern = CHARACTER_CLASS_PATTERN.matcher(numberPattern).replaceAll(\"\\\\\\\\d\");\n\n    // Replace any standalone digit (not the one in d{}) with \\d\n    numberPattern = STANDALONE_DIGIT_PATTERN.matcher(numberPattern).replaceAll(\"\\\\\\\\d\");\n    formattingTemplate.setLength(0);\n    String tempTemplate = getFormattingTemplate(numberPattern, format.getFormat());\n    if (tempTemplate.length() > 0) {\n      formattingTemplate.append(tempTemplate);\n      return true;\n    }\n    return false;\n  }\n"}, {"dataset": "matcher", "exampleID": 6018, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 159, "focalAPIEnd": 181, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.replaceAll(String)"], "useStart": [159], "useEnd": [201], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/blackdrag/jarjar/tree/master/jarjar/src/main/com/tonicsystems/jarjar/Wildcard.java", "rawCode": "  private static String replaceAllLiteral(Pattern pattern, String value, String replace) {\n    replace = replace.replaceAll(\"([$\\\\\\\\])\", \"\\\\\\\\$0\");\n    return pattern.matcher(value).replaceAll(replace);\n  }\n"}, {"dataset": "matcher", "exampleID": 6019, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "MalformedCtxIdentifierException", "exceptionHandlingCall": ["getLocalizedMessage()", "error(String,*)"], "tryExpressionStart": 407, "tryExpressionEnd": 411, "tryBlockStart": 407, "tryBlockEnd": 1796, "catchExpressionStart": 1581, "catchExpressionEnd": 1626, "catchBlockStart": 1581, "catchBlockEnd": 1796, "exceptionHandlingCallStart": [1742, 1637], "exceptionHandlingCallEnd": [1768, 1787], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null)", "guardType": "IF {", "guardExpressionStart": 421, "guardExpressionEnd": 440, "guardBlockStart": 421, "guardBlockEnd": 543, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 646, "focalAPIEnd": 680, "followUpCheck": "!match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 690, "followUpCheckExpressionEnd": 719, "followUpCheckBlockStart": 690, "followUpCheckBlockEnd": 868, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/societies/SOCIETIES-Platform/tree/master/context-management/context-event-mgmt/src/main/java/org/societies/context/event/impl/CtxEventMgr.java", "rawCode": "    @Override\n    public void pubsubEvent(IIdentity pubsubService, String node, String itemId, Object payload) {\n\n      if (LOG.isDebugEnabled())\n        LOG.debug(\n            \"pubsubEvent:pubsubService=\"\n                + pubsubService\n                + \",node=\"\n                + node\n                + \",itemId=\"\n                + itemId\n                + \",payload=\"\n                + payload);\n\n      try {\n        if (itemId == null) {\n          LOG.error(\"Remote context change event itemId can't be null\");\n          return;\n        }\n\n        // Check if itemId, i.e. ctxId, matches against filter\n        final Matcher filterMatcher = this.patternFilter.matcher(itemId);\n        if (!filterMatcher.matches()) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Ignoring remote context change event for ctxId \" + itemId);\n          return;\n        }\n\n        final CtxIdentifier ctxId = CtxIdentifierFactory.getInstance().fromString(itemId);\n        final CtxChangeEvent ctxChangeEvent = new CtxChangeEvent(ctxId);\n        final String topic = node;\n        if (CtxChangeEventTopic.CREATED.equals(topic)) this.listener.onCreation(ctxChangeEvent);\n        else if (CtxChangeEventTopic.UPDATED.equals(topic)) this.listener.onUpdate(ctxChangeEvent);\n        else if (CtxChangeEventTopic.MODIFIED.equals(topic))\n          this.listener.onModification(ctxChangeEvent);\n        else if (CtxChangeEventTopic.REMOVED.equals(topic)) this.listener.onRemoval(ctxChangeEvent);\n        else LOG.error(\"Unexpected remote context change event topic: '\" + topic + \"'\");\n      } catch (MalformedCtxIdentifierException mcie) {\n\n        LOG.error(\n            \"Malformed context identifier in remote context change event: \"\n                + mcie.getLocalizedMessage(),\n            mcie);\n      }\n    }\n"}, {"dataset": "matcher", "exampleID": 6020, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 274, "focalAPIEnd": 304, "followUpCheck": "match != null", "checkType": "IF", "followUpCheckExpressionStart": 406, "followUpCheckExpressionEnd": 423, "followUpCheckBlockStart": 406, "followUpCheckBlockEnd": 1141, "use": ["Pattern.matcher(match)", "Matcher.reset(match)", "match.substring(int,*)", "match.substring(int)"], "useStart": [481, 600, 791, 985], "useEnd": [507, 613, 823, 1008], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.7/kernel-util/src/main/java/org/sakaiproject/util/FormattedText.java", "rawCode": "  private static String processHtml(final String source, StringBuilder errorMessages) {\n    if (M_evilTags == null) init();\n\n    // normalize all variants of the \"<br>\" HTML tag to be \"<br />\\n\"\n    // TODO call a method to do this in each process routine\n    String Html = M_patternTagBr.matcher(source).replaceAll(\"<br />\");\n\n    // process text and tags\n    StringBuilder buf = new StringBuilder();\n    if (Html != null) {\n      try {\n        int start = 0;\n        Matcher m = M_patternTag.matcher(Html);\n\n        // if there are no tags, return as is\n        if (!m.find()) return Html;\n        m.reset(Html);\n\n        // if there are tags, make sure they are safe\n        while (m.find()) {\n          // append text that isn't part of a tag\n          if (m.start() > start) buf.append(Html.substring(start, m.start()));\n          start = m.end();\n\n          buf.append(checkTag(m.group(), errorMessages));\n        }\n\n        // tail\n        if (Html.length() > start) buf.append(Html.substring((start)));\n      } catch (Exception e) {\n        M_log.warn(\"FormattedText.processEscapedHtml M_patternTag.matcher(Html):\", e);\n      }\n    }\n    return String.valueOf(buf.toString());\n  }\n"}, {"dataset": "matcher", "exampleID": 6021, "initialization": ["String input = Text.getData()", "Pattern pattern = compile(*,*)"], "initializationStart": [169, 321], "initializationEnd": [180, 381], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(true||input.indexOf(sBorder,)==-1)", "guardType": "IF {", "guardExpressionStart": 186, "guardExpressionEnd": 240, "guardBlockStart": 186, "guardBlockEnd": 248, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 399, "focalAPIEnd": 422, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 428, "followUpCheckExpressionEnd": 444, "followUpCheckBlockStart": 428, "followUpCheckBlockEnd": 1215, "use": ["match.group(int)", "match.appendReplacement(StringBuffer,String)", "match.appendReplacement(StringBuffer,*)", "match.appendReplacement(StringBuffer,String)", "match.appendTail(StringBuffer)"], "useStart": [467, 506, 636, 794, 1220], "useEnd": [477, 544, 691, 827, 1242], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1_9_1/trunk-archive/src/util/xml/XML.java", "rawCode": "  private static void replaceNodeTokens(Text t, String sBorder, Map mReplace) {\n    // Get value and look for tokens. If there aren't any, bail now.\n    String sValue = t.getData();\n    if (mReplace == null || sValue.indexOf(sBorder) == -1) return;\n\n    StringBuffer sbBefore = new StringBuffer();\n\n    Pattern pTokens = Pattern.compile(sBorder + \"(.*?)\" + sBorder, Pattern.DOTALL);\n    Matcher m = pTokens.matcher(sValue);\n    while (m.find()) {\n      String sKey = m.group(1);\n      if (sKey.equals(\"\")) m.appendReplacement(sbBefore, sBorder);\n      else {\n        Node nMatch = (Node) mReplace.get(sKey);\n        if (nMatch == null) m.appendReplacement(sbBefore, sBorder + sKey + sBorder);\n        else {\n          // OK, found a token. Get everything before it into the buffer...\n          m.appendReplacement(sbBefore, \"\");\n          // ...create a new text node with the 'before' text...\n          Text tBefore = t.getOwnerDocument().createTextNode(sbBefore.toString());\n          t.getParentNode().insertBefore(tBefore, t);\n          sbBefore.setLength(0);\n          // ...add the new node...\n          t.getParentNode().insertBefore(t.getOwnerDocument().importNode(nMatch, true), t);\n        }\n      }\n    }\n    m.appendTail(sbBefore);\n    t.setData(sbBefore.toString());\n  }\n"}, {"dataset": "matcher", "exampleID": 6022, "initialization": ["String input = NumberFormat.getPattern()"], "initializationStart": [93], "initializationEnd": [112], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "bitwise", "guardType": "IF {", "guardExpressionStart": 255, "guardExpressionEnd": 292, "guardBlockStart": 255, "guardBlockEnd": 320, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 394, "focalAPIEnd": 440, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Pattern.matcher(match)", "getFormattingTemplate(match,*)"], "useStart": [548, 680], "useEnd": [595, 736], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/google-libphonenumber-mirror/tree/master/tags/libphonenumber-4.5/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java", "rawCode": "  private boolean createFormattingTemplate(NumberFormat format) {\n    String numberPattern = format.getPattern();\n\n    // The formatter doesn't format numbers when numberPattern contains \"|\", e.g.\n    // (20|3)\\d{4}. In those cases we quickly return.\n    if (numberPattern.indexOf('|') != -1) {\n      return false;\n    }\n\n    // Replace anything in the form of [..] with \\d\n    numberPattern = CHARACTER_CLASS_PATTERN.matcher(numberPattern).replaceAll(\"\\\\\\\\d\");\n\n    // Replace any standalone digit (not the one in d{}) with \\d\n    numberPattern = STANDALONE_DIGIT_PATTERN.matcher(numberPattern).replaceAll(\"\\\\\\\\d\");\n    formattingTemplate.setLength(0);\n    String tempTemplate = getFormattingTemplate(numberPattern, format.getFormat());\n    if (tempTemplate.length() > 0) {\n      formattingTemplate.append(tempTemplate);\n      return true;\n    }\n    return false;\n  }\n"}, {"dataset": "matcher", "exampleID": 6023, "initialization": ["String input = valueOf(char)", "String input = normalize(String,*)"], "initializationStart": [364, 516], "initializationEnd": [381, 561], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 575, "focalAPIEnd": 596, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "match.replace(String,String)", "replace(int,*,match)"], "useStart": [720, 754, 788, 821, 854, 888, 922, 955, 988, 1021, 1054, 1087, 1120, 1153, 1186, 1219, 1252, 1285, 1318, 1351, 1384, 1417, 1450, 1483, 1516, 1549, 1582, 1615, 1648, 1681, 1714, 1747, 1780, 1813, 1846, 1879, 1912, 1945, 1978, 2011, 2044, 2077, 2110, 2143, 2176, 2206], "useEnd": [740, 774, 807, 840, 874, 908, 941, 974, 1007, 1040, 1073, 1106, 1139, 1172, 1205, 1238, 1271, 1304, 1337, 1370, 1403, 1436, 1469, 1502, 1535, 1568, 1601, 1634, 1667, 1700, 1733, 1766, 1799, 1832, 1865, 1898, 1931, 1964, 1997, 2030, 2063, 2096, 2129, 2162, 2195, 2233], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/C3C0/GravityBox/tree/master/src/com/ceco/gm2/gravitybox/UnicodeFilter.java", "rawCode": "  public CharSequence filter(CharSequence source) {\n    StringBuilder output = new StringBuilder(source);\n    final int sourceLength = source.length();\n\n    for (int i = 0; i < sourceLength; i++) {\n      char c = source.charAt(i);\n\n      // Character requires Unicode, try to replace it\n      if (!mStripNonDecodableOnly || !gsm.canEncode(c)) {\n        String s = String.valueOf(c);\n\n        // Try normalizing the character into Unicode NFKD form and\n        // stripping out diacritic mark characters.\n        s = Normalizer.normalize(s, Normalizer.Form.NFKD);\n        s = diacritics.matcher(s).replaceAll(\"\");\n\n        // Special case characters that don't get stripped by the\n        // above technique.\n        s = s.replace(\"Œ\", \"OE\");\n        s = s.replace(\"œ\", \"oe\");\n        s = s.replace(\"Ł\", \"L\");\n        s = s.replace(\"ł\", \"l\");\n        s = s.replace(\"Đ\", \"DJ\");\n        s = s.replace(\"đ\", \"dj\");\n        s = s.replace(\"Α\", \"A\");\n        s = s.replace(\"Β\", \"B\");\n        s = s.replace(\"Ε\", \"E\");\n        s = s.replace(\"Ζ\", \"Z\");\n        s = s.replace(\"Η\", \"H\");\n        s = s.replace(\"Ι\", \"I\");\n        s = s.replace(\"Κ\", \"K\");\n        s = s.replace(\"Μ\", \"M\");\n        s = s.replace(\"Ν\", \"N\");\n        s = s.replace(\"Ο\", \"O\");\n        s = s.replace(\"Ρ\", \"P\");\n        s = s.replace(\"Τ\", \"T\");\n        s = s.replace(\"Υ\", \"Y\");\n        s = s.replace(\"Χ\", \"X\");\n        s = s.replace(\"α\", \"A\");\n        s = s.replace(\"β\", \"B\");\n        s = s.replace(\"γ\", \"Γ\");\n        s = s.replace(\"δ\", \"Δ\");\n        s = s.replace(\"ε\", \"E\");\n        s = s.replace(\"ζ\", \"Z\");\n        s = s.replace(\"η\", \"H\");\n        s = s.replace(\"θ\", \"Θ\");\n        s = s.replace(\"ι\", \"I\");\n        s = s.replace(\"κ\", \"K\");\n        s = s.replace(\"λ\", \"Λ\");\n        s = s.replace(\"μ\", \"M\");\n        s = s.replace(\"ν\", \"N\");\n        s = s.replace(\"ξ\", \"Ξ\");\n        s = s.replace(\"ο\", \"O\");\n        s = s.replace(\"π\", \"Π\");\n        s = s.replace(\"ρ\", \"P\");\n        s = s.replace(\"σ\", \"Σ\");\n        s = s.replace(\"τ\", \"T\");\n        s = s.replace(\"υ\", \"Y\");\n        s = s.replace(\"φ\", \"Φ\");\n        s = s.replace(\"χ\", \"X\");\n        s = s.replace(\"ψ\", \"Ψ\");\n        s = s.replace(\"ω\", \"Ω\");\n        s = s.replace(\"ς\", \"Σ\");\n\n        output.replace(i, i + 1, s);\n      }\n    }\n\n    // Source is a spanned string, so copy the spans from it\n    if (source instanceof Spanned) {\n      SpannableString spannedoutput = new SpannableString(output);\n      TextUtils.copySpansFrom((Spanned) source, 0, sourceLength, null, spannedoutput, 0);\n\n      return spannedoutput;\n    }\n\n    // Source is a vanilla charsequence, so return output as-is\n    return output.toString();\n  }\n"}, {"dataset": "matcher", "exampleID": 6024, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 95, "focalAPIEnd": 115, "followUpCheck": "!match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 121, "followUpCheckExpressionEnd": 138, "followUpCheckBlockStart": 121, "followUpCheckBlockEnd": 226, "use": ["match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)"], "useStart": [246, 333, 1251, 1361], "useEnd": [256, 343, 1261, 1371], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/library/main/src/main/java/org/geotools/filter/FunctionImpl.java", "rawCode": "  static Parameter toParameter(String param) throws IllegalArgumentException {\n    Matcher m = PARAM.matcher(param);\n    if (!m.matches()) {\n      throw new IllegalArgumentException(\"Illegal parameter syntax: \" + param);\n    }\n\n    String name = m.group(1);\n    Class type = null;\n    int min = 1;\n    int max = 1;\n\n    String grp = m.group(2);\n    if (\"\".equals(grp)) {\n      grp = null;\n    }\n    if (grp != null) {\n      try {\n        type = Class.forName(grp);\n      } catch (ClassNotFoundException e) {\n        // try prefixing with java.lang\n        try {\n          type = Class.forName(\"java.lang.\" + grp);\n        } catch (ClassNotFoundException e1) {\n          // try prefixing with jts.geom\n          try {\n            type = Class.forName(\"com.vividsolutions.jts.geom.\" + grp);\n          } catch (ClassNotFoundException e2) {\n            // throw back the original\n            throw (IllegalArgumentException)\n                new IllegalArgumentException(\"Unknown type: \" + grp).initCause(e);\n          }\n        }\n      }\n    }\n\n    // recognize some well known names\n    if (type == null) {\n      if (\"geom\".equals(name)) {\n        type = Geometry.class;\n      }\n    }\n\n    if (type == null) {\n      type = Object.class;\n    }\n\n    grp = m.group(3);\n    if (grp != null) {\n      min = !\"\".equals(grp) ? Integer.parseInt(grp) : -1;\n    }\n\n    grp = m.group(4);\n    if (grp != null) {\n      max = !\"\".equals(grp) ? Integer.parseInt(grp) : -1;\n    }\n\n    return new org.geotools.data.Parameter(name, type, min, max);\n  }\n"}, {"dataset": "matcher", "exampleID": 6025, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 59, "focalAPIEnd": 87, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()"], "useStart": [59], "useEnd": [97], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wholeplatform/whole/tree/master/org.whole.langs.legacy/src/org/whole/lang/xml/util/XmlUtils.java", "rawCode": "  public static boolean isQName(String input) {\n    return QNAME_PATTERN.matcher(input).matches();\n  }\n"}, {"dataset": "matcher", "exampleID": 6026, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [151], "initializationEnd": [179], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 199, "focalAPIEnd": 222, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.region(int,int)", "match.matches()", "match.toMatchResult()", "match.toMatchResult()", "match.toMatchResult()", "match.toMatchResult()", "match.toMatchResult()", "match.toMatchResult()", "match.toMatchResult()"], "useStart": [229, 309, 393, 528, 650, 763, 840, 917, 1055], "useEnd": [245, 322, 412, 547, 669, 782, 859, 936, 1074], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/justinsb/android-libcore/tree/master/luni/src/test/java/libcore/java/util/regex/OldMatcherTest.java", "rawCode": "  public void test_toMatchResult() {\n    String testPattern = \"(((abb)a)(bb))\";\n    String testString = \"babbabbcccabbabbabbabbabb\";\n    Pattern pat = Pattern.compile(testPattern);\n    Matcher mat = pat.matcher(testString);\n\n    mat.region(1, 7);\n    assertTrue(\"matcher should find pattern in given region\", mat.matches());\n    assertEquals(\"matched section should start from 1 position\", 1, mat.toMatchResult().start());\n    assertEquals(\n        \"matched section for 2 group should start from 1 position\",\n        1,\n        mat.toMatchResult().start(2));\n    assertEquals(\n        \"matched section for whole pattern should end on 7 position\", 7, mat.toMatchResult().end());\n    assertEquals(\n        \"matched section for 3 group should end at 4 position\", 4, mat.toMatchResult().end(3));\n    assertEquals(\"group not matched\", \"abbabb\", mat.toMatchResult().group());\n    assertEquals(\"3 group not matched\", \"abb\", mat.toMatchResult().group(3));\n    assertEquals(\n        \"Total number of groups does not matched with given pattern\",\n        4,\n        mat.toMatchResult().groupCount());\n  }\n"}, {"dataset": "matcher", "exampleID": 6027, "initialization": ["String input = getCanonicalPath()"], "initializationStart": [437], "initializationEnd": [460], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 495, "focalAPIEnd": 520, "followUpCheck": "match", "checkType": "IF", "followUpCheckExpressionStart": 542, "followUpCheckExpressionEnd": 553, "followUpCheckBlockStart": 542, "followUpCheckBlockEnd": 652, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FinamTrade/bustard/tree/master/bustard-core/src/main/java/ru/finam/bustard/codegen/ClasspathFileRetriever.java", "rawCode": "  private static Collection<String> getResourcesLinesFromDirectory(File directory, Pattern pattern)\n      throws IOException {\n    ArrayList<String> lines = Lists.newArrayList();\n    File[] list = directory.listFiles();\n    if (list != null) {\n      for (final File file : list) {\n        if (file.isDirectory()) {\n          lines.addAll(getResourcesLinesFromDirectory(file, pattern));\n        } else {\n          final String fileName = file.getCanonicalPath();\n          final boolean accept = pattern.matcher(fileName).matches();\n          if (accept) {\n            lines.addAll(Resources.readLines(file.toURI().toURL(), Charsets.UTF_8));\n          }\n        }\n      }\n    }\n    return lines;\n  }\n"}, {"dataset": "matcher", "exampleID": 6028, "initialization": ["Pattern pattern = compile(String,*)"], "initializationStart": [932], "initializationEnd": [980], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 990, "focalAPIEnd": 1008, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 1014, "followUpCheckExpressionEnd": 1027, "followUpCheckBlockStart": 1014, "followUpCheckBlockEnd": 1258, "use": ["pattern.matcher(String)", "match.start()", "match.start()"], "useStart": [1399, 1518, 1575], "useEnd": [1417, 1527, 1584], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olanto/MYCAT/tree/master/prog/TranslationText/src/java/org/olanto/TranslationText/server/TranslateServiceImpl.java", "rawCode": "  @Override\n  public int[][] getHitPosNearCR(\n      String content,\n      ArrayList<String> Query,\n      int queryLn,\n      float reFactor,\n      int sepNumber,\n      int avgTokenLn) {\n    int refLength = (int) (reFactor * (queryLn + sepNumber * avgTokenLn));\n    int startp, lastp;\n    // System.out.println(\"Searching for near on a window of: \" + refLength);\n    ArrayList<Integer> Pos = new ArrayList<>();\n    ArrayList<Integer> PosLn = new ArrayList<>();\n    ArrayList<Integer> startPos = new ArrayList<>();\n    ArrayList<Integer> lastPos = new ArrayList<>();\n    String first, last, regex;\n    Pattern p;\n    Matcher m;\n    startPos.clear();\n    lastPos.clear();\n\n    first = removeBorders(Query.get(0));\n    last = removeBorders(Query.get(Query.size() - 1));\n    System.out.println(\"First: \" + first);\n    System.out.println(\"Last: \" + last);\n    regex = REGEX_BEFORE_TOKEN + Pattern.quote(first) + REGEX_AFTER_TOKEN;\n    p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);\n    m = p.matcher(content);\n    if (m.find()) {\n      // System.out.println(\"start found at : \" + m.start());\n      startPos.add(m.start());\n      while (m.find()) {\n        startPos.add(m.start());\n        // System.out.println(\"Start found at : \" + m.start());\n      }\n    }\n    regex = REGEX_BEFORE_TOKEN + Pattern.quote(last) + REGEX_AFTER_TOKEN;\n    p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);\n    m = p.matcher(content);\n    if (m.find()) {\n      // System.out.println(\"last found at : \" + m.start());\n      lastPos.add(m.start());\n      while (m.find()) {\n        lastPos.add(m.start());\n        // System.out.println(\"last found at : \" + m.start());\n      }\n    }\n    for (int i = 0; i < startPos.size(); i++) {\n      startp = startPos.get(i);\n      for (int k = 0; k < lastPos.size(); k++) {\n        lastp = lastPos.get(k);\n        if ((Math.abs(lastp - startp) >= (queryLn - 6))\n            && (Math.abs(lastp - startp) <= refLength)) {\n          if (lastp > startp) {\n            if (getAllWords(content.substring(startp, lastp + last.length() + 1), Query)) {\n              Pos.add(startp);\n              PosLn.add(lastp + last.length() - startp);\n            }\n          } else {\n            if (getAllWords(content.substring(lastp, startp + first.length() + 1), Query)) {\n              Pos.add(lastp);\n              PosLn.add(startp + first.length() - lastp);\n            }\n          }\n        }\n      }\n    }\n    // for (int i = 0; i < Pos.size(); i++) {\n    // System.out.println(\"Positions found in Line: \" + Pos.get(i));\n    // }\n    return getClosePositions(Pos, PosLn);\n  }\n"}, {"dataset": "matcher", "exampleID": 6029, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [56], "initializationEnd": [78], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 96, "focalAPIEnd": 115, "followUpCheck": "!match.find()", "checkType": "IF", "followUpCheckExpressionStart": 145, "followUpCheckExpressionEnd": 159, "followUpCheckBlockStart": 145, "followUpCheckBlockEnd": 262, "use": ["match.group(int)"], "useStart": [277], "useEnd": [287], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Top-Q/jsystem/tree/master/jsystem-core-projects/jsystemCommon/src/main/java/jsystem/extensions/analyzers/text/GetParameterValue.java", "rawCode": "  public void analyze() {\n    Pattern p = null;\n    p = Pattern.compile(regEx);\n    Matcher m = p.matcher(testText);\n    message = testText;\n    if (!m.find()) {\n      status = false;\n      title = \"GetParameterValue is not found: \" + toFind;\n      return;\n    }\n    counter = m.group(1);\n\n    title = \"Get parameter value: \" + counter;\n    status = true;\n  }\n"}, {"dataset": "matcher", "exampleID": 6030, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 78, "focalAPIEnd": 104, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()"], "useStart": [78], "useEnd": [114], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sgoldfed/error-prone/tree/master/docgen/src/main/java/com/google/errorprone/DocGen.java", "rawCode": "    @Override\n    public boolean accept(File dir, String name) {\n      return matchPattern.matcher(name).matches();\n    }\n"}, {"dataset": "matcher", "exampleID": 6031, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 1030, "focalAPIEnd": 1069, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 1079, "followUpCheckExpressionEnd": 1095, "followUpCheckBlockStart": 1079, "followUpCheckBlockEnd": 1142, "use": ["match.group(int)", "match.group(int)"], "useStart": [1130, 1388], "useEnd": [1140, 1404], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.7.2/trunk/src/om/loadtest/TNTester.java", "rawCode": "  private void sendRequestGetMedia(int iServer, Map mTokens, HttpScript.Item i, StepStats ss)\n      throws IOException {\n    if (DEBUG) System.err.print(\" \" + i.getURL());\n    ss.sPath = i.getURL();\n    long lBefore = System.currentTimeMillis();\n\n    Socket s = new Socket(HOSTS[iServer], PORTS[iServer]);\n    // Again with the dodgy charset assumptions\n    OutputStreamWriter osw = new OutputStreamWriter(s.getOutputStream());\n    String sRequest = i.getRequest();\n    sRequest = XML.replaceTokens(sRequest, \"%%\", mTokens).replaceAll(\"HTTP/1.1\", \"HTTP/1.0\");\n    osw.write(sRequest + \"\\r\\n\");\n    if (i.getData() != null) osw.write(i.getData());\n    osw.flush();\n\n    // Get input\n    InputStream is = s.getInputStream();\n    String sLine = \"\";\n    int iContentLength = -1;\n    boolean bFirst = true;\n    while (true) {\n      int iChar = is.read();\n      if (iChar == -1) throw new IOException(\"Unexpected EOF in socket input\");\n      if (iChar == 10) {\n        if (sLine.equals(\"\")) break; // End of headers\n        Matcher m = HttpScript.CONTENTLENGTH.matcher(sLine);\n        if (m.matches()) iContentLength = Integer.parseInt(m.group(1));\n        if (bFirst) {\n          bFirst = false;\n          Matcher mStatus = HttpScript.STATUSCODE.matcher(sLine);\n          if (!mStatus.matches()) throw new IOException(\"Unexpected HTTP status format: \" + sLine);\n          if (Integer.parseInt(mStatus.group(1)) != i.getExpectedResponse())\n            throw new IOException(\n                \"Unexpected response code: \"\n                    + sLine\n                    + \" (expecting \"\n                    + i.getExpectedResponse()\n                    + \")\\n\"\n                    + IO.loadString(is));\n        }\n        // System.err.println(sLine);\n        sLine = \"\";\n      } else if (iChar != 13) {\n        sLine += (char) iChar;\n      }\n    }\n\n    byte[] abData;\n    if (iContentLength != -1) {\n      abData = new byte[iContentLength];\n      for (int iRead = 0; iRead < abData.length; ) {\n        int iThisTime = is.read(abData, iRead, abData.length - iRead);\n        if (iThisTime == -1) throw new IOException(\"Didn't get all data\");\n        iRead += iThisTime;\n      }\n    } else {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      while (true) {\n        int iRead = is.read();\n        if (iRead == -1) break;\n        baos.write(iRead);\n      }\n      abData = baos.toByteArray();\n    }\n    s.close();\n\n    ss.lTime = System.currentTimeMillis() - lBefore;\n    if (DEBUG) {\n      System.err.print(\" [\" + abData.length + \" bytes]\");\n      System.err.println(\" (\" + ss.lTime + \" ms)\");\n    }\n\n    // OK now go through looking for *.gif, jpg, .css, .png\n    String sContent = new String(abData);\n    Set<String> sDone = new HashSet<String>();\n    Matcher m = MEDIALINK.matcher(sContent);\n    while (m.find()) {\n      String sURL = m.group(1);\n      if (sDone.contains(sURL)) continue;\n      sDone.add(sURL);\n\n      sURL =\n          \"http://\"\n              + HOSTS[iServer]\n              + (PORTS[iServer] != 80 ? (\":\" + PORTS[iServer]) : \"\")\n              + \"/om-tn/simple1/\"\n              + sURL;\n      sURL = sURL.replaceAll(\"simple1/../\", \"\");\n\n      loadMedia(mTokens, new URL(sURL), ss);\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6032, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 63, "focalAPIEnd": 86, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 92, "followUpCheckExpressionEnd": 105, "followUpCheckBlockStart": 92, "followUpCheckBlockEnd": 155, "use": ["match.group(int)"], "useStart": [137], "useEnd": [147], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sages-health/sagesmobile-mReceive/tree/master/rapidjava/org.rapidsms.java/src/org/rapidsms/java/core/parser/interpreter/IntegerInterpreter.java", "rawCode": "  public Object interpretValue(String token) {\n    Matcher m = mPattern.matcher(token);\n    if (m.find()) {\n      return Integer.valueOf(m.group(0));\n    }\n    return null;\n  }\n"}, {"dataset": "matcher", "exampleID": 6033, "initialization": ["Pattern pattern = compile(String,*)"], "initializationStart": [498], "initializationEnd": [558], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 576, "focalAPIEnd": 597, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()"], "useStart": [610], "useEnd": [621], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seasarorg/mayaa/tree/master/src-impl/org/seasar/mayaa/impl/engine/processor/WriteProcessor.java", "rawCode": "  protected boolean isExistsBodyTextInScript(String scriptText) {\n    String pattern =\n        \".*(\"\n            + \"\\\\$\\\\{\"\n            + BODY_VARIABLE_NAME\n            + \"\\\\}|\"\n            + \"\\\\$\\\\{\"\n            + BODY_VARIABLE_NAME\n            + \"[^a-zA-Z_$].*\\\\}|\"\n            + \"\\\\$\\\\{.*[^a-zA-Z_$]\"\n            + BODY_VARIABLE_NAME\n            + \"\\\\}|\"\n            + \"\\\\$\\\\{.*[^a-zA-Z_$]\"\n            + BODY_VARIABLE_NAME\n            + \"[^a-zA-Z_$].*\\\\}\"\n            + \")+.*\";\n    Pattern p = Pattern.compile(pattern, Pattern.DOTALL | Pattern.MULTILINE);\n    Matcher m = p.matcher(scriptText);\n    return m.matches();\n  }\n"}, {"dataset": "matcher", "exampleID": 6034, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 98, "focalAPIEnd": 119, "followUpCheck": "match.find() == false", "checkType": "IF", "followUpCheckExpressionStart": 125, "followUpCheckExpressionEnd": 147, "followUpCheckBlockStart": 125, "followUpCheckBlockEnd": 174, "use": ["match.group(int)"], "useStart": [297], "useEnd": [307], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7475/src/net/sourceforge/plantuml/StringUtils.java", "rawCode": "  public static final List<String> getSplit(Pattern pattern, String line) {\n    final Matcher m = pattern.matcher(line);\n    if (m.find() == false) {\n      return null;\n    }\n    final List<String> result = new ArrayList<String>();\n    for (int i = 1; i <= m.groupCount(); i++) {\n      result.add(m.group(i));\n    }\n    return result;\n  }\n"}, {"dataset": "matcher", "exampleID": 6035, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "input.endsWith(\")\",)||input.endsWith(\"]\",)||input.endsWith(\"}\",)", "guardType": "IF {", "guardExpressionStart": 359, "guardExpressionEnd": 426, "guardBlockStart": 359, "guardBlockEnd": 628, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 447, "focalAPIEnd": 489, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 497, "followUpCheckExpressionEnd": 510, "followUpCheckBlockStart": 497, "followUpCheckBlockEnd": 622, "use": ["match.group()", "match.replaceAll(String)"], "useStart": [570, 597], "useEnd": [579, 613], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/metamolecular/opsin/tree/master/opsin-core/src/main/java/uk/ac/cam/ch/wwmm/opsin/Parser.java", "rawCode": "  /**\n   * Parses a chemical name to an XML representation of the parse.\n   *\n   * @param n2sConfig\n   * @param name The name to parse.\n   * @return The parse.\n   * @throws ParsingException If the name is unparsable.\n   */\n  List<Element> parse(NameToStructureConfig n2sConfig, String name) throws ParsingException {\n    Integer[] componentRatios = null;\n    if (name.endsWith(\")\") || name.endsWith(\"]\") || name.endsWith(\"}\")) {\n      Matcher m = matchStoichiometryIndication.matcher(name);\n      if (m.find()) {\n        componentRatios = processStoichiometryIndication(m.group());\n        name = m.replaceAll(\"\");\n      }\n    }\n    Parse parse = null;\n    if (name.contains(\", \")) {\n      try {\n        TokenizationResult tokenizationResult =\n            tokeniser.tokenize(CASTools.uninvertCASName(name, parseRules), false);\n        if (tokenizationResult.isSuccessfullyTokenized()) {\n          parse = tokenizationResult.getParse();\n        }\n      } catch (ParsingException ignored) {\n      }\n    } else if (name.contains(\n        \"; \")) { // a mixture, spaces are sufficient for OPSIN to treat as a mixture. These spaces\n                 // for obvious reasons must not be removed\n      TokenizationResult tokenizationResult =\n          tokeniser.tokenize(matchSemiColonSpace.matcher(name).replaceAll(\" \"), false);\n      if (tokenizationResult.isSuccessfullyTokenized()) {\n        parse = tokenizationResult.getParse();\n      }\n    }\n    boolean allowSpaceRemoval;\n    if (parse == null) {\n      allowSpaceRemoval = true;\n      TokenizationResult tokenizationResult = tokeniser.tokenize(name, true);\n      if (tokenizationResult.isSuccessfullyTokenized()) {\n        parse = tokenizationResult.getParse();\n      } else {\n        if (n2sConfig.isDetailedFailureAnalysis()) {\n          generateExactParseFailureReason(tokenizationResult, name);\n        } else {\n          throw new ParsingException(\n              name\n                  + \" is unparsable due to the following being uninterpretable: \"\n                  + tokenizationResult.getUninterpretableName()\n                  + \" The following was not parseable: \"\n                  + tokenizationResult.getUnparsableName());\n        }\n      }\n    } else {\n      allowSpaceRemoval = false;\n    }\n\n    List<Parse> parses = generateParseCombinations(parse);\n    if (parses.size() == 0) {\n      throw new ParsingException(\"No parses could be found for \" + name);\n    }\n\n    List<Element> results = new ArrayList<Element>();\n    ParsingException preciseException = null;\n    for (Parse pp : parses) {\n      Element moleculeEl = new GroupingEl(MOLECULE_EL);\n      moleculeEl.addAttribute(new Attribute(NAME_ATR, name));\n      for (ParseWord pw : pp.getWords()) {\n        Element word = new GroupingEl(WORD_EL);\n        moleculeEl.addChild(word);\n        if (pw.getParseTokens().size() != 1) {\n          throw new ParsingException(\n              \"OPSIN bug: parseWord should have exactly 1 annotations after creating additional parses step\");\n        }\n        ParseTokens tokensForWord = pw.getParseTokens().get(0);\n        WordType wordType = OpsinTools.determineWordType(tokensForWord.getAnnotations());\n        word.addAttribute(new Attribute(TYPE_ATR, wordType.toString()));\n        if (pw.getWord()\n            .startsWith(\"-\")) { // we want -functionalterm to be the same as functionalterm\n          word.addAttribute(new Attribute(VALUE_ATR, pw.getWord().substring(1)));\n        } else {\n          word.addAttribute(new Attribute(VALUE_ATR, pw.getWord()));\n        }\n        writeWordXML(\n            word,\n            tokensForWord.getTokens(),\n            WordTools.chunkAnnotations(tokensForWord.getAnnotations()));\n      }\n      /* All words are placed into a wordRule.\n       * Often multiple words in the same wordRule.\n       * WordRules can be nested within each other e.g. in Carbonyl cyanide m-chlorophenyl hydrazone ->\n       * <wr><wr>Carbonyl cyanide</wr> m-chlorophenyl hydrazone </wr>\n       */\n      try {\n        wordRules.groupWordsIntoWordRules(\n            moleculeEl, n2sConfig, allowSpaceRemoval, componentRatios);\n      } catch (ParsingException e) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(e.getMessage(), e);\n        }\n        // Using that parse no word rules matched\n        continue;\n      }\n      try {\n        if (componentRatios != null) {\n          applyStoichiometryIndicationToWordRules(moleculeEl, componentRatios);\n        }\n        if (moleculeEl.getAttributeValue(ISSALT_ATR) != null\n            && moleculeEl.getChildElements(WORDRULE_EL).size() < 2) {\n          throw new ParsingException(\n              name\n                  + \" is apparently a salt, but the name only contained one component. The name could be describing a class of compounds\");\n        }\n        results.add(moleculeEl);\n      } catch (ParsingException e) {\n        preciseException = e;\n      }\n    }\n    if (results.size() == 0) {\n      if (preciseException != null) {\n        throw preciseException;\n      }\n      throw new ParsingException(\n          name\n              + \" could be parsed but OPSIN was unsure of the meaning of the words. This error will occur, by default, if a name is just a substituent\");\n    }\n\n    return results;\n  }\n"}, {"dataset": "matcher", "exampleID": 6036, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 148, "focalAPIEnd": 184, "followUpCheck": "!match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 190, "followUpCheckExpressionEnd": 207, "followUpCheckBlockStart": 190, "followUpCheckBlockEnd": 401, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.13/trunk-archive/src/om/devservlet/DevServlet.java", "rawCode": "  private void handleQuestion(\n      String idVersion, HttpServletRequest request, HttpServletResponse response) throws Exception {\n    Matcher m = QUESTIONID_REGEXP.matcher(idVersion);\n    if (!m.matches()) {\n      sendError(\n          request,\n          response,\n          HttpServletResponse.SC_NOT_FOUND,\n          \"Not found\",\n          \"Not a valid question id-version.\",\n          null);\n    }\n    File file = new File(getServletContext().getRealPath(\"questions\"), m.group(1) + \".jar\");\n\n    // Check that the requested file exits.\n    if (!file.exists()) {\n      sendError(\n          request,\n          response,\n          HttpServletResponse.SC_NOT_FOUND,\n          \"Not found\",\n          \"The requested question is not present on this server.\",\n          null);\n    }\n\n    // Then send it.\n    byte[] abQuestion = IO.loadBytes(new FileInputStream(file));\n    response.setContentType(\"application/x-openmark\");\n    response.setContentLength(abQuestion.length);\n    OutputStream os = response.getOutputStream();\n    os.write(abQuestion);\n    os.close();\n  }\n"}, {"dataset": "matcher", "exampleID": 6037, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 58, "focalAPIEnd": 70, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 76, "followUpCheckExpressionEnd": 92, "followUpCheckBlockStart": 76, "followUpCheckBlockEnd": 125, "use": ["match.group(int)"], "useStart": [108], "useEnd": [118], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-6939/src/net/sourceforge/plantuml/code/ArobaseStringCompressor.java", "rawCode": "  private String clean1(String s) {\n    final Matcher m = p.matcher(s);\n    if (m.matches()) {\n      return m.group(2);\n    }\n    return s;\n  }\n"}, {"dataset": "matcher", "exampleID": 6038, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 402, "focalAPIEnd": 441, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 447, "followUpCheckExpressionEnd": 469, "followUpCheckBlockStart": 447, "followUpCheckBlockEnd": 545, "use": ["match.group(int)", "match.group(int)"], "useStart": [503, 521], "useEnd": [519, 537], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/UWCS/choob/tree/master/src/main/plugins/Factoids2.java", "rawCode": "  private FactoidSearch getFactoidSearch(final Message mes) {\n    final String[] params1 = mods.util.getParamArray(mes, 2);\n\n    if (params1.length == 2) {\n      return new FactoidSearch(params1[1]);\n    }\n    if (params1.length <= 1) {\n      return null;\n    }\n\n    final String[] params2 = mods.util.getParamArray(mes, 1);\n\n    // If they have used quotes, split on that.\n    final Matcher mQuoted = quotedSearchPattern.matcher(params2[1]);\n    if (mQuoted.matches()) {\n      return new FactoidSearch(mQuoted.group(1), mQuoted.group(2));\n    }\n\n    // If there's a regexp search, split on that.\n    final Matcher mRegExp = regexpSearchPattern.matcher(params2[1]);\n    if (mRegExp.matches()) {\n      return new FactoidSearch(mRegExp.group(1), mRegExp.group(2));\n    }\n\n    // If they have used is/are, split on that.\n    final Matcher mIsAre = addDefinitionPattern.matcher(params2[1]);\n    if (mIsAre.matches()) {\n      return new FactoidSearch(mIsAre.group(1), mIsAre.group(2));\n    }\n\n    // Default to first word + rest split.\n    return new FactoidSearch(params1[1], params1[2]);\n  }\n"}, {"dataset": "matcher", "exampleID": 6039, "initialization": ["Pattern pattern = compile(String,*)"], "initializationStart": [222], "initializationEnd": [296], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 314, "focalAPIEnd": 328, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 376, "followUpCheckExpressionEnd": 392, "followUpCheckBlockStart": 376, "followUpCheckBlockEnd": 435, "use": ["match.appendReplacement(StringBuffer,String)", "match.appendTail(StringBuffer)"], "useStart": [401, 440], "useEnd": [428, 456], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/LuckyStars/nbc/tree/master/function-cardmanage/src/main/com/nbcedu/function/cardmanage/core/dao/impl/BaseDaoImpl.java", "rawCode": "  /**\n   * 去除hql的orderby 子句，用于pagedQuery.\n   *\n   * @see #pagedQuery(String,int,int,Object[])\n   */\n  @SuppressWarnings(\"unused\")\n  private static String removeOrders(String hql) {\n    Assert.hasText(hql);\n    Pattern p = Pattern.compile(\"order\\\\s*by[\\\\w|\\\\W|\\\\s|\\\\S]*\", Pattern.CASE_INSENSITIVE);\n    Matcher m = p.matcher(hql);\n    StringBuffer sb = new StringBuffer();\n    while (m.find()) {\n      m.appendReplacement(sb, \"\");\n    }\n    m.appendTail(sb);\n    return sb.toString();\n  }\n"}, {"dataset": "matcher", "exampleID": 6040, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "input.startsWith(\"PR\\t\",)||input.startsWith(\"\\t\",)", "guardType": "IF {", "guardExpressionStart": 399, "guardExpressionEnd": 452, "guardBlockStart": 399, "guardBlockEnd": 1455, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 541, "focalAPIEnd": 577, "followUpCheck": "match.find() && input.startsWith(\"PR\\t\")", "checkType": "IF", "followUpCheckExpressionStart": 730, "followUpCheckExpressionEnd": 792, "followUpCheckBlockStart": 730, "followUpCheckBlockEnd": 924, "use": ["match.group(int)"], "useStart": [881], "useEnd": [913], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnmay/mdk/tree/master/io/text-parsers/src/main/java/uk/ac/ebi/mdk/io/text/brenda/PRLineParser.java", "rawCode": "  /**\n   * The contents are organised in 40 information fields as given below. Protein information is\n   * included in '#'...#', literature citations are in '<...>', commentaries in '(...)' and field-\n   * special information in '{...}'.\n   *\n   * @param line\n   * @return\n   */\n  public String parse(String line) throws IOException {\n    boolean keepParsing = true;\n    while (keepParsing) {\n      if (line.startsWith(\"PR\\t\") || line.startsWith(\"\\t\")) {\n        // if(line.contains(this.specie)) {\n        Matcher protNumberInLineMatcher = this.proteinNumPattern.matcher(line);\n        Matcher citationListMatcher = this.citationListPattern.matcher(line);\n        Matcher dbRefMatcher = this.dbRefPattern.matcher(line);\n\n        if (protNumberInLineMatcher.find() && line.startsWith(\"PR\\t\")) {\n          // protNumber.add(protNumberInLineMatcher.group(1));\n          protNumber = protNumberInLineMatcher.group(1);\n        }\n        if ((line.contains(\"<\") || line.contains(\">\")) && citationListMatcher.find()) {\n          this.citations.addAll(Arrays.asList(citationListMatcher.group(2).split(\",\")));\n        }\n        if (dbRefMatcher.find()) {\n          this.id2DbRef.put(dbRefMatcher.group(1), dbRefMatcher.group(2));\n        }\n        // } else {\n        // return this.reader.readLine();\n        // }\n        line = reader.readLine();\n        if (line.startsWith(\"PR\\t\") || line.length() < 2) return line;\n      } else {\n        return line;\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "matcher", "exampleID": 6041, "initialization": ["String input = getText()"], "initializationStart": [185], "initializationEnd": [194], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 212, "focalAPIEnd": 233, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 240, "followUpCheckExpressionEnd": 253, "followUpCheckBlockStart": 240, "followUpCheckBlockEnd": 278, "use": ["createSubText(match)"], "useStart": [261], "useEnd": [277], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vivek/hudson/tree/master/core/src/main/java/hudson/AbstractMarkupText.java", "rawCode": "  /**\n   * Find the first occurrence of the given pattern in this text, or null.\n   *\n   * @since 1.349\n   */\n  public MarkupText.SubText findToken(Pattern pattern) {\n    String text = getText();\n    Matcher m = pattern.matcher(text);\n\n    if (m.find()) return createSubText(m);\n\n    return null;\n  }\n"}, {"dataset": "matcher", "exampleID": 6042, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(input)!=null && input.indexOf(\"default\",)==0||input.indexOf(\"0.0.0.0\",)>=0", "guardType": "LOOP {", "guardExpressionStart": 122, "guardExpressionEnd": 172, "guardBlockStart": 122, "guardBlockEnd": 899, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 499, "focalAPIEnd": 523, "followUpCheck": "match.find(start)", "checkType": "LOOP {", "followUpCheckExpressionStart": 556, "followUpCheckExpressionEnd": 577, "followUpCheckBlockStart": 556, "followUpCheckBlockEnd": 885, "use": ["match.group()", "match.end()"], "useStart": [603, 863], "useEnd": [612, 870], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tomp2p/TomP2P/tree/master/nat/src/main/java/net/tomp2p/natpmp/Gateway.java", "rawCode": "  static InetAddress parse(BufferedReader bufferedreader) throws IOException, UnknownHostException {\n    String line;\n    while ((line = bufferedreader.readLine()) != null) {\n      boolean gatewayLine = false;\n      if (line.indexOf(\"default\") == 0 || line.indexOf(\"0.0.0.0\") >= 0) {\n        // MacOSX\n        if (line.indexOf(\"default\") == 0) {\n          gatewayLine = true;\n        }\n        // this is the line with the gateway IP, search for the first\n        // good entry.\n        Matcher m = IP_PATTERN.matcher(line);\n        int start = 0;\n        while (m.find(start)) {\n          String tmp = m.group();\n          // first entry\n          if (start == 0 && tmp.equals(\"0.0.0.0\")) {\n            gatewayLine = true;\n          } else if (!tmp.equals(\"0.0.0.0\") && gatewayLine) {\n            return InetAddress.getByName(tmp);\n          }\n          start = m.end() + 1;\n        }\n      }\n    }\n    return null;\n  }\n"}, {"dataset": "matcher", "exampleID": 6043, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [122], "initializationEnd": [149], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 169, "focalAPIEnd": 192, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()", "pattern.matcher(String)", "match.matches()", "pattern.matcher(String)", "match.matches()", "pattern.matcher(String)", "match.matches()", "pattern.matcher(String)", "match.matches()"], "useStart": [209, 335, 375, 504, 544, 680, 720, 852, 892], "useEnd": [222, 358, 388, 527, 557, 703, 733, 875, 905], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/PatternTest.java", "rawCode": "  public void testEmbeddedFlags() {\n    String baseString = \"(?i)((?s)a)\";\n    String testString = \"A\";\n    Pattern pat = Pattern.compile(baseString);\n    Matcher mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n\n    baseString = \"(?x)(?i)(?s)(?d)a\";\n    testString = \"A\";\n    pat = Pattern.compile(baseString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n\n    baseString = \"(?x)(?i)(?s)(?d)a.\";\n    testString = \"a\\n\";\n    pat = Pattern.compile(baseString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n\n    baseString = \"abc(?x:(?i)(?s)(?d)a.)\";\n    testString = \"abcA\\n\";\n    pat = Pattern.compile(baseString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n\n    baseString = \"abc((?x)d)(?i)(?s)a\";\n    testString = \"abcdA\";\n    pat = Pattern.compile(baseString);\n    mat = pat.matcher(testString);\n    assertTrue(mat.matches());\n  }\n"}, {"dataset": "matcher", "exampleID": 6044, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [81], "initializationEnd": [130], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 154, "focalAPIEnd": 166, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.find()", "match.group(int)"], "useStart": [172, 193], "useEnd": [180, 203], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7177/src/net/sourceforge/plantuml/cucadiagram/dot/CucaDiagramFileMaker.java", "rawCode": "  private static String getValue(String s, String param) {\n    final Pattern p = Pattern.compile(\"(?i)\" + param + \"=\\\"([^\\\"]+)\\\"\");\n    final Matcher m = p.matcher(s);\n    m.find();\n    return m.group(1);\n  }\n"}, {"dataset": "matcher", "exampleID": 6045, "initialization": ["Pattern pattern = getExecuteCall()"], "initializationStart": [110], "initializationEnd": [137], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 151, "focalAPIEnd": 177, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["parseQueryProcedureCallParameters(match)"], "useStart": [222], "useEnd": [273], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/elka-projekt/cs-voltdb/tree/master/tests/frontend/org/voltdb/utils/TestSqlCmdInterface.java", "rawCode": "  private void assertThis2(String query, String cleanQryStr, int num, int testID) {\n    Pattern ExecuteCall = SQLCommand.getExecuteCall();\n    query = ExecuteCall.matcher(query).replaceFirst(\"\");\n    List<String> params = SQLCommand.parseQueryProcedureCallParameters(query);\n    String parsedString = Joiner.on(\"\").join(params);\n    String msg = \"\\nTest ID: \" + testID + \". \";\n    String err1 = \"\\nExpected # of queries: \" + num + \"\\n\";\n    err1 += \"Actual # of queries: \" + params.size() + \"\\n\";\n    assertEquals(msg + err1, num, params.size());\n    String err2 = \"\\nExpected queries: \\n#\" + cleanQryStr + \"#\\n\";\n    err2 += \"Actual queries: \\n#\" + parsedString + \"#\\n\";\n    assertTrue(msg + err2, cleanQryStr.equalsIgnoreCase(parsedString));\n  }\n"}, {"dataset": "matcher", "exampleID": 6046, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["input.endsWith(*)"], "configurationStart": [84], "configurationEnd": [111], "guardCondition": "pattern!=null", "guardType": "IF {", "guardExpressionStart": 124, "guardExpressionEnd": 149, "guardBlockStart": 124, "guardBlockEnd": 318, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 165, "focalAPIEnd": 190, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()"], "useStart": [165], "useEnd": [200], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wolfses/pmd_STANly/tree/master/src/main/java/net/sourceforge/pmd/util/filter/RegexStringFilter.java", "rawCode": "  public boolean filter(String obj) {\n    if (this.endsWith != null) {\n      return obj.endsWith(this.endsWith);\n    } else if (this.pattern != null) {\n      return this.pattern.matcher(obj).matches();\n    } else {\n      // The regular expression must have been bad, so it will match nothing.\n      return false;\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6047, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [316], "initializationEnd": [335], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 353, "focalAPIEnd": 369, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 375, "followUpCheckExpressionEnd": 391, "followUpCheckBlockStart": 375, "followUpCheckBlockEnd": 469, "use": ["thornifyMatcher(Syntax,match)"], "useStart": [407], "useEnd": [430], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ICGog/MapReduce-Thorn/tree/master/lib/fisher/src/fisher/runtime/StringTh.java", "rawCode": "  private Thing CmatchRE(\n      String methodName, Thing[] args, Evaller evaller, Framelike frame, Syntax src)\n      throws FisherException {\n    checkNumberOfArgs(1, 1, methodName, args, evaller, frame, src);\n    String re = args[0].asString(src);\n    // TODO -- if Pattern doesn't cache, we could.\n    Pattern p = Pattern.compile(re);\n    Matcher m = p.matcher(value);\n    if (m.matches()) {\n      return thornifyMatcher(src, m);\n    } else {\n      return null;\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6048, "initialization": ["String input = File.getAbsolutePath()"], "initializationStart": [119], "initializationEnd": [141], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 159, "focalAPIEnd": 188, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()"], "useStart": [201], "useEnd": [212], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kef/boost/tree/master/src/test/java/au/net/netstorm/boost/sniper/aggregator/TestRegexFilter.java", "rawCode": "  public boolean accept(File file) {\n    if (file.isDirectory()) {\n      return false;\n    }\n    String absolutePath = file.getAbsolutePath();\n    Matcher m = pattern.matcher(absolutePath);\n    return m.matches();\n  }\n"}, {"dataset": "matcher", "exampleID": 6049, "initialization": ["String input = toString()"], "initializationStart": [316], "initializationEnd": [329], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["input.replace(*,*)"], "configurationStart": [385], "configurationEnd": [422], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 527, "focalAPIEnd": 547, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.replaceAll(*)"], "useStart": [527], "useEnd": [571], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdunck/google-refine/tree/master/main/src/com/google/refine/expr/functions/strings/Replace.java", "rawCode": "  @Override\n  public Object call(Properties bindings, Object[] args) {\n    if (args.length == 3) {\n      Object o1 = args[0];\n      Object o2 = args[1];\n      Object o3 = args[2];\n      if (o1 != null && o2 != null && o3 != null && o3 instanceof String) {\n        String str = (o1 instanceof String) ? (String) o1 : o1.toString();\n\n        if (o2 instanceof String) {\n          return str.replace((String) o2, (String) o3);\n        } else if (o2 instanceof Pattern) {\n          Pattern pattern = (Pattern) o2;\n          return pattern.matcher(str).replaceAll((String) o3);\n        }\n      }\n    }\n    return new EvalError(\n        ControlFunctionRegistry.getFunctionName(this)\n            + \" expects 3 strings, or 1 string, 1 regex, and 1 string\");\n  }\n"}, {"dataset": "matcher", "exampleID": 6050, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 290, "focalAPIEnd": 320, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 326, "followUpCheckExpressionEnd": 342, "followUpCheckBlockStart": 326, "followUpCheckBlockEnd": 1327, "use": ["match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)"], "useStart": [366, 399, 432, 469], "useEnd": [376, 409, 442, 479], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/JetBrains/intellij-plugins/tree/master/osmorc/src/org/osmorc/maven/facet/ImporterUtil.java", "rawCode": "  /**\n   * Clean up version parameters. Other builders use more fuzzy definitions of the version syntax.\n   * This method cleans up such a version to match an OSGi version.\n   */\n  static String cleanupVersion(String version) {\n    StringBuffer result = new StringBuffer();\n    Matcher m = FUZZY_VERSION.matcher(version);\n    if (m.matches()) {\n      String major = m.group(1);\n      String minor = m.group(3);\n      String micro = m.group(5);\n      String qualifier = m.group(7);\n\n      if (major != null) {\n        result.append(major);\n        if (minor != null) {\n          result.append(\".\");\n          result.append(minor);\n          if (micro != null) {\n            result.append(\".\");\n            result.append(micro);\n            if (qualifier != null) {\n              result.append(\".\");\n              cleanupModifier(result, qualifier);\n            }\n          } else if (qualifier != null) {\n            result.append(\".0.\");\n            cleanupModifier(result, qualifier);\n          } else {\n            result.append(\".0\");\n          }\n        } else if (qualifier != null) {\n          result.append(\".0.0.\");\n          cleanupModifier(result, qualifier);\n        } else {\n          result.append(\".0.0\");\n        }\n      }\n    } else {\n      result.append(\"0.0.0.\");\n      cleanupModifier(result, version);\n    }\n    return result.toString();\n  }\n"}, {"dataset": "matcher", "exampleID": 6051, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "tst.matcher(input,).find()", "guardType": "IF {", "guardExpressionStart": 46, "guardExpressionEnd": 72, "guardBlockStart": 46, "guardBlockEnd": 308, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 85, "focalAPIEnd": 99, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)"], "useStart": [131, 175, 219, 266], "useEnd": [144, 188, 233, 280], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/DTRules/DTRules/tree/master/dtrules-engine/src/main/java/com/dtrules/xmlparser/GenericXMLParser.java", "rawCode": "  public static String encode(String s) {\n    if (tst.matcher(s).find()) {\n      s = amp.matcher(s).replaceAll(\"&amp;\");\n      s = lt.matcher(s).replaceAll(\"&lt;\");\n      s = gt.matcher(s).replaceAll(\"&gt;\");\n      s = squ.matcher(s).replaceAll(\"&apos;\");\n      s = dqu.matcher(s).replaceAll(\"&quot;\");\n    }\n    return s;\n  }\n"}, {"dataset": "matcher", "exampleID": 6052, "initialization": ["String input = BufferedReader.readLine()"], "initializationStart": [310], "initializationEnd": [323], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "input!=null", "guardType": "LOOP {", "guardExpressionStart": 331, "guardExpressionEnd": 351, "guardBlockStart": 331, "guardBlockEnd": 704, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 374, "focalAPIEnd": 401, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.find()"], "useStart": [427], "useEnd": [435], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()"], "finallyExpressionStart": 741, "finallyExpressionEnd": 749, "finallyBlockStart": 741, "finallyBlockEnd": 774, "cleanUpCallStart": [757], "cleanUpCallEnd": [767], "url": "https://github.com/vaadin/gwt/tree/master/dev/codeserver/java/com/google/gwt/dev/codeserver/WebServer.java", "rawCode": "  /**\n   * Copies in to out line by line, escaping each line for html characters and highlighting error\n   * lines. Closes <code>in</code> when done.\n   */\n  private static void sendLogAsHtml(BufferedReader in, HtmlWriter out) throws IOException {\n    try {\n      out.startTag(\"pre\").nl();\n      String line = in.readLine();\n      while (line != null) {\n        Matcher m = ERROR_PATTERN.matcher(line);\n        boolean error = m.find();\n        if (error) {\n          out.startTag(\"span\", \"class=\", \"error\");\n        }\n        out.text(line);\n        if (error) {\n          out.endTag(\"span\");\n        }\n        out.nl(); // the readLine doesn't include the newline.\n        line = in.readLine();\n      }\n      out.endTag(\"pre\").nl();\n    } finally {\n      in.close();\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6053, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 725, "focalAPIEnd": 780, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 959, "followUpCheckExpressionEnd": 992, "followUpCheckBlockStart": 959, "followUpCheckBlockEnd": 1729, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/crow-misia/ermaster.old/tree/master/org.insightech.er/src/org/insightech/er/db/impl/oracle/OracleTableImportManager.java", "rawCode": "  @Override\n  protected ColumnData createColumnData(ResultSet columnSet) throws SQLException {\n    ColumnData columnData = super.createColumnData(columnSet);\n    String type = columnData.type.toLowerCase();\n\n    if (\"number\".equals(type)) {\n      if (columnData.size == 22 && columnData.decimalDigits == 0) {\n        columnData.size = 0;\n      }\n\n    } else if (\"float\".equals(type)) {\n      if (columnData.size == 126 && columnData.decimalDigits == 0) {\n        columnData.size = 0;\n      }\n\n    } else if (\"urowid\".equals(type)) {\n      if (columnData.size == 4000) {\n        columnData.size = 0;\n      }\n\n    } else if (\"anydata\".equals(type)) {\n      columnData.size = 0;\n\n    } else {\n      Matcher yearToMonthMatcber = INTERVAL_YEAR_TO_MONTH_PATTERN.matcher(columnData.type);\n      Matcher dayToSecondMatcber = INTERVAL_DAY_TO_SECCOND_PATTERN.matcher(columnData.type);\n      Matcher timestampMatcber = TIMESTAMP_PATTERN.matcher(columnData.type);\n\n      if (yearToMonthMatcber.matches()) {\n        columnData.type = \"interval year to month\";\n\n        if (columnData.size == 2) {\n          columnData.size = 0;\n        }\n\n      } else if (dayToSecondMatcber.matches()) {\n        columnData.type = \"interval day to second\";\n\n        if (columnData.size == 2 && columnData.decimalDigits == 6) {\n          columnData.size = 0;\n          columnData.decimalDigits = 0;\n        }\n\n      } else if (timestampMatcber.matches()) {\n        columnData.type = columnData.type.replaceAll(\"\\\\(.\\\\)\", \"\");\n        columnData.size = 0;\n\n        if (columnData.decimalDigits == 6) {\n          columnData.size = 0;\n\n        } else {\n          columnData.size = columnData.decimalDigits;\n        }\n\n        columnData.decimalDigits = 0;\n      }\n    }\n\n    return columnData;\n  }\n"}, {"dataset": "matcher", "exampleID": 6054, "initialization": ["String input = Field.toGenericString()"], "initializationStart": [161], "initializationEnd": [180], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 198, "focalAPIEnd": 214, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 220, "followUpCheckExpressionEnd": 233, "followUpCheckBlockStart": 220, "followUpCheckBlockEnd": 933, "use": ["match.group(int)"], "useStart": [253], "useEnd": [263], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nutzam/nutz/tree/master/src/org/nutz/lang/Mirror.java", "rawCode": "  /**\n   * 获取一个字段的泛型参数数组，如果这个字段没有泛型，返回空数组\n   *\n   * @param f 字段\n   * @return 泛型参数数组\n   */\n  public static Class<?>[] getGenericTypes(Field f) {\n    String gts = f.toGenericString();\n    Matcher m = PTN.matcher(gts);\n    if (m.find()) {\n      String s = m.group(2);\n      String[] ss = Strings.splitIgnoreBlank(s);\n      if (ss.length > 0) {\n        Class<?>[] re = new Class<?>[ss.length];\n        try {\n          for (int i = 0; i < ss.length; i++) {\n            String className = ss[i];\n            if (className.length() > 0 && className.charAt(0) == '?') re[i] = Object.class;\n            else {\n              int pos = className.indexOf('<');\n              if (pos < 0) re[i] = Lang.loadClass(className);\n              else re[i] = Lang.loadClass(className.substring(0, pos));\n            }\n          }\n          return re;\n        } catch (ClassNotFoundException e) {\n          throw Lang.wrapThrow(e);\n        }\n      }\n    }\n    return new Class<?>[0];\n  }\n"}, {"dataset": "matcher", "exampleID": 6055, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [269], "initializationEnd": [313], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 752, "tryExpressionEnd": 756, "tryBlockStart": 752, "tryBlockEnd": 4258, "catchExpressionStart": 4053, "catchExpressionEnd": 4085, "catchBlockStart": 4053, "catchBlockEnd": 4160, "exceptionHandlingCallStart": [4134], "exceptionHandlingCallEnd": [4153], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(input)!=null", "guardType": "LOOP {", "guardExpressionStart": 988, "guardExpressionEnd": 1027, "guardBlockStart": 988, "guardBlockEnd": 4007, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 1050, "focalAPIEnd": 1071, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 1165, "followUpCheckExpressionEnd": 1181, "followUpCheckBlockStart": 1165, "followUpCheckBlockEnd": 1498, "use": ["match.group(int)", "match.group(int)", "match.group(int)"], "useStart": [1200, 1232, 1265], "useEnd": [1210, 1242, 1275], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seweissman/wikiduper/tree/master/src/main/wikiduper/dist/EditDistance.java", "rawCode": "  public static void main(String args[]) {\n\n    if (args.length != 1) {\n      System.out.println(\"Usage: EditDistance <filein>\\n\");\n      System.exit(-1);\n    }\n    // Pattern linepat = Pattern.compile(\"(\\\\[[-0-9, ]+\\\\])\\t\\\\((.*), \\\\d+:\\\\d+\\\\)\");\n    Pattern linepat = Pattern.compile(\"([-0-9]+)\\t([^\\t]+)\\t(.*)\");\n    // ArrayList<ArrayList<String>> clusterlist = new ArrayList<ArrayList<String>>();\n    HashMap<String, HashSet<String>> matchmap = new HashMap<String, HashSet<String>>();\n    HashMap<String, HashSet<String>> nomatchmap = new HashMap<String, HashSet<String>>();\n\n    FileInputStream fin;\n    int clusterct = 0;\n    int uniquematchct = 0;\n    int uniquefalseposct = 0;\n    int nonuniquematchct = 0;\n    int nonuniquefalseposct = 0;\n    try {\n      fin = new FileInputStream(args[0]);\n      BufferedReader bin = new BufferedReader(new InputStreamReader(fin));\n      String line;\n      ArrayList<String> cluster = new ArrayList<String>();\n      String sigcurr = null;\n      while ((line = bin.readLine()) != null) {\n        Matcher m = linepat.matcher(line);\n        String sig = \"\";\n        String sentence = \"\";\n        String article = \"\";\n        if (m.matches()) {\n          sig = m.group(1);\n          article = m.group(2);\n          sentence = m.group(3);\n          System.out.println(\n              \"sig = \" + sig + \", article = \" + article + \", sentence = \" + sentence);\n        } else {\n          System.out.println(\"Bad line: \" + line);\n          System.exit(-1);\n        }\n\n        if (sigcurr == null) {\n          sigcurr = sig;\n        }\n        if (!sigcurr.equals(sig)) {\n          clusterct++;\n          if (clusterct % 1000 == 0) System.out.println(\"clusterct = \" + clusterct);\n          for (int i = 0; i < cluster.size(); i++) {\n            String m1 = cluster.get(i);\n            for (int j = i + 1; j < cluster.size(); j++) {\n              String m2 = cluster.get(j);\n              long dl = Math.max(m1.length(), m2.length()) - Math.min(m1.length(), m2.length());\n              long d = dist(m1, m2);\n              long score =\n                  Math.round(100 * (d - dl + 1) * 1.0 / Math.max(m1.length(), m2.length()));\n\n              if (score > 25) {\n                nonuniquefalseposct++;\n                // System.out.println(m1 + \">>>>>>\" + m2 + \">>>>>> \" + score);\n                if (!nomatchmap.containsKey(m1)) {\n                  nomatchmap.put(m1, new HashSet<String>());\n                }\n\n                if (!nomatchmap.containsKey(m2)) {\n                  nomatchmap.put(m2, new HashSet<String>());\n                }\n                if (!(nomatchmap.get(m2).contains(m1) || nomatchmap.get(m1).contains(m2))) {\n                  // System.out.println(m1 + \"\\t\" + m2);\n                  uniquefalseposct++;\n                }\n\n                nomatchmap.get(m2).add(m1);\n                nomatchmap.get(m1).add(m2);\n              } else {\n                nonuniquematchct++;\n\n                if (!matchmap.containsKey(m1)) {\n                  matchmap.put(m1, new HashSet<String>());\n                }\n\n                if (!matchmap.containsKey(m2)) {\n                  matchmap.put(m2, new HashSet<String>());\n                }\n                if (!(matchmap.get(m2).contains(m1) || matchmap.get(m1).contains(m2))) {\n                  uniquematchct++;\n                }\n                matchmap.get(m2).add(m1);\n                matchmap.get(m1).add(m2);\n              }\n            }\n          }\n          // clusterlist.add(cluster);\n          // cluster = new ArrayList<String>();\n          cluster.clear();\n        }\n        sigcurr = sig;\n\n        sentence =\n            sentence\n                .replace(\"External Links\", \"\")\n                .replace(\"External links\", \"\")\n                .replace(\"References\", \"\")\n                .replace(\"Official site\", \"\")\n                .replace(\"official site\", \"\");\n        if (sentence.length() > 100) {\n          cluster.add(sentence);\n        }\n\n        // System.out.println(\"entity = \" + entity);\n      }\n      bin.close();\n      fin.close();\n\n    } catch (FileNotFoundException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    } catch (IOException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    }\n\n    System.out.println(\"Cluster count:\" + clusterct);\n    System.out.println(\"N unique input matchess: \" + uniquematchct);\n    System.out.println(\"N unique input false positives: \" + uniquefalseposct);\n    System.out.println(\"N non-unique input matchess: \" + nonuniquematchct);\n    System.out.println(\"N non-unique input false positives: \" + nonuniquefalseposct);\n    // System.exit(-1);\n    int componentct = 0;\n    HashMap<Long, Long> histogram = new HashMap<Long, Long>();\n    long matchct = 0;\n    long badct = 0;\n    while (!matchmap.isEmpty()) {\n      String[] matchentities = matchmap.keySet().toArray(new String[0]);\n      String entity = matchentities[0];\n      HashSet<String> comp = getConnectedComponent(entity, matchmap);\n      // System.out.println(\"entity = \" + entity);\n      String cluster[] = comp.toArray(new String[0]);\n      componentct++;\n      System.out.println(\"componentct = \" + componentct + \" \" + comp.size());\n\n      int clustdisplayct = 0;\n      for (String m : cluster) {\n        if (clustdisplayct > 20) break;\n        System.out.println(\"item = \" + m);\n        clustdisplayct++;\n      }\n\n      for (int i = 0; i < cluster.length; i++) {\n        String entity1 = cluster[i];\n        for (int j = i + 1; j < cluster.length; j++) {\n          matchct++;\n          String entity2 = cluster[j];\n          long dl =\n              Math.max(entity1.length(), entity2.length())\n                  - Math.min(entity1.length(), entity2.length());\n          long d = dist(entity1, entity2);\n          long score =\n              Math.round(100 * (d - dl + 1) * 1.0 / Math.max(entity1.length(), entity2.length()));\n          // System.out.println(entity1 + \", \" + entity2 + \", \" + d + \", \" + dl + \", \" + Math.ceil(\n          // 100*score));\n          if (score > 0) {\n            if (!histogram.containsKey(score)) {\n              histogram.put(score, 0l);\n            }\n            histogram.put(score, histogram.get(score) + 1);\n          }\n          // if(dl > d){\n          // System.out.println(\"Weird lines:\");\n          // System.out.println(entity1 + \", \" + entity2 + \", \" + d + \", \" + dl + \", \" + Math.ceil(\n          // 100*score));\n          // }\n\n          if (score > 5) {\n            badct++;\n          }\n        }\n      }\n      System.out.println(\"matchct = \" + matchct + \" ,'badct = \" + badct);\n    }\n    for (long i = 0; i <= 100; i++) {\n      if (histogram.containsKey(i)) {\n        System.out.println(i + \",\" + histogram.get(i));\n      } else {\n        System.out.println(i + \",\" + 0);\n      }\n    }\n    System.out.println(\"N input buckets: \" + clusterct);\n    System.out.println(\"Total pairs: \" + matchct);\n    System.out.println(\"Bad pairs: \" + badct);\n    System.out.println(\"N components: \" + componentct);\n\n    System.out.println(\"FP rate: \" + badct * 1.0 / matchct);\n    // String s1 = \"abcedfgh\";\n    // String s2 = \"bcdefg\";\n    // System.out.println(\"distance: \" + EditDistance.dist(s1, s2));\n  }\n"}, {"dataset": "matcher", "exampleID": 6056, "initialization": ["String input = Text.getData()", "Pattern pattern = compile(*,*)"], "initializationStart": [169, 321], "initializationEnd": [180, 381], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(true||input.indexOf(sBorder,)==-1)", "guardType": "IF {", "guardExpressionStart": 186, "guardExpressionEnd": 240, "guardBlockStart": 186, "guardBlockEnd": 248, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 399, "focalAPIEnd": 422, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 428, "followUpCheckExpressionEnd": 444, "followUpCheckBlockStart": 428, "followUpCheckBlockEnd": 1215, "use": ["match.group(int)", "match.appendReplacement(StringBuffer,String)", "match.appendReplacement(StringBuffer,*)", "match.appendReplacement(StringBuffer,String)", "match.appendTail(StringBuffer)"], "useStart": [467, 506, 636, 794, 1220], "useEnd": [477, 544, 691, 827, 1242], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.10.2/src/util/xml/XML.java", "rawCode": "  private static void replaceNodeTokens(Text t, String sBorder, Map mReplace) {\n    // Get value and look for tokens. If there aren't any, bail now.\n    String sValue = t.getData();\n    if (mReplace == null || sValue.indexOf(sBorder) == -1) return;\n\n    StringBuffer sbBefore = new StringBuffer();\n\n    Pattern pTokens = Pattern.compile(sBorder + \"(.*?)\" + sBorder, Pattern.DOTALL);\n    Matcher m = pTokens.matcher(sValue);\n    while (m.find()) {\n      String sKey = m.group(1);\n      if (sKey.equals(\"\")) m.appendReplacement(sbBefore, sBorder);\n      else {\n        Node nMatch = (Node) mReplace.get(sKey);\n        if (nMatch == null) m.appendReplacement(sbBefore, sBorder + sKey + sBorder);\n        else {\n          // OK, found a token. Get everything before it into the buffer...\n          m.appendReplacement(sbBefore, \"\");\n          // ...create a new text node with the 'before' text...\n          Text tBefore = t.getOwnerDocument().createTextNode(sbBefore.toString());\n          t.getParentNode().insertBefore(tBefore, t);\n          sbBefore.setLength(0);\n          // ...add the new node...\n          t.getParentNode().insertBefore(t.getOwnerDocument().importNode(nMatch, true), t);\n        }\n      }\n    }\n    m.appendTail(sbBefore);\n    t.setData(sbBefore.toString());\n  }\n"}, {"dataset": "matcher", "exampleID": 6057, "initialization": ["String input = Configuration.get(String)", "Pattern pattern = Pattern.compile(String)"], "initializationStart": [83, 192], "initializationEnd": [117, 224], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 242, "focalAPIEnd": 268, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 303, "followUpCheckExpressionEnd": 316, "followUpCheckBlockStart": 303, "followUpCheckBlockEnd": 375, "use": ["match.group(int)"], "useStart": [357], "useEnd": [367], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pgroth/hbase-rdf/tree/master/src/main/java/nl/vu/datalayer/hbase/bulkload/AbstractPrefixMatchBulkLoad.java", "rawCode": "  protected int getChildJVMSize(Configuration conf) {\n    String childOptsString = conf.get(\"mapred.child.java.opts\");\n    System.out.println(\"ChildOpts: \" + childOptsString);\n    Pattern p = Pattern.compile(\"-Xmx([0-9]*)m\");\n    Matcher m = p.matcher(childOptsString);\n    int childJVMSize = 1024;\n    if (m.find()) {\n      childJVMSize = Integer.parseInt(m.group(1));\n    }\n    System.out.println(\"ChildJVM: \" + childJVMSize);\n    return childJVMSize;\n  }\n"}, {"dataset": "matcher", "exampleID": 6058, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 299, "focalAPIEnd": 331, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 339, "followUpCheckExpressionEnd": 355, "followUpCheckBlockStart": 339, "followUpCheckBlockEnd": 1554, "use": ["match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)"], "useStart": [478, 530, 581, 637, 690, 743, 869, 1040], "useEnd": [488, 540, 591, 647, 700, 753, 879, 1050], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mozilla-b2g/android-sdk/tree/master/ddms/libs/ddmuilib/src/com/android/ddmuilib/location/GpxParser.java", "rawCode": "    /**\n     * Converts the string description of the time into milliseconds since epoch.\n     *\n     * @param timeString the string data.\n     * @return date in milliseconds.\n     */\n    private long computeTime(String timeString) {\n      // Time looks like: 2008-04-05T19:24:50Z\n      Matcher m = ISO8601_TIME.matcher(timeString);\n      if (m.matches()) {\n        // get the various elements and reconstruct time as a long.\n        try {\n          int year = Integer.parseInt(m.group(1));\n          int month = Integer.parseInt(m.group(2));\n          int date = Integer.parseInt(m.group(3));\n          int hourOfDay = Integer.parseInt(m.group(4));\n          int minute = Integer.parseInt(m.group(5));\n          int second = Integer.parseInt(m.group(6));\n\n          // handle the optional parameters.\n          int milliseconds = 0;\n\n          String subSecondGroup = m.group(7);\n          if (subSecondGroup != null) {\n            milliseconds = (int) (1000 * Double.parseDouble(subSecondGroup));\n          }\n\n          boolean utcTime = m.group(8) != null;\n\n          // now we convert into milliseconds since epoch.\n          Calendar c;\n          if (utcTime) {\n            c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\")); // $NON-NLS-1$\n          } else {\n            c = Calendar.getInstance();\n          }\n\n          c.set(year, month, date, hourOfDay, minute, second);\n\n          return c.getTimeInMillis() + milliseconds;\n        } catch (NumberFormatException e) {\n          // format is invalid, we'll return -1 below.\n        }\n      }\n\n      // invalid time!\n      return -1;\n    }\n"}, {"dataset": "matcher", "exampleID": 6059, "initialization": ["String input = ReadLine.readLine()"], "initializationStart": [80], "initializationEnd": [97], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null)", "guardType": "IF {", "guardExpressionStart": 103, "guardExpressionEnd": 117, "guardBlockStart": 103, "guardBlockEnd": 144, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 168, "focalAPIEnd": 191, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 197, "followUpCheckExpressionEnd": 210, "followUpCheckBlockStart": 197, "followUpCheckBlockEnd": 592, "use": ["match.group(int)"], "useStart": [249], "useEnd": [259], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sixman9/plantuml-69/tree/master/src/net/sourceforge/plantuml/preproc/IfManager.java", "rawCode": "  protected String readLineInternal() throws IOException {\n    final String s = source.readLine();\n    if (s == null) {\n      return null;\n    }\n\n    final Matcher m = ifdefPattern.matcher(s);\n    if (m.find()) {\n      boolean ok = defines.isDefine(m.group(2));\n      if (m.group(1) != null) {\n        ok = !ok;\n      }\n      if (ok) {\n        child = new IfManagerPositif(source, defines);\n      } else {\n        child = new IfManagerNegatif(source, defines);\n      }\n      // child = new IfManager(source, defines, ok ? IfPart.IF :\n      // IfPart.SKIP);\n      return this.readLine();\n    }\n\n    // m = endifPattern.matcher(s);\n    // if (m.find()) {\n    // return null;\n    // }\n    return s;\n  }\n"}, {"dataset": "matcher", "exampleID": 6060, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [1257], "initializationEnd": [1284], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(StringUtils.isBlank(input,))", "guardType": "IF {", "guardExpressionStart": 426, "guardExpressionEnd": 458, "guardBlockStart": 426, "guardBlockEnd": 519, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 1294, "focalAPIEnd": 1311, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 1317, "followUpCheckExpressionEnd": 1333, "followUpCheckBlockStart": 1317, "followUpCheckBlockEnd": 1356, "use": ["pattern.matcher(String)", "pattern.matcher(String)", "pattern.matcher(String)"], "useStart": [1536, 1804, 2354], "useEnd": [1553, 1821, 2371], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.1.0-beta06/kernel-util/src/main/java/org/sakaiproject/util/PasswordCheck.java", "rawCode": "  /**\n   * Compute the strength of the given password and return it as one of the constant values.\n   *\n   * @param passwd - The password string to check\n   * @return strength indication of a password as per constants\n   */\n  public static int getPasswordStrength(String passwd) {\n    int upper = 0, lower = 0, numbers = 0, special = 0, length = 0, strength = 0;\n    Pattern p;\n    Matcher m;\n\n    // null/blank passwords\n    if (StringUtils.isBlank(passwd)) {\n      log.debug(\"Password null\");\n      return NONE;\n    }\n\n    // LENGTH\n    length = passwd.length();\n\n    // length 4 or less\n    if (length < 5) {\n      strength = (strength + 3);\n      log.debug(\"3 points for length (\" + length + \")\");\n    }\n    // length between 5 and 7\n    else if (length > 4 && passwd.length() < 8) {\n      strength = (strength + 6);\n      log.debug(\"6 points for length (\" + length + \")\");\n    }\n    // length between 8 and 15\n    else if (length > 7 && passwd.length() < 16) {\n      strength = (strength + 12);\n      log.debug(\"12 points for length (\" + length + \")\");\n    }\n    // length 16 or more\n    else if (length > 15) {\n      strength = (strength + 18);\n      log.debug(\"18 points for length (\" + length + \")\");\n    }\n\n    // LETTERS\n    // lower case\n    p = Pattern.compile(\".??[a-z]\");\n    m = p.matcher(passwd);\n    while (m.find()) {\n      lower++;\n    }\n    if (lower > 0) {\n      strength = (strength + 1);\n      log.debug(\"1 point for a lower case character\");\n    }\n\n    // upper case\n    p = Pattern.compile(\".??[A-Z]\");\n    m = p.matcher(passwd);\n    while (m.find()) {\n      upper++;\n    }\n    if (upper > 0) {\n      strength = (strength + 5);\n      log.debug(\"5 points for an upper case character\");\n    }\n\n    // NUMBERS\n    // at least one number\n    p = Pattern.compile(\".??[0-9]\");\n    m = p.matcher(passwd);\n    while (m.find()) {\n      numbers += 1;\n    }\n    if (numbers > 0) {\n      strength = (strength + 5);\n      log.debug(\"5 points for a number\");\n      if (numbers > 1) {\n        strength = (strength + 2);\n        log.debug(\"2 points for at least two numbers\");\n\n        if (numbers > 2) {\n          strength = (strength + 3);\n          log.debug(\"3 points for at least three numbers\");\n        }\n      }\n    }\n\n    // SPECIAL CHAR\n    // at least one special char\n    p = Pattern.compile(\".??[:,!,@,#,$,%,^,&,*,?,_,~]\");\n    m = p.matcher(passwd);\n    while (m.find()) {\n      special += 1;\n    }\n    if (special > 0) {\n      strength = (strength + 5);\n      log.debug(\"5 points for a special character\");\n      if (special > 1) {\n        strength += (strength + 5);\n        log.debug(\"5 points for at least two special characters\");\n      }\n    }\n\n    // COMBOS\n    // both upper and lower case\n    if (upper > 0 && lower > 0) {\n      strength = (strength + 2);\n      log.debug(\"2 combo points for upper and lower letters\");\n    }\n    // both letters and numbers\n    if ((upper > 0 || lower > 0) && numbers > 0) {\n      strength = (strength + 2);\n      log.debug(\"2 combo points for letters and numbers\");\n    }\n    // letters, numbers, and special characters\n    if ((upper > 0 || lower > 0) && numbers > 0 && special > 0) {\n      strength = (strength + 2);\n      log.debug(\"2 combo points for letters, numbers and special chars\");\n    }\n    // upper, lower, numbers, and special characters\n    if (upper > 0 && lower > 0 && numbers > 0 && special > 0) {\n      strength = (strength + 2);\n      log.debug(\"2 combo points for upper and lower case letters, numbers and special chars\");\n    }\n    if (strength < 16) {\n      log.debug(\"very weak\");\n      return VERY_WEAK;\n    } else if (strength > 15 && strength < 25) {\n      log.debug(\"weak\");\n      return WEAK;\n    } else if (strength > 24 && strength < 35) {\n      log.debug(\"mediocre\");\n      return MEDIOCRE;\n    } else if (strength > 34 && strength < 45) {\n      log.debug(\"strong\");\n      return STRONG;\n    } else {\n      log.debug(\"very strong\");\n      return VERY_STRONG;\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6061, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 299, "focalAPIEnd": 328, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()"], "useStart": [299], "useEnd": [338], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ESGF/esgf-node-manager/tree/master/src/java/main/esg/node/filters/UrlResolvingDAO.java", "rawCode": "  /**\n   * Resolves a given string for a (virtual) resource to the \"local\" resource location\n   *\n   * @param input Path or Url to (virtual) resource (described by the DRS taxonomy)\n   * @return Path to local resource referenced\n   */\n  public String resolve(String input) {\n    try {\n      return (urlTestPattern.matcher(input).matches())\n          ? resolveDRSUrl(input)\n          : resolveDRSPath(input);\n    } catch (Throwable t) {\n      return null;\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6062, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "pattern!=null", "guardType": "IF {", "guardExpressionStart": 496, "guardExpressionEnd": 522, "guardBlockStart": 496, "guardBlockEnd": 1147, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 555, "focalAPIEnd": 581, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 638, "followUpCheckExpressionEnd": 666, "followUpCheckBlockStart": 638, "followUpCheckBlockEnd": 951, "use": ["match.start()", "match.group(int)", "match.end()"], "useStart": [758, 868, 923], "useEnd": [779, 890, 942], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/alex73/OmegaT/tree/master/src/org/omegat/gui/tagvalidation/TagValidationFrame.java", "rawCode": "  /**\n   * Formats plain text as html with placeholders and to-remove text in color\n   *\n   * @param str the text to format\n   * @param color the color to use for placeholders\n   * @param placeholderPattern the pattern to decide what is a placeholder\n   * @param removePattern the pattern to decide what text had to be removed.\n   * @return html text\n   */\n  private String formatRemoveTagsAndPlaceholders(\n      String str, String color, Pattern placeholderPattern, Pattern removePattern) {\n    if (removePattern != null) {\n      Matcher removeMatcher = removePattern.matcher(str);\n      String htmlResult = \"\";\n      int pos = 0;\n      while (removeMatcher.find()) {\n        htmlResult +=\n            formatPlaceholders(\n                str.substring(pos, removeMatcher.start()), color, placeholderPattern);\n        htmlResult += \"<font color=\\\"red\\\"><b>\" + htmlize(removeMatcher.group(0)) + \"</b></font>\";\n        pos = removeMatcher.end();\n      }\n      htmlResult += formatPlaceholders(str.substring(pos), color, placeholderPattern);\n      return htmlResult;\n    } else {\n      return formatPlaceholders(str, color, placeholderPattern);\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6063, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 197, "focalAPIEnd": 250, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()"], "useStart": [197], "useEnd": [260], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lievenva/SchemaSpy-ng/tree/master/src/main/java/net/sourceforge/schemaspy/model/TableColumn.java", "rawCode": "  /**\n   * Returns <code>true</code> if tableName.columnName matches the supplied regular expression.\n   *\n   * @param regex\n   * @return\n   */\n  public boolean matches(Pattern regex) {\n    return regex.matcher(getTable().getName() + '.' + getName()).matches();\n  }\n"}, {"dataset": "matcher", "exampleID": 6064, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 6450, "focalAPIEnd": 6492, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 6502, "followUpCheckExpressionEnd": 6518, "followUpCheckBlockStart": 6502, "followUpCheckBlockEnd": 8069, "use": ["match.group(int)", "match.group(int)"], "useStart": [6595, 6660], "useEnd": [6605, 6670], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/metamolecular/opsin/tree/master/opsin-core/src/main/java/uk/ac/cam/ch/wwmm/opsin/ComponentGenerator.java", "rawCode": "  /**\n   * Identifies lambdaConvention elements. The elementsValue is expected to be a comma seperated\n   * lambda values and 0 or more locants. Where a lambda value has the following form: optional\n   * locant, the word lambda and then a number which is the valency specified (with possibly some\n   * attempt to indicate this number is superscripted) If the element is followed by heteroatoms\n   * (possibly multiplied) they are multiplied and the locant/lambda assigned to them Otherwise a\n   * new lambdaConvention element is created with the valency specified by the lambda convention\n   * taking the attribute \"lambda\" In the case where heteroatoms belong to a fused ring system a new\n   * lambdaConvention element is also created. The original locants are retained in the benzo\n   * specific fused ring nomenclature: 2H-5lambda^5-phosphinino[3,2-b]pyran --> 2H 5lambda^5\n   * phosphinino[3,2-b]pyran BUT 1lambda^4,5-Benzodithiepin --> 1lambda^4 1,5-Benzodithiepin\n   *\n   * @param subOrRoot\n   * @throws ComponentGenerationException\n   */\n  private void processLambdaConvention(Element subOrRoot) throws ComponentGenerationException {\n    List<Element> lambdaConventionEls = subOrRoot.getChildElements(LAMBDACONVENTION_EL);\n    boolean fusedRingPresent = false;\n    if (lambdaConventionEls.size() > 0) {\n      if (subOrRoot.getChildElements(GROUP_EL).size() > 1) {\n        fusedRingPresent = true;\n      }\n    }\n    for (Element lambdaConventionEl : lambdaConventionEls) {\n      boolean frontLocantsExpected =\n          false; // Is the lambdaConvention el followed by benz/benzo of a fused ring system (these\n                 // have front locants which correspond to the final fused rings numbering) or by a\n                 // polycylicspiro system\n      String[] lambdaValues =\n          MATCH_COMMA.split(StringTools.removeDashIfPresent(lambdaConventionEl.getValue()));\n      Element possibleHeteroatomOrMultiplier = OpsinTools.getNextSibling(lambdaConventionEl);\n      int heteroCount = 0;\n      int multiplierValue = 1;\n      while (possibleHeteroatomOrMultiplier != null) {\n        if (possibleHeteroatomOrMultiplier.getName().equals(HETEROATOM_EL)) {\n          heteroCount += multiplierValue;\n          multiplierValue = 1;\n        } else if (possibleHeteroatomOrMultiplier.getName().equals(MULTIPLIER_EL)) {\n          multiplierValue =\n              Integer.parseInt(possibleHeteroatomOrMultiplier.getAttributeValue(VALUE_ATR));\n        } else {\n          break;\n        }\n        possibleHeteroatomOrMultiplier = OpsinTools.getNextSibling(possibleHeteroatomOrMultiplier);\n      }\n      boolean assignLambdasToHeteroAtoms = false;\n      if (lambdaValues.length\n          == heteroCount) { // heteroatom and number of locants +lambdas must match\n        if (fusedRingPresent\n            && possibleHeteroatomOrMultiplier != null\n            && possibleHeteroatomOrMultiplier.getName().equals(GROUP_EL)\n            && possibleHeteroatomOrMultiplier\n                .getAttributeValue(SUBTYPE_ATR)\n                .equals(HANTZSCHWIDMAN_SUBTYPE_VAL)) {\n          // You must not set the locants of a HW system which forms a component of a fused ring\n          // system. The locant specified corresponds to the complete fused ring system.\n        } else {\n          assignLambdasToHeteroAtoms = true;\n        }\n      } else if (possibleHeteroatomOrMultiplier != null\n          && ((heteroCount == 0\n                  && OpsinTools.getNextSibling(lambdaConventionEl)\n                      .equals(possibleHeteroatomOrMultiplier)\n                  && fusedRingPresent\n                  && possibleHeteroatomOrMultiplier.getName().equals(GROUP_EL)\n                  && (possibleHeteroatomOrMultiplier.getValue().equals(\"benzo\")\n                      || possibleHeteroatomOrMultiplier.getValue().equals(\"benz\"))\n                  && !OpsinTools.getNextSibling(possibleHeteroatomOrMultiplier)\n                      .getName()\n                      .equals(FUSION_EL)\n                  && !OpsinTools.getNextSibling(possibleHeteroatomOrMultiplier)\n                      .getName()\n                      .equals(LOCANT_EL))\n              || (possibleHeteroatomOrMultiplier.getName().equals(POLYCYCLICSPIRO_EL)\n                  && (possibleHeteroatomOrMultiplier.getAttributeValue(VALUE_ATR).equals(\"spirobi\")\n                      || possibleHeteroatomOrMultiplier\n                          .getAttributeValue(VALUE_ATR)\n                          .equals(\"spiroter\"))))) {\n        frontLocantsExpected =\n            true; // a benzo fused ring e.g. 1lambda4,3-benzothiazole or a symmetrical poly cyclic\n                  // spiro system\n      }\n      List<Element> heteroAtoms =\n          new ArrayList<\n              Element>(); // contains the heteroatoms to apply the lambda values too. Can be empty\n                          // if the values are applied to a group directly rather than to a\n                          // heteroatom\n      if (assignLambdasToHeteroAtoms) { // populate heteroAtoms, multiplied heteroatoms are\n                                        // multiplied out\n        Element multiplier = null;\n        Element heteroatomOrMultiplier = OpsinTools.getNextSibling(lambdaConventionEl);\n        while (heteroatomOrMultiplier != null) {\n          if (heteroatomOrMultiplier.getName().equals(HETEROATOM_EL)) {\n            heteroAtoms.add(heteroatomOrMultiplier);\n            if (multiplier != null) {\n              for (int i = 1; i < Integer.parseInt(multiplier.getAttributeValue(VALUE_ATR)); i++) {\n                Element newHeteroAtom = heteroatomOrMultiplier.copy();\n                OpsinTools.insertBefore(heteroatomOrMultiplier, newHeteroAtom);\n                heteroAtoms.add(newHeteroAtom);\n              }\n              multiplier.detach();\n              multiplier = null;\n            }\n          } else if (heteroatomOrMultiplier.getName().equals(MULTIPLIER_EL)) {\n            if (multiplier != null) {\n              break;\n            } else {\n              multiplier = heteroatomOrMultiplier;\n            }\n          } else {\n            break;\n          }\n          heteroatomOrMultiplier = OpsinTools.getNextSibling(heteroatomOrMultiplier);\n        }\n      }\n\n      for (int i = 0;\n          i < lambdaValues.length;\n          i++) { // assign all the lambdas to heteroatoms or to newly created lambdaConvention\n                 // elements\n        String lambdaValue = lambdaValues[i];\n        Matcher m = matchLambdaConvention.matcher(lambdaValue);\n        if (m.matches()) { // a lambda\n          Attribute valencyChange = new Attribute(LAMBDA_ATR, m.group(2));\n          Attribute locantAtr = null;\n          if (m.group(1) != null) {\n            locantAtr = new Attribute(LOCANT_ATR, m.group(1));\n          }\n          if (frontLocantsExpected) {\n            if (m.group(1) == null) {\n              throw new ComponentGenerationException(\n                  \"Locant not found for lambda convention before a benzo fused ring system\");\n            }\n            lambdaValues[i] = m.group(1);\n          }\n          if (assignLambdasToHeteroAtoms) {\n            Element heteroAtom = heteroAtoms.get(i);\n            heteroAtom.addAttribute(valencyChange);\n            if (locantAtr != null) {\n              heteroAtom.addAttribute(locantAtr);\n            }\n          } else {\n            Element newLambda = new TokenEl(LAMBDACONVENTION_EL);\n            newLambda.addAttribute(valencyChange);\n            if (locantAtr != null) {\n              newLambda.addAttribute(locantAtr);\n            }\n            OpsinTools.insertBefore(lambdaConventionEl, newLambda);\n          }\n        } else { // just a locant e.g 1,3lambda5\n          if (!assignLambdasToHeteroAtoms) {\n            if (!frontLocantsExpected) {\n              throw new ComponentGenerationException(\n                  \"Lambda convention not specified for locant: \" + lambdaValue);\n            }\n          } else {\n            Element heteroAtom = heteroAtoms.get(i);\n            heteroAtom.addAttribute(new Attribute(LOCANT_ATR, lambdaValue));\n          }\n        }\n      }\n      if (!frontLocantsExpected) {\n        lambdaConventionEl.detach();\n      } else {\n        lambdaConventionEl.setName(LOCANT_EL);\n        lambdaConventionEl.setValue(StringTools.arrayToString(lambdaValues, \",\"));\n      }\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6065, "initialization": ["Pattern pattern = compile(*,*)"], "initializationStart": [898], "initializationEnd": [975], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 1075, "focalAPIEnd": 1104, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 1110, "followUpCheckExpressionEnd": 1126, "followUpCheckBlockStart": 1110, "followUpCheckBlockEnd": 1474, "use": ["match.group()"], "useStart": [1154], "useEnd": [1163], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/petalslink/petals-studio/tree/master/plugins/com.ebmwebsourcing.petals.common/src/com/ebmwebsourcing/petals/common/internal/provisional/utils/PetalsRefactoringUtils.java", "rawCode": "  /**\n   * Builds a list of {@link ReplaceEdit} for a refactoring wizard.\n   *\n   * @param text the original text\n   * @param regex the regular expression to replace\n   * @param newValue the new text\n   * @param leftRegex a regular expression that defines a left delimiter (can be null for none)\n   * @param rightRegex a regular expression that defines a right delimiter (can be null for none)\n   * @return a non-null list of Replace edits\n   */\n  public static List<ReplaceEdit> buildReplaceEdits(\n      String text, String regex, String leftRegex, String rightRegex, String newValue) {\n\n    StringBuilder completeRegex = new StringBuilder();\n    if (leftRegex != null) completeRegex.append(leftRegex);\n    completeRegex.append(regex);\n    if (rightRegex != null) completeRegex.append(rightRegex);\n\n    List<ReplaceEdit> edits = new ArrayList<ReplaceEdit>();\n    Pattern completePattern =\n        Pattern.compile(completeRegex.toString(), Pattern.MULTILINE | Pattern.DOTALL);\n    Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE | Pattern.DOTALL);\n    Matcher m = completePattern.matcher(text);\n    while (m.find()) {\n\n      String sequence = m.group();\n      Matcher subMatcher = pattern.matcher(sequence);\n      if (subMatcher.find()) {\n        int start = m.start() + subMatcher.start();\n        int length = subMatcher.group().length();\n\n        ReplaceEdit replaceEdit = new ReplaceEdit(start, length, newValue);\n        edits.add(replaceEdit);\n      }\n    }\n\n    return edits;\n  }\n"}, {"dataset": "matcher", "exampleID": 6066, "initialization": ["Pattern pattern = Pattern.compile(String)", "String input = getMethodName()"], "initializationStart": [1011, 1309], "initializationEnd": [1042, 1326], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 1352, "focalAPIEnd": 1379, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/knutwalker/google-closure-compiler/tree/master/lib/rhino/src/org/mozilla/javascript/RhinoException.java", "rawCode": "  /**\n   * Get the script stack of this exception as an array of {@link ScriptStackElement}s. If\n   * optimization is enabled, this includes java stack elements whose source and method names\n   * suggest they have been generated by the Rhino script compiler.\n   *\n   * @return the script stack for this exception\n   * @since 1.7R3\n   */\n  public ScriptStackElement[] getScriptStack() {\n    List<ScriptStackElement> list = new ArrayList<ScriptStackElement>();\n    ScriptStackElement[][] interpreterStack = null;\n    if (interpreterStackInfo != null) {\n      Evaluator interpreter = Context.createInterpreter();\n      if (interpreter instanceof Interpreter)\n        interpreterStack = ((Interpreter) interpreter).getScriptStackElements(this);\n    }\n    int interpreterStackIndex = 0;\n    StackTraceElement[] stack = getStackTrace();\n    // Pattern to recover function name from java method name -\n    // see Codegen.getBodyMethodName()\n    // kudos to Marc Guillemot for coming up with this\n    Pattern pattern = Pattern.compile(\"_c_(.*)_\\\\d+\");\n    for (StackTraceElement e : stack) {\n      String fileName = e.getFileName();\n      if (e.getMethodName().startsWith(\"_c_\")\n          && e.getLineNumber() > -1\n          && fileName != null\n          && !fileName.endsWith(\".java\")) {\n        String methodName = e.getMethodName();\n        Matcher match = pattern.matcher(methodName);\n        // the method representing the main script is always \"_c_script_0\" -\n        // at least we hope so\n        methodName = !\"_c_script_0\".equals(methodName) && match.find() ? match.group(1) : null;\n        list.add(new ScriptStackElement(fileName, methodName, e.getLineNumber()));\n      } else if (\"org.mozilla.javascript.Interpreter\".equals(e.getClassName())\n          && \"interpretLoop\".equals(e.getMethodName())\n          && interpreterStack != null\n          && interpreterStack.length > interpreterStackIndex) {\n        for (ScriptStackElement elem : interpreterStack[interpreterStackIndex++]) {\n          list.add(elem);\n        }\n      }\n    }\n    return list.toArray(new ScriptStackElement[list.size()]);\n  }\n"}, {"dataset": "matcher", "exampleID": 6067, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 70, "focalAPIEnd": 94, "followUpCheck": "match.find() == false", "checkType": "IF", "followUpCheckExpressionStart": 100, "followUpCheckExpressionEnd": 122, "followUpCheckBlockStart": 100, "followUpCheckBlockEnd": 171, "use": ["match.group(int)"], "useStart": [195], "useEnd": [205], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-6939/src/net/sourceforge/plantuml/graphic/Img.java", "rawCode": "  static HtmlCommand getInstance(String html) {\n    final Matcher m = srcPattern.matcher(html);\n    if (m.find() == false) {\n      return new Text(\"(SYNTAX ERROR)\");\n    }\n    final String src = m.group(1);\n    try {\n      final File f = FileSystem.getInstance().getFile(src);\n      if (f.exists() == false) {\n        return new Text(\"(File not found: \" + f + \")\");\n      }\n      final int vspace = getVspace(html);\n      final ImgValign valign = getValign(html);\n      return new Img(new TileImage(ImageIO.read(f), valign, vspace), src);\n    } catch (IOException e) {\n      return new Text(\"ERROR \" + e.toString());\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6068, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null) && !(input.length()==0)", "guardType": "IF {", "guardExpressionStart": 478, "guardExpressionEnd": 496, "guardBlockStart": 478, "guardBlockEnd": 507, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 657, "focalAPIEnd": 686, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)"], "useStart": [1295, 1371, 1447, 1523, 1602, 1693, 1784, 2054], "useEnd": [1328, 1404, 1480, 1556, 1648, 1739, 1830, 2100], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/tags/kernel-1.2.0-rc02/kernel-util/src/main/java/org/sakaiproject/util/FormattedText.java", "rawCode": "  /**\n   * Prepares the given HTML formatted text for output as part of an HTML document. Makes sure that\n   * links open up in a new window by setting 'target=\"_blank\"' on anchor tags.\n   *\n   * @param value The formatted text to escape\n   * @param supressNewlines If true, remove newlines (\"&lt;br /&gt;\") when escaping.\n   * @return The string to include in an HTML document.\n   */\n  private static String escapeHtmlFormattedText(String value, boolean supressNewlines) {\n    if (value == null) return \"\";\n    if (value.length() == 0) return \"\";\n\n    if (supressNewlines) {\n      // zap HTML line breaks (\"<br />\") into plain-old whitespace\n      value = M_patternTagBr.matcher(value).replaceAll(\" \");\n    }\n\n    // make sure that links open up in a new window. This\n    // makes sure every anchor tag has a blank target.\n    // for example:\n    // <a href=\"http://www.microsoft.com\">Microsoft</a>\n    // becomes:\n    // <a href=\"http://www.microsoft.com\" target=\"_blank\">Microsoft</a>\n    // removed for KNL-526\n    // value = M_patternAnchorTagWithTarget.matcher(value).replaceAll(\"$1$2>\"); // strips out\n    // targets\n    // value = M_patternAnchorTag.matcher(value).replaceAll(\"$1$2$3 target=\\\"_blank\\\">\"); // adds in\n    // blank targets\n    // added for KNL-526\n    String testvalue0 = M_patternAnchorTag.matcher(value).replaceAll(\"$0\");\n    String testvalue1 = M_patternAnchorTag.matcher(value).replaceAll(\"$1\");\n    String testvalue2 = M_patternAnchorTag.matcher(value).replaceAll(\"$2\");\n    String testvalue3 = M_patternAnchorTag.matcher(value).replaceAll(\"$3\");\n\n    String testvalueWO0 = M_patternAnchorTagWithOutTarget.matcher(value).replaceAll(\"$0\");\n    String testvalueWO1 = M_patternAnchorTagWithOutTarget.matcher(value).replaceAll(\"$1\");\n    String testvalueWO2 = M_patternAnchorTagWithOutTarget.matcher(value).replaceAll(\"$2\");\n    // String testvalueWO3 = M_patternAnchorTagWithOutTarget.matcher(value).replaceAll(\"$3\");\n    // String testvalueWO4 = M_patternAnchorTagWithOutTarget.matcher(value).replaceAll(\"$4\");\n\n    Matcher m = M_patternAnchorTagWithOutTarget.matcher(value);\n    if (m.find()) {\n      value = m.replaceAll(\"$1$2 target=\\\"_blank\\\">\"); // adds a target to A tags without one\n    }\n\n    return value;\n  }\n"}, {"dataset": "matcher", "exampleID": 6069, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 119, "focalAPIEnd": 133, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.find()"], "useStart": [154], "useEnd": [162], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sonyfe25cp/EventsMachine/tree/master/gossip/src/main/java/gossip/urlTemp/ChinaNews.java", "rawCode": "  /**\n   * 判断是否是最终页\n   *\n   * @param url\n   * @return Jul 11, 2012\n   */\n  public boolean verify(String url) {\n    m = p.matcher(url);\n    boolean flag = m.find();\n    return flag;\n  }\n"}, {"dataset": "matcher", "exampleID": 6070, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null||input.length()==0)", "guardType": "IF {", "guardExpressionStart": 277, "guardExpressionEnd": 316, "guardBlockStart": 277, "guardBlockEnd": 338, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 355, "focalAPIEnd": 378, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 385, "followUpCheckExpressionEnd": 401, "followUpCheckBlockStart": 385, "followUpCheckBlockEnd": 3890, "use": ["match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)"], "useStart": [614, 1293, 1327, 2106], "useEnd": [624, 1303, 1337, 2116], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spullara/maptool/tree/master/src/net/rptools/maptool/client/functions/MacroLinkFunction.java", "rawCode": "  /**\n   * Runs the macro specified by the link.\n   *\n   * @param link the link to the macro.\n   * @param setVars should the variables be set in the macro context as well as passed in as\n   *     macro.args.\n   */\n  public void runMacroLink(String link, boolean setVars) {\n    if (link == null || link.length() == 0) {\n      return;\n    }\n    Matcher m = macroLink.matcher(link);\n\n    if (m.matches()) {\n      OutputTo outputTo;\n      String macroName = \"\";\n      String args = \"\";\n      Set<String> outputToPlayers = new HashSet<String>();\n\n      if (m.group(1).equalsIgnoreCase(\"macro\")) {\n\n        String who = m.group(3);\n        if (who.equalsIgnoreCase(\"self\")) {\n          outputTo = OutputTo.SELF;\n        } else if (who.equalsIgnoreCase(\"gm\")) {\n          outputTo = OutputTo.GM;\n        } else if (who.equalsIgnoreCase(\"none\")) {\n          outputTo = OutputTo.NONE;\n        } else if (who.equalsIgnoreCase(\"all\") || who.equalsIgnoreCase(\"say\")) {\n          outputTo = OutputTo.ALL;\n        } else if (who.equalsIgnoreCase(\"gm-self\") || who.equalsIgnoreCase(\"gmself\")) {\n          outputTo = OutputTo.SELF_AND_GM;\n        } else if (who.equalsIgnoreCase(\"list\")) {\n          outputTo = OutputTo.LIST;\n        } else {\n          outputTo = OutputTo.NONE;\n        }\n        macroName = m.group(2);\n\n        String val = m.group(5);\n        if (val != null) {\n          try {\n            Double.parseDouble(val);\n            // Do nothing as its a number\n          } catch (NumberFormatException e) {\n            try {\n              val = argsToStrPropList(val);\n            } catch (ParserException e1) {\n              MapTool.addLocalMessage(\"Error running macro link: \" + e1.getMessage());\n            }\n          }\n          args = val;\n          try {\n            JSONObject jobj = JSONObject.fromObject(args);\n            if (jobj.containsKey(\"mlOutputList\")) {\n              outputToPlayers.addAll(jobj.getJSONArray(\"mlOutputList\"));\n            }\n          } catch (Exception e) {\n            // Do nothing as we just dont populate the list.\n          }\n        }\n\n        String[] targets = m.group(4).split(\",\");\n        Zone zone = MapTool.getFrame().getCurrentZoneRenderer().getZone();\n\n        try {\n          for (String t : targets) {\n            if (t.equalsIgnoreCase(\"impersonated\")) {\n              Token token;\n              GUID guid = MapTool.getFrame().getCommandPanel().getIdentityGUID();\n              if (guid != null)\n                token = MapTool.getFrame().getCurrentZoneRenderer().getZone().getToken(guid);\n              else token = zone.resolveToken(MapTool.getFrame().getCommandPanel().getIdentity());\n              MapToolVariableResolver resolver = new MapToolVariableResolver(token);\n              String output = MapTool.getParser().runMacro(resolver, token, macroName, args);\n              doOutput(token, outputTo, output, outputToPlayers); // TODO\n            } else if (t.equalsIgnoreCase(\"selected\")) {\n              for (GUID id : MapTool.getFrame().getCurrentZoneRenderer().getSelectedTokenSet()) {\n                Token token = zone.getToken(id);\n                MapToolVariableResolver resolver = new MapToolVariableResolver(token);\n                String output = MapTool.getParser().runMacro(resolver, token, macroName, args);\n                doOutput(token, outputTo, output, outputToPlayers);\n              }\n            } else {\n              Token token = zone.resolveToken(t);\n              MapToolVariableResolver resolver = new MapToolVariableResolver(token);\n              String output = MapTool.getParser().runMacro(resolver, token, macroName, args);\n              doOutput(token, outputTo, output, outputToPlayers);\n            }\n          }\n        } catch (AbortFunctionException e) {\n          // Do nothing\n        } catch (ParserException e) {\n          MapTool.addLocalMessage(e.getMessage());\n        }\n      }\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6071, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 234, "focalAPIEnd": 273, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 349, "followUpCheckExpressionEnd": 365, "followUpCheckBlockStart": 349, "followUpCheckBlockEnd": 925, "use": ["match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)"], "useStart": [442, 511, 570, 636, 693, 750, 807, 882], "useEnd": [475, 538, 603, 660, 717, 774, 839, 917], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/teamgummy/frameworks_base/tree/master/telephony/java/com/android/internal/telephony/cdma/CdmaMmiCode.java", "rawCode": "  /** Check if provided string contains Mmi code in it and create corresponding Mmi if it does */\n  public static CdmaMmiCode newFromDialString(String dialString, CDMAPhone phone) {\n    Matcher m;\n    CdmaMmiCode ret = null;\n\n    m = sPatternSuppService.matcher(dialString);\n\n    // Is this formatted like a standard supplementary service code?\n    if (m.matches()) {\n      ret = new CdmaMmiCode(phone);\n      ret.poundString = makeEmptyNull(m.group(MATCH_GROUP_POUND_STRING));\n      ret.action = makeEmptyNull(m.group(MATCH_GROUP_ACTION));\n      ret.sc = makeEmptyNull(m.group(MATCH_GROUP_SERVICE_CODE));\n      ret.sia = makeEmptyNull(m.group(MATCH_GROUP_SIA));\n      ret.sib = makeEmptyNull(m.group(MATCH_GROUP_SIB));\n      ret.sic = makeEmptyNull(m.group(MATCH_GROUP_SIC));\n      ret.pwd = makeEmptyNull(m.group(MATCH_GROUP_PWD_CONFIRM));\n      ret.dialingNumber = makeEmptyNull(m.group(MATCH_GROUP_DIALING_NUMBER));\n    }\n\n    return ret;\n  }\n"}, {"dataset": "matcher", "exampleID": 6072, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 262, "focalAPIEnd": 297, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 367, "followUpCheckExpressionEnd": 383, "followUpCheckBlockStart": 367, "followUpCheckBlockEnd": 539, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/crosswire/jsword/tree/master/src/main/java/org/crosswire/common/diff/Patch.java", "rawCode": "  /**\n   * Parse a textual representation of patches and return a List of Patch objects.\n   *\n   * @param input Text representation of patches\n   * @return List of Patch objects\n   */\n  public Patch fromText(String input) {\n    patches.clear();\n\n    Matcher m = patchBoundaryPattern.matcher(input);\n\n    // Add segments before each match found\n    int index = 0;\n    while (m.find()) {\n      int start = m.start();\n      String match = input.substring(index, start);\n      patches.add(new PatchEntry(match));\n      index = start + 1;\n    }\n\n    if (index == 0) {\n      // No match was found, the patch consists of the entire string\n      patches.add(new PatchEntry(input));\n    } else {\n      // Add remaining segment\n      patches.add(new PatchEntry(input.substring(index)));\n    }\n\n    return this;\n  }\n"}, {"dataset": "matcher", "exampleID": 6073, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null) && !(input.length()==0)", "guardType": "IF {", "guardExpressionStart": 478, "guardExpressionEnd": 496, "guardBlockStart": 478, "guardBlockEnd": 507, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 657, "focalAPIEnd": 686, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Pattern.matcher(match)", "Pattern.matcher(match)"], "useStart": [1000, 1077], "useEnd": [1043, 1110], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/sakai-kernel/tree/master/branches/SAK-8391/kernel-util/src/main/java/org/sakaiproject/util/FormattedText.java", "rawCode": "  /**\n   * Prepares the given HTML formatted text for output as part of an HTML document. Makes sure that\n   * links open up in a new window by setting 'target=\"_blank\"' on anchor tags.\n   *\n   * @param value The formatted text to escape\n   * @param supressNewlines If true, remove newlines (\"&lt;br /&gt;\") when escaping.\n   * @return The string to include in an HTML document.\n   */\n  private static String escapeHtmlFormattedText(String value, boolean supressNewlines) {\n    if (value == null) return \"\";\n    if (value.length() == 0) return \"\";\n\n    if (supressNewlines) {\n      // zap HTML line breaks (\"<br />\") into plain-old whitespace\n      value = M_patternTagBr.matcher(value).replaceAll(\" \");\n    }\n\n    // make sure that links open up in a new window. This\n    // makes sure every anchor tag has a blank target.\n    // for example:\n    // <a href=\"http://www.microsoft.com\">Microsoft</a>\n    // becomes:\n    // <a href=\"http://www.microsoft.com\" target=\"_blank\">Microsoft</a>\n    value = M_patternAnchorTagWithTarget.matcher(value).replaceAll(\"$1$2>\");\n    value = M_patternAnchorTag.matcher(value).replaceAll(\"$1$2$3 target=\\\"_blank\\\">\");\n\n    return value;\n  }\n"}, {"dataset": "matcher", "exampleID": 6074, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null||input.length()==0)", "guardType": "IF {", "guardExpressionStart": 42, "guardExpressionEnd": 75, "guardBlockStart": 42, "guardBlockEnd": 89, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 101, "focalAPIEnd": 125, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()"], "useStart": [101], "useEnd": [135], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cloudsmith/geppetto/tree/master/org.cloudsmith.geppetto.pp.dsl/src/org/cloudsmith/geppetto/pp/dsl/validation/PPPatternHelper.java", "rawCode": "  public boolean isREGEXP(String s) {\n    if (s == null || s.length() == 0) return false;\n    return regexpPattern.matcher(s).matches();\n  }\n"}, {"dataset": "matcher", "exampleID": 6075, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 265, "focalAPIEnd": 291, "followUpCheck": "!match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 299, "followUpCheckExpressionEnd": 316, "followUpCheckBlockStart": 299, "followUpCheckBlockEnd": 326, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/ProcfsBasedProcessTree.java", "rawCode": "  /** Get the list of all processes in the system. */\n  private List<String> getProcessList() {\n    String[] processDirs = (new File(procfsDir)).list();\n    List<String> processList = new ArrayList<String>();\n\n    for (String dir : processDirs) {\n      Matcher m = numberPattern.matcher(dir);\n      if (!m.matches()) continue;\n      try {\n        if ((new File(procfsDir, dir)).isDirectory()) {\n          processList.add(dir);\n        }\n      } catch (SecurityException s) {\n        // skip this process\n      }\n    }\n    return processList;\n  }\n"}, {"dataset": "matcher", "exampleID": 6076, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [143], "initializationEnd": [167], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 177, "focalAPIEnd": 199, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()", "match.groupCount()", "match.group(int)", "pattern.matcher(String)", "match.matches()", "match.groupCount()", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "pattern.matcher(String)", "match.matches()", "match.groupCount()", "match.group(int)", "match.group(int)", "pattern.matcher(String)", "match.matches()"], "useStart": [216, 250, 296, 361, 397, 431, 475, 513, 549, 585, 621, 732, 768, 802, 842, 871, 1240, 1280], "useEnd": [227, 264, 306, 380, 408, 445, 485, 523, 559, 595, 631, 751, 779, 816, 852, 881, 1263, 1291], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/robovm/robovm/tree/master/tests/libcore/luni/src/test/java/org/apache/harmony/regex/tests/java/util/regex/Pattern2Test.java", "rawCode": "  public void testCapturingGroups() throws PatternSyntaxException {\n    Pattern p;\n    Matcher m;\n\n    // Test simple capturing groups\n    p = Pattern.compile(\"(a+)b\");\n    m = p.matcher(\"aaaaaaaab\");\n    assertTrue(m.matches());\n    assertEquals(1, m.groupCount());\n    assertEquals(\"aaaaaaaa\", m.group(1));\n\n    p = Pattern.compile(\"((an)+)((as)+)\");\n    m = p.matcher(\"ananas\");\n    assertTrue(m.matches());\n    assertEquals(4, m.groupCount());\n    assertEquals(\"ananas\", m.group(0));\n    assertEquals(\"anan\", m.group(1));\n    assertEquals(\"an\", m.group(2));\n    assertEquals(\"as\", m.group(3));\n    assertEquals(\"as\", m.group(4));\n\n    // Test grouping without capture (?:...)\n    p = Pattern.compile(\"(?:(?:an)+)(as)\");\n    m = p.matcher(\"ananas\");\n    assertTrue(m.matches());\n    assertEquals(1, m.groupCount());\n    assertEquals(\"as\", m.group(1));\n    try {\n      m.group(2);\n      fail(\"expected IndexOutOfBoundsException\");\n    } catch (IndexOutOfBoundsException ioobe) {\n      // expected\n    }\n\n    // Test combination of grouping and capture\n    // TODO\n\n    // Test \\<num> sequence with capturing and non-capturing groups\n    // TODO\n\n    // Test \\<num> with <num> out of range\n    p = Pattern.compile(\"((an)+)as\\\\1\");\n    m = p.matcher(\"ananasanan\");\n    assertTrue(m.matches());\n\n    try {\n      p = Pattern.compile(\"((an)+)as\\\\4\");\n      fail(\"expected PatternSyntaxException\");\n    } catch (PatternSyntaxException pse) {\n      // expected\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6077, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 49, "focalAPIEnd": 76, "followUpCheck": "match.group(1) == null", "checkType": "IF", "followUpCheckExpressionStart": 211, "followUpCheckExpressionEnd": 234, "followUpCheckBlockStart": 211, "followUpCheckBlockEnd": 322, "use": ["match.find()", "match.group(int)"], "useStart": [101, 215], "useEnd": [109, 225], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7650/src/net/sourceforge/plantuml/FileGroup.java", "rawCode": "  private void recurse() {\n    final Matcher m = predirPath.matcher(pattern);\n    final boolean ok = m.find();\n    if (ok == false) {\n      throw new IllegalArgumentException();\n    }\n    final File parent;\n    if (m.group(1) == null) {\n      parent = new File(\".\");\n    } else {\n      parent = new File(m.group(1));\n    }\n    initWithDoubleStar(parent);\n  }\n"}, {"dataset": "matcher", "exampleID": 6078, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["Log.error(String)"], "tryExpressionStart": 560, "tryExpressionEnd": 564, "tryBlockStart": 560, "tryBlockEnd": 1833, "catchExpressionStart": 1729, "catchExpressionEnd": 1751, "catchBlockStart": 1729, "catchBlockEnd": 1833, "exceptionHandlingCallStart": [1759], "exceptionHandlingCallEnd": [1826], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(input)!=null", "guardType": "LOOP {", "guardExpressionStart": 683, "guardExpressionEnd": 724, "guardBlockStart": 683, "guardBlockEnd": 1699, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 754, "focalAPIEnd": 795, "followUpCheck": "!match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 805, "followUpCheckExpressionEnd": 822, "followUpCheckBlockStart": 805, "followUpCheckBlockEnd": 915, "use": ["match.group(int)", "match.group(int)"], "useStart": [974, 1411], "useEnd": [984, 1421], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dimalabs/stratosphere-iterations/tree/master/nephele/nephele-clustermanager/src/main/java/eu/stratosphere/nephele/instance/cluster/ClusterManager.java", "rawCode": "  /** Reads the IP to instance type mapping from the slave file. */\n  private void loadIPToInstanceTypeMapping() {\n\n    final String configDir = GlobalConfiguration.getString(CONFIG_DIR_KEY, null);\n    if (configDir == null) {\n      LOG.error(\"Cannot find configuration directory to read IP to instance type mapping\");\n      return;\n    }\n\n    final File slaveFile = new File(configDir + File.separator + SLAVE_FILE_NAME);\n    if (!slaveFile.exists()) {\n      LOG.error(\"Cannot access slave file to read IP to instance type mapping\");\n      return;\n    }\n\n    try {\n\n      final BufferedReader input = new BufferedReader(new FileReader(slaveFile));\n\n      String line = null;\n\n      while ((line = input.readLine()) != null) {\n\n        final Matcher m = IP_TO_INSTANCE_TYPE_PATTERN.matcher(line);\n        if (!m.matches()) {\n          LOG.error(\"Entry does not match format: \" + line);\n          continue;\n        }\n        InetAddress address = null;\n        String host = m.group(1);\n        try {\n          final int pos = host.lastIndexOf('/');\n          if (pos != -1) {\n            host = host.substring(pos + 1);\n          }\n          address = InetAddress.getByName(host);\n        } catch (UnknownHostException e) {\n          LOG.error(\"Cannot resolve \" + host + \" to a hostname/IP address\", e);\n          continue;\n        }\n\n        InstanceType instanceType = null;\n        String instanceTypeName = m.group(2);\n        if (instanceTypeName != null && instanceTypeName.length() > 0) {\n\n          instanceType = getInstanceTypeByName(instanceTypeName);\n          if (instanceType != null) {\n            this.ipToInstanceTypeMapping.put(address, instanceType);\n          }\n        }\n      }\n\n      input.close();\n\n    } catch (IOException e) {\n      LOG.error(\"Cannot load IP to instance type mapping from file \" + e);\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6079, "initialization": ["String input = new String(*,String)", "Pattern pattern = Pattern.compile(String)"], "initializationStart": [198, 261], "initializationEnd": [237, 295], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 319, "focalAPIEnd": 331, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.find()", "match.group(int)"], "useStart": [337, 358], "useEnd": [345, 368], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-6242/src/net/sourceforge/plantuml/cucadiagram/dot/CucaDiagramFileMaker.java", "rawCode": "  public static String getSvg(UGraphicSvg ug) throws IOException {\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ug.createXml(baos);\n    baos.close();\n    final String s = new String(baos.toByteArray(), \"UTF-8\");\n    final Pattern p = Pattern.compile(\"(?i)<g\\\\W.*</g>\");\n    final Matcher m = p.matcher(s);\n    m.find();\n    return m.group(0);\n  }\n"}, {"dataset": "matcher", "exampleID": 6080, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 83, "focalAPIEnd": 111, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 117, "followUpCheckExpressionEnd": 130, "followUpCheckBlockStart": 117, "followUpCheckBlockEnd": 156, "use": ["match.group(int)"], "useStart": [145], "useEnd": [155], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ESGF/esgf-node-manager/tree/master/src/java/main/esg/node/filters/AccessLoggingDAO.java", "rawCode": "  private String strip(String url) {\n    String strippedUrl = url;\n    Matcher m = urlStripPattern.matcher(url);\n    if (m.find()) strippedUrl = m.group(3);\n    return strippedUrl;\n  }\n"}, {"dataset": "matcher", "exampleID": 6081, "initialization": ["String input = ZipEntry.getName()"], "initializationStart": [372], "initializationEnd": [384], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 415, "focalAPIEnd": 440, "followUpCheck": "match", "checkType": "IF", "followUpCheckExpressionStart": 458, "followUpCheckExpressionEnd": 469, "followUpCheckBlockStart": 458, "followUpCheckBlockEnd": 599, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/FinamTrade/bustard/tree/master/bustard-core/src/main/java/ru/finam/bustard/codegen/ClasspathFileRetriever.java", "rawCode": "  private static Collection<String> getResourcesLinesFromJarFile(File file, Pattern pattern)\n      throws IOException {\n    final ArrayList<String> lines = Lists.newArrayList();\n    ZipFile zf = new ZipFile(file);\n    final Enumeration e = zf.entries();\n    while (e.hasMoreElements()) {\n      final ZipEntry ze = (ZipEntry) e.nextElement();\n      final String fileName = ze.getName();\n      final boolean accept = pattern.matcher(fileName).matches();\n      if (accept) {\n        lines.addAll(\n            CharStreams.readLines(new InputStreamReader(zf.getInputStream(ze), Charsets.UTF_8)));\n      }\n    }\n    zf.close();\n    return lines;\n  }\n"}, {"dataset": "matcher", "exampleID": 6082, "initialization": ["String input = String.substring(int,int)"], "initializationStart": [249], "initializationEnd": [285], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["input.indexOf(String)", "input.lastIndexOf(String)", "input.substring(int,int)"], "configurationStart": [115, 172, 249], "configurationEnd": [132, 193, 285], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 360, "focalAPIEnd": 392, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 398, "followUpCheckExpressionEnd": 411, "followUpCheckBlockStart": 398, "followUpCheckBlockEnd": 541, "use": ["match.group()", "match.replaceAll(String)"], "useStart": [451, 503], "useEnd": [460, 519], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wso2/tools/tree/master/ide/eclipse/jaggery/org.eclipse.php.core/src/org/eclipse/php/internal/core/typeinference/evaluators/phpdoc/PHPDocClassVariableEvaluator.java", "rawCode": "  public static MultiTypeType getArrayType(String type, IType currentNamespace, int offset) {\n    int beginIndex = type.indexOf(\"[\") + 1; // $NON-NLS-1$\n    int endIndex = type.lastIndexOf(\"]\"); // $NON-NLS-1$\n    if (endIndex != -1) {\n      type = type.substring(beginIndex, endIndex);\n    }\n    MultiTypeType arrayType = new MultiTypeType();\n    Matcher m = ARRAY_TYPE_PATTERN.matcher(type);\n    if (m.find()) {\n      arrayType.addType(getArrayType(m.group(), currentNamespace, offset));\n      type = m.replaceAll(\"\"); // $NON-NLS-1$\n    }\n    String[] typeNames = type.split(\",\"); // $NON-NLS-1$\n    for (String name : typeNames) {\n      if (!\"\".equals(name)) { // $NON-NLS-1$\n\n        if (name.indexOf(NamespaceReference.NAMESPACE_SEPARATOR) > 0 && currentNamespace != null) {\n          // check if the first part is an\n          // alias,then get the full name\n          ModuleDeclaration moduleDeclaration =\n              SourceParserUtil.getModuleDeclaration(currentNamespace.getSourceModule());\n          String prefix = name.substring(0, name.indexOf(NamespaceReference.NAMESPACE_SEPARATOR));\n          final Map<String, UsePart> result =\n              PHPModelUtils.getAliasToNSMap(\n                  prefix, moduleDeclaration, offset, currentNamespace, true);\n          if (result.containsKey(prefix)) {\n            String fullName = result.get(prefix).getNamespace().getFullyQualifiedName();\n            name = name.replace(prefix, fullName);\n            if (name.charAt(0) != NamespaceReference.NAMESPACE_SEPARATOR) {\n              name = NamespaceReference.NAMESPACE_SEPARATOR + name;\n            }\n          }\n        }\n        arrayType.addType(getEvaluatedType(name, currentNamespace));\n      }\n    }\n    return arrayType;\n  }\n"}, {"dataset": "matcher", "exampleID": 6083, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 65, "focalAPIEnd": 92, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.lookingAt()"], "useStart": [65], "useEnd": [104], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bryanjimenez/empanada/tree/master/hadoop/hadoop-1.2.1/src/tools/org/apache/hadoop/tools/rumen/HadoopLogsAnalyzer.java", "rawCode": "  private boolean apparentXMLFileStart(String line) {\n    return xmlFilePrefix.matcher(line).lookingAt();\n  }\n"}, {"dataset": "matcher", "exampleID": 6084, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null)", "guardType": "IF {", "guardExpressionStart": 180, "guardExpressionEnd": 197, "guardBlockStart": 180, "guardBlockEnd": 210, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 228, "focalAPIEnd": 251, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.matches()"], "useStart": [265], "useEnd": [276], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jsvm/JSVM/tree/master/WEB-INF/src/org/jsvm/util/FileUtil.java", "rawCode": "  /**\n   * Return file name, exclude file path.\n   *\n   * @param path\n   * @return\n   * @see #getFilePath(String)\n   */\n  public static String getFileName(final String path) {\n    if (path == null) return path;\n\n    Matcher m = REGX_PATH.matcher(path);\n\n    return m.matches() ? m.group(2) : path;\n  }\n"}, {"dataset": "matcher", "exampleID": 6085, "initialization": ["String input = HttpServletRequest.getRequestURI()", "String input = substring(*)"], "initializationStart": [204, 240], "initializationEnd": [227, 288], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["input.substring(*)"], "configurationStart": [240], "configurationEnd": [288], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 307, "focalAPIEnd": 342, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 349, "followUpCheckExpressionEnd": 365, "followUpCheckBlockStart": 349, "followUpCheckBlockEnd": 466, "use": ["match.group(int)"], "useStart": [398], "useEnd": [408], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sdorra/scm-manager/tree/master/scm-core/src/main/java/sonia/scm/web/filter/RegexPermissionFilter.java", "rawCode": "  /**\n   * Method description\n   *\n   * @param request\n   * @return\n   */\n  @Override\n  protected Repository getRepository(HttpServletRequest request) {\n    Repository repository = null;\n    String uri = request.getRequestURI();\n\n    uri = uri.substring(request.getContextPath().length());\n\n    Matcher m = PATTERN_REPOSITORYNAME.matcher(uri);\n\n    if (m.matches()) {\n      String repositoryname = m.group(1);\n\n      repository = getRepository(repositoryname);\n    }\n\n    return repository;\n  }\n"}, {"dataset": "matcher", "exampleID": 6086, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 117, "focalAPIEnd": 137, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 143, "followUpCheckExpressionEnd": 168, "followUpCheckBlockStart": 143, "followUpCheckBlockEnd": 237, "use": ["match.group(int)"], "useStart": [207], "useEnd": [229], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stefanotravelli/seam-2.2/tree/master/src/ioc/org/jboss/seam/ioc/microcontainer/SeamComponentRegistryPlugin.java", "rawCode": "  protected static Boolean parseCreate(String name) {\n    Boolean create = Boolean.TRUE;\n    Matcher createMatcher = CREATE.matcher(name);\n    if (createMatcher.find()) {\n      create = Boolean.parseBoolean(createMatcher.group(1));\n    }\n    return create;\n  }\n"}, {"dataset": "matcher", "exampleID": 6087, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [868], "initializationEnd": [898], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null||input.equals(\"\",))", "guardType": "IF {", "guardExpressionStart": 537, "guardExpressionEnd": 597, "guardBlockStart": 537, "guardBlockEnd": 630, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 930, "focalAPIEnd": 971, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 1122, "followUpCheckExpressionEnd": 1152, "followUpCheckBlockStart": 1122, "followUpCheckBlockEnd": 2649, "use": ["match.group(int)", "match.group(int)"], "useStart": [1171, 1225], "useEnd": [1195, 1249], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IQSS/dvn/tree/master/src/DVN-ingest/src/edu/harvard/iq/dvn/ingest/statdataio/impl/plugins/spss/SPSSFileReader.java", "rawCode": "  int read_ValLabels(String valLabelsCommand) {\n\n    int readStatus = 0;\n\n    Map<String, Map<String, String>> valueLabelTable =\n        new LinkedHashMap<String, Map<String, String>>();\n    Map<String, String> valueVariableMappingTable = new LinkedHashMap<String, String>();\n\n    // Value Labels are referenced by the (declared) variable names,\n    // followed by a number of value-\"label\" pairs; for every variable\n    // the entry is terminated with a \"/\".\n\n    dbgLog.fine(\"parsing \" + valLabelsCommand + \" for value labels.\");\n\n    if (valLabelsCommand == null || valLabelsCommand.equals(\"\")) {\n      return readStatus;\n    }\n\n    String varName = null;\n    String valLabelDeclaration = null;\n\n    String varValue = null;\n    String valueLabel = null;\n\n    int labelCounter = 0;\n\n    String valLabelRegex = \"\\\\s*(\\\\S+)\\\\s+([^/]+)/\";\n    Pattern valLabelPattern = Pattern.compile(valLabelRegex);\n    Matcher valLabelMatcher = valLabelPattern.matcher(valLabelsCommand);\n\n    String labelDeclarationRegex = \"\\\\s*(\\\\S+)\\\\s+(\\\"[^\\\"]*\\\")\";\n    Pattern labelDeclarationPattern = Pattern.compile(labelDeclarationRegex);\n\n    while (valLabelMatcher.find()) {\n      varName = valLabelMatcher.group(1);\n      valLabelDeclaration = valLabelMatcher.group(2);\n\n      dbgLog.fine(\"found value label declaration for \" + varName + \": \" + valLabelDeclaration);\n\n      Map<String, String> valueLabelPairs = new LinkedHashMap<String, String>();\n\n      Matcher labelDeclarationMatcher = labelDeclarationPattern.matcher(valLabelDeclaration);\n\n      int localLabelCounter = 0;\n\n      while (labelDeclarationMatcher.find()) {\n        varValue = labelDeclarationMatcher.group(1);\n        valueLabel = labelDeclarationMatcher.group(2);\n\n        dbgLog.fine(\"found label \" + valueLabel + \" for value \" + varValue);\n\n        Boolean isNumeric = false; // TODO: !\n        if (isNumeric) {\n          // Numeric variable:\n          dbgLog.fine(\"processing numeric value label\");\n          valueLabelPairs.put(doubleNumberFormatter.format(new Double(varValue)), valueLabel);\n        } else {\n          // String variable\n          dbgLog.fine(\"processing string value label\");\n          varValue = varValue.replaceFirst(\"^[\\\"']\", \"\");\n          varValue = varValue.replaceFirst(\"[\\\"']$\", \"\");\n\n          valueLabelPairs.put(varValue, valueLabel);\n        }\n\n        localLabelCounter++;\n      }\n\n      if (localLabelCounter > 0) {\n        valueLabelTable.put(varName, valueLabelPairs);\n        valueVariableMappingTable.put(varName, varName);\n        labelCounter += localLabelCounter;\n      }\n\n      // TODO:\n      // Do SPSS cards support shared value label sets -- ?\n\n    }\n\n    if (labelCounter > 0) {\n      smd.setValueLabelTable(valueLabelTable);\n      smd.setValueLabelMappingTable(valueVariableMappingTable);\n      readStatus = labelCounter;\n    }\n\n    // TODO:\n    // Better validation, error reporting.\n\n    return readStatus;\n  }\n"}, {"dataset": "matcher", "exampleID": 6088, "initialization": ["String input = HttpServletRequest.getHeader(String)"], "initializationStart": [320], "initializationEnd": [351], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input.indexOf(\"KHTML\",)!=-1) && !(input.indexOf(\"Opera\",)!=-1)", "guardType": "IF {", "guardExpressionStart": 385, "guardExpressionEnd": 419, "guardBlockStart": 385, "guardBlockEnd": 435, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 564, "focalAPIEnd": 592, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 598, "followUpCheckExpressionEnd": 619, "followUpCheckBlockStart": 598, "followUpCheckBlockEnd": 692, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/branches/DEV_v1_8/src/util/misc/UserAgent.java", "rawCode": "  /**\n   * @param request the request to analyse the user-agent header of.\n   * @return A string identifying the browser that made the request, of the form gecko-1-8 or\n   *     ie-5[space]ie-5-5, or empty string if unknown\n   */\n  public static String getBrowserString(HttpServletRequest request) {\n    String sAgent = request.getHeader(\"user-agent\");\n    // Filter troublemakers\n    if (sAgent.indexOf(\"KHTML\") != -1) return \"khtml\";\n    if (sAgent.indexOf(\"Opera\") != -1) return \"opera\";\n\n    // Check version of our two supported browsers\n    Matcher mGecko = GECKOVERSION.matcher(sAgent);\n    if (mGecko.matches()) {\n      return \"gecko-\" + mGecko.group(1) + \"-\" + mGecko.group(2);\n    }\n    Matcher mIE = IEVERSION.matcher(sAgent);\n    if (mIE.matches()) {\n      return \"winie-\" + mIE.group(1); // Major verison only\n    }\n\n    return \"\";\n  }\n"}, {"dataset": "matcher", "exampleID": 6089, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "input.indexOf(\":ip_addr\",)>0", "guardType": "IF {", "guardExpressionStart": 488, "guardExpressionEnd": 521, "guardBlockStart": 488, "guardBlockEnd": 616, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 538, "focalAPIEnd": 559, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 622, "followUpCheckExpressionEnd": 642, "followUpCheckBlockStart": 622, "followUpCheckBlockEnd": 1439, "use": ["match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)"], "useStart": [754, 820, 886, 952, 1018], "useEnd": [768, 834, 900, 966, 1032], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/DSpace/DSpace/tree/master/dspace-api/src/main/java/org/dspace/app/statistics/LogAnalyser.java", "rawCode": "  /**\n   * split the given line into it's relevant segments if applicable (i.e. the line matches the\n   * required regular expression.\n   *\n   * @param line the line to be segmented\n   * @return a Log Line object for the given line\n   */\n  public static LogLine getLogLine(String line) {\n    // FIXME: consider moving this code into the LogLine class. To do this\n    // we need to much more carefully define the structure and behaviour\n    // of the LogLine class\n    Matcher match;\n\n    if (line.indexOf(\":ip_addr\") > 0) {\n      match = valid14.matcher(line);\n    } else {\n      match = valid13.matcher(line);\n    }\n\n    if (match.matches()) {\n      // set up a new log line object\n      LogLine logLine =\n          new LogLine(\n              parseDate(match.group(1).trim()),\n              LogManager.unescapeLogField(match.group(2)).trim(),\n              LogManager.unescapeLogField(match.group(3)).trim(),\n              LogManager.unescapeLogField(match.group(4)).trim(),\n              LogManager.unescapeLogField(match.group(5)).trim());\n\n      return logLine;\n    } else {\n      match = validBase.matcher(line);\n      if (match.matches()) {\n        LogLine logLine =\n            new LogLine(\n                parseDate(match.group(1).trim()),\n                LogManager.unescapeLogField(match.group(2)).trim(),\n                null,\n                null,\n                null);\n        return logLine;\n      }\n      return null;\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6090, "initialization": ["String input = GroovyScript.getSource()"], "initializationStart": [127], "initializationEnd": [145], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "input!=null", "guardType": "IF {", "guardExpressionStart": 105, "guardExpressionEnd": 154, "guardBlockStart": 105, "guardBlockEnd": 374, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 194, "focalAPIEnd": 252, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 260, "followUpCheckExpressionEnd": 295, "followUpCheckBlockStart": 260, "followUpCheckBlockEnd": 368, "use": ["match.group(int)"], "useStart": [329], "useEnd": [358], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Union-Investment/Crud2Go/tree/master/eai-portal-xsd-crudportlet/src/main/java/de/unioninvestment/eai/portal/portlet/crud/config/visitor/DatasourceNameCollectingVisitor.java", "rawCode": "  private void visitScriptConfig(ScriptConfig config) {\n    GroovyScript script = config.getValue();\n    if (script != null && script.getSource() != null) {\n      Matcher datasourceNameFinder = DATASOURCE_NAME_FINDER_PATTERN.matcher(script.getSource());\n      while (datasourceNameFinder.find()) {\n        this.addDataSourceName(datasourceNameFinder.group(1));\n      }\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6091, "initialization": ["String input = IfManager.readLine()"], "initializationStart": [63], "initializationEnd": [80], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null)", "guardType": "IF {", "guardExpressionStart": 86, "guardExpressionEnd": 100, "guardBlockStart": 86, "guardBlockEnd": 127, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 145, "focalAPIEnd": 169, "followUpCheck": "match.find()", "checkType": "IF", "followUpCheckExpressionStart": 175, "followUpCheckExpressionEnd": 188, "followUpCheckBlockStart": 175, "followUpCheckBlockEnd": 226, "use": ["manageDefine(match)", "manageUndef(match)"], "useStart": [204, 294], "useEnd": [219, 308], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7500/src/net/sourceforge/plantuml/preproc/Preprocessor.java", "rawCode": "  public String readLine() throws IOException {\n    String s = source.readLine();\n    if (s == null) {\n      return null;\n    }\n\n    Matcher m = definePattern.matcher(s);\n    if (m.find()) {\n      return manageDefine(m);\n    }\n\n    m = undefPattern.matcher(s);\n    if (m.find()) {\n      return manageUndef(m);\n    }\n\n    s = defines.applyDefines(s);\n    return s;\n  }\n"}, {"dataset": "matcher", "exampleID": 6092, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [391], "initializationEnd": [423], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "pattern.matcher(input,).matches() && (input)!=null", "guardType": "LOOP {", "guardExpressionStart": 829, "guardExpressionEnd": 866, "guardBlockStart": 829, "guardBlockEnd": 4539, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 1434, "focalAPIEnd": 1458, "followUpCheck": "match.group(2) != null", "checkType": "IF", "followUpCheckExpressionStart": 3971, "followUpCheckExpressionEnd": 3994, "followUpCheckBlockStart": 3971, "followUpCheckBlockEnd": 4149, "use": ["match.matches()", "match.group(int)", "match.matches()", "match.group(int)", "match.matches()", "match.group(int)", "match.group(int)", "match.group(int)", "match.group(int)"], "useStart": [1434, 1742, 2045, 3059, 3367, 3947, 3975, 4205, 4233], "useEnd": [1468, 1752, 2079, 3069, 3401, 3957, 3985, 4215, 4243], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/istlab/Alitheia-Core/tree/master/alitheia/core/src/main/java/eu/sqooss/impl/service/tds/diff/UnifiedDiffParser.java", "rawCode": "  /** Parse a unified diff and return true on success or false and set the error message. */\n  public boolean parseDiff() {\n    // Don't re-parse the parsed diff\n    if (parsed) return true;\n\n    Pattern chunkStart = Pattern.compile(diffChunkStart);\n    Pattern propChunk = Pattern.compile(propChunkStart);\n    Pattern fileTarget = Pattern.compile(chunkFileTarget);\n    Pattern fileSource = Pattern.compile(chunkFileSource);\n    Pattern idx = Pattern.compile(index);\n    Pattern equals = Pattern.compile(eqs);\n\n    Matcher m = null;\n\n    BufferedReader r = new BufferedReader(new StringReader(theDiff));\n    String line;\n\n    boolean diffStart = false, chnkStart = false;\n    StringBuffer curChunkText = null;\n    String curPath = null;\n    DiffChunkImpl curChunk = null;\n    List<DiffChunk> curChunkList = null;\n    try {\n      while ((line = r.readLine()) != null) {\n        /*\n         * Skip SVN introduced lines like\n         * Index: specs/src/eu/sqooss/impl/service/dsl/SpRevision.java\n         * ===========================================================\n         */\n        if (idx.matcher(line).matches() || equals.matcher(line).matches()) {\n          continue;\n        }\n\n        /* Match lines like\n         * --- specs/src/eu/sqooss/impl/service/dsl/SpRevision.java\n         *\n         *\n         * and record file name. Match either of those 2 lines\n         * signifies start of parsing chunks\n         */\n        if (fileSource.matcher(line).matches()) {\n          // New group found\n          if (diffStart == true && curChunkList.size() != 0) {\n            diffChunks.put(curPath, curChunkList);\n          }\n\n          m = fileSource.matcher(line);\n          m.matches();\n          curPath = FileUtils.appendPath(basePath, m.group(1));\n          changedPaths.add(curPath);\n          curChunkList = new ArrayList<DiffChunk>();\n          diffStart = true;\n          continue;\n        }\n        /* those lines are not really interesting\n         * +++ specs/src/eu/sqooss/impl/service/dsl/SpRevision.java\n         */\n        if (fileTarget.matcher(line).matches()) {\n          continue;\n        }\n\n        /*\n         * Match a chunk describing a property change\n         * (this is SVN specific code)\n         * Property changes on: ProjectFile.java\n         */\n        if (propChunk.matcher(line).matches()) {\n          /* Match */\n          if (chnkStart == true) {\n            curChunk.setChunk(curChunkText.toString());\n            curChunkList.add(curChunk);\n          }\n\n          chnkStart = true;\n          curChunk = new DiffChunkImpl();\n          curChunk.setDiffOp(DiffOp.UNDEF);\n          curChunkText = new StringBuffer();\n\n          /* If the property change is the only thing\n           * appearing in the diff, we need to start\n           * parsing and init some variables first.\n           */\n          if (!diffStart) {\n            curChunkList = new ArrayList<DiffChunk>();\n            diffStart = true;\n            m = propChunk.matcher(line);\n            m.matches();\n            curPath = FileUtils.appendPath(basePath, m.group(1));\n            changedPaths.add(curPath);\n          }\n        }\n\n        if (!diffStart) {\n          error = \"Not a chunk header: \" + line;\n          return false;\n        }\n\n        /* Match chunk start lines like\n         * @@ -111,10 +111,10 @@ or\n         * @@ -1 +1 @@\n         */\n        if (chunkStart.matcher(line).matches()) {\n\n          if (chnkStart == true) {\n            curChunk.setChunk(curChunkText.toString());\n            curChunkList.add(curChunk);\n          }\n\n          chnkStart = true;\n          curChunk = new DiffChunkImpl();\n          m = chunkStart.matcher(line);\n          // We already know that it matches, just trigger the group extraction\n          m.matches();\n\n          // Unified diffs do not support this\n          curChunk.setDiffOp(DiffOp.UNDEF);\n          curChunk.setPath(curPath);\n          curChunk.setSourceStartLine(Integer.parseInt(m.group(1)));\n          if (m.group(2) != null) {\n            curChunk.setSourceLenght(Integer.parseInt(m.group(2).substring(1)));\n          } else {\n            curChunk.setSourceLenght(0);\n          }\n          curChunk.setTargetStartLine(Integer.parseInt(m.group(3)));\n          if (m.group(4) != null) {\n            curChunk.setTargetLength(Integer.parseInt(m.group(4).substring(1)));\n          } else {\n            curChunk.setTargetLength(0);\n          }\n          curChunkText = new StringBuffer();\n          continue;\n        }\n\n        curChunkText.append(line).append(\"\\n\");\n      }\n    } catch (IOException e) {\n      error = \"Error reading diff file\";\n      return false;\n    }\n    // Clean up\n    if (curChunk != null) {\n      curChunk.setChunk(curChunkText.toString());\n      curChunkList.add(curChunk);\n      diffChunks.put(curPath, curChunkList);\n    } else {\n      // This means that the actual diff was empty\n      List<DiffChunk> l = Collections.emptyList();\n      diffChunks.put(curPath, l);\n    }\n\n    // Don't hold up space now that the diff is parsed\n    theDiff = null;\n    parsed = true;\n    return true;\n  }\n"}, {"dataset": "matcher", "exampleID": 6093, "initialization": ["String input = Subfield.getValue()", "Pattern pattern = Pattern.compile(String)"], "initializationStart": [90, 121], "initializationEnd": [103, 144], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 162, "focalAPIEnd": 178, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["match.replaceAll(String)"], "useStart": [202], "useEnd": [218], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/europeana/contrib/tree/master/repox/branches/repox_april/src/main/java/pt/utl/ist/marc/util/RemovePontuationVisitor.java", "rawCode": "  protected static void removePontuation(Subfield sf, String regExp) {\n    String value = sf.getValue();\n    Pattern p = Pattern.compile(regExp);\n    Matcher m = p.matcher(value);\n    String newValue = m.replaceAll(\"\");\n    sf.setValue(newValue);\n  }\n"}, {"dataset": "matcher", "exampleID": 6094, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 1687, "focalAPIEnd": 1715, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 1762, "followUpCheckExpressionEnd": 1779, "followUpCheckBlockStart": 1762, "followUpCheckBlockEnd": 1917, "use": ["match.start()", "match.group(int)", "match.appendReplacement(StringBuffer,*)", "match.appendTail(StringBuffer)"], "useStart": [1803, 1862, 1837, 1926], "useEnd": [1813, 1873, 1874, 1943], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/g-pechorin/degen/tree/master/jsyntaxpane/src/main/java/jsyntaxpane/actions/ActionUtils.java", "rawCode": "  /**\n   * Expand the string template and replaces the selection with the expansion of the template. The\n   * template String may contain any of the following special tags.\n   * <li>{@code #{selection}} replaced with the selection, if any. If there is no selection, then\n   *     the {@code #{selection}} tag will be removed.\n   * <li>{@code #{p:any text}} will be replaced by {@code any text} and then set selection to {@code\n   *     any text}\n   *\n   *     <p>This method properly handles indentation as follows: The indentation of the whole block\n   *     will match the indentation of the caret line, or the line with the beginning of the\n   *     selection, if the selection is in whole line, i.e.e one or more lines of selected text.\n   *     {@see selectLines()}\n   *\n   * @param target JEditorCOmponent to be affected\n   * @param templateLines template split as a String array of lines.\n   * @see insertLinesTemplate\n   */\n  public static void insertLinesTemplate(JTextComponent target, String[] templateLines) {\n    // get some stuff we'll need:\n    String thisIndent = getIndent(getLineAt(target, target.getSelectionStart()));\n    String[] selLines = getSelectedLines(target);\n    int selStart = -1, selEnd = -1;\n    StringBuffer sb = new StringBuffer();\n    for (String tLine : templateLines) {\n      int selNdx = tLine.indexOf(\"#{selection}\");\n      if (selNdx >= 0) {\n        // for each of the selected lines:\n        for (String selLine : selLines) {\n          sb.append(tLine.subSequence(0, selNdx));\n          sb.append(selLine);\n          sb.append('\\n');\n        }\n      } else {\n        sb.append(thisIndent);\n        // now check for any ptags\n        Matcher pm = PTAGS_PATTERN.matcher(tLine);\n        int lineStart = sb.length();\n        while (pm.find()) {\n          selStart = pm.start() + lineStart;\n          pm.appendReplacement(sb, pm.group(1));\n          selEnd = sb.length();\n        }\n        pm.appendTail(sb);\n        sb.append('\\n');\n      }\n    }\n    int ofst = target.getSelectionStart();\n    target.replaceSelection(sb.toString());\n    if (selStart >= 0) {\n      // target.setCaretPosition(selStart);\n      target.select(ofst + selStart, ofst + selEnd);\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6095, "initialization": ["String input = DataInputStream.readLine()", "String input = DataInputStream.readLine()"], "initializationStart": [233, 484], "initializationEnd": [246, 497], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["input.substring(int)", "input.substring(*)", "input.substring(*)"], "configurationStart": [454, 887, 1045], "configurationEnd": [470, 922, 1083], "guardCondition": "conditional", "guardType": "IF {", "guardExpressionStart": 348, "guardExpressionEnd": 397, "guardBlockStart": 348, "guardBlockEnd": 617, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 1121, "focalAPIEnd": 1152, "followUpCheck": "match.matches()", "checkType": "IF", "followUpCheckExpressionStart": 1162, "followUpCheckExpressionEnd": 1178, "followUpCheckBlockStart": 1162, "followUpCheckBlockEnd": 1310, "use": ["match.group(int)", "match.group(int)"], "useStart": [1216, 1265], "useEnd": [1226, 1275], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sgothel/jogl-demos/tree/master/src/demos/hdr/RGBE.java", "rawCode": "  public static Header readHeader(DataInputStream in) throws IOException {\n    int valid = 0;\n    String programType = null;\n    float gamma = 1.0f;\n    float exposure = 1.0f;\n    int width = 0;\n    int height = 0;\n\n    String buf = in.readLine();\n    if (buf == null) {\n      throw new IOException(\"Unexpected EOF reading magic token\");\n    }\n    if (buf.charAt(0) == '#' && buf.charAt(1) == '?') {\n      valid |= VALID_PROGRAMTYPE;\n      programType = buf.substring(2);\n      buf = in.readLine();\n      if (buf == null) {\n        throw new IOException(\"Unexpected EOF reading line after magic token\");\n      }\n    }\n\n    boolean foundFormat = false;\n    boolean done = false;\n    while (!done) {\n      if (buf.equals(\"FORMAT=32-bit_rle_rgbe\")) {\n        foundFormat = true;\n      } else if (buf.startsWith(gammaString)) {\n        valid |= VALID_GAMMA;\n        gamma = Float.parseFloat(buf.substring(gammaString.length()));\n      } else if (buf.startsWith(exposureString)) {\n        valid |= VALID_EXPOSURE;\n        exposure = Float.parseFloat(buf.substring(exposureString.length()));\n      } else {\n        Matcher m = widthHeightPattern.matcher(buf);\n        if (m.matches()) {\n          width = Integer.parseInt(m.group(2));\n          height = Integer.parseInt(m.group(1));\n          done = true;\n        }\n      }\n\n      if (!done) {\n        buf = in.readLine();\n        if (buf == null) {\n          throw new IOException(\"Unexpected EOF reading header\");\n        }\n      }\n    }\n\n    if (!foundFormat) {\n      throw new IOException(\"No FORMAT specifier found\");\n    }\n\n    return new Header(valid, programType, gamma, exposure, width, height);\n  }\n"}, {"dataset": "matcher", "exampleID": 6096, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [95], "initializationEnd": [118], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 136, "focalAPIEnd": 151, "followUpCheck": "match.find()", "checkType": "LOOP {", "followUpCheckExpressionStart": 157, "followUpCheckExpressionEnd": 173, "followUpCheckBlockStart": 157, "followUpCheckBlockEnd": 218, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ppolabs/jlinda/tree/master/jlinda-core/src/test/java/org/jlinda/core/coregistration/legacy/CoregistrationTest.java", "rawCode": "  private int extractNumber(String line) {\n    String numbers = new String();\n\n    Pattern p = Pattern.compile(\"\\\\d+\");\n    Matcher m = p.matcher(line);\n    while (m.find()) {\n      numbers = numbers + m.group();\n    }\n\n    return Integer.parseInt(numbers);\n  }\n"}, {"dataset": "matcher", "exampleID": 6097, "initialization": ["String input = CellWrapper.getStringValue()"], "initializationStart": [105], "initializationEnd": [126], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 146, "focalAPIEnd": 164, "followUpCheck": "!match.find()", "checkType": "IF", "followUpCheckExpressionStart": 170, "followUpCheckExpressionEnd": 186, "followUpCheckBlockStart": 170, "followUpCheckBlockEnd": 214, "use": ["match.group(int)"], "useStart": [238], "useEnd": [250], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/seasarorg/fisshplate/tree/master/fisshplate/src/main/java/org/seasar/fisshplate/core/parser/WhileParser.java", "rawCode": "  public boolean process(CellWrapper cell, FPParser parser) throws FPParseException {\n    String value = cell.getStringValue();\n    Matcher mat = pat.matcher(value);\n    if (!mat.find()) {\n      return false;\n    }\n    String condition = mat.group(1);\n    RowWrapper row = cell.getRow();\n    AbstractBlock block = new WhileBlock(row, condition);\n    parser.addBlockElement(block);\n    return true;\n  }\n"}, {"dataset": "matcher", "exampleID": 6098, "initialization": ["Pattern pattern = Pattern.compile(String)"], "initializationStart": [384], "initializationEnd": [412], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 432, "focalAPIEnd": 455, "followUpCheck": "match.find(start + j - 2)", "checkType": "LOOP {", "followUpCheckExpressionStart": 544, "followUpCheckExpressionEnd": 575, "followUpCheckBlockStart": 544, "followUpCheckBlockEnd": 991, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benjaminvm/vm/tree/master/libcore/regex/src/test/java/org/apache/harmony/regex/tests/java/util/regex/MatcherTest.java", "rawCode": "  /** @test java.util.regex.Matcher#end(int) test end(int) method. */\n  @TestTargetNew(\n    level = TestLevel.PARTIAL_COMPLETE,\n    notes = \"Verifies the basic functionality of end(int group) method.\",\n    method = \"end\",\n    args = {int.class}\n  )\n  public void test_endI() {\n    String testPattern = \"(((abb)a)(bb))\";\n    String testString = \"cccabbabbabbabbabb\";\n    Pattern pat = Pattern.compile(testPattern);\n    Matcher mat = pat.matcher(testString);\n    int start = 3;\n    int end = 6;\n    int i, j;\n\n    for (j = 0; j < 3; j++) {\n      while (mat.find(start + j - 2)) {\n        for (i = 0; i < 4; i++) {\n          assertEquals(\n              \"End is wrong for group \" + i + \" :\" + mat.group(i),\n              start + mat.group(i).length(),\n              mat.end(i));\n        }\n        assertEquals(\n            \"End is wrong for group \" + i + \" :\" + mat.group(i),\n            start + 4 + mat.group(i).length(),\n            mat.end(i));\n\n        start = end;\n        end += 3;\n      }\n    }\n  }\n"}, {"dataset": "matcher", "exampleID": 6099, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 608, "focalAPIEnd": 621, "followUpCheck": "match.find() == false", "checkType": "IF", "followUpCheckExpressionStart": 629, "followUpCheckExpressionEnd": 651, "followUpCheckBlockStart": 629, "followUpCheckBlockEnd": 704, "use": ["match.group(int)", "match.group(int)"], "useStart": [758, 788], "useEnd": [768, 798], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7940/src/net/sourceforge/plantuml/command/CommandSkinParamMultilines.java", "rawCode": "  public CommandExecutionResult execute(List<String> lines) {\n    final Context context = new Context();\n    final Matcher mStart = getStartingPattern().matcher(lines.get(0).trim());\n    if (mStart.find() == false) {\n      throw new IllegalStateException();\n    }\n    if (mStart.group(1) != null) {\n      context.push(mStart.group(1));\n    }\n\n    lines = new ArrayList<String>(lines.subList(1, lines.size() - 1));\n    StringUtils.trim(lines, true);\n\n    for (String s : lines) {\n      assert s.length() > 0;\n      if (s.equals(\"}\")) {\n        context.pop();\n        continue;\n      }\n      final Matcher m = p1.matcher(s);\n      if (m.find() == false) {\n        throw new IllegalStateException();\n      }\n      if (m.group(2) != null) {\n        context.push(m.group(1));\n      } else if (m.group(3) != null) {\n        final String key = context.getFullParam() + m.group(1);\n        getSystem().setParam(key, m.group(3));\n      } else {\n        throw new IllegalStateException();\n      }\n    }\n\n    return CommandExecutionResult.ok();\n  }\n"}, {"dataset": "matcher", "exampleID": 6100, "initialization": ["String input = clean(String)"], "initializationStart": [325], "initializationEnd": [348], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(input==null) && !(input.length()==0)", "guardType": "IF {", "guardExpressionStart": 227, "guardExpressionEnd": 243, "guardBlockStart": 227, "guardBlockEnd": 270, "focalAPI": "match = pattern.matcher(input)", "focalAPIStart": 521, "focalAPIEnd": 541, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)", "Pattern.matcher(match)", "match.length()", "match.charAt(int)", "match.toCharArray()"], "useStart": [573, 623, 671, 724, 872, 924, 1073, 1103, 1224], "useEnd": [592, 641, 693, 744, 894, 947, 1085, 1116, 1241], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/IDE4edu/isa-curriculum/tree/master/trunk/testing/AndyTest/Test/src/org/apache/commons/codec/language/Nysiis.java", "rawCode": "  /**\n   * Retrieves the NYSIIS code for a given String object.\n   *\n   * @param str String to encode using the NYSIIS algorithm\n   * @return A NYSIIS code for the String supplied\n   */\n  public String nysiis(String str) {\n    if (str == null) {\n      return null;\n    }\n\n    // Use the same clean rules as Soundex\n    str = SoundexUtils.clean(str);\n\n    if (str.length() == 0) {\n      return str;\n    }\n\n    // Translate first characters of name:\n    // MAC -> MCC, KN -> NN, K -> C, PH | PF -> FF, SCH -> SSS\n    str = PAT_MAC.matcher(str).replaceFirst(\"MCC\");\n    str = PAT_KN.matcher(str).replaceFirst(\"NN\");\n    str = PAT_K.matcher(str).replaceFirst(\"C\");\n    str = PAT_PH_PF.matcher(str).replaceFirst(\"FF\");\n    str = PAT_SCH.matcher(str).replaceFirst(\"SSS\");\n\n    // Translate last characters of name:\n    // EE -> Y, IE -> Y, DT | RT | RD | NT | ND -> D\n    str = PAT_EE_IE.matcher(str).replaceFirst(\"Y\");\n    str = PAT_DT_ETC.matcher(str).replaceFirst(\"D\");\n\n    // First character of key = first character of name.\n    final StringBuilder key = new StringBuilder(str.length());\n    key.append(str.charAt(0));\n\n    // Transcode remaining characters, incrementing by one character each time\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n\n    for (int i = 1; i < len; i++) {\n      final char next = i < len - 1 ? chars[i + 1] : SPACE;\n      final char aNext = i < len - 2 ? chars[i + 2] : SPACE;\n      final char[] transcoded = transcodeRemaining(chars[i - 1], chars[i], next, aNext);\n      System.arraycopy(transcoded, 0, chars, i, transcoded.length);\n\n      // only append the current char to the key if it is different from the last one\n      if (chars[i] != chars[i - 1]) {\n        key.append(chars[i]);\n      }\n    }\n\n    if (key.length() > 1) {\n      char lastChar = key.charAt(key.length() - 1);\n\n      // If last character is S, remove it.\n      if (lastChar == 'S') {\n        key.deleteCharAt(key.length() - 1);\n        lastChar = key.charAt(key.length() - 1);\n      }\n\n      if (key.length() > 2) {\n        final char last2Char = key.charAt(key.length() - 2);\n        // If last characters are AY, replace with Y.\n        if (last2Char == 'A' && lastChar == 'Y') {\n          key.deleteCharAt(key.length() - 2);\n        }\n      }\n\n      // If last character is A, remove it.\n      if (lastChar == 'A') {\n        key.deleteCharAt(key.length() - 1);\n      }\n    }\n\n    final String string = key.toString();\n    return this.isStrict() ? string.substring(0, Math.min(TRUE_LENGTH, string.length())) : string;\n  }\n"}]