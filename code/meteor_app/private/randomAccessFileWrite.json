[{"dataset": "randomAccessFileWrite", "exampleID": 6801, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)", "RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)", "byte[] b = String.getBytes(Charset)"], "initializationStart": [306, 364, 484], "initializationEnd": [339, 397, 507], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.writeByte(int)", "randomAccessFile.writeByte(int)", "randomAccessFile.writeInt(int)"], "configurationStart": [405, 435, 557], "configurationEnd": [419, 449, 590], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 600, "focalAPIEnd": 614, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.writeLong(long)", "randomAccessFile.seek(int)", "randomAccessFile.readByte()", "randomAccessFile.readByte()"], "useStart": [624, 655, 684, 713], "useEnd": [639, 665, 696, 725], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vyloy/lnvc/tree/master/vovo/client/src/com/lorent/vovo/util/CallHistory.java", "rawCode": "  public List<CallHistoryItem> init() throws IOException {\n    File path = new File(System.getProperty(\"user.dir\") + File.separator + \"users\");\n    if (!path.exists()) {\n      path.mkdirs();\n    }\n    File file = new File(path, DataUtil.getUserName() + \".phoneHistory\");\n    if (file.exists()) {\n      r = new RandomAccessFile(file, \"rwd\");\n    } else {\n      r = new RandomAccessFile(file, \"rwd\");\n      r.writeByte(0); // size\n      r.writeByte(0); // position\n      byte[] bytes = PHONE.getBytes(charset);\n      for (int i = 0; i < COUNT; i++) {\n        r.writeInt(CallInfo.INVALID.mask);\n        r.write(bytes);\n        r.writeLong(0L);\n      }\n      r.seek(0L);\n    }\n    size = r.readByte();\n    position = r.readByte();\n    return getAll();\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6802, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 75, "tryExpressionEnd": 79, "tryBlockStart": 75, "tryBlockEnd": 198, "catchExpressionStart": 142, "catchExpressionEnd": 164, "catchBlockStart": 142, "catchBlockEnd": 198, "exceptionHandlingCallStart": [172], "exceptionHandlingCallEnd": [191], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 87, "focalAPIEnd": 134, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/tags/release_4_0_RC4/appia/src/net/sf/appia/test/perf/PerfSession.java", "rawCode": "  private void readPayload(MsgBuffer mbuf, RandomAccessFile payload) {\n    try {\n      payloadOut.write(mbuf.data, mbuf.off, mbuf.len);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6803, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [176], "configurationEnd": [199], "guardCondition": "len>off", "guardType": "IF {", "guardExpressionStart": 152, "guardExpressionEnd": 167, "guardBlockStart": 152, "guardBlockEnd": 264, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 207, "focalAPIEnd": 239, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.common/tree/master/plugins/org.eclipse.birt.core/src/org/eclipse/birt/core/archive/RAStreamBuffer.java", "rawCode": "  /**\n   * Write the data in the buffer to the underlying file\n   *\n   * @throws IOException\n   */\n  public void flushBuffer() throws IOException {\n    if (bufLen > 0) {\n      randomFile.seek(offset);\n      randomFile.write(buf, 0, bufLen);\n      bufLen = 0;\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6804, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [5395], "initializationEnd": [5456], "hasTryCatch": 1, "exceptionType": "UnknownHostException", "exceptionHandlingCall": ["setStatus(*)"], "tryExpressionStart": 4948, "tryExpressionEnd": 4952, "tryBlockStart": 4948, "tryBlockEnd": 13340, "catchExpressionStart": 12836, "catchExpressionEnd": 12867, "catchBlockStart": 12836, "catchBlockEnd": 12991, "exceptionHandlingCallStart": [10572], "exceptionHandlingCallEnd": [10626], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [6195], "configurationEnd": [6216], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 7498, "focalAPIEnd": 7531, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [11356], "useEnd": [11373], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sgbell/podsalinan/tree/master/podsalinan/src/com/mimpidev/podsalinan/Downloader.java", "rawCode": "  /** This is where the file gets downloaded from */\n  public int getFile() {\n    RandomAccessFile outStream;\n    boolean remoteFileExists = false;\n    int numTries = 0;\n    URLConnection conn;\n    List<String> values;\n\n    if (Log.isDebug()) Log.logInfo(this, \"Is internet Reachable? \");\n    if (isInternetReachable()) {\n      setResult(Status.CURRENTLY_DOWNLOADING);\n      if (Log.isDebug()) Log.logInfo(this, \"Yes it is.\");\n      byte buf[] = new byte[1024];\n      int byteRead; // Number of bytes read from file being downloaded\n\n      if (Log.isDebug()) Log.logInfo(this, \"Attempting to download:\" + downloadItem.getURL());\n\n      while ((!remoteFileExists) && (numTries < 2) && (!isStopThread())) {\n        // System.out.println(\"Inside first while\");\n        try {\n          // checkURLRedirect(new URL(downloadItem.getURL()));\n\n          conn = downloadURL.openConnection();\n          conn.setConnectTimeout(2000);\n          /* The following line gets the file size of the Download. had to do it this\n           * way cos URLConnection.getContentLength was an int and couldn't handle over\n           * 2GB\n           */\n          String length = null;\n          values = conn.getHeaderFields().get(\"Content-Length\");\n          boolean isDirectory = false;\n\n          File destinationFile = downloadItem.getDestinationFile();\n          if (destinationFile.list() != null) isDirectory = true;\n          else isDirectory = false;\n\n          // If the destination is currently set to a folder, we need to add the filename to it\n          if (isDirectory) {\n            // First we test if the server is handing us a filename to set, set it here.\n            List<String> disposition = conn.getHeaderFields().get(\"content-disposition\");\n\n            if (disposition != null) {\n              // If the file is going to be renamed from the server, grab the new name here\n              int index = disposition.get(0).indexOf(\"filename=\");\n              if (index > 0) {\n                String newFilename =\n                    disposition.get(0).substring(index + 10, disposition.get(0).length() - 1);\n                File newFile =\n                    new File(downloadItem.getDestination() + fileSystemSlash + newFilename);\n                // If it doesn't exists create it.\n                if (!newFile.exists()) newFile.createNewFile();\n                // If it has been created set it as the destination for the download.\n                if ((newFile.exists()) && (newFile.isFile())) downloadItem.setDestination(newFile);\n              }\n            } else {\n              String filePath =\n                  downloadItem.getDestination() + fileSystemSlash + getFilenameDownload();\n              File outputFile = new File(filePath);\n              downloadItem.setDestination(outputFile);\n            }\n          } else if ((!destinationFile.exists()) && (!destinationFile.getParentFile().exists())) {\n            downloadItem.setStatus(URLDetails.DESTINATION_INVALID);\n            if (Log.isDebug()) Log.logInfo(this, \"Destination does not exist.\");\n            return Status.DESTINATION_INVALID;\n          }\n\n          if (values != null && !values.isEmpty()) {\n            length = (String) values.get(0);\n          } else {\n            length = \"-1\";\n          }\n          if (downloadItem.getDestinationFile().exists()) {\n            saved = downloadItem.getDestinationFile().length();\n          }\n\n          long tempfileSize = -1;\n          if (length != null) {\n            tempfileSize = Long.parseLong(length);\n            if (downloadItem.getSize().length() == 0\n                || Long.parseLong(downloadItem.getSize()) != tempfileSize)\n              downloadItem.setSize(length);\n          }\n          if (downloadItem.getSize() == null || downloadItem.getSize().equals(\"\"))\n            downloadItem.setSize(\"-1\");\n          remoteFileExists = true;\n        } catch (MalformedURLException e) {\n          e.printStackTrace();\n          setResult(Status.CONNECTION_FAILED);\n          remoteFileExists = false;\n        } catch (IOException e) {\n          e.printStackTrace();\n          setResult(Status.CONNECTION_FAILED);\n          remoteFileExists = false;\n        }\n\n        /* Just incase the link (whether it was manually added or via a podcast)\n         * is incorrect, we will try to switch it from http to ftp and vice versa.\n         */\n        if (!remoteFileExists) {\n          String protocol;\n          if (downloadURL.toString().substring(0, 3).equals(\"http\")) {\n            protocol = \"ftp\";\n          } else protocol = \"http\";\n          try {\n\n            downloadURL =\n                new URL(\n                    protocol, downloadURL.getHost(), downloadURL.getPort(), downloadURL.getFile());\n          } catch (MalformedURLException e) {\n            setResult(Status.CONNECTION_FAILED);\n            remoteFileExists = false;\n          }\n        }\n        numTries++;\n      }\n\n      if (remoteFileExists) {\n        try {\n          if ((saved < Long.parseLong(downloadItem.getSize()))\n              || (Long.parseLong(downloadItem.getSize()) == -1)) {\n            if (Log.isDebug())\n              Log.logInfo(this, \"Filename to save to:\" + downloadItem.getDestinationFile());\n            File outputFile = downloadItem.getDestinationFile();\n            if ((outputFile.exists() && outputFile.canWrite()) || outputFile.createNewFile()) {\n              outStream = new RandomAccessFile(downloadItem.getDestinationFile(), \"rw\");\n              if (saved > 0) outStream.seek(saved);\n\n              conn = downloadURL.openConnection();\n              /* Skip incoming connection ahead before we connect a stream to it,\n               * otherwise it'll waste user bandwidth\n               */\n              if (saved > 0) conn.setRequestProperty(\"Range\", \"bytes=\" + saved + \"-\");\n              // if (Log.isDebug()) Log.logMap(this, conn.getHeaderFields());\n              if (conn.getHeaderFields().get(\"Content-Length\") != null) {\n                if (saved < Long.parseLong(conn.getHeaderFields().get(\"Content-Length\").get(0))) {\n                  if (conn.getHeaderFields().get(\"Content-Range\") == null && saved > 0) {\n                    saved = 0;\n                    outStream.seek(saved);\n                  }\n                }\n              }\n              if (Log.isDebug()) Log.logMap(this, conn.getHeaderFields());\n              conn.connect();\n              InputStream inStream = conn.getInputStream();\n              conn.setReadTimeout(1000);\n              if (Log.isDebug()) Log.logInfo(this, \"External socket opened to download.\");\n\n              long time = System.currentTimeMillis();\n              // System.out.println(\"before the download while\");\n              if (Log.isDebug()) Log.logInfo(this, \"Start to read.\");\n              long lastSize = outStream.length();\n              // BufferedStreamReader is locking up when internet connection is lost\n              boolean keepReading = true;\n              int checkAvailable = 0;\n              int voidInputBytes = 0;\n              long originalSaved = saved;\n              while (keepReading\n                  && !isStopThread()\n                  && downloadItem.getStatus() == URLDetails.CURRENTLY_DOWNLOADING) {\n                if (inStream.available() > 0) {\n                  if ((byteRead = inStream.read(buf)) == -1) {\n                    keepReading = false;\n                  } else {\n                    if (isStopThread()) Log.logInfo(this, \"Thread Should be stopping.\");\n                    outStream.write(buf, 0, byteRead);\n                    saved += byteRead;\n                    for (byte b : buf) {\n                      if (b == 0x0) {\n                        voidInputBytes++;\n                      } else {\n                        voidInputBytes = 0;\n                      }\n                    }\n\n                    long sleep = (System.currentTimeMillis() - time);\n                    if ((((saved - lastSize) / 1024) >= getDownloadSpeedLimit())\n                        || (sleep >= 1000)) {\n                      if (Log.isDebug()) Log.logInfo(this, \"Sleep:\" + sleep);\n                      if (Log.isDebug()) Log.logInfo(this, \"Saved:\" + (saved - lastSize));\n                      try {\n                        // Every second, check the parent DownloadQueue, and see how many\n                        // downloaders are active,\n                        // and calculate how fast the downloader should be downloading at.\n                        if (sleep < 800) {\n                          Thread.sleep(1000 - sleep);\n                        }\n                        currentDownloadSpeed = (int) ((outStream.length() - lastSize) / 1024);\n                        if (!speedUnlocked) {\n                          setDownloadSpeedLimit(\n                              DownloadQueue.getDownloadSpeedLimit(getCurrentDownloadSpeed()));\n                        }\n                        lastSize = outStream.length();\n                        if (!DownloadQueue.timeToDownload()) {\n                          setStopThread(true);\n                        }\n                      } catch (InterruptedException e) {\n                        // sleep interrupted\n                      }\n                      if (Log.isDebug())\n                        Log.logInfo(this, \"Downloading: \" + (outStream.length() / 1024) + \" Kb\");\n                      if (Log.isDebug())\n                        Log.logInfo(this, \"Download Speed: \" + currentDownloadSpeed + \" KB\\\\sec\");\n                      if (Log.isDebug())\n                        Log.logInfo(\n                            this, \"Download Speed Limit: \" + getDownloadSpeedLimit() + \" KB\\\\sec\");\n                    }\n                    if (Log.isDebug()) Log.logInfo(this, \"While Loop\");\n                  }\n                }\n                time = System.currentTimeMillis();\n                if (inStream.available() > 0) {\n                  if (Log.isDebug()) Log.logInfo(this, \"Available: \" + inStream.available());\n                  checkAvailable = 0;\n                  keepReading = true;\n                } else {\n                  checkAvailable++;\n                  if (checkAvailable > 10) {\n                    keepReading = false;\n                  } else {\n                    try {\n                      Thread.sleep(200);\n                    } catch (InterruptedException e) {\n                      // just ignore the sleep interruption\n                    }\n                  }\n                }\n                if (voidInputBytes >= 1024000) {\n                  keepReading = false;\n                  downloadItem.setStatus(URLDetails.INCOMPLETE_DOWNLOAD);\n                  setResult(Status.CONNECTION_FAILED);\n                }\n              }\n              if (!keepReading) {\n                // Check if the reason the file download stopped was because the downloader can't\n                // find the server\n                if (!isInternetReachable(downloadItem.getURL())) {\n                  if (Log.isDebug()) Log.logInfo(this, \"Can't find the server\");\n                  downloadItem.setStatus(URLDetails.INCOMPLETE_DOWNLOAD);\n                  setResult(Status.CONNECTION_FAILED);\n                }\n              }\n              inStream.close();\n              if (voidInputBytes >= 1024000) {\n                outStream.setLength(originalSaved);\n              }\n              outStream.close();\n              if (Log.isDebug()) Log.logInfo(this, \"Finished reading.\");\n            } else {\n              if (Log.isDebug()) Log.logInfo(this, \"Can not open local file to save.\");\n              downloadItem.setStatus(URLDetails.DESTINATION_INVALID);\n              setResult(Status.DOWNLOAD_ERROR);\n            }\n          }\n          if (downloadItem.getStatus() != URLDetails.DESTINATION_INVALID) {\n            if (saved == Long.parseLong(downloadItem.getSize())\n                || (Long.parseLong(downloadItem.getSize()) == -1 && !isStopThread())) {\n              downloadItem.setStatus(URLDetails.FINISHED);\n              setResult(Status.DOWNLOAD_COMPLETE);\n            } else if (saved < Long.parseLong(downloadItem.getSize())) {\n              downloadItem.setStatus(URLDetails.INCOMPLETE_DOWNLOAD);\n              setResult(Status.DOWNLOAD_INCOMPLETE);\n            } else if ((saved > Long.parseLong(downloadItem.getSize()))\n                && (Long.parseLong(downloadItem.getSize()) > 0)) {\n              downloadItem.setStatus(URLDetails.DOWNLOAD_FAULT);\n              setResult(Status.DOWNLOAD_ERROR);\n            } else if ((Long.parseLong(downloadItem.getSize()) == -1)\n                && saved > 0\n                && isStopThread()) {\n              // If downloader is stopped prematurely\n              downloadItem.setStatus(URLDetails.INCOMPLETE_DOWNLOAD);\n              setResult(Status.DOWNLOAD_INCOMPLETE);\n            }\n          }\n        } catch (UnknownHostException e) {\n          downloadItem.setStatus(URLDetails.INCOMPLETE_DOWNLOAD);\n          setResult(Status.CONNECTION_FAILED);\n        } catch (IOException e) {\n          File outputFile = downloadItem.getDestinationFile();\n          if (!outputFile.exists()) {\n            downloadItem.setStatus(URLDetails.DESTINATION_INVALID);\n          } else {\n            downloadItem.setStatus(URLDetails.INCOMPLETE_DOWNLOAD);\n          }\n          setResult(Status.CONNECTION_FAILED);\n        }\n      }\n    } else {\n      // No internet connection.\n      setResult(Status.CONNECTION_FAILED);\n    }\n    return result;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6805, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [100], "configurationEnd": [144], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 150, "focalAPIEnd": 167, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/molgenis/systemsgenetics/tree/master/genetica-libraries/src/main/java/umcg/genetica/io/trityper/WGAFileMatrixRawData.java", "rawCode": "  public void setTheta(int snp, int ind, byte[] value) throws IOException {\n    cachedSnp = -1;\n    file.seek(getElement(snp, ind) + nrInds * 2);\n    file.write(value);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6806, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()", "new RuntimeException(*)"], "tryExpressionStart": 71, "tryExpressionEnd": 75, "tryBlockStart": 71, "tryBlockEnd": 222, "catchExpressionStart": 123, "catchExpressionEnd": 145, "catchBlockStart": 123, "catchBlockEnd": 222, "exceptionHandlingCallStart": [155, 190], "exceptionHandlingCallEnd": [174, 213], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "randomAccessFile!=null", "guardType": "IF {", "guardExpressionStart": 45, "guardExpressionEnd": 62, "guardBlockStart": 45, "guardBlockEnd": 228, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 85, "focalAPIEnd": 113, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/charleso/naca/tree/master/JLib/src/jlib/misc/DataFileReadWrite.java", "rawCode": "  public void writeEndOfRecordMarker() {\n    if (m_rw != null) {\n      try {\n        m_rw.write(FileEndOfLine.LF);\n      } catch (IOException e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n      }\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6807, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "randomAccessFile!=null", "guardType": "IF {", "guardExpressionStart": 243, "guardExpressionEnd": 263, "guardBlockStart": 243, "guardBlockEnd": 288, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 264, "focalAPIEnd": 287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sonatype/JGit/tree/master/org.spearce.jgit/src/org/spearce/jgit/transport/IndexPack.java", "rawCode": "  private void readPackFooter() throws IOException {\n    sync();\n    final byte[] cmpcsum = packDigest.digest();\n    final int c = fillFromInput(20);\n    packcsum = new byte[20];\n    System.arraycopy(buf, c, packcsum, 0, 20);\n    use(20);\n    if (packOut != null) packOut.write(packcsum);\n\n    if (!Arrays.equals(cmpcsum, packcsum))\n      throw new CorruptObjectException(\"Packfile checksum incorrect.\");\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6808, "initialization": ["byte[] b = ArrayList<FileIdentifierDescriptor>.get(int)", "byte[] b = getBytes()", "byte[] b = ArrayList<FileIdentifierDescriptor>.get(int)", "byte[] b = getBytes()"], "initializationStart": [7299, 8014, 9348, 9543], "initializationEnd": [7336, 8062, 9385, 9591], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [9022], "configurationEnd": [9066], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 9603, "focalAPIEnd": 9663, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.seek(int)", "writeFileData(randomAccessFile,*)", "randomAccessFile.seek(int)", "ExtendedFileEntry.write(randomAccessFile,int)"], "useStart": [12785, 12849, 13371, 13434], "useEnd": [12839, 12926, 13428, 13490], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stephenc/java-iso-tools/tree/master/sabre/src/main/java/com/github/stephenc/javaisotools/udflib/UDFImageBuilder.java", "rawCode": "  private long[] recursiveWriteFilesystemWithMetadata(\n      RandomAccessFile myRandomAccessFile,\n      long partitionStartingBlock,\n      long metadataPartitionStartingBlock,\n      int blockSize,\n      int serialNumberForTags,\n      UDFImageBuilderFile currentUDFImageBuilderFile,\n      long currentMetadataBlock,\n      long currentFiledataBlock,\n      FileEntry parentFileEntry,\n      long uniqueID,\n      int descriptorVersion)\n      throws Exception {\n    long[] nextFreeBlocks = new long[2];\n\n    ExtendedFileEntry myExtendedFileEntry = new ExtendedFileEntry();\n\n    myExtendedFileEntry.DescriptorTag.TagSerialNumber = serialNumberForTags;\n    myExtendedFileEntry.DescriptorTag.DescriptorVersion = descriptorVersion;\n    myExtendedFileEntry.DescriptorTag.TagLocation =\n        currentMetadataBlock - metadataPartitionStartingBlock;\n\n    myExtendedFileEntry.Uid = 0xFFFFFFFF; // TODO: get current uid and gid if java supports it\n    myExtendedFileEntry.Gid = 0xFFFFFFFF;\n\n    // TODO: get real file permission if java supports it\n    myExtendedFileEntry.Permissions =\n        Permissions.OTHER_Read | Permissions.GROUP_Read | Permissions.OWNER_Read;\n\n    myExtendedFileEntry.FileLinkCount = currentUDFImageBuilderFile.getFileLinkCount();\n\n    myExtendedFileEntry.RecordFormat = 0;\n    myExtendedFileEntry.RecordDisplayAttributes = 0;\n    myExtendedFileEntry.RecordLength = 0;\n\n    myExtendedFileEntry.AccessTime = new Timestamp(currentUDFImageBuilderFile.getAccessTime());\n    myExtendedFileEntry.ModificationTime =\n        new Timestamp(currentUDFImageBuilderFile.getModificationTime());\n    myExtendedFileEntry.AttributeTime =\n        new Timestamp(currentUDFImageBuilderFile.getAttributeTime());\n\n    myExtendedFileEntry.Checkpoint = 1;\n\n    myExtendedFileEntry.ImplementationIdentifier.setIdentifier(applicationIdentifier);\n    myExtendedFileEntry.ImplementationIdentifier.IdentifierSuffix = applicationIdentifierSuffix;\n\n    myExtendedFileEntry.ICBTag.PriorRecordedNumberofDirectEntries = 0;\n    myExtendedFileEntry.ICBTag.NumberofEntries = 1;\n    myExtendedFileEntry.ICBTag.StrategyType = 4;\n\n    myExtendedFileEntry.UniqueID = uniqueID;\n\n    nextFreeBlocks[0] = currentMetadataBlock + 1;\n    nextFreeBlocks[1] = currentFiledataBlock;\n\n    /*\n     * if file is a directory\n     */\n    if (currentUDFImageBuilderFile.getFileType() == UDFImageBuilderFile.FileType.Directory) {\n      myExtendedFileEntry.ICBTag.FileType = 4; // directory\n\n      myExtendedFileEntry.Permissions |=\n          Permissions.OTHER_Execute | Permissions.GROUP_Execute | Permissions.OWNER_Execute;\n\n      // create file identifier descriptors for all child files\n      UDFImageBuilderFile childUDFImageBuilderFiles[] = currentUDFImageBuilderFile.getChilds();\n\n      ArrayList<FileIdentifierDescriptor> childFileIdentifierDescriptors =\n          new ArrayList<FileIdentifierDescriptor>();\n\n      // parent directory FID\n      FileIdentifierDescriptor parentDirectoryFileIdentifierDescriptor =\n          new FileIdentifierDescriptor();\n\n      parentDirectoryFileIdentifierDescriptor.DescriptorTag.TagLocation =\n          currentMetadataBlock - metadataPartitionStartingBlock;\n      parentDirectoryFileIdentifierDescriptor.DescriptorTag.TagSerialNumber = serialNumberForTags;\n      parentDirectoryFileIdentifierDescriptor.DescriptorTag.DescriptorVersion = descriptorVersion;\n\n      parentDirectoryFileIdentifierDescriptor.ICB.ExtentLength = blockSize;\n      parentDirectoryFileIdentifierDescriptor.ICB.ExtentLocation.part_num = 1;\n\n      parentDirectoryFileIdentifierDescriptor.FileVersionNumber = 1;\n      parentDirectoryFileIdentifierDescriptor.FileCharacteristics =\n          10; // file is directory and parent\n\n      // if root directory\n      if (parentFileEntry == null) {\n        parentDirectoryFileIdentifierDescriptor.ICB.ExtentLocation.lb_num =\n            currentMetadataBlock - metadataPartitionStartingBlock;\n      }\n      // if non root directory\n      else {\n        parentDirectoryFileIdentifierDescriptor.ICB.ExtentLocation.lb_num =\n            parentFileEntry.DescriptorTag.TagLocation;\n\n        parentDirectoryFileIdentifierDescriptor.ICB.implementationUse = new byte[6];\n        parentDirectoryFileIdentifierDescriptor.ICB.implementationUse[2] =\n            (byte) (parentFileEntry.UniqueID & 0xFF);\n        parentDirectoryFileIdentifierDescriptor.ICB.implementationUse[3] =\n            (byte) ((parentFileEntry.UniqueID >> 8) & 0xFF);\n        parentDirectoryFileIdentifierDescriptor.ICB.implementationUse[4] =\n            (byte) ((parentFileEntry.UniqueID >> 16) & 0xFF);\n        parentDirectoryFileIdentifierDescriptor.ICB.implementationUse[5] =\n            (byte) ((parentFileEntry.UniqueID >> 32) & 0xFF);\n      }\n\n      childFileIdentifierDescriptors.add(parentDirectoryFileIdentifierDescriptor);\n\n      // child file FIDs\n      for (int i = 0; i < childUDFImageBuilderFiles.length; ++i) {\n        long childFileUniqueID = myUniqueIdDisposer.getNextUniqueId();\n\n        FileIdentifierDescriptor childFileIdentifierDescriptor = new FileIdentifierDescriptor();\n\n        childFileIdentifierDescriptor.DescriptorTag.TagLocation =\n            currentMetadataBlock - metadataPartitionStartingBlock;\n        childFileIdentifierDescriptor.DescriptorTag.TagSerialNumber = serialNumberForTags;\n        childFileIdentifierDescriptor.DescriptorTag.DescriptorVersion = descriptorVersion;\n\n        childFileIdentifierDescriptor.ICB.ExtentLength = blockSize;\n        childFileIdentifierDescriptor.ICB.ExtentLocation.lb_num =\n            nextFreeBlocks[0] - metadataPartitionStartingBlock;\n        childFileIdentifierDescriptor.ICB.ExtentLocation.part_num = 1;\n\n        childFileIdentifierDescriptor.ICB.implementationUse = new byte[6];\n        childFileIdentifierDescriptor.ICB.implementationUse[2] = (byte) (childFileUniqueID & 0xFF);\n        childFileIdentifierDescriptor.ICB.implementationUse[3] =\n            (byte) ((childFileUniqueID >> 8) & 0xFF);\n        childFileIdentifierDescriptor.ICB.implementationUse[4] =\n            (byte) ((childFileUniqueID >> 16) & 0xFF);\n        childFileIdentifierDescriptor.ICB.implementationUse[5] =\n            (byte) ((childFileUniqueID >> 32) & 0xFF);\n\n        childFileIdentifierDescriptor.FileVersionNumber = 1;\n\n        childFileIdentifierDescriptor.setFileIdentifier(\n            childUDFImageBuilderFiles[i].getIdentifier());\n\n        if (childUDFImageBuilderFiles[i].getFileType() == UDFImageBuilderFile.FileType.Directory) {\n          childFileIdentifierDescriptor.FileCharacteristics = 2;\n        }\n\n        childFileIdentifierDescriptors.add(childFileIdentifierDescriptor);\n\n        nextFreeBlocks =\n            recursiveWriteFilesystemWithMetadata(\n                myRandomAccessFile,\n                partitionStartingBlock,\n                metadataPartitionStartingBlock,\n                blockSize,\n                serialNumberForTags,\n                childUDFImageBuilderFiles[i],\n                nextFreeBlocks[0],\n                nextFreeBlocks[1],\n                myExtendedFileEntry,\n                childFileUniqueID,\n                descriptorVersion);\n      }\n\n      // get directory file data length\n      int directoryFileDataLength = 0;\n      for (int i = 0; i < childFileIdentifierDescriptors.size(); ++i) {\n        directoryFileDataLength += childFileIdentifierDescriptors.get(i).getLength();\n      }\n\n      myExtendedFileEntry.InformationLength = directoryFileDataLength;\n\n      if (directoryFileDataLength <= blockSize - ExtendedFileEntry.fixedPartLength) {\n        // inline embedded file data\n        myExtendedFileEntry.ICBTag.Flags = 3; // storage type inline\n        myExtendedFileEntry.LogicalBlocksRecorded = 0;\n        myExtendedFileEntry.LengthofAllocationDescriptors = directoryFileDataLength;\n        myExtendedFileEntry.AllocationDescriptors = new byte[directoryFileDataLength];\n\n        int pos = 0;\n        for (int i = 0; i < childFileIdentifierDescriptors.size(); ++i) {\n          byte childFileIdentifierDescriptorBytes[] =\n              childFileIdentifierDescriptors.get(i).getBytes();\n\n          System.arraycopy(\n              childFileIdentifierDescriptorBytes,\n              0,\n              myExtendedFileEntry.AllocationDescriptors,\n              pos,\n              childFileIdentifierDescriptorBytes.length);\n          pos += childFileIdentifierDescriptorBytes.length;\n        }\n      } else {\n        // store as exernal file data with Short_ad\n        myExtendedFileEntry.ICBTag.Flags = 0; // storage type short_ad\n\n        myExtendedFileEntry.LogicalBlocksRecorded = (long) (directoryFileDataLength / blockSize);\n        if (directoryFileDataLength % blockSize != 0) {\n          myExtendedFileEntry.LogicalBlocksRecorded++;\n        }\n\n        Short_ad allocationDescriptor = new Short_ad();\n\n        allocationDescriptor.ExtentLength = directoryFileDataLength;\n        allocationDescriptor.ExtentPosition = nextFreeBlocks[0] - metadataPartitionStartingBlock;\n\n        long currentRealPosition = nextFreeBlocks[0] * blockSize;\n        myRandomAccessFile.seek(currentRealPosition);\n\n        for (int i = 0; i < childFileIdentifierDescriptors.size(); ++i) {\n          long tagLocationBlock =\n              (long) (currentRealPosition / blockSize) - metadataPartitionStartingBlock;\n\n          FileIdentifierDescriptor childFileIdentifierDescriptor =\n              childFileIdentifierDescriptors.get(i);\n\n          childFileIdentifierDescriptor.DescriptorTag.TagLocation = tagLocationBlock;\n\n          byte childFileIdentifierDescriptorBytes[] =\n              childFileIdentifierDescriptors.get(i).getBytes();\n          myRandomAccessFile.write(childFileIdentifierDescriptorBytes);\n\n          currentRealPosition += childFileIdentifierDescriptorBytes.length;\n        }\n\n        nextFreeBlocks[0] += myExtendedFileEntry.LogicalBlocksRecorded;\n\n        myExtendedFileEntry.AllocationDescriptors = allocationDescriptor.getBytes();\n        myExtendedFileEntry.LengthofAllocationDescriptors =\n            myExtendedFileEntry.AllocationDescriptors.length;\n      }\n    }\n\n    /*\n     * if file is a \"normal\" file\n     */\n    else if (currentUDFImageBuilderFile.getFileType() == UDFImageBuilderFile.FileType.File) {\n      myExtendedFileEntry.ICBTag.FileType = 5; // normal file\n\n      long fileSize = currentUDFImageBuilderFile.getFileLength();\n\n      myExtendedFileEntry.InformationLength = fileSize;\n\n      if (fileSize <= (blockSize - ExtendedFileEntry.fixedPartLength)) {\n        // store as inline embedded file data\n        myExtendedFileEntry.ICBTag.Flags = 3; // storage type inline\n        myExtendedFileEntry.LogicalBlocksRecorded = 0;\n        myExtendedFileEntry.LengthofAllocationDescriptors = fileSize;\n        myExtendedFileEntry.AllocationDescriptors = new byte[(int) fileSize];\n        currentUDFImageBuilderFile.readFileData(myExtendedFileEntry.AllocationDescriptors);\n      } else {\n        // store as exernal file data with Long_ad\n        myExtendedFileEntry.ICBTag.Flags = 1; // storage type long_ad\n\n        myExtendedFileEntry.LogicalBlocksRecorded = (long) (fileSize / blockSize);\n        if (fileSize % blockSize != 0) {\n          myExtendedFileEntry.LogicalBlocksRecorded++;\n        }\n\n        ArrayList<Long_ad> allocationDescriptors = new ArrayList<Long_ad>();\n\n        long restFileSize = fileSize;\n        long currentExtentPosition = nextFreeBlocks[1] - partitionStartingBlock;\n\n        while (restFileSize > 0) {\n          Long_ad allocationDescriptor = new Long_ad();\n\n          if (restFileSize < maximumAllocationLength) {\n            allocationDescriptor.ExtentLength = restFileSize;\n          } else {\n            allocationDescriptor.ExtentLength = maximumAllocationLength;\n          }\n\n          allocationDescriptor.ExtentLocation.part_num = 0;\n          allocationDescriptor.ExtentLocation.lb_num = currentExtentPosition;\n\n          allocationDescriptors.add(allocationDescriptor);\n\n          restFileSize -= maximumAllocationLength;\n\n          currentExtentPosition += (maximumAllocationLength / blockSize);\n          if (maximumAllocationLength % blockSize != 0) {\n            currentExtentPosition++;\n          }\n        }\n\n        byte allocationDescriptorBytes[] = new byte[allocationDescriptors.size() * 16];\n\n        int allocationDescriptorBytesPosition = 0;\n\n        for (int i = 0; i < allocationDescriptors.size(); ++i) {\n          byte singleAllocationDescriptorBytes[] = allocationDescriptors.get(i).getBytes();\n          System.arraycopy(\n              singleAllocationDescriptorBytes,\n              0,\n              allocationDescriptorBytes,\n              allocationDescriptorBytesPosition,\n              singleAllocationDescriptorBytes.length);\n          allocationDescriptorBytesPosition += singleAllocationDescriptorBytes.length;\n        }\n\n        myRandomAccessFile.seek(nextFreeBlocks[1] * blockSize);\n        writeFileData(myRandomAccessFile, currentUDFImageBuilderFile.getSourceFile());\n\n        nextFreeBlocks[1] += myExtendedFileEntry.LogicalBlocksRecorded;\n\n        myExtendedFileEntry.AllocationDescriptors = allocationDescriptorBytes;\n        myExtendedFileEntry.LengthofAllocationDescriptors = allocationDescriptorBytes.length;\n      }\n    }\n\n    myExtendedFileEntry.ObjectSize = myExtendedFileEntry.InformationLength;\n    myExtendedFileEntry.CreationTime = new Timestamp(currentUDFImageBuilderFile.getCreationTime());\n\n    myRandomAccessFile.seek(currentMetadataBlock * blockSize);\n    myExtendedFileEntry.write(myRandomAccessFile, blockSize);\n\n    return nextFreeBlocks;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6809, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [150], "initializationEnd": [179], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 1255, "focalAPIEnd": 1269, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.getChannel()", "randomAccessFile.length()"], "useStart": [1281, 1351], "useEnd": [1297, 1363], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/redstar3894/android-gcc/tree/master/libjava/gnu/gcj/runtime/PersistentByteMap.java", "rawCode": "  private void init(PersistentByteMap m, File f, int capacity, int strtabSize) throws IOException {\n    f.createNewFile();\n    RandomAccessFile raf = new RandomAccessFile(f, \"rw\");\n\n    {\n      // The user has explicitly provided a size for the table.\n      // We're going to make that size prime. This isn't\n      // strictly necessary but it can't hurt.\n      //\n      // We expand the size by 3/2 and round the result because the\n      // hash table is intolerably slow when more than 2/3 full.\n\n      BigInteger size = new BigInteger(Integer.toString(((capacity * 3) + 1) / 2));\n      BigInteger two = BigInteger.ONE.add(BigInteger.ONE);\n\n      if (size.getLowestSetBit() != 0) // A hard way to say isEven()\n      size = size.add(BigInteger.ONE);\n\n      while (!size.isProbablePrime(10)) size = size.add(two);\n\n      this.capacity = capacity = size.intValue();\n    }\n\n    table_base = 64;\n    string_base = table_base + capacity * TABLE_ENTRY_SIZE;\n    string_size = 0;\n    file_size = string_base;\n    elements = 0;\n\n    int totalFileSize = string_base + strtabSize;\n\n    // Create the file; this rounds up the size of the file to a fixed\n    // number of 4k pages.\n    byte[] _4k = new byte[4096];\n    for (long i = 0; i < totalFileSize; i += 4096) raf.write(_4k);\n\n    fc = raf.getChannel();\n    buf = fc.map(FileChannel.MapMode.READ_WRITE, 0, raf.length());\n\n    for (int i = 0; i < capacity; i++) putKeyPos(UNUSED_ENTRY, i);\n\n    putWord(0x67636a64, MAGIC);\n    putWord(0x01, VERSION);\n    putWord(capacity, CAPACITY);\n    putWord(table_base, TABLE_BASE);\n    putWord(string_base, STRING_BASE);\n    putWord(file_size, FILE_SIZE);\n    putWord(elements, ELEMENTS);\n    buf.force();\n\n    length = fc.size();\n    string_size = 0;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6810, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new BlockStoreException(*)"], "tryExpressionStart": 207, "tryExpressionEnd": 211, "tryBlockStart": 207, "tryBlockEnd": 395, "catchExpressionStart": 252, "catchExpressionEnd": 275, "catchBlockStart": 252, "catchBlockEnd": 395, "exceptionHandlingCallStart": [361], "exceptionHandlingCallEnd": [388], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 219, "focalAPIEnd": 232, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[])"], "useStart": [724], "useEnd": [761], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hank/litecoinj/tree/master/core/src/main/java/com/google/litecoin/store/DiskBlockStore.java", "rawCode": "  private void createNewStore(NetworkParameters params) throws BlockStoreException {\n    // Create a new block store if the file wasn't found or anything went wrong whilst reading.\n    blockMap.clear();\n    try {\n      file.write(1); // Version.\n    } catch (IOException e1) {\n      // We could not load a block store nor could we create a new one!\n      throw new BlockStoreException(e1);\n    }\n    try {\n      // Set up the genesis block. When we start out fresh, it is by definition the top of the\n      // chain.\n      Block genesis = params.genesisBlock.cloneAsHeader();\n      StoredBlock storedGenesis = new StoredBlock(genesis, genesis.getWork(), 0);\n      this.chainHead = storedGenesis.getHeader().getHash();\n      file.write(this.chainHead.getBytes());\n      put(storedGenesis);\n    } catch (VerificationException e1) {\n      throw new RuntimeException(e1); // Cannot happen.\n    } catch (IOException e) {\n      throw new BlockStoreException(e);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6811, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.io.RandomAccessFile.seek(long)"], "configurationStart": [195], "configurationEnd": [217], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 225, "focalAPIEnd": 256, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/visad/visad/tree/master/deps/src/ucar/netcdf/RandomAccessFile.java", "rawCode": "  /**\n   * Copy the contents of the buffer to the disk.\n   *\n   * @exception IOException if an I/O error occurrs.\n   */\n  public void flush() throws IOException {\n    if (bufferModified) {\n      file.seek(bufferStart);\n      file.write(buffer, 0, dataSize);\n      bufferModified = false;\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6812, "initialization": ["byte[] b = ByteArrayOutputStream.toByteArray()"], "initializationStart": [101], "initializationEnd": [124], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 231, "focalAPIEnd": 253, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dancres/blitzjavaspaces/tree/master/src/main/java/org/prevayler/implementation/DelegatingByteCountStream2.java", "rawCode": "  public void flush() throws IOException {\n    // System.err.println(\"Flush\");\n\n    byte[] myBytes = theBuffer.toByteArray();\n    theBuffer.reset();\n\n    // File was opened in \"rwd\" mode so we need do no more than write\n    //\n    theFile.write(myBytes);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6813, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "SecurityException", "exceptionHandlingCall": ["new FileSecurityException(*,String,*)"], "tryExpressionStart": 1374, "tryExpressionEnd": 1378, "tryBlockStart": 1374, "tryBlockEnd": 1728, "catchExpressionStart": 1429, "catchExpressionEnd": 1458, "catchBlockStart": 1429, "catchBlockEnd": 1528, "exceptionHandlingCallStart": [1472], "exceptionHandlingCallEnd": [1521], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [1386], "configurationEnd": [1397], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 1405, "focalAPIEnd": 1421, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Euphemiasan/Project_FrameData/tree/master/lib/hsqldb-2.2.8/hsqldb/src/org/hsqldb/persist/LockFile.java", "rawCode": "  /**\n   * Writes the {@link #MAGIC} value to this object's lock file that distiguishes it as an HSQLDB\n   * lock file.\n   *\n   * <p>\n   *\n   * @throws FileSecurityException possibly never (seek and write are native methods whose JavaDoc\n   *     entries do not actually specify throwing <tt>SecurityException</tt>). However, it is\n   *     conceivable that these native methods may, in turn, access Java methods that do throw\n   *     <tt>SecurityException</tt>. In this case, a <tt>SecurityException</tt> might be thrown if a\n   *     required system property value cannot be accessed, or if a security manager exists and its\n   *     <tt>{@link java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)}</tt> method denies\n   *     write access to the file\n   * @throws UnexpectedEndOfFileException if an end of file exception is thrown while attempting to\n   *     write the <tt>MAGIC</tt> value to the target file (typically, this cannot happen, but the\n   *     case is included to distiguish it from the general <tt>IOException</tt> case).\n   * @throws UnexpectedFileIOException if any other I/O error occurs while attepting to write the\n   *     <tt>MAGIC</tt> value to the target file.\n   */\n  private final void writeMagic()\n      throws LockFile.FileSecurityException, LockFile.UnexpectedEndOfFileException,\n          LockFile.UnexpectedFileIOException {\n\n    try {\n      raf.seek(0);\n      raf.write(MAGIC);\n    } catch (SecurityException ex) {\n      throw new FileSecurityException(this, \"writeMagic\", ex);\n    } catch (EOFException ex) {\n      throw new UnexpectedEndOfFileException(this, \"writeMagic\", ex);\n    } catch (IOException ex) {\n      throw new UnexpectedFileIOException(this, \"writeMagic\", ex);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6814, "initialization": ["byte[] b = AbstractDataType.writeByteArray()"], "initializationStart": [492], "initializationEnd": [515], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 523, "focalAPIEnd": 541, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tulskiy/musique/tree/master/dependencies/jaudiotagger/src/main/java/org/jaudiotagger/tag/lyrics3/AbstractLyrics3v2FieldFrameBody.java", "rawCode": "  /**\n   * Write the contents of this datatype to the file at the position it is currently at.\n   *\n   * @param file destination file\n   * @throws IOException on any I/O error\n   */\n  public void write(RandomAccessFile file) throws IOException {\n    // Write the various fields to file in order\n    byte[] buffer;\n    AbstractDataType object;\n    Iterator<AbstractDataType> iterator = objectList.listIterator();\n    while (iterator.hasNext()) {\n      object = iterator.next();\n      buffer = object.writeByteArray();\n      file.write(buffer);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6815, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["toString()", "Logger.debug(String)"], "tryExpressionStart": 868, "tryExpressionEnd": 872, "tryBlockStart": 868, "tryBlockEnd": 1016, "catchExpressionStart": 934, "catchExpressionEnd": 954, "catchBlockStart": 934, "catchBlockEnd": 1016, "exceptionHandlingCallStart": [996, 962], "exceptionHandlingCallEnd": [1008, 1009], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 880, "focalAPIEnd": 926, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/StigLau/vdvil/tree/master/audio-renderer/src/main/java/no/bouvet/kpro/renderer/audio/WaveFileTarget.java", "rawCode": "  /**\n   * Writes one or more samples to the audio target.\n   *\n   * <p>Audio sample data is passed within a byte array, where each sample is represented by four\n   * bytes. The first two bytes are a signed little-endian 16-bit value for the left channel\n   * intensity, and the last two bytes are a signed little-endian 16-bit value for the right channel\n   * intensity.\n   *\n   * @param buffer An array of bytes that contains the sample data to write, where each sample is\n   *     four bytes\n   * @param offset The offset into buffer of the first sample to write, measured in samples (i.e.\n   *     units of 4 bytes)\n   * @param duration The number of samples to write, measured in samples\n   * @return The number of samples written, which may be less than requested\n   */\n  public int write(byte[] buffer, int offset, int duration) {\n    // Write the samples\n\n    try {\n      _raf.write(buffer, offset << 2, duration << 2);\n    } catch (Exception e) {\n      log.debug(\"Exception writing: \" + e.toString());\n    }\n\n    // Increment the duration\n\n    _duration += duration;\n\n    return duration;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6816, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [311], "initializationEnd": [347], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 294, "tryExpressionEnd": 298, "tryBlockStart": 294, "tryBlockEnd": 629, "catchExpressionStart": 401, "catchExpressionEnd": 421, "catchBlockStart": 401, "catchBlockEnd": 476, "exceptionHandlingCallStart": [429], "exceptionHandlingCallEnd": [448], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 355, "focalAPIEnd": 393, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [535], "useEnd": [545], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 477, "finallyExpressionEnd": 485, "finallyBlockStart": 477, "finallyBlockEnd": 629, "cleanUpCallStart": [535], "cleanUpCallEnd": [545], "url": "https://github.com/firefoxmmx2/techsupport/tree/master/src/com/aisino2/basicsystem/action/QyxxExpImpAction.java", "rawCode": "  public String writeXmlFile(byte[] bytetemp) {\n    String serviceFile = ServletActionContext.getRequest().getRealPath(\"qyrzxxTemp\");\n    long nowtime = System.currentTimeMillis();\n    String fileName = serviceFile + \"\\\\\" + String.valueOf(nowtime) + \".xml\";\n    RandomAccessFile os = null;\n    try {\n      os = new RandomAccessFile(fileName, \"rw\");\n      os.write(bytetemp, 0, bytetemp.length);\n    } catch (Exception e) {\n      e.printStackTrace();\n      fileName = \"\";\n    } finally {\n      try {\n        if (os != null) {\n          os.close();\n        }\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n    }\n    return fileName;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6817, "initialization": ["byte[] b = String.getBytes(String)"], "initializationStart": [77], "initializationEnd": [95], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 101, "focalAPIEnd": 120, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fiji/ImageJA/tree/master/src/main/java/ij/plugin/filter/AVI_Writer.java", "rawCode": "  private void writeString(String s) throws IOException {\n    byte[] bytes = s.getBytes(\"UTF8\");\n    raFile.write(bytes);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6818, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [649], "initializationEnd": [687], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 932, "tryExpressionEnd": 936, "tryBlockStart": 932, "tryBlockEnd": 1069, "catchExpressionStart": 1011, "catchExpressionEnd": 1031, "catchBlockStart": 1011, "catchBlockEnd": 1069, "exceptionHandlingCallStart": [1041], "exceptionHandlingCallEnd": [1060], "configuration": ["randomAccessFile.setLength(long)", "randomAccessFile.seek(int)"], "configurationStart": [693, 728], "configurationEnd": [722, 739], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 946, "focalAPIEnd": 969, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [1624], "useEnd": [1635], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sunqimin09/FirstApp/tree/master/AppVideo/src/com/example/appvideo/play/BBVideoPlayer.java", "rawCode": "  /** 下载和缓冲mp4文件头部数据 */\n  private void prepareVideo() throws IOException {\n    URL url = new URL(remoteUrl);\n    HttpURLConnection httpConnection = (HttpURLConnection) url.openConnection();\n    httpConnection.setConnectTimeout(3000);\n    httpConnection.setRequestProperty(\"RANGE\", \"bytes=\" + 0 + \"-\");\n\n    InputStream is = httpConnection.getInputStream();\n\n    videoTotalSize = httpConnection.getContentLength();\n    if (videoTotalSize == -1) {\n      return;\n    }\n\n    File cacheFile = new File(localUrl);\n\n    if (!cacheFile.exists()) {\n      cacheFile.getParentFile().mkdirs();\n      cacheFile.createNewFile();\n    }\n\n    RandomAccessFile raf = new RandomAccessFile(cacheFile, \"rws\");\n    raf.setLength(videoTotalSize);\n    raf.seek(0);\n\n    byte buf[] = new byte[10 * 1024];\n    int size = 0;\n\n    videoCacheSize = 0;\n    int buffercnt = 0;\n    Message msg = null;\n    while ((size = is.read(buf)) != -1 && (!isready)) {\n      try {\n        raf.write(buf, 0, size);\n        videoCacheSize += size;\n      } catch (Exception e) {\n        e.printStackTrace();\n      }\n      Log.d(\"tag\", \"Loading--->\" + videoCacheSize + \"++\" + READY_BUFF);\n      // 可以在这里添加，数据加载百分数\n      if (videoCacheSize < READY_BUFF) {\n        msg = mHandler.obtainMessage();\n        msg.what = VIDEO_LOADING;\n        msg.arg1 = (100 * (int) videoCacheSize) / READY_BUFF;\n        mHandler.sendMessage(msg);\n      }\n\n      if (videoCacheSize > READY_BUFF && (buffercnt++ % 20 == 0)) {\n        mHandler.sendEmptyMessage(CACHE_VIDEO_READY);\n      }\n    }\n\n    if (!isready) {\n      mHandler.sendEmptyMessage(CACHE_VIDEO_READY);\n    }\n\n    is.close();\n    raf.close();\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6819, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "randomAccessFile!=null", "guardType": "IF {", "guardExpressionStart": 353, "guardExpressionEnd": 369, "guardBlockStart": 353, "guardBlockEnd": 468, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 378, "focalAPIEnd": 409, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/and146/SPLAT-ARI/tree/master/ant/src/main/org/apache/tools/zip/ZipOutputStream.java", "rawCode": "  /**\n   * Write bytes to output or random access file.\n   *\n   * @param data the byte array to write\n   * @param offset the start position to write from\n   * @param length the number of bytes to write\n   * @throws IOException on error\n   * @since 1.14\n   */\n  protected final void writeOut(byte[] data, int offset, int length) throws IOException {\n    if (raf != null) {\n      raf.write(data, offset, length);\n    } else {\n      out.write(data, offset, length);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6820, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,*,int)"], "initializationStart": [997], "initializationEnd": [1104], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 896, "tryExpressionEnd": 900, "tryBlockStart": 896, "tryBlockEnd": 3660, "catchExpressionStart": 3606, "catchExpressionEnd": 3626, "catchBlockStart": 3606, "catchBlockEnd": 3660, "exceptionHandlingCallStart": [3634], "exceptionHandlingCallEnd": [3653], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "off<b.length", "guardType": "LOOP {", "guardExpressionStart": 811, "guardExpressionEnd": 848, "guardBlockStart": 811, "guardBlockEnd": 890, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 1297, "focalAPIEnd": 1330, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [1371], "useEnd": [1386], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/molgenis/systemsgenetics/tree/master/genetica-libraries/src/main/java/umcg/genetica/io/bin/RandomAccessFile.java", "rawCode": "  /**\n   * Test the block operations of the RandomAccessFile class. These are the methods that read/write\n   * blocks of data. The following checks are made:\n   *\n   * <ul>\n   *   <li>Writing blocks of data that are smaller than the buffer size.\n   *   <li>Writing blocks of data that are larger than the buffer size.\n   *   <li>Checking the size of the file is correct.\n   *   <li>Reading small blocks of the file back in and verifying its contents.\n   *   <li>Reading large blocks of the file back in and verifying its contents.\n   * </ul>\n   *\n   * @param filename the name of the test file to generate.\n   */\n  public static void testBlocks(String filename) {\n\n    System.err.println(\"\\nTesting block operations...\");\n\n    // Generate the data.\n    int bufferSize = 10;\n    byte data[] = new byte[256];\n    for (int i = 0; i < data.length; i++) {\n      data[i] = (byte) (i % 256);\n    }\n\n    try {\n\n      // Write the data in small and large blocks.\n      RandomAccessFile outFile =\n          new RandomAccessFile(\n              filename, RandomAccessFile.WRITE | RandomAccessFile.CREATE, bufferSize);\n      for (int i = 0; i < data.length; ) {\n        int blockSize = (i < data.length / 2) ? 3 : 13;\n        blockSize = (i + blockSize >= data.length) ? (data.length - i) : blockSize;\n        outFile.write(data, i, blockSize);\n        i += blockSize;\n      }\n\n      outFile.close();\n\n      // Check that the file length is correct.\n      if ((new File(filename)).length() != data.length) {\n        System.out.println(\n            \"X New file size incorrect (should be \"\n                + data.length\n                + \", but is \"\n                + (new File(filename)).length()\n                + \").\");\n      } else {\n        System.out.println(\". File size correct (\" + data.length + \").\");\n      }\n\n      // Reopen the file for reading.\n      RandomAccessFile inFile = new RandomAccessFile(filename, RandomAccessFile.READ, bufferSize);\n\n      // Read and check random small blocks of data.\n      boolean verified = true;\n      int firstFailure = 256;\n      Random random = new Random(0);\n      byte block[] = new byte[(int) (bufferSize * 0.5)];\n      for (int i = 0; i < 100; i++) {\n        int index = Math.abs(random.nextInt()) % (data.length - block.length);\n        inFile.seek(index);\n        inFile.read(block);\n\n        // Verify the block of data.\n        for (int j = 0; j < block.length; j++) {\n          if (block[j] != data[index + j]) {\n            verified = false;\n            if (index + j < firstFailure) {\n              firstFailure = index + j;\n            }\n          }\n        }\n      }\n      if (verified) {\n        System.err.println(\". Reading small blocks verified.\");\n      } else {\n        System.err.println(\"X Reading small blocks failed (byte \" + firstFailure + \").\");\n      }\n\n      // Read and check random large (bigger than the bufferSize) blocks\n      // of data.\n      verified = true;\n      random = new Random(0);\n      block = new byte[(int) (bufferSize * 1.5)];\n      for (int i = 0; i < 100; i++) {\n        int index = Math.abs(random.nextInt()) % (data.length - block.length);\n        inFile.seek(index);\n        inFile.read(block);\n\n        // Verify the block of data.\n        for (int j = 0; j < block.length; j++) {\n          if (block[j] != data[j + index]) {\n            verified = false;\n          }\n        }\n      }\n      if (verified) {\n        System.err.println(\". Reading large blocks verified.\");\n      } else {\n        System.err.println(\"X Reading large blocks failed.\");\n      }\n\n      // Close the input file.\n      inFile.close();\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6821, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)", "int len = InputStream.read(byte[])"], "initializationStart": [1525, 1746], "initializationEnd": [1561, 1763], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 1803, "focalAPIEnd": 1832, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.seek(int)"], "useStart": [1862], "useEnd": [1873], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/OMFGB/dalvik/tree/master/tools/dexdeps/src/com/android/dexdeps/Main.java", "rawCode": "  /**\n   * Tries to open the input file as a Zip archive (jar/apk) with a \"classes.dex\" inside.\n   *\n   * @return a RandomAccessFile for classes.dex, or null if the input file is not a zip archive\n   * @throws IOException if the file isn't found, or it's a zip and classes.dex isn't found inside\n   */\n  RandomAccessFile openInputFileAsZip() throws IOException {\n    ZipFile zipFile;\n\n    /*\n     * Try it as a zip file.\n     */\n    try {\n      zipFile = new ZipFile(mInputFileName);\n    } catch (FileNotFoundException fnfe) {\n      /* not found, no point in retrying as non-zip */\n      System.err.println(\"Unable to open '\" + mInputFileName + \"': \" + fnfe.getMessage());\n      throw fnfe;\n    } catch (ZipException ze) {\n      /* not a zip */\n      return null;\n    }\n\n    /*\n     * We know it's a zip; see if there's anything useful inside. A\n     * failure here results in some type of IOException (of which\n     * ZipException is a subclass).\n     */\n    ZipEntry entry = zipFile.getEntry(CLASSES_DEX);\n    if (entry == null) {\n      System.err.println(\"Unable to find '\" + CLASSES_DEX + \"' in '\" + mInputFileName + \"'\");\n      zipFile.close();\n      throw new ZipException();\n    }\n\n    InputStream zis = zipFile.getInputStream(entry);\n\n    /*\n     * Create a temp file to hold the DEX data, open it, and delete it\n     * to ensure it doesn't hang around if we fail.\n     */\n    File tempFile = File.createTempFile(\"dexdeps\", \".dex\");\n    // System.out.println(\"+++ using temp \" + tempFile);\n    RandomAccessFile raf = new RandomAccessFile(tempFile, \"rw\");\n    tempFile.delete();\n\n    /*\n     * Copy all data from input stream to output file.\n     */\n    byte copyBuf[] = new byte[32768];\n    int actual;\n\n    while (true) {\n      actual = zis.read(copyBuf);\n      if (actual == -1) break;\n\n      raf.write(copyBuf, 0, actual);\n    }\n\n    zis.close();\n    raf.seek(0);\n\n    return raf;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6822, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [629], "initializationEnd": [687], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 693, "focalAPIEnd": 708, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ekirkilevics/TestSSQL/tree/master/sql12/fw/src/test/java/net/sourceforge/squirrel_sql/fw/util/FileTest.java", "rawCode": "  /** @tests java.io.File#length() */\n  public void test_length() throws IOException {\n    FileWrapper f = new FileWrapperImpl(System.getProperty(\"user.dir\"), platformId + \"input.tst\");\n    assertEquals(\"File Length Should Have Returned 0.\", 0, f.length());\n    FileOutputStream fos = new FileOutputStream(f.getAbsolutePath());\n    fos.write(fileString.getBytes());\n    fos.close();\n    assertEquals(\"Incorrect file length returned\", fileString.length(), f.length());\n    f.delete();\n\n    // regression test for HARMONY-1497\n    f = FileWrapperImpl.createTempFile(\"test\", \"tmp\");\n    f.deleteOnExit();\n    RandomAccessFile raf = new RandomAccessFile(new File(f.getAbsolutePath()), \"rwd\");\n    raf.write(0x41);\n    assertEquals(1, f.length());\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6823, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 317, "focalAPIEnd": 346, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[],int,int)"], "useStart": [352], "useEnd": [390], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vokalinteractive/android_packages_apps_Mms/tree/master/src/com/android/mms/util/BlobCache.java", "rawCode": "  private void insertInternal(long key, byte[] data, int length) throws IOException {\n    byte[] header = mBlobHeader;\n    int sum = checkSum(data);\n    writeLong(header, BH_KEY, key);\n    writeInt(header, BH_CHECKSUM, sum);\n    writeInt(header, BH_OFFSET, mActiveBytes);\n    writeInt(header, BH_LENGTH, length);\n    mActiveDataFile.write(header);\n    mActiveDataFile.write(data, 0, length);\n\n    mIndexBuffer.putLong(mSlotOffset, key);\n    mIndexBuffer.putInt(mSlotOffset + 8, mActiveBytes);\n    mActiveBytes += BLOB_HEADER_SIZE + length;\n    writeInt(mIndexHeader, IH_ACTIVE_BYTES, mActiveBytes);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6824, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)", "int len = min(*,*)"], "initializationStart": [1609, 2937], "initializationEnd": [1654, 2999], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 3093, "focalAPIEnd": 3156, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [3409], "useEnd": [3424], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 3354, "finallyExpressionEnd": 3362, "finallyBlockStart": 3354, "finallyBlockEnd": 3521, "cleanUpCallStart": [3409], "cleanUpCallEnd": [3424], "url": "https://github.com/commoncrawl/commoncrawl-crawler/tree/master/src/org/commoncrawl/service/listcrawler/CacheManager.java", "rawCode": "  private final void flushLocalLog(\n      final long bytesToRemove,\n      final int itemsToRemove,\n      final List<FingerprintAndOffsetTuple> flushedTupleList,\n      final ArrayList<IndexDataFileTriple> tempFileTriples) {\n\n    LOG.info(\"Acquiring Log Access Semaphores\");\n    // first boost this thread's priority ...\n    int originalThreadPriority = Thread.currentThread().getPriority();\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);\n    // next acquire all permits to the local access log ... block until we get there ...\n    getLocalLogAccessSemaphore().acquireUninterruptibly(LOG_ACCESS_SEMAPHORE_COUNT);\n    // now that we have all the semaphores we need, reduce the thread's priority to normal\n    Thread.currentThread().setPriority(originalThreadPriority);\n    LOG.info(\"Acquired ALL Log Access Semaphores\");\n\n    long timeStart = System.currentTimeMillis();\n\n    // now we have exclusive access to the local transaction log ...\n    File activeLogFilePath = getActiveLogFilePath();\n    File checkpointLogFilePath = getCheckpointLogFilePath();\n    try {\n      // delete checkpoint file if it existed ...\n      checkpointLogFilePath.delete();\n      // now rename activelog to checkpoint path\n      activeLogFilePath.renameTo(checkpointLogFilePath);\n\n      long logFileConsolidationStartTime = System.currentTimeMillis();\n      // now trap for exceptions in case something fails\n      try {\n        // fix up the header ...\n        _header._fileSize -= bytesToRemove;\n        _header._itemCount -= itemsToRemove;\n\n        // open a old file and new file\n        RandomAccessFile newFile = new RandomAccessFile(activeLogFilePath, \"rw\");\n        RandomAccessFile oldFile = new RandomAccessFile(checkpointLogFilePath, \"r\");\n\n        LOG.info(\n            \"Opened new and old files. New Header FileSize is:\"\n                + _header._fileSize\n                + \" ItemCount:\"\n                + _header._itemCount);\n        try {\n          // write out header ...\n          long bytesRemainingInLogFile = _header._fileSize;\n\n          LOG.info(\n              \"Writing Header to New File. Bytes Remaining for Data are:\"\n                  + bytesRemainingInLogFile);\n          // write header to new file ...\n          _header.writeHeader(newFile);\n          // decrement bytes available ...\n          bytesRemainingInLogFile -= LocalLogFileHeader.SIZE;\n\n          if (bytesRemainingInLogFile != 0) {\n            byte transferBuffer[] = new byte[(1 << 20) * 16];\n            LOG.info(\n                \"Seeking old file past flushed data (pos:\"\n                    + LocalLogFileHeader.SIZE\n                    + bytesToRemove\n                    + \")\");\n            // seek past old data ...\n            oldFile.seek(LocalLogFileHeader.SIZE + bytesToRemove);\n            // and copy across remaining data\n            while (bytesRemainingInLogFile != 0) {\n              int bytesToReadWriteThisIteration =\n                  Math.min((int) bytesRemainingInLogFile, transferBuffer.length);\n              oldFile.read(transferBuffer, 0, bytesToReadWriteThisIteration);\n              newFile.write(transferBuffer, 0, bytesToReadWriteThisIteration);\n              LOG.info(\"Copied \" + bytesToReadWriteThisIteration + \" from Old to New\");\n              bytesRemainingInLogFile -= bytesToReadWriteThisIteration;\n            }\n          }\n        } finally {\n          if (newFile != null) {\n            newFile.close();\n          }\n          if (oldFile != null) {\n            oldFile.close();\n          }\n        }\n        // if we reached here then checkpoint was successfull ...\n        LOG.info(\n            \"Checkpoint - Log Consolidation Successfull! TOOK:\"\n                + (System.currentTimeMillis() - logFileConsolidationStartTime));\n\n        LOG.info(\"Loading Index Files\");\n        for (IndexDataFileTriple triple : tempFileTriples) {\n          LOG.info(\"Loading Index File:\" + triple._localIndexFilePath);\n          final HDFSFileIndex fileIndex =\n              new HDFSFileIndex(\n                  _remoteFileSystem, triple._localIndexFilePath, triple._dataFilePath);\n          LOG.info(\"Loaded Index File\");\n          // update hdfs index list ...\n          synchronized (CacheManager.this) {\n            LOG.info(\"Adding HDFS Index to list\");\n            _hdfsIndexList.addElement(fileIndex);\n          }\n        }\n\n        // create a semaphore to wait on\n        final Semaphore semaphore = new Semaphore(0);\n\n        LOG.info(\"Scheduling Async Event\");\n        // now we need to schedule an async call to main thread to update data structures safely ...\n        _eventLoop.setTimer(\n            new Timer(\n                0,\n                false,\n                new Timer.Callback() {\n\n                  @Override\n                  public void timerFired(Timer timer) {\n                    LOG.info(\"Cleaning Map\");\n\n                    synchronized (CacheManager.this) {\n                      // walk tuples\n                      for (FingerprintAndOffsetTuple tuple : flushedTupleList) {\n                        // TODO: HACK!\n                        // remove from collection ...\n                        _fingerprintToLocalLogPos.removeAll(tuple._fingerprint);\n                      }\n                    }\n                    LOG.info(\"Increment Offset Info\");\n                    // finally increment locallog offset by bytes removed ...\n                    _localLogStartOffset += bytesToRemove;\n\n                    LOG.info(\"Releasing Wait Semaphore\");\n                    // release wait sempahore\n                    semaphore.release();\n                  }\n                }));\n\n        LOG.info(\"Waiting for Async Event to Complete\");\n        // wait for async operation to complete ...\n        semaphore.acquireUninterruptibly();\n\n        LOG.info(\"Async Event to Completed\");\n      } catch (IOException e) {\n        LOG.error(\"Checkpoint Failed with Exception:\" + CCStringUtils.stringifyException(e));\n        // delete new file ...\n        activeLogFilePath.delete();\n        // and rename checkpoint file to active file ...\n        checkpointLogFilePath.renameTo(activeLogFilePath);\n      }\n    } finally {\n      LOG.info(\n          \"Releasing ALL Log Access Semaphores. HELD FOR:\"\n              + (System.currentTimeMillis() - timeStart));\n      getLocalLogAccessSemaphore().release(LOG_ACCESS_SEMAPHORE_COUNT);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6825, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 1071, "focalAPIEnd": 1104, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/angusmacdonald/h2o/tree/master/src/test/org/h2/test/unit/TestFileSystem.java", "rawCode": "  private void testRandomAccess(String fsBase) throws Exception {\n    FileSystem fs = FileSystem.getInstance(fsBase);\n    String s = fs.createTempFile(fsBase + \"/temp\", \".tmp\", false, false);\n    File file = new File(baseDir + \"/temp\");\n    file.delete();\n    RandomAccessFile ra = new RandomAccessFile(file, \"rw\");\n    fs.delete(s);\n    FileObject f = fs.openFileObject(s, \"rw\");\n    try {\n      f.readFully(new byte[1], 0, 1);\n      fail();\n    } catch (EOFException e) {\n      // expected\n    }\n    f.sync();\n    Random random = new Random(1);\n    int size = getSize(100, 500);\n    for (int i = 0; i < size; i++) {\n      int pos = random.nextInt(10000);\n      switch (random.nextInt(7)) {\n        case 0:\n          {\n            pos = (int) Math.min(pos, ra.length());\n            trace(\"seek \" + pos);\n            f.seek(pos);\n            ra.seek(pos);\n            break;\n          }\n        case 1:\n          {\n            byte[] buffer = new byte[random.nextInt(1000)];\n            random.nextBytes(buffer);\n            trace(\"write \" + buffer.length);\n            f.write(buffer, 0, buffer.length);\n            ra.write(buffer, 0, buffer.length);\n            break;\n          }\n        case 2:\n          {\n            f.setFileLength(pos);\n            ra.setLength(pos);\n            if (ra.getFilePointer() > pos) {\n              f.seek(0);\n              ra.seek(0);\n            }\n            trace(\"setLength \" + pos);\n            break;\n          }\n        case 3:\n          {\n            int len = random.nextInt(1000);\n            len = (int) Math.min(len, ra.length() - ra.getFilePointer());\n            byte[] b1 = new byte[len];\n            byte[] b2 = new byte[len];\n            ra.readFully(b1, 0, len);\n            f.readFully(b2, 0, len);\n            trace(\"readFully \" + len);\n            assertEquals(b1, b2);\n            break;\n          }\n        case 4:\n          {\n            trace(\"getFilePointer\");\n            assertEquals(ra.getFilePointer(), f.getFilePointer());\n            break;\n          }\n        case 5:\n          {\n            trace(\"length \" + ra.length());\n            assertEquals(ra.length(), f.length());\n            break;\n          }\n        case 6:\n          {\n            trace(\"reopen\");\n            f.close();\n            ra.close();\n            ra = new RandomAccessFile(file, \"rw\");\n            f = fs.openFileObject(s, \"rw\");\n            assertEquals(ra.length(), f.length());\n            break;\n          }\n        default:\n      }\n    }\n    f.close();\n    ra.close();\n    fs.close();\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6826, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 52, "focalAPIEnd": 64, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ivmai/JCGO/tree/master/jtrsrc/com/ivmaisoft/jcgo/FileAppendOutput.java", "rawCode": "  public void write(int v) throws IOException {\n    raf.write(v);\n    Main.dict.outBytesCount++;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6827, "initialization": ["RandomAccessFile randomAccessFile = getDescriptor()"], "initializationStart": [105], "initializationEnd": [120], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [222], "configurationEnd": [233], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 241, "focalAPIEnd": 253, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["putDescriptor(randomAccessFile)"], "useStart": [277], "useEnd": [295], "hasFinally": 1, "cleanUpCall": ["putDescriptor(RandomAccessFile)"], "finallyExpressionStart": 261, "finallyExpressionEnd": 269, "finallyBlockStart": 261, "finallyBlockEnd": 302, "cleanUpCallStart": [277], "cleanUpCallEnd": [295], "url": "https://github.com/sisbell/jxta/tree/master/j2se/core/src/main/java/net/jxta/impl/xindice/core/filer/Paged.java", "rawCode": "  private void createFile() throws IOException {\n    RandomAccessFile raf = null;\n\n    try {\n      raf = getDescriptor();\n      long o = fileHeader.headerSize + (fileHeader.pageCount + 1) * fileHeader.pageSize - 1;\n\n      raf.seek(o);\n      raf.write(0);\n    } finally {\n      putDescriptor(raf);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6828, "initialization": ["byte[] b = patternToHash(List<LockPatternView.Cell>)", "RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [297, 409], "initializationEnd": [336, 457], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["e(String,String)"], "tryExpressionStart": 342, "tryExpressionEnd": 346, "tryBlockStart": 342, "tryBlockEnd": 2112, "catchExpressionStart": 1773, "catchExpressionEnd": 1808, "catchBlockStart": 1773, "catchBlockEnd": 1982, "exceptionHandlingCallStart": [1907], "exceptionHandlingCallEnd": [1975], "configuration": ["randomAccessFile.setLength(int)"], "configurationStart": [561], "configurationEnd": [577], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 602, "focalAPIEnd": 633, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [649], "useEnd": [660], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/munjeni/miui_sony_xperia/tree/master/miui/src/frameworks/base/core/java/com/android/internal/widget/LockPatternUtils.java", "rawCode": "  /**\n   * Save a lock pattern.\n   *\n   * @param pattern The new pattern to save.\n   * @param isFallback Specifies if this is a fallback to biometric weak\n   */\n  public void saveLockPattern(List<LockPatternView.Cell> pattern, boolean isFallback) {\n    // Compute the hash\n    final byte[] hash = LockPatternUtils.patternToHash(pattern);\n    try {\n      // Write the hash to file\n      RandomAccessFile raf = new RandomAccessFile(sLockPatternFilename, \"rw\");\n      // Truncate the file if pattern is null, to clear the lock\n      if (pattern == null) {\n        raf.setLength(0);\n      } else {\n        raf.write(hash, 0, hash.length);\n      }\n      raf.close();\n      DevicePolicyManager dpm = getDevicePolicyManager();\n      KeyStore keyStore = KeyStore.getInstance();\n      if (pattern != null) {\n        keyStore.password(patternToString(pattern));\n        setBoolean(PATTERN_EVER_CHOSEN_KEY, true);\n        if (!isFallback) {\n          deleteGallery();\n          setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);\n          dpm.setActivePasswordState(\n              DevicePolicyManager.PASSWORD_QUALITY_SOMETHING, pattern.size(), 0, 0, 0, 0, 0, 0);\n        } else {\n          setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK);\n          setLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);\n          finishBiometricWeak();\n          dpm.setActivePasswordState(\n              DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK, 0, 0, 0, 0, 0, 0, 0);\n        }\n      } else {\n        if (keyStore.isEmpty()) {\n          keyStore.reset();\n        }\n        dpm.setActivePasswordState(\n            DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED, 0, 0, 0, 0, 0, 0, 0);\n      }\n    } catch (FileNotFoundException fnfe) {\n      // Cant do much, unless we want to fail over to using the settings\n      // provider\n      Log.e(TAG, \"Unable to save lock pattern to \" + sLockPatternFilename);\n    } catch (IOException ioe) {\n      // Cant do much\n      Log.e(TAG, \"Unable to save lock pattern to \" + sLockPatternFilename);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6829, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [354], "initializationEnd": [389], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 336, "tryExpressionEnd": 340, "tryBlockStart": 336, "tryBlockEnd": 946, "catchExpressionStart": 821, "catchExpressionEnd": 852, "catchBlockStart": 821, "catchBlockEnd": 909, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [455], "configurationEnd": [472], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 480, "focalAPIEnd": 499, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.getChannel()", "randomAccessFile.close()", "randomAccessFile.close()"], "useStart": [507, 543, 800], "useEnd": [523, 554, 811], "hasFinally": 1, "cleanUpCall": ["Deflater.end()"], "finallyExpressionStart": 690, "finallyExpressionEnd": 698, "finallyBlockStart": 690, "finallyBlockEnd": 946, "cleanUpCallStart": [723], "cleanUpCallEnd": [732], "url": "https://github.com/eclipse/jgit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/ObjectDirectoryPackParser.java", "rawCode": "  /** {@inheritDoc} */\n  @Override\n  public PackLock parse(ProgressMonitor receiving, ProgressMonitor resolving) throws IOException {\n    tmpPack =\n        File.createTempFile(\"incoming_\", \".pack\", db.getDirectory()); // $NON-NLS-1$ //$NON-NLS-2$\n    tmpIdx = new File(db.getDirectory(), baseName(tmpPack) + \".idx\"); // $NON-NLS-1$\n    try {\n      out = new RandomAccessFile(tmpPack, \"rw\"); // $NON-NLS-1$\n\n      super.parse(receiving, resolving);\n\n      out.seek(packEnd);\n      out.write(packHash);\n      out.getChannel().force(true);\n      out.close();\n\n      writeIdx();\n\n      tmpPack.setReadOnly();\n      tmpIdx.setReadOnly();\n\n      return renameAndOpenPack(getLockMessage());\n    } finally {\n      if (def != null) def.end();\n      try {\n        if (out != null && out.getChannel().isOpen()) out.close();\n      } catch (IOException closeError) {\n        // Ignored. We want to delete the file.\n      }\n      cleanupTemporaryFiles();\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6830, "initialization": ["byte[] b = ByteArrayOutputStream.toByteArray()", "RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [3889, 3991], "initializationEnd": [3906, 4023], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "Utils.compareNotNull(data,b,)!=0", "guardType": "IF {", "guardExpressionStart": 3914, "guardExpressionEnd": 3959, "guardBlockStart": 3914, "guardBlockEnd": 4172, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 4033, "focalAPIEnd": 4049, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.setLength(int)", "randomAccessFile.close()"], "useStart": [4059, 4096], "useEnd": [4086, 4105], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/coderplay/h2-bitmap/tree/master/h2/src/tools/org/h2/build/code/CheckTextFiles.java", "rawCode": "  /**\n   * Check a source code file. The following properties are checked: copyright, license, incorrect\n   * source switches, trailing white space, newline characters, tab characters, and characters codes\n   * (only characters below 128 are allowed).\n   *\n   * @param file the file to check\n   * @param fix automatically fix newline characters and trailing spaces\n   * @param checkLicense check the license and copyright\n   */\n  public void checkOrFixFile(File file, boolean fix, boolean checkLicense) throws Exception {\n    RandomAccessFile in = new RandomAccessFile(file, \"r\");\n    byte[] data = new byte[(int) file.length()];\n    ByteArrayOutputStream out = fix ? new ByteArrayOutputStream() : null;\n    in.readFully(data);\n    in.close();\n    if (checkLicense) {\n      if (data.length > COPYRIGHT.length() + LICENSE.length()) {\n        // don't check tiny files\n        String text = new String(data);\n        if (text.indexOf(COPYRIGHT) < 0) {\n          fail(file, \"copyright is missing\", 0);\n        }\n        if (text.indexOf(LICENSE) < 0) {\n          fail(file, \"license is missing\", 0);\n        }\n        if (text.indexOf(\"// \" + \"##\") > 0) {\n          fail(file, \"unexpected space between // and ##\", 0);\n        }\n        if (text.indexOf(\"/* \" + \"##\") > 0) {\n          fail(file, \"unexpected space between /* and ##\", 0);\n        }\n        if (text.indexOf(\"##\" + \" */\") > 0) {\n          fail(file, \"unexpected space between ## and */\", 0);\n        }\n      }\n    }\n    int line = 1;\n    boolean lastWasWhitespace = false;\n    for (int i = 0; i < data.length; i++) {\n      char ch = (char) (data[i] & 0xff);\n      boolean isWhitespace = Character.isWhitespace(ch);\n      if (ch > 127) {\n        fail(file, \"contains character \" + (int) ch + \" at \" + new String(data, i - 10, 20), line);\n        return;\n      } else if (ch < 32) {\n        if (ch == '\\n') {\n          if (lastWasWhitespace && !allowTrailingSpaces) {\n            fail(file, \"contains trailing white space\", line);\n            return;\n          }\n          if (fix) {\n            if (useCRLF) {\n              out.write('\\r');\n            }\n            out.write(ch);\n          }\n          lastWasWhitespace = false;\n          line++;\n        } else if (ch == '\\r') {\n          if (!allowCR) {\n            fail(file, \"contains CR\", line);\n            return;\n          }\n          if (lastWasWhitespace && !allowTrailingSpaces) {\n            fail(file, \"contains trailing white space\", line);\n            return;\n          }\n          lastWasWhitespace = false;\n          // ok\n        } else if (ch == '\\t') {\n          if (fix) {\n            for (int j = 0; j < spacesPerTab; j++) {\n              out.write(' ');\n            }\n          } else {\n            if (!allowTab) {\n              fail(file, \"contains TAB\", line);\n              return;\n            }\n          }\n          lastWasWhitespace = true;\n          // ok\n        } else {\n          fail(file, \"contains character \" + (int) ch, line);\n          return;\n        }\n      } else if (isWhitespace) {\n        lastWasWhitespace = true;\n        if (fix) {\n          boolean write = true;\n          for (int j = i + 1; j < data.length; j++) {\n            char ch2 = (char) (data[j] & 0xff);\n            if (ch2 == '\\n' || ch2 == '\\r') {\n              write = false;\n              lastWasWhitespace = false;\n              ch = ch2;\n              i = j - 1;\n              break;\n            } else if (!Character.isWhitespace(ch2)) {\n              break;\n            }\n          }\n          if (write) {\n            out.write(ch);\n          }\n        }\n      } else {\n        if (fix) {\n          out.write(ch);\n        }\n        lastWasWhitespace = false;\n      }\n    }\n    if (lastWasWhitespace && !allowTrailingSpaces) {\n      fail(file, \"contains trailing white space at the very end\", line);\n      return;\n    }\n    if (fix) {\n      byte[] changed = out.toByteArray();\n      if (Utils.compareNotNull(data, changed) != 0) {\n        RandomAccessFile f = new RandomAccessFile(file, \"rw\");\n        f.write(changed);\n        f.setLength(changed.length);\n        f.close();\n        System.out.println(\"CHANGED: \" + file.getName());\n      }\n    }\n    line = 1;\n    for (int i = 0; i < data.length; i++) {\n      if (data[i] < 32) {\n        line++;\n        for (int j = i + 1; j < data.length; j++) {\n          if (data[j] != 32) {\n            int mod = (j - i - 1) & 3;\n            if (mod != 0 && (mod != 1 || data[j] != '*')) {\n              fail(file, \"contains wrong number of heading spaces: \" + (j - i - 1), line);\n            }\n            break;\n          }\n        }\n      }\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6831, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 540, "focalAPIEnd": 564, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[])"], "useStart": [758], "useEnd": [776], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kiniry-teaching/UCD/tree/master/COMP30050-2008/groups/Music Comparison Software/MusicComparison/src/org/jaudiotagger/tag/lyrics3/FieldFrameBodyLYR.java", "rawCode": "  /**\n   * @param file\n   * @throws java.io.IOException\n   */\n  public void write(RandomAccessFile file) throws java.io.IOException {\n    int size = 0;\n    int offset = 0;\n    byte[] buffer = new byte[5];\n    String str = \"\";\n\n    size = getSize();\n    str = Integer.toString(size);\n\n    for (int i = 0; i < (5 - str.length()); i++) {\n      buffer[i] = (byte) '0';\n    }\n\n    offset += (5 - str.length());\n\n    for (int i = 0; i < str.length(); i++) {\n      buffer[i + offset] = (byte) str.charAt(i);\n    }\n\n    offset += str.length();\n    file.write(buffer, 0, 5);\n\n    if (size > 0) {\n      str = writeString();\n      buffer = new byte[str.length()];\n\n      for (int i = 0; i < str.length(); i++) {\n        buffer[i] = (byte) str.charAt(i);\n      }\n\n      file.write(buffer);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6832, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [171], "configurationEnd": [183], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 791, "focalAPIEnd": 811, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()", "randomAccessFile.close()"], "useStart": [825, 1070], "useEnd": [837, 1082], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/davidmerrick/Classes/tree/master/ECE 152/Final Project/finalproj/javazoom/jl/converter/RiffFile.java", "rawCode": "  /** Close Riff File. Length is written too. */\n  public int Close() {\n    int retcode = DDC_SUCCESS;\n\n    switch (fmode) {\n      case RFM_WRITE:\n        try {\n          file.seek(0);\n          try {\n            byte[] br = new byte[8];\n            br[0] = (byte) ((riff_header.ckID >>> 24) & 0x000000FF);\n            br[1] = (byte) ((riff_header.ckID >>> 16) & 0x000000FF);\n            br[2] = (byte) ((riff_header.ckID >>> 8) & 0x000000FF);\n            br[3] = (byte) (riff_header.ckID & 0x000000FF);\n\n            br[7] = (byte) ((riff_header.ckSize >>> 24) & 0x000000FF);\n            br[6] = (byte) ((riff_header.ckSize >>> 16) & 0x000000FF);\n            br[5] = (byte) ((riff_header.ckSize >>> 8) & 0x000000FF);\n            br[4] = (byte) (riff_header.ckSize & 0x000000FF);\n            file.write(br, 0, 8);\n            file.close();\n          } catch (IOException ioe) {\n            retcode = DDC_FILE_ERROR;\n          }\n        } catch (IOException ioe) {\n          retcode = DDC_FILE_ERROR;\n        }\n        break;\n\n      case RFM_READ:\n        try {\n          file.close();\n        } catch (IOException ioe) {\n          retcode = DDC_FILE_ERROR;\n        }\n        break;\n    }\n    file = null;\n    fmode = RFM_UNKNOWN;\n    return retcode;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6833, "initialization": ["RandomAccessFile randomAccessFile = getTmpBucket()", "int len = InputStream.read(byte[],int,int)"], "initializationStart": [214, 635], "initializationEnd": [228, 664], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "len>off && len>=off&&size>off", "guardType": "LOOP {", "guardExpressionStart": 586, "guardExpressionEnd": 615, "guardBlockStart": 586, "guardBlockEnd": 787, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 728, "focalAPIEnd": 764, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.getChannel()", "randomAccessFile.length()", "randomAccessFile.seek(int)", "randomAccessFile.getFD()", "safeClose(randomAccessFile)"], "useStart": [868, 970, 1006, 1147, 3254], "useEnd": [914, 995, 1030, 1171, 3281], "hasFinally": 1, "cleanUpCall": ["safeClose(RandomAccessFile)", "safeClose(BufferedReader)"], "finallyExpressionStart": 3236, "finallyExpressionEnd": 3244, "finallyBlockStart": 3236, "finallyBlockEnd": 3313, "cleanUpCallStart": [3254, 3291], "cleanUpCallEnd": [3281, 3304], "url": "https://github.com/trishika/DroidUPnP/tree/master/src/main/java/fi/iki/elonen/NanoHTTPD.java", "rawCode": "    private void parseBody(Map<String, String> files) throws IOException, ResponseException {\n      RandomAccessFile randomAccessFile = null;\n      BufferedReader in = null;\n      try {\n\n        randomAccessFile = getTmpBucket();\n\n        long size;\n        if (headers.containsKey(\"content-length\")) {\n          size = Integer.parseInt(headers.get(\"content-length\"));\n        } else if (splitbyte < rlen) {\n          size = rlen - splitbyte;\n        } else {\n          size = 0;\n        }\n\n        // Now read all the body and write it to f\n        byte[] buf = new byte[512];\n        while (rlen >= 0 && size > 0) {\n          rlen = inputStream.read(buf, 0, 512);\n          size -= rlen;\n          if (rlen > 0) {\n            randomAccessFile.write(buf, 0, rlen);\n          }\n        }\n\n        // Get the raw body as a byte []\n        ByteBuffer fbuf =\n            randomAccessFile\n                .getChannel()\n                .map(FileChannel.MapMode.READ_ONLY, 0, randomAccessFile.length());\n        randomAccessFile.seek(0);\n\n        // Create a BufferedReader for easily reading it as string.\n        InputStream bin = new FileInputStream(randomAccessFile.getFD());\n        in = new BufferedReader(new InputStreamReader(bin));\n\n        // If the method is POST, there may be parameters\n        // in data section, too, read it:\n        if (Method.POST.equals(method)) {\n          String contentType = \"\";\n          String contentTypeHeader = headers.get(\"content-type\");\n\n          StringTokenizer st = null;\n          if (contentTypeHeader != null) {\n            st = new StringTokenizer(contentTypeHeader, \",; \");\n            if (st.hasMoreTokens()) {\n              contentType = st.nextToken();\n            }\n          }\n\n          if (\"multipart/form-data\".equalsIgnoreCase(contentType)) {\n            // Handle multipart/form-data\n            if (!st.hasMoreTokens()) {\n              throw new ResponseException(\n                  Response.Status.BAD_REQUEST,\n                  \"BAD REQUEST: Content type is multipart/form-data but boundary missing. Usage: GET /example/file.html\");\n            }\n\n            String boundaryStartString = \"boundary=\";\n            int boundaryContentStart =\n                contentTypeHeader.indexOf(boundaryStartString) + boundaryStartString.length();\n            String boundary =\n                contentTypeHeader.substring(boundaryContentStart, contentTypeHeader.length());\n            if (boundary.startsWith(\"\\\"\") && boundary.startsWith(\"\\\"\")) {\n              boundary = boundary.substring(1, boundary.length() - 1);\n            }\n\n            decodeMultipartData(boundary, fbuf, in, parms, files);\n          } else {\n            // Handle application/x-www-form-urlencoded\n            String postLine = \"\";\n            char pbuf[] = new char[512];\n            int read = in.read(pbuf);\n            while (read >= 0 && !postLine.endsWith(\"\\r\\n\")) {\n              postLine += String.valueOf(pbuf, 0, read);\n              read = in.read(pbuf);\n            }\n            postLine = postLine.trim();\n            decodeParms(postLine, parms);\n          }\n        } else if (Method.PUT.equals(method)) {\n          files.put(\"content\", saveTmpFile(fbuf, 0, fbuf.limit()));\n        }\n      } finally {\n        safeClose(randomAccessFile);\n        safeClose(in);\n      }\n    }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6834, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.getChannel()", "randomAccessFile.seek(int)"], "configurationStart": [486, 677], "configurationEnd": [503, 690], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 698, "focalAPIEnd": 716, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ConatyConsulting/jaudiotagger/tree/master/src/org/jaudiotagger/tag/id3/AbstractID3v2Tag.java", "rawCode": "  /**\n   * Delete Tag\n   *\n   * @param file to delete the tag from\n   * @throws IOException if problem accessing the file\n   *     <p>\n   */\n  // TODO should clear all data and preferably recover lost space and go upto end of mp3s\n  public void delete(RandomAccessFile file) throws IOException {\n    // this works by just erasing the \"ID3\" tag at the beginning\n    // of the file\n    byte[] buffer = new byte[FIELD_TAGID_LENGTH];\n    // Read into Byte Buffer\n    final FileChannel fc = file.getChannel();\n    fc.position();\n    ByteBuffer byteBuffer = ByteBuffer.allocate(TAG_HEADER_LENGTH);\n    fc.read(byteBuffer, 0);\n    byteBuffer.flip();\n    if (seek(byteBuffer)) {\n      file.seek(0L);\n      file.write(buffer);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6835, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 642, "focalAPIEnd": 664, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fiji/imagej1/tree/master/ij/plugin/filter/AVI_Writer.java", "rawCode": "  /**\n   * Write the color table entries (for 8 bit grayscale or indexed color). Byte order or LUT\n   * entries: blue byte, green byte, red byte, 0 byte\n   */\n  private void writeLUT(ImageProcessor ip) throws IOException {\n    IndexColorModel cm = (IndexColorModel) (ip.getCurrentColorModel());\n    int mapSize = cm.getMapSize();\n    byte[] lutWrite = new byte[4 * 256];\n    for (int i = 0; i < 256; i++) {\n      if (i < mapSize) {\n        lutWrite[4 * i] = (byte) cm.getBlue(i);\n        lutWrite[4 * i + 1] = (byte) cm.getGreen(i);\n        lutWrite[4 * i + 2] = (byte) cm.getRed(i);\n        lutWrite[4 * i + 3] = (byte) 0;\n      }\n    }\n    raFile.write(lutWrite);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6836, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 319, "focalAPIEnd": 347, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fcrohas/QIcomPCR/tree/master/3rdparty/SpeexAudio/src/org/xiph/speex/PcmWaveWriter.java", "rawCode": "  /**\n   * Writes a packet of audio.\n   *\n   * @param data audio data\n   * @param offset the offset from which to start reading the data.\n   * @param len the length of data to read.\n   * @exception IOException\n   */\n  public void writePacket(final byte[] data, final int offset, final int len) throws IOException {\n    raf.write(data, offset, len);\n    size += len;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6837, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": [], "tryExpressionStart": 304, "tryExpressionEnd": 308, "tryBlockStart": 304, "tryBlockEnd": 385, "catchExpressionStart": 350, "catchExpressionEnd": 374, "catchBlockStart": 350, "catchBlockEnd": 385, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "randomAccessFile!=null", "guardType": "IF {", "guardExpressionStart": 274, "guardExpressionEnd": 293, "guardBlockStart": 274, "guardBlockEnd": 393, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 320, "focalAPIEnd": 338, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/russellb/androvoip/tree/master/src/com/mexuar/corraleta/audio/javasound/Audio8kEcho.java", "rawCode": "  public long readWithTime(byte[] buff) throws IOException {\n    long ret = super.readWithTime(buff);\n    boolean doStereoRec = AudioProperties.isStereoRec();\n    int micnext = (_micCount - 1) % _rbuffs.length;\n    ABuffer ab = _rbuffs[micnext];\n\n    if (_canWrite) {\n      if (micRaf != null) {\n        try {\n          micRaf.write(buff);\n        } catch (IOException ioe) {\n        }\n      }\n      if (_rawMic != null) {\n        try {\n          _rawMic.write(ab.getBuff());\n        } catch (IOException ioe) {\n        }\n      }\n\n      if (_aec != null) {\n        // We should do AEC here\n        // Problem is finding WHICH play buffer to use :(\n        byte sbuff[];\n        int sb = 0;\n        if (doStereoRec) {\n          sbuff = new byte[320];\n          copyRight(ab.getBuff(), sbuff);\n        } else {\n          // Use _micSpeakOffset for now.\n          sb = _micCount + _micSpeakOffset;\n          ABuffer sab = _pbuffs[sb % _pbuffs.length];\n          sbuff = sab.getBuff();\n        }\n        long start = System.currentTimeMillis();\n        byte[] ebuff = _aec.process(buff, sbuff);\n        System.arraycopy(ebuff, 0, buff, 0, ebuff.length);\n        long tdiff = (System.currentTimeMillis() - start);\n        if (tdiff > 10) {\n          Log.warn(\"AEC took \" + tdiff);\n        }\n        if (!doStereoRec && (tdiff > 20) && (Log.getLevel() > 5)) {\n          _aec.writeSample(buff, sbuff, sb);\n        }\n\n        if (aecRaf != null) {\n          try {\n            aecRaf.write(buff);\n          } catch (IOException ioe) {\n          }\n        }\n      }\n    }\n    return ret;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6838, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [93], "configurationEnd": [134], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 140, "focalAPIEnd": 171, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anhquang/contiki/tree/master/tools/coffee-manager/se/sics/coffee/CoffeeImageFile.java", "rawCode": "  @Override\n  public void write(byte[] bytes, int size, int offset) throws IOException {\n    imageFile.seek(conf.startOffset + offset);\n    imageFile.write(bytes, 0, size);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6839, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [338], "initializationEnd": [374], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 381, "focalAPIEnd": 397, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.getFD()", "randomAccessFile.close()"], "useStart": [404, 429], "useEnd": [416, 441], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop/hadoop-1.1.2/src/test/org/apache/hadoop/fs/TestDU.java", "rawCode": "  private void createFile(File newFile, int size) throws IOException {\n    // write random data so that filesystems with compression enabled (e.g., ZFS)\n    // can't compress the file\n    Random random = new Random();\n    byte[] data = new byte[size];\n    random.nextBytes(data);\n\n    newFile.createNewFile();\n    RandomAccessFile file = new RandomAccessFile(newFile, \"rws\");\n\n    file.write(data);\n\n    file.getFD().sync();\n    file.close();\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6840, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 52, "focalAPIEnd": 64, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/penSecIT/commons-vfs/tree/master/branches/VFS281/core/src/main/java/org/apache/commons/vfs/provider/local/LocalFileRandomAccessContent.java", "rawCode": "  public void write(int b) throws IOException {\n    raf.write(b);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6841, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 251, "focalAPIEnd": 263, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dxd/2apl--old-/tree/master/2apl/release/lib/com/sun/jini/reliableLog/LogOutputStream.java", "rawCode": "  /**\n   * Writes a byte of data. This method will block until the byte is actually written.\n   *\n   * @param b the byte to be written\n   * @exception IOException If an I/O error has occurred.\n   */\n  public void write(int b) throws IOException {\n    raf.write(b);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6842, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)", "randomAccessFile.readInt()", "randomAccessFile.length()", "randomAccessFile.length()", "randomAccessFile.seek(int)", "randomAccessFile.writeInt(int)", "randomAccessFile.seek(long)"], "configurationStart": [247, 287, 912, 1037, 1094, 1147, 1202], "configurationEnd": [268, 302, 926, 1051, 1115, 1174, 1226], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 1272, "focalAPIEnd": 1301, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/compbio-UofT/savant/tree/master/savant.core/src/main/java/savant/util/CachedSeekableStream.java", "rawCode": "  @Override\n  public synchronized void seek(long pos) throws IOException {\n\n    positionInFile = pos;\n\n    // determine which block needs to be accessed\n    int block = (int) (pos / bufferSize);\n\n    // Check offset for block\n    openCache();\n    cache.seek(block * 4);\n    int offset = cache.readInt();\n\n    if (offset != 0) {\n      // block is cached\n      int positionOffset = (int) (pos % bufferSize);\n      cachedSeek(offset, positionOffset);\n      closeCache();\n    } else {\n      // Not cached, seek to start of block\n      positionInFile = pos - (pos % bufferSize);\n      wrappedStream.seek(positionInFile);\n      bufferedStream.close();\n      bufferedStream = new BufferedInputStream(wrappedStream, bufferSize);\n\n      // Cache block\n      byte[] b = new byte[bufferSize];\n      int numRead = bufferedStream.read(b, 0, bufferSize); // read buffer into byte[] b\n      int storeOffset =\n          (int) ((cache.length() - (numBlocks * 4)) / this.bufferSize)\n              + 1; // offset to data in cache\n      long actualOffset = cache.length(); // actual pointer to data in cache\n      cache.seek(block * 4); // seek to write offset\n      cache.writeInt(storeOffset); // write the offset\n      cache.seek(actualOffset); // seek to where data will be written\n      cache.write(b, 0, bufferSize); // write data\n\n      // skip to position % buffersize\n      positionInBuf = 0;\n      closeCache();\n\n      // TODO: is this necessary? extra work...\n      seek(pos);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6843, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [155], "initializationEnd": [186], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.setLength(int)"], "configurationStart": [270], "configurationEnd": [290], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 296, "focalAPIEnd": 316, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [343], "useEnd": [358], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.engine/tree/master/tests/org.eclipse.birt.core.tests/test/org/eclipse/birt/core/archive/ArchiveFileSaveTest.java", "rawCode": "  void copyFile(String src, String tgt) throws IOException {\n    RandomAccessFile srcFile = new RandomAccessFile(src, \"r\");\n    RandomAccessFile tgtFile = new RandomAccessFile(tgt, \"rw\");\n    byte[] bytes = new byte[(int) srcFile.length()];\n    srcFile.read(bytes);\n    tgtFile.setLength(0);\n    tgtFile.write(bytes);\n    srcFile.close();\n    tgtFile.close();\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6844, "initialization": ["byte[] b = ByteArray.getByteArray()", "RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [1084, 1275], "initializationEnd": [1101, 1311], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)", "exit(int)"], "tryExpressionStart": 1240, "tryExpressionEnd": 1244, "tryBlockStart": 1240, "tryBlockEnd": 1489, "catchExpressionStart": 1367, "catchExpressionEnd": 1389, "catchBlockStart": 1367, "catchBlockEnd": 1489, "exceptionHandlingCallStart": [1397, 1468], "exceptionHandlingCallEnd": [1460, 1482], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 1319, "focalAPIEnd": 1340, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [1348], "useEnd": [1359], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dgarnier/MDSplus/tree/master/javatraverser/LoadFile.java", "rawCode": "  public static void main(String args[]) {\n    if (args.length < 3 || args.length > 5) {\n      System.err.println(\"Usage: java StoreFile <filename> <nodename> <experiment> [< shot> \");\n      System.exit(0);\n    }\n    String fileName = args[0];\n    String nodeName = args[1];\n    String experiment = args[2];\n\n    int shot = -1;\n    if (args.length == 4) {\n      try {\n        shot = Integer.parseInt(args[3]);\n      } catch (Exception exc) {\n        System.err.println(\"Invalid shot number\");\n        System.exit(0);\n      }\n    }\n    Database tree = new Database(experiment, shot);\n    try {\n      tree.open();\n    } catch (Exception exc) {\n      System.err.println(\"Cannot open experiment \" + experiment + \" shot \" + shot + \": \" + exc);\n      System.exit(0);\n    }\n    NidData nid = null;\n    try {\n      nid = tree.resolve(new PathData(nodeName), 0);\n    } catch (Exception exc) {\n      System.err.println(\"Cannot find node \" + nodeName);\n      System.exit(0);\n    }\n    byte[] serialized = null;\n    try {\n      ByteArray ba = (ByteArray) tree.getData(nid, 0);\n      serialized = ba.getByteArray();\n    } catch (Exception exc) {\n      System.err.println(\"Error reading data in\" + nodeName + \": \" + exc);\n      System.exit(0);\n    }\n    try {\n      RandomAccessFile raf = new RandomAccessFile(fileName, \"rw\");\n      raf.write(serialized);\n      raf.close();\n    } catch (Exception exc) {\n      System.err.println(\"Cannot read file \" + fileName + \": \" + exc);\n      System.exit(0);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6845, "initialization": ["int len = min(long,int)"], "initializationStart": [775], "initializationEnd": [803], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.setLength(long)", "randomAccessFile.getFilePointer()", "randomAccessFile.seek(long)"], "configurationStart": [294, 478, 507], "configurationEnd": [319, 499, 524], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 813, "focalAPIEnd": 841, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.seek(long)"], "useStart": [885], "useEnd": [899], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/angusmacdonald/h2o/tree/master/src/main/org/h2/util/FileUtils.java", "rawCode": "  /**\n   * Change the length of the file.\n   *\n   * @param file the random access file\n   * @param newLength the new length\n   */\n  public static void setLength(final RandomAccessFile file, final long newLength)\n      throws IOException {\n\n    try {\n      trace(\"setLength\", null, file);\n      file.setLength(newLength);\n    } catch (final IOException e) {\n      final long length = file.length();\n      if (newLength < length) {\n        throw e;\n      }\n      final long pos = file.getFilePointer();\n      file.seek(length);\n      long remaining = newLength - length;\n      final int maxSize = 1024 * 1024;\n      final int block = (int) Math.min(remaining, maxSize);\n      final byte[] buffer = new byte[block];\n      while (remaining > 0) {\n        final int write = (int) Math.min(remaining, maxSize);\n        file.write(buffer, 0, write);\n        remaining -= write;\n      }\n      file.seek(pos);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6846, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 121, "focalAPIEnd": 145, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eclipse/jgit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/ObjectDirectoryPackParser.java", "rawCode": "  /** {@inheritDoc} */\n  @Override\n  protected void onStoreStream(byte[] raw, int pos, int len) throws IOException {\n    out.write(raw, pos, len);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6847, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [201], "configurationEnd": [230], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 238, "focalAPIEnd": 253, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])"], "useStart": [261, 298, 321, 358, 381, 418, 531, 568, 591, 628, 651, 688, 711, 748, 861, 898, 921, 958, 981, 1018, 1041, 1078, 1101, 1138, 1161, 1198, 1221, 1258, 1281, 1318], "useEnd": [290, 313, 350, 373, 410, 433, 560, 583, 620, 643, 680, 703, 740, 763, 890, 913, 950, 973, 1010, 1033, 1070, 1093, 1130, 1153, 1190, 1213, 1250, 1273, 1310, 1333], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/openGDA/gda-core/tree/master/uk.ac.gda.core/src/gda/device/detector/odccd/ModifyCrysalisHeader.java", "rawCode": "  public void editDoubleHeader(String field, double newVal) throws IOException {\n\n    int specialOffset = 768;\n\n    if (field.equals(\"imon1\")) {\n      byte[] b = intToByteArray((int) newVal, 4);\n      raf.seek(specialOffset + 528);\n      raf.write(b[3]);\n      raf.seek(specialOffset + 529);\n      raf.write(b[2]);\n      raf.seek(specialOffset + 530);\n      raf.write(b[1]);\n      raf.seek(specialOffset + 531);\n      raf.write(b[0]);\n    }\n\n    if (field.equals(\"imon2\")) {\n      byte[] b = intToByteArray((int) newVal, 4);\n      raf.seek(specialOffset + 532);\n      raf.write(b[3]);\n      raf.seek(specialOffset + 533);\n      raf.write(b[2]);\n      raf.seek(specialOffset + 534);\n      raf.write(b[1]);\n      raf.seek(specialOffset + 535);\n      raf.write(b[0]);\n    }\n\n    if (field.equals(\"dexposuretimeinsec\")) {\n      int[] b = doubleToHex(newVal);\n      raf.seek(specialOffset + 487);\n      raf.write(b[0]);\n      raf.seek(specialOffset + 486);\n      raf.write(b[1]);\n      raf.seek(specialOffset + 485);\n      raf.write(b[2]);\n      raf.seek(specialOffset + 484);\n      raf.write(b[3]);\n      raf.seek(specialOffset + 483);\n      raf.write(b[4]);\n      raf.seek(specialOffset + 482);\n      raf.write(b[5]);\n      raf.seek(specialOffset + 581);\n      raf.write(b[6]);\n      raf.seek(specialOffset + 580);\n      raf.write(b[7]);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6848, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [1223], "configurationEnd": [1245], "guardCondition": "(len)!=-1", "guardType": "LOOP {", "guardExpressionStart": 1134, "guardExpressionEnd": 1192, "guardBlockStart": 1134, "guardBlockEnd": 1435, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 1359, "focalAPIEnd": 1391, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [1468], "useEnd": [1486], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sunqimin09/FirstApp/tree/master/NewJingBaoAndroidApp/src/cn/com/bjnews/thinker/img/FileHelper.java", "rawCode": "  public static boolean unZipFile(String fileName, String unZipDir) throws Exception {\n    File f = new File(unZipDir);\n\n    if (!f.exists()) {\n      f.mkdirs();\n    }\n\n    BufferedInputStream is = null;\n    ZipEntry entry;\n    ZipFile zipfile = new ZipFile(fileName);\n    Enumeration<?> enumeration = zipfile.entries();\n    byte data[] = new byte[FILE_BUFFER_SIZE];\n    log.i(\"unZipDir: \" + unZipDir);\n\n    while (enumeration.hasMoreElements()) {\n      entry = (ZipEntry) enumeration.nextElement();\n\n      if (entry.isDirectory()) {\n        File f1 = new File(unZipDir + \"/\" + entry.getName());\n        log.i(\"entry.isDirectory XXX \" + f1.getPath());\n        if (!f1.exists()) {\n          f1.mkdirs();\n        }\n      } else {\n        is = new BufferedInputStream(zipfile.getInputStream(entry));\n        int count;\n        String name = unZipDir + \"/\" + entry.getName();\n        RandomAccessFile m_randFile = null;\n        File file = new File(name);\n        if (file.exists()) {\n          file.delete();\n        }\n\n        file.createNewFile();\n        m_randFile = new RandomAccessFile(file, \"rw\");\n        int begin = 0;\n\n        while ((count = is.read(data, 0, FILE_BUFFER_SIZE)) != -1) {\n          try {\n            m_randFile.seek(begin);\n          } catch (Exception ex) {\n            log.e(\"exception, ex: \" + ex.toString());\n          }\n\n          m_randFile.write(data, 0, count);\n          begin = begin + count;\n        }\n\n        file.delete();\n        m_randFile.close();\n        is.close();\n      }\n    }\n\n    return true;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6849, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 131, "focalAPIEnd": 163, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stephenc/java-iso-tools/tree/master/sabre/src/main/java/com/github/stephenc/javaisotools/udflib/structures/ReservedArea.java", "rawCode": "  public static void write(RandomAccessFile myRandomAccessFile) throws IOException {\n    byte buffer[] = new byte[16 * 2048];\n\n    myRandomAccessFile.write(buffer);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6850, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 421, "focalAPIEnd": 450, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[],int,int)"], "useStart": [665], "useEnd": [694], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sonatype/JGit/tree/master/org.spearce.jgit/src/org/spearce/jgit/transport/IndexPack.java", "rawCode": "  private void writeWhole(final Deflater def, final int typeCode, final byte[] data)\n      throws IOException {\n    int sz = data.length;\n    int hdrlen = 0;\n    buf[hdrlen++] = (byte) ((typeCode << 4) | sz & 15);\n    sz >>>= 4;\n    while (sz > 0) {\n      buf[hdrlen - 1] |= 0x80;\n      buf[hdrlen++] = (byte) (sz & 0x7f);\n      sz >>>= 7;\n    }\n    packDigest.update(buf, 0, hdrlen);\n    crc.update(buf, 0, hdrlen);\n    packOut.write(buf, 0, hdrlen);\n    def.reset();\n    def.setInput(data);\n    def.finish();\n    while (!def.finished()) {\n      final int datlen = def.deflate(buf);\n      packDigest.update(buf, 0, datlen);\n      crc.update(buf, 0, datlen);\n      packOut.write(buf, 0, datlen);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6851, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 922, "focalAPIEnd": 947, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/haizi-zh/Bioscope/tree/master/ImageJ_src/src/ij/plugin/filter/AVI_Writer.java", "rawCode": "  /**\n   * Write RGB data. Each 3-byte triplet in the bitmap array represents blue, green, and red,\n   * respectively, for a pixel. The color bytes are in reverse order (Windows convention). Lines are\n   * padded to a length that is a multiple of 4 bytes.\n   */\n  private void writeRGBFrame(ImageProcessor ip) throws IOException {\n    ip = ip.convertToRGB();\n    int[] pixels = (int[]) ip.getPixels();\n    int width = ip.getWidth();\n    int height = ip.getHeight();\n    int c, offset, index = 0;\n    for (int y = height - 1; y >= 0; y--) {\n      offset = y * width;\n      for (int x = 0; x < width; x++) {\n        c = pixels[offset++];\n        bufferWrite[index++] = (byte) (c & 0xff); // blue\n        bufferWrite[index++] = (byte) ((c & 0xff00) >> 8); // green\n        bufferWrite[index++] = (byte) ((c & 0xff0000) >> 16); // red\n      }\n      for (int i = 0; i < linePad; i++) bufferWrite[index++] = (byte) 0;\n    }\n    raFile.write(bufferWrite);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6852, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [96], "initializationEnd": [128], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new RuntimeException(String,*)"], "tryExpressionStart": 62, "tryExpressionEnd": 66, "tryBlockStart": 62, "tryBlockEnd": 308, "catchExpressionStart": 209, "catchExpressionEnd": 231, "catchBlockStart": 209, "catchBlockEnd": 308, "exceptionHandlingCallStart": [245], "exceptionHandlingCallEnd": [301], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 136, "focalAPIEnd": 150, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.setLength(int)", "randomAccessFile.close()"], "useStart": [158, 191], "useEnd": [183, 201], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chris-martin/h2/tree/master/h2/src/tools/org/h2/dev/util/Migrate.java", "rawCode": "  private static void writeFile(File file, byte[] data) {\n    try {\n      RandomAccessFile ra = new RandomAccessFile(file, \"rw\");\n      ra.write(data);\n      ra.setLength(data.length);\n      ra.close();\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error writing to file \" + file, e);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6853, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 245, "focalAPIEnd": 265, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.setLength(int)"], "useStart": [271], "useEnd": [302], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mirror/jpcsp/tree/master/src/jpcsp/format/PSF.java", "rawCode": "  public void write(RandomAccessFile output) throws IOException {\n    byte[] buffer = new byte[size()];\n    ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);\n    write(byteBuffer);\n\n    // Write the file and truncate it to the correct length\n    output.write(buffer);\n    output.setLength(buffer.length);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6854, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)", "byte[] b = String.getBytes()"], "initializationStart": [700, 808], "initializationEnd": [741, 825], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 676, "tryExpressionEnd": 680, "tryBlockStart": 676, "tryBlockEnd": 1160, "catchExpressionStart": 955, "catchExpressionEnd": 987, "catchBlockStart": 955, "catchBlockEnd": 1062, "exceptionHandlingCallStart": [1036], "exceptionHandlingCallEnd": [1055], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [833], "configurationEnd": [850], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 859, "focalAPIEnd": 878, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.setLength(int)", "randomAccessFile.close()"], "useStart": [886, 930], "useEnd": [922, 947], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/charleso/naca/tree/master/JLib/src/jlib/persitantQueue/PersistantQueue.java", "rawCode": "  private synchronized void buildIndexes() {\n    int nMin = 0x7fffffff;\n    int nMax = 0x80000000;\n\n    FileSystem.createPath(m_csDir);\n    String tcsNames[] = FileSystem.getFileNameListBySuffix(m_csDir, \".q\");\n    if (tcsNames == null) nMin = nMax = 0;\n    else if (tcsNames.length == 0) nMin = nMax = 0;\n    else {\n      for (int n = 0; n < tcsNames.length; n++) {\n        String csFullName = tcsNames[n];\n        String csName = FileSystem.getNameWithoutExtension(csFullName);\n        int nName = NumberParser.getAsInt(csName);\n        if (nName < nMin) nMin = nName;\n        if (nName > nMax) nMax = nName;\n      }\n      nMax++;\n    }\n\n    RandomAccessFile fileIndex;\n    try {\n      fileIndex = new RandomAccessFile(m_csIndexFile, \"rw\");\n      String csLine = \"\" + nMin + \":\" + nMax;\n\n      byte tb[] = csLine.getBytes();\n      fileIndex.seek(0);\n\n      fileIndex.write(tb);\n      fileIndex.setLength(csLine.length());\n      fileIndex.close();\n    } catch (FileNotFoundException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    } catch (IOException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6855, "initialization": ["RandomAccessFile randomAccessFile = getChunkFile(*)"], "initializationStart": [393], "initializationEnd": [419], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["e(String,String)"], "tryExpressionStart": 350, "tryExpressionEnd": 354, "tryBlockStart": 350, "tryBlockEnd": 1192, "catchExpressionStart": 1109, "catchExpressionEnd": 1129, "catchBlockStart": 1109, "catchBlockEnd": 1192, "exceptionHandlingCallStart": [1139], "exceptionHandlingCallEnd": [1183], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [464], "configurationEnd": [493], "guardCondition": "!(b.length<=record.sizeOnDisk) && randomAccessFile!=null", "guardType": "IF {", "guardExpressionStart": 211, "guardExpressionEnd": 266, "guardBlockStart": 211, "guardBlockEnd": 1198, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 505, "focalAPIEnd": 526, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.length()", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[])"], "useStart": [1415, 1443, 1475], "useEnd": [1433, 1465, 1496], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/MIPS/packages-apps-Gallery3D/tree/master/src/com/cooliris/media/DiskCache.java", "rawCode": "  public void put(long key, byte[] data, long timestamp) {\n    // Check to see if the record already exists.\n    Record record = null;\n    synchronized (mIndexMap) {\n      record = mIndexMap.get(key);\n    }\n    if (record != null && data.length <= record.sizeOnDisk) {\n      // We just replace the chunk.\n      int currentChunk = record.chunk;\n      try {\n        RandomAccessFile chunkFile = getChunkFile(record.chunk);\n        if (chunkFile != null) {\n          chunkFile.seek(record.offset);\n          chunkFile.write(data);\n          synchronized (mIndexMap) {\n            mIndexMap.put(\n                key,\n                new Record(currentChunk, record.offset, data.length, record.sizeOnDisk, timestamp));\n          }\n          if (++mNumInsertions == 32) { // CR: 32 => constant\n            // Flush the index file at a regular interval. To avoid\n            // writing the entire\n            // index each time the format could be changed to an\n            // append-only journal with\n            // a snapshot generated on exit.\n            flush();\n          }\n          return;\n        }\n      } catch (Exception e) {\n        Log.e(TAG, \"Unable to read from chunk file\");\n      }\n    }\n    // Append a new chunk to the current chunk.\n    final int chunk = mTailChunk;\n    final RandomAccessFile chunkFile = getChunkFile(chunk);\n    if (chunkFile != null) {\n      try {\n        final int offset = (int) chunkFile.length();\n        chunkFile.seek(offset);\n        chunkFile.write(data);\n        synchronized (mIndexMap) {\n          mIndexMap.put(key, new Record(chunk, offset, data.length, data.length, timestamp));\n        }\n        if (offset + data.length > CHUNK_SIZE) {\n          ++mTailChunk;\n        }\n\n        if (++mNumInsertions == 32) { // CR: 32 => constant\n          // Flush the index file at a regular interval. To avoid\n          // writing the entire\n          // index each time the format could be changed to an\n          // append-only journal with\n          // a snapshot generated on exit.\n          flush();\n        }\n      } catch (IOException e) {\n        Log.e(TAG, \"Unable to write new entry to chunk file\");\n      }\n    } else {\n      Log.e(TAG, \"getChunkFile() returned null\");\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6856, "initialization": ["byte[] b = takeThreadLocalBuf()"], "initializationStart": [378], "initializationEnd": [403], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.writeInt(int)"], "configurationStart": [517], "configurationEnd": [534], "guardCondition": "(len)!=-1", "guardType": "LOOP {", "guardExpressionStart": 619, "guardExpressionEnd": 659, "guardBlockStart": 619, "guardBlockEnd": 737, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 670, "focalAPIEnd": 699, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.seek(long)", "randomAccessFile.writeInt(int)"], "useStart": [790, 817], "useEnd": [809, 838], "hasFinally": 1, "cleanUpCall": ["releaseThreadLocalBuf(byte[])"], "finallyExpressionStart": 963, "finallyExpressionEnd": 971, "finallyBlockStart": 963, "finallyBlockEnd": 1017, "cleanUpCallStart": [979], "cleanUpCallEnd": [1010], "url": "https://github.com/prsebastian/gwt-issue8215/tree/master/dev/core/src/com/google/gwt/dev/util/DiskCache.java", "rawCode": "  /**\n   * Write the rest of the data in an input stream to disk. Note: this method does not close the\n   * InputStream.\n   *\n   * @param in open stream containing the data to write to the disk cache.\n   * @return a token to retrieve the data later\n   */\n  public synchronized long transferFromStream(InputStream in) throws IOException {\n    assert in != null;\n    byte[] buf = Util.takeThreadLocalBuf();\n    try {\n      long position = moveToEndPosition();\n\n      // Placeholder, we don't know the length yet.\n      file.writeInt(-1);\n\n      // Transfer all the bytes.\n      int length = 0;\n      int bytesRead;\n      while ((bytesRead = in.read(buf)) != -1) {\n        file.write(buf, 0, bytesRead);\n        length += bytesRead;\n      }\n\n      // Now go back and fill in the length.\n      file.seek(position);\n      file.writeInt(length);\n      // Don't eagerly seek the end, the next operation might be a read.\n      atEnd = false;\n      return position;\n    } finally {\n      Util.releaseThreadLocalBuf(buf);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6857, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 642, "focalAPIEnd": 664, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ruytoor/M1S2/tree/master/TI/workspace/IJ/src/ij/plugin/filter/AVI_Writer.java", "rawCode": "  /**\n   * Write the color table entries (for 8 bit grayscale or indexed color). Byte order or LUT\n   * entries: blue byte, green byte, red byte, 0 byte\n   */\n  private void writeLUT(ImageProcessor ip) throws IOException {\n    IndexColorModel cm = (IndexColorModel) (ip.getCurrentColorModel());\n    int mapSize = cm.getMapSize();\n    byte[] lutWrite = new byte[4 * 256];\n    for (int i = 0; i < 256; i++) {\n      if (i < mapSize) {\n        lutWrite[4 * i] = (byte) cm.getBlue(i);\n        lutWrite[4 * i + 1] = (byte) cm.getGreen(i);\n        lutWrite[4 * i + 2] = (byte) cm.getRed(i);\n        lutWrite[4 * i + 3] = (byte) 0;\n      }\n    }\n    raFile.write(lutWrite);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6858, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)", "byte[] b = Cipher.doFinal(byte[])"], "initializationStart": [2248, 2483], "initializationEnd": [2288, 2505], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["decodeStream(InputStream)"], "tryExpressionStart": 530, "tryExpressionEnd": 534, "tryBlockStart": 530, "tryBlockEnd": 1669, "catchExpressionStart": 2807, "catchExpressionEnd": 2829, "catchBlockStart": 2807, "catchBlockEnd": 2944, "exceptionHandlingCallStart": [2903], "exceptionHandlingCallEnd": [2933], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(len)!=-1", "guardType": "LOOP {", "guardExpressionStart": 2298, "guardExpressionEnd": 2360, "guardBlockStart": 2298, "guardBlockEnd": 2577, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 2529, "focalAPIEnd": 2566, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()", "randomAccessFile.write(byte[],int,int)", "randomAccessFile.close()", "randomAccessFile.close()"], "useStart": [2586, 3119, 3214, 3273], "useEnd": [2602, 3156, 3230, 3289], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/KKBOX/android_kktoolkit/tree/master/src/com/kkbox/toolkit/image/KKImageRequest.java", "rawCode": "  @Override\n  public Bitmap doInBackground(Object... params) {\n    Bitmap bitmap;\n    try {\n      int readLength;\n      cachePath = KKImageManager.getTempImagePath(context, url);\n      File cacheFile = new File(cachePath);\n      File localFile = null;\n      String tempFilePath =\n          context.getCacheDir().getAbsolutePath()\n              + File.separator\n              + \"image\"\n              + File.separator\n              + hashCode();\n      if (localPath != null) {\n        localFile = new File(localPath);\n      }\n      try {\n        if (cacheFile.exists()) {\n          if (actionType == KKImageManager.ActionType.DOWNLOAD) {\n            if (localFile == null || !localFile.exists()) {\n              cryptToFile(cachePath, localPath);\n            }\n            return null;\n          } else {\n            bitmap = decodeBitmap(cachePath);\n            if (bitmap != null) {\n              if (localPath != null && saveToLocal && (localFile == null || !localFile.exists())) {\n                cryptToFile(cachePath, localPath);\n              }\n              return bitmap;\n            } else {\n              removeCacheFile();\n            }\n          }\n        }\n        if (localFile != null && localFile.exists()) {\n          if (actionType == KKImageManager.ActionType.DOWNLOAD) {\n            return null;\n          } else {\n            cryptToFile(localPath, tempFilePath);\n            moveFileTo(tempFilePath, cachePath);\n            bitmap = decodeBitmap(cachePath);\n            if (bitmap != null) {\n              return bitmap;\n            } else {\n              removeCacheFile();\n            }\n          }\n        }\n      } catch (Exception e) {\n      }\n      // Do fetch server resource if either cache nor local file is not valid to read\n      if (!KKImageManager.networkEnabled) {\n        return null;\n      }\n      response = httpClient.newCall(new Request.Builder().url(url).build()).execute();\n      if (!response.isSuccessful()) {\n        throw new Exception(\"Unexpected code \" + response);\n      }\n      final InputStream is = response.body().byteStream();\n      headers = response.headers();\n      removeInvalidImageFiles();\n      if (actionType == KKImageManager.ActionType.DOWNLOAD) {\n        RandomAccessFile tempFile = new RandomAccessFile(tempFilePath, \"rw\");\n        while ((readLength = is.read(buffer, 0, buffer.length)) != -1) {\n          if (interuptFlag) {\n            return null;\n          }\n          if (cipher != null) {\n            buffer = cipher.doFinal(buffer);\n          }\n          tempFile.write(buffer, 0, readLength);\n        }\n        tempFile.close();\n        moveFileTo(tempFilePath, localPath);\n        return null;\n      } else {\n        RandomAccessFile tempFile;\n        try {\n          tempFile = new RandomAccessFile(tempFilePath, \"rw\");\n        } catch (IOException e) {\n          // we don't save to SD card if cache is full\n          return BitmapFactory.decodeStream(is);\n        }\n        try {\n          while ((readLength = is.read(buffer, 0, buffer.length)) != -1) {\n            if (interuptFlag) {\n              return null;\n            }\n            tempFile.write(buffer, 0, readLength);\n          }\n        } catch (IOException e) {\n          tempFile.close();\n          return null;\n        }\n        tempFile.close();\n        moveFileTo(tempFilePath, cachePath);\n        bitmap = decodeBitmap(cachePath);\n        if (bitmap != null) {\n          if (saveToLocal && localPath != null) {\n            cryptToFile(cachePath, localPath);\n          }\n          return bitmap;\n        }\n      }\n    } catch (final Exception e) {\n      isNetworkError = true;\n      removeInvalidImageFiles();\n    }\n    return null;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6859, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 353, "focalAPIEnd": 374, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asascience-open/EDC/tree/master/AsaJavaLib/com/asascience/utilities/io/LERandomAccessFile.java", "rawCode": "  /**\n   * Write an signed short even though parameter is an int. Like java.io.RandomAcessFile#writeShort.\n   * also acts as a writeUnsignedShort.\n   *\n   * @param v signed number to write\n   * @throws IOException if read fails.\n   */\n  public final void writeShort(int v) throws IOException {\n    work[0] = (byte) v;\n    work[1] = (byte) (v >> 8);\n    raf.write(work, 0, 2);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6860, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["resetPointer()", "logWarningEvent(String,*)"], "tryExpressionStart": 77, "tryExpressionEnd": 81, "tryBlockStart": 77, "tryBlockEnd": 572, "catchExpressionStart": 431, "catchExpressionEnd": 453, "catchBlockStart": 431, "catchBlockEnd": 572, "exceptionHandlingCallStart": [461, 483], "exceptionHandlingCallEnd": [475, 549], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [89], "configurationEnd": [112], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 266, "focalAPIEnd": 292, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ferquies/2dam/tree/master/AD/Tema 2/hsqldb-2.3.1/hsqldb/src/org/hsqldb/persist/RAFile.java", "rawCode": "  public void write(byte[] b, int off, int length) throws IOException {\n\n    try {\n      file.seek(seekPosition);\n\n      if (seekPosition < bufferOffset + buffer.length && seekPosition + length > bufferOffset) {\n        writeToBuffer(b, off, length);\n      }\n\n      file.write(b, off, length);\n\n      seekPosition += length;\n\n      if (!extendLength && fileLength < seekPosition) {\n        fileLength = seekPosition;\n      }\n    } catch (IOException e) {\n      resetPointer();\n      database.logger.logWarningEvent(\"failed to write a byte array\", e);\n\n      throw e;\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6861, "initialization": ["byte[] b = MessageBlock.getData()"], "initializationStart": [133], "initializationEnd": [148], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.writeInt(int)"], "configurationStart": [435], "configurationEnd": [467], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 473, "focalAPIEnd": 495, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lietou/insight/tree/master/cat-core/src/main/java/com/dianping/cat/storage/dump/MessageBlockWriter.java", "rawCode": "  public synchronized void writeBlock(MessageBlock block) throws IOException {\n    int len = block.getBlockSize();\n    byte[] data = block.getData();\n    int blockSize = 0;\n\n    for (int i = 0; i < len; i++) {\n      int seq = block.getIndex(i);\n      int size = block.getSize(i);\n\n      m_indexFile.seek(seq * 6);\n      m_indexFile.writeInt(m_blockAddress);\n      m_indexFile.writeShort(blockSize);\n      blockSize += size;\n    }\n\n    m_dataFile.writeInt(data.length);\n    m_dataFile.write(data);\n    m_blockAddress += data.length + 4;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6862, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)", "byte[] b = String.getBytes(String)"], "initializationStart": [356, 1006], "initializationEnd": [393, 1031], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.writeLong(long)", "randomAccessFile.writeInt(int)", "randomAccessFile.writeInt(int)"], "configurationStart": [402, 684, 1092], "configurationEnd": [436, 725, 1121], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 1159, "focalAPIEnd": 1182, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.writeInt(int)", "randomAccessFile.writeLong(long)", "randomAccessFile.getFilePointer()", "randomAccessFile.seek(long)", "randomAccessFile.writeLong(long)", "randomAccessFile.seek(long)", "randomAccessFile.writeInt(int)", "randomAccessFile.write(byte[])", "randomAccessFile.writeByte(int)", "randomAccessFile.writeInt(int)", "randomAccessFile.writeInt(int)", "randomAccessFile.writeInt(int)", "randomAccessFile.writeLong(long)", "randomAccessFile.close()"], "useStart": [1343, 1568, 1750, 1846, 1878, 1916, 2277, 2348, 2454, 2603, 2731, 2868, 3015, 3214], "useEnd": [1374, 1585, 1770, 1868, 1905, 1932, 2307, 2372, 2501, 2628, 2754, 2901, 3052, 3225], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 3155, "finallyExpressionEnd": 3163, "finallyBlockStart": 3155, "finallyBlockEnd": 3306, "cleanUpCallStart": [3214], "cleanUpCallEnd": [3225], "url": "https://github.com/bocchino/DPJ-UR/tree/master/Implementation/Compiler/src/share/classes/com/sun/tools/javac/zip/ZipFileIndex.java", "rawCode": "  private boolean writeIndex() {\n    boolean ret = false;\n    if (readFromIndex || !usePreindexedCache) {\n      return true;\n    }\n\n    if (!writeIndex) {\n      return true;\n    }\n\n    File indexFile = getIndexFile();\n    if (indexFile == null) {\n      return false;\n    }\n\n    RandomAccessFile raf = null;\n    long writtenSoFar = 0;\n    try {\n      raf = new RandomAccessFile(indexFile, \"rw\");\n\n      raf.writeLong(zipFileLastModified);\n      writtenSoFar += 8;\n\n      Iterator<String> iterDirName = directories.keySet().iterator();\n      List<DirectoryEntry> directoriesToWrite = new ArrayList<DirectoryEntry>();\n      Map<String, Long> offsets = new HashMap<String, Long>();\n      raf.writeInt(directories.keySet().size());\n      writtenSoFar += 4;\n\n      while (iterDirName.hasNext()) {\n        String dirName = iterDirName.next();\n        DirectoryEntry dirEntry = directories.get(dirName);\n\n        directoriesToWrite.add(dirEntry);\n\n        // Write the dir name bytes\n        byte[] dirNameBytes = dirName.getBytes(\"UTF-8\");\n        int dirNameBytesLen = dirNameBytes.length;\n        raf.writeInt(dirNameBytesLen);\n        writtenSoFar += 4;\n\n        raf.write(dirNameBytes);\n        writtenSoFar += dirNameBytesLen;\n\n        // Write the number of files in the dir\n        List dirEntries = dirEntry.getEntriesAsCollection();\n        raf.writeInt(dirEntries.size());\n        writtenSoFar += 4;\n\n        offsets.put(dirName, new Long(writtenSoFar));\n\n        // Write the offset of the file's data in the dir\n        dirEntry.writtenOffsetOffset = 0L;\n        raf.writeLong(0L);\n        writtenSoFar += 8;\n      }\n\n      for (DirectoryEntry de : directoriesToWrite) {\n        // Fix up the offset in the directory table\n        long currFP = raf.getFilePointer();\n\n        long offsetOffset = offsets.get(de.dirName).longValue();\n        raf.seek(offsetOffset);\n        raf.writeLong(writtenSoFar);\n\n        raf.seek(currFP);\n\n        // Now write each of the files in the DirectoryEntry\n        List<ZipFileIndexEntry> entries = de.getEntriesAsCollection();\n        for (ZipFileIndexEntry zfie : entries) {\n          // Write the name bytes\n          byte[] zfieNameBytes = zfie.name.getBytes(\"UTF-8\");\n          int zfieNameBytesLen = zfieNameBytes.length;\n          raf.writeInt(zfieNameBytesLen);\n          writtenSoFar += 4;\n          raf.write(zfieNameBytes);\n          writtenSoFar += zfieNameBytesLen;\n\n          // Write isDir\n          raf.writeByte(zfie.isDir ? (byte) 1 : (byte) 0);\n          writtenSoFar += 1;\n\n          // Write offset of bytes in the real Jar/Zip file\n          raf.writeInt(zfie.offset);\n          writtenSoFar += 4;\n\n          // Write size of the file in the real Jar/Zip file\n          raf.writeInt(zfie.size);\n          writtenSoFar += 4;\n\n          // Write compressed size of the file in the real Jar/Zip file\n          raf.writeInt(zfie.compressedSize);\n          writtenSoFar += 4;\n\n          // Write java time stamp of the file in the real Jar/Zip file\n          raf.writeLong(zfie.getLastModified());\n          writtenSoFar += 8;\n        }\n      }\n    } catch (Throwable t) {\n      // Do nothing\n    } finally {\n      try {\n        if (raf != null) {\n          raf.close();\n        }\n      } catch (IOException ioe) {\n        // Do nothing\n      }\n    }\n\n    return ret;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6863, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [207], "configurationEnd": [248], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 256, "focalAPIEnd": 292, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/okoye/Puppet-OS/tree/master/contiki/tools/coffee-manager/se/sics/coffee/CoffeeImageFile.java", "rawCode": "  public void erase(int size, int offset) throws IOException {\n    byte[] bytes = new byte[256];\n    int chunkSize;\n\n    while (size > 0) {\n      chunkSize = size > bytes.length ? bytes.length : size;\n      imageFile.seek(conf.startOffset + offset);\n      imageFile.write(bytes, 0, chunkSize);\n      size -= chunkSize;\n      offset += chunkSize;\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6864, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [206], "initializationEnd": [238], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new RuntimeException(String,*)"], "tryExpressionStart": 172, "tryExpressionEnd": 176, "tryBlockStart": 172, "tryBlockEnd": 418, "catchExpressionStart": 319, "catchExpressionEnd": 341, "catchBlockStart": 319, "catchBlockEnd": 418, "exceptionHandlingCallStart": [355], "exceptionHandlingCallEnd": [411], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 246, "focalAPIEnd": 260, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.setLength(int)", "randomAccessFile.close()"], "useStart": [268, 301], "useEnd": [293, 311], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ferquies/2dam/tree/master/AD/Tema 2/h2/src/tools/org/h2/build/BuildBase.java", "rawCode": "  /**\n   * Create or overwrite a file.\n   *\n   * @param file the file\n   * @param data the data to write\n   */\n  public static void writeFile(File file, byte[] data) {\n    try {\n      RandomAccessFile ra = new RandomAccessFile(file, \"rw\");\n      ra.write(data);\n      ra.setLength(data.length);\n      ra.close();\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error writing to file \" + file, e);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6865, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)", "printStackTrace()"], "tryExpressionStart": 75, "tryExpressionEnd": 79, "tryBlockStart": 75, "tryBlockEnd": 505, "catchExpressionStart": 393, "catchExpressionEnd": 413, "catchBlockStart": 393, "catchBlockEnd": 505, "exceptionHandlingCallStart": [421, 479], "exceptionHandlingCallEnd": [471, 498], "configuration": ["randomAccessFile.seek(long)", "randomAccessFile.writeInt(int)"], "configurationStart": [87, 188], "configurationEnd": [103, 207], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 303, "focalAPIEnd": 335, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olanto/MYCAT/tree/master/prog/coreidx/src/org/olanto/idxvli/IdxIO.java", "rawCode": "  protected final void saveBag(int d, int[] bag) {\n    int length = 0;\n    try {\n      bf.seek(lastbag);\n      glue.rdnbag[d] = lastbag;\n      // save idx\n      length = bag.length;\n      bf.writeInt(length);\n      byte[] byteidx = new byte[length * 4];\n      intTobyte(bag, length * 4, byteidx);\n      bf.write(byteidx, 0, length * 4);\n      lastbag += 4 * length + 4; // int = 4bytes\n\n    } catch (Exception e) {\n      System.err.println(\"IO error in savebag doc=\" + d);\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6866, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 80, "focalAPIEnd": 103, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[])"], "useStart": [109], "useEnd": [139], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/irbull/rt.eclipse.p2/tree/master/bundles/org.eclipse.equinox.p2.publisher.eclipse/src/org/eclipse/pde/internal/swt/tools/IconExe.java", "rawCode": "  static void writeU2(RandomAccessFile raf, int value) throws IOException {\n    raf.write(value & 0xFF);\n    raf.write((value >> 8) & 0xFF);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6867, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [81], "configurationEnd": [122], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 128, "focalAPIEnd": 159, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/paolope/Contiki-MspCodeWatcherImproved/tree/master/tools/coffee-manager/se/sics/coffee/CoffeeImageFile.java", "rawCode": "  public void write(byte[] bytes, int size, int offset) throws IOException {\n    imageFile.seek(conf.startOffset + offset);\n    imageFile.write(bytes, 0, size);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6868, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 68, "focalAPIEnd": 87, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.writeInt(int)", "randomAccessFile.writeInt(int)", "randomAccessFile.writeLong(long)", "randomAccessFile.writeUTF(String)"], "useStart": [93, 126, 156, 194], "useEnd": [120, 150, 188, 222], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Schmoller/PlayerSpy/tree/master/src/au/com/mineauz/PlayerSpy/Utilities/Journal.java", "rawCode": "  public void write(RandomAccessFile file) throws IOException {\n    file.write(idBytes);\n    file.writeInt(sectionCount);\n    file.writeInt(randomVal);\n    file.writeLong(originalFileSize);\n    file.writeUTF(masterJournal);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6869, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [150], "initializationEnd": [179], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 1255, "focalAPIEnd": 1269, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.getChannel()", "randomAccessFile.length()"], "useStart": [1281, 1351], "useEnd": [1297, 1363], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/atgreen/moxiedev/tree/master/gcc/libjava/gnu/gcj/runtime/PersistentByteMap.java", "rawCode": "  private void init(PersistentByteMap m, File f, int capacity, int strtabSize) throws IOException {\n    f.createNewFile();\n    RandomAccessFile raf = new RandomAccessFile(f, \"rw\");\n\n    {\n      // The user has explicitly provided a size for the table.\n      // We're going to make that size prime. This isn't\n      // strictly necessary but it can't hurt.\n      //\n      // We expand the size by 3/2 and round the result because the\n      // hash table is intolerably slow when more than 2/3 full.\n\n      BigInteger size = new BigInteger(Integer.toString(((capacity * 3) + 1) / 2));\n      BigInteger two = BigInteger.ONE.add(BigInteger.ONE);\n\n      if (size.getLowestSetBit() != 0) // A hard way to say isEven()\n      size = size.add(BigInteger.ONE);\n\n      while (!size.isProbablePrime(10)) size = size.add(two);\n\n      this.capacity = capacity = size.intValue();\n    }\n\n    table_base = 64;\n    string_base = table_base + capacity * TABLE_ENTRY_SIZE;\n    string_size = 0;\n    file_size = string_base;\n    elements = 0;\n\n    int totalFileSize = string_base + strtabSize;\n\n    // Create the file; this rounds up the size of the file to a fixed\n    // number of 4k pages.\n    byte[] _4k = new byte[4096];\n    for (long i = 0; i < totalFileSize; i += 4096) raf.write(_4k);\n\n    fc = raf.getChannel();\n    buf = fc.map(FileChannel.MapMode.READ_WRITE, 0, raf.length());\n\n    for (int i = 0; i < capacity; i++) putKeyPos(UNUSED_ENTRY, i);\n\n    putWord(0x67636a64, MAGIC);\n    putWord(0x01, VERSION);\n    putWord(capacity, CAPACITY);\n    putWord(table_base, TABLE_BASE);\n    putWord(string_base, STRING_BASE);\n    putWord(file_size, FILE_SIZE);\n    putWord(elements, ELEMENTS);\n    buf.force();\n\n    length = fc.size();\n    string_size = 0;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6870, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 133, "focalAPIEnd": 163, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[],int,int)"], "useStart": [183], "useEnd": [210], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/krosenvold/struts2/tree/master/core/src/main/java/org/apache/struts2/util/FastByteArrayOutputStream.java", "rawCode": "  public void writeTo(OutputStream out) throws IOException {\n    if (buffers != null) {\n      for (byte[] bytes : buffers) {\n        out.write(bytes, 0, blockSize);\n      }\n    }\n    out.write(buffer, 0, index);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6871, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["resetPointer()", "logContext(*,*)"], "tryExpressionStart": 74, "tryExpressionEnd": 78, "tryBlockStart": 74, "tryBlockEnd": 534, "catchExpressionStart": 433, "catchExpressionEnd": 455, "catchBlockStart": 433, "catchBlockEnd": 534, "exceptionHandlingCallStart": [463, 485], "exceptionHandlingCallEnd": [477, 511], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [130], "configurationEnd": [153], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 339, "focalAPIEnd": 362, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/elka-projekt/cs-voltdb/tree/master/src/hsqldb19b3/org/hsqldb_voltpatches/persist/ScaledRAFile.java", "rawCode": "  public void write(byte[] b, int off, int len) throws IOException {\n\n    try {\n      if (realPosition != seekPosition) {\n        file.seek(seekPosition);\n\n        realPosition = seekPosition;\n      }\n\n      if (seekPosition < bufferOffset + buffer.length && seekPosition + len > bufferOffset) {\n        bufferDirty = true;\n      }\n\n      file.write(b, off, len);\n\n      seekPosition += len;\n      realPosition = seekPosition;\n    } catch (IOException e) {\n      resetPointer();\n      appLog.logContext(e, null);\n\n      throw e;\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6872, "initialization": ["byte[] b = ByteArrayOutputStream.toByteArray()", "RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [3899, 3990], "initializationEnd": [3916, 4022], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 4032, "focalAPIEnd": 4048, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.setLength(int)", "randomAccessFile.close()"], "useStart": [4058, 4095], "useEnd": [4085, 4104], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chris-martin/h2/tree/master/h2/src/tools/org/h2/build/code/CheckTextFiles.java", "rawCode": "  /**\n   * Check a source code file. The following properties are checked: copyright, license, incorrect\n   * source switches, trailing white space, newline characters, tab characters, and characters codes\n   * (only characters below 128 are allowed).\n   *\n   * @param file the file to check\n   * @param fix automatically fix newline characters and trailing spaces\n   * @param checkLicense check the license and copyright\n   */\n  public void checkOrFixFile(File file, boolean fix, boolean checkLicense) throws Exception {\n    RandomAccessFile in = new RandomAccessFile(file, \"r\");\n    byte[] data = new byte[(int) file.length()];\n    ByteArrayOutputStream out = fix ? new ByteArrayOutputStream() : null;\n    in.readFully(data);\n    in.close();\n    if (checkLicense) {\n      if (data.length > COPYRIGHT.length() + LICENSE.length()) {\n        // don't check tiny files\n        String text = new String(data);\n        if (text.indexOf(COPYRIGHT) < 0) {\n          fail(file, \"copyright is missing\", 0);\n        }\n        if (text.indexOf(LICENSE) < 0) {\n          fail(file, \"license is missing\", 0);\n        }\n        if (text.indexOf(\"// \" + \"##\") > 0) {\n          fail(file, \"unexpected space between // and ##\", 0);\n        }\n        if (text.indexOf(\"/* \" + \"##\") > 0) {\n          fail(file, \"unexpected space between /* and ##\", 0);\n        }\n        if (text.indexOf(\"##\" + \" */\") > 0) {\n          fail(file, \"unexpected space between ## and */\", 0);\n        }\n      }\n    }\n    int line = 1;\n    boolean lastWasWhitespace = false;\n    for (int i = 0; i < data.length; i++) {\n      char ch = (char) (data[i] & 0xff);\n      boolean isWhitespace = Character.isWhitespace(ch);\n      if (ch > 127) {\n        fail(file, \"contains character \" + (int) ch + \" at \" + new String(data, i - 10, 20), line);\n        return;\n      } else if (ch < 32) {\n        if (ch == '\\n') {\n          if (lastWasWhitespace && !ALLOW_TRAILING_SPACES) {\n            fail(file, \"contains trailing white space\", line);\n            return;\n          }\n          if (fix) {\n            if (useCRLF) {\n              out.write('\\r');\n            }\n            out.write(ch);\n          }\n          lastWasWhitespace = false;\n          line++;\n        } else if (ch == '\\r') {\n          if (!ALLOW_CR) {\n            fail(file, \"contains CR\", line);\n            return;\n          }\n          if (lastWasWhitespace && !ALLOW_TRAILING_SPACES) {\n            fail(file, \"contains trailing white space\", line);\n            return;\n          }\n          lastWasWhitespace = false;\n          // ok\n        } else if (ch == '\\t') {\n          if (fix) {\n            for (int j = 0; j < SPACES_PER_TAB; j++) {\n              out.write(' ');\n            }\n          } else {\n            if (!ALLOW_TAB) {\n              fail(file, \"contains TAB\", line);\n              return;\n            }\n          }\n          lastWasWhitespace = true;\n          // ok\n        } else {\n          fail(file, \"contains character \" + (int) ch, line);\n          return;\n        }\n      } else if (isWhitespace) {\n        lastWasWhitespace = true;\n        if (fix) {\n          boolean write = true;\n          for (int j = i + 1; j < data.length; j++) {\n            char ch2 = (char) (data[j] & 0xff);\n            if (ch2 == '\\n' || ch2 == '\\r') {\n              write = false;\n              lastWasWhitespace = false;\n              ch = ch2;\n              i = j - 1;\n              break;\n            } else if (!Character.isWhitespace(ch2)) {\n              break;\n            }\n          }\n          if (write) {\n            out.write(ch);\n          }\n        }\n      } else {\n        if (fix) {\n          out.write(ch);\n        }\n        lastWasWhitespace = false;\n      }\n    }\n    if (lastWasWhitespace && !ALLOW_TRAILING_SPACES) {\n      fail(file, \"contains trailing white space at the very end\", line);\n      return;\n    }\n    if (fix) {\n      byte[] changed = out.toByteArray();\n      if (!Arrays.equals(data, changed)) {\n        RandomAccessFile f = new RandomAccessFile(file, \"rw\");\n        f.write(changed);\n        f.setLength(changed.length);\n        f.close();\n        System.out.println(\"CHANGED: \" + file.getName());\n      }\n    }\n    line = 1;\n    for (int i = 0; i < data.length; i++) {\n      if (data[i] < 32) {\n        line++;\n        for (int j = i + 1; j < data.length; j++) {\n          if (data[j] != 32) {\n            int mod = (j - i - 1) & 3;\n            if (mod != 0 && (mod != 1 || data[j] != '*')) {\n              fail(file, \"contains wrong number of heading spaces: \" + (j - i - 1), line);\n            }\n            break;\n          }\n        }\n      }\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6873, "initialization": ["byte[] b = buffer()"], "initializationStart": [143], "initializationEnd": [151], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)", "randomAccessFile.readFully(byte[],int,int)", "randomAccessFile.seek(int)"], "configurationStart": [394, 411, 549], "configurationEnd": [405, 436, 560], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 566, "focalAPIEnd": 587, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.read(byte[])"], "useStart": [662], "useEnd": [675], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/SiteView/NEWECC9.2/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/storage/file/ObjectDirectoryPackParser.java", "rawCode": "  @Override\n  protected void onEndThinPack() throws IOException {\n    final byte[] tailHash = this.tailDigest.digest();\n    final byte[] buf = buffer();\n\n    final MessageDigest origDigest = Constants.newMessageDigest();\n    final MessageDigest tailDigest = Constants.newMessageDigest();\n    final MessageDigest packDigest = Constants.newMessageDigest();\n\n    long origRemaining = origEnd;\n    out.seek(0);\n    out.readFully(buf, 0, 12);\n    origDigest.update(buf, 0, 12);\n    origRemaining -= 12;\n\n    NB.encodeInt32(buf, 8, getObjectCount());\n    out.seek(0);\n    out.write(buf, 0, 12);\n    packDigest.update(buf, 0, 12);\n\n    for (; ; ) {\n      final int n = out.read(buf);\n      if (n < 0) break;\n      if (origRemaining != 0) {\n        final int origCnt = (int) Math.min(n, origRemaining);\n        origDigest.update(buf, 0, origCnt);\n        origRemaining -= origCnt;\n        if (origRemaining == 0) tailDigest.update(buf, origCnt, n - origCnt);\n      } else tailDigest.update(buf, 0, n);\n\n      packDigest.update(buf, 0, n);\n    }\n\n    if (!Arrays.equals(origDigest.digest(), origHash)\n        || !Arrays.equals(tailDigest.digest(), tailHash))\n      throw new IOException(JGitText.get().packCorruptedWhileWritingToFilesystem);\n\n    packHash = packDigest.digest();\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6874, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [207], "configurationEnd": [248], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 256, "focalAPIEnd": 292, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/paolope/Contiki-MspCodeWatcherImproved/tree/master/tools/coffee-manager/se/sics/coffee/CoffeeImageFile.java", "rawCode": "  public void erase(int size, int offset) throws IOException {\n    byte[] bytes = new byte[256];\n    int chunkSize;\n\n    while (size > 0) {\n      chunkSize = size > bytes.length ? bytes.length : size;\n      imageFile.seek(conf.startOffset + offset);\n      imageFile.write(bytes, 0, chunkSize);\n      size -= chunkSize;\n      offset += chunkSize;\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6875, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new RuntimeException(String,*)"], "tryExpressionStart": 160, "tryExpressionEnd": 164, "tryBlockStart": 160, "tryBlockEnd": 397, "catchExpressionStart": 298, "catchExpressionEnd": 320, "catchBlockStart": 298, "catchBlockEnd": 397, "exceptionHandlingCallStart": [334], "exceptionHandlingCallEnd": [390], "configuration": ["randomAccessFile.writeInt(int)"], "configurationStart": [215], "configurationEnd": [242], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 250, "focalAPIEnd": 267, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/google-web-toolkit/gwt/tree/master/dev/core/src/com/google/gwt/dev/util/DiskCache.java", "rawCode": "  /**\n   * Write a byte array to disk.\n   *\n   * @return a token to retrieve the data later\n   */\n  public synchronized long writeByteArray(byte[] bytes) {\n    try {\n      long position = moveToEndPosition();\n      file.writeInt(bytes.length);\n      file.write(bytes);\n      return position;\n    } catch (IOException e) {\n      throw new RuntimeException(\"Unable to write to byte cache\", e);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6876, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 75, "tryExpressionEnd": 79, "tryBlockStart": 75, "tryBlockEnd": 198, "catchExpressionStart": 142, "catchExpressionEnd": 164, "catchBlockStart": 142, "catchBlockEnd": 198, "exceptionHandlingCallStart": [172], "exceptionHandlingCallEnd": [191], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 87, "focalAPIEnd": 134, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joninvski/Appia/tree/master/trunk/appia/src/test/net/sf/appia/test/perf/PerfSession.java", "rawCode": "  private void readPayload(MsgBuffer mbuf, RandomAccessFile payload) {\n    try {\n      payloadOut.write(mbuf.data, mbuf.off, mbuf.len);\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6877, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [353], "initializationEnd": [382], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 388, "focalAPIEnd": 398, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [425], "useEnd": [434], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/coderplay/h2-bitmap/tree/master/h2/src/test/org/h2/test/db/TestReadOnly.java", "rawCode": "  private void testReadOnlyFiles(boolean setReadOnly) throws Exception {\n    new File(System.getProperty(\"java.io.tmpdir\")).mkdirs();\n    File f = File.createTempFile(\"test\", \"temp\");\n    assertTrue(f.canWrite());\n    f.setReadOnly();\n    assertTrue(!f.canWrite());\n    f.delete();\n\n    f = File.createTempFile(\"test\", \"temp\");\n    RandomAccessFile r = new RandomAccessFile(f, \"rw\");\n    r.write(1);\n    f.setReadOnly();\n    r.close();\n    assertTrue(!f.canWrite());\n    f.delete();\n\n    deleteDb(\"readonly\");\n    Connection conn = getConnection(\"readonly\");\n    Statement stat = conn.createStatement();\n    stat.execute(\"CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR)\");\n    stat.execute(\"INSERT INTO TEST VALUES(1, 'Hello')\");\n    stat.execute(\"INSERT INTO TEST VALUES(2, 'World')\");\n    assertTrue(!conn.isReadOnly());\n    conn.close();\n\n    if (setReadOnly) {\n      setReadOnly();\n      conn = getConnection(\"readonly\");\n    } else {\n      conn = getConnection(\"readonly;ACCESS_MODE_DATA=r\");\n    }\n    assertTrue(conn.isReadOnly());\n    stat = conn.createStatement();\n    stat.execute(\"SELECT * FROM TEST\");\n    assertThrows(ErrorCode.DATABASE_IS_READ_ONLY, stat).execute(\"DELETE FROM TEST\");\n    conn.close();\n\n    if (setReadOnly) {\n      conn = getConnection(\"readonly;DB_CLOSE_DELAY=1\");\n    } else {\n      conn = getConnection(\"readonly;DB_CLOSE_DELAY=1;ACCESS_MODE_DATA=r\");\n    }\n    stat = conn.createStatement();\n    stat.execute(\"SELECT * FROM TEST\");\n    assertThrows(ErrorCode.DATABASE_IS_READ_ONLY, stat).execute(\"DELETE FROM TEST\");\n    stat.execute(\"SET DB_CLOSE_DELAY=0\");\n    conn.close();\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6878, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.length()", "randomAccessFile.setLength(int)"], "configurationStart": [949, 1395], "configurationEnd": [967, 1447], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 2502, "focalAPIEnd": 2525, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[])"], "useStart": [2621], "useEnd": [2644], "hasFinally": 1, "cleanUpCall": ["Inflater.end()"], "finallyExpressionStart": 3301, "finallyExpressionEnd": 3309, "finallyBlockStart": 3301, "finallyBlockEnd": 3342, "cleanUpCallStart": [3317], "cleanUpCallEnd": [3335], "url": "https://github.com/araqne/logdb/tree/master/araqne-logstorage/src/main/java/org/araqne/logstorage/file/LogFileRepairerV2.java", "rawCode": "  private LogFileFixReport generate(\n      File indexPath,\n      File dataPath,\n      RandomAccessFile indexFile,\n      RandomAccessFile dataFile,\n      List<LogIndexBlock> indexBlocks,\n      List<LogDataBlockHeader> dataBlockHeaders)\n      throws IOException {\n    logger.trace(\"araqne logstorage: checking incomplete index block, file [{}]\", indexPath);\n\n    // truncate data file\n    LogDataBlockHeader lastDataBlockHeader = dataBlockHeaders.get(dataBlockHeaders.size() - 1);\n    long logicalEndOfData =\n        lastDataBlockHeader.getFilePointer() + 24 + lastDataBlockHeader.getCompressedLength();\n\n    long dataOver = dataFile.length() - logicalEndOfData;\n    if (dataOver > 0) {\n      dataFile.setLength(logicalEndOfData);\n      dataBlockHeaders.remove(dataBlockHeaders.size() - 1);\n    }\n\n    // check immature last index block writing\n    LogIndexBlock lastIndexBlock = indexBlocks.get(indexBlocks.size() - 1);\n    long lastIndexBlockSize = indexFile.length() - lastIndexBlock.getFilePointer();\n    long expectedIndexBlockSize = 4 + lastIndexBlock.getCount() * LogFileReaderV2.INDEX_ITEM_SIZE;\n\n    // truncate immature last index block\n    if (lastIndexBlockSize != expectedIndexBlockSize) {\n      logger.trace(\n          \"araqne logstorage: expected last index block size [{}], actual last index block size [{}]\",\n          expectedIndexBlockSize,\n          lastIndexBlockSize);\n      indexFile.setLength(lastIndexBlock.getFilePointer());\n      indexBlocks.remove(indexBlocks.size() - 1);\n\n      logger.info(\n          \"araqne logstorage: truncated immature last index block [{}], removed [{}] bytes\",\n          indexPath,\n          lastIndexBlockSize);\n    }\n\n    Inflater decompresser = new Inflater();\n    int addedLogs = 0;\n    try {\n      // generate index block (support only v2 block recovery)\n      int offset = indexBlocks.size();\n      int missingBlockCount = dataBlockHeaders.size() - indexBlocks.size();\n      byte[] intbuf = new byte[4];\n      logger.info(\n          \"araqne logstorage: index block [{}], data block [{}], missing count [{}]\",\n          new Object[] {indexBlocks.size(), dataBlockHeaders.size(), missingBlockCount});\n\n      for (int i = 0; i < missingBlockCount; i++) {\n        LogDataBlockHeader blockHeader = dataBlockHeaders.get(offset + i);\n        ByteBuffer bb = readDataBlockV2(decompresser, dataFile, blockHeader);\n        List<Integer> logOffsets = readLogOffsets(bb);\n\n        // write index block\n        prepareInt(logOffsets.size(), intbuf);\n        indexFile.write(intbuf);\n        for (int logOffset : logOffsets) {\n          prepareInt(logOffset, intbuf);\n          indexFile.write(intbuf);\n        }\n\n        addedLogs += logOffsets.size();\n        logger.info(\n            \"araqne logstorage: rewrite index block for {}, log count [{}], index file [{}]\",\n            new Object[] {blockHeader, logOffsets.size(), indexPath});\n      }\n\n      LogFileFixReport report = new LogFileFixReport();\n      report.setIndexPath(indexPath);\n      report.setDataPath(dataPath);\n      report.setTotalLogCount(countLogs(indexBlocks) + addedLogs);\n      report.setTotalIndexBlocks(indexBlocks.size() + missingBlockCount);\n      report.setTotalDataBlocks(dataBlockHeaders.size());\n      report.setAddedIndexBlocks(missingBlockCount);\n      return report;\n    } finally {\n      decompresser.end();\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6879, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["new RuntimeException(String,*)"], "tryExpressionStart": 160, "tryExpressionEnd": 164, "tryBlockStart": 160, "tryBlockEnd": 397, "catchExpressionStart": 298, "catchExpressionEnd": 320, "catchBlockStart": 298, "catchBlockEnd": 397, "exceptionHandlingCallStart": [334], "exceptionHandlingCallEnd": [390], "configuration": ["randomAccessFile.writeInt(int)"], "configurationStart": [215], "configurationEnd": [242], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 250, "focalAPIEnd": 267, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vaadin/gwt/tree/master/dev/core/src/com/google/gwt/dev/util/DiskCache.java", "rawCode": "  /**\n   * Write a byte array to disk.\n   *\n   * @return a token to retrieve the data later\n   */\n  public synchronized long writeByteArray(byte[] bytes) {\n    try {\n      long position = moveToEndPosition();\n      file.writeInt(bytes.length);\n      file.write(bytes);\n      return position;\n    } catch (IOException e) {\n      throw new RuntimeException(\"Unable to write to byte cache\", e);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6880, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(File,String)"], "initializationStart": [950], "initializationEnd": [989], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "(len)!=-1", "guardType": "LOOP {", "guardExpressionStart": 1486, "guardExpressionEnd": 1549, "guardBlockStart": 1486, "guardBlockEnd": 1625, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 1560, "focalAPIEnd": 1616, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.setLength(int)", "randomAccessFile.seek(int)", "randomAccessFile.write(byte[],int,int)", "randomAccessFile.close()"], "useStart": [1669, 1779, 2089, 2161], "useEnd": [1714, 1818, 2149, 2190], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benothman/jboss-web-nio2/tree/master/java/org/apache/catalina/servlets/DefaultServlet.java", "rawCode": "  /**\n   * Handle a partial PUT. New content specified in request is appended to existing content in\n   * oldRevisionContent (if present). This code does not support simultaneous partial updates to the\n   * same resource.\n   */\n  protected File executePartialPut(HttpServletRequest req, Range range, String path)\n      throws IOException {\n\n    // Append data specified in ranges to existing content for this\n    // resource - create a temp. file on the local filesystem to\n    // perform this operation\n    File tempDir = (File) getServletContext().getAttribute(ServletContext.TEMPDIR);\n    // Convert all '/' characters to '.' in resourcePath\n    String convertedResourcePath = path.replace('/', '.');\n    File contentFile = new File(tempDir, convertedResourcePath);\n    if (contentFile.createNewFile()) {\n      // Clean up contentFile when Tomcat is terminated\n      contentFile.deleteOnExit();\n    }\n\n    RandomAccessFile randAccessContentFile = new RandomAccessFile(contentFile, \"rw\");\n\n    Resource oldResource = null;\n    try {\n      Object obj = resources.lookup(path);\n      if (obj instanceof Resource) oldResource = (Resource) obj;\n    } catch (NamingException e) {\n      // Ignore\n    }\n\n    // Copy data in oldRevisionContent to contentFile\n    if (oldResource != null) {\n      BufferedInputStream bufOldRevStream =\n          new BufferedInputStream(oldResource.streamContent(), BUFFER_SIZE);\n\n      int numBytesRead;\n      byte[] copyBuffer = new byte[BUFFER_SIZE];\n      while ((numBytesRead = bufOldRevStream.read(copyBuffer)) != -1) {\n        randAccessContentFile.write(copyBuffer, 0, numBytesRead);\n      }\n\n      bufOldRevStream.close();\n    }\n\n    randAccessContentFile.setLength(range.length);\n\n    // Append data in request input stream to contentFile\n    randAccessContentFile.seek(range.start);\n    int numBytesRead;\n    byte[] transferBuffer = new byte[BUFFER_SIZE];\n    BufferedInputStream requestBufInStream =\n        new BufferedInputStream(req.getInputStream(), BUFFER_SIZE);\n    while ((numBytesRead = requestBufInStream.read(transferBuffer)) != -1) {\n      randAccessContentFile.write(transferBuffer, 0, numBytesRead);\n    }\n    randAccessContentFile.close();\n    requestBufInStream.close();\n\n    return contentFile;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6881, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["println(String)", "printStackTrace()"], "tryExpressionStart": 75, "tryExpressionEnd": 79, "tryBlockStart": 75, "tryBlockEnd": 478, "catchExpressionStart": 366, "catchExpressionEnd": 386, "catchBlockStart": 366, "catchBlockEnd": 478, "exceptionHandlingCallStart": [394, 452], "exceptionHandlingCallEnd": [444, 471], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [87], "configurationEnd": [103], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 276, "focalAPIEnd": 308, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/olanto/MYCAT/tree/master/prog/coreidx/src/org/olanto/idxvli/IdxIO.java", "rawCode": "  protected final void saveSeq(int d, int[] seq) {\n    int length = 0;\n    try {\n      sf.seek(lastseq);\n      glue.rdnseq[d] = lastseq;\n      // save idx\n      length = seq.length;\n      byte[] byteidx = new byte[length * 4];\n      intTobyte(seq, length * 4, byteidx);\n      sf.write(byteidx, 0, length * 4);\n      lastseq += 4 * length + 4; // int = 4bytes\n\n    } catch (Exception e) {\n      System.err.println(\"IO error in saveseq doc=\" + d);\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6882, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [596], "configurationEnd": [608], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 614, "focalAPIEnd": 635, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/YongJiang/org.eclipse.birt.common/tree/master/plugins/org.eclipse.birt.core/src/org/eclipse/birt/core/archive/compound/ArchiveFileV2.java", "rawCode": "  /**\n   * write the data into cache.\n   *\n   * <p>The API saves <code>len</code> bytes in <code>b</code> from <code>off</code> to block <code>\n   * blockId</code> from <code>blockOff</code>\n   *\n   * @param blockId block id.\n   * @param blockOff offset in the block.\n   * @param b data to be saved\n   * @param off offset.\n   * @param len write size.\n   * @throws IOException\n   */\n  synchronized void write(int blockId, int blockOff, byte[] b, int off, int len)\n      throws IOException {\n    assertWritable();\n    ensureFileCreated();\n    long pos = (long) blockId * BLOCK_SIZE + blockOff;\n    rf.seek(pos);\n    rf.write(b, off, len);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6883, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [170], "initializationEnd": [232], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [460], "configurationEnd": [488], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 494, "focalAPIEnd": 531, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [537], "useEnd": [548], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johnugeorge/distributed/tree/master/Fast_Copy_HDFS/src/test/org/apache/hadoop/hdfs/TestFSInputChecker.java", "rawCode": "  private void checkFileCorruption(LocalFileSystem fileSys, Path file, Path fileToCorrupt)\n      throws IOException {\n\n    // corrupt the file\n    RandomAccessFile out = new RandomAccessFile(new File(fileToCorrupt.toString()), \"rw\");\n\n    byte[] buf = new byte[(int) fileSys.getFileStatus(file).getLen()];\n    int corruptFileLen = (int) fileSys.getFileStatus(fileToCorrupt).getLen();\n    assertTrue(buf.length >= corruptFileLen);\n\n    rand.nextBytes(buf);\n    out.seek(corruptFileLen / 2);\n    out.write(buf, 0, corruptFileLen / 4);\n    out.close();\n\n    boolean gotException = false;\n\n    InputStream in = fileSys.open(file);\n    try {\n      IOUtils.readFully(in, buf, 0, buf.length);\n    } catch (ChecksumException e) {\n      gotException = true;\n    }\n    assertTrue(gotException);\n    in.close();\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6884, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["printStackTrace()", "getName()", "e(*,String)"], "tryExpressionStart": 94, "tryExpressionEnd": 98, "tryBlockStart": 94, "tryBlockEnd": 966, "catchExpressionStart": 768, "catchExpressionEnd": 790, "catchBlockStart": 768, "catchBlockEnd": 966, "exceptionHandlingCallStart": [798, 842, 825], "exceptionHandlingCallEnd": [817, 874, 942], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 166, "focalAPIEnd": 198, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/saetre/TABuss/tree/master/src/org/ubicompforall/BusTUC/Speech/ExtAudioRecorder.java", "rawCode": "  public void record() {\n    audioRecorder.read(buffer, 0, buffer.length); // Fill buffer\n    try {\n      // System.out.println(\"BUFFERSTR: \" + buffer.length);\n      randomAccessWriter.write(buffer); // Write buffer to file\n      payloadSize += buffer.length;\n      if (bSamples == 16) {\n        for (int i = 0; i < buffer.length / 2; i++) { // 16bit sample size\n          short curSample = getShort(buffer[i * 2], buffer[i * 2 + 1]);\n          if (curSample > cAmplitude) { // Check amplitude\n            cAmplitude = curSample;\n          }\n        }\n      } else { // 8bit sample size\n        for (int i = 0; i < buffer.length; i++) {\n          if (buffer[i] > cAmplitude) { // Check amplitude\n            cAmplitude = buffer[i];\n          }\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n      Log.e(\n          ExtAudioRecorder.class.getName(),\n          \"Error occured in updateListener, recording is aborted\");\n      // stop();\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6885, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 459, "focalAPIEnd": 477, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[])"], "useStart": [484], "useEnd": [501], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tulskiy/musique/tree/master/dependencies/jaudiotagger/src/main/java/org/jaudiotagger/tag/lyrics3/FieldFrameBodyUnsupported.java", "rawCode": "  /**\n   * @param file\n   * @throws IOException\n   */\n  public void write(RandomAccessFile file) throws IOException {\n    int offset = 0;\n    String str;\n    byte[] buffer = new byte[5];\n\n    str = Integer.toString(value.length);\n\n    for (int i = 0; i < (5 - str.length()); i++) {\n      buffer[i] = (byte) '0';\n    }\n\n    offset += (5 - str.length());\n\n    for (int i = 0; i < str.length(); i++) {\n      buffer[i + offset] = (byte) str.charAt(i);\n    }\n\n    file.write(buffer);\n\n    file.write(value);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6886, "initialization": ["byte[] b = ByteArrayOutputStream.toByteArray()"], "initializationStart": [855], "initializationEnd": [873], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.getFilePointer()", "randomAccessFile.length()", "randomAccessFile.seek(long)", "randomAccessFile.setLength(long)"], "configurationStart": [209, 253, 311, 473], "configurationEnd": [235, 271, 331, 501], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 911, "focalAPIEnd": 930, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.seek(long)"], "useStart": [946], "useEnd": [966], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/aduros-mirrors/caffeine-hx/tree/master/projects/memedb/src/java/memedb/state/FileSystemState.java", "rawCode": "  /**\n   * Checks the size of the index and data files, growing them to at least initial capacity or\n   * GROWTH_FACTOR times larger\n   */\n  private void checkCapacities() throws IOException {\n    long posI = indexFile.getFilePointer();\n    long lenI = indexFile.length();\n    if (posI >= (0.8 * lenI)) {\n      indexFile.seek(lenI);\n      long newSize = ((long) (lenI * GROWTH_FACTOR)) + lenI;\n      if (newSize == 0) newSize = INITIAL_CAPACITY * SIZEOF_INDEX_ENTRY;\n      indexFile.setLength(newSize);\n      long count = (newSize - lenI) / SIZEOF_INDEX_ENTRY / 1024;\n\n      // 16k buffer, 1024 entries of 16 bytes\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      DataOutputStream dos = new DataOutputStream(baos);\n      for (int x = 0; x < 1024; x++) {\n        dos.writeLong(-1);\n        dos.writeLong(-1);\n      }\n      byte[] ba = baos.toByteArray();\n      while (count-- > 0) {\n        indexFile.write(ba);\n      }\n      indexFile.seek(posI);\n    }\n\n    long posD = dataFile.getFilePointer();\n    long lenD = dataFile.length();\n    if (posD >= (0.8 * lenD)) {\n      long newSize = ((long) (lenD * GROWTH_FACTOR)) + lenD;\n      if (newSize == 0) newSize = INITIAL_CAPACITY * 1024; // 1k per record\n      dataFile.setLength(newSize);\n      dataFile.seek(posD);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6887, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [207], "configurationEnd": [248], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 256, "focalAPIEnd": 292, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/schneider42/contiki/tree/master/tools/coffee-manager/se/sics/coffee/CoffeeImageFile.java", "rawCode": "  public void erase(int size, int offset) throws IOException {\n    byte[] bytes = new byte[256];\n    int chunkSize;\n\n    while (size > 0) {\n      chunkSize = size > bytes.length ? bytes.length : size;\n      imageFile.seek(conf.startOffset + offset);\n      imageFile.write(bytes, 0, chunkSize);\n      size -= chunkSize;\n      offset += chunkSize;\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6888, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 317, "focalAPIEnd": 346, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[],int,int)"], "useStart": [352], "useEnd": [390], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hecao/gallery3d/tree/master/gallerycommon/com/android/gallery3d/common/BlobCache.java", "rawCode": "  private void insertInternal(long key, byte[] data, int length) throws IOException {\n    byte[] header = mBlobHeader;\n    int sum = checkSum(data);\n    writeLong(header, BH_KEY, key);\n    writeInt(header, BH_CHECKSUM, sum);\n    writeInt(header, BH_OFFSET, mActiveBytes);\n    writeInt(header, BH_LENGTH, length);\n    mActiveDataFile.write(header);\n    mActiveDataFile.write(data, 0, length);\n\n    mIndexBuffer.putLong(mSlotOffset, key);\n    mIndexBuffer.putInt(mSlotOffset + 8, mActiveBytes);\n    mActiveBytes += BLOB_HEADER_SIZE + length;\n    writeInt(mIndexHeader, IH_ACTIVE_BYTES, mActiveBytes);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6889, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "BundlePayloadWrongTypeException", "exceptionHandlingCall": ["getInstance()", "getBPFLogger()", "getMessage()", "error(String,*)"], "tryExpressionStart": 757, "tryExpressionEnd": 761, "tryBlockStart": 757, "tryBlockEnd": 1249, "catchExpressionStart": 977, "catchExpressionEnd": 1019, "catchBlockStart": 977, "catchBlockEnd": 1102, "exceptionHandlingCallStart": [1032, 1032, 1076, 1032], "exceptionHandlingCallEnd": [1049, 1064, 1090, 1091], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [859], "configurationEnd": [884], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 897, "focalAPIEnd": 921, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["unpin_file_handle(randomAccessFile)"], "useStart": [934], "useEnd": [965], "hasFinally": 1, "cleanUpCall": ["IByteBuffer.reset()"], "finallyExpressionStart": 1208, "finallyExpressionEnd": 1216, "finallyBlockStart": 1208, "finallyBlockEnd": 1249, "cleanUpCallStart": [1228], "cleanUpCallEnd": [1238], "url": "https://github.com/WSN-2012/BPF/tree/master/src/se/kth/ssvl/tslab/wsn/general/servlib/bundling/bundles/BundlePayload.java", "rawCode": "  /** Write data from the current buffer position to the payload offset with the length */\n  protected void internal_write(IByteBuffer bp, int offset, int len) {\n    assert lock_.isHeldByCurrentThread()\n        : \"BundlePayload:internal_write, lock not held by current Thread\";\n    assert length_ >= (offset + len)\n        : \"BundlePayload:internal_write, length_ is not longer than offset + len\";\n\n    byte[] temp = new byte[len];\n    switch (location_) {\n      case MEMORY:\n        bp.mark();\n        try {\n          for (int i = offset; i < offset + len; i++) {\n            data_[i] = bp.get();\n          }\n        } finally {\n          bp.reset();\n        }\n        break;\n      case DISK:\n        // check if we need to seek\n        bp.mark();\n        try {\n\n          RandomAccessFile file_handle_ = pin_file_handle();\n          bp.get(temp);\n          file_handle_.seek(offset);\n\n          file_handle_.write(temp);\n\n          unpin_file_handle(file_handle_);\n        } catch (BundlePayloadWrongTypeException e) {\n\n          BPF.getInstance().getBPFLogger().error(TAG, e.getMessage());\n        } catch (IOException e) {\n          BPF.getInstance().getBPFLogger().error(TAG, e.getMessage());\n        } finally {\n          bp.reset();\n        }\n        break;\n      case NODATA:\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6890, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [372], "initializationEnd": [407], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.getFD()", "randomAccessFile.seek(long)", "randomAccessFile.setLength(long)"], "configurationStart": [421, 606, 636], "configurationEnd": [432, 624, 659], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 736, "focalAPIEnd": 754, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dxd/2apl--old-/tree/master/2apl/lib/com/sun/jini/reliableLog/ReliableLog.java", "rawCode": "  /**\n   * Opens the incremental update log file in read/write mode. If the file does not exist, it is\n   * created.\n   *\n   * @throws IOException if an I/O error occurs\n   */\n  private void openLogFile() throws IOException {\n    try {\n      close();\n    } catch (IOException e) {\n      /* assume this is okay */\n    }\n\n    logName = versionName(logfilePrefix);\n    log = new RandomAccessFile(logName, \"rw\");\n    logFD = log.getFD();\n\n    if (logBytes == 0) {\n      format = FORMAT_PADDED;\n      writeInt(log, MAGIC);\n      writeInt(log, format);\n      logBytes = (intBytes + intBytes);\n    } else {\n      log.seek(logBytes);\n    }\n    log.setLength(logBytes);\n    /* always start out with zero length header for the next update */\n    log.write(zeroBuf);\n    /* force length header to disk */\n    logFD.sync();\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6891, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 87, "focalAPIEnd": 123, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[])", "randomAccessFile.write(byte[])", "randomAccessFile.write(byte[])"], "useStart": [129, 171, 212], "useEnd": [165, 206, 247], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/quarnster/yamm/tree/master/org/gjt/fredde/yamm/mail/Index.java", "rawCode": "  protected static void write32(RandomAccessFile out, long l) throws IOException {\n    out.write((byte) ((l >> 24) & 0xff));\n    out.write((byte) ((l >> 16) & 0xff));\n    out.write((byte) ((l >> 8) & 0xff));\n    out.write((byte) ((l >> 0) & 0xff));\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6892, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [222], "configurationEnd": [234], "guardCondition": "seek(randomAccessFile,)", "guardType": "IF {", "guardExpressionStart": 198, "guardExpressionEnd": 213, "guardBlockStart": 198, "guardBlockEnd": 267, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 242, "focalAPIEnd": 260, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lboynton/XMPP-Client/tree/master/lib/mp3tag/src/org/farng/mp3/id3/AbstractID3v2.java", "rawCode": "  public void delete(final RandomAccessFile file) throws IOException {\n    // this works by just erasing the \"TAG\" tag at the beginning\n    // of the file\n    final byte[] buffer = new byte[3];\n    if (seek(file)) {\n      file.seek(0);\n      file.write(buffer);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6893, "initialization": ["RandomAccessFile randomAccessFile = new RandomAccessFile(*,String)"], "initializationStart": [395], "initializationEnd": [447], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [453], "configurationEnd": [477], "guardCondition": "(len)!=-1", "guardType": "LOOP {", "guardExpressionStart": 605, "guardExpressionEnd": 639, "guardBlockStart": 605, "guardBlockEnd": 871, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 648, "focalAPIEnd": 670, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [893], "useEnd": [904], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sunqimin09/FirstApp/tree/master/AppVideo/src/com/example/appvideo/play/BBVideoPlayer.java", "rawCode": "  /** 下载一段视频 */\n  private void downloadbyvideoinfo(VideoInfo vi) throws IOException {\n    System.out.println(\"download -> \" + vi.toString());\n\n    URL url = new URL(this.url);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setConnectTimeout(3000);\n    conn.setRequestProperty(\"Range\", \"bytes=\" + vi.offsetstart + \"-\" + vi.offsetend);\n\n    RandomAccessFile raf = new RandomAccessFile(new File(localFilePath), \"rws\");\n    raf.seek(vi.offsetstart);\n\n    InputStream in = conn.getInputStream();\n\n    byte[] buf = new byte[1024 * 10];\n    int len;\n    vi.downloadsize = 0;\n    while ((len = in.read(buf)) != -1) {\n      raf.write(buf, 0, len);\n      vi.downloadsize += len;\n      Message msg = handler.obtainMessage();\n      msg.what = MSG_DOWNLOADUPDATE;\n      msg.obj = vi.offsetstart + vi.downloadsize;\n      handler.sendMessage(msg);\n    }\n\n    in.close();\n    raf.close();\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6894, "initialization": ["byte[] b = String.getBytes(String)"], "initializationStart": [77], "initializationEnd": [95], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 101, "focalAPIEnd": 120, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/smas036/ImageJ/tree/master/src/main/ij/plugin/filter/AVI_Writer.java", "rawCode": "  private void writeString(String s) throws IOException {\n    byte[] bytes = s.getBytes(\"UTF8\");\n    raFile.write(bytes);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6895, "initialization": ["byte[] b = patternToHash(List<LockPatternView.Cell>)", "RandomAccessFile randomAccessFile = new RandomAccessFile(String,String)"], "initializationStart": [297, 409], "initializationEnd": [336, 457], "hasTryCatch": 1, "exceptionType": "FileNotFoundException", "exceptionHandlingCall": ["e(String,String)"], "tryExpressionStart": 342, "tryExpressionEnd": 346, "tryBlockStart": 342, "tryBlockEnd": 2112, "catchExpressionStart": 1773, "catchExpressionEnd": 1808, "catchBlockStart": 1773, "catchBlockEnd": 1982, "exceptionHandlingCallStart": [1907], "exceptionHandlingCallEnd": [1975], "configuration": ["randomAccessFile.setLength(int)"], "configurationStart": [561], "configurationEnd": [577], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 602, "focalAPIEnd": 633, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.close()"], "useStart": [649], "useEnd": [660], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/teamgummy/frameworks_base/tree/master/core/java/com/android/internal/widget/LockPatternUtils.java", "rawCode": "  /**\n   * Save a lock pattern.\n   *\n   * @param pattern The new pattern to save.\n   * @param isFallback Specifies if this is a fallback to biometric weak\n   */\n  public void saveLockPattern(List<LockPatternView.Cell> pattern, boolean isFallback) {\n    // Compute the hash\n    final byte[] hash = LockPatternUtils.patternToHash(pattern);\n    try {\n      // Write the hash to file\n      RandomAccessFile raf = new RandomAccessFile(sLockPatternFilename, \"rw\");\n      // Truncate the file if pattern is null, to clear the lock\n      if (pattern == null) {\n        raf.setLength(0);\n      } else {\n        raf.write(hash, 0, hash.length);\n      }\n      raf.close();\n      DevicePolicyManager dpm = getDevicePolicyManager();\n      KeyStore keyStore = KeyStore.getInstance();\n      if (pattern != null) {\n        keyStore.password(patternToString(pattern));\n        setBoolean(PATTERN_EVER_CHOSEN_KEY, true);\n        if (!isFallback) {\n          deleteGallery();\n          setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);\n          dpm.setActivePasswordState(\n              DevicePolicyManager.PASSWORD_QUALITY_SOMETHING, pattern.size(), 0, 0, 0, 0, 0, 0);\n        } else {\n          setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK);\n          setLong(PASSWORD_TYPE_ALTERNATE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);\n          finishBiometricWeak();\n          dpm.setActivePasswordState(\n              DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK, 0, 0, 0, 0, 0, 0, 0);\n        }\n      } else {\n        if (keyStore.isEmpty()) {\n          keyStore.reset();\n        }\n        dpm.setActivePasswordState(\n            DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED, 0, 0, 0, 0, 0, 0, 0);\n      }\n    } catch (FileNotFoundException fnfe) {\n      // Cant do much, unless we want to fail over to using the settings\n      // provider\n      Log.e(TAG, \"Unable to save lock pattern to \" + sLockPatternFilename);\n    } catch (IOException ioe) {\n      // Cant do much\n      Log.e(TAG, \"Unable to save lock pattern to \" + sLockPatternFilename);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6896, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [683], "configurationEnd": [697], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b,off,len)", "focalAPIStart": 703, "focalAPIEnd": 763, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/camptocamp/secureOWS/tree/master/owsproxyserver/src/org/deegree/io/shpapi/FileHeader.java", "rawCode": "  /**\n   * method: writeHeader()<br>\n   * Writes a blank header into the shape file.<br>\n   */\n  public void writeHeader() throws IOException {\n\n    header = new byte[ShapeConst.SHAPE_FILE_HEADER_LENGTH];\n\n    ByteUtils.writeBEInt(header, 0, ShapeConst.SHAPE_FILE_CODE);\n    ByteUtils.writeBEInt(header, 24, 50);\n\n    // empty shape file size in 16 bit words\n    ByteUtils.writeLEInt(header, 28, ShapeConst.SHAPE_FILE_VERSION);\n    ByteUtils.writeLEInt(header, 32, ShapeConst.SHAPE_TYPE_NULL);\n    ByteUtils.writeLEDouble(header, 36, 0.0);\n    ByteUtils.writeLEDouble(header, 44, 0.0);\n    ByteUtils.writeLEDouble(header, 52, 0.0);\n    ByteUtils.writeLEDouble(header, 60, 0.0);\n\n    rafShp.seek(0);\n    rafShp.write(header, 0, ShapeConst.SHAPE_FILE_HEADER_LENGTH);\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6897, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 122, "focalAPIEnd": 134, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arjunroy/cinder_base/tree/master/awt/javax/imageio/stream/FileCacheImageOutputStream.java", "rawCode": "  @Override\n  public void write(int b) throws IOException {\n    flushBits(); // See the flushBits method description\n\n    raf.write(b);\n    streamPos++;\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6898, "initialization": ["byte[] b = ByteArrayOutputStream.toByteArray()"], "initializationStart": [401], "initializationEnd": [421], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(int)"], "configurationStart": [877], "configurationEnd": [920], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 1105, "focalAPIEnd": 1135, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/jcaptcha-trunk/tree/master/extension-buffered-engine/src/main/java/com/octo/captcha/engine/bufferedengine/buffer/DiskCaptchaBuffer.java", "rawCode": "  /** Puts items into the store. */\n  protected synchronized void store(Object element, Locale locale) throws IOException {\n    if (!isInitalized) return;\n    // Serialise the entry\n    final ByteArrayOutputStream outstr = new ByteArrayOutputStream();\n    final ObjectOutputStream objstr = new ObjectOutputStream(outstr);\n    objstr.writeObject(element);\n    objstr.close();\n    final byte[] buffer = outstr.toByteArray();\n\n    // check if there is space\n    // if (diskElements.size() >= maxDataSize)\n    // {\n    // return false;\n    // }\n\n    // Check for a free block\n    DiskElement diskElement = findFreeBlock(buffer.length);\n    if (diskElement == null) {\n      diskElement = new DiskElement();\n      diskElement.position = randomAccessFile.length();\n      diskElement.blockSize = buffer.length;\n    }\n\n    // TODO - cleanup block on failure\n    // Write the record\n    randomAccessFile.seek(diskElement.position);\n\n    // TODO the free block algorithm will gradually leak disk space, due to\n    // payload size being less than block size\n    // this will be a problem for the persistent cache\n    randomAccessFile.write(buffer);\n\n    // Add to index, update stats\n    diskElement.payloadSize = buffer.length;\n    totalSize += buffer.length;\n\n    // create the localized buffer\n    if (!diskElements.containsKey(locale)) {\n\n      diskElements.put(locale, new LinkedList());\n    }\n    ((LinkedList) diskElements.get(locale)).addLast(diskElement);\n\n    if (log.isDebugEnabled()) {\n      long menUsed = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n      log.debug(\n          \"Store \"\n              + locale.toString()\n              + \" on object, total size : \"\n              + size()\n              + \" Total unsed elements : \"\n              + freeSpace.size()\n              + \" memory used \"\n              + menUsed);\n    }\n  }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6899, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["randomAccessFile.seek(long)"], "configurationStart": [55], "configurationEnd": [71], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 177, "focalAPIEnd": 197, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["randomAccessFile.write(byte[])"], "useStart": [294], "useEnd": [318], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/visad/visad/tree/master/deps/src/ucar/netcdf/NetcdfFile.java", "rawCode": "    void fillO(long offset) throws IOException {\n      raf.seek(offset);\n      int remainder = vsize;\n      for (; remainder >= fillbytes.length; remainder -= fillbytes.length) raf.write(fillbytes);\n      // handle any remainder;\n      if (remainder > 0) for (int ii = 0; ii < remainder; ii++) raf.write(fillbytes[ii]);\n    }\n"}, {"dataset": "randomAccessFileWrite", "exampleID": 6900, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": " = randomAccessFile.write(b)", "focalAPIStart": 817, "focalAPIEnd": 834, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["RandomAccessFile.close()"], "finallyExpressionStart": 2062, "finallyExpressionEnd": 2070, "finallyBlockStart": 2062, "finallyBlockEnd": 2117, "cleanUpCallStart": [2086], "cleanUpCallEnd": [2102], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/TestReplication.java", "rawCode": "  @Test\n  public void testPendingReplicationRetry() throws IOException {\n\n    MiniDFSCluster cluster = null;\n    int numDataNodes = 4;\n    String testFile = \"/replication-test-file\";\n    Path testPath = new Path(testFile);\n\n    byte buffer[] = new byte[1024];\n    for (int i = 0; i < buffer.length; i++) {\n      buffer[i] = '1';\n    }\n\n    try {\n      Configuration conf = new HdfsConfiguration();\n      conf.set(DFSConfigKeys.DFS_REPLICATION_KEY, Integer.toString(numDataNodes));\n      // first time format\n      cluster = new MiniDFSCluster.Builder(conf).numDataNodes(numDataNodes).build();\n      cluster.waitActive();\n      DFSClient dfsClient =\n          new DFSClient(new InetSocketAddress(\"localhost\", cluster.getNameNodePort()), conf);\n\n      OutputStream out = cluster.getFileSystem().create(testPath);\n      out.write(buffer);\n      out.close();\n\n      waitForBlockReplication(testFile, dfsClient.getNamenode(), numDataNodes, -1);\n\n      // get first block of the file.\n      ExtendedBlock block =\n          dfsClient.getNamenode().getBlockLocations(testFile, 0, Long.MAX_VALUE).get(0).getBlock();\n\n      cluster.shutdown();\n      cluster = null;\n\n      for (int i = 0; i < 25; i++) {\n        buffer[i] = '0';\n      }\n\n      int fileCount = 0;\n      // Choose 3 copies of block file - delete 1 and corrupt the remaining 2\n      for (int dnIndex = 0; dnIndex < 3; dnIndex++) {\n        File blockFile = MiniDFSCluster.getBlockFile(dnIndex, block);\n        LOG.info(\"Checking for file \" + blockFile);\n\n        if (blockFile != null && blockFile.exists()) {\n          if (fileCount == 0) {\n            LOG.info(\"Deleting file \" + blockFile);\n            assertTrue(blockFile.delete());\n          } else {\n            // corrupt it.\n            LOG.info(\"Corrupting file \" + blockFile);\n            long len = blockFile.length();\n            assertTrue(len > 50);\n            RandomAccessFile blockOut = new RandomAccessFile(blockFile, \"rw\");\n            try {\n              blockOut.seek(len / 3);\n              blockOut.write(buffer, 0, 25);\n            } finally {\n              blockOut.close();\n            }\n          }\n          fileCount++;\n        }\n      }\n      assertEquals(3, fileCount);\n\n      /* Start the MiniDFSCluster with more datanodes since once a writeBlock\n       * to a datanode node fails, same block can not be written to it\n       * immediately. In our case some replication attempts will fail.\n       */\n\n      LOG.info(\"Restarting minicluster after deleting a replica and corrupting 2 crcs\");\n      conf = new HdfsConfiguration();\n      conf.set(DFSConfigKeys.DFS_REPLICATION_KEY, Integer.toString(numDataNodes));\n      conf.set(DFSConfigKeys.DFS_NAMENODE_REPLICATION_PENDING_TIMEOUT_SEC_KEY, Integer.toString(2));\n      conf.set(\"dfs.datanode.block.write.timeout.sec\", Integer.toString(5));\n      conf.set(\n          DFSConfigKeys.DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY, \"0.75f\"); // only 3 copies exist\n\n      cluster =\n          new MiniDFSCluster.Builder(conf).numDataNodes(numDataNodes * 2).format(false).build();\n      cluster.waitActive();\n\n      dfsClient =\n          new DFSClient(new InetSocketAddress(\"localhost\", cluster.getNameNodePort()), conf);\n\n      waitForBlockReplication(testFile, dfsClient.getNamenode(), numDataNodes, -1);\n\n    } finally {\n      if (cluster != null) {\n        cluster.shutdown();\n      }\n    }\n  }\n"}]