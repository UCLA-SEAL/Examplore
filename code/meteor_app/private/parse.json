[{"dataset": "parse", "exampleID": 7701, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 101, "tryExpressionEnd": 105, "tryBlockStart": 101, "tryBlockEnd": 251, "catchExpressionStart": 151, "catchExpressionEnd": 176, "catchBlockStart": 151, "catchBlockEnd": 251, "exceptionHandlingCallStart": [225], "exceptionHandlingCallEnd": [244], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 122, "focalAPIEnd": 143, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dateTime.getDate()", "dateTime.getMonth()", "dateTime.getYear()"], "useStart": [296, 335, 378], "useEnd": [312, 352, 394], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jenniferk89/cs424project3g1/tree/master/src/GUI/MainSketch.java", "rawCode": "  @SuppressWarnings(\"deprecation\")\n  public void Start(String theText) {\n    Date result = null;\n    try {\n      result = format.parse(theText);\n    } catch (ParseException e) {\n      // TODO Auto-generated catch block\n      e.printStackTrace();\n    }\n    // println(theText);\n    startDateDay = result.getDate();\n    startDateMonth = result.getMonth() + 1;\n    startDateYear = result.getYear() + 1900;\n  }\n"}, {"dataset": "parse", "exampleID": 7702, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new ConversionException(String,*)"], "tryExpressionStart": 134, "tryExpressionEnd": 138, "tryBlockStart": 134, "tryBlockEnd": 278, "catchExpressionStart": 190, "catchExpressionEnd": 215, "catchBlockStart": 190, "catchBlockEnd": 278, "exceptionHandlingCallStart": [231], "exceptionHandlingCallEnd": [269], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(the_text==null)", "guardType": "IF {", "guardExpressionStart": 79, "guardExpressionEnd": 93, "guardBlockStart": 79, "guardBlockEnd": 284, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 155, "focalAPIEnd": 180, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/stemey/atem.utility.github.com/tree/master/src/main/java/org/atemsource/atem/utility/transform/impl/converter/DateConverter.java", "rawCode": "  @Override\n  public Date convertBA(String b, TransformationContext ctx) {\n    if (b == null) {\n      return null;\n    } else {\n      try {\n        return simpleDateFormat.parse(b);\n      } catch (ParseException e) {\n        throw new ConversionException(b, Date.class);\n      }\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7703, "initialization": ["String the_text = Node.getNodeValue()", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [425, 490], "initializationEnd": [451, 520], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["warn(*,String)"], "tryExpressionStart": 129, "tryExpressionEnd": 133, "tryBlockStart": 129, "tryBlockEnd": 763, "catchExpressionStart": 580, "catchExpressionEnd": 606, "catchBlockStart": 580, "catchBlockEnd": 666, "exceptionHandlingCallStart": [616], "exceptionHandlingCallEnd": [657], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 540, "focalAPIEnd": 570, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wtsi-npg/illumina2bam/tree/master/src/uk/ac/sanger/npg/illumina/Lane.java", "rawCode": "  /** @return run date */\n  public Date readRunDate() {\n\n    Date runDate = null;\n    if (this.runConfigXmlNode != null) {\n      try {\n        XPathExpression exprRunDate = xpath.compile(\"RunParameters/RunFolderDate/text()\");\n        Node runDateNode = (Node) exprRunDate.evaluate(this.runConfigXmlNode, XPathConstants.NODE);\n        if (runDateNode == null) {\n          return null;\n        }\n        String runDateString = runDateNode.getNodeValue();\n        SimpleDateFormat formatter = new SimpleDateFormat(\"yyMMdd\");\n        runDate = formatter.parse(runDateString);\n      } catch (ParseException ex) {\n        log.warn(ex, \"Problems parsing run date\");\n      } catch (XPathExpressionException ex) {\n        log.warn(ex, \"Problems reading run date\");\n      }\n    }\n\n    return runDate;\n  }\n"}, {"dataset": "parse", "exampleID": 7704, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [175], "initializationEnd": [217], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 234, "focalAPIEnd": 278, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setCurrentTime(dateTime)", "simpleDateFormat.parse(String)"], "useStart": [284, 409], "useEnd": [313, 453], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/1and1/Activiti-internal/tree/master/modules/activiti-engine/src/test/java/org/activiti/standalone/calendar/DurationBusinessCalendarTest.java", "rawCode": "  public void testSimpleDuration() throws Exception {\n    DurationBusinessCalendar businessCalendar = new DurationBusinessCalendar();\n\n    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy MM dd - HH:mm\");\n    Date now = simpleDateFormat.parse(\"2010 06 11 - 17:23\");\n    ClockUtil.setCurrentTime(now);\n\n    Date duedate = businessCalendar.resolveDuedate(\"P2DT5H70M\");\n\n    Date expectedDuedate = simpleDateFormat.parse(\"2010 06 13 - 23:33\");\n\n    assertEquals(expectedDuedate, duedate);\n  }\n"}, {"dataset": "parse", "exampleID": 7705, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["e(String,String,*)"], "tryExpressionStart": 51, "tryExpressionEnd": 55, "tryBlockStart": 51, "tryBlockEnd": 239, "catchExpressionStart": 157, "catchExpressionEnd": 178, "catchBlockStart": 157, "catchBlockEnd": 239, "exceptionHandlingCallStart": [186], "exceptionHandlingCallEnd": [232], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 73, "focalAPIEnd": 105, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["DateFormat.format(dateTime)"], "useStart": [120], "useEnd": [149], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arhughes/droidchatty/tree/master/src/cc/hughes/droidchatty/ShackApi.java", "rawCode": "  static String convertTime(String original) {\n    try {\n      Date dt = _shackDateFormat.parse(original);\n      return _displayDateFormat.format(dt);\n    } catch (Exception ex) {\n      Log.e(\"DroidChatty\", \"Error parsing date\", ex);\n    }\n\n    return original;\n  }\n"}, {"dataset": "parse", "exampleID": 7706, "initialization": ["ParsePosition position = new ParsePosition(int)"], "initializationStart": [467], "initializationEnd": [487], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(the_text==null)", "guardType": "IF {", "guardExpressionStart": 403, "guardExpressionEnd": 430, "guardBlockStart": 403, "guardBlockEnd": 441, "focalAPI": "dateTime = simpleDateFormat.parse(the_text,position)", "focalAPIStart": 521, "focalAPIEnd": 558, "followUpCheck": "dateTime == null", "checkType": "IF", "followUpCheckExpressionStart": 566, "followUpCheckExpressionEnd": 587, "followUpCheckBlockStart": 566, "followUpCheckBlockEnd": 598, "use": ["dateTime.getTime()"], "useStart": [612], "useEnd": [630], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/kitkatandroid/JLS36G_base/tree/master/media/java/android/media/ExifInterface.java", "rawCode": "  /**\n   * Returns number of milliseconds since Jan. 1, 1970, midnight UTC. Returns -1 if the date time\n   * information if not available.\n   *\n   * @hide\n   */\n  public long getGpsDateTime() {\n    String date = mAttributes.get(TAG_GPS_DATESTAMP);\n    String time = mAttributes.get(TAG_GPS_TIMESTAMP);\n    if (date == null || time == null) return -1;\n\n    String dateTimeString = date + ' ' + time;\n    if (dateTimeString == null) return -1;\n\n    ParsePosition pos = new ParsePosition(0);\n    try {\n      Date datetime = sFormatter.parse(dateTimeString, pos);\n      if (datetime == null) return -1;\n      return datetime.getTime();\n    } catch (IllegalArgumentException ex) {\n      return -1;\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7707, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 89, "focalAPIEnd": 157, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/vifl1011/swa/tree/master/shop/src/main/java/de/shop/bestellverwaltung/domain/Lieferung.java", "rawCode": "  public void setVersanddatumStr(String date) throws ParseException {\n    versanddatum = new SimpleDateFormat(DATE_PATTERNS, Locale.getDefault()).parse(date);\n  }\n"}, {"dataset": "parse", "exampleID": 7708, "initialization": ["String the_text = substring(int,*)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [295, 410], "initializationEnd": [333, 442], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 455, "focalAPIEnd": 485, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jonnyzzz/maragogype/tree/master/tags/v1.7.2/java/com/xerox/amazonws/simpledb/DataUtils.java", "rawCode": "  /**\n   * Decodes date value from the string representation created using encodeDate(..) function.\n   *\n   * @param value string representation of the date value\n   * @return original date value\n   */\n  public static Date decodeDate(String value) throws ParseException {\n    String javaValue = value.substring(0, value.length() - 3) + value.substring(value.length() - 2);\n    SimpleDateFormat dateFormatter = new SimpleDateFormat(dateFormat);\n    return dateFormatter.parse(javaValue);\n  }\n"}, {"dataset": "parse", "exampleID": 7709, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [293], "initializationEnd": [326], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 333, "tryExpressionEnd": 337, "tryBlockStart": 333, "tryBlockEnd": 648, "catchExpressionStart": 570, "catchExpressionEnd": 595, "catchBlockStart": 570, "catchBlockEnd": 648, "exceptionHandlingCallStart": [603], "exceptionHandlingCallEnd": [622], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 359, "focalAPIEnd": 379, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.parse(String)", "MetricasBO.listFileBancoDadosColeta(Integer,dateTime,Date)"], "useStart": [398, 489], "useEnd": [415, 540], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/felipe-vieira/efw-monitoring/tree/master/ServerRest/src/br/com/fiap/monitor/rest/BancoFilesColetasRest.java", "rawCode": "  @GET\n  @Produces(MediaType.APPLICATION_JSON)\n  @Consumes(MediaType.APPLICATION_JSON)\n  public List<MetricaTO> listaMetricas(\n      @QueryParam(\"idArquivo\") Integer idArquivo,\n      @QueryParam(\"inicio\") String strInicio,\n      @QueryParam(\"fim\") String strFim) {\n\n    SimpleDateFormat sdf = new SimpleDateFormat(\"d/M/y H:m\");\n\n    try {\n      Date inicio = sdf.parse(strInicio);\n      Date fim = sdf.parse(strFim);\n\n      MetricasBO bo = new MetricasBO();\n\n      List<MetricaTO> lista = bo.listFileBancoDadosColeta(idArquivo, inicio, fim);\n\n      return lista;\n\n    } catch (ParseException e) {\n      e.printStackTrace();\n      return null;\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7710, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getStackTraceString(*)", "lanzarDialogoError(*,String,*)"], "tryExpressionStart": 41, "tryExpressionEnd": 45, "tryBlockStart": 41, "tryBlockEnd": 303, "catchExpressionStart": 93, "catchExpressionEnd": 113, "catchBlockStart": 93, "catchBlockEnd": 303, "exceptionHandlingCallStart": [243, 121], "exceptionHandlingCallEnd": [295, 296], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 70, "focalAPIEnd": 84, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setDate(dateTime)"], "useStart": [53], "useEnd": [85], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Phesus/Omoikane/tree/master/main/src/omoikane/formularios/VentasDetalles.java", "rawCode": "  public void setFecha(String val) {\n    try {\n      txtFecha.setDate(sdf.parse(val));\n    } catch (Exception e) {\n      omoikane.sistema.Dialogos.lanzarDialogoError(\n          null,\n          \"Error en el registro: Fecha inválida\",\n          omoikane.sistema.Herramientas.getStackTraceString(e));\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7711, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [103], "initializationEnd": [144], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new IllegalArgumentException(String)"], "tryExpressionStart": 65, "tryExpressionEnd": 69, "tryBlockStart": 65, "tryBlockEnd": 358, "catchExpressionStart": 247, "catchExpressionEnd": 272, "catchBlockStart": 247, "catchBlockEnd": 358, "exceptionHandlingCallStart": [286], "exceptionHandlingCallEnd": [351], "configuration": ["simpleDateFormat.setTimeZone(TimeZone)"], "configurationStart": [152], "configurationEnd": [199], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 214, "focalAPIEnd": 239, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/duraspace/dfr/tree/master/dfr-ocs/src/main/java/org/duraspace/dfr/ocs/simpleproc/SimpleProcessor.java", "rawCode": "  private static Date parseISO8601Date(String contentDate) {\n    try {\n      SimpleDateFormat format = new SimpleDateFormat(ISO8601_DATE_FORMAT);\n      format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n      return format.parse(contentDate);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Date is malformed: \" + contentDate);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7712, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 341, "focalAPIEnd": 395, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dianping/cat/tree/master/cat-home/src/test/java/com/dianping/cat/report/task/utilization/UtilizationBuilderTest.java", "rawCode": "  @Test\n  public void testHourlyReport() throws Exception {\n    UtilizationReportBuilder builder = lookup(UtilizationReportBuilder.class);\n    HostinfoService hostinfoService = lookup(HostinfoService.class);\n\n    hostinfoService.initialize();\n    builder.buildHourlyTask(\n        Constants.REPORT_UTILIZATION,\n        Constants.CAT,\n        new SimpleDateFormat(\"yyyyMMddHH\").parse(\"2013082617\"));\n  }\n"}, {"dataset": "parse", "exampleID": 7713, "initialization": ["String the_text = XmlPullParser.nextText()"], "initializationStart": [515], "initializationEnd": [532], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 653, "focalAPIEnd": 688, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new OccupantInfo(String,String,dateTime)"], "useStart": [840], "useEnd": [879], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joshlong/si-extensions-testbed/tree/master/sesia_smack_jabber_api_3_1_0/src/main/java/org/jivesoftware/smackx/workgroup/packet/OccupantsInfo.java", "rawCode": "    private OccupantInfo parseOccupantInfo(XmlPullParser parser) throws Exception {\n\n      boolean done = false;\n      String jid = null;\n      String nickname = null;\n      Date joined = null;\n      while (!done) {\n        int eventType = parser.next();\n        if ((eventType == XmlPullParser.START_TAG) && (\"jid\".equals(parser.getName()))) {\n          jid = parser.nextText();\n        } else if ((eventType == XmlPullParser.START_TAG)\n            && (\"nickname\".equals(parser.getName()))) {\n          nickname = parser.nextText();\n        } else if ((eventType == XmlPullParser.START_TAG) && (\"joined\".equals(parser.getName()))) {\n          joined = UTC_FORMAT.parse(parser.nextText());\n        } else if (eventType == XmlPullParser.END_TAG && \"occupant\".equals(parser.getName())) {\n          done = true;\n        }\n      }\n      return new OccupantInfo(jid, nickname, joined);\n    }\n"}, {"dataset": "parse", "exampleID": 7714, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 593, "tryExpressionEnd": 597, "tryBlockStart": 593, "tryBlockEnd": 755, "catchExpressionStart": 663, "catchExpressionEnd": 689, "catchBlockStart": 663, "catchBlockEnd": 755, "exceptionHandlingCallStart": [701], "exceptionHandlingCallEnd": [721], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(the_text.equalsIgnoreCase(NULL_VALUE,))", "guardType": "IF {", "guardExpressionStart": 72, "guardExpressionEnd": 107, "guardBlockStart": 72, "guardBlockEnd": 120, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 616, "focalAPIEnd": 651, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/posttool/PSWebV1.0/tree/master/src/com/pagesociety/web/module/dump/ExcelDumpModule.java", "rawCode": "  private Object parse_simple_value(FieldDefinition f, String s) {\n\n    if (s.equalsIgnoreCase(NULL_VALUE)) return null;\n    switch (f.getBaseType()) {\n      case Types.TYPE_BOOLEAN:\n        return Boolean.parseBoolean(s);\n      case Types.TYPE_LONG:\n        return Long.parseLong(s);\n      case Types.TYPE_INT:\n        return Integer.parseInt(s);\n      case Types.TYPE_DOUBLE:\n        return Double.parseDouble(s);\n      case Types.TYPE_FLOAT:\n        return Float.parseFloat(s);\n      case Types.TYPE_STRING:\n      case Types.TYPE_TEXT:\n        return s;\n      case Types.TYPE_DATE:\n        try {\n          return spreadsheet_date_formatter.parse(s);\n        } catch (ParseException e1) {\n          e1.printStackTrace();\n          return null;\n        }\n      case Types.TYPE_BLOB:\n        return Byte.parseByte(s);\n      case Types.TYPE_REFERENCE:\n        Entity e = new Entity();\n        String[] type_id = s.split(\":\");\n        e.setType(type_id[0]);\n        e.setId(Long.parseLong(type_id[1]));\n        return e;\n      default:\n        return s;\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7715, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [162, 292], "initializationEnd": [205, 332], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new UnsupportedOperationException(String)"], "tryExpressionStart": 464, "tryExpressionEnd": 468, "tryBlockStart": 464, "tryBlockEnd": 592, "catchExpressionStart": 510, "catchExpressionEnd": 535, "catchBlockStart": 510, "catchBlockEnd": 592, "exceptionHandlingCallStart": [549], "exceptionHandlingCallEnd": [585], "configuration": ["simpleDateFormat.setTimeZone(TimeZone)"], "configurationStart": [407], "configurationEnd": [458], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 483, "focalAPIEnd": 502, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/trunk/src/net/sourceforge/plantuml/acearth/PSystemXearth.java", "rawCode": "  private Date extractGmt(String s) {\n    final SimpleDateFormat timeFormat;\n    if (s.matches(\"\\\\d{4}/\\\\d{2}/\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2}\")) {\n      timeFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n    } else if (s.matches(\"\\\\d{4}/\\\\d{2}/\\\\d{2} \\\\d{2}:\\\\d{2}\")) {\n      timeFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm\");\n    } else {\n      throw new UnsupportedOperationException(s);\n    }\n    timeFormat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    try {\n      return timeFormat.parse(s);\n    } catch (ParseException e) {\n      throw new UnsupportedOperationException(s);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7716, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 430, "focalAPIEnd": 502, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/1and1/Activiti-internal/tree/master/modules/activiti-engine/src/test/java/org/activiti/engine/test/history/HistoricTaskInstanceTest.java", "rawCode": "  @Deployment\n  public void testHistoricTaskInstanceQuery() throws Exception {\n    // First instance is finished\n    ProcessInstance finishedInstance =\n        runtimeService.startProcessInstanceByKey(\"HistoricTaskQueryTest\");\n\n    // Set priority to non-default value\n    Task task =\n        taskService.createTaskQuery().processInstanceId(finishedInstance.getId()).singleResult();\n    task.setPriority(1234);\n    Date dueDate = new SimpleDateFormat(\"dd/MM/yyyy hh:mm:ss\").parse(\"01/02/2003 04:05:06\");\n    task.setDueDate(dueDate);\n\n    taskService.saveTask(task);\n\n    // Complete the task\n    String taskId = task.getId();\n    taskService.complete(taskId);\n\n    // Task id\n    assertEquals(1, historyService.createHistoricTaskInstanceQuery().taskId(taskId).count());\n    assertEquals(\n        0, historyService.createHistoricTaskInstanceQuery().taskId(\"unexistingtaskid\").count());\n\n    // Name\n    assertEquals(1, historyService.createHistoricTaskInstanceQuery().taskName(\"Clean up\").count());\n    assertEquals(\n        0, historyService.createHistoricTaskInstanceQuery().taskName(\"unexistingname\").count());\n    assertEquals(\n        1, historyService.createHistoricTaskInstanceQuery().taskNameLike(\"Clean u%\").count());\n    assertEquals(\n        1, historyService.createHistoricTaskInstanceQuery().taskNameLike(\"%lean up\").count());\n    assertEquals(\n        1, historyService.createHistoricTaskInstanceQuery().taskNameLike(\"%lean u%\").count());\n    assertEquals(\n        0,\n        historyService.createHistoricTaskInstanceQuery().taskNameLike(\"%unexistingname%\").count());\n\n    // Description\n    assertEquals(\n        1,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDescription(\"Historic task description\")\n            .count());\n    assertEquals(\n        0,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDescription(\"unexistingdescription\")\n            .count());\n    assertEquals(\n        1,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDescriptionLike(\"%task description\")\n            .count());\n    assertEquals(\n        1,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDescriptionLike(\"Historic task %\")\n            .count());\n    assertEquals(\n        1, historyService.createHistoricTaskInstanceQuery().taskDescriptionLike(\"%task%\").count());\n    assertEquals(\n        0,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDescriptionLike(\"%unexistingdescripton%\")\n            .count());\n\n    // Execution id\n    assertEquals(\n        1,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .executionId(finishedInstance.getId())\n            .count());\n    assertEquals(\n        0,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .executionId(\"unexistingexecution\")\n            .count());\n\n    // Process instance id\n    assertEquals(\n        1,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .processInstanceId(finishedInstance.getId())\n            .count());\n    assertEquals(\n        0,\n        historyService.createHistoricTaskInstanceQuery().processInstanceId(\"unexistingid\").count());\n\n    // Process definition id\n    assertEquals(\n        1,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .processDefinitionId(finishedInstance.getProcessDefinitionId())\n            .count());\n    assertEquals(\n        0,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .processDefinitionId(\"unexistingdefinitionid\")\n            .count());\n\n    // Process definition name\n    assertEquals(\n        1,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .processDefinitionName(\"Historic task query test process\")\n            .count());\n    assertEquals(\n        0,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .processDefinitionName(\"unexistingdefinitionname\")\n            .count());\n\n    // Process definition key\n    assertEquals(\n        1,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .processDefinitionKey(\"HistoricTaskQueryTest\")\n            .count());\n    assertEquals(\n        0,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .processDefinitionKey(\"unexistingdefinitionkey\")\n            .count());\n\n    // Assignee\n    assertEquals(\n        1, historyService.createHistoricTaskInstanceQuery().taskAssignee(\"kermit\").count());\n    assertEquals(\n        0, historyService.createHistoricTaskInstanceQuery().taskAssignee(\"johndoe\").count());\n    assertEquals(\n        1, historyService.createHistoricTaskInstanceQuery().taskAssigneeLike(\"%ermit\").count());\n    assertEquals(\n        1, historyService.createHistoricTaskInstanceQuery().taskAssigneeLike(\"kermi%\").count());\n    assertEquals(\n        1, historyService.createHistoricTaskInstanceQuery().taskAssigneeLike(\"%ermi%\").count());\n    assertEquals(\n        0, historyService.createHistoricTaskInstanceQuery().taskAssigneeLike(\"%johndoe%\").count());\n\n    // Delete reason\n    assertEquals(\n        1,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDeleteReason(TaskEntity.DELETE_REASON_COMPLETED)\n            .count());\n    assertEquals(\n        0, historyService.createHistoricTaskInstanceQuery().taskDeleteReason(\"deleted\").count());\n\n    // Task definition ID\n    assertEquals(\n        1, historyService.createHistoricTaskInstanceQuery().taskDefinitionKey(\"task\").count());\n    assertEquals(\n        0,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDefinitionKey(\"unexistingkey\")\n            .count());\n\n    // Task priority\n    assertEquals(1, historyService.createHistoricTaskInstanceQuery().taskPriority(1234).count());\n    assertEquals(0, historyService.createHistoricTaskInstanceQuery().taskPriority(5678).count());\n\n    // Due date\n    Calendar anHourAgo = Calendar.getInstance();\n    anHourAgo.setTime(dueDate);\n    anHourAgo.add(Calendar.HOUR, -1);\n\n    Calendar anHourLater = Calendar.getInstance();\n    anHourLater.setTime(dueDate);\n    anHourLater.add(Calendar.HOUR, 1);\n\n    assertEquals(1, historyService.createHistoricTaskInstanceQuery().taskDueDate(dueDate).count());\n    assertEquals(\n        0,\n        historyService.createHistoricTaskInstanceQuery().taskDueDate(anHourAgo.getTime()).count());\n    assertEquals(\n        0,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDueDate(anHourLater.getTime())\n            .count());\n\n    // Due date before\n    assertEquals(\n        1,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDueBefore(anHourLater.getTime())\n            .count());\n    assertEquals(\n        0,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDueBefore(anHourAgo.getTime())\n            .count());\n\n    // Due date after\n    assertEquals(\n        1,\n        historyService.createHistoricTaskInstanceQuery().taskDueAfter(anHourAgo.getTime()).count());\n    assertEquals(\n        0,\n        historyService\n            .createHistoricTaskInstanceQuery()\n            .taskDueAfter(anHourLater.getTime())\n            .count());\n\n    // Finished and Unfinished - Add anther other instance that has a running task (unfinished)\n    runtimeService.startProcessInstanceByKey(\"HistoricTaskQueryTest\");\n\n    assertEquals(1, historyService.createHistoricTaskInstanceQuery().finished().count());\n    assertEquals(1, historyService.createHistoricTaskInstanceQuery().unfinished().count());\n  }\n"}, {"dataset": "parse", "exampleID": 7717, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [186], "initializationEnd": [220], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 233, "focalAPIEnd": 248, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hispindia/registration/tree/master/api/src/main/java/org/openmrs/module/registration/util/RegistrationUtils.java", "rawCode": "  /**\n   * Parse Date\n   *\n   * @param date\n   * @return\n   * @throws ParseException\n   */\n  public static Date parseDate(String date) throws ParseException {\n    SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\");\n    return sdf.parse(date);\n  }\n"}, {"dataset": "parse", "exampleID": 7718, "initialization": ["String the_text = readLine(String)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [93, 142], "initializationEnd": [109, 176], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["getName()", "getLogger(*)", "log(*,*,*)"], "tryExpressionStart": 62, "tryExpressionEnd": 66, "tryBlockStart": 62, "tryBlockEnd": 362, "catchExpressionStart": 248, "catchExpressionEnd": 274, "catchBlockStart": 248, "catchBlockEnd": 362, "exceptionHandlingCallStart": [301, 284, 284], "exceptionHandlingCallEnd": [324, 325, 353], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 199, "focalAPIEnd": 216, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ajorgesantosp/EAPLI_PL_2DB/tree/master/eapli.util/src/eapli/util/Console.java", "rawCode": "  public static Date readDate(String prompt) {\n    do {\n      try {\n        String strDate = readLine(prompt);\n\n        SimpleDateFormat df = new SimpleDateFormat(\"dd-MM-yyyy\");\n\n        Date date = df.parse(strDate);\n\n        return date;\n      } catch (ParseException ex) {\n        Logger.getLogger(Console.class.getName()).log(Level.SEVERE, null, ex);\n      }\n    } while (true);\n  }\n"}, {"dataset": "parse", "exampleID": 7719, "initialization": ["String the_text = trim()"], "initializationStart": [297], "initializationEnd": [308], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 343, "focalAPIEnd": 369, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asascience/THREDDS/tree/master/cdm/src/main/java/ucar/nc2/units/DateFormatter.java", "rawCode": "  /**\n   * Parse text in the format \"yyyy-MM-dd\"\n   *\n   * @param text parse this text\n   * @return equivalent Date\n   * @throws java.text.ParseException if not formatted correctly\n   */\n  private Date dateOnlyFormat(String text) throws java.text.ParseException {\n    text = (text == null) ? \"\" : text.trim();\n    dateOnlyFormat();\n    return dateOnlyFormat.parse(text);\n  }\n"}, {"dataset": "parse", "exampleID": 7720, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [397], "initializationEnd": [431], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 454, "focalAPIEnd": 480, "followUpCheck": "dateTime.equals(gc.getTime())", "checkType": "IF", "followUpCheckExpressionStart": 486, "followUpCheckExpressionEnd": 521, "followUpCheckBlockStart": 486, "followUpCheckBlockEnd": 647, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fsteen/monopoly-for-the-gods/tree/master/jfreechart-1.0.14/tests/org/jfree/data/time/junit/DayTests.java", "rawCode": "  /**\n   * Problem for date parsing.\n   *\n   * <p>This test works only correct if the short pattern of the date format is \"dd/MM/yyyy\". If\n   * not, this test will result in a false negative.\n   *\n   * @throws ParseException on parsing errors.\n   */\n  public void testParseDay() throws ParseException {\n    GregorianCalendar gc = new GregorianCalendar(2001, 12, 31);\n    SimpleDateFormat format = new SimpleDateFormat(\"dd/MM/yyyy\");\n    Date reference = format.parse(\"31/12/2001\");\n    if (reference.equals(gc.getTime())) {\n      // test 1...\n      Day d = Day.parseDay(\"31/12/2001\");\n      assertEquals(37256, d.getSerialDate().toSerial());\n    }\n\n    // test 2...\n    Day d = Day.parseDay(\"2001-12-31\");\n    assertEquals(37256, d.getSerialDate().toSerial());\n  }\n"}, {"dataset": "parse", "exampleID": 7721, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 364, "tryExpressionEnd": 368, "tryBlockStart": 364, "tryBlockEnd": 1255, "catchExpressionStart": 1099, "catchExpressionEnd": 1124, "catchBlockStart": 1099, "catchBlockEnd": 1178, "exceptionHandlingCallStart": [1132], "exceptionHandlingCallEnd": [1151], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!((the_text)==null)", "guardType": "IF {", "guardExpressionStart": 376, "guardExpressionEnd": 414, "guardBlockStart": 376, "guardBlockEnd": 536, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 586, "focalAPIEnd": 616, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dateTime.getTime()", "simpleDateFormat.parse(String)", "dateTime.getTime()"], "useStart": [586, 959, 959], "useEnd": [626, 989, 999], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bjpeterdelacruz/HiREAP/tree/master/src/org/wattdepot/hnei/export/Exporter.java", "rawCode": "  /**\n   * Gets a date from the user via the command-line.\n   *\n   * @param br Used to get information from the command-line.\n   * @return True if input is successful, false otherwise.\n   */\n  public boolean getDates(BufferedReader br) {\n    System.out.print(\"Please enter a start date in the format mm/dd/yyyy (e.g. 2/1/2011): \");\n    String command = null;\n\n    try {\n      if ((command = br.readLine()) == null) {\n        System.out.println(\"Error encountered while trying to read in start timestamp.\");\n        return false;\n      }\n      this.startTimestamp = Tstamp.makeTimestamp(this.formatDate.parse(command).getTime());\n      System.out.print(\"Please enter an end date in the format mm/dd/yyyy (e.g. 2/1/2011): \");\n      if ((command = br.readLine()) == null) {\n        System.out.println(\"Error encountered while trying to read in end timestamp.\");\n        return false;\n      }\n      XMLGregorianCalendar timestamp =\n          Tstamp.makeTimestamp(this.formatDate.parse(command).getTime());\n      this.endTimestamp = Tstamp.incrementSeconds(Tstamp.incrementDays(timestamp, 1), -1);\n    } catch (ParseException e) {\n      e.printStackTrace();\n      return false;\n    } catch (IOException e) {\n      e.printStackTrace();\n      return false;\n    }\n    return true;\n  }\n"}, {"dataset": "parse", "exampleID": 7722, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [275], "initializationEnd": [303], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(the_text==null||true)", "guardType": "IF {", "guardExpressionStart": 180, "guardExpressionEnd": 212, "guardBlockStart": 180, "guardBlockEnd": 240, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 350, "focalAPIEnd": 368, "followUpCheck": "!simpleDateFormat.format(dateTime).equals(the_text)", "checkType": "IF", "followUpCheckExpressionStart": 444, "followUpCheckExpressionEnd": 482, "followUpCheckBlockStart": 444, "followUpCheckBlockEnd": 510, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/setvect/LiteratureBoy-Home/tree/master/source/common/com/setvect/common/date/DateUtil.java", "rawCode": "  /**\n   * 날짜 패턴을 검사함\n   *\n   * @param s 날짜 문자열\n   * @param format 검사 패턴 형식 <br>\n   *     예: \"yyyy-MM-dd\"\n   */\n  public static boolean isDatePatten(String s, String format) {\n    if (s == null || format == null) {\n      return false;\n    }\n\n    SimpleDateFormat formatter = new SimpleDateFormat(format);\n    Date date = null;\n    try {\n      date = formatter.parse(s);\n    } catch (java.text.ParseException e) {\n      return false;\n    }\n\n    if (!formatter.format(date).equals(s)) {\n      return false;\n    }\n    return true;\n  }\n"}, {"dataset": "parse", "exampleID": 7723, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [2840], "initializationEnd": [2879], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["Connection.rollback()"], "tryExpressionStart": 726, "tryExpressionEnd": 730, "tryBlockStart": 726, "tryBlockEnd": 5949, "catchExpressionStart": 4670, "catchExpressionEnd": 4691, "catchBlockStart": 4670, "catchBlockEnd": 5347, "exceptionHandlingCallStart": [4713], "exceptionHandlingCallEnd": [4734], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 3034, "focalAPIEnd": 3068, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dateTime.getTime()"], "useStart": [3126], "useEnd": [3144], "hasFinally": 1, "cleanUpCall": ["Connection.close()"], "finallyExpressionStart": 5348, "finallyExpressionEnd": 5356, "finallyBlockStart": 5348, "finallyBlockEnd": 5949, "cleanUpCallStart": [5408], "cleanUpCallEnd": [5426], "url": "https://github.com/caciula/c391/tree/master/PhotoWebApp/WEB-INF/classes/main/web/UploadImage.java", "rawCode": "  /**\n   * Called when the \"Upload\" button is clicked on uploadImage.jsp Uploads an image and stores the\n   * provided image details in the database Upon completion, redirects to viewImage.jsp\n   */\n  public void doPost(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    HttpSession session = request.getSession();\n    String userName = (String) session.getAttribute(\"username\");\n    Integer photoId = null;\n    String subject = null;\n    String place = null;\n    String description = null;\n    String date = null;\n    String time = null;\n    String access = null;\n    BufferedImage img = null;\n    BufferedImage thumbNail = null;\n\n    Connection connection = null;\n    try {\n      connection = DBConnection.createConnection();\n      // Obtain the form info from the request\n      ServletFileUpload upload = new ServletFileUpload();\n      response.setContentType(\"text/plain\");\n      FileItemIterator iterator = upload.getItemIterator(request);\n\n      while (iterator.hasNext()) {\n        FileItemStream item = iterator.next();\n        InputStream stream = item.openStream();\n        // Item is a text input field\n        if (item.isFormField()) {\n          if (item.getFieldName().equals(\"subject\")) {\n            subject = Streams.asString(stream);\n          } else if (item.getFieldName().equals(\"place\")) {\n            place = Streams.asString(stream);\n          } else if (item.getFieldName().equals(\"description\")) {\n            description = Streams.asString(stream);\n          } else if (item.getFieldName().equals(\"access\")) {\n            access = Streams.asString(stream);\n          } else if (item.getFieldName().equals(\"date\")) {\n            date = Streams.asString(stream);\n          } else if (item.getFieldName().equals(\"time\")) {\n            time = Streams.asString(stream);\n          }\n          // Item is the uploaded image\n        } else {\n          img = ImageIO.read(stream);\n          thumbNail = shrink(img, 10);\n        }\n        stream.close();\n      }\n\n      // First, generate a unique photo_id using the SQL sequence\n      Statement statement = connection.createStatement();\n      ResultSet rset1 = statement.executeQuery(\"SELECT pic_id_sequence.nextval from dual\");\n      rset1.next();\n      photoId = rset1.getInt(1);\n\n      // Create a new image record with the provided image details\n      PreparedStatement preparedStatement =\n          connection.prepareStatement(SQLQueries.UPLOAD_IMAGE_DETAILS);\n      preparedStatement.setInt(1, photoId);\n      preparedStatement.setString(2, userName);\n      preparedStatement.setString(3, access);\n      preparedStatement.setString(4, subject);\n      preparedStatement.setString(5, place);\n      // If the date is entered, but the time is not, set the time to noon by default\n      SimpleDateFormat formatter = new SimpleDateFormat(\"dd/MM/yyyy k:mm\");\n      if (date != null && !date.equals(\"\")) {\n        if (time == null || time.equals(\"\")) {\n          time = \"12:00\";\n        }\n        Date dateTime = formatter.parse(date + \" \" + time);\n        preparedStatement.setTimestamp(6, new Timestamp(dateTime.getTime()));\n      } else {\n        if (time == null || time.equals(\"\")) {\n          preparedStatement.setTimestamp(6, null);\n        } else {\n          request.setAttribute(\n              \"errorMessage\", \"A date must be entered when a time is specified. Please try again.\");\n          request.setAttribute(\"errorBackLink\", \"/PhotoWebApp/UploadImage\");\n          request.getRequestDispatcher(\"/Error.jsp\").forward(request, response);\n          return;\n        }\n      }\n      preparedStatement.setString(7, description);\n      preparedStatement.execute();\n\n      // Write both the full image and the thumbnail image\n      PreparedStatement updateStatement =\n          connection.prepareStatement(SQLQueries.SELECT_IMAGE_FOR_UPDATE);\n      updateStatement.setInt(1, photoId);\n      ResultSet rset = updateStatement.executeQuery();\n      rset.next();\n      BLOB fullBlob = ((OracleResultSet) rset).getBLOB(9);\n      BLOB thumbNailBlob = ((OracleResultSet) rset).getBLOB(8);\n      OutputStream fullOutstream = fullBlob.setBinaryStream(0);\n      ImageIO.write(img, \"jpg\", fullOutstream);\n      fullOutstream.close();\n\n      OutputStream thumbnailOutstream = thumbNailBlob.setBinaryStream(0);\n      ImageIO.write(thumbNail, \"jpg\", thumbnailOutstream);\n      thumbnailOutstream.close();\n\n      Statement commitStatement = connection.createStatement();\n      commitStatement.executeQuery(\"commit\");\n\n      // Redirect to the ViewImage servlet to view the uploaded image\n      response.sendRedirect(\"/PhotoWebApp/ViewImage?\" + photoId);\n    } catch (Exception ex) {\n      try {\n        connection.rollback();\n      } catch (Exception rollbackEx) {\n        System.out.println(\"An error occured while rolling back the transaction: \" + rollbackEx);\n      }\n      System.out.println(\"An error occured while uploading a photo: \" + ex);\n      request.setAttribute(\n          \"errorMessage\",\n          \"An error occured while uploading the file. Please ensure a .jpg or .gif file is selected and \"\n              + \"all fields have been entered correctly.\");\n      request.setAttribute(\"errorBackLink\", \"/PhotoWebApp/UploadImage\");\n      request.getRequestDispatcher(\"/Error.jsp\").forward(request, response);\n      return;\n    } finally {\n      // Close the connection\n      try {\n        connection.close();\n      } catch (Exception ex) {\n        System.out.println(\"An error occured while uploading a photo: \" + ex);\n        request.setAttribute(\n            \"errorMessage\",\n            \"An error occured while uploading the file. Please ensure a .jpg or .gif file is selected and \"\n                + \"all fields have been entered correctly.\");\n        request.setAttribute(\"errorBackLink\", \"/PhotoWebApp/UploadImage\");\n        request.getRequestDispatcher(\"/Error.jsp\").forward(request, response);\n        return;\n      }\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7724, "initialization": ["String the_text = getString(String,*,String)"], "initializationStart": [245], "initializationEnd": [290], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["showException(*,*)"], "tryExpressionStart": 41, "tryExpressionEnd": 45, "tryBlockStart": 41, "tryBlockEnd": 1557, "catchExpressionStart": 1479, "catchExpressionEnd": 1499, "catchBlockStart": 1479, "catchBlockEnd": 1557, "exceptionHandlingCallStart": [1507], "exceptionHandlingCallEnd": [1550], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 356, "focalAPIEnd": 378, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pdinc-oss/gitblit/tree/master/src/com/gitblit/client/GitblitManager.java", "rawCode": "  private void loadRegistrations() {\n    try {\n      StoredConfig config = getConfig();\n      Set<String> servers = config.getSubsections(SERVER);\n      for (String server : servers) {\n        Date lastLogin = new Date(0);\n        String date = config.getString(SERVER, server, \"lastLogin\");\n        if (!StringUtils.isEmpty(date)) {\n          lastLogin = dateFormat.parse(date);\n        }\n        String url = config.getString(SERVER, server, \"url\");\n        String account = config.getString(SERVER, server, \"account\");\n        char[] password;\n        String pw = config.getString(SERVER, server, \"password\");\n        if (StringUtils.isEmpty(pw)) {\n          password = new char[0];\n        } else {\n          password = new String(Base64.decode(pw)).toCharArray();\n        }\n        GitblitRegistration reg =\n            new GitblitRegistration(server, url, account, password) {\n              private static final long serialVersionUID = 1L;\n\n              protected void cacheFeeds() {\n                writeFeedCache(this);\n              }\n            };\n        String[] feeds = config.getStringList(SERVER, server, FEED);\n        if (feeds != null) {\n          // deserialize the field definitions\n          for (String definition : feeds) {\n            FeedModel feed = new FeedModel(definition);\n            reg.feeds.add(feed);\n          }\n        }\n        reg.lastLogin = lastLogin;\n        loadFeedCache(reg);\n        registrations.put(reg.name, reg);\n      }\n    } catch (Throwable t) {\n      Utils.showException(GitblitManager.this, t);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7725, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 1837, "focalAPIEnd": 1853, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["println(dateTime)"], "useStart": [1818], "useEnd": [1854], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dendrite/viscosity/tree/master/Uploader/groovy-test/src/com/reversemind/TestString.java", "rawCode": "  public static void main(String... args) throws ParseException {\n    /*\n    50263|200520475|zuluzka1975|Sat Oct 09 18:30:47 MSD 2010||0\n    50264|532794591|bakatnuk|Thu Mar 22 04:11:54 MSK 2012||0\n    50265|111893900|Anastas16|Sat Feb 06 17:12:33 MSK 2010||285\n    50266|232267373|BarbaraKaulitz4|Thu Dec 30 20:51:11 MSK 2010||129\n    50267|448167901|BobiKinta|Tue Dec 27 21:01:39 MSK 2011||1\n    50268|11403012|millosh|Fri Dec 21 15:58:03 MSK 2007||432\n    50269|187984093|Nadya_pavlova|Tue Sep 07 21:06:10 MSD 2010|http://polymedia.ru|155\n    50270|477718116|StasV12|Sun Jan 29 16:56:42 MSK 2012||1\n    50271|155518191|RusGuru|Mon Jun 14 14:39:02 MSD 2010|http://www.rusgu.ru/|1270\n    50272|66161947|sashasoshnikov|Sun Aug 16 22:19:07 MSD 2009|http://vkontakte.ru/sashasoshnikov|52\n\n    */\n\n    String[] strings = {\n      \"50263|200520475|zuluzka1975|Sat Oct 09 18:30:47 MSD 2010||0\",\n      \"50264|532794591|bakatnuk|Thu Mar 22 04:11:54 MSK 2012||0\",\n      \"50265|111893900|Anastas16|Sat Feb 06 17:12:33 MSK 2010||285\",\n      \"50266|232267373|BarbaraKaulitz4|Thu Dec 30 20:51:11 MSK 2010||129\",\n      \"50267|448167901|BobiKinta|Tue Dec 27 21:01:39 MSK 2011||1\",\n      \"50268|11403012|millosh|Fri Dec 21 15:58:03 MSK 2007||432\",\n      \"50269|187984093|Nadya_pavlova|Tue Sep 07 21:06:10 MSD 2010|http://polymedia.ru|155\",\n      \"50270|477718116|StasV12|Sun Jan 29 16:56:42 MSK 2012||1\",\n      \"50271|155518191|RusGuru|Mon Jun 14 14:39:02 MSD 2010|http://www.rusgu.ru/|1270\",\n      \"50272|66161947|sashasoshnikov|Sun Aug 16 22:19:07 MSD 2009|http://vkontakte.ru/sashasoshnikov|52\"\n    };\n\n    for (int i = 0; i < strings.length; i++) {\n      System.out.println(strings[i]);\n    }\n\n    String tmp = strings[0];\n\n    String date = \"Fri Dec 21 15:58:03 MSK 2007\";\n    String date2 = \"Sun Aug 16 22:19:07 MSD 2009\";\n\n    System.out.println(sdf.parse(date2));\n\n    System.out.println(\"\\n\\n\\n\");\n\n    for (int i = 0; i < strings.length; i++) {\n      System.out.println(parse(strings[i]));\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7726, "initialization": ["String the_text = Element.getTextContent()"], "initializationStart": [182], "initializationEnd": [203], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 218, "focalAPIEnd": 233, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Praqma/AbstractVcsApi/tree/master/src/main/java/net/praqma/vcs/persistence/XMLStrategy.java", "rawCode": "  @Override\n  public Date getLastCommitDate(AbstractBranch branch) {\n    try {\n      Element b = getBranch(branch);\n      Element last = getFirstElement(b, \"last\");\n      String d = last.getTextContent();\n      return format.parse(d);\n    } catch (Exception e) {\n      /* The field did not exist, return null */\n      return null;\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7727, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["getName()", "getLogger(*)", "log(*,*,*)"], "tryExpressionStart": 107, "tryExpressionEnd": 111, "tryBlockStart": 107, "tryBlockEnd": 306, "catchExpressionStart": 175, "catchExpressionEnd": 201, "catchBlockStart": 175, "catchBlockEnd": 306, "exceptionHandlingCallStart": [228, 211, 211], "exceptionHandlingCallEnd": [268, 269, 297], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "the_text!=null", "guardType": "IF {", "guardExpressionStart": 80, "guardExpressionEnd": 98, "guardBlockStart": 80, "guardBlockEnd": 312, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 134, "focalAPIEnd": 165, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/I-TECH/OpenEMRConnect/tree/master/CdsTest/src/ke/go/moh/oec/cdstest/NotifyPersonChangedTest2.java", "rawCode": "  private static Date parseDate(String sDate) {\n    Date returnDate = null;\n    if (sDate != null) {\n      try {\n        returnDate = SIMPLE_DATE_FORMAT.parse(sDate);\n      } catch (ParseException ex) {\n        Logger.getLogger(NotifyPersonChangedTest2.class.getName()).log(Level.SEVERE, null, ex);\n      }\n    }\n    return returnDate;\n  }\n"}, {"dataset": "parse", "exampleID": 7728, "initialization": ["String the_text = get(*)"], "initializationStart": [657], "initializationEnd": [672], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["error(String,*)"], "tryExpressionStart": 1671, "tryExpressionEnd": 1675, "tryBlockStart": 1671, "tryBlockEnd": 2178, "catchExpressionStart": 1870, "catchExpressionEnd": 1895, "catchBlockStart": 1870, "catchBlockEnd": 2178, "exceptionHandlingCallStart": [1919], "exceptionHandlingCallEnd": [2155], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "the_text!=null&&!(the_text.isEmpty()) && !(the_text.contains(\"%\",))", "guardType": "IF {", "guardExpressionStart": 810, "guardExpressionEnd": 884, "guardBlockStart": 810, "guardBlockEnd": 2258, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 1821, "focalAPIEnd": 1844, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BlackSharkCZE/q13kamoskal87/tree/master/src/main/java/cz/kamoska/partner/dao/template/DaoTemplate.java", "rawCode": "  private Predicate getPredicate(\n      Root<T> entityRoot,\n      Class rootClass,\n      CriteriaBuilder criteriaBuilder,\n      Map<String, String> filter) {\n    Predicate finalPredicate = null;\n    List<Predicate> predicates = null;\n\n    if (filter != null && !filter.isEmpty()) {\n      predicates = new ArrayList<>(filter.size());\n      for (String key : filter.keySet()) {\n        Field field;\n        try {\n          field = rootClass.getDeclaredField(key);\n        } catch (NoSuchFieldException e) {\n          // takove pole v objektu neni takze pro nej tezko sestavime filter. Vynechame ho.\n          continue;\n        }\n\n        final String value = filter.get(key);\n        if (value != null && !value.isEmpty()) {\n          // v hodnote mame neco ulozene, takze to muzeme pouzit jako filter\n          if (value.contains(\"%\") && field.getType().isAssignableFrom(String.class)) {\n            // hodnota obsahuje procento, takz chceme hledat pres LIKE\n            predicates.add(criteriaBuilder.like(entityRoot.<String>get(key), value));\n          } else {\n            // hodnota neobsahuje procento takze chceme hledat equals\n\n            if (field.getType().isAssignableFrom(String.class)) {\n              predicates.add(criteriaBuilder.equal(entityRoot.<String>get(key), value));\n            } else {\n              if (field.getType().isAssignableFrom(Integer.class)) {\n                predicates.add(\n                    criteriaBuilder.equal(entityRoot.<Integer>get(key), Integer.parseInt(value)));\n              } else {\n                if (field.getType().isAssignableFrom(Date.class)) {\n                  synchronized (dateFormatLock) {\n                    try {\n                      predicates.add(\n                          criteriaBuilder.equal(\n                              entityRoot.<Date>get(key), dateFormat.parse(value)));\n                    } catch (ParseException e) {\n                      logger.error(\n                          \"Can not parse \"\n                              + value\n                              + \" as Date with pattern: \"\n                              + Constants.DATE_FORMAT,\n                          e);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      for (Predicate p : predicates) {\n        if (finalPredicate != null) {\n          finalPredicate = criteriaBuilder.and(finalPredicate, p);\n        } else {\n          finalPredicate = criteriaBuilder.and(p);\n        }\n      }\n    }\n\n    return finalPredicate;\n  }\n"}, {"dataset": "parse", "exampleID": 7729, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [1903], "initializationEnd": [1941], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new Date()"], "tryExpressionStart": 1969, "tryExpressionEnd": 1973, "tryBlockStart": 1969, "tryBlockEnd": 2089, "catchExpressionStart": 2025, "catchExpressionEnd": 2050, "catchBlockStart": 2025, "catchBlockEnd": 2089, "exceptionHandlingCallStart": [2072], "exceptionHandlingCallEnd": [2082], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 1995, "focalAPIEnd": 2017, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dateTime.getTime()", "dateTime.getTime()", "dateTime.getTime()", "dateTime.setTime(*)", "simpleDateFormat.format(Date)", "simpleDateFormat.parse(String)", "simpleDateFormat.format(Date)", "simpleDateFormat.parse(String)", "simpleDateFormat.format(Date)"], "useStart": [2156, 2218, 2305, 2285, 2365, 5172, 5103, 5366, 5297], "useEnd": [2177, 2239, 2326, 2350, 2395, 5213, 5248, 5406, 5441], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ybonnel/ybo-tv-android/tree/master/src/main/java/fr/ybo/ybotv/android/modele/ChannelWithProgramme.java", "rawCode": "  public static List<ChannelWithProgramme> getProgrammesForDate(\n      YboTvApplication application, String date) {\n    YboTvDatabase database = application.getDatabase();\n\n    StringBuilder sqlQuery = new StringBuilder();\n\n    sqlQuery.append(\"SELECT Channel.id as channelId, \");\n    sqlQuery.append(\"Channel.displayName as channelDisplayName, \");\n    sqlQuery.append(\"Channel.icon as channelIcon, \");\n    sqlQuery.append(\"Channel.numero as channelNumero, \");\n    sqlQuery.append(\"Programme.id as programmeId, \");\n    sqlQuery.append(\"Programme.start as programmeStart, \");\n    sqlQuery.append(\"Programme.stop as programmeStop, \");\n    sqlQuery.append(\"Programme.icon as programmeIcon, \");\n    sqlQuery.append(\"Programme.title as programmeTitle, \");\n    sqlQuery.append(\"Programme.desc as programmeDesc, \");\n    sqlQuery.append(\"Programme.starRating as programmeStarRating, \");\n    sqlQuery.append(\"Programme.csaRating as programmeCsaRating, \");\n    sqlQuery.append(\"Programme.directors as programmeDirectors, \");\n    sqlQuery.append(\"Programme.actors as programmeActors, \");\n    sqlQuery.append(\"Programme.writers as programmeWriters, \");\n    sqlQuery.append(\"Programme.presenters as programmePresenters, \");\n    sqlQuery.append(\"Programme.date as programmeDate, \");\n    sqlQuery.append(\"Programme.categories as programmeCategories, \");\n    sqlQuery.append(\"Programme.critique as programmeCritique \");\n\n    sqlQuery.append(\"FROM Channel, Programme, FavoriteChannel \");\n    sqlQuery.append(\"WHERE \");\n    sqlQuery.append(\"Channel.id = Programme.channel \");\n    sqlQuery.append(\"AND Channel.id = FavoriteChannel.channel \");\n    sqlQuery.append(\"AND Programme.start <= :currentDate \");\n    sqlQuery.append(\"AND Programme.stop >= :currentDate \");\n\n    TimeZone currentTimeZone = TimeZone.getDefault();\n    TimeZone frenchTimeZone = TimeZone.getTimeZone(\"Europe/Paris\");\n\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n    Date currentDate;\n    try {\n      currentDate = dateFormat.parse(date);\n    } catch (ParseException e) {\n      currentDate = new Date();\n    }\n\n    int diffToApplyBetweenTZ =\n        currentTimeZone.getOffset(currentDate.getTime())\n            - frenchTimeZone.getOffset(currentDate.getTime());\n    if (diffToApplyBetweenTZ != 0) {\n      currentDate.setTime(currentDate.getTime() + diffToApplyBetweenTZ);\n      date = dateFormat.format(currentDate);\n    }\n\n    List<String> selectionArgs = new ArrayList<String>(1);\n\n    selectionArgs.add(date);\n\n    long startTime = System.nanoTime();\n    Cursor cursor = database.executeSelectQuery(sqlQuery.toString(), selectionArgs);\n\n    int nbResult = cursor.getCount();\n    long elapsedTime = System.nanoTime() - startTime;\n    Log.d(\"YboTv\", \"Requete executee : \" + sqlQuery.toString());\n    Log.d(\"YboTv\", \"Nombre de resultas : \" + nbResult + \" en \" + (elapsedTime / 1000) + \"µs\");\n\n    List<ChannelWithProgramme> channels = new ArrayList<ChannelWithProgramme>();\n\n    int channelIdCol = cursor.getColumnIndex(\"channelId\");\n    int channelDisplayNameCol = cursor.getColumnIndex(\"channelDisplayName\");\n    int channelIconCol = cursor.getColumnIndex(\"channelIcon\");\n    int channelNumeroCol = cursor.getColumnIndex(\"channelNumero\");\n    int programmeIdCol = cursor.getColumnIndex(\"programmeId\");\n    int programmeStartCol = cursor.getColumnIndex(\"programmeStart\");\n    int programmeStopCol = cursor.getColumnIndex(\"programmeStop\");\n    int programmeIconCol = cursor.getColumnIndex(\"programmeIcon\");\n    int programmeTitleCol = cursor.getColumnIndex(\"programmeTitle\");\n    int programmeDescCol = cursor.getColumnIndex(\"programmeDesc\");\n    int programmeStarRatingCol = cursor.getColumnIndex(\"programmeStarRating\");\n    int programmeCsaRatingCol = cursor.getColumnIndex(\"programmeCsaRating\");\n    int programmeDirectorsCol = cursor.getColumnIndex(\"programmeDirectors\");\n    int programmeActorsCol = cursor.getColumnIndex(\"programmeActors\");\n    int programmeWritersCol = cursor.getColumnIndex(\"programmeWriters\");\n    int programmePresentersCol = cursor.getColumnIndex(\"programmePresenters\");\n    int programmeDateCol = cursor.getColumnIndex(\"programmeDate\");\n    int programmeCategoriesCol = cursor.getColumnIndex(\"programmeCategories\");\n    int programmeCritiqueCol = cursor.getColumnIndex(\"programmeCritique\");\n\n    while (cursor.moveToNext()) {\n      ChannelWithProgramme oneChannelWithProgramme = new ChannelWithProgramme();\n\n      Channel oneChannel = new Channel();\n      oneChannel.setId(cursor.getString(channelIdCol));\n      oneChannel.setDisplayName(cursor.getString(channelDisplayNameCol));\n      oneChannel.setIcon(cursor.getString(channelIconCol));\n      oneChannel.setNumero(cursor.getInt(channelNumeroCol));\n      oneChannelWithProgramme.setChannel(oneChannel);\n\n      Programme oneProgramme = new Programme();\n      oneProgramme.setId(cursor.getString(programmeIdCol));\n      oneProgramme.setStart(cursor.getString(programmeStartCol));\n      oneProgramme.setStop(cursor.getString(programmeStopCol));\n      if (diffToApplyBetweenTZ != 0) {\n        try {\n          oneProgramme.setStart(\n              dateFormat.format(\n                  new Date(\n                      dateFormat.parse(oneProgramme.getStart()).getTime() - diffToApplyBetweenTZ)));\n          oneProgramme.setStop(\n              dateFormat.format(\n                  new Date(\n                      dateFormat.parse(oneProgramme.getStop()).getTime() - diffToApplyBetweenTZ)));\n        } catch (ParseException e) {\n          e.printStackTrace();\n        }\n      }\n      oneProgramme.setIcon(cursor.getString(programmeIconCol));\n      oneProgramme.setTitle(cursor.getString(programmeTitleCol));\n      oneProgramme.setDesc(cursor.getString(programmeDescCol));\n      oneProgramme.setCritique(cursor.getString(programmeCritiqueCol));\n      oneProgramme.setStarRating(cursor.getString(programmeStarRatingCol));\n      oneProgramme.setCsaRating(cursor.getString(programmeCsaRatingCol));\n      oneProgramme.setChannel(oneChannel.getId());\n      oneProgramme.fillDirectorsWithDb(cursor.getString(programmeDirectorsCol));\n      oneProgramme.fillActorsWithDb(cursor.getString(programmeActorsCol));\n      oneProgramme.fillWritersWithDb(cursor.getString(programmeWritersCol));\n      oneProgramme.fillPresentersWithDb(cursor.getString(programmePresentersCol));\n      oneProgramme.setDate(cursor.getString(programmeDateCol));\n      oneProgramme.fillCategoriesWithDb(cursor.getString(programmeCategoriesCol));\n\n      oneChannelWithProgramme.setProgramme(oneProgramme);\n\n      channels.add(oneChannelWithProgramme);\n    }\n\n    cursor.close();\n\n    Iterator<ChannelWithProgramme> iterator = channels.iterator();\n    Set<String> channelsAlreadyIn = new HashSet<String>();\n    while (iterator.hasNext()) {\n      ChannelWithProgramme currentChannel = iterator.next();\n      if (channelsAlreadyIn.contains(currentChannel.getChannel().getId())) {\n        iterator.remove();\n      } else {\n        channelsAlreadyIn.add(currentChannel.getChannel().getId());\n      }\n    }\n\n    return channels;\n  }\n"}, {"dataset": "parse", "exampleID": 7730, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [117], "initializationEnd": [158], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 180, "tryExpressionEnd": 184, "tryBlockStart": 180, "tryBlockEnd": 309, "catchExpressionStart": 235, "catchExpressionEnd": 260, "catchBlockStart": 235, "catchBlockEnd": 309, "exceptionHandlingCallStart": [268], "exceptionHandlingCallEnd": [287], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 199, "focalAPIEnd": 227, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DefaultPosition(dateTime)"], "useStart": [352], "useEnd": [377], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/library/cql/src/test/java/org/geotools/filter/text/cql2/FilterCQLSample.java", "rawCode": "  private static Instant dateToInstant(String strDate) throws ParseException {\n\n    SimpleDateFormat dateFormatter = new SimpleDateFormat(DATE_TIME_FORMATTER);\n\n    Date date;\n    try {\n      date = dateFormatter.parse(strDate);\n    } catch (ParseException e) {\n      e.printStackTrace();\n      throw e;\n    }\n\n    Instant instant = new DefaultInstant(new DefaultPosition(date));\n\n    return instant;\n  }\n"}, {"dataset": "parse", "exampleID": 7731, "initialization": ["SimpleDateFormat simpleDateFormat = getDateFormat(String,String,String)"], "initializationStart": [373], "initializationEnd": [412], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["get(*,*,String)"], "tryExpressionStart": 418, "tryExpressionEnd": 422, "tryBlockStart": 418, "tryBlockEnd": 625, "catchExpressionStart": 511, "catchExpressionEnd": 531, "catchBlockStart": 511, "catchBlockEnd": 625, "exceptionHandlingCallStart": [569], "exceptionHandlingCallEnd": [618], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 473, "focalAPIEnd": 495, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/H2-Mirror/tree/master/h2/src/main/org/h2/util/DateTimeUtils.java", "rawCode": "  /**\n   * Parses a date using a format string.\n   *\n   * @param date the date to parse\n   * @param format the parsing format\n   * @param locale the locale\n   * @param timeZone the timeZone\n   * @return the parsed date\n   */\n  public static java.util.Date parseDateTime(\n      String date, String format, String locale, String timeZone) {\n    SimpleDateFormat dateFormat = getDateFormat(format, locale, timeZone);\n    try {\n      synchronized (dateFormat) {\n        return dateFormat.parse(date);\n      }\n    } catch (Exception e) {\n      // ParseException\n      throw DbException.get(ErrorCode.PARSE_ERROR_1, e, date);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7732, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 105, "tryExpressionEnd": 109, "tryBlockStart": 105, "tryBlockEnd": 757, "catchExpressionStart": 698, "catchExpressionEnd": 723, "catchBlockStart": 698, "catchBlockEnd": 757, "exceptionHandlingCallStart": [731], "exceptionHandlingCallEnd": [750], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 130, "focalAPIEnd": 150, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.parse(String)", "buildGraph(dateTime,Date)", "buildGraphDatasForHour(dateTime,Date,String,*,List<Graph>)"], "useStart": [169, 218, 320], "useEnd": [189, 240, 382], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lietou/insight/tree/master/cat-home/src/test/java/com/dianping/cat/report/page/transaction/TransactionGraphDataTest.java", "rawCode": "  @Test\n  public void testBuildGraphDatesByType() {\n    HistoryGraphs handler = new HistoryGraphs();\n    try {\n      Date start = sf.parse(\"20120601\");\n      Date end = sf.parse(\"20120607\");\n      List<Graph> graphs = buildGraph(start, end);\n      String type = \"URL\";\n      Map<String, double[]> graphDates =\n          handler.buildGraphDatasForHour(start, end, type, null, graphs);\n      double[] expectTotalCount = graphDates.get(\"total_count\");\n      double[] expectFailureCount = graphDates.get(\"failure_count\");\n      double[] expectSum = graphDates.get(\"sum\");\n\n      assertArray(15, expectTotalCount);\n      assertArray(0, expectFailureCount);\n      assertArray(234038.7, expectSum);\n    } catch (ParseException e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7733, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(the_text.startsWith(\"log\",))", "guardType": "IF {", "guardExpressionStart": 70, "guardExpressionEnd": 97, "guardBlockStart": 70, "guardBlockEnd": 129, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 203, "focalAPIEnd": 224, "followUpCheck": "dateTime.before(logdate)", "checkType": "IF", "followUpCheckExpressionStart": 297, "followUpCheckExpressionEnd": 333, "followUpCheckBlockStart": 297, "followUpCheckBlockEnd": 478, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/builddoctor/cruisecontrol/tree/master/cruisecontrol/main/src/net/sourceforge/cruisecontrol/logmanipulators/DeleteArtifactsManipulator.java", "rawCode": "    public boolean accept(final File dir, final String name) {\n\n      if (name.startsWith(\"log\")) {\n        return false;\n      }\n\n      final Date artifactDirDate;\n      try {\n        artifactDirDate = FORMATTER.parse(name);\n      } catch (ParseException e) {\n        return false;\n      }\n      if (artifactDirDate.before(logdate)) {\n        final File checkArtifactDir = new File(dir, name);\n        return checkArtifactDir.exists() && checkArtifactDir.isDirectory();\n      }\n      return false;\n    }\n"}, {"dataset": "parse", "exampleID": 7734, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [158], "initializationEnd": [192], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 200, "tryExpressionEnd": 204, "tryBlockStart": 200, "tryBlockEnd": 375, "catchExpressionStart": 269, "catchExpressionEnd": 294, "catchBlockStart": 269, "catchBlockEnd": 375, "exceptionHandlingCallStart": [347], "exceptionHandlingCallEnd": [366], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "the_text.length()==10", "guardType": "IF {", "guardExpressionStart": 91, "guardExpressionEnd": 120, "guardBlockStart": 91, "guardBlockEnd": 468, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 232, "focalAPIEnd": 258, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new DateTime(dateTime)"], "useStart": [219], "useEnd": [259], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/peggyl/hackblue/tree/master/src/extractor/EventExtractor.java", "rawCode": "  private static boolean isToday(String otherDate) {\n    DateTime d1 = new DateTime();\n    if (otherDate.length() == 10) {\n      SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n      try {\n        d1 = new DateTime(formatter.parse(otherDate));\n      } catch (ParseException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n      }\n    } else {\n      d1 = ISODateTimeFormat.dateTimeNoMillis().parseDateTime(otherDate);\n    }\n    DateTime d2 = new DateTime(new Date());\n    return (d1.getDayOfYear() == d2.getDayOfYear() && d1.getYear() == d2.getYear());\n  }\n"}, {"dataset": "parse", "exampleID": 7735, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["toString()", "error(*)", "getInstance()", "getTime()"], "tryExpressionStart": 51, "tryExpressionEnd": 55, "tryBlockStart": 51, "tryBlockEnd": 212, "catchExpressionStart": 97, "catchExpressionEnd": 123, "catchBlockStart": 97, "catchBlockEnd": 212, "exceptionHandlingCallStart": [144, 131, 173, 173], "exceptionHandlingCallEnd": [157, 158, 195, 205], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 70, "focalAPIEnd": 89, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/enina/AdvertManager/tree/master/src/java/com/mne/advertmanager/util/PurchaseOrderImporter.java", "rawCode": "  private Date processTime(String itemValue) {\n    try {\n      return df.parse(itemValue);\n    } catch (ParseException ex) {\n      logger.error(ex.toString());\n      return Calendar.getInstance().getTime();\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7736, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [511], "initializationEnd": [543], "hasTryCatch": 1, "exceptionType": "PlatformException", "exceptionHandlingCall": ["printStackTrace()", "setSuccess(*)", "getMessage()", "setMessage(*)"], "tryExpressionStart": 188, "tryExpressionEnd": 192, "tryBlockStart": 188, "tryBlockEnd": 1134, "catchExpressionStart": 851, "catchExpressionEnd": 879, "catchBlockStart": 851, "catchBlockEnd": 996, "exceptionHandlingCallStart": [887, 914, 974, 955], "exceptionHandlingCallEnd": [906, 947, 988, 989], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 563, "focalAPIEnd": 592, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Calendar.setTime(dateTime)"], "useStart": [650], "useEnd": [672], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eastseven/tsm/tree/master/tsm/src/main/java/com/justinmobile/tsm/application/web/ApplicationVersionController.java", "rawCode": "  @RequestMapping\n  public @ResponseBody JsonMessage subReportFinishTest(\n      HttpServletRequest request, @RequestParam Long appverId) {\n    JsonMessage message = new JsonMessage();\n    try {\n      ApplicationVersionTestReport testReport = new ApplicationVersionTestReport();\n      SpringMVCUtils.bindObject(request, testReport);\n      String year = request.getParameter(\"year\");\n      String month = request.getParameter(\"month\");\n      String day = request.getParameter(\"day\");\n      SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMdd\");\n      Date date = sdf.parse(year + month + day);\n      Calendar calendar = Calendar.getInstance();\n      calendar.setTime(date);\n      testReport.setTestDate(calendar);\n      String subType = request.getParameter(\"subType\");\n      applicationVersionManager.finishTest(testReport, appverId, subType);\n    } catch (PlatformException e) {\n      e.printStackTrace();\n      message.setSuccess(Boolean.FALSE);\n      message.setMessage(e.getMessage());\n    } catch (Exception e) {\n      e.printStackTrace();\n      message.setSuccess(Boolean.FALSE);\n      message.setMessage(e.getMessage());\n    }\n    return message;\n  }\n"}, {"dataset": "parse", "exampleID": 7737, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String,*)", "String the_text = DatabasePDBrev.getDate_original()"], "initializationStart": [188, 475], "initializationEnd": [233, 499], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 446, "tryExpressionEnd": 450, "tryBlockStart": 446, "tryBlockEnd": 883, "catchExpressionStart": 820, "catchExpressionEnd": 845, "catchBlockStart": 820, "catchBlockEnd": 883, "exceptionHandlingCallStart": [855], "exceptionHandlingCallEnd": [874], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 557, "focalAPIEnd": 579, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["PDBHeader.setDepDate(dateTime)", "simpleDateFormat.parse(String)", "simpleDateFormat.parse(String)"], "useStart": [625, 700, 929], "useEnd": [647, 733, 962], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sbliven/biojava/tree/master/biojava3-structure/src/main/java/org/biojava/bio/structure/io/mmcif/SimpleMMcifConsumer.java", "rawCode": "  @SuppressWarnings(\"deprecation\")\n  public void newDatabasePDBrev(DatabasePDBrev dbrev) {\n    // System.out.println(\"got a database revision:\" + dbrev);\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.US);\n    PDBHeader header = structure.getPDBHeader();\n    Map<String, Object> h = structure.getHeader();\n\n    if (header == null) {\n      header = new PDBHeader();\n    }\n\n    if (dbrev.getNum().equals(\"1\")) {\n\n      try {\n\n        String date = dbrev.getDate_original();\n        // System.out.println(date);\n        Date dep = dateFormat.parse(date);\n        // System.out.println(dep);\n        header.setDepDate(dep);\n        h.put(\"depDate\", date);\n        Date mod = dateFormat.parse(dbrev.getDate());\n\n        header.setModDate(mod);\n        h.put(\"revDate\", dbrev.getDate());\n\n      } catch (ParseException e) {\n        e.printStackTrace();\n      }\n    } else {\n      try {\n\n        Date mod = dateFormat.parse(dbrev.getDate());\n        header.setModDate(mod);\n        h.put(\"revDate\", dbrev.getDate());\n\n      } catch (ParseException e) {\n        e.printStackTrace();\n      }\n    }\n\n    structure.setPDBHeader(header);\n  }\n"}, {"dataset": "parse", "exampleID": 7738, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["Logger.error(String)", "new Date()"], "tryExpressionStart": 866, "tryExpressionEnd": 870, "tryBlockStart": 866, "tryBlockEnd": 1092, "catchExpressionStart": 953, "catchExpressionEnd": 978, "catchBlockStart": 953, "catchBlockEnd": 1092, "exceptionHandlingCallStart": [992, 1069], "exceptionHandlingCallEnd": [1036, 1079], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 903, "focalAPIEnd": 939, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["BufferedReader.close()", "InputStream.close()"], "finallyExpressionStart": 1482, "finallyExpressionEnd": 1490, "finallyBlockStart": 1482, "finallyBlockEnd": 1546, "cleanUpCallStart": [1500, 1520], "cleanUpCallEnd": [1510, 1537], "url": "https://github.com/builddoctor/cruisecontrol/tree/master/cruisecontrol/main/src/net/sourceforge/cruisecontrol/sourcecontrols/UCM.java", "rawCode": "  /**\n   * @param activityID stream ID\n   * @param activityDate activity date\n   * @return all the activities on the stream since the last build date\n   */\n  private UCMModification describeActivity(final String activityID, final String activityDate) {\n\n    final UCMModification mod = new UCMModification();\n\n    final Commandline commandLine = buildDescribeActivityCommand(activityID);\n    LOG.debug(\"Executing: \" + commandLine);\n\n    try {\n      commandLine.setWorkingDirectory(viewPath);\n      final InputStream cmdStream = CommandlineUtil.streamOutput(commandLine);\n      final InputStreamReader isr = new InputStreamReader(cmdStream);\n      final BufferedReader br = new BufferedReader(isr);\n      try {\n\n        String line = br.readLine();\n        while ((line != null) && (!line.equals(\"\"))) {\n          final String[] details = getDetails(line);\n          try {\n            mod.modifiedTime = outputDateFormat.parse(activityDate);\n          } catch (ParseException e) {\n            LOG.error(\"Error parsing modification date\");\n            mod.modifiedTime = new Date();\n          }\n          mod.type = \"activity\";\n          // counter for UCM without ClearQuest\n          if (details[0].equals(\"\")) {\n            mod.revision = details[3];\n          } else {\n            mod.revision = details[0];\n          }\n          mod.crmtype = details[1];\n          mod.userName = details[2];\n          mod.comment = details[3];\n\n          line = br.readLine();\n        }\n      } finally {\n        br.close();\n        cmdStream.close();\n      }\n    } catch (IOException e) {\n      LOG.error(\"IO Error executing ClearCase describe command\", e);\n    } catch (CruiseControlException e) {\n      LOG.error(\"Interrupt error executing ClearCase describe command\", e);\n    }\n\n    return mod;\n  }\n"}, {"dataset": "parse", "exampleID": 7739, "initialization": ["String the_text = String.replace(char,char)"], "initializationStart": [481], "initializationEnd": [505], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 566, "tryExpressionEnd": 570, "tryBlockStart": 566, "tryBlockEnd": 706, "catchExpressionStart": 643, "catchExpressionEnd": 668, "catchBlockStart": 643, "catchBlockEnd": 706, "exceptionHandlingCallStart": [678], "exceptionHandlingCallEnd": [697], "configuration": ["the_text.replace(char,char)"], "configurationStart": [481], "configurationEnd": [505], "guardCondition": "!(StringUtils.isBlank(the_text,))", "guardType": "IF {", "guardExpressionStart": 97, "guardExpressionEnd": 129, "guardBlockStart": 97, "guardBlockEnd": 156, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 587, "focalAPIEnd": 633, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/manabone/codemonkey/tree/master/codemonkey-core/src/main/java/com/codemonkey/web/converter/DateConverter.java", "rawCode": "  public Date convert(String source) {\n\n    String dateFormat = null;\n    Date date = null;\n\n    if (StringUtils.isBlank(source)) {\n      return null;\n    }\n\n    if (RegUtils.matches(RegUtils.DATE_REG, source)) {\n      dateFormat = \"yyyy-MM-dd\";\n    } else if (RegUtils.matches(RegUtils.DATE_TIME_REG, source)) {\n      dateFormat = \"yyyy-MM-dd hh:mm:ss\";\n    } else if (RegUtils.matches(RegUtils.T_DATE_TIME_REG, source)) {\n      dateFormat = \"yyyy-MM-dd hh:mm:ss\";\n      source = source.replace('T', ' ');\n    }\n\n    if (StringUtils.isNotBlank(dateFormat)) {\n      try {\n        date = new SimpleDateFormat(dateFormat).parse(source);\n      } catch (ParseException e) {\n        e.printStackTrace();\n      }\n    }\n\n    return date;\n  }\n"}, {"dataset": "parse", "exampleID": 7740, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["error(*)", "new GregorianCalendar()"], "tryExpressionStart": 86, "tryExpressionEnd": 90, "tryBlockStart": 86, "tryBlockEnd": 234, "catchExpressionStart": 141, "catchExpressionEnd": 166, "catchBlockStart": 141, "catchBlockEnd": 234, "exceptionHandlingCallStart": [174, 204], "exceptionHandlingCallEnd": [189, 227], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 111, "focalAPIEnd": 133, "followUpCheck": "dateTime == null", "checkType": "IF", "followUpCheckExpressionStart": 239, "followUpCheckExpressionEnd": 262, "followUpCheckBlockStart": 239, "followUpCheckBlockEnd": 308, "use": ["GregorianCalendar.setTime(dateTime)"], "useStart": [373], "useEnd": [402], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zgorbe/BabaNaplo/tree/master/naplo-webapp/src/main/java/com/zotyo/diary/web/DiaryHelper.java", "rawCode": "  public GregorianCalendar getDayCal(String theDay) {\n    Date theDayDate = null;\n    try {\n      theDayDate = formatHU.parse(theDay);\n    } catch (ParseException e) {\n      logger.error(e);\n      return new GregorianCalendar();\n    }\n    if (theDayDate == null) {\n      return new GregorianCalendar();\n    }\n\n    GregorianCalendar theDayCal = new GregorianCalendar();\n    theDayCal.setTime(theDayDate);\n\n    return theDayCal;\n  }\n"}, {"dataset": "parse", "exampleID": 7741, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [84], "initializationEnd": [121], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 170, "tryExpressionEnd": 174, "tryBlockStart": 170, "tryBlockEnd": 413, "catchExpressionStart": 338, "catchExpressionEnd": 363, "catchBlockStart": 338, "catchBlockEnd": 413, "exceptionHandlingCallStart": [371], "exceptionHandlingCallEnd": [390], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 194, "focalAPIEnd": 211, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/EnderDom/Eddie/tree/master/src/enderdom/eddie/tools/Tools_System.java", "rawCode": "  public static int getDeltaInDaysToNow(String source) {\n    SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT_NOW);\n    Calendar now = Calendar.getInstance();\n    try {\n      Date then = sdf.parse(source);\n      return (int)\n          ((now.getTime().getTime() - then.getTime()) / (1000 * 3600 * 24)); // millis*minutes*days\n    } catch (ParseException e) {\n      e.printStackTrace();\n      return 0;\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7742, "initialization": ["String the_text = Map<String, String>.get(String)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [3971, 4033], "initializationEnd": [3999, 4067], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 4106, "focalAPIEnd": 4130, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/smart-it/smart-user/tree/master/smart-user-resource/src/main/java/com/smartitengineering/user/ws/resources/ProfileResource.java", "rawCode": "  private Person getProfileFromContent(String message) {\n\n    Map<String, String> keyValueMap = new HashMap<String, String>();\n\n    String[] keyValuePairs = message.split(\"&\");\n\n    for (int i = 0; i < keyValuePairs.length; i++) {\n\n      String[] keyValuePair = keyValuePairs[i].split(\"=\");\n      keyValueMap.put(keyValuePair[0], keyValuePair[1]);\n    }\n\n    Person newPerson = new Person();\n    BasicIdentity self = new BasicIdentity();\n    Name selfName = new Name();\n\n    if (keyValueMap.get(\"firstName\") != null) {\n      selfName.setFirstName(keyValueMap.get(\"firstName\"));\n    }\n    if (keyValueMap.get(\"lastName\") != null) {\n      selfName.setFirstName(keyValueMap.get(\"lastName\"));\n    }\n    if (keyValueMap.get(\"middleInitial\") != null) {\n      selfName.setMiddleInitial(keyValueMap.get(\"middleInitial\"));\n    }\n    self.setName(selfName);\n\n    if (keyValueMap.get(\"nationalID\") != null) {\n      self.setNationalID(keyValueMap.get(\"nationalID\"));\n    }\n    newPerson.setSelf(self);\n\n    BasicIdentity spouse = new BasicIdentity();\n    Name spouseName = new Name();\n\n    if (keyValueMap.get(\"spouseFirstName\") != null) {\n      spouseName.setFirstName(keyValueMap.get(\"spouseFirstName\"));\n    }\n    if (keyValueMap.get(\"spouseLastName\") != null) {\n      spouseName.setFirstName(keyValueMap.get(\"spouseLastName\"));\n    }\n    if (keyValueMap.get(\"spouseMiddleInitial\") != null) {\n      spouseName.setMiddleInitial(keyValueMap.get(\"spouseMiddleInitial\"));\n    }\n    spouse.setName(spouseName);\n\n    if (keyValueMap.get(\"spouseNationalID\") != null) {\n      spouse.setNationalID(keyValueMap.get(\"spouseNationalID\"));\n    }\n    newPerson.setSpouse(spouse);\n\n    BasicIdentity mother = new BasicIdentity();\n    Name motherName = new Name();\n\n    if (keyValueMap.get(\"motherFirstName\") != null) {\n      motherName.setFirstName(keyValueMap.get(\"motherFirstName\"));\n    }\n    if (keyValueMap.get(\"motherLastName\") != null) {\n      motherName.setFirstName(keyValueMap.get(\"motherLastName\"));\n    }\n    if (keyValueMap.get(\"motherMiddleInitial\") != null) {\n      motherName.setMiddleInitial(keyValueMap.get(\"motherMiddleInitial\"));\n    }\n    mother.setName(motherName);\n\n    if (keyValueMap.get(\"motherNationalID\") != null) {\n      mother.setNationalID(keyValueMap.get(\"motherNationalID\"));\n    }\n    newPerson.setMother(mother);\n\n    BasicIdentity father = new BasicIdentity();\n    Name fatherName = new Name();\n\n    if (keyValueMap.get(\"fatherFirstName\") != null) {\n      fatherName.setFirstName(keyValueMap.get(\"fatherFirstName\"));\n    }\n    if (keyValueMap.get(\"fatherLastName\") != null) {\n      fatherName.setFirstName(keyValueMap.get(\"fatherLastName\"));\n    }\n    if (keyValueMap.get(\"fatherMiddleInitial\") != null) {\n      fatherName.setMiddleInitial(keyValueMap.get(\"fatherMiddleInitial\"));\n    }\n    father.setName(fatherName);\n\n    if (keyValueMap.get(\"fatherNationalID\") != null) {\n      father.setNationalID(keyValueMap.get(\"fatherNationalID\"));\n    }\n    newPerson.setFather(father);\n\n    Address address = new Address();\n    GeoLocation geoLocation = new GeoLocation();\n\n    if (keyValueMap.get(\"longitude\") != null) {\n      Double longitude = Double.parseDouble(keyValueMap.get(\"longitude\"));\n      geoLocation.setLongitude(longitude);\n    }\n\n    if (keyValueMap.get(\"latitude\") != null) {\n      Double latitude = Double.parseDouble(keyValueMap.get(\"latitude\"));\n      geoLocation.setLatitude(latitude);\n    }\n\n    address.setGeoLocation(geoLocation);\n\n    if (keyValueMap.get(\"city\") != null) {\n      address.setCity(keyValueMap.get(\"city\"));\n    }\n\n    if (keyValueMap.get(\"country\") != null) {\n      address.setCountry(keyValueMap.get(\"country\"));\n    }\n\n    if (keyValueMap.get(\"state\") != null) {\n      address.setState(keyValueMap.get(\"state\"));\n    }\n    if (keyValueMap.get(\"zip\") != null) {\n      address.setZip(keyValueMap.get(\"zip\"));\n    }\n    newPerson.setAddress(address);\n\n    if (keyValueMap.get(\"birthDate\") != null) {\n      String dateString = keyValueMap.get(\"birthDate\");\n      SimpleDateFormat format = new SimpleDateFormat(\"YYYY-MM-DD\");\n      try {\n        Date birthDate = format.parse(dateString);\n      } catch (Exception ex) {\n      }\n    }\n\n    if (keyValueMap.get(\"primaryEmail\") != null) {\n      newPerson.setPrimaryEmail(keyValueMap.get(\"primaryEmail\"));\n    }\n\n    if (keyValueMap.get(\"phoneNumber\") != null) {\n      newPerson.setPhoneNumber(keyValueMap.get(\"phoneNumber\"));\n    }\n    if (keyValueMap.get(\"secondaryEmail\") != null) {\n      newPerson.setSecondaryEmail(keyValueMap.get(\"secondaryEmail\"));\n    }\n    if (keyValueMap.get(\"faxNumber\") != null) {\n      newPerson.setFaxNumber(keyValueMap.get(\"faxNumber\"));\n    }\n    if (keyValueMap.get(\"cellPhoneNumber\") != null) {\n      newPerson.setCellPhoneNumber(keyValueMap.get(\"cellPhoneNumber\"));\n    }\n    return newPerson;\n  }\n"}, {"dataset": "parse", "exampleID": 7743, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [250], "initializationEnd": [284], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["println(String)"], "tryExpressionStart": 101, "tryExpressionEnd": 105, "tryBlockStart": 101, "tryBlockEnd": 638, "catchExpressionStart": 554, "catchExpressionEnd": 580, "catchBlockStart": 554, "catchBlockEnd": 638, "exceptionHandlingCallStart": [588], "exceptionHandlingCallEnd": [631], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 305, "focalAPIEnd": 328, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.parse(String)", "GregorianCalendar.setTime(dateTime)"], "useStart": [347, 378], "useEnd": [370, 397], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Pezmc/H14/tree/master/IBMS/src/ibms/RDH.java", "rawCode": "  /** Display all current holidays */\n  private static void displayHolidays(int currentUserId) {\n    try {\n      // List all the holidays a driver has taken already\n      GregorianCalendar gcal = new GregorianCalendar();\n      SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy.MM.dd\");\n      Date start = sdf.parse(\"2010.01.01\");\n      Date end = sdf.parse(\"2010.01.14\");\n      gcal.setTime(start);\n      while (gcal.getTime().before(end)) {\n        gcal.add(Calendar.DAY_OF_YEAR, 1);\n        System.out.println(gcal.getTime().toString());\n      }\n    } catch (ParseException ex) {\n      println(\"That doesn't look like a date?!?\");\n    }\n    // throw new UnsupportedOperationException(\"Not yet implemented\");\n  }\n"}, {"dataset": "parse", "exampleID": 7744, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [154], "initializationEnd": [185], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 343, "tryExpressionEnd": 347, "tryBlockStart": 343, "tryBlockEnd": 618, "catchExpressionStart": 559, "catchExpressionEnd": 584, "catchBlockStart": 559, "catchBlockEnd": 618, "exceptionHandlingCallStart": [592], "exceptionHandlingCallEnd": [611], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 367, "focalAPIEnd": 386, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.parse(String)", "simpleDateFormat.format(Date)", "simpleDateFormat.format(Date)", "simpleDateFormat.format(Date)", "getNonWorkingHours(dateTime,Date)"], "useStart": [404, 642, 689, 813, 844], "useEnd": [421, 663, 708, 836, 882], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jarvis-su/codes/tree/master/dataOperation/src/main/java/sqlite/Main.java", "rawCode": "  /** @param args */\n  public static void main(String[] args) {\n    // method();\n    String formatStr = \"yyyy-MM-dd HH:mm:ss\";\n    SimpleDateFormat sdf = new SimpleDateFormat(formatStr);\n    String beginStr = \"2013-06-04 18:34:49\";\n    String endStr = \"2013-06-04 19:00:00\";\n    Date beginDate = new Date();\n    Date endDate = new Date();\n    try {\n      beginDate = sdf.parse(beginStr);\n      endDate = sdf.parse(endStr);\n\n      float hours = (float) ((endDate.getTime() - beginDate.getTime()) / 1000.0 / 60.0 / 60.0);\n      System.out.println(hours);\n    } catch (ParseException e) {\n      e.printStackTrace();\n    }\n    System.out.println(sdf.format(beginDate));\n    System.out.println(sdf.format(endDate));\n\n    Calendar c = Calendar.getInstance();\n    c.set(Calendar.HOUR_OF_DAY, 20);\n    System.out.println(sdf.format(c.getTime()));\n\n    getNonWorkingHours(beginDate, endDate);\n  }\n"}, {"dataset": "parse", "exampleID": 7745, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(the_text==null)", "guardType": "IF {", "guardExpressionStart": 104, "guardExpressionEnd": 121, "guardBlockStart": 104, "guardBlockEnd": 156, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 182, "focalAPIEnd": 204, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Calendar.setTime(dateTime)"], "useStart": [257], "useEnd": [271], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mbastian/gephi-maven/tree/master/modules/DataLaboratoryAPI/src/main/java/org/gephi/datalab/impl/AttributeColumnsMergeStrategiesControllerImpl.java", "rawCode": "  private double parseDateToDouble(SimpleDateFormat dateFormat, String date, double defaultValue) {\n    if (date == null) {\n      return defaultValue;\n    }\n    try {\n      Date d = dateFormat.parse(date);\n      Calendar cal = Calendar.getInstance();\n      cal.setTime(d);\n      return cal.getTimeInMillis();\n    } catch (Exception ex) {\n      return defaultValue;\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7746, "initialization": ["String the_text = get(*)"], "initializationStart": [1861], "initializationEnd": [1886], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 1948, "focalAPIEnd": 1996, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sgewuhan/vim/tree/master/com.sg.vim/src/com/sg/vim/VimUtils.java", "rawCode": "  private static VehicleBasicInfo getVehicleBasicInfo(DBObject data, boolean isUpdate, String memo)\n      throws Exception {\n    // Object cocId = data.get(IVIMFields.COC_ID);\n    // DBCollection col = DBActivator.getCollection(IVIMFields.DB_NAME, IVIMFields.COL_COCINFO);\n    // DBObject cocData = col.findOne(new BasicDBObject().append(\"_id\", cocId));\n    // if(cocData==null){\n    // throw new Exception(\"无法获得对应的车辆一致性信息\");\n    // }\n    // data.putAll(cocData);\n\n    VehicleBasicInfo info = new VehicleBasicInfo();\n    // 序号 属性 中文名称 数据类型\n    // （soap描述） 说明\n    // 1 V_Id 反馈码 s:string 系统生成，无需操作。\n\n    // 2 Vin 车辆备案号（VIN码） s:string 主表车辆备案号（VIN码）字段（规定时间内上报时使用）\n    info.setVin((String) data.get(IVIMFields.F_0_6b));\n\n    // 3 App_Vin 车辆备案号（VIN码） s:string 申请表车辆备案号（VIN码）字段（申请补传、修改、撤销时使用）\n    if (isUpdate) {\n      info.setAppVin((String) data.get(IVIMFields.F_0_6b));\n    }\n\n    // 4 User_Id 企业登录用户名 s:string\n    info.setUserId(FUELLABEL_USERNAME);\n\n    // 5 Qcscqy 汽车生产企业 s:string\n    info.setQcscqy((String) data.get(IVIMFields.F_0_1));\n\n    // 6 Jkqczjxs 进口汽车经销商 s:string 国内生产商此项可为空，进口商企业为必填项\n\n    // 7 Clxh 车辆型号 s:string\n    info.setClxh((String) data.get(IVIMFields.F_0_2C1));\n\n    // 8 Clzl 车辆种类 s:string 从“乘用车（M1）、轻型客车（M2）、轻型货车（N1）”下拉框中选择，其中，M1、M2、N1 的定义按GB/T\n    // 15089-2001《机动车辆及挂车分类》\n    info.setClzl((String) data.get(IVIMFields.F_0_4));\n\n    // 9 Rllx 燃料类型 s:string 汽油、柴油、两用燃料、双燃料、纯电动、非插电式混合动力、插电式混合动力、燃料电池\n    info.setRllx((String) data.get(IVIMFields.F_25));\n\n    // Zczbzl 整车整备质量 s:string\n    info.setZczbzl((String) data.get(IVIMFields.C_08));\n\n    // Zgcs 最高车速 s:string\n    info.setZgcs((String) data.get(IVIMFields.F_44));\n\n    // Ltgg 轮胎规格 s:string\n    info.setLtgg((String) data.get(IVIMFields.F_32A));\n\n    // Zj 轴距 s:string\n    info.setZj((String) data.get(IVIMFields.F_3));\n\n    // Clzzrq 车辆制造日期/进口日期 s:string\n    String value = (String) data.get(IVIMFields.G_34);\n    // Assert.isNotNull(value, \"车辆制造日期\");\n    Date dValue = new SimpleDateFormat(\"yyyy年MM月dd日\").parse(value);\n    GregorianCalendar nowGregorianCalendar = new GregorianCalendar();\n    nowGregorianCalendar.setTime(dValue);\n    XMLGregorianCalendar xmlDatetime =\n        DatatypeFactory.newInstance().newXMLGregorianCalendar(nowGregorianCalendar);\n    info.setClzzrq(xmlDatetime);\n\n    // Tymc 通用名称 s:string //销售车型\n    info.setTymc((String) data.get(IVIMFields.D_20));\n\n    // Yyc 越野车（G类） s:string 是/否\n    info.setYyc((String) data.get(IVIMFields.D_30));\n\n    // Zwps 座位排数 s:string\n    info.setZwps((String) data.get(IVIMFields.D_17));\n\n    // Zdsjzzl 最大设计总质量 s:string\n    info.setZdsjzzl((String) data.get(IVIMFields.F_14_1));\n\n    // Edzk 额定载客 s:string\n    info.setEdzk((String) data.get(IVIMFields.F_42_1));\n\n    // Lj 轮距（前/后） s:string\n    String qlj = (String) data.get(IVIMFields.F_5A);\n    String hlj = (String) data.get(IVIMFields.F_5B);\n    info.setLj(qlj + \"/\" + hlj);\n\n    // Qdxs 驱动型式 s:string 从“前轮驱动、后轮驱动、分时全轮驱动、全时全轮驱动、智能(适时)全轮驱动”下拉框中选择\n    info.setQdxs((String) data.get(IVIMFields.D_22));\n\n    // CreateTime 上传时间 s:datetime 此项可为空，server端处理此字段\n    // UpdateTime 更新时间 s:datetime 此项可为空，server端处理此字段\n    // Status 状态 s:string 此项可为空，server端处理此字段\n    // 状态说明见表五\n\n    // Jyjgmc 检测机构名称 s:string\n    info.setJyjgmc((String) data.get(IVIMFields.D_31));\n\n    // Jybgbh 检测报告编号 s:string\n    info.setJybgbh((String) data.get(IVIMFields.D_32));\n\n    if (isUpdate && !Utils.isNullOrEmpty(memo)) {\n      // 原因\n      info.setReason(memo);\n    }\n\n    // Apply_Type 申请操作类型 s:string 此项可为空，server端处理此字段\n    // Check s:string 辅助字段，企业开发时忽略此字段\n    // Reason 申请原因字段 s:string 在申请补传，申请修改时（即调用接口4: UploadOverTime，5 :ApplyUpdate）时此字段为必填项\n    // EntityList 燃料参数数组 RllxParamEntity[] 数据结构见表四\n    // 只考虑了传统能源的情况\n\n    String vin = (String) data.get(IVIMFields.F_0_6b);\n\n    ArrayOfRllxParamEntity arrayRllx = new ArrayOfRllxParamEntity();\n    List<RllxParamEntity> rllxlist = arrayRllx.getRllxParamEntity();\n\n    // 变速器档位数\n    rllxlist.add(\n        getRllxParamEntity(IVIMFields.CT_BSQDWS, (String) data.get(IVIMFields.F_28_1), vin));\n\n    // 变速器形式\n    value = (String) data.get(IVIMFields.F_28);\n    if (\"手动\".equals(value)) {\n      rllxlist.add(getRllxParamEntity(IVIMFields.CT_BSQXS, \"MT\", vin));\n    } else if (\"自动\".equals(value)) {\n      rllxlist.add(getRllxParamEntity(IVIMFields.CT_BSQXS, \"AT\", vin));\n    } else {\n      rllxlist.add(getRllxParamEntity(IVIMFields.CT_BSQXS, \"其他\", vin));\n    }\n\n    // 额定功率\n    value = (String) data.get(IVIMFields.C_01);\n    rllxlist.add(getRllxParamEntity(IVIMFields.CT_EDGL, value, vin));\n\n    // 发动机型号\n    value = (String) data.get(IVIMFields.F_C4);\n    rllxlist.add(getRllxParamEntity(IVIMFields.CT_FDJXH, value, vin));\n\n    // 净功率\n    value = (String) data.get(IVIMFields.F_26);\n    rllxlist.add(getRllxParamEntity(IVIMFields.CT_JGL, value, vin));\n\n    // 排量\n    value = (String) data.get(IVIMFields.F_24);\n    rllxlist.add(getRllxParamEntity(IVIMFields.CT_PL, value, vin));\n\n    // 汽车节能技术\n    value = \"\";\n    rllxlist.add(getRllxParamEntity(IVIMFields.CT_QCJNJS, value, vin));\n\n    // 气缸数\n    value = (String) data.get(IVIMFields.F_23);\n    rllxlist.add(getRllxParamEntity(IVIMFields.CT_QGS, value, vin));\n\n    // 其他信息\n    value = \"\";\n    rllxlist.add(getRllxParamEntity(IVIMFields.CT_QTXX, value, vin));\n\n    rllxlist.add(\n        getRllxParamEntity(IVIMFields.CT_SQGKRLXHL, (String) data.get(IVIMFields.D_14), vin));\n    rllxlist.add(\n        getRllxParamEntity(IVIMFields.CT_SJGKRLXHL, (String) data.get(IVIMFields.D_15), vin));\n    rllxlist.add(\n        getRllxParamEntity(IVIMFields.CT_ZHGKRLXHL, (String) data.get(IVIMFields.D_16), vin));\n    rllxlist.add(\n        getRllxParamEntity(\n            IVIMFields.CT_ZHGKCO2PFL, (String) data.get(IVIMFields.CT_ZHGKCO2PFL), vin));\n\n    info.setEntityList(arrayRllx);\n    return info;\n  }\n"}, {"dataset": "parse", "exampleID": 7747, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 252, "focalAPIEnd": 287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setLastModified(dateTime)", "simpleDateFormat.parse(String)", "simpleDateFormat.parse(String)"], "useStart": [226, 577, 901], "useEnd": [288, 612, 936], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cstamas/nexus-core/tree/master/nexus/nexus-rest-api/src/test/java/org/sonatype/nexus/client/model/TestMarshalUnmarchal.java", "rawCode": "  public void testContentListResourceResponse() throws ParseException {\n\n    ContentListResourceResponse responseResponse = new ContentListResourceResponse();\n    ContentListResource resource1 = new ContentListResource();\n    resource1.setLastModified(this.dateFormat.parse(\"01/01/2001\"));\n    resource1.setLeaf(false);\n    resource1.setRelativePath(\"relativePath1\");\n    resource1.setResourceURI(\"resourceURI1\");\n    resource1.setSizeOnDisk(41);\n    resource1.setText(\"resource1\");\n\n    ContentListResource resource2 = new ContentListResource();\n    resource2.setLastModified(this.dateFormat.parse(\"01/01/2002\"));\n    resource2.setLeaf(true);\n    resource2.setRelativePath(\"relativePath2\");\n    resource2.setResourceURI(\"resourceURI2\");\n    resource2.setSizeOnDisk(42);\n    resource2.setText(\"resource2\");\n\n    ContentListResource resource3 = new ContentListResource();\n    resource3.setLastModified(this.dateFormat.parse(\"01/01/2003\"));\n    resource3.setLeaf(true);\n    resource3.setRelativePath(\"relativePath3\");\n    resource3.setResourceURI(\"resourceURI3\");\n    resource3.setSizeOnDisk(43);\n    resource3.setText(\"resource3\");\n\n    responseResponse.addData(resource1);\n    responseResponse.addData(resource2);\n\n    this.marshalUnmarchalThenCompare(\n        responseResponse, this.xstreamXML); // FIXME: JSON READER CANNOT PARSE DATES\n    // CORRECTLY.\n    this.validateXmlHasNoPackageNames(responseResponse);\n  }\n"}, {"dataset": "parse", "exampleID": 7748, "initialization": ["SimpleDateFormat simpleDateFormat = getDateFormat(String)"], "initializationStart": [690], "initializationEnd": [716], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 752, "focalAPIEnd": 783, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["invoke(Object,dateTime)"], "useStart": [725], "useEnd": [784], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yangjiandong/sshapp/tree/master/modules/extension/src/main/java/org/springside/modules/utils/leona/JsonUtils.java", "rawCode": "  /**\n   * 根据类型，反射调用setter方法.\n   *\n   * @param entity 实例\n   * @param writeMethod setter方法\n   * @param propertyType 数据类型\n   * @param propertyValue 数据值\n   * @param datePattern 日期格式\n   * @throws Exception 异常\n   */\n  public static void invokeWriteMethod(\n      Object entity,\n      Method writeMethod,\n      Class propertyType,\n      String propertyValue,\n      String datePattern)\n      throws Exception {\n    if (isPrimivite(propertyType)) {\n      invokePrimivite(entity, writeMethod, propertyType, propertyValue);\n    } else if (propertyType == String.class) {\n      writeMethod.invoke(entity, propertyValue);\n    } else if (propertyType == Date.class) {\n      SimpleDateFormat dateFormat = getDateFormat(datePattern);\n\n      writeMethod.invoke(entity, dateFormat.parse(propertyValue));\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7749, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [1165], "initializationEnd": [1199], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 1236, "focalAPIEnd": 1259, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setDate(String,dateTime)", "simpleDateFormat.format(Date)", "simpleDateFormat.format(Date)", "simpleDateFormat.format(Date)", "simpleDateFormat.format(Date)", "simpleDateFormat.format(Date)"], "useStart": [1207, 2193, 3104, 4051, 5579, 6494], "useEnd": [1260, 2228, 3139, 4086, 5614, 6529], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jdmr/mateo/tree/master/src/main/java/mx/edu/um/mateo/activos/dao/impl/ActivoDaoHibernate.java", "rawCode": "  @SuppressWarnings(\"unchecked\")\n  @Override\n  public void arreglaFechas(OutputStream out) {\n    log.debug(\"Arreglando fechas\");\n    Date inicio = new Date();\n    XSSFWorkbook wb = new XSSFWorkbook();\n    CreationHelper createHelper = wb.getCreationHelper();\n    CellStyle cellStyle = wb.createCellStyle();\n    cellStyle.setDataFormat(createHelper.createDataFormat().getFormat(\"dd/mm/yyyy\"));\n    XSSFSheet fechas = wb.createSheet(\"FECHAS-ANTERIORES\");\n    int fechasRow = 0;\n    XSSFSheet fechas2 = wb.createSheet(\"FECHAS-POSTERIORES\");\n    int fechas2Row = 0;\n    Transaction tx = null;\n    try {\n      tx = currentSession().beginTransaction();\n      Query update =\n          currentSession()\n              .createQuery(\"update Activo set fechaCompra = :fechaCompra where id = :id\");\n      Query query =\n          currentSession()\n              .createQuery(\n                  \"select new Activo(a.id, a.descripcion, a.fechaCompra, a.tipoActivo.cuenta.id.idCtaMayor, a.centroCosto.id.idCosto, a.codigo) from Activo a where a.fechaCompra < :fechaCompra order by a.tipoActivo.cuenta.id.idCtaMayor, a.centroCosto.id.idCosto, a.codigo\");\n      SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\");\n      query.setDate(\"fechaCompra\", sdf.parse(\"01/01/1970\"));\n      List<Activo> activos = query.list();\n      int cont = 0;\n      for (Activo activo : activos) {\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(activo.getFechaCompra());\n        if (cal1.get(Calendar.YEAR) < 10) {\n          log.debug(\n              \"Pasando al año 2000 {} - {}\", activo.getDescripcion(), activo.getFechaCompra());\n          cal1.add(Calendar.YEAR, 2000);\n          update.setDate(\"fechaCompra\", cal1.getTime());\n          update.setLong(\"id\", activo.getId());\n          update.executeUpdate();\n          XSSFRow renglon = fechas.createRow(fechasRow++);\n          renglon.createCell(0).setCellValue(activo.getTipoActivoCuenta());\n          renglon.createCell(1).setCellValue(activo.getCentroCostoCuenta());\n          renglon.createCell(2).setCellValue(activo.getCodigo());\n          renglon.createCell(3).setCellValue(activo.getDescripcion());\n          renglon.createCell(4).setCellValue(sdf.format(activo.getFechaCompra()));\n          Cell cell = renglon.createCell(5);\n          cell.setCellValue(cal1.getTime());\n          cell.setCellStyle(cellStyle);\n        } else if (cal1.get(Calendar.YEAR) < 100) {\n          log.debug(\n              \"Pasando al año 1900 {} - {}\", activo.getDescripcion(), activo.getFechaCompra());\n          cal1.add(Calendar.YEAR, 1900);\n          update.setDate(\"fechaCompra\", cal1.getTime());\n          update.setLong(\"id\", activo.getId());\n          update.executeUpdate();\n          XSSFRow renglon = fechas.createRow(fechasRow++);\n          renglon.createCell(0).setCellValue(activo.getTipoActivoCuenta());\n          renglon.createCell(1).setCellValue(activo.getCentroCostoCuenta());\n          renglon.createCell(2).setCellValue(activo.getCodigo());\n          renglon.createCell(3).setCellValue(activo.getDescripcion());\n          renglon.createCell(4).setCellValue(sdf.format(activo.getFechaCompra()));\n          Cell cell = renglon.createCell(5);\n          cell.setCellValue(cal1.getTime());\n          cell.setCellStyle(cellStyle);\n        } else if (cal1.get(Calendar.YEAR) >= 1900 && cal1.get(Calendar.YEAR) <= 1912) {\n          log.debug(\n              \"Pasando al año 2000 {} - {}\", activo.getDescripcion(), activo.getFechaCompra());\n          cal1.add(Calendar.YEAR, 100);\n          update.setDate(\"fechaCompra\", cal1.getTime());\n          update.setLong(\"id\", activo.getId());\n          update.executeUpdate();\n          XSSFRow renglon = fechas.createRow(fechasRow++);\n          renglon.createCell(0).setCellValue(activo.getTipoActivoCuenta());\n          renglon.createCell(1).setCellValue(activo.getCentroCostoCuenta());\n          renglon.createCell(2).setCellValue(activo.getCodigo());\n          renglon.createCell(3).setCellValue(activo.getDescripcion());\n          renglon.createCell(4).setCellValue(sdf.format(activo.getFechaCompra()));\n          Cell cell = renglon.createCell(5);\n          cell.setCellValue(cal1.getTime());\n          cell.setCellStyle(cellStyle);\n        }\n        cont++;\n      }\n      currentSession().flush();\n\n      query =\n          currentSession()\n              .createQuery(\n                  \"select new Activo(a.id, a.descripcion, a.fechaCompra, a.tipoActivo.cuenta.id.idCtaMayor, a.centroCosto.id.idCosto, a.codigo) from Activo a where a.fechaCompra > :fechaCompra order by a.tipoActivo.cuenta.id.idCtaMayor, a.centroCosto.id.idCosto, a.codigo\");\n      query.setDate(\"fechaCompra\", new Date());\n      activos = query.list();\n      for (Activo activo : activos) {\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(activo.getFechaCompra());\n        if (cal1.get(Calendar.YEAR) < 2020) {\n          log.debug(\n              \"Quitandole 10 anios {} - {}\", activo.getDescripcion(), activo.getFechaCompra());\n          cal1.add(Calendar.YEAR, -10);\n          update.setDate(\"fechaCompra\", cal1.getTime());\n          update.setLong(\"id\", activo.getId());\n          update.executeUpdate();\n          XSSFRow renglon = fechas2.createRow(fechas2Row++);\n          renglon.createCell(0).setCellValue(activo.getTipoActivoCuenta());\n          renglon.createCell(1).setCellValue(activo.getCentroCostoCuenta());\n          renglon.createCell(2).setCellValue(activo.getCodigo());\n          renglon.createCell(3).setCellValue(activo.getDescripcion());\n          renglon.createCell(4).setCellValue(sdf.format(activo.getFechaCompra()));\n          Cell cell = renglon.createCell(5);\n          cell.setCellValue(cal1.getTime());\n          cell.setCellStyle(cellStyle);\n        } else if (cal1.get(Calendar.YEAR) >= 2020) {\n          log.debug(\n              \"Pasando al año 1900 {} - {}\", activo.getDescripcion(), activo.getFechaCompra());\n          cal1.add(Calendar.YEAR, -100);\n          update.setDate(\"fechaCompra\", cal1.getTime());\n          update.setLong(\"id\", activo.getId());\n          update.executeUpdate();\n          XSSFRow renglon = fechas2.createRow(fechas2Row++);\n          renglon.createCell(0).setCellValue(activo.getTipoActivoCuenta());\n          renglon.createCell(1).setCellValue(activo.getCentroCostoCuenta());\n          renglon.createCell(2).setCellValue(activo.getCodigo());\n          renglon.createCell(3).setCellValue(activo.getDescripcion());\n          renglon.createCell(4).setCellValue(sdf.format(activo.getFechaCompra()));\n          Cell cell = renglon.createCell(5);\n          cell.setCellValue(cal1.getTime());\n          cell.setCellStyle(cellStyle);\n        }\n        cont++;\n      }\n      currentSession().flush();\n\n      tx.commit();\n      log.debug(\n          \"Termino actualizando {} de {} en {}\",\n          new Object[] {cont, activos.size(), ((new Date().getTime() - inicio.getTime()) / 1000)});\n      wb.write(out);\n    } catch (ParseException | HibernateException | IOException e) {\n      log.error(\"No se pudieron arreglar las fechas de los activos\", e);\n      tx.rollback();\n      throw new RuntimeException(\"No se pudieron arreglar las fechas de los actios\", e);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7750, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [366], "initializationEnd": [400], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 425, "focalAPIEnd": 461, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(dateTime,*)"], "useStart": [756], "useEnd": [807], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spring-projects/spring-xd/tree/master/spring-xd-dirt/src/test/java/org/springframework/xd/dirt/plugins/job/ExpandedJobParametersConverterTests.java", "rawCode": "  @Test\n  public void convertDateAndNumberJobParametersToJson() throws Exception {\n\n    final ExpandedJobParametersConverter jobParametersConverter =\n        new ExpandedJobParametersConverter();\n    jobParametersConverter.setMakeParametersUnique(false);\n    jobParametersConverter.setDateFormatAsString(\"yyyy/MM/dd\");\n\n    final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy/MM/dd\");\n\n    final Date date = simpleDateFormat.parse(\"2014/02/18\");\n\n    final String json = \"{\\\"param1(date)\\\":\\\"2014/02/18\\\",\\\"param2(long)\\\":\\\"123456789\\\"}\";\n\n    final JobParameters jobParameters = jobParametersConverter.getJobParametersForJsonString(json);\n\n    assertNotNull(jobParameters);\n    assertTrue(jobParameters.getParameters().size() == 2);\n\n    assertEquals(date, jobParameters.getDate(\"param1\"));\n    assertEquals(Long.valueOf(123456789L), jobParameters.getLong(\"param2\"));\n\n    for (JobParameter jobParameter : jobParameters.getParameters().values()) {\n      assertTrue(jobParameter.isIdentifying());\n    }\n\n    final String jobParametersAsJson =\n        jobParametersConverter.getJobParametersAsString(jobParameters);\n\n    assertEquals(json, jobParametersAsJson);\n  }\n"}, {"dataset": "parse", "exampleID": 7751, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 2754, "tryExpressionEnd": 2758, "tryBlockStart": 2754, "tryBlockEnd": 4560, "catchExpressionStart": 4489, "catchExpressionEnd": 4514, "catchBlockStart": 4489, "catchBlockEnd": 4560, "exceptionHandlingCallStart": [4528], "exceptionHandlingCallEnd": [4547], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 2792, "focalAPIEnd": 2848, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setTime(dateTime)", "simpleDateFormat.parse(String)", "simpleDateFormat.parse(String)"], "useStart": [2772, 3215, 3292], "useEnd": [2849, 3257, 3332], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hamo26/EECE419Group7/tree/master/schedushare-android/SchedUShare/src/com/schedushare/android/fragments/DiffFragment.java", "rawCode": "  @Override\n  public View onCreateView(\n      LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n    super.onCreateView(inflater, container, savedInstanceState);\n\n    View view = inflater.inflate(R.layout.fragment_diff, container, false);\n\n    Bundle bundle = getArguments();\n    if (bundle != null) {\n      this.selectedUsers =\n          DiffActivity.restoreByteArray(getArguments().getByteArray(\"selectedUsers\"));\n\n      this.userSchedules = new ArrayList<ScheduleData>();\n\n      SchedulesDataSource dataSource = new SchedulesDataSource(getActivity());\n      dataSource.open();\n      for (int i = 0; i < this.selectedUsers.size(); i++) {\n        System.out.println(\"userId: \" + this.selectedUsers.get(i).getId());\n        UserData user =\n            dataSource.getUserFromSid(Long.parseLong(this.selectedUsers.get(i).getId()));\n        this.userSchedules.add(dataSource.getActiveScheduleFromOwnerId(user.id));\n      }\n\n      SharedPreferences p = getActivity().getSharedPreferences(MainMenuActivity.PREFS_NAME, 0);\n      this.userSchedules.add(\n          dataSource.getScheduleFromId(\n              p.getLong(getString(R.string.settings_owner_active_schedule_id), 1)));\n\n      // Initialize all rows in the diffTable.\n      this.diffTable = (TableLayout) view.findViewById(R.id.diff_table_layout);\n      addAllRows();\n\n      // Calendars used for comparison.\n      Calendar currentTime = Calendar.getInstance();\n      Calendar startTime = Calendar.getInstance();\n      Calendar endTime = Calendar.getInstance();\n\n      // Layout params used by block.\n      LayoutParams blockParams = new LayoutParams(0, LayoutParams.WRAP_CONTENT, 1f);\n      blockParams.setMargins(1, 0, 1, 0);\n\n      // Iterate through all days. Colour all free blocks.\n      for (int j = 0; j < 7; j++) {\n        final int dayIndex = j;\n\n        // Get all the time blocks of each schedule for the given day.\n        ArrayList<ArrayList<TimeBlockData>> scheduleTimeBlocks =\n            new ArrayList<ArrayList<TimeBlockData>>();\n        for (ScheduleData s : this.userSchedules) {\n          ArrayList<TimeBlockData> t = dataSource.getScheduleDayTimeBlocks(s.id, j);\n\n          if (t != null) {\n            scheduleTimeBlocks.add(dataSource.getScheduleDayTimeBlocks(s.id, j));\n          }\n        }\n\n        // Go through each time block for the day and perform a diff between all schedules.\n        for (int k = 0; k < EditScheduleActivity.TIME_DATA.length; k++) {\n          final int timeIndex = k;\n\n          TableRow row = (TableRow) view.findViewWithTag(EditScheduleActivity.TIME_DATA[k]);\n          TextView tv = new TextView(getActivity());\n          tv.setLayoutParams(blockParams);\n\n          // Set calendar object as basis for comparison.\n          try {\n            currentTime.setTime(this.timeFormat.parse(EditScheduleActivity.TIME_DATA[k]));\n\n            // Count the number of schedules that are free for the time block.\n            int numSchedulesFree = 0;\n            boolean isBlockFree = true;\n\n            for (ArrayList<TimeBlockData> timeBlocks : scheduleTimeBlocks) {\n              isBlockFree = true;\n\n              for (TimeBlockData timeBlock : timeBlocks) {\n                startTime.setTime(this.timeFormat.parse(timeBlock.startTime));\n                endTime.setTime(this.timeFormat.parse(timeBlock.endTime));\n\n                // Found time block that is not free.\n                if ((currentTime.getTime().getTime() >= startTime.getTime().getTime())\n                    && (currentTime.getTime().getTime() < endTime.getTime().getTime())) {\n                  isBlockFree = false;\n                  break;\n                }\n              }\n\n              if (isBlockFree) numSchedulesFree++;\n            }\n\n            // All schedules are free at that time.\n            if (numSchedulesFree == scheduleTimeBlocks.size()) {\n              tv.setBackgroundColor(Color.GREEN);\n            }\n\n            // tv.setOnClickListener(new OnClickListener() {\n            // @Override\n            // public void onClick(View v) {\n            // Intent intent = new Intent(DiffFragment.this.getActivity(),\n            // CreateFacebookEventActivity.class);\n            // Bundle b = new Bundle();\n            // b.putInt(\"day\", dayIndex);\n            // b.putString(\"startTime\", EditScheduleActivity.TIME_DATA[timeIndex]);\n            // intent.putExtras(b);\n            // startActivity(intent);\n            // }\n            // });\n\n            row.addView(tv);\n          } catch (ParseException e) {\n            e.printStackTrace();\n          }\n        }\n      }\n\n      dataSource.close();\n    } else {\n      System.out.println(\"Bundle is null.\");\n    }\n\n    return view;\n  }\n"}, {"dataset": "parse", "exampleID": 7752, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(*)", "String the_text = SimpleDateFormat.format(Timestamp)"], "initializationStart": [971, 1037, 1481], "initializationEnd": [1006, 1094, 1502], "hasTryCatch": 1, "exceptionType": "SQLException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 731, "tryExpressionEnd": 735, "tryBlockStart": 731, "tryBlockEnd": 2683, "catchExpressionStart": 2171, "catchExpressionEnd": 2195, "catchBlockStart": 2171, "catchBlockEnd": 2230, "exceptionHandlingCallStart": [2203], "exceptionHandlingCallEnd": [2223], "configuration": ["simpleDateFormat.format(Timestamp)"], "configurationStart": [1481], "configurationEnd": [1502], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 1516, "focalAPIEnd": 1536, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["TreeSet<Date>.add(dateTime)"], "useStart": [1546], "useEnd": [1556], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 2348, "finallyExpressionEnd": 2356, "finallyBlockStart": 2348, "finallyBlockEnd": 2683, "cleanUpCallStart": [2410], "cleanUpCallEnd": [2424], "url": "https://github.com/kef/hieos/tree/master/src/logbrowser/src/java/com/vangent/hieos/logbrowser/servlets/GetDateServlet.java", "rawCode": "  /**\n   * @param req\n   * @param res\n   */\n  public void doGet(HttpServletRequest req, HttpServletResponse res) {\n    PreparedStatement dateStatement = null;\n    Log log = new Log();\n    try {\n      Connection con = log.getConnection();\n      System.out.println(\"LOG (dateStatement) = \" + this.sqlCommand);\n      dateStatement = con.prepareStatement(this.sqlCommand);\n    } catch (SQLException e) {\n      logger.error(e);\n    } catch (LoggerException e) {\n      logger.error(e);\n    }\n    if (dateStatement == null) {\n      try {\n        log.closeConnection();\n        return; // EARLY EXIT: Can not continue processing\n      } catch (LoggerException ex) {\n        logger.error(ex);\n      }\n    }\n    ResultSet result = null;\n    try {\n      result = dateStatement.executeQuery();\n      TreeSet<Date> set = new TreeSet<Date>();\n      SimpleDateFormat sdf = null;\n      SimpleDateFormat sdf2 = null;\n      if (req.getParameter(\"formatDisplayed\") == null) {\n        sdf = new SimpleDateFormat(\"yyyy-MMM dd\");\n      } else {\n        sdf = new SimpleDateFormat(req.getParameter(\"formatDisplayed\"));\n      }\n      if (req.getParameter(\"formatValue\") == null) {\n        sdf2 = new SimpleDateFormat(\"yyyy-MM-dd\");\n      } else {\n        sdf2 = new SimpleDateFormat(req.getParameter(\"formatValue\"));\n      }\n      Timestamp timeStamp = null;\n      String stringTmp = null;\n      Date d = null;\n      while (result.next()) {\n        timeStamp = result.getTimestamp(1);\n        stringTmp = sdf.format(timeStamp);\n        d = sdf.parse(stringTmp);\n        set.add(d);\n      }\n      Object[] stArray = set.toArray();\n      StringBuffer time = new StringBuffer();\n      res.setContentType(\"text/xml\");\n      time.append(\"<select>\");\n      time.append(\"<option value ='0' ></option>\\n\");\n      for (int i = stArray.length - 1; i > -1; i--) {\n        time.append(\n            \"<option value ='\"\n                + sdf2.format((Date) stArray[i])\n                + \"' > \"\n                + sdf.format((Date) stArray[i])\n                + \"</option>\\n\");\n      }\n      time.append(\"</select >\");\n      stArray = null;\n      res.getWriter().write(time.toString());\n      time = null;\n    } catch (SQLException e1) {\n      e1.printStackTrace();\n    } catch (ParseException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    } finally {\n      try {\n        if (result != null) {\n          result.close();\n        }\n        if (dateStatement != null) {\n          dateStatement.close();\n        }\n        log.closeConnection();\n      } catch (LoggerException ex) {\n        logger.error(ex);\n      } catch (SQLException se) {\n        logger.error(se);\n      }\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7753, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [139], "initializationEnd": [171], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 177, "tryExpressionEnd": 181, "tryBlockStart": 177, "tryBlockEnd": 470, "catchExpressionStart": 394, "catchExpressionEnd": 419, "catchBlockStart": 394, "catchBlockEnd": 470, "exceptionHandlingCallStart": [428], "exceptionHandlingCallEnd": [447], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 201, "focalAPIEnd": 223, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dateTime.getHours()", "dateTime.getMinutes()", "dateTime.getSeconds()"], "useStart": [248, 291, 336], "useEnd": [263, 308, 353], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/HUSTDAVID/wuhan-dm/tree/master/src/src/com/wh/dm/util/TimeUtil.java", "rawCode": "  public static long getCurtime(String time) {\n\n    Date curdate = new Date(System.currentTimeMillis());\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"HH:mm:ss\");\n    try {\n      Date date = dateFormat.parse(time);\n      curdate.setHours(date.getHours());\n      curdate.setMinutes(date.getMinutes());\n      curdate.setSeconds(date.getSeconds());\n      return curdate.getTime();\n    } catch (ParseException e) {\n\n      e.printStackTrace();\n      return 0;\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7754, "initialization": ["SimpleDateFormat simpleDateFormat = getDateFormat()"], "initializationStart": [305], "initializationEnd": [341], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 503, "focalAPIEnd": 531, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.parse(String)", "createBlocks(String,String,String,dateTime,*,int)"], "useStart": [545, 390], "useEnd": [573, 589], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nblair/sometime/tree/master/sometime-spi/src/test/java/org/jasig/schedassist/impl/owner/SpringJDBCAvailableScheduleDaoImplTest.java", "rawCode": "  /**\n   * @throws ParseException\n   * @throws InputFormatException\n   */\n  @Test\n  public void testAvailable104() throws InputFormatException, ParseException {\n    // get owner with meeting durations preference of 20 minutes\n    IScheduleOwner owner = sampleOwners[3];\n\n    SimpleDateFormat dateFormat = CommonDateOperations.getDateFormat();\n    SortedSet<AvailableBlock> blocks =\n        AvailableBlockBuilder.createBlocks(\n            \"9:00 AM\",\n            \"11:40 AM\",\n            \"MW\",\n            dateFormat.parse(\"20100830\"),\n            dateFormat.parse(\"20100903\"),\n            1);\n    availableScheduleDao.addToSchedule(owner, blocks);\n\n    AvailableSchedule stored = availableScheduleDao.retrieve(owner);\n    SortedSet<AvailableBlock> storedBlocks = stored.getAvailableBlocks();\n    Assert.assertEquals(2, storedBlocks.size());\n    Assert.assertEquals(\n        CommonDateOperations.getDateTimeFormat().parse(\"20100830-0900\"),\n        storedBlocks.first().getStartTime());\n    Assert.assertEquals(\n        CommonDateOperations.getDateTimeFormat().parse(\"20100830-1140\"),\n        storedBlocks.first().getEndTime());\n\n    Assert.assertEquals(\n        CommonDateOperations.getDateTimeFormat().parse(\"20100901-0900\"),\n        storedBlocks.last().getStartTime());\n    Assert.assertEquals(\n        CommonDateOperations.getDateTimeFormat().parse(\"20100901-1140\"),\n        storedBlocks.last().getEndTime());\n\n    SortedSet<AvailableBlock> expanded = AvailableBlockBuilder.expand(storedBlocks, 20);\n    Assert.assertEquals(16, expanded.size());\n\n    Date originalStart = CommonDateOperations.getDateTimeFormat().parse(\"20100830-0900\");\n    Date currentStart = originalStart;\n    for (AvailableBlock e : expanded) {\n      if (!DateUtils.isSameDay(e.getStartTime(), currentStart)) {\n        currentStart = DateUtils.addDays(originalStart, 2);\n      }\n      Assert.assertEquals(currentStart, e.getStartTime());\n      currentStart = DateUtils.addMinutes(currentStart, 20);\n      Assert.assertEquals(currentStart, e.getEndTime());\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7755, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 375, "tryExpressionEnd": 379, "tryBlockStart": 375, "tryBlockEnd": 488, "catchExpressionStart": 429, "catchExpressionEnd": 454, "catchBlockStart": 429, "catchBlockEnd": 488, "exceptionHandlingCallStart": [462], "exceptionHandlingCallEnd": [481], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 394, "focalAPIEnd": 421, "followUpCheck": "(!(dateTime.getDay() % 7 == 0))", "checkType": "IF", "followUpCheckExpressionStart": 648, "followUpCheckExpressionEnd": 703, "followUpCheckBlockStart": 648, "followUpCheckBlockEnd": 1156, "use": ["simpleDateFormat.format(Date)", "simpleDateFormat.format(Date)", "dateTime.getTime()"], "useStart": [798, 1081, 1190], "useEnd": [820, 1103, 1204], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bomm/thera-pi/tree/master/Reha/src/hmrCheck/HMRCheck.java", "rawCode": "  /** *************************************** */\n  @SuppressWarnings(\"deprecation\")\n  public static String hmrLetztesDatum(\n      String startdatum, int differenz, boolean samstagistwerktag) {\n    // SimpleDateFormat sd = new SimpleDateFormat(\"dd.MM.yyyy\");\n    int i = 0;\n    int werktage = 0;\n    Date date = null;\n    // System.out.println(\"Übergabe = \"+startdatum);\n\n    try {\n      date = sdDeutsch.parse(startdatum);\n    } catch (ParseException e) {\n      e.printStackTrace();\n    }\n\n    // System.out.println(\"geparstes Datum = \"+sd.format(date));\n    while (true) {\n      // System.out.println(\"Getestetes Datum = \"+sd.format(date));\n      if ((!(date.getDay() % 7 == 0)) && (samstagistwerktag)) {\n        if (!istFeiertag(date)) {\n          if (werktage == differenz) {\n            return sdDeutsch.format(date);\n          }\n          werktage++;\n        }\n      } else if ((!(date.getDay() % 7 == 0))\n          && (!samstagistwerktag)\n          && (!(date.getDay() % 6 == 0))) {\n        if (!istFeiertag(date)) {\n          if (werktage == differenz) {\n            return sdDeutsch.format(date);\n          }\n          werktage++;\n        }\n      }\n      i++;\n      date = new Date(date.getTime() + (24 * 60 * 60 * 1000));\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7756, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 247, "tryExpressionEnd": 251, "tryBlockStart": 247, "tryBlockEnd": 360, "catchExpressionStart": 291, "catchExpressionEnd": 316, "catchBlockStart": 291, "catchBlockEnd": 360, "exceptionHandlingCallStart": [330], "exceptionHandlingCallEnd": [353], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(StringUtils.isEmpty(the_text,))", "guardType": "IF {", "guardExpressionStart": 182, "guardExpressionEnd": 214, "guardBlockStart": 182, "guardBlockEnd": 241, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 266, "focalAPIEnd": 283, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nemuzuka/mishima/tree/master/src/main/java/jp/co/nemuzuka/utils/ConvertUtils.java", "rawCode": "  /**\n   * Date変換.\n   *\n   * @param source 文字列\n   * @param sdf 日付変換フォーマットオブジェクト\n   * @return Dateオブジェクト\n   */\n  public static Date toDate(String source, SimpleDateFormat sdf) {\n\n    if (StringUtils.isEmpty(source)) {\n      return null;\n    }\n\n    try {\n      return sdf.parse(source);\n    } catch (ParseException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7757, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 634, "focalAPIEnd": 668, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.parse(String)", "assertEquals(dateTime,*)", "PageHistory.getPassFailBar(dateTime,int)"], "useStart": [687, 789, 905], "useEnd": [721, 822, 942], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/unclebob/fitnesse/tree/master/test/fitnesse/responders/testHistory/PageHistoryResponderTest.java", "rawCode": "  @Test\n  public void pageHistoryShouldHaveStatsForTwoTestsIfTwoPageHistoryFilesArePresent()\n      throws Exception {\n    File pageDirectory = addPageDirectory(\"TestPage\");\n    addTestResult(pageDirectory, \"20090503110451_6_5_3_1\");\n    addTestResult(pageDirectory, \"20090418123103_1_2_3_4\");\n\n    TestHistory history = new TestHistory(resultsDirectory);\n    PageHistory pageHistory = history.getPageHistory(\"TestPage\");\n    assertEquals(2, pageHistory.size());\n    assertEquals(12, pageHistory.maxAssertions());\n    SortedSet<Date> dates = pageHistory.datesInChronologicalOrder();\n    assertEquals(2, dates.size());\n    Date date1 = dateFormat.parse(\"20090418123103\");\n    Date date2 = dateFormat.parse(\"20090503110451\");\n    Date[] dateArray = dates.toArray(new Date[dates.size()]);\n    assertEquals(date1, dateArray[1]);\n    assertEquals(date2, dateArray[0]);\n    PageHistory.PassFailBar passFailBar = pageHistory.getPassFailBar(date1, 50);\n    assertEquals(1, passFailBar.getPass());\n    assertEquals(6, passFailBar.getFail());\n    assertEquals(4, passFailBar.getPassUnits());\n    assertEquals(25, passFailBar.getFailUnits());\n    passFailBar = pageHistory.getPassFailBar(date2, 50);\n    assertEquals(6, passFailBar.getPass());\n    assertEquals(6, passFailBar.getFail());\n    assertEquals(25, passFailBar.getPassUnits());\n    assertEquals(25, passFailBar.getFailUnits());\n  }\n"}, {"dataset": "parse", "exampleID": 7758, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [214, 291, 372, 455, 544], "initializationEnd": [243, 323, 406, 495, 587], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["usage(*,String,int)"], "tryExpressionStart": 730, "tryExpressionEnd": 734, "tryBlockStart": 730, "tryBlockEnd": 918, "catchExpressionStart": 789, "catchExpressionEnd": 814, "catchBlockStart": 789, "catchBlockEnd": 918, "exceptionHandlingCallStart": [822], "exceptionHandlingCallEnd": [858], "configuration": ["the_text.length()"], "configurationStart": [169], "configurationEnd": [179], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 749, "focalAPIEnd": 764, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dateTime.getTime()"], "useStart": [749], "useEnd": [774], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/wuzbin/opentsdb/tree/master/src/tools/CliQuery.java", "rawCode": "  /** Parses the date in argument and returns a UNIX timestamp in seconds. */\n  private static long parseDate(final String s) {\n    SimpleDateFormat format;\n    switch (s.length()) {\n      case 5:\n        format = new SimpleDateFormat(\"HH:mm\");\n        break;\n      case 8:\n        format = new SimpleDateFormat(\"HH:mm:ss\");\n        break;\n      case 10:\n        format = new SimpleDateFormat(\"yyyy/MM/dd\");\n        break;\n      case 16:\n        format = new SimpleDateFormat(\"yyyy/MM/dd-HH:mm\");\n        break;\n      case 19:\n        format = new SimpleDateFormat(\"yyyy/MM/dd-HH:mm:ss\");\n        break;\n      default:\n        usage(null, \"Invalid date: \" + s, 3);\n        return -1; // Never executed as usage() exits.\n    }\n    try {\n      return format.parse(s).getTime() / 1000;\n    } catch (ParseException e) {\n      usage(null, \"Invalid date: \" + s, 3);\n      return -1; // Never executed as usage() exits.\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7759, "initialization": ["SimpleDateFormat simpleDateFormat = getDateTimeFormat()"], "initializationStart": [596], "initializationEnd": [636], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["simpleDateFormat.setTimeZone(TimeZone)"], "configurationStart": [642], "configurationEnd": [705], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 724, "focalAPIEnd": 757, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.parse(String)", "createBlock(dateTime,Date,int)"], "useStart": [774, 837], "useEnd": [807, 885], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nblair/sometime/tree/master/sometime-spi-caldav/src/test/java/org/jasig/schedassist/impl/caldav/CaldavEventUtilsImplTest.java", "rawCode": "  /**\n   * Construct an appointment for a \"group\" appointment (e.g. multiple visitor3). Compare with\n   * 'vevent-examples/example-group-appointment.ics'.\n   *\n   * @throws InputFormatException\n   * @throws IOException\n   * @throws ParserException\n   * @throws ParseException\n   */\n  @Test\n  public void testConstructGroupAppointment()\n      throws InputFormatException, IOException, ParserException, ParseException {\n    CaldavEventUtilsImpl eventUtils = new CaldavEventUtilsImpl(new NullAffiliationSourceImpl());\n    eventUtils.setExplicitSetTimeZone(false);\n\n    SimpleDateFormat dateFormat = CommonDateOperations.getDateTimeFormat();\n    dateFormat.setTimeZone(TimeZone.getTimeZone(\"America/Chicago\"));\n    Date start = dateFormat.parse(\"20110503-0800\");\n    Date end = dateFormat.parse(\"20110503-0900\");\n\n    AvailableBlock block = AvailableBlockBuilder.createBlock(start, end, 5);\n    MockCalendarAccount ownerAccount = new MockCalendarAccount();\n    ownerAccount.setDisplayName(\"OWNER NAME\");\n    ownerAccount.setEmailAddress(\"someone@wherever.org\");\n    MockScheduleOwner owner = new MockScheduleOwner(ownerAccount, 1L);\n    owner.setPreference(Preferences.MEETING_PREFIX, \"Group Appointment\");\n    owner.setPreference(Preferences.LOCATION, \"123 University Building\");\n\n    MockCalendarAccount visitorAccount = new MockCalendarAccount();\n    visitorAccount.setDisplayName(\"VISITOR NAME\");\n    visitorAccount.setEmailAddress(\"somevisitor@wherever.org\");\n    MockScheduleVisitor visitor = new MockScheduleVisitor(visitorAccount);\n    VEvent generated = eventUtils.constructAvailableAppointment(block, owner, visitor, \"Test\");\n\n    MockCalendarAccount visitorAccount2 = new MockCalendarAccount();\n    visitorAccount2.setDisplayName(\"VISITOR TWO NAME\");\n    visitorAccount2.setEmailAddress(\"somevisitor2@wherever.org\");\n    generated\n        .getProperties()\n        .add(\n            eventUtils.constructSchedulingAssistantAttendee(\n                visitorAccount2, AppointmentRole.VISITOR));\n\n    MockCalendarAccount visitorAccount3 = new MockCalendarAccount();\n    visitorAccount3.setDisplayName(\"VISITOR THREE NAME\");\n    visitorAccount3.setEmailAddress(\"somevisitor3@wherever.org\");\n    generated\n        .getProperties()\n        .add(\n            eventUtils.constructSchedulingAssistantAttendee(\n                visitorAccount3, AppointmentRole.VISITOR));\n\n    Resource example = new ClassPathResource(\"vevent-examples/example-group-appointment.ics\");\n    CalendarBuilder builder = new CalendarBuilder();\n    Calendar expectedCalendar = builder.build(example.getInputStream());\n    VEvent expectedEvent = (VEvent) expectedCalendar.getComponents(VEvent.VEVENT).get(0);\n\n    Assert.assertEquals(generated.getOrganizer(), expectedEvent.getOrganizer());\n    Assert.assertEquals(generated.getStartDate(), expectedEvent.getStartDate());\n    Assert.assertEquals(generated.getEndDate(), expectedEvent.getEndDate());\n    Assert.assertEquals(generated.getSummary(), expectedEvent.getSummary());\n    Assert.assertEquals(generated.getDescription(), expectedEvent.getDescription());\n    Assert.assertEquals(\n        generated.getProperty(VisitorLimit.VISITOR_LIMIT),\n        expectedEvent.getProperty(VisitorLimit.VISITOR_LIMIT));\n\n    // verify owner and visitors have correct roles in the example\n    Assert.assertTrue(eventUtils.isAttendingAsOwner(expectedEvent, ownerAccount));\n    Assert.assertTrue(eventUtils.isAttendingAsVisitor(expectedEvent, visitorAccount));\n    Assert.assertTrue(eventUtils.isAttendingAsVisitor(expectedEvent, visitorAccount2));\n    Assert.assertTrue(eventUtils.isAttendingAsVisitor(expectedEvent, visitorAccount3));\n    // verify owner and visitors have same roles in the generated event\n    Assert.assertTrue(eventUtils.isAttendingAsOwner(generated, ownerAccount));\n    Assert.assertTrue(eventUtils.isAttendingAsVisitor(generated, visitorAccount));\n    Assert.assertTrue(eventUtils.isAttendingAsVisitor(generated, visitorAccount2));\n    Assert.assertTrue(eventUtils.isAttendingAsVisitor(generated, visitorAccount3));\n  }\n"}, {"dataset": "parse", "exampleID": 7760, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 344, "focalAPIEnd": 374, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dateTime.getTime()", "simpleDateFormat.parse(String)"], "useStart": [344, 419], "useEnd": [384, 449], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/enwida/idpRepo/tree/master/workspace/enwida/src/test/java/de/enwida/web/ChartNavigationTest.java", "rawCode": "  @Transactional\n  private Role setupBasicRights(Role role) throws Exception {\n    final Connection connection = dataSource.getConnection();\n    final int[] tsos = new int[] {99, 199};\n    final int[] products =\n        new int[] {211, 212, 221, 222, 311, 312, 321, 322, 313, 323, 314, 324, 315, 325, 316, 326};\n    final Date time1 = new Date(dateFormat.parse(\"2009-01-01\").getTime());\n    final Date time2 = new Date(dateFormat.parse(\"2012-01-01\").getTime());\n    // final CalendarRange timeRange = new CalendarRange(time1, time2);\n\n    for (final int tso : tsos) {\n      for (final int product : products) {\n        for (final Aspect aspect : Aspect.values()) {\n          for (final DataResolution resolution : DataResolution.values()) {\n            final PreparedStatement stmt =\n                connection.prepareStatement(\n                    \"INSERT INTO users.rights (aspect,product,resolution,start_date,end_date,tso,enabled,role_id) VALUES (?,?,?,?,?,?,?,?)\");\n            stmt.setString(1, aspect.name());\n            stmt.setInt(2, product);\n            stmt.setString(3, resolution.name());\n            stmt.setDate(4, time1);\n            stmt.setDate(5, time2);\n            stmt.setInt(6, tso);\n            stmt.setBoolean(7, true);\n            stmt.setLong(8, role.getRoleID());\n            stmt.execute();\n\n            // TOO SLOW:\n            // final Right right = new Right(tso, product, resolution.name(), timeRange,\n            // aspect.name(), true);\n            // userService.saveRight(right);\n            // right.setRole(role);\n            // userService.saveRight(right);\n\n            // if (++i % 100 == 0) {\n            // System.out.println(i + \" rights inserted\");\n            // }\n          }\n        }\n      }\n    }\n    connection.close();\n    return role;\n  }\n"}, {"dataset": "parse", "exampleID": 7761, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)", "ParsePosition position = new ParsePosition(int)"], "initializationStart": [775, 858], "initializationEnd": [818, 878], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getString(String)", "new IllegalArgumentException(*)"], "tryExpressionStart": 1259, "tryExpressionEnd": 1263, "tryBlockStart": 1259, "tryBlockEnd": 1417, "catchExpressionStart": 1304, "catchExpressionEnd": 1324, "catchBlockStart": 1304, "catchBlockEnd": 1417, "exceptionHandlingCallStart": [1367, 1338], "exceptionHandlingCallEnd": [1394, 1395], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(the_text==null)", "guardType": "IF {", "guardExpressionStart": 600, "guardExpressionEnd": 614, "guardBlockStart": 600, "guardBlockEnd": 747, "focalAPI": "dateTime = simpleDateFormat.parse(the_text,position)", "focalAPIStart": 1281, "focalAPIEnd": 1296, "followUpCheck": "dateTime == null", "checkType": "IF", "followUpCheckExpressionStart": 1423, "followUpCheckExpressionEnd": 1443, "followUpCheckBlockStart": 1423, "followUpCheckBlockEnd": 1537, "use": ["dateTime.getTime()"], "useStart": [4060], "useEnd": [4077], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benjaminvm/vm/tree/master/libcore/sql/src/main/java/java/sql/Timestamp.java", "rawCode": "  /**\n   * Creates a {@code Timestamp} object with a time value equal to the time specified by a supplied\n   * String holding the time in JDBC timestamp escape format, which is {@code \"yyyy-mm-dd\n   * hh:mm:ss.nnnnnnnnn}\"\n   *\n   * @param s the {@code String} containing a time in JDBC timestamp escape format.\n   * @return A {@code Timestamp} object with time value as defined by the supplied {@code String}.\n   * @throws IllegalArgumentException if the provided string is {@code null}.\n   * @since Android 1.0\n   */\n  public static Timestamp valueOf(String s) throws IllegalArgumentException {\n    if (s == null) {\n      // sql.3=Argument cannot be null\n      throw new IllegalArgumentException(Messages.getString(\"sql.3\")); // $NON-NLS-1$\n    }\n\n    SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); // $NON-NLS-1$\n    ParsePosition pp = new ParsePosition(0);\n\n    /*\n     * First parse out the yyyy-MM-dd HH:mm:ss component of the String into\n     * a Date object using the SimpleDateFormat. This should stop after the\n     * seconds value, according to the definition of SimpleDateFormat.parse,\n     * with the ParsePosition indicating the index of the \".\" which should\n     * precede the nanoseconds value\n     */\n    Date theDate;\n    try {\n      theDate = df.parse(s, pp);\n    } catch (Exception e) {\n      throw new IllegalArgumentException(Messages.getString(\"sql.2\")); // $NON-NLS-1$\n    }\n\n    if (theDate == null) {\n      throw new IllegalArgumentException(Messages.getString(\"sql.2\")); // $NON-NLS-1$\n    }\n\n    /*\n     * If we get here, the Date part of the string was OK - now for the\n     * nanoseconds value. Strictly, this requires the remaining part of the\n     * String to look like \".nnnnnnnnn\". However, we accept anything with a\n     * '.' followed by 1 to 9 digits - we also accept nothing (no fractions\n     * of a second). Anything else is interpreted as incorrect format which\n     * will generate an IllegalArgumentException\n     */\n    int position = pp.getIndex();\n    int remaining = s.length() - position;\n    int theNanos;\n\n    if (remaining == 0) {\n      // First, allow for the case where no fraction of a second is given:\n      theNanos = 0;\n    } else {\n      /*\n       * Case where fraction of a second is specified: Require 1 character\n       * plus the \".\" in the remaining part of the string...\n       */\n      if ((s.length() - position) < \".n\".length()) { // $NON-NLS-1$\n        throw new IllegalArgumentException(Messages.getString(\"sql.2\")); // $NON-NLS-1$\n      }\n\n      /*\n       * If we're strict, we should not allow any EXTRA characters after\n       * the 9 digits\n       */\n      if ((s.length() - position) > \".nnnnnnnnn\".length()) { // $NON-NLS-1$\n        throw new IllegalArgumentException(Messages.getString(\"sql.2\")); // $NON-NLS-1$\n      }\n\n      // Require the next character to be a \".\"\n      if (s.charAt(position) != '.') {\n        // sql.4=Bad input string format: expected '.' not {0}\n        throw new NumberFormatException(\n            Messages.getString(\"sql.4\", s.charAt(position))); // $NON-NLS-1$\n      }\n      // Get the length of the number string - need to account for the '.'\n      int nanoLength = s.length() - position - 1;\n\n      // Get the 9 characters following the \".\" as an integer\n      String theNanoString = s.substring(position + 1, position + 1 + nanoLength);\n      /*\n       * We must adjust for the cases where the nanos String was not 9\n       * characters long by padding out with zeros\n       */\n      theNanoString = theNanoString + \"000000000\"; // $NON-NLS-1$\n      theNanoString = theNanoString.substring(0, 9);\n\n      try {\n        theNanos = Integer.parseInt(theNanoString);\n      } catch (Exception e) {\n        // If we get here, the string was not a number\n        throw new IllegalArgumentException(Messages.getString(\"sql.2\")); // $NON-NLS-1$\n      }\n    }\n\n    if (theNanos < 0 || theNanos > 999999999) {\n      throw new IllegalArgumentException(Messages.getString(\"sql.2\")); // $NON-NLS-1$\n    }\n\n    Timestamp theTimestamp = new Timestamp(theDate.getTime());\n    theTimestamp.setNanos(theNanos);\n\n    return theTimestamp;\n  }\n"}, {"dataset": "parse", "exampleID": 7762, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new RuntimeException(*)"], "tryExpressionStart": 81, "tryExpressionEnd": 85, "tryBlockStart": 81, "tryBlockEnd": 491, "catchExpressionStart": 422, "catchExpressionEnd": 447, "catchBlockStart": 422, "catchBlockEnd": 491, "exceptionHandlingCallStart": [461], "exceptionHandlingCallEnd": [484], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 131, "focalAPIEnd": 189, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/moonjava/moonjava-flight/tree/master/src/main/java/br/com/moonjava/flight/util/FormatDateTime.java", "rawCode": "  public static String parseToStringDateTime(String value, String country) {\n    try {\n      String time = null;\n      Date date = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\").parse(value);\n      if (country.equals(\"US\")) {\n        time = new SimpleDateFormat(\"MM/dd/yyyy hh:mm:ss aa\").format(date);\n      } else {\n        time = new SimpleDateFormat(\"dd/MM/yyyy HH:mm:ss\").format(date);\n      }\n      return time;\n    } catch (ParseException e) {\n      throw new RuntimeException(e);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7763, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 251, "tryExpressionEnd": 255, "tryBlockStart": 251, "tryBlockEnd": 409, "catchExpressionStart": 350, "catchExpressionEnd": 375, "catchBlockStart": 350, "catchBlockEnd": 409, "exceptionHandlingCallStart": [383], "exceptionHandlingCallEnd": [402], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 270, "focalAPIEnd": 342, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/msjackso/DesperateHousePi/tree/master/DesperateHousePi/desperatehousepi/Tests/TestRelationship.java", "rawCode": "  @Test\n  public void testFirstMet() {\n\n    // Test full constructor\n    Relationship r = new Relationship(\"Michael Jackson\", \"Brad Brauner\", \"127.0.0.1\", 0);\n    assertNotNull(r);\n\n    r.setFirstMet(\"10/02/1992 10:10:10\");\n\n    Date date = null;\n    try {\n      date = new SimpleDateFormat(\"MM/dd/yyyy HH:mm:ss\").parse(\"10/02/1992 10:10:10\");\n    } catch (ParseException e) {\n      e.printStackTrace();\n    }\n\n    assertEquals(r.getFirstMet(), date);\n  }\n"}, {"dataset": "parse", "exampleID": 7764, "initialization": ["String the_text = getString(String)"], "initializationStart": [6076], "initializationEnd": [6107], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "the_text!=null", "guardType": "IF {", "guardExpressionStart": 6171, "guardExpressionEnd": 6199, "guardBlockStart": 6171, "guardBlockEnd": 6262, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 6222, "focalAPIEnd": 6253, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.parse(String)", "createObservedValue(String,*,dateTime,Date,String,String,String,*)"], "useStart": [6398, 6539], "useEnd": [6427, 6763], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/molgenis/molgenis_apps-legacy/tree/master/apps/animaldb/org/molgenis/animaldb/convertors/rhutdb/ConvertRhutDbToPheno.java", "rawCode": "  public void populateAnimal(String filename) throws Exception {\n    final Date now = new Date();\n\n    File file = new File(filename);\n    CsvFileReader reader = new CsvFileReader(file);\n    for (Tuple tuple : reader) {\n      String animalName = \"mm_\" + ct.prependZeros(Integer.toString(highestNr++), 6);\n      animalNames.add(animalName);\n      Individual newAnimal = ct.createIndividual(invName, animalName, userName);\n      animalsToAddList.add(newAnimal);\n\n      // ID -> OldRhutDbAnimalId\n      String oldAnimalId = tuple.getString(\"ID\");\n      valuesToAddList.add(\n          ct.createObservedValue(\n              invName,\n              appMap.get(\"SetOldRhutDbAnimalId\"),\n              now,\n              null,\n              \"OldRhutDbAnimalId\",\n              animalName,\n              oldAnimalId,\n              null));\n      animalMap.put(oldAnimalId, animalName);\n\n      // Species (always Mus musculus)\n      valuesToAddList.add(\n          ct.createObservedValue(\n              invName,\n              appMap.get(\"SetSpecies\"),\n              now,\n              null,\n              \"Species\",\n              animalName,\n              null,\n              \"House mouse\"));\n\n      // litter nr -> OldRhutDbLitterId + AnimalType (if -1 then\n      // animaltype=GMO, if 0 then animaltype=WT (Gewoon dier))\n      String litterId = tuple.getString(\"litter nr\");\n      List<String> animalNameList;\n      if (litterMap.get(litterId) != null) {\n        animalNameList = litterMap.get(litterId);\n      } else {\n        animalNameList = new ArrayList<String>();\n      }\n      animalNameList.add(animalName);\n      litterMap.put(litterId, animalNameList);\n      valuesToAddList.add(\n          ct.createObservedValue(\n              invName,\n              appMap.get(\"SetOldRhutDbLitterId\"),\n              now,\n              null,\n              \"OldRhutDbLitterId\",\n              animalName,\n              litterId,\n              null));\n      String animalType = \"B. Transgeen dier\";\n      if (litterId != null && litterId.equals(\"0\")) {\n        animalType = \"A. Gewoon dier\";\n      }\n      valuesToAddList.add(\n          ct.createObservedValue(\n              invName,\n              appMap.get(\"SetAnimalType\"),\n              now,\n              null,\n              \"AnimalType\",\n              animalName,\n              animalType,\n              null));\n\n      // Sex -> Sex (0 = female, 1 = male)\n      Integer sex = tuple.getInt(\"Sex\");\n      if (sex != null) {\n        String sexName;\n        if (sex == 0) {\n          sexName = \"Female\";\n        } else {\n          sexName = \"Male\";\n        }\n        valuesToAddList.add(\n            ct.createObservedValue(\n                invName, appMap.get(\"SetSex\"), now, null, \"Sex\", animalName, null, sexName));\n      }\n\n      // Genotype -> Background (default C57BL/6j and otherwise CBA/CaJ)\n      // or Genotype (GeneModification + GeneState)\n      String background = tuple.getString(\"Genotype\");\n      if (background != null) {\n        String backgroundName;\n        if (background.equals(\"CBA/CaJ\")) {\n          backgroundName = \"CBA/CaJ\";\n        } else {\n          backgroundName = \"C57BL/6j\";\n        }\n        valuesToAddList.add(\n            ct.createObservedValue(\n                invName,\n                appMap.get(\"SetBackground\"),\n                now,\n                null,\n                \"Background\",\n                animalName,\n                null,\n                backgroundName));\n      }\n\n      // Genotyped as -> Genotype (GeneModification + GeneState)\n      String genotype = tuple.getString(\"Genotyped as\");\n      // if empty, try Genotype column (stored as background)\n      if (genotype == null\n          && background != null\n          && (background.contains(\"Cry\") || background.contains(\"Per\"))) {\n        genotype = background;\n      }\n      if (genotype != null) {\n        String geneState;\n        String geneName;\n        String geneNameBase = null;\n        if (genotype.contains(\"Cry\")) geneNameBase = \"Cry\";\n        if (genotype.contains(\"Per\")) geneNameBase = \"Per\";\n        int index1 = genotype.indexOf(\"1\");\n        if (index1 != -1) {\n          geneName = geneNameBase + \"1\";\n          geneName += \" KO\";\n          geneState = genotype.substring(index1 + 1, index1 + 4);\n          if (geneState.equals(\"-/+\")) geneState = \"+/-\";\n          valuesToAddList.add(\n              ct.createObservedValue(\n                  invName,\n                  appMap.get(\"SetGenotype1\"),\n                  now,\n                  null,\n                  \"GeneModification\",\n                  animalName,\n                  geneName,\n                  null));\n          valuesToAddList.add(\n              ct.createObservedValue(\n                  invName,\n                  appMap.get(\"SetGenotype1\"),\n                  now,\n                  null,\n                  \"GeneState\",\n                  animalName,\n                  geneState,\n                  null));\n        }\n        int index2 = genotype.indexOf(\"2\");\n        if (index2 != -1) {\n          geneName = geneNameBase + \"2\";\n          geneName += \" KO\";\n          geneState = genotype.substring(index2 + 1, index2 + 4);\n          if (geneState.equals(\"-/+\")) geneState = \"+/-\";\n          valuesToAddList.add(\n              ct.createObservedValue(\n                  invName,\n                  appMap.get(\"SetGenotype2\"),\n                  now,\n                  null,\n                  \"GeneModification\",\n                  animalName,\n                  geneName,\n                  null));\n          valuesToAddList.add(\n              ct.createObservedValue(\n                  invName,\n                  appMap.get(\"SetGenotype2\"),\n                  now,\n                  null,\n                  \"GeneState\",\n                  animalName,\n                  geneState,\n                  null));\n        }\n      }\n\n      // arrival date and rem date -> Active start and end time\n      // Don't set DeathDate (to rem date) because we do not know if the\n      // animal was terminated or removed\n      String state = \"Alive\";\n      String startDateString = tuple.getString(\"arrival date\");\n      Date startDate = null;\n      Date remDate = null;\n      if (startDateString != null) {\n        startDate = dbFormat.parse(startDateString);\n      }\n      String remDateString = tuple.getString(\"rem date\");\n      if (remDateString != null) {\n        state = \"Dead\";\n        remDate = dbFormat.parse(remDateString);\n        removalDateMap.put(animalName, remDate);\n      }\n      activeMap.put(\n          animalName,\n          ct.createObservedValue(\n              invName,\n              appMap.get(\"SetActive\"),\n              startDate,\n              remDate,\n              \"Active\",\n              animalName,\n              state,\n              null));\n\n      // rem cause -> Removal\n      String removal = tuple.getString(\"rem cause\");\n      if (removal != null && remDate != null) {\n        valuesToAddList.add(\n            ct.createObservedValue(\n                invName,\n                appMap.get(\"SetRemoval\"),\n                remDate,\n                null,\n                \"Removal\",\n                animalName,\n                removal,\n                null));\n      }\n\n      // remarks -> Source + sometimes DoB\n      String source = tuple.getString(\"remarks\");\n      if (source != null) {\n        String sourceName = null;\n        if (source.contains(\"Erasmus\")) sourceName = \"ErasmusMC\";\n        if (source.contains(\"Jaap\")) sourceName = defaultSourceName;\n        if (source.contains(\"Arjen\")) sourceName = defaultSourceName;\n        if (source.contains(\"arlan\")) sourceName = \"Harlan\";\n        if (source.contains(\"Jackson\")) sourceName = \"JacksonCharlesRiver\";\n        valuesToAddList.add(\n            ct.createObservedValue(\n                invName,\n                appMap.get(\"SetSource\"),\n                now,\n                null,\n                \"Source\",\n                animalName,\n                null,\n                sourceName));\n        sourceMap.put(animalName, sourceName);\n        if (source.toUpperCase().contains(\"DOB\")) {\n          int start = source.toUpperCase().indexOf(\"DOB\");\n          Pattern p = Pattern.compile(\"(\\\\d+)-(\\\\d+)-(\\\\d+)\");\n          Matcher m = p.matcher(source.substring(start));\n          if (m.find()) {\n            String year = m.group(3);\n            if (year.length() == 1) {\n              year = \"200\" + year;\n            }\n            String dobDateString = m.group(1) + \"-\" + m.group(2) + \"-\" + year;\n            Date dobDate = dobFormat.parse(dobDateString);\n            dobDateString = newDateOnlyFormat.format(dobDate);\n            valuesToAddList.add(\n                ct.createObservedValue(\n                    invName,\n                    appMap.get(\"SetDateOfBirth\"),\n                    remDate,\n                    null,\n                    \"DateOfBirth\",\n                    animalName,\n                    dobDateString,\n                    null));\n          }\n        }\n      } else {\n        // Default source:\n        valuesToAddList.add(\n            ct.createObservedValue(\n                invName,\n                appMap.get(\"SetSource\"),\n                now,\n                null,\n                \"Source\",\n                animalName,\n                null,\n                defaultSourceName));\n      }\n\n      // Ear Code -> Earmark (R -> 1 r, L -> 1 l, RL -> 1 r 1 l)\n      String earmark = tuple.getString(\"Ear Code\");\n      if (earmark != null) {\n        if (earmark.equals(\"R\")) earmark = \"1 r\";\n        if (earmark.equals(\"L\")) earmark = \"1 l\";\n        if (earmark.equals(\"RL\")) earmark = \"1 r 1 l\";\n        valuesToAddList.add(\n            ct.createObservedValue(\n                invName,\n                appMap.get(\"SetEarmark\"),\n                now,\n                null,\n                \"Earmark\",\n                animalName,\n                earmark,\n                null));\n      }\n\n      // sample date -> OldRhutDbSampleDate\n      String sampleDate = tuple.getString(\"sample date\");\n      if (sampleDate != null) {\n        valuesToAddList.add(\n            ct.createObservedValue(\n                invName,\n                appMap.get(\"SetOldRhutDbSampleDate\"),\n                now,\n                null,\n                \"OldRhutDbSampleDate\",\n                animalName,\n                sampleDate,\n                null));\n      }\n\n      // sample nr -> OldRhutDbSampleNr\n      String sampleNr = tuple.getString(\"sample nr\");\n      if (sampleNr != null) {\n        valuesToAddList.add(\n            ct.createObservedValue(\n                invName,\n                appMap.get(\"SetOldRhutDbSampleNr\"),\n                now,\n                null,\n                \"OldRhutDbSampleNr\",\n                animalName,\n                sampleNr,\n                null));\n      }\n\n      // Transp ID -> TransponderId -> SKIP (not filled in)\n      // Fenotyped as -> SKIP (not filled in)\n      // To Be Removed -> SKIP\n      // Cage nr -> SKIP (not filled in)\n\n      // ResponsibleResearcher\n      valuesToAddList.add(\n          ct.createObservedValue(\n              invName,\n              appMap.get(\"SetResponsibleResearcher\"),\n              now,\n              null,\n              \"ResponsibleResearcher\",\n              animalName,\n              \"Roelof Hut\",\n              null));\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7765, "initialization": ["String the_text = getText(Element,String)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [346, 1281], "initializationEnd": [371, 1324], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new OmUnexpectedException(*)"], "tryExpressionStart": 1067, "tryExpressionEnd": 1071, "tryBlockStart": 1067, "tryBlockEnd": 1543, "catchExpressionStart": 1413, "catchExpressionEnd": 1438, "catchBlockStart": 1413, "catchBlockEnd": 1543, "exceptionHandlingCallStart": [1508], "exceptionHandlingCallEnd": [1536], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 1389, "focalAPIEnd": 1405, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.10.2/trunk-archive/src/om/tnavigator/TestDeployment.java", "rawCode": "  /**\n   * @param sTag Date tag to compare\n   * @param sDefaultTime Default time for that tag if only date is specified\n   * @return Java date object\n   * @throws OmFormatException\n   */\n  private Date getActualDate(String sTag, String sDefaultTime) throws OmFormatException {\n    String sDate;\n    try {\n      // Get the date text\n      sDate = XML.getText(eDates, sTag);\n    } catch (XMLException xe) {\n      // Shouldn't happen because we just checked hasChild\n      throw new OmUnexpectedException(xe);\n    }\n\n    // Check it with regex\n    Matcher m = DATETIME.matcher(sDate);\n    if (!m.matches()) throw new OmFormatException(\"Invalid date: \" + sDate);\n    if (m.group(1) == null) {\n      // No time specified, use default\n      sDate += \" \" + sDefaultTime;\n    } else {\n      // Check time\n      String sTime = m.group(1);\n      Matcher mPart = PARTTIME.matcher(sTime);\n      if (mPart.matches()) {\n        sDate += \":00\";\n      } else if (!FULLTIME.matcher(sTime).matches()) {\n        throw new OmFormatException(\"Invalid time: \" + sDate);\n      }\n    }\n\n    try {\n      // OK, we now have a full date and time string, let's parse it\n      // (note that this SDF isn't static because apparently they aren't\n      // supposed to be thread-safe)\n      SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n      // We're using the local time zone (I hope)\n      return sdf.parse(sDate);\n    } catch (ParseException e) {\n      // Shouldn't happen because we validated the date\n      throw new OmUnexpectedException(e);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7766, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [58], "initializationEnd": [98], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 175, "tryExpressionEnd": 179, "tryBlockStart": 175, "tryBlockEnd": 274, "catchExpressionStart": 220, "catchExpressionEnd": 240, "catchBlockStart": 220, "catchBlockEnd": 274, "exceptionHandlingCallStart": [248], "exceptionHandlingCallEnd": [267], "configuration": ["simpleDateFormat.setCalendar(Calendar)"], "configurationStart": [104], "configurationEnd": [169], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 198, "focalAPIEnd": 212, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/onlyjonas/Sonnenwind/tree/master/WSPRSimple/code/swp/WSPRSpot.java", "rawCode": "  protected void createDate() {\n    SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd kk:mm\");\n    df.setCalendar(Calendar.getInstance(TimeZone.getTimeZone(\"UTC\")));\n    try {\n      spotDate = df.parse(date);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7767, "initialization": ["String the_text = DateConverter.toString(Date)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [321, 621], "initializationEnd": [345, 668], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 692, "focalAPIEnd": 707, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["assertEquals(dateTime,Date)", "assertEquals(dateTime,Date)", "simpleDateFormat.parse(String)", "assertEquals(dateTime,Date)", "simpleDateFormat.parse(String)"], "useStart": [713, 942, 1100, 1121, 1185], "useEnd": [752, 981, 1115, 1160, 1221], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/8nevil8/xstream/tree/master/xstream/src/test/com/thoughtworks/xstream/converters/basic/DateConverterTest.java", "rawCode": "  public void testUnmarshalsDateWithDifferentDefaultTimeZones() throws ParseException {\n    converter = new DateConverter((TimeZone) null); // use default TZ\n    Calendar cal = Calendar.getInstance();\n    cal.clear();\n    cal.set(2004, Calendar.FEBRUARY, 23, 1, 46, 4);\n    Date date = cal.getTime();\n    String strIST = converter.toString(date);\n    assertEquals(\"2004-02-23 01:46:04.0 IST\", strIST);\n    // select arbitrary TZ\n    TimeZone.setDefault(TimeZone.getTimeZone(\"EST\"));\n    // compare parsed date with JDK implementation\n    Date dateRetrieved = (Date) converter.fromString(strIST);\n    SimpleDateFormat f = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S z\");\n    Date simpleDate = f.parse(strIST);\n    assertEquals(simpleDate, dateRetrieved);\n    // DateConverter does not get influenced by change of current TZ ...\n    TimeZone.setDefault(TimeZone.getTimeZone(\"UTC\"));\n    dateRetrieved = (Date) converter.fromString(strIST);\n    assertEquals(simpleDate, dateRetrieved);\n    // ... as well as the SimpleDateFormat\n    f = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S z\");\n    simpleDate = f.parse(strIST);\n    assertEquals(simpleDate, dateRetrieved);\n    assertEquals(date, f.parse(\"2004-02-22 20:16:04.0 UTC\"));\n    // assertEquals(date, simpleDate); off by +03:30 ... but why ??\n  }\n"}, {"dataset": "parse", "exampleID": 7768, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [165], "initializationEnd": [207], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 224, "focalAPIEnd": 268, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setCurrentTime(dateTime)", "simpleDateFormat.parse(String)"], "useStart": [274, 401], "useEnd": [303, 444], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/1and1/Activiti-internal/tree/master/modules/activiti-engine/src/test/java/org/activiti/standalone/calendar/CycleBusinessCalendarTest.java", "rawCode": "  public void testSimpleCron() throws Exception {\n    CycleBusinessCalendar businessCalendar = new CycleBusinessCalendar();\n\n    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy MM dd - HH:mm\");\n    Date now = simpleDateFormat.parse(\"2011 03 11 - 17:23\");\n    ClockUtil.setCurrentTime(now);\n\n    Date duedate = businessCalendar.resolveDuedate(\"0 0 0 1 * ?\");\n\n    Date expectedDuedate = simpleDateFormat.parse(\"2011 04 1 - 00:00\");\n\n    assertEquals(expectedDuedate, duedate);\n  }\n"}, {"dataset": "parse", "exampleID": 7769, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [75], "initializationEnd": [109], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new Date()"], "tryExpressionStart": 139, "tryExpressionEnd": 143, "tryBlockStart": 139, "tryBlockEnd": 246, "catchExpressionStart": 189, "catchExpressionEnd": 214, "catchBlockStart": 189, "catchBlockEnd": 246, "exceptionHandlingCallStart": [229], "exceptionHandlingCallEnd": [239], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 158, "focalAPIEnd": 181, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/deschbach/de.htwg.seapal.person/tree/master/app/de/htwg/seapal/person/views/tui/EditPersonTuiState.java", "rawCode": "  private Date parseDate(String input) {\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"dd.MM.yyyy\");\n\n    Date date = null;\n\n    try {\n      date = dateFormat.parse(input);\n    } catch (ParseException e) {\n      date = new Date();\n    }\n\n    return date;\n  }\n"}, {"dataset": "parse", "exampleID": 7770, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [87], "initializationEnd": [133], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 152, "focalAPIEnd": 169, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["println(dateTime)"], "useStart": [176], "useEnd": [200], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/fits/try_samples/tree/master/blog/20140427/parse_isodate/Sample1.java", "rawCode": "  public static void main(String... args) throws Exception {\n    SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssX\");\n\n    Date date = df.parse(args[0]);\n\n    System.out.println(date);\n  }\n"}, {"dataset": "parse", "exampleID": 7771, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(*)"], "initializationStart": [190], "initializationEnd": [237], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 243, "focalAPIEnd": 264, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nitromannitol/testng-plugin-modification/tree/master/src/test/java/hudson/plugins/testng/parser/TestParser.java", "rawCode": "  @Test\n  public void testDateParser() throws ParseException {\n    // example of date format used in testng report\n    String dateString = \"2010-07-20T11:49:17Z\";\n    SimpleDateFormat sdf = new SimpleDateFormat(ResultsParser.DATE_FORMAT);\n    sdf.parse(dateString);\n  }\n"}, {"dataset": "parse", "exampleID": 7772, "initialization": ["String the_text = substring(int,*)", "SimpleDateFormat simpleDateFormat = formatFor(*)"], "initializationStart": [1125, 1260], "initializationEnd": [1171, 1298], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["the_text.length()", "the_text.substring(int,*)", "simpleDateFormat.set2DigitYearStart(Date)"], "configurationStart": [1025, 1125, 1306], "configurationEnd": [1043, 1171, 1346], "guardCondition": "!(the_text==null)", "guardType": "IF {", "guardExpressionStart": 693, "guardExpressionEnd": 715, "guardBlockStart": 693, "guardBlockEnd": 786, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 1376, "focalAPIEnd": 1403, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/onedanshow/Screen-Courter/tree/master/lib/src/org/apache/http/impl/cookie/DateUtils.java", "rawCode": "  /**\n   * Parses the date value using the given date formats.\n   *\n   * @param dateValue the date value to parse\n   * @param dateFormats the date formats to use\n   * @param startDate During parsing, two digit years will be placed in the range <code>startDate\n   *     </code> to <code>startDate + 100 years</code>. This value may be <code>null</code>. When\n   *     <code>null</code> is given as a parameter, year <code>2000</code> will be used.\n   * @return the parsed date\n   * @throws DateParseException if none of the dataFormats could parse the dateValue\n   */\n  public static Date parseDate(String dateValue, String[] dateFormats, Date startDate)\n      throws DateParseException {\n\n    if (dateValue == null) {\n      throw new IllegalArgumentException(\"dateValue is null\");\n    }\n    if (dateFormats == null) {\n      dateFormats = DEFAULT_PATTERNS;\n    }\n    if (startDate == null) {\n      startDate = DEFAULT_TWO_DIGIT_YEAR_START;\n    }\n    // trim single quotes around date if present\n    // see issue #5279\n    if (dateValue.length() > 1 && dateValue.startsWith(\"'\") && dateValue.endsWith(\"'\")) {\n      dateValue = dateValue.substring(1, dateValue.length() - 1);\n    }\n\n    for (String dateFormat : dateFormats) {\n      SimpleDateFormat dateParser = DateFormatHolder.formatFor(dateFormat);\n      dateParser.set2DigitYearStart(startDate);\n\n      try {\n        return dateParser.parse(dateValue);\n      } catch (ParseException pe) {\n        // ignore this exception, we will try the next format\n      }\n    }\n\n    // we were unable to parse the date\n    throw new DateParseException(\"Unable to parse the date \" + dateValue);\n  }\n"}, {"dataset": "parse", "exampleID": 7773, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 350, "focalAPIEnd": 372, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dateTime.getTime()"], "useStart": [392], "useEnd": [407], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lietou/insight/tree/master/cat-home/src/test/java/com/dianping/cat/report/analyzer/CatStateAnalyzer.java", "rawCode": "  @Test\n  public void test() throws ParseException {\n    StringBuilder sb = new StringBuilder();\n\n    sb.append(\"Date\").append('\\t').append(\"total\").append('\\t').append(\"m_loss\").append('\\t');\n    sb.append(\"avgNumber\").append('\\t').append(\"dumpSize\").append('\\n');\n\n    System.out.println(sb);\n    String startDate = \"2012/11/01\";\n\n    Date start = m_sdf.parse(startDate);\n    for (long i = start.getTime(); i < System.currentTimeMillis(); i = i + TimeUtil.ONE_DAY) {\n      State state = buildState(new Date(i));\n\n      System.out.println(state);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7774, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [162, 292], "initializationEnd": [205, 332], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new UnsupportedOperationException(String)"], "tryExpressionStart": 464, "tryExpressionEnd": 468, "tryBlockStart": 464, "tryBlockEnd": 592, "catchExpressionStart": 510, "catchExpressionEnd": 535, "catchBlockStart": 510, "catchBlockEnd": 592, "exceptionHandlingCallStart": [549], "exceptionHandlingCallEnd": [585], "configuration": ["simpleDateFormat.setTimeZone(TimeZone)"], "configurationStart": [407], "configurationEnd": [458], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 483, "focalAPIEnd": 502, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/plantuml/tree/master/tags/plantuml-7938/src/net/sourceforge/plantuml/acearth/PSystemXearth.java", "rawCode": "  private Date extractGmt(String s) {\n    final SimpleDateFormat timeFormat;\n    if (s.matches(\"\\\\d{4}/\\\\d{2}/\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2}\")) {\n      timeFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n    } else if (s.matches(\"\\\\d{4}/\\\\d{2}/\\\\d{2} \\\\d{2}:\\\\d{2}\")) {\n      timeFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm\");\n    } else {\n      throw new UnsupportedOperationException(s);\n    }\n    timeFormat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    try {\n      return timeFormat.parse(s);\n    } catch (ParseException e) {\n      throw new UnsupportedOperationException(s);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7775, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [299], "initializationEnd": [337], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["simpleDateFormat.setTimeZone(TimeZone)"], "configurationStart": [343], "configurationEnd": [395], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 428, "focalAPIEnd": 462, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Kryo.writeObject(ByteBuffer,dateTime)", "assertEquals(dateTime,Date)"], "useStart": [649, 769], "useEnd": [682, 816], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mxro/osgi-maven/tree/master/thrdKryo/src/test/java/de/mxro/thrd/kryo/tests/TestDate.java", "rawCode": "  /**\n   * Test due to a bug re date storing in Appjangle cloud.\n   *\n   * @throws ParseException\n   * @see https ://groups.google.com/forum/?fromgroups=#!topic/kryo-users/kZacb0ikW98\n   */\n  @Test\n  public void test_serialize_date() throws ParseException {\n\n    final SimpleDateFormat dateFormat = new SimpleDateFormat(\"dd/MM/yy hh:mm\");\n    dateFormat.setTimeZone(TimeZone.getTimeZone(\"NZDT\"));\n\n    final Date expectedDate = dateFormat.parse(\"22/02/13 11:00\");\n\n    final Kryo kryo = new Kryo();\n    kryo.setRegistrationOptional(true);\n    kryo.register(Date.class, new DateSerializer());\n\n    final ByteBuffer b = ByteBuffer.allocate(100);\n\n    kryo.writeObject(b, expectedDate);\n\n    b.rewind();\n\n    final Date deserialized = kryo.readObject(b, Date.class);\n\n    Assert.assertEquals(expectedDate, deserialized);\n  }\n"}, {"dataset": "parse", "exampleID": 7776, "initialization": ["String the_text = getString(String,*)"], "initializationStart": [262], "initializationEnd": [332], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new IllegalStateException(String)"], "tryExpressionStart": 481, "tryExpressionEnd": 485, "tryBlockStart": 481, "tryBlockEnd": 1046, "catchExpressionStart": 884, "catchExpressionEnd": 909, "catchBlockStart": 884, "catchBlockEnd": 1046, "exceptionHandlingCallStart": [958], "exceptionHandlingCallEnd": [1039], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 515, "focalAPIEnd": 577, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/BobEvans/omgpaco/tree/master/PacoAndroidLib/src/com/google/sampling/experiential/android/lib/GoogleAccountLoginHelper.java", "rawCode": "  /**\n   * Retrieve the stored Paco appengine server login cookie.\n   *\n   * @return Cookie\n   */\n  public synchronized Cookie retrievePacoAuthCookie() {\n    String name = authTokenPreferences.getString(AUTH_TOKEN_PREFERENCE_NAME_KEY, null);\n    String expiry = authTokenPreferences.getString(AUTH_TOKEN_PREFERENCE_EXPIRE_KEY, null);\n    if (!isPacoAuthCookieSetAndValid(name, expiry)) {\n      throw new IllegalStateException(\"Invalid Auth Cookie! Send back to login!\");\n    }\n    try {\n      Date expirationDate = new SimpleDateFormat(Constants.DATE_TIME_FORMAT).parse(expiry);\n      return new MyCookie(\n          name,\n          authTokenPreferences.getString(\"value\", \"\"),\n          expirationDate,\n          authTokenPreferences.getString(\"domain\", \"google.com\"),\n          authTokenPreferences.getString(\"path\", \"/\"),\n          authTokenPreferences.getInt(\"version\", 0));\n    } catch (ParseException e) {\n      // this should never happen.\n      throw new IllegalStateException(\"Unparseable date in Auth Cookie! Send back to login!\");\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7777, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 72, "focalAPIEnd": 104, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.parse(String)"], "useStart": [120], "useEnd": [152], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/araqne/logdb/tree/master/araqne-logdb/src/test/java/org/araqne/logdb/query/expr/DateDiffAddTest.java", "rawCode": "  @Before\n  public void setup() throws ParseException {\n    startDate = sdf.parse(\"2014-09-18 13:55:00\");\n    endDate = sdf.parse(\"2015-09-18 13:55:00\");\n  }\n"}, {"dataset": "parse", "exampleID": 7778, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [434], "initializationEnd": [478], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "the_text!=null&&the_text.length()!=8", "guardType": "IF {", "guardExpressionStart": 235, "guardExpressionEnd": 276, "guardBlockStart": 235, "guardBlockEnd": 779, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 505, "focalAPIEnd": 528, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setTime(dateTime)"], "useStart": [488], "useEnd": [529], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/baohaojun/davmail/tree/master/src/java/davmail/util/StringUtil.java", "rawCode": "  /**\n   * Get allday date value from zulu timestamp.\n   *\n   * @param value zulu datetime\n   * @return yyyyMMdd allday date value\n   */\n  public static String convertZuluDateTimeToAllDay(String value) {\n    String result = value;\n    if (value != null && value.length() != 8) {\n      // try to convert datetime value to date value\n      try {\n        Calendar calendar = Calendar.getInstance();\n        SimpleDateFormat dateParser = new SimpleDateFormat(\"yyyyMMdd'T'HHmmss'Z'\");\n        calendar.setTime(dateParser.parse(value));\n        calendar.add(Calendar.HOUR_OF_DAY, 12);\n        SimpleDateFormat dateFormatter = new SimpleDateFormat(\"yyyyMMdd\");\n        result = dateFormatter.format(calendar.getTime());\n      } catch (ParseException e) {\n        // ignore\n      }\n    }\n    return result;\n  }\n"}, {"dataset": "parse", "exampleID": 7779, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 622, "focalAPIEnd": 662, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(dateTime)", "simpleDateFormat.parse(String)"], "useStart": [616, 797], "useEnd": [663, 837], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/victortey/geotool/tree/master/modules/extension/xsd/xsd-wfs/src/test/java/org/geotools/wfs/v2_0/bindings/ValueCollectionTypeBindingTest.java", "rawCode": "  public void testEncode() throws Exception {\n    SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder();\n    tb.setName(\"feature\");\n    tb.setNamespaceURI(\"http://geotools.org\");\n    tb.add(\"geom\", Point.class);\n    tb.add(\"str\", String.class);\n    tb.add(\"int\", Integer.class);\n    tb.add(\"date\", Date.class);\n\n    SimpleFeatureType featureType = tb.buildFeatureType();\n    SimpleFeatureBuilder b = new SimpleFeatureBuilder(featureType);\n\n    DefaultFeatureCollection features = new DefaultFeatureCollection(null, null);\n\n    b.add(new WKTReader().read(\"POINT(0 0)\"));\n    b.add(\"zero\");\n    b.add(\"0\");\n    b.add(DATE_FORMAT.parse(\"2011-06-20 00:00:00\"));\n    features.add(b.buildFeature(null));\n\n    b.add(new WKTReader().read(\"POINT(1 1)\"));\n    b.add(\"one\");\n    b.add(\"1\");\n    b.add(DATE_FORMAT.parse(\"2011-06-20 11:11:11\"));\n    features.add(b.buildFeature(null));\n\n    ValueCollectionType vc = Wfs20Factory.eINSTANCE.createValueCollectionType();\n    vc.getMember().add(new PropertyValueCollection(features, featureType.getDescriptor(\"geom\")));\n\n    Document doc = encode(vc, WFS.ValueCollection);\n    assertEquals(\"wfs:ValueCollection\", doc.getDocumentElement().getNodeName());\n    assertEquals(2, getElementsByQName(doc, WFS.member).getLength());\n\n    NodeList geoms = getElementsByQName(doc, new QName(\"http://geotools.org\", \"geom\"));\n    assertEquals(2, geoms.getLength());\n\n    assertNotNull(getElementByQName((Element) geoms.item(0), GML.Point));\n    assertNotNull(getElementByQName((Element) geoms.item(1), GML.Point));\n\n    vc = Wfs20Factory.eINSTANCE.createValueCollectionType();\n    vc.getMember().add(new PropertyValueCollection(features, featureType.getDescriptor(\"str\")));\n\n    doc = encode(vc, WFS.ValueCollection);\n    assertEquals(\"wfs:ValueCollection\", doc.getDocumentElement().getNodeName());\n    assertEquals(2, getElementsByQName(doc, WFS.member).getLength());\n\n    NodeList strs = getElementsByQName(doc, new QName(\"http://geotools.org\", \"str\"));\n    assertEquals(2, strs.getLength());\n\n    Set vals = new HashSet(Arrays.asList(\"zero\", \"one\"));\n    vals.remove(strs.item(0).getFirstChild().getNodeValue());\n    vals.remove(strs.item(1).getFirstChild().getNodeValue());\n    assertTrue(vals.isEmpty());\n\n    vc = Wfs20Factory.eINSTANCE.createValueCollectionType();\n    vc.getMember().add(new PropertyValueCollection(features, featureType.getDescriptor(\"date\")));\n\n    doc = encode(vc, WFS.ValueCollection);\n    assertEquals(\"wfs:ValueCollection\", doc.getDocumentElement().getNodeName());\n    assertEquals(2, getElementsByQName(doc, WFS.member).getLength());\n\n    // print(doc);\n    NodeList dates = getElementsByQName(doc, new QName(\"http://geotools.org\", \"date\"));\n    assertEquals(2, dates.getLength());\n  }\n"}, {"dataset": "parse", "exampleID": 7780, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)", "String the_text = String.trim()"], "initializationStart": [131, 218], "initializationEnd": [160, 235], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["simpleDateFormat.setLenient(boolean)", "the_text.trim()"], "configurationStart": [166, 218], "configurationEnd": [187, 235], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 250, "focalAPIEnd": 271, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Calendar.setTime(dateTime)"], "useStart": [329], "useEnd": [351], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dvn/dvn-svn-import-test4/tree/master/tags/release-2.1/src/DVN-web/src/edu/harvard/iq/dvn/core/web/util/DateValidator.java", "rawCode": "  private boolean isValid(String dateString, String pattern) {\n    boolean valid = true;\n    Date date;\n    SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n    sdf.setLenient(false);\n    try {\n      dateString = dateString.trim();\n      date = sdf.parse(dateString);\n      Calendar calendar = Calendar.getInstance();\n      calendar.setTime(date);\n      int year = calendar.get(Calendar.YEAR);\n      int era = calendar.get(Calendar.ERA);\n      if (era == GregorianCalendar.AD) {\n        if (year > 9999) {\n          valid = false;\n        }\n      }\n      // System.out.println(\"pattern is \"+ pattern);\n      // System.out.println(\"Year is \"+year);\n      // System.out.println(\"Calendar date is \"+date.toString());\n      // System.out.println(\"Era is \"+calendar.get(Calendar.ERA));\n    } catch (ParseException e) {\n      valid = false;\n    }\n    if (dateString.length() > pattern.length()) {\n      valid = false;\n    }\n    return valid;\n  }\n"}, {"dataset": "parse", "exampleID": 7781, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)", "ParsePosition position = new ParsePosition(int)"], "initializationStart": [98, 321], "initializationEnd": [130, 341], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["simpleDateFormat.setTimeZone(TimeZone)", "simpleDateFormat.setLenient(boolean)"], "configurationStart": [246, 278], "configurationEnd": [272, 297], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text,position)", "focalAPIStart": 356, "focalAPIEnd": 369, "followUpCheck": "dateTime == null || !StringUtil.isRestOfStringBlank(the_text,position.getIndex())", "checkType": "IF", "followUpCheckExpressionStart": 375, "followUpCheckExpressionEnd": 441, "followUpCheckBlockStart": 375, "followUpCheckBlockEnd": 525, "use": ["dateTime.getTime()"], "useStart": [543], "useEnd": [554], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Bhamni/OpenElis/tree/master/openelis/src/us/mn/state/health/lims/common/util/DateUtil.java", "rawCode": "  public static synchronized int decodeTime(String s) throws Exception {\n    SimpleDateFormat f = new SimpleDateFormat(\"HH:mm:ss\");\n    // System.out.println(\"Passed in this time \" +s);\n    TimeZone utcTimeZone = TimeZone.getTimeZone(\"UTC\");\n    f.setTimeZone(utcTimeZone);\n    f.setLenient(false);\n    ParsePosition p = new ParsePosition(0);\n    Date d = f.parse(s, p);\n    if (d == null || !StringUtil.isRestOfStringBlank(s, p.getIndex())) {\n      throw new Exception(\"Invalid time value (hh:mm:ss): \\\"\" + s + \"\\\".\");\n    }\n    return (int) d.getTime();\n  }\n"}, {"dataset": "parse", "exampleID": 7782, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String,*)"], "initializationStart": [437], "initializationEnd": [501], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 568, "focalAPIEnd": 623, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dateTime.getTime()"], "useStart": [568], "useEnd": [633], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spring-projects/spring-integration/tree/master/spring-integration-http/src/test/java/org/springframework/integration/http/support/DefaultHttpHeaderMapperFromMessageOutboundTests.java", "rawCode": "  @Test\n  public void validateIfModifiedSinceAsNumber() throws ParseException {\n    HeaderMapper<HttpHeaders> mapper = DefaultHttpHeaderMapper.outboundMapper();\n    Map<String, Object> messageHeaders = new HashMap<>();\n    messageHeaders.put(\"If-Modified-Since\", 12345678);\n    HttpHeaders headers = new HttpHeaders();\n    mapper.fromHeaders(new MessageHeaders(messageHeaders), headers);\n\n    SimpleDateFormat simpleDateFormat =\n        new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.US);\n\n    assertThat(headers.getIfModifiedSince())\n        .isEqualTo(simpleDateFormat.parse(\"Thu, 01 Jan 1970 03:25:45 GMT\").getTime());\n  }\n"}, {"dataset": "parse", "exampleID": 7783, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 116, "focalAPIEnd": 142, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Feed(String,String,dateTime)", "simpleDateFormat.parse(String)", "simpleDateFormat.parse(String)"], "useStart": [88, 276, 495], "useEnd": [143, 302, 521], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Praqma/praqmajutils/tree/master/src/test/java/net/praqma/util/xml/feed/FeedTest.java", "rawCode": "  @Test\n  public void testFeed() throws FeedException, ParseException {\n    Feed feed = new Feed(\"test\", \"my--001\", format.parse(\"2012-01-01\"));\n    feed.link = \"http://www.praqma.net\";\n    feed.author = new Person(\"PRAQMA\");\n\n    Entry e = new Entry(\"Title E1\", \"My-id-001\", format.parse(\"2012-01-02\"));\n    e.summary = \"Something cool\";\n    e.author = new Person(\"PRAQMA #1\");\n    e.content = \"A very long content tag\";\n    feed.addEntry(e);\n\n    Entry e2 = new Entry(\"Title E2\", \"My-id-002\", format.parse(\"2012-01-03\"));\n    e2.summary = \"Something cool 2\";\n    e2.author = new Person(\"PRAQMA #2\");\n    e2.content = \"A very long content tag 2\";\n    feed.addEntry(e2);\n\n    String xml = feed.getXML(new AtomPublisher());\n\n    System.out.println(\"XML: \" + xml);\n  }\n"}, {"dataset": "parse", "exampleID": 7784, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["getMessage()", "new JsonConversionException(String,*)"], "tryExpressionStart": 648, "tryExpressionEnd": 652, "tryBlockStart": 648, "tryBlockEnd": 1814, "catchExpressionStart": 1668, "catchExpressionEnd": 1694, "catchBlockStart": 1668, "catchBlockEnd": 1814, "exceptionHandlingCallStart": [1787, 1708], "exceptionHandlingCallEnd": [1802, 1807], "configuration": ["the_text.replaceAll(String,String)", "the_text.replace(String,String)", "simpleDateFormat.setTimeZone(TimeZone)"], "configurationStart": [923, 1171, 1313], "configurationEnd": [954, 1205, 1373], "guardCondition": "!(the_text.matches(\".*T000000\",)) && !(the_text==null)", "guardType": "IF {", "guardExpressionStart": 661, "guardExpressionEnd": 685, "guardBlockStart": 661, "guardBlockEnd": 718, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 1403, "focalAPIEnd": 1441, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["SimpleDateFormat.format(dateTime)"], "useStart": [1617], "useEnd": [1660], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/schmurfy/funambol-json/tree/master/json/connector/json-core/src/main/java/com/funambol/json/converter/AppointmentConverter.java", "rawCode": "  /**\n   * Converts from \"yyyyMMdd'T'HHmmss'Z'\" to \"yyyyMMdd'T'HHmmss\" using the timezone ID. If the given\n   * date is in standard allday format 'yyyyMMdd', no convertion is needed. If it is in not standard\n   * allday format 'yyyy-MM-dd', it's needed to remove the '-'.\n   *\n   * @param patternDate the date to convert\n   * @param tmzid the timezone id to use in the convertion\n   * @return String the converted date in local time\n   * @throws com.funambol.json.exception.JsonConversionException\n   */\n  private String zuluToLocalConversion(String patternDate, String tmzid)\n      throws JsonConversionException {\n\n    String output = null;\n\n    try {\n\n      if (patternDate == null) {\n        return output;\n      }\n\n      String dateFormat = Utility.getDateFormat(patternDate);\n\n      if (\"yyyyMMdd\".equals(dateFormat)) {\n        return patternDate;\n      }\n\n      if (\"yyyy-MM-dd\".equals(dateFormat)) {\n        return patternDate.replaceAll(\"-\", \"\");\n      }\n\n      if (\"yyyyMMdd'T'HHmmss\".equals(dateFormat) && patternDate.matches(\".*T000000\")) {\n        // if \"Z\" is not specified and HHmmss == 000000 then it is an all-day\n        // See bug #6724\n        return patternDate.replace(\"T000000\", \"\");\n      }\n\n      SimpleDateFormat ZULU_DATE_FORMATTER = new SimpleDateFormat(\"yyyyMMdd'T'HHmmss'Z'\");\n      ZULU_DATE_FORMATTER.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n      Date datePatterDate = ZULU_DATE_FORMATTER.parse(patternDate);\n\n      SimpleDateFormat LOCAL_DATE_FORMATTER = new SimpleDateFormat(\"yyyyMMdd'T'HHmmss\");\n      LOCAL_DATE_FORMATTER.setTimeZone(TimeZone.getTimeZone(tmzid));\n      output = LOCAL_DATE_FORMATTER.format(datePatterDate);\n    } catch (ParseException pe) {\n      throw new JsonConversionException(\n          \"Error in the zuluToLocalConversion.\" + pe.getMessage(), pe);\n    }\n\n    return output;\n  }\n"}, {"dataset": "parse", "exampleID": 7785, "initialization": ["String the_text = RenderRequest.getPreferences()", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [727, 854], "initializationEnd": [751, 888], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "the_text!=null", "guardType": "IF {", "guardExpressionStart": 787, "guardExpressionEnd": 814, "guardBlockStart": 787, "guardBlockEnd": 1009, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 926, "focalAPIEnd": 957, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["RenderRequest.setAttribute(String,dateTime)"], "useStart": [1016], "useEnd": [1060], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yukoff/concourse-connect/tree/master/src/main/java/com/concursive/connect/web/modules/scrum/portlets/ScrumReleaseBurnDownPortlet.java", "rawCode": "  protected void doEdit(RenderRequest request, RenderResponse response)\n      throws PortletException, IOException {\n    try {\n      Connection db = PortalUtils.useConnection(request);\n      Project thisProject = PortalUtils.getProject(request);\n\n      // Get the categories for the user\n      TaskCategoryList categoryList = new TaskCategoryList();\n      categoryList.setProjectId(PortalUtils.getProject(request).getId());\n      categoryList.buildList(db);\n      request.setAttribute(\"categoryList\", categoryList);\n      request.setAttribute(\"categoryId\", request.getPreferences().getValue(\"categoryId\", \"-1\"));\n\n      // Get the date\n      Date startDate = new Date(System.currentTimeMillis());\n      String startDateValue = request.getPreferences().getValue(\"startDate\", null);\n      if (startDateValue != null) {\n        SimpleDateFormat formatter = new SimpleDateFormat(\"MM/dd/yyyy\");\n        try {\n          startDate = formatter.parse(startDateValue);\n        } catch (Exception e) {\n\n        }\n      }\n      request.setAttribute(\"startDate\", startDate);\n\n      // Show the releases\n      ProjectItemList targetReleaseList = new ProjectItemList();\n      targetReleaseList.setProjectId(thisProject.getId());\n      targetReleaseList.setEnabled(Constants.TRUE);\n      targetReleaseList.buildList(db, ProjectItemList.LIST_TARGET_RELEASE);\n      request.setAttribute(\"releaseList\", targetReleaseList);\n      request.setAttribute(\"releaseId\", request.getPreferences().getValue(\"releaseId\", \"-1\"));\n\n      // Chart parameters\n      request.setAttribute(\"daysToShow\", request.getPreferences().getValue(\"daysToShow\", \"45\"));\n      request.setAttribute(\n          \"estimatedHours\", request.getPreferences().getValue(\"estimatedHours\", \"0.0\"));\n      request.setAttribute(\"workHours\", request.getPreferences().getValue(\"workHours\", \"7.0\"));\n      request.setAttribute(\"chartHeight\", request.getPreferences().getValue(\"chartHeight\", \"250\"));\n\n      // Show the edit page\n      PortletContext context = getPortletContext();\n      PortletRequestDispatcher requestDispatcher = context.getRequestDispatcher(EDIT_PAGE);\n      requestDispatcher.include(request, response);\n    } catch (Exception e) {\n\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7786, "initialization": ["SimpleDateFormat simpleDateFormat = getDateTimeFormat()"], "initializationStart": [119], "initializationEnd": [159], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 178, "focalAPIEnd": 211, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.parse(String)", "createSmallestAllowedBlock(dateTime)"], "useStart": [231, 294], "useEnd": [264, 349], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Jasig/sched-assist/tree/master/sched-assist-api/src/test/java/org/jasig/schedassist/model/AvailableBlockBuilderTest.java", "rawCode": "  /** @throws Exception */\n  @Test\n  public void testCombine15s() throws Exception {\n    SimpleDateFormat timeFormat = CommonDateOperations.getDateTimeFormat();\n    Date time1 = timeFormat.parse(\"20090211-1100\");\n\n    Date time2 = timeFormat.parse(\"20090211-1105\");\n    AvailableBlock block1 = AvailableBlockBuilder.createSmallestAllowedBlock(time1);\n    assertEquals(time2, block1.getEndTime());\n\n    AvailableBlock block2 = AvailableBlockBuilder.createSmallestAllowedBlock(time2);\n    SortedSet<AvailableBlock> smallBlocks = new TreeSet<AvailableBlock>();\n    smallBlocks.add(block1);\n    smallBlocks.add(block2);\n\n    Set<AvailableBlock> combined1 = AvailableBlockBuilder.combine(smallBlocks);\n    assertEquals(1, combined1.size());\n    AvailableBlock expected =\n        AvailableBlockBuilder.createBlock(block1.getStartTime(), block2.getEndTime());\n    assertTrue(combined1.contains(expected));\n  }\n"}, {"dataset": "parse", "exampleID": 7787, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 94, "focalAPIEnd": 117, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["dateTime.getTime()"], "useStart": [94], "useEnd": [127], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ibaca/simple-scrum-application/tree/master/ssa-mobile/src/org/inftel/ssa/mobile/ui/fragments/TaskEditFragment.java", "rawCode": "  private String secureEpochDate(String insecureDate) {\n    try {\n      return String.valueOf(sdf.parse(insecureDate).getTime());\n    } catch (Exception ignored) {\n      return null; // FIXME jeje esto es poco 'elegante'\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7788, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [1257], "initializationEnd": [1286], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["getInstance(*)", "log(String,*,*)"], "tryExpressionStart": 1307, "tryExpressionEnd": 1311, "tryBlockStart": 1307, "tryBlockEnd": 1509, "catchExpressionStart": 1352, "catchExpressionEnd": 1372, "catchBlockStart": 1352, "catchBlockEnd": 1509, "exceptionHandlingCallStart": [1380, 1380], "exceptionHandlingCallEnd": [1427, 1488], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 1326, "focalAPIEnd": 1344, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["simpleDateFormat.format(Date)", "dateTime.getTime()", "dateTime.setTime(*)", "SimpleDateFormat.format(dateTime)", "simpleDateFormat.parse(String)", "simpleDateFormat.parse(String)"], "useStart": [1570, 1607, 1594, 1662, 2303, 2325], "useEnd": [1586, 1621, 1633, 1678, 2323, 2345], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gillesB/semantischeOperabilitaet2013/tree/master/SI-Hauptprojekt/src/de/htw/gui/TimeFrameChooser/TimeFrameChooser.java", "rawCode": "  private void initCalendarDisplay() {\n    calendarBaseLayer = new JPanel();\n    calendarBaseLayer.setLayout(new GridBagLayout());\n    calendarBaseLayer.setBackground(new Color(205, 205, 205));\n\n    GridBagConstraints constraints = new GridBagConstraints();\n    constraints.anchor = GridBagConstraints.CENTER;\n    constraints.insets = new Insets(1, 1, 1, 1);\n    constraints.fill = GridBagConstraints.NONE;\n\n    constraints.gridx = 3;\n    constraints.gridy = 1;\n    constraints.gridheight = 1;\n    constraints.gridwidth = 1;\n    constraints.weightx = 999;\n    constraints.weighty = 1;\n\n    // add labels for weekdays\n    for (int i = 0; i < 7; ++i) {\n      JButton temp = new JButton(String.valueOf(Day.getByID(i + 1)));\n      final int finalI = i;\n      temp.addActionListener(\n          new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n              toggleByDayID(finalI);\n            }\n          });\n      calendarBaseLayer.add(temp, constraints);\n      constraints.gridx += 2;\n    }\n\n    // add time frames\n    constraints.gridx = 1;\n    constraints.gridy = 3;\n    constraints.weighty = 999;\n    constraints.weightx = 1;\n    constraints.anchor = GridBagConstraints.NORTH;\n\n    SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm\");\n    Date date;\n    try {\n      date = sdf.parse(\"07:00\");\n    } catch (Exception e) {\n      RootLogger.getInstance(LoggerNames.MAIN_LOGGER)\n          .log(\"Error creating Table Data\", Level.SEVERE, e);\n      return;\n    }\n    for (int i = 0; i < 16; ++i) {\n      String timeFrame = sdf.format(date);\n      date.setTime(date.getTime() + ONE_HOUR);\n      timeFrame += \" - \" + sdf.format(date);\n      JLabel temp = new JLabel(timeFrame);\n      timeLabels.add(temp);\n      calendarBaseLayer.add(temp, constraints);\n      constraints.gridy += 2;\n    }\n\n    // create calendar like look\n    constraints.gridx = 3;\n    constraints.gridy = 3;\n    constraints.weighty = 999;\n    constraints.anchor = GridBagConstraints.CENTER;\n    constraints.fill = GridBagConstraints.BOTH;\n    try {\n      for (int i = 0; i < 7; ++i) {\n        constraints.gridy = 3;\n        for (int j = 0; j < 16; ++j) {\n          String[] tArray = timeLabels.get(j).getText().split(\"-\");\n          TimeFramePanel temp =\n              new TimeFramePanel(sdf.parse(tArray[0]), sdf.parse(tArray[1]), Day.getByID(i + 1));\n          timeFramePanels.add(temp);\n          calendarBaseLayer.add(temp, constraints);\n          constraints.gridy += 2;\n        }\n        constraints.gridx += 2;\n      }\n    } catch (ParseException e) {\n      RootLogger.getInstance(LoggerNames.MAIN_LOGGER).log(\"Error Parsing Times!\", Level.SEVERE, e);\n      System.exit(-1);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7789, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [3208], "initializationEnd": [3251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["simpleDateFormat.setTimeZone(TimeZone)", "simpleDateFormat.format(Date)", "simpleDateFormat.format(Date)", "simpleDateFormat.format(Date)"], "configurationStart": [3257, 6549, 8895, 10935], "configurationEnd": [3312, 6617, 8963, 10968], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 13304, "focalAPIEnd": 13334, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["put(dateTime,long)", "simpleDateFormat.parse(String)", "simpleDateFormat.parse(String)"], "useStart": [13550, 14104, 16392], "useEnd": [13614, 14134, 16422], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gsathya/metrics-tasks/tree/master/task-5807/src/EvalBridgeDirreqStats.java", "rawCode": "  public static void main(String[] args) throws Exception {\n\n    /* Parse relay consensuses from in/relay-descriptors/. Skip this step\n     * if in/relay-descriptors/ does not exist. */\n    File consensusesDirectory = new File(\"in/relay-descriptors\");\n    File hashedFingerprintsFile = new File(\"out/hashed-fingerprints\");\n    File consensusesPerDayFile = new File(\"out/consensuses-per-day\");\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n    dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n    if (consensusesDirectory.exists()) {\n      SortedSet<String> hashedFingerprints = new TreeSet<String>();\n      SortedMap<String, Integer> consensusesPerDay = new TreeMap<String, Integer>();\n      DescriptorReader descriptorReader = DescriptorSourceFactory.createDescriptorReader();\n      descriptorReader.addDirectory(consensusesDirectory);\n      Iterator<DescriptorFile> descriptorFiles = descriptorReader.readDescriptors();\n      while (descriptorFiles.hasNext()) {\n        DescriptorFile descriptorFile = descriptorFiles.next();\n        for (Descriptor descriptor : descriptorFile.getDescriptors()) {\n          if (!(descriptor instanceof RelayNetworkStatusConsensus)) {\n            continue;\n          }\n          RelayNetworkStatusConsensus consensus = (RelayNetworkStatusConsensus) descriptor;\n\n          /* Extract hashed fingerprints of all known relays to remove\n           * those fingerprints from bridge usage statistics later on. */\n          for (NetworkStatusEntry statusEntry : consensus.getStatusEntries().values()) {\n            hashedFingerprints.add(\n                Hex.encodeHexString(\n                        DigestUtils.sha(Hex.decodeHex(statusEntry.getFingerprint().toCharArray())))\n                    .toUpperCase());\n          }\n\n          /* Count the number of consensuses per day. */\n          String date = dateFormat.format(consensus.getValidAfterMillis());\n          int consensuses = 1;\n          if (consensusesPerDay.containsKey(date)) {\n            consensuses += consensusesPerDay.get(date);\n          }\n          consensusesPerDay.put(date, consensuses);\n        }\n      }\n      hashedFingerprintsFile.getParentFile().mkdirs();\n      BufferedWriter bw = new BufferedWriter(new FileWriter(hashedFingerprintsFile));\n      for (String hashedFingerprint : hashedFingerprints) {\n        bw.write(hashedFingerprint + \"\\n\");\n      }\n      bw.close();\n      consensusesPerDayFile.getParentFile().mkdirs();\n      bw = new BufferedWriter(new FileWriter(consensusesPerDayFile));\n      for (Map.Entry<String, Integer> e : consensusesPerDay.entrySet()) {\n        bw.write(e.getKey() + \",\" + e.getValue() + \"\\n\");\n      }\n      bw.close();\n    }\n\n    /* Parse bridge network statuses from in/bridge-descriptors/. Skip\n     * this step if in/bridge-descriptors/ does not exist. */\n    File bridgeDescriptorsDirectory = new File(\"in/bridge-descriptors\");\n    File bridgesPerDayFile = new File(\"out/bridges-per-day\");\n    File dirreqResponsesFile = new File(\"out/dirreq-responses\");\n    File dirreqWriteHistoryFile = new File(\"out/dirreq-write-history\");\n    File bridgeStatsUsersFile = new File(\"out/bridge-stats-users\");\n    SimpleDateFormat dateTimeFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    dateTimeFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n    if (bridgeDescriptorsDirectory.exists()) {\n\n      /* Read hashed fingerprints from disk, so that we can include in the\n       * intermediate files whether a bridge was running as non-bridge\n       * relay before. */\n      SortedSet<String> hashedFingerprints = new TreeSet<String>();\n      String line;\n      BufferedReader br = new BufferedReader(new FileReader(hashedFingerprintsFile));\n      while ((line = br.readLine()) != null) {\n        hashedFingerprints.add(line.toUpperCase());\n      }\n      br.close();\n\n      /* Prepare data structures for first collecting everything we parse.\n       * There may be duplicates which we can best remove in memory. */\n      SortedMap<String, List<Integer>> bridgesPerDay = new TreeMap<String, List<Integer>>();\n      SortedSet<String> dirreqResponses = new TreeSet<String>();\n      SortedMap<String, SortedMap<Long, Long>> dirreqWriteHistory =\n          new TreeMap<String, SortedMap<Long, Long>>();\n      SortedSet<String> bridgeIps = new TreeSet<String>();\n\n      /* Parse everything in in/bridge-descriptors/. */\n      DescriptorReader descriptorReader = DescriptorSourceFactory.createDescriptorReader();\n      descriptorReader.addDirectory(bridgeDescriptorsDirectory);\n      Iterator<DescriptorFile> descriptorFiles = descriptorReader.readDescriptors();\n      while (descriptorFiles.hasNext()) {\n        DescriptorFile descriptorFile = descriptorFiles.next();\n        for (Descriptor descriptor : descriptorFile.getDescriptors()) {\n          if (descriptor instanceof BridgeNetworkStatus) {\n            BridgeNetworkStatus status = (BridgeNetworkStatus) descriptor;\n\n            /* Extract number of running bridges to calculate daily means.\n             * Skip network statuses where less than 1% of bridges have\n             * the Running flag. */\n            String date = dateFormat.format(status.getPublishedMillis());\n            int totalBridges = 0, runningBridges = 0;\n            for (NetworkStatusEntry statusEntry : status.getStatusEntries().values()) {\n              totalBridges++;\n              if (statusEntry.getFlags().contains(\"Running\")) {\n                runningBridges++;\n              }\n            }\n            if (runningBridges * 100 > totalBridges) {\n              if (!bridgesPerDay.containsKey(date)) {\n                bridgesPerDay.put(date, new ArrayList<Integer>());\n              }\n              bridgesPerDay.get(date).add(runningBridges);\n            }\n          } else if (descriptor instanceof ExtraInfoDescriptor) {\n            ExtraInfoDescriptor extraInfoDescriptor = (ExtraInfoDescriptor) descriptor;\n            String fingerprint = extraInfoDescriptor.getFingerprint().toUpperCase();\n            String wasSeenAsRelay = hashedFingerprints.contains(fingerprint) ? \"TRUE\" : \"FALSE\";\n\n            /* Extract v3 directory request response numbers from dirreq\n             * stats, if available. */\n            if (extraInfoDescriptor.getDirreqStatsEndMillis() >= 0\n                && extraInfoDescriptor.getDirreqStatsIntervalLength() == 86400\n                && extraInfoDescriptor.getDirreqV3Resp() != null\n                && extraInfoDescriptor.getDirreqV3Resp().containsKey(\"ok\")) {\n              String dirreqStatsEnd =\n                  dateTimeFormat.format(extraInfoDescriptor.getDirreqStatsEndMillis());\n              SortedMap<String, Integer> resp = extraInfoDescriptor.getDirreqV3Resp();\n              String ok = String.valueOf(resp.get(\"ok\"));\n              String notEnoughSigs =\n                  resp.containsKey(\"not-enough-sigs\")\n                      ? String.valueOf(resp.get(\"not-enough-sigs\"))\n                      : \"NA\";\n              String unavailable =\n                  resp.containsKey(\"unavailable\") ? String.valueOf(resp.get(\"unavailable\")) : \"NA\";\n              String notFound =\n                  resp.containsKey(\"not-found\") ? String.valueOf(resp.get(\"not-found\")) : \"NA\";\n              String notModified =\n                  resp.containsKey(\"not-modified\")\n                      ? String.valueOf(resp.get(\"not-modified\"))\n                      : \"NA\";\n              String busy = resp.containsKey(\"busy\") ? String.valueOf(resp.get(\"busy\")) : \"NA\";\n              dirreqResponses.add(\n                  String.format(\n                      \"%s,%s,%s,%s,%s,%s,%s,%s%n\",\n                      dirreqStatsEnd,\n                      fingerprint,\n                      wasSeenAsRelay,\n                      ok,\n                      notEnoughSigs,\n                      unavailable,\n                      notFound,\n                      notModified,\n                      busy));\n            }\n\n            /* Extract written directory bytes, if available. */\n            if (extraInfoDescriptor.getDirreqWriteHistory() != null\n                && extraInfoDescriptor.getDirreqWriteHistory().getIntervalLength() == 900) {\n              if (!dirreqWriteHistory.containsKey(fingerprint)) {\n                dirreqWriteHistory.put(fingerprint, new TreeMap<Long, Long>());\n              }\n              dirreqWriteHistory\n                  .get(fingerprint)\n                  .putAll(extraInfoDescriptor.getDirreqWriteHistory().getBandwidthValues());\n            }\n\n            /* Sum up unique IP address counts from .sy and from all\n             * countries from bridge stats, if available. */\n            if (extraInfoDescriptor.getBridgeStatsEndMillis() >= 0\n                && extraInfoDescriptor.getBridgeStatsIntervalLength() == 86400\n                && extraInfoDescriptor.getBridgeIps() != null) {\n              String bridgeStatsEnd =\n                  dateTimeFormat.format(extraInfoDescriptor.getBridgeStatsEndMillis());\n              int sy = 0, all = 0;\n              for (Map.Entry<String, Integer> e : extraInfoDescriptor.getBridgeIps().entrySet()) {\n                String country = e.getKey();\n                int adjustedIps = e.getValue() - 4;\n                if (country.equals(\"sy\")) {\n                  sy = adjustedIps;\n                }\n                all += adjustedIps;\n              }\n              bridgeIps.add(\n                  String.format(\n                      \"%s,%s,%s,%d,%d%n\", bridgeStatsEnd, fingerprint, wasSeenAsRelay, sy, all));\n            }\n          }\n        }\n      }\n\n      /* Write to disk what we learned while parsing bridge extra-info\n       * descriptors. */\n      bridgesPerDayFile.getParentFile().mkdirs();\n      BufferedWriter bw = new BufferedWriter(new FileWriter(bridgesPerDayFile));\n      for (Map.Entry<String, List<Integer>> e : bridgesPerDay.entrySet()) {\n        String date = e.getKey();\n        List<Integer> bridges = e.getValue();\n        int sum = 0;\n        for (int b : bridges) {\n          sum += b;\n        }\n        bw.write(String.format(\"%s,%d%n\", date, sum / bridges.size()));\n      }\n      bw.close();\n      dirreqResponsesFile.getParentFile().mkdirs();\n      bw = new BufferedWriter(new FileWriter(dirreqResponsesFile));\n      for (String resp : dirreqResponses) {\n        bw.write(resp);\n      }\n      bw.close();\n      bridgeStatsUsersFile.getParentFile().mkdirs();\n      bw = new BufferedWriter(new FileWriter(bridgeStatsUsersFile));\n      for (String ips : bridgeIps) {\n        bw.write(ips);\n      }\n      bw.close();\n      bw = new BufferedWriter(new FileWriter(dirreqWriteHistoryFile));\n      for (Map.Entry<String, SortedMap<Long, Long>> e : dirreqWriteHistory.entrySet()) {\n        String fingerprint = e.getKey();\n        String wasSeenAsRelay = hashedFingerprints.contains(fingerprint) ? \"TRUE\" : \"FALSE\";\n        for (Map.Entry<Long, Long> f : e.getValue().entrySet()) {\n          String historyIntervalEnd = dateTimeFormat.format(f.getKey());\n          bw.write(\n              String.format(\n                  \"%s,%s,%d,%s%n\", fingerprint, historyIntervalEnd, f.getValue(), wasSeenAsRelay));\n        }\n      }\n      bw.close();\n    }\n\n    /* Aggregate the parse results from above and write relevant data for\n     * estimating daily bridge users to disk. Write results to\n     * out/bridge-dirreq-stats. This step is distinct from the parsing\n     * steps, so that the parsing only has to be done once, whereas the\n     * aggregation can be tweaked and re-run easily. */\n    File bridgeDirreqStatsNoRelaysFile = new File(\"out/bridge-dirreq-stats-no-relays\");\n    File bridgeDirreqStatsAllBridgesFile = new File(\"out/bridge-dirreq-stats-all-bridges\");\n    if (bridgesPerDayFile.exists()\n        && dirreqResponsesFile.exists()\n        && bridgeStatsUsersFile.exists()\n        && dirreqWriteHistoryFile.exists()\n        && consensusesPerDayFile.exists()) {\n\n      /* Run the aggregation twice, once for all bridges and once for only\n       * bridges which haven't been seen as non-bridge relays before. */\n      boolean[] exclude = new boolean[] {true, false};\n      File[] outFiles = new File[] {bridgeDirreqStatsNoRelaysFile, bridgeDirreqStatsAllBridgesFile};\n      for (int r = 0; r < 2; r++) {\n        boolean excludeHashedFingerprints = exclude[r];\n        File outFile = outFiles[r];\n\n        /* Read parse results back to memory. */\n        SortedMap<String, Integer> bridgesPerDay = new TreeMap<String, Integer>();\n        BufferedReader br = new BufferedReader(new FileReader(bridgesPerDayFile));\n        String line;\n        while ((line = br.readLine()) != null) {\n          String[] parts = line.split(\",\");\n          bridgesPerDay.put(parts[0], Integer.parseInt(parts[1]));\n        }\n        br.close();\n        SortedMap<String, SortedMap<Long, Long>> dirreqOkResponses =\n            new TreeMap<String, SortedMap<Long, Long>>();\n        br = new BufferedReader(new FileReader(dirreqResponsesFile));\n        while ((line = br.readLine()) != null) {\n          String[] parts = line.split(\",\");\n          if (excludeHashedFingerprints && parts[2].equals(\"TRUE\")) {\n            /* Skip, because this bridge has been seen as relay before. */\n            continue;\n          }\n          String fingerprint = parts[1].toUpperCase();\n          long dirreqStatsEndMillis = dateTimeFormat.parse(parts[0]).getTime();\n          long ok = Long.parseLong(parts[3]);\n          if (!dirreqOkResponses.containsKey(fingerprint)) {\n            dirreqOkResponses.put(fingerprint, new TreeMap<Long, Long>());\n          }\n          dirreqOkResponses.get(fingerprint).put(dirreqStatsEndMillis, ok);\n        }\n        br.close();\n        SortedMap<String, long[]> ipsPerDay = new TreeMap<String, long[]>();\n        br = new BufferedReader(new FileReader(bridgeStatsUsersFile));\n        while ((line = br.readLine()) != null) {\n          String[] parts = line.split(\",\");\n          if (excludeHashedFingerprints && parts[2].equals(\"TRUE\")) {\n            /* Skip, because this bridge has been seen as relay before. */\n            continue;\n          }\n          long bridgeStatsEndMillis = dateTimeFormat.parse(parts[0]).getTime();\n          long bridgeStatsStartMillis = bridgeStatsEndMillis - 86400000L;\n          long currentStartMillis = bridgeStatsStartMillis;\n\n          /* Find UTC date break in the interval and make sure that we\n           * distribute IPs to the two days correctly. */\n          String[] dates =\n              new String[] {\n                dateFormat.format(bridgeStatsStartMillis), dateFormat.format(bridgeStatsEndMillis)\n              };\n          long[] seconds = new long[2];\n          if (!dates[0].equals(dates[1])) {\n            long dateBreakMillis = (bridgeStatsEndMillis / 86400000L) * 86400000L;\n            seconds[0] = (dateBreakMillis - bridgeStatsStartMillis) / 1000L;\n            bridgeStatsStartMillis = dateBreakMillis;\n          }\n          seconds[1] = (bridgeStatsEndMillis - bridgeStatsStartMillis) / 1000L;\n\n          /* Update per-day counters. */\n          for (int i = 0; i < dates.length; i++) {\n            String date = dates[i];\n            long sy = seconds[i] * Long.parseLong(parts[3]);\n            long all = seconds[i] * Long.parseLong(parts[4]);\n            if (!ipsPerDay.containsKey(date)) {\n              ipsPerDay.put(date, new long[] {0L, 0L});\n            }\n            ipsPerDay.get(date)[0] += sy;\n            ipsPerDay.get(date)[1] += all;\n          }\n        }\n        br.close();\n        SortedMap<String, Integer> consensusesPerDay = new TreeMap<String, Integer>();\n        br = new BufferedReader(new FileReader(consensusesPerDayFile));\n        while ((line = br.readLine()) != null) {\n          String[] parts = line.split(\",\");\n          consensusesPerDay.put(parts[0], Integer.parseInt(parts[1]));\n        }\n        br.close();\n        br = new BufferedReader(new FileReader(dirreqWriteHistoryFile));\n        SortedMap<String, SortedMap<Long, Long>> dirreqWriteHistory =\n            new TreeMap<String, SortedMap<Long, Long>>();\n        while ((line = br.readLine()) != null) {\n          String[] parts = line.split(\",\");\n          if (excludeHashedFingerprints && parts[3].equals(\"TRUE\")) {\n            /* Skip, because this bridge has been seen as relay before. */\n            continue;\n          }\n          String fingerprint = parts[0].toUpperCase();\n          long historyIntervalEndMillis = dateTimeFormat.parse(parts[1]).getTime();\n          long writtenBytes = Long.parseLong(parts[2]);\n          if (!dirreqWriteHistory.containsKey(fingerprint)) {\n            dirreqWriteHistory.put(fingerprint, new TreeMap<Long, Long>());\n          }\n          dirreqWriteHistory.get(fingerprint).put(historyIntervalEndMillis, writtenBytes);\n        }\n        br.close();\n\n        /* For every day, count reported v3 directory request responses,\n         * reported written directory bytes, and reporting bridges.\n         * Distinguish between bridges reporting both responses and bytes,\n         * bridges reporting only responses, and bridges reporting. Map\n         * keys are dates, map values are the number of responses, bytes,\n         * or bridges. */\n        SortedMap<String, Long> responsesReportingBoth = new TreeMap<String, Long>(),\n            responsesNotReportingBytes = new TreeMap<String, Long>(),\n            bytesReportingBoth = new TreeMap<String, Long>(),\n            bytesNotReportingResponses = new TreeMap<String, Long>(),\n            bridgesReportingBoth = new TreeMap<String, Long>(),\n            bridgesNotReportingBytes = new TreeMap<String, Long>(),\n            bridgesNotReportingResponses = new TreeMap<String, Long>();\n\n        /* Consider each bridge separately. */\n        SortedSet<String> allFingerprints = new TreeSet<String>();\n        allFingerprints.addAll(dirreqOkResponses.keySet());\n        allFingerprints.addAll(dirreqWriteHistory.keySet());\n        for (String fingerprint : allFingerprints) {\n\n          /* Obtain iterators over dirreq stats intervals and dirreq write\n           * history intervals, from oldest to newest. Either iterator\n           * may contain zero elements if the bridge did not report any\n           * values, but not both. */\n          SortedMap<Long, Long> bridgeDirreqOkResponses =\n              dirreqOkResponses.containsKey(fingerprint)\n                  ? dirreqOkResponses.get(fingerprint)\n                  : new TreeMap<Long, Long>();\n          SortedMap<Long, Long> bridgeDirreqWriteHistory =\n              dirreqWriteHistory.containsKey(fingerprint)\n                  ? dirreqWriteHistory.get(fingerprint)\n                  : new TreeMap<Long, Long>();\n          Iterator<Long> responsesIterator = bridgeDirreqOkResponses.keySet().iterator();\n          Iterator<Long> historyIterator = bridgeDirreqWriteHistory.keySet().iterator();\n\n          /* Keep references to the currently considered intervals. */\n          long responseEndMillis =\n              responsesIterator.hasNext() ? responsesIterator.next() : Long.MAX_VALUE;\n          long historyEndMillis =\n              historyIterator.hasNext() ? historyIterator.next() : Long.MAX_VALUE;\n\n          /* Keep the time until when we have processed statistics. */\n          long currentStartMillis = 0L;\n\n          /* Iterate over both responses and byte histories until we set\n           * both to Long.MAX_VALUE, indicating that there are no further\n           * values. */\n          while (responseEndMillis < Long.MAX_VALUE || historyEndMillis < Long.MAX_VALUE) {\n\n            /* Dirreq-stats intervals are guaranteed to be 24 hours long,\n             * and dirreq-write-history intervals are 15 minutes long.\n             * This is guaranteed in the parsing code above. It allows us\n             * to calculate interval starts. Also, if we have already\n             * processed part of an interval, move the considered interval\n             * start accordingly. */\n            long historyStartMillis = Math.max(currentStartMillis, historyEndMillis - 900000L);\n            long responseStartMillis = Math.max(currentStartMillis, responseEndMillis - 86400000L);\n\n            /* Determine start and end time of the next interval, and\n             * whether the bridge reported dirreq-stats in that interval,\n             * or dirreq histories, or both. */\n            long currentEndMillis;\n            boolean addHistory = false, addResponses = false;\n            if (historyStartMillis < responseStartMillis) {\n              currentStartMillis = historyStartMillis;\n              currentEndMillis = Math.min(historyEndMillis, responseStartMillis);\n              addHistory = true;\n            } else if (responseStartMillis < historyStartMillis) {\n              currentStartMillis = responseStartMillis;\n              currentEndMillis = Math.min(historyStartMillis, responseEndMillis);\n              addResponses = true;\n            } else {\n              currentStartMillis = historyStartMillis;\n              currentEndMillis = Math.min(historyEndMillis, responseEndMillis);\n              addHistory = true;\n              addResponses = true;\n            }\n\n            /* Depending on which statistics the bridge reported in the\n             * determined interval, obtain the number of bytes or\n             * responses to add. */\n            long bytesInInterval = 0L, responsesInInterval = 0L;\n            if (addHistory) {\n              bytesInInterval = bridgeDirreqWriteHistory.get(historyEndMillis);\n            }\n            if (addResponses) {\n              responsesInInterval = bridgeDirreqOkResponses.get(responseEndMillis);\n            }\n\n            /* Find out if there is a UTC date break in the interval to be\n             * added. If there is, make sure that we distribute responses\n             * and bytes to the two days correctly. */\n            String[] dates =\n                new String[] {\n                  dateFormat.format(currentStartMillis), dateFormat.format(currentEndMillis)\n                };\n            long[] seconds = new long[2];\n            if (!dates[0].equals(dates[1])) {\n              long dateBreakMillis = (currentEndMillis / 86400000L) * 86400000L;\n              seconds[0] = (dateBreakMillis - currentStartMillis) / 1000L;\n              currentStartMillis = dateBreakMillis;\n            }\n            seconds[1] = (currentEndMillis - currentStartMillis) / 1000L;\n\n            /* Update per-day counters. */\n            for (int i = 0; i < dates.length; i++) {\n              String date = dates[i];\n              long bytes = seconds[i] * bytesInInterval;\n              long responses = seconds[i] * responsesInInterval;\n              if (!bytesReportingBoth.containsKey(date)) {\n                bytesReportingBoth.put(date, 0L);\n                bytesNotReportingResponses.put(date, 0L);\n                responsesReportingBoth.put(date, 0L);\n                responsesNotReportingBytes.put(date, 0L);\n                bridgesReportingBoth.put(date, 0L);\n                bridgesNotReportingBytes.put(date, 0L);\n                bridgesNotReportingResponses.put(date, 0L);\n              }\n              if (addHistory) {\n                if (addResponses) {\n                  bytesReportingBoth.put(date, bytesReportingBoth.get(date) + bytes);\n                  responsesReportingBoth.put(date, responsesReportingBoth.get(date) + responses);\n                  bridgesReportingBoth.put(date, bridgesReportingBoth.get(date) + seconds[i]);\n                } else {\n                  bytesNotReportingResponses.put(\n                      date, bytesNotReportingResponses.get(date) + bytes);\n                  bridgesNotReportingResponses.put(\n                      date, bridgesNotReportingResponses.get(date) + seconds[i]);\n                }\n              } else if (addResponses) {\n                responsesNotReportingBytes.put(\n                    date, responsesNotReportingBytes.get(date) + responses);\n                bridgesNotReportingBytes.put(date, bridgesNotReportingBytes.get(date) + seconds[i]);\n              }\n            }\n\n            /* Move next interval start to the current interval end, and\n             * possibly move to the next stats intervals. If we have run\n             * out of intervals in either or both of the sets, change the\n             * reference to Long.MAX_VALUE to add the other intervals and\n             * finally exit the loop. */\n            currentStartMillis = currentEndMillis;\n            if (historyEndMillis <= currentStartMillis) {\n              historyEndMillis =\n                  historyIterator.hasNext() ? historyIterator.next() : Long.MAX_VALUE;\n            }\n            if (responseEndMillis <= currentStartMillis) {\n              responseEndMillis =\n                  responsesIterator.hasNext() ? responsesIterator.next() : Long.MAX_VALUE;\n            }\n          }\n        }\n\n        /* Put together what we learned about bridge usage per day. */\n        outFile.getParentFile().mkdirs();\n        BufferedWriter bw = new BufferedWriter(new FileWriter(outFile));\n        bw.write(\"date,nabcd,sy,consensuses,ha,hc,ra,rb,na,nb,nc\\n\");\n        for (String date : bytesReportingBoth.keySet()) {\n          String bridges = \"NA\";\n          if (bridgesPerDay.containsKey(date)) {\n            bridges = String.valueOf(bridgesPerDay.get(date) * 86400L);\n          }\n          String sy = \"NA\";\n          if (ipsPerDay.containsKey(date)) {\n            long[] ips = ipsPerDay.get(date);\n            sy = String.format(\"%.5f\", ((double) ips[0]) / ((double) ips[1]));\n          }\n          String consensuses = \"NA\";\n          if (consensusesPerDay.containsKey(date)) {\n            consensuses = String.valueOf(consensusesPerDay.get(date));\n          }\n          bw.write(\n              String.format(\n                  \"%s,%s,%s,%s,%d,%d,%d,%d,%d,%d,%d%n\",\n                  date,\n                  bridges,\n                  sy,\n                  consensuses,\n                  bytesReportingBoth.get(date),\n                  bytesNotReportingResponses.get(date),\n                  responsesReportingBoth.get(date),\n                  responsesNotReportingBytes.get(date),\n                  bridgesReportingBoth.get(date),\n                  bridgesNotReportingBytes.get(date),\n                  bridgesNotReportingResponses.get(date)));\n        }\n        bw.close();\n      }\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7790, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 786, "focalAPIEnd": 811, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["round(dateTime,int)"], "useStart": [834], "useEnd": [867], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jmfaleiro/MessagePassing/tree/master/src/java/apps/archivist/json/VolumeAggregatorJson.java", "rawCode": "  public static void process() {\n\n    // Create two object nodes, one to keep track of volume counts,\n    // the other to send newly computed counts to the master every\n    // epoch.\n    ObjectMapper mapper = new ObjectMapper();\n    ObjectNode vals = mapper.createObjectNode();\n    ObjectNode to_send = mapper.createObjectNode();\n    HashSet<String> epoch_changes = new HashSet<String>();\n\n    while (true) {\n      ObjectNode new_tweet_wrapper = ShMem.AcquirePlain(0);\n      JsonNode tweets = new_tweet_wrapper.get(\"tweets\");\n      int num_tweets = tweets.size();\n\n      for (int i = 0; i < num_tweets; ++i) {\n        JsonNode tweet = tweets.get(i);\n        String date_string = tweet.get(\"created_at\").getTextValue();\n        Date cur_date = null;\n\n        try {\n          Date temp = format.parse(date_string);\n          cur_date = DateUtils.round(temp, round_type);\n        } catch (Exception e) {\n          continue;\n        }\n\n        date_string = cur_date.toString();\n        JsonNode count_wrapper = vals.get(date_string);\n        epoch_changes.add(date_string);\n        if (count_wrapper != null) {\n          vals.put(date_string, count_wrapper.getIntValue() + 1);\n        } else {\n          vals.put(date_string, 1);\n        }\n      }\n\n      for (String date_string : epoch_changes) {\n        to_send.put(date_string, vals.get(date_string));\n      }\n      ShMem.ReleasePlain(to_send, 0);\n      to_send.removeAll();\n      epoch_changes.clear();\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7791, "initialization": ["SimpleDateFormat simpleDateFormat = Iterator<SimpleDateFormat>.next()"], "initializationStart": [630], "initializationEnd": [647], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["toPattern()", "debug(*)"], "tryExpressionStart": 690, "tryExpressionEnd": 694, "tryBlockStart": 690, "tryBlockEnd": 1273, "catchExpressionStart": 1154, "catchExpressionEnd": 1180, "catchBlockStart": 1154, "catchBlockEnd": 1273, "exceptionHandlingCallStart": [1242, 1190], "exceptionHandlingCallEnd": [1263, 1264], "configuration": ["simpleDateFormat.setLenient(boolean)"], "configurationStart": [655], "configurationEnd": [682], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 762, "focalAPIEnd": 784, "followUpCheck": "dateTime == null", "checkType": "IF", "followUpCheckExpressionStart": 1284, "followUpCheckExpressionEnd": 1301, "followUpCheckBlockStart": 1284, "followUpCheckBlockEnd": 1401, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NCIP/cagrid-core/tree/master/caGrid/projects/data/src/java/validation/gov/nih/nci/cagrid/data/cql/validation/DataTypeValidator.java", "rawCode": "  private static void validateDate(String value) throws DomainConformanceException {\n    // try short date / time, time, then XSD dateTime, just XSD date\n    List<SimpleDateFormat> formats = new ArrayList<SimpleDateFormat>(4);\n    formats.add((SimpleDateFormat) DateFormat.getInstance());\n    formats.add(new SimpleDateFormat(\"HH:mm:ss\"));\n    formats.add(new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\"));\n    formats.add(new SimpleDateFormat(\"yyyy-MM-dd\"));\n\n    Date date = null;\n    Iterator<SimpleDateFormat> formatIter = formats.iterator();\n    while (date == null && formatIter.hasNext()) {\n      SimpleDateFormat formatter = formatIter.next();\n      formatter.setLenient(false);\n      try {\n        // can we parse a date out of that string?\n        date = formatter.parse(value);\n        // does the resulting date match the original input when formatted?\n        /*\n        String reformat = formatter.format(date);\n        if (!value.equals(reformat)) {\n        LOG.debug(value + \" parsed by pattern \" + formatter.toPattern() +\n        \" but reformats as \" + reformat + \", and so is not valid\");\n        date = null;\n        }\n        */\n      } catch (ParseException ex) {\n        LOG.debug(value + \" was not parsable by pattern \" + formatter.toPattern());\n      }\n    }\n    if (date == null) {\n      throw new DomainConformanceException(\"Value \" + value + \" does not parse as a Date\");\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7792, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [4721], "initializationEnd": [4755], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 4861, "focalAPIEnd": 4875, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["SimpleDateFormat.format(dateTime)"], "useStart": [4847], "useEnd": [4876], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/baron/books-macosx/tree/master/Export Plugins/Web Exporter/src/Java/net/aetherial/books/webexporter/WebExporter.java", "rawCode": "  @SuppressWarnings(\"unchecked\")\n  private static void writeHTMLPage(HashMap<String, String> fields)\n      throws IOException, ParseException {\n    String filePath = destination.getAbsolutePath() + \"/books/\" + fields.get(\"id\");\n\n    File bookDir = new File(filePath);\n\n    bookDir.mkdirs();\n\n    String htmlString = getHeader(2, fields.get(\"title\"));\n\n    // htmlString += \"<div class=\\\"navigation\\\"><a href=\\\"../../index.html\\\">My Books</a>: <a\n    // href=\\\"../../lists/genre/index.html\\\">Genres</a>: \" +\n    // \"<a href=\\\"../../lists/genre/\" + getFilename (fields.get (\"genre\")) + \".html\\\">\" + fields.get\n    // (\"genre\") + \"</a></div>\";\n\n    String isbn = fields.get(\"isbn\");\n\n    if (isbn != null && !isbn.equals(\"\")) {\n      isbn = isbn.replaceAll(\"-\", \"\").replaceAll(\" \", \"\");\n\n      htmlString +=\n          \"<div class=\\\"buy\\\">Buy online: <a href=\\\"http://www.amazon.com/exec/obidos/ASIN/\"\n              + isbn\n              + \"/aetherialnu-20a\\\">Amazon</a></div>\";\n    }\n\n    if (fields.get(\"coverImage\") != null) {\n      String coverPath = source.getParent() + \"/\" + fields.get(\"coverImage\");\n\n      try {\n        File srcCover = new File(coverPath);\n        File destCover = new File(filePath + \"/cover.png\");\n\n        BufferedInputStream fin = new BufferedInputStream(new FileInputStream(srcCover));\n        BufferedOutputStream fout = new BufferedOutputStream(new FileOutputStream(destCover));\n\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n\n        byte[] buf = new byte[4096];\n        int read = 0;\n\n        while ((read = fin.read(buf, 0, buf.length)) != -1) {\n          bout.write(buf, 0, read);\n        }\n\n        fin.close();\n\n        fout.write(bout.toByteArray());\n        fout.close();\n\n        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());\n\n        SeekableStream s = SeekableStream.wrapInputStream(bin, true);\n        RenderedOp objImage = JAI.create(\"stream\", s);\n        ((OpImage) objImage.getRendering()).setTileCache(null);\n\n        float width = 100;\n        float height = 150;\n\n        float xScale = width / objImage.getWidth();\n        float yScale = height / objImage.getHeight();\n\n        float scale = xScale;\n\n        if (xScale > yScale) scale = yScale;\n\n        ParameterBlock pb = new ParameterBlock();\n        pb.addSource(objImage); // The source image\n        pb.add(scale); // The xScale\n        pb.add(scale); // The yScale\n        pb.add(0.0F); // The x translation\n        pb.add(0.0F); // The y translation\n        pb.add(new InterpolationNearest()); // The interpolation\n\n        objImage = JAI.create(\"scale\", pb, null);\n\n        FileOutputStream out = new FileOutputStream(filePath + \"/thumbnail.png\");\n\n        EncodeDescriptor.create(objImage, out, \"PNG\", null, new RenderingHints(null));\n\n        out.flush();\n        out.close();\n\n        htmlString += \"<a href=\\\"cover.png\\\"><img src=\\\"cover.png\\\" class=\\\"cover\\\" /></a>\";\n      } catch (Exception e) {\n        htmlString += getListSidebar(2);\n      }\n    } else {\n      htmlString += getListSidebar(2);\n    }\n\n    htmlString += \"<div class=\\\"metadata\\\"><table class=\\\"book-def\\\">\";\n\n    ArrayList keys = getKeys();\n\n    for (int i = 0; i < keys.size(); i++) {\n      String key = (String) keys.get(i);\n\n      String value = fields.get(key);\n\n      if (value != null && !value.equals(\"\")) {\n        value = value.trim();\n\n        String collector = \"\";\n\n        for (String v : value.split(\";\")) {\n          v = v.trim();\n\n          if (v.startsWith(\"Ê\")) v = v.substring(1);\n\n          if (key.equals(\"authors\")) {\n            ArrayList<HashMap> list = (ArrayList) authors.get(v);\n\n            if (list == null) {\n              list = new ArrayList<HashMap>();\n\n              authors.put(v, list);\n            }\n\n            list.add(fields);\n\n            v = \"<a href=\\\"../../lists/authors/\" + getFilename(v) + \".html\\\">\" + v + \"</a>\";\n          } else if (key.equals(\"genre\")) {\n            ArrayList<HashMap> list = (ArrayList) genres.get(v);\n\n            if (list == null) {\n              list = new ArrayList<HashMap>();\n\n              genres.put(v, list);\n            }\n\n            list.add(fields);\n\n            v = \"<a href=\\\"../../lists/genre/\" + getFilename(v) + \".html\\\">\" + v + \"</a>\";\n          } else if (key.equals(\"listName\")) {\n            ArrayList<HashMap> list = (ArrayList) lists.get(v);\n\n            if (list == null) {\n              list = new ArrayList<HashMap>();\n\n              lists.put(v, list);\n            }\n\n            list.add(fields);\n\n            v = \"<a href=\\\"../../lists/lists/\" + getFilename(v) + \".html\\\">\" + v + \"</a>\";\n          } else if (key.equals(\"publishDate\")) {\n            if (sdfIn == null) {\n              sdfIn = new SimpleDateFormat(\"yyyy-MM-dd\");\n\n              sdfOut = new SimpleDateFormat(\"MMMM yyyy\");\n            }\n\n            v = sdfOut.format(sdfIn.parse(v));\n          }\n\n          if (collector.length() > 0) collector += \", \";\n\n          collector += v;\n        }\n\n        htmlString +=\n            \"<tr><td class=\\\"key\\\">\"\n                + getFieldName(key)\n                + \":</td><td class=\\\"value\\\">\"\n                + collector\n                + \"</td></tr>\";\n      }\n    }\n\n    htmlString += \"</table></div>\";\n\n    htmlString += getFooter();\n\n    OutputStreamWriter out =\n        new OutputStreamWriter(\n            new FileOutputStream(bookDir.getAbsolutePath() + \"/index.html\"), \"UTF-8\");\n\n    out.write(htmlString);\n\n    out.close();\n  }\n"}, {"dataset": "parse", "exampleID": 7793, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 146, "focalAPIEnd": 195, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["AuditLogDAO.getAllAfterDate(dateTime)", "simpleDateFormat.parse(String)", "AuditLogDAO.getAllAfterDate(dateTime)"], "useStart": [226, 346, 411], "useEnd": [253, 395, 438], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Dhandapani/gluster-ovirt/tree/master/backend/manager/modules/dal/src/test/java/org/ovirt/engine/core/dao/AuditLogDAOTest.java", "rawCode": "  /**\n   * Test date filtering\n   *\n   * @throws Exception\n   */\n  @Test\n  public void testGetAllAfterDate() throws Exception {\n    Date cutoff = EXPECTED_DATE_FORMAT.parse(\"2010-12-20 13:00:00\");\n\n    List<AuditLog> result = dao.getAllAfterDate(cutoff);\n\n    assertNotNull(result);\n    assertEquals(EXISTING_COUNT, result.size());\n\n    cutoff = EXPECTED_DATE_FORMAT.parse(\"2010-12-20 14:00:00\");\n\n    result = dao.getAllAfterDate(cutoff);\n\n    assertNotNull(result);\n    assertEquals(0, result.size());\n  }\n"}, {"dataset": "parse", "exampleID": 7794, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["error(*)"], "tryExpressionStart": 2129, "tryExpressionEnd": 2133, "tryBlockStart": 2129, "tryBlockEnd": 2294, "catchExpressionStart": 2242, "catchExpressionEnd": 2267, "catchBlockStart": 2242, "catchBlockEnd": 2294, "exceptionHandlingCallStart": [2275], "exceptionHandlingCallEnd": [2287], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 2191, "focalAPIEnd": 2233, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["println(dateTime)"], "useStart": [2141], "useEnd": [2234], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/student2ua/myTaning/tree/master/src/com/tor/text/FormatedOut_SimpleDateFormat.java", "rawCode": "  public static void main(String[] args) {\n\n    System.out.println(\"Задача: вывести текущую дату в виде число название месяца полный год:\");\n    SimpleDateFormat formatter = new SimpleDateFormat(\"dd MMMM yyyy\");\n    System.out.println(\"dd MMMM yyyy = \" + formatter.format(new Date(System.currentTimeMillis())));\n\n    /**\n     * Календарь используемый для форматирования можно установить с помощью setCalendar(), получить\n     * с помощью getCalendar().\n     */\n    System.out.println(\"Задача: получить текущую дату по буддийскому календарю:\");\n    formatter.setCalendar(new sun.util.BuddhistCalendar());\n    System.out.println(\"Buddhist = \" + formatter.format(new Date(System.currentTimeMillis())));\n\n    Locale ru = new Locale(\"ru\");\n    DateFormat sdf = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL, ru);\n    System.out.println(\"FULL \" + sdf.format(new Date()));\n    sdf = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, ru);\n    System.out.println(\"LONG \" + sdf.format(new Date()));\n    sdf = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM, ru);\n    System.out.println(\"MEDIUM \" + sdf.format(new Date()));\n    sdf = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, ru);\n    System.out.println(\"SHORT \" + sdf.format(new Date()));\n\n    System.out.println(\n        \"Задача: получить названия месяцев для русской локали \"\n            + \"в правильной словоформе (не 29 Сентябрь, а 29 сентября):\");\n\n    String[] months = {\n      \"января\",\n      \"февраля\",\n      \"марта\",\n      \"апреля\",\n      \"мая\",\n      \"июня\",\n      \"июля\",\n      \"августа\",\n      \"сентября\",\n      \"октября\",\n      \"ноября\",\n      \"декабря\"\n    };\n    DateFormatSymbols symbols = new DateFormatSymbols(new Locale(\"ru\"));\n    symbols.setMonths(months);\n    sdf = new SimpleDateFormat(\"dd MMMM yyyy г.\", symbols);\n    System.out.println(sdf.format(new Date()));\n\n    System.out.println(\n        \"Задача: перевести в дату время формирования файла с именем bakup_20050929_1836.rar\");\n    formatter = new SimpleDateFormat(\"'bakup_'yyyyMMdd_HHmm'.rar'\"); // Внимательно!!! доп символы '\n    try {\n      System.out.println(\"bakup_20050929_1836.rar = \" + formatter.parse(\"bakup_20050929_1836.rar\"));\n    } catch (ParseException e) {\n      log.error(e);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7795, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 719, "focalAPIEnd": 768, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setlog_time(dateTime)"], "useStart": [695], "useEnd": [769], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Dhandapani/gluster-ovirt/tree/master/backend/manager/modules/dal/src/test/java/org/ovirt/engine/core/dao/AuditLogDAOTest.java", "rawCode": "  @Override\n  @Before\n  public void setUp() throws Exception {\n    super.setUp();\n    dao = prepareDAO(dbFacade.getAuditLogDAO());\n\n    // create some test data\n    newAuditLog = new AuditLog();\n    newAuditLog.setaudit_log_id(44000);\n    newAuditLog.setuser_id(new Guid(\"9bf7c640-b620-456f-a550-0348f366544b\"));\n    newAuditLog.setuser_name(\"userportal3\");\n    newAuditLog.setvm_id(new Guid(\"77296e00-0cad-4e5a-9299-008a7b6f4355\"));\n    newAuditLog.setvm_name(VM_NAME);\n    newAuditLog.setvm_template_id(new Guid(\"1b85420c-b84c-4f29-997e-0eb674b40b79\"));\n    newAuditLog.setvm_template_name(VM_TEMPLATE_NAME);\n    newAuditLog.setvds_id(VDS_ID);\n    newAuditLog.setvds_name(\"magenta-vdsc\");\n    newAuditLog.setlog_time(EXPECTED_DATE_FORMAT.parse(\"2010-12-22 14:00:00\"));\n    newAuditLog.setlog_type(AuditLogType.IRS_DISK_SPACE_LOW_ERROR);\n    newAuditLog.setseverity(AuditLogSeverity.ERROR);\n    newAuditLog.setmessage(\"Critical, Low disk space. domain has 1 GB of free space\");\n    newAuditLog.setstorage_pool_id(new Guid(\"6d849ebf-755f-4552-ad09-9a090cda105d\"));\n    newAuditLog.setstorage_pool_name(\"rhel6.iscsi\");\n    newAuditLog.setstorage_domain_id(new Guid(\"72e3a666-89e1-4005-a7ca-f7548004a9ab\"));\n    newAuditLog.setstorage_domain_name(\"fDMzhE-wx3s-zo3q-Qcxd-T0li-yoYU-QvVePk\");\n    newAuditLog.setQuotaId(FixturesTool.DEFAULT_QUOTA_GENERAL);\n    newAuditLog.setQuotaName(\"General Quota\");\n    newAuditLog.setGlusterVolumeId(new Guid(\"0e0abdbc-2a0f-4df0-8b99-cc577a7a9bb5\"));\n    newAuditLog.setGlusterVolumeName(\"gluster_volume_name-1\");\n\n    existingAuditLog = dao.get(EXISTING_ENTRY_ID);\n  }\n"}, {"dataset": "parse", "exampleID": 7796, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 590, "tryExpressionEnd": 594, "tryBlockStart": 590, "tryBlockEnd": 712, "catchExpressionStart": 653, "catchExpressionEnd": 678, "catchBlockStart": 653, "catchBlockEnd": 712, "exceptionHandlingCallStart": [686], "exceptionHandlingCallEnd": [705], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 609, "focalAPIEnd": 645, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Calendar.setTime(dateTime)", "queryConnections(*,*,*,dateTime,boolean,int,*,*,*,*)"], "useStart": [777, 1105], "useEnd": [794, 1332], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/rovo89/public-transport-enabler-fork/tree/master/enabler/src/de/schildbach/pte/SadProvider.java", "rawCode": "  public QueryConnectionsResult queryMoreConnections(\n      final QueryConnectionsContext contextObj, final boolean later, final int numConnections)\n      throws IOException {\n    // Split and parse context\n    final Context context = (Context) contextObj;\n    final String commandUri = context.context;\n    final String[] split = commandUri.split(\",\");\n    if (split.length != 4) {\n      return null;\n    }\n    final int fromId = Integer.parseInt(split[0]);\n    final int toId = Integer.parseInt(split[1]);\n    final boolean dep = Boolean.parseBoolean(split[2]);\n    Date date = null;\n    try {\n      date = RESPONSE_DATE_FORMAT.parse(split[3]);\n    } catch (ParseException e) {\n      e.printStackTrace();\n    }\n    final Calendar cal = new GregorianCalendar(timeZone());\n    cal.setTime(date);\n\n    // Calculate new Date, depending on the specified next flag\n    cal.add(Calendar.HOUR_OF_DAY, later ? HOURS_AFTER_START : -HOURS_AFTER_START);\n    date = cal.getTime();\n\n    // Query for connections with new date/time value\n    // NOTE: via, products, walkSpeed, accessibility are set to null\n    return queryConnections(\n        new Location(LocationType.STATION, fromId),\n        null,\n        new Location(LocationType.STATION, toId),\n        date,\n        dep,\n        0,\n        null,\n        null,\n        null,\n        null);\n  }\n"}, {"dataset": "parse", "exampleID": 7797, "initialization": ["String the_text = getText()"], "initializationStart": [140], "initializationEnd": [149], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["simpleDateFormat.format(Date)"], "configurationStart": [170], "configurationEnd": [198], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 216, "focalAPIEnd": 248, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["SimpleDateFormat.format(dateTime)"], "useStart": [354], "useEnd": [381], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RamesesDev/osiris2/tree/master/client/rameses-client-ui/src/com/rameses/rcp/control/XDateField.java", "rawCode": "  private final void showFormattedValue(boolean formatted) {\n    try {\n      if (formatted && outputFormatter != null && !ValueUtil.isEmpty(getText())) {\n        setText(outputFormatter.format(date));\n        date = outputFormatter.parse(getText());\n      } else {\n\n        if (ValueUtil.isEmpty(getText())) setText(\"\");\n        else {\n          setText(inputFormatter.format(date));\n          date = inputFormatter.parse(getText());\n        }\n      }\n    } catch (Exception ex) {\n    }\n\n    if (!formatted) selectAll();\n  }\n"}, {"dataset": "parse", "exampleID": 7798, "initialization": ["SimpleDateFormat simpleDateFormat = ThreadLocal<Map<String, SimpleDateFormat>>.get()", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String,*)"], "initializationStart": [110, 174], "initializationEnd": [125, 218], "hasTryCatch": 1, "exceptionType": "ParseException", "exceptionHandlingCall": ["new TwitterException(String,*)"], "tryExpressionStart": 322, "tryExpressionEnd": 326, "tryBlockStart": 322, "tryBlockEnd": 512, "catchExpressionStart": 364, "catchExpressionEnd": 390, "catchBlockStart": 364, "catchBlockEnd": 512, "exceptionHandlingCallStart": [404], "exceptionHandlingCallEnd": [505], "configuration": ["simpleDateFormat.setTimeZone(TimeZone)"], "configurationStart": [226], "configurationEnd": [270], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 341, "focalAPIEnd": 356, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/florhaf/ravent/tree/master/service/lib/twitter4j-2.2.6/twitter4j-core/src/main/java/twitter4j/internal/util/z_T4JInternalParseUtil.java", "rawCode": "  public static Date getDate(String name, String format) throws TwitterException {\n    SimpleDateFormat sdf = formatMap.get().get(format);\n    if (null == sdf) {\n      sdf = new SimpleDateFormat(format, Locale.ENGLISH);\n      sdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n      formatMap.get().put(format, sdf);\n    }\n    try {\n      return sdf.parse(name);\n    } catch (ParseException pe) {\n      throw new TwitterException(\n          \"Unexpected date format(\" + name + \") returned from twitter.com\", pe);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7799, "initialization": ["String the_text = evaluate(String,Document,*)", "SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [252, 342], "initializationEnd": [310, 379], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["error(String,*)", "new Date(int)"], "tryExpressionStart": 37, "tryExpressionEnd": 41, "tryBlockStart": 37, "tryBlockEnd": 549, "catchExpressionStart": 452, "catchExpressionEnd": 472, "catchBlockStart": 452, "catchBlockEnd": 549, "exceptionHandlingCallStart": [480, 531], "exceptionHandlingCallEnd": [516, 542], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 402, "focalAPIEnd": 420, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/zqsd/jmc2obj/tree/master/src/org/jmc/CheckUpdate.java", "rawCode": "  public static Date getDate() {\n    try {\n\n      URL updateLink = new URL(\"http://jmc2obj.net/update.xml\");\n      Document doc = Xml.loadDocument(updateLink);\n      XPath xpath = XPathFactory.newInstance().newXPath();\n\n      String datestr = (String) xpath.evaluate(\"/update/date\", doc, XPathConstants.STRING);\n\n      SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMMdd hhmm\");\n      Date newdate = sdf.parse(datestr);\n\n      return newdate;\n\n    } catch (Exception e) {\n      Log.error(\"Cannot check update \", e);\n      return new Date(0);\n    }\n  }\n"}, {"dataset": "parse", "exampleID": 7800, "initialization": ["SimpleDateFormat simpleDateFormat = new SimpleDateFormat(String)"], "initializationStart": [416], "initializationEnd": [448], "hasTryCatch": 1, "exceptionType": "PageLevelException", "exceptionHandlingCall": ["getMessage()", "addAttribute(String,*)"], "tryExpressionStart": 484, "tryExpressionEnd": 488, "tryBlockStart": 484, "tryBlockEnd": 603, "catchExpressionStart": 977, "catchExpressionEnd": 1023, "catchBlockStart": 977, "catchBlockEnd": 1135, "exceptionHandlingCallStart": [1063, 1031], "exceptionHandlingCallEnd": [1094, 1095], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "the_text!=null", "guardType": "IF {", "guardExpressionStart": 496, "guardExpressionEnd": 513, "guardBlockStart": 496, "guardBlockEnd": 563, "focalAPI": "dateTime = simpleDateFormat.parse(the_text)", "focalAPIStart": 539, "focalAPIEnd": 554, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["retrieveEditEvent(*,Long,Long,dateTime)"], "useStart": [648], "useEnd": [757], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/NewMediaCenter/MobileWeb/tree/master/events/web/src/main/java/org/kuali/mobility/events/controllers/CalendarController.java", "rawCode": "  @RequestMapping(value = \"/editEvent\", method = RequestMethod.GET)\n  public String editEvent(\n      HttpServletRequest request,\n      Model uiModel,\n      @RequestParam(required = true) Long eventId,\n      @RequestParam(required = false) Long seriesId,\n      @RequestParam(required = false) String date) {\n    User user = (User) request.getSession().getAttribute(Constants.KME_USER_KEY);\n    SimpleDateFormat sdf = new SimpleDateFormat(\"MMddyyyy\");\n    Date selectedDate = null;\n    try {\n      if (date != null) {\n        selectedDate = sdf.parse(date);\n      }\n    } catch (ParseException e) {\n\n    }\n    try {\n      EditEvent event =\n          calendarEventOAuthService.retrieveEditEvent(\n              user.getUserId(), eventId, seriesId, selectedDate);\n      uiModel.addAttribute(\"event\", event);\n      if (seriesId == null) {\n        uiModel.addAttribute(\"seriesId\", event.getSeriesId());\n      } else {\n        uiModel.addAttribute(\"seriesId\", seriesId);\n      }\n    } catch (PageLevelException pageLevelException) {\n      uiModel.addAttribute(\"message\", pageLevelException.getMessage());\n      return \"calendar/message\";\n    }\n    return \"calendar/editEvent\";\n  }\n"}]