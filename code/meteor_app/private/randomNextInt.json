[{"dataset": "randomNextInt", "exampleID": 6601, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 135, "focalAPIEnd": 157, "followUpCheck": "true || (paramInt2 + element + 1 > paramWorld.height)", "checkType": "IF", "followUpCheckExpressionStart": 299, "followUpCheckExpressionEnd": 362, "followUpCheckBlockStart": 299, "followUpCheckBlockEnd": 376, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/DjDCH/OneHundredGenerator/tree/master/src/com/djdch/bukkit/onehundredgenerator/mc100/WorldGenSwampTree.java", "rawCode": "  @Override\n  public boolean a(\n      World paramWorld, Random paramRandom, int paramInt1, int paramInt2, int paramInt3) {\n    int i = paramRandom.nextInt(4) + 5;\n    while (paramWorld.getMaterial(paramInt1, paramInt2 - 1, paramInt3) == Material.WATER) {\n      paramInt2--;\n    }\n    int j = 1;\n    if ((paramInt2 < 1) || (paramInt2 + i + 1 > paramWorld.height)) return false;\n    int n;\n    int i1;\n    int i2;\n    int k;\n    int m;\n    for (k = paramInt2; k <= paramInt2 + 1 + i; k++) {\n      m = 1;\n      if (k == paramInt2) m = 0;\n      if (k >= paramInt2 + 1 + i - 2) m = 3;\n      for (n = paramInt1 - m; (n <= paramInt1 + m) && (j != 0); n++) {\n        for (i1 = paramInt3 - m; (i1 <= paramInt3 + m) && (j != 0); i1++) {\n          if ((k >= 0) && (k < paramWorld.height)) {\n            i2 = paramWorld.getTypeId(n, k, i1);\n            if ((i2 != 0) && (i2 != Block.LEAVES.id))\n              if ((i2 == Block.STATIONARY_WATER.id) || (i2 == Block.WATER.id)) {\n                if (k > paramInt2) j = 0;\n              } else j = 0;\n          } else {\n            j = 0;\n          }\n        }\n      }\n    }\n\n    if (j == 0) return false;\n\n    k = paramWorld.getTypeId(paramInt1, paramInt2 - 1, paramInt3);\n    if (((k != Block.GRASS.id) && (k != Block.DIRT.id)) || (paramInt2 >= paramWorld.height - i - 1))\n      return false;\n\n    paramWorld.setRawTypeId(paramInt1, paramInt2 - 1, paramInt3, Block.DIRT.id);\n    int i3;\n    for (m = paramInt2 - 3 + i; m <= paramInt2 + i; m++) {\n      n = m - (paramInt2 + i);\n      i1 = 2 - n / 2;\n      for (i2 = paramInt1 - i1; i2 <= paramInt1 + i1; i2++) {\n        i3 = i2 - paramInt1;\n        for (int i4 = paramInt3 - i1; i4 <= paramInt3 + i1; i4++) {\n          int i5 = i4 - paramInt3;\n          if (((Math.abs(i3) != i1)\n                  || (Math.abs(i5) != i1)\n                  || ((paramRandom.nextInt(2) != 0) && (n != 0)))\n              && (Block.o[paramWorld.getTypeId(i2, m, i4)] == false))\n            paramWorld.setRawTypeId(i2, m, i4, Block.LEAVES.id);\n        }\n      }\n    }\n\n    for (m = 0; m < i; m++) {\n      n = paramWorld.getTypeId(paramInt1, paramInt2 + m, paramInt3);\n      if ((n != 0)\n          && (n != Block.LEAVES.id)\n          && (n != Block.WATER.id)\n          && (n != Block.STATIONARY_WATER.id)) continue;\n      paramWorld.setRawTypeId(paramInt1, paramInt2 + m, paramInt3, Block.LOG.id);\n    }\n\n    for (m = paramInt2 - 3 + i; m <= paramInt2 + i; m++) {\n      n = m - (paramInt2 + i);\n      i1 = 2 - n / 2;\n      for (i2 = paramInt1 - i1; i2 <= paramInt1 + i1; i2++) {\n        for (i3 = paramInt3 - i1; i3 <= paramInt3 + i1; i3++) {\n          if (paramWorld.getTypeId(i2, m, i3) == Block.LEAVES.id) {\n            if ((paramRandom.nextInt(4) == 0) && (paramWorld.getTypeId(i2 - 1, m, i3) == 0)) {\n              a(paramWorld, i2 - 1, m, i3, 8);\n            }\n            if ((paramRandom.nextInt(4) == 0) && (paramWorld.getTypeId(i2 + 1, m, i3) == 0)) {\n              a(paramWorld, i2 + 1, m, i3, 2);\n            }\n            if ((paramRandom.nextInt(4) == 0) && (paramWorld.getTypeId(i2, m, i3 - 1) == 0)) {\n              a(paramWorld, i2, m, i3 - 1, 1);\n            }\n            if ((paramRandom.nextInt(4) == 0) && (paramWorld.getTypeId(i2, m, i3 + 1) == 0)) {\n              a(paramWorld, i2, m, i3 + 1, 4);\n            }\n          }\n        }\n      }\n    }\n    return true;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6602, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 72, "tryExpressionEnd": 76, "tryBlockStart": 72, "tryBlockEnd": 212, "catchExpressionStart": 160, "catchExpressionEnd": 180, "catchBlockStart": 160, "catchBlockEnd": 212, "exceptionHandlingCallStart": [731], "exceptionHandlingCallEnd": [750], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 124, "focalAPIEnd": 147, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["sleep(element)", "random.nextInt(int)", "sleep(element)"], "useStart": [88, 594, 558], "useEnd": [148, 617, 618], "hasFinally": 1, "cleanUpCall": ["ResultSet.close()"], "finallyExpressionStart": 833, "finallyExpressionEnd": 841, "finallyBlockStart": 833, "finallyBlockEnd": 1116, "cleanUpCallStart": [871], "cleanUpCallEnd": [883], "url": "https://github.com/svn2github/apache-commons-dbcp/tree/master/tags/jwsdp_10_02/src/test/org/apache/commons/dbcp/TestJOCLed.java", "rawCode": "    public void run() {\n      for (int i = 0; i < _iter; i++) {\n        try {\n          Thread.currentThread().sleep((long) _random.nextInt(_delay));\n        } catch (Exception e) {\n          // ignored\n        }\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rset = null;\n        try {\n          conn = DriverManager.getConnection(\"jdbc:apache:commons:dbcp:/testpool\");\n          stmt = conn.prepareStatement(\"select 'literal', SYSDATE from dual\");\n          rset = stmt.executeQuery();\n          try {\n            Thread.currentThread().sleep((long) _random.nextInt(_delay));\n          } catch (Exception e) {\n            // ignored\n          }\n        } catch (Exception e) {\n          e.printStackTrace();\n          _failed = true;\n          _complete = true;\n          break;\n        } finally {\n          try {\n            rset.close();\n          } catch (Exception e) {\n          }\n          try {\n            stmt.close();\n          } catch (Exception e) {\n          }\n          try {\n            conn.close();\n          } catch (Exception e) {\n          }\n        }\n      }\n      _complete = true;\n    }\n"}, {"dataset": "randomNextInt", "exampleID": 6603, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 358, "focalAPIEnd": 400, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt(int)"], "useStart": [403], "useEnd": [422], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/patrickangeles/hush/tree/master/src/main/java/com/hbasebook/hush/UserManager.java", "rawCode": "  /**\n   * Returns a \"random\" IP address based on weighted blocks of IP ranges. The idea is to not get\n   * roughly the same amount of hits per country but get some more popular to those that have barely\n   * any hits. Clear, Eh?\n   *\n   * @return\n   */\n  private String getRandomIp() {\n    return String.format(\n        \"%s.%d\",\n        IP_BLOCK_BY_COUNTRY[RANDOM.nextInt(IP_BLOCK_BY_COUNTRY.length)], RANDOM.nextInt(255));\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6604, "initialization": ["Random random = new Random(*)"], "initializationStart": [214], "initializationEnd": [252], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 38, "tryExpressionEnd": 42, "tryBlockStart": 38, "tryBlockEnd": 943, "catchExpressionStart": 889, "catchExpressionEnd": 909, "catchBlockStart": 889, "catchBlockEnd": 943, "exceptionHandlingCallStart": [917], "exceptionHandlingCallEnd": [936], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 330, "focalAPIEnd": 341, "followUpCheck": "element < 0", "checkType": "IF", "followUpCheckExpressionStart": 357, "followUpCheckExpressionEnd": 367, "followUpCheckBlockStart": 357, "followUpCheckBlockEnd": 381, "use": ["random.nextDouble()", "random.nextBoolean()"], "useStart": [443, 484], "useEnd": [457, 499], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/paulvlase/auction_house/tree/master/apache-tomcat-7.0.40/webapps/examples/WEB-INF/classes/async/Stockticker.java", "rawCode": "  @Override\n  public void run() {\n    try {\n\n      Stock[] stocks =\n          new Stock[] {\n            new Stock(\"GOOG\", 435.43), new Stock(\"YHOO\", 27.88), new Stock(\"ASF\", 1015.55),\n          };\n      Random r = new Random(System.currentTimeMillis());\n      while (run) {\n        for (int j = 0; j < 1; j++) {\n          int i = r.nextInt() % 3;\n          if (i < 0) i = i * (-1);\n          Stock stock = stocks[i];\n          double change = r.nextDouble();\n          boolean plus = r.nextBoolean();\n          if (plus) {\n            stock.setValue(stock.getValue() + change);\n          } else {\n            stock.setValue(stock.getValue() - change);\n          }\n          stock.setCnt(++ticknr);\n          for (TickListener l : listeners) {\n            l.tick(stock);\n          }\n        }\n        Thread.sleep(850);\n      }\n    } catch (InterruptedException ix) {\n      // Ignore\n    } catch (Exception x) {\n      x.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6605, "initialization": ["Random random = new Random()"], "initializationStart": [89], "initializationEnd": [101], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 275, "focalAPIEnd": 292, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt(int)"], "useStart": [308], "useEnd": [325], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gcastigl/SIA1C2012/tree/master/TPE_pre1/src/edificios/LevelGenerator.java", "rawCode": "  public static void main(String[] args) {\n\n    m = new int[dim][dim];\n    Random rand = new Random();\n    int count = dim * 5;\n    numbers = new int[dim];\n    int i, j;\n    for (i = 0; i < dim; i++) {\n      numbers[i] = i + 1;\n    }\n    while (count-- != 0) {\n      int a = rand.nextInt(dim);\n      int b = rand.nextInt(dim);\n      j = numbers[a];\n      numbers[a] = numbers[b];\n      numbers[b] = j;\n    }\n    for (i = 0; i < dim; i++) {\n      System.out.println(numbers[i]);\n    }\n    for (i = 0; i < dim; i++) {\n      for (j = 0; j < dim; j++) {\n        m[i][j] = 0;\n      }\n    }\n    fillSpace(0, 0);\n    for (i = 0; i < dim; i++) {\n      String pr = \"\";\n      for (j = 0; j < dim; j++) {\n        pr += m[i][j] + \",\";\n      }\n      System.out.println(pr);\n    }\n    System.out.println(\"FILE\");\n    System.out.println(\"-------------\");\n    System.out.println(dim);\n    String pr = \"\";\n    for (i = 0; i < dim; i++) {\n\n      int h = checkHeight(0, i, 1, 0);\n      pr += h;\n      if (i != dim - 1) {\n        pr += \",\";\n      }\n    }\n    System.out.println(pr);\n    pr = \"\";\n    for (i = 0; i < dim; i++) {\n\n      int h = checkHeight(dim - 1, i, -1, 0);\n      pr += h;\n      if (i != dim - 1) {\n        pr += \",\";\n      }\n    }\n    System.out.println(pr);\n    pr = \"\";\n    for (i = 0; i < dim; i++) {\n\n      int h = checkHeight(i, 0, 0, 1);\n      pr += h;\n      if (i != dim - 1) {\n        pr += \",\";\n      }\n    }\n    System.out.println(pr);\n    pr = \"\";\n    for (i = 0; i < dim; i++) {\n\n      int h = checkHeight(i, dim - 1, 0, -1);\n      pr += h;\n      if (i != dim - 1) {\n        pr += \",\";\n      }\n    }\n    System.out.println(pr);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6606, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 177, "focalAPIEnd": 192, "followUpCheck": "!set.contains(bound - element)", "checkType": "LOOP {", "followUpCheckExpressionStart": 222, "followUpCheckExpressionEnd": 258, "followUpCheckBlockStart": 222, "followUpCheckBlockEnd": 345, "use": ["Set<Integer>.add(element)", "random.nextInt(int)"], "useStart": [269, 321], "useEnd": [284, 336], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thrap/project-euler/tree/master/src/Java/Problem371BaseCase.java", "rawCode": "  public static void main(String[] args) {\n    double totalPlates = 0;\n    for (int i = 0; i < TESTS; i++) {\n      Set<Integer> set = new HashSet<Integer>();\n      int number = R.nextInt(1000);\n      int plates = 1;\n      while (!set.contains(1000 - number)) {\n        set.add(number);\n        plates++;\n        number = R.nextInt(1000);\n      }\n      totalPlates += plates;\n    }\n    System.out.println(totalPlates / TESTS);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6607, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 104, "focalAPIEnd": 120, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/liucong/jms4cxf2/tree/master/rt/databinding/aegis/src/main/java/org/apache/cxf/aegis/util/UID.java", "rawCode": "  public static String generate() {\n    return String.valueOf(System.currentTimeMillis()) + counter++ + random.nextInt();\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6608, "initialization": ["Random random = new Random()"], "initializationStart": [471], "initializationEnd": [483], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 645, "focalAPIEnd": 660, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AsherBond/opentaps/tree/master/applications/order/src/org/ofbiz/order/finaccount/FinAccountHelper.java", "rawCode": "  /**\n   * @param delegator\n   * @param length length of the number to generate (up to 19 digits)\n   * @param isId to be used as an ID (will check the DB to make sure it doesn't already exist)\n   * @return String generated number\n   * @throws GenericEntityException\n   */\n  public static String generateRandomFinNumber(Delegator delegator, int length, boolean isId)\n      throws GenericEntityException {\n    if (length > 19) {\n      length = 19;\n    }\n\n    Random rand = new Random();\n    boolean isValid = false;\n    String number = null;\n    while (!isValid) {\n      number = \"\";\n      for (int i = 0; i < length; i++) {\n        int randInt = rand.nextInt(9);\n        number = number + randInt;\n      }\n\n      if (isId) {\n        int check = UtilValidate.getLuhnCheckDigit(number);\n        number = number + check;\n\n        // validate the number\n        if (checkFinAccountNumber(number)) {\n          // make sure this number doens't already exist\n          isValid = checkIsNumberInDatabase(delegator, number);\n        }\n      } else {\n        isValid = true;\n      }\n    }\n    return number;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6609, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 89, "focalAPIEnd": 101, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new IncrementalGivens(element)", "new Matrix(int,element)"], "useStart": [163, 205], "useEnd": [187, 221], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/soartech/soar/tree/master/Domains/RoomsWorld/april/java/src/april/jmat/IncrementalGivens.java", "rawCode": "  public static void main(String args[]) {\n    Random r = new Random();\n\n    int n = 3 + r.nextInt(5);\n    int m = n + r.nextInt(10);\n    IncrementalGivens incg = new IncrementalGivens(n);\n\n    Matrix A = new Matrix(m, n);\n    double b[] = new double[m];\n\n    for (int row = 0; row < A.getRowDimension(); row++) {\n      int nz = 1 + r.nextInt(n - 2);\n      for (int j = 0; j < nz; j++) {\n        while (true) {\n          int col = r.nextInt(A.getColumnDimension());\n          if (A.get(row, col) != 0) continue;\n          A.set(row, col, 10 * (r.nextDouble() - .5));\n          break;\n        }\n      }\n      b[row] = 10 * (r.nextDouble() - .5);\n    }\n    A = A.coerceOption(Matrix.SPARSE);\n    /*\n    Matrix A = new Matrix( new double[][] {\n    { 1, 1, 0, 0, 0},\n    { 0, 1, 1, 0, 0},\n    { 0, 0, 1, 1, 0},\n    { 0, 0, 0, 1, 1},\n    { 1, 0, 0, 0, 1},\n    { 1, 0, 0, 1, 1},\n    { 1, 0, 1, 0, 0} }).coerceOption(Matrix.SPARSE);\n\n    double b[] = new double[] { 1, 5, 8, 9, 10, 12, 15 };\n    */\n\n    Matrix At = A.transpose();\n    LinAlg.print(At.times(A).inverse().times(At.times(b)));\n\n    incg.addRows(matrixToCSRVec(A), b);\n\n    LinAlg.print(incg.solve());\n    System.out.printf(\"nrotations: %d\\n\", incg.nrotations);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6610, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["random.nextFloat()", "random.nextFloat()", "random.nextFloat()"], "configurationStart": [553, 613, 712], "configurationEnd": [576, 636, 735], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 869, "focalAPIEnd": 892, "followUpCheck": "element > itemstack.stackSize", "checkType": "IF", "followUpCheckExpressionStart": 912, "followUpCheckExpressionEnd": 941, "followUpCheckBlockStart": 912, "followUpCheckBlockEnd": 997, "use": ["new ItemStack(*,element,*)"], "useStart": [1238], "useEnd": [1300], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/carneymo/learncraft/tree/master/common/LBlockChest.java", "rawCode": "  /** ejects contained items into the world, and notifies neighbours of an update, as appropriate */\n  @Override\n  public void breakBlock(World par1World, int par2, int par3, int par4, int par5, int par6) {\n    TileEntityLChest TileEntityLChest =\n        (TileEntityLChest) par1World.getBlockTileEntity(par2, par3, par4);\n\n    if (TileEntityLChest != null) {\n      for (int j1 = 0; j1 < TileEntityLChest.getSizeInventory(); ++j1) {\n        ItemStack itemstack = TileEntityLChest.getStackInSlot(j1);\n\n        if (itemstack != null) {\n          float f = this.random.nextFloat() * 0.8F + 0.1F;\n          float f1 = this.random.nextFloat() * 0.8F + 0.1F;\n          EntityItem entityitem;\n\n          for (float f2 = this.random.nextFloat() * 0.8F + 0.1F;\n              itemstack.stackSize > 0;\n              par1World.spawnEntityInWorld(entityitem)) {\n            int k1 = this.random.nextInt(21) + 10;\n\n            if (k1 > itemstack.stackSize) {\n              k1 = itemstack.stackSize;\n            }\n\n            itemstack.stackSize -= k1;\n            entityitem =\n                new EntityItem(\n                    par1World,\n                    par2 + f,\n                    par3 + f1,\n                    par4 + f2,\n                    new ItemStack(itemstack.itemID, k1, itemstack.getItemDamage()));\n            float f3 = 0.05F;\n            entityitem.motionX = (float) this.random.nextGaussian() * f3;\n            entityitem.motionY = (float) this.random.nextGaussian() * f3 + 0.2F;\n            entityitem.motionZ = (float) this.random.nextGaussian() * f3;\n\n            if (itemstack.hasTagCompound()) {\n              entityitem\n                  .getEntityItem()\n                  .setTagCompound((NBTTagCompound) itemstack.getTagCompound().copy());\n            }\n          }\n        }\n      }\n\n      par1World.func_96440_m(par2, par3, par4, par5);\n    }\n\n    super.breakBlock(par1World, par2, par3, par4, par5, par6);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6611, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 461, "focalAPIEnd": 481, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jevinskie/contiki/tree/master/tools/cooja/examples/appmote_rimeabc/RimeABC.java", "rawCode": "  public void execute(long time) {\n    /*System.out.println(this + \": execute(\" + time + \")\");*/\n\n    if (radio == null) {\n      simulation = getSimulation();\n      random = simulation.getRandomGenerator();\n      radio = (ApplicationRadio) getInterfaces().getRadio();\n      leds = (ApplicationLED) getInterfaces().getLED();\n    }\n\n    /* Delay 2-4 seconds */\n    simulation.scheduleEvent(\n        transmitEvent,\n        simulation.getSimulationTime() + (2000 + random.nextInt(2000)) * Simulation.MILLISECOND);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6612, "initialization": ["Random random = new Random()"], "initializationStart": [57], "initializationEnd": [69], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 106, "focalAPIEnd": 121, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt(int)", "random.nextInt(int)", "random.nextInt(int)", "random.nextInt(int)", "random.nextInt(int)"], "useStart": [942, 1154, 1323, 1404, 1524], "useEnd": [962, 1174, 1343, 1421, 1544], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/marcou/mysecondproject/tree/master/src/com/gra/gra/SpaceShip.java", "rawCode": "  public void calculateProperties() {\n\n    Random rand = new Random();\n\n    int interval;\n\n    interval = rand.nextInt(4);\n\n    /**\n     * ******************************************************** z katami bedzie troche roboty bo :\n     * ________________ o - obiekt1 | | --> skraj mapy | | | | | | o - obiekt2 | O - ziemia | | | |\n     * | | o - obiekt3 |_______________|\n     *\n     * <p>w takiej sytuacji obiekt : 1 - powinien miec kat w przedziale 0 - 90 2 - powinien miec kat\n     * w przedziale 315 - 45 3 - powinien miec kat w przedziale 270 - 360\n     *\n     * <p>stad ponizszy wzor na kat : (w zaleznosci ktora z 4 mozliwosci, w tym przykladzie x =\n     * (-79, 0) i y (0, 879))[rysunek u gory] kat = random(90) + - y/880 (liczba z przedzialu 0 - 1)\n     * * 90 ********************************************************\n     */\n    switch (interval) {\n        // lewa\n      case 0:\n        x = area_x; // rand.nextInt(80);\n        y = rand.nextInt(area_h);\n        angle = 90 - rand.nextInt(180); // rand.nextInt(90) - (int)((y/879.0)*90.0);\n        break;\n        // prawa\n      case 1:\n        x = area_w; // 480 + rand.nextInt(80);\n        y = rand.nextInt(area_h);\n        angle = 90 + rand.nextInt(180); // rand.nextInt(90) + (int)((y/879.0)*90.0) + 90;\n        break;\n        // gora\n      case 2:\n        x = rand.nextInt(area_w);\n        y = area_y; // - rand.nextInt(80);\n        angle = rand.nextInt(180); // rand.nextInt(90) + (int)((x/559.0)*90.0);\n        break;\n        // dol\n      case 3:\n        x = rand.nextInt(area_w);\n        y = area_h; // 800 + rand.nextInt(80);\n        angle = 180 + rand.nextInt(180); // rand.nextInt(90) - (int)((x/559.0)*90.0) + 270;\n        break;\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6613, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 35, "focalAPIEnd": 46, "followUpCheck": "element < 0", "checkType": "IF", "followUpCheckExpressionStart": 56, "followUpCheckExpressionEnd": 66, "followUpCheckBlockStart": 56, "followUpCheckBlockEnd": 74, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/joeytwiddle/code/tree/master/java/gfx/CyberPet/CyberPet.java", "rawCode": "  boolean rnd(int p) {\n    int q = r.nextInt() % p;\n    if (q < 0) q = -q;\n    if (q == 0) return true;\n    else return false;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6614, "initialization": ["Random random = new Random()"], "initializationStart": [90], "initializationEnd": [102], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 127, "focalAPIEnd": 143, "followUpCheck": "element < 0", "checkType": "IF", "followUpCheckExpressionStart": 151, "followUpCheckExpressionEnd": 170, "followUpCheckBlockStart": 151, "followUpCheckBlockEnd": 218, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jonbaraq/linked-data-visualization-tools/tree/master/src/main/java/es/upm/fi/dia/oeg/map4rdf/server/servlet/FileUploadServlet.java", "rawCode": "  private String createDirectory() {\n    File file = null;\n    do {\n      Random random = new Random();\n      int nextRandom = random.nextInt();\n      if (nextRandom < 0) {\n        nextRandom = nextRandom * -1;\n      }\n      file = new File(UPLOAD_DIRECTORY + \"/\" + nextRandom);\n    } while (file.exists());\n    file.mkdirs();\n\n    return file.getAbsolutePath();\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6615, "initialization": ["Random random = new Random(*)"], "initializationStart": [178], "initializationEnd": [196], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 916, "focalAPIEnd": 930, "followUpCheck": "element >= sNumCharacterClasses", "checkType": "IF", "followUpCheckExpressionStart": 940, "followUpCheckExpressionEnd": 978, "followUpCheckBlockStart": 940, "followUpCheckBlockEnd": 1061, "use": ["random.nextInt(int)", "CounterHelper.addChar(element)"], "useStart": [1187, 1249], "useEnd": [1209, 1270], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/STS-Dev-Team/android_frameworks_opt_telephony/tree/master/tests/telephonytests/src/com/android/internal/telephony/SmsMessageBodyTest.java", "rawCode": "  @LargeTest\n  public void testCalcLengthMixed7bit() throws Exception {\n    StringBuilder sb = new StringBuilder(320);\n    CounterHelper ch = new CounterHelper();\n    Random r = new Random(0x4321); // use the same seed for reproducibility\n    int[] expectedValues = new int[6];\n    int[] origLockingShiftTables = GsmAlphabet.getEnabledLockingShiftTables();\n    int[] origSingleShiftTables = GsmAlphabet.getEnabledSingleShiftTables();\n    int enabledLanguagesTestCases = sEnabledSingleShiftTables.length;\n    long startTime = System.currentTimeMillis();\n\n    // Repeat for 10 test runs\n    for (int run = 0; run < 10; run++) {\n      sb.setLength(0);\n      ch.clear();\n      int unicodeOnlyCount = 0;\n\n      // Test incrementally from 1 to 320 character random messages\n      for (int i = 1; i < 320; i++) {\n        // 1% chance to add from each special character class, else add an ASCII char\n        int charClass = r.nextInt(100);\n        if (charClass >= sNumCharacterClasses) {\n          charClass = sNumCharacterClasses - 1; // last class is ASCII\n        }\n        int classLength = sCharacterClasses[charClass].length();\n        char nextChar = sCharacterClasses[charClass].charAt(r.nextInt(classLength));\n        sb.append(nextChar);\n        ch.addChar(charClass);\n\n        // if (i % 20 == 0) {\n        // Log.d(TAG, \"test string: \" + sb);\n        // }\n\n        // Test string against all combinations of enabled languages\n        boolean unicodeOnly = true;\n        for (int j = 0; j < enabledLanguagesTestCases; j++) {\n          GsmAlphabet.setEnabledSingleShiftTables(sEnabledSingleShiftTables[j]);\n          GsmAlphabet.setEnabledLockingShiftTables(sEnabledLockingShiftTables[j]);\n          ch.fillData(j, false, expectedValues, i);\n          if (expectedValues[3] == SmsConstants.ENCODING_7BIT) {\n            unicodeOnly = false;\n          }\n          callGsmLengthMethods(sb, false, expectedValues);\n          // test 7 bit only mode\n          ch.fillData(j, true, expectedValues, i);\n          callGsmLengthMethods(sb, true, expectedValues);\n        }\n        // after 10 iterations with a Unicode-only string, skip to next test string\n        // so we can spend more time testing strings that do encode into 7 bits.\n        if (unicodeOnly && ++unicodeOnlyCount == 10) {\n          // Log.d(TAG, \"Unicode only: skipping to next test string\");\n          break;\n        }\n      }\n    }\n    ch.printStats();\n    Log.d(TAG, \"Completed in \" + (System.currentTimeMillis() - startTime) + \" ms\");\n    GsmAlphabet.setEnabledLockingShiftTables(origLockingShiftTables);\n    GsmAlphabet.setEnabledSingleShiftTables(origSingleShiftTables);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6616, "initialization": ["Random random = new Random()"], "initializationStart": [66], "initializationEnd": [78], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 93, "focalAPIEnd": 107, "followUpCheck": "i < element + 10", "checkType": "LOOP", "followUpCheckExpressionStart": 234, "followUpCheckExpressionEnd": 267, "followUpCheckBlockStart": 234, "followUpCheckBlockEnd": 320, "use": ["random.nextInt(int)", "random.nextInt()", "random.nextLong()", "random.nextLong()"], "useStart": [128, 300, 429, 472], "useEnd": [143, 311, 441, 484], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/CVi/Fellesprosjekt/tree/master/Fellesprosjektet/src/org/vikenpedia/fellesprosjekt/test/TestWeek.java", "rawCode": "  @Before\n  public void setUp() throws Exception {\n    Random r = new Random();\n    int n1 = r.nextInt(500) + 500;\n    int n2 = r.nextInt(1000) + 1000;\n    cals = new ArrayList<FpCalendar>();\n    meets = new ArrayList<Meeting>();\n    for (int i = 1; i < n1 + 10; i++) {\n      cals.add(new FpCalendar(r.nextInt()));\n    }\n    for (int i = 1; i < n2 + 10; i++) {\n      meets.add(\n          new Meeting(\n              new Timestamp(r.nextLong()),\n              new Timestamp(r.nextLong()),\n              UUID.randomUUID().toString(),\n              UUID.randomUUID().toString(),\n              r.nextInt()));\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6617, "initialization": ["Random random = new Random()"], "initializationStart": [305], "initializationEnd": [317], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 338, "focalAPIEnd": 354, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt()", "new Point(element,int)"], "useStart": [375, 426], "useEnd": [391, 441], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/scs/uclinux/tree/master/lib/classpath/examples/gnu/classpath/examples/datatransfer/Demo.java", "rawCode": "  /**\n   * The Object Panel holds a simple (Point) object that can be copied and pasted to another program\n   * that supports exchanging serialized objects.\n   */\n  private Panel createObjectPanel() {\n    Panel objectPanel = new Panel();\n    objectPanel.setLayout(new BorderLayout());\n    Random random = new Random();\n    int x = (byte) random.nextInt();\n    int y = (byte) random.nextInt();\n    object = new ObjectComponent(new Point(x, y));\n    Panel objectButtons = new Panel();\n    copyObject = new Button(\"Copy object\");\n    copyObject.addActionListener(this);\n    pasteObject = new Button(\"Paste object\");\n    pasteObject.addActionListener(this);\n    objectButtons.add(copyObject);\n    objectButtons.add(pasteObject);\n    objectPanel.add(object, BorderLayout.CENTER);\n    objectPanel.add(objectButtons, BorderLayout.SOUTH);\n    return objectPanel;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6618, "initialization": ["Random random = new Random()"], "initializationStart": [51], "initializationEnd": [63], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 82, "focalAPIEnd": 112, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["encode(element)", "assertEquals(element,int)"], "useStart": [149, 180], "useEnd": [173, 208], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/yokuyuki/Enrichr/tree/master/src/test/java/edu/mssm/pharm/maayanlab/Enrichr/ShortenerTest.java", "rawCode": "  public void testEquivalency() {\n    Random rng = new Random();\n    int number = rng.nextInt(Integer.MAX_VALUE);\n\n    int result = Shortener.decode(Shortener.encode(number));\n    assertEquals(number, result);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6619, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 433, "focalAPIEnd": 445, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/benbai123/ZK_Practice/tree/master/Components/projects/Addon_Practice/PivottableTest/GetDistinctFieldValue/src/test/PivotModelProvider.java", "rawCode": "  /**\n   * prepare the data for pivottable's model The order of object put into data list matches the\n   * order of column names\n   *\n   * @return\n   * @throws Exception\n   */\n  public List<List<Object>> getData() {\n    List<List<Object>> result = new ArrayList<List<Object>>();\n    Random r = new Random();\n\n    for (int i = 0; i < 100; i++) {\n      List<Object> data = new ArrayList<Object>();\n      data.add(\"Row_Level_001 - \" + (r.nextInt(5) + 1));\n      data.add(\"Row_Level_002 - \" + (r.nextInt(5) + 1));\n      data.add(\"Row_Level_003 - \" + (r.nextInt(5) + 1));\n      data.add(\"Row_Level_004 - \" + (r.nextInt(5) + 1));\n      data.add(\"Column_Level_001 - \" + (r.nextInt(5) + 1));\n      data.add(\"Column_Level_002 - \" + (r.nextInt(5) + 1));\n      data.add(r.nextInt(10000));\n      data.add(r.nextDouble() * 10000.0);\n      data.add(r.nextInt(100));\n      result.add(data);\n    }\n    return result;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6620, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 441, "focalAPIEnd": 461, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jamie-bates-8/Mario-Kart-GL/tree/master/Mario-Kart-OpenGL-Demo/src/bates/jamie/graphics/particle/RainDrop.java", "rawCode": "  private void recycle() {\n    position =\n        new Vec2(\n            Scene.singleton.getWidth() * generator.nextFloat(),\n            Scene.singleton.getHeight() * generator.nextFloat() - 200);\n    direction = Vec2.getRandomVector();\n\n    stationary = generator.nextFloat() < 0.2;\n\n    acceleration = 0.75f + generator.nextFloat() * 0.5f;\n\n    pointSize = 20.0f + generator.nextFloat() * 10.0f;\n\n    if (stationary) {\n      duration = 2 + generator.nextInt(8);\n      pointSize *= generator.nextFloat() * 2.0f;\n    } else duration = 180 + generator.nextInt(60);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6621, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 232, "focalAPIEnd": 246, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hone/school/tree/master/parallel_programming/java_threads/TenThreads.java", "rawCode": "  public static int[][] getBigHairyMatrix() {\n    int[][] int_array = new int[WIDTH][HEIGHT];\n    Random rand = new Random();\n\n    for (int i = 0; i < WIDTH; i++) {\n      for (int j = 2; j < HEIGHT; j++) {\n        int_array[i][j] = rand.nextInt();\n      }\n    }\n\n    return int_array;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6622, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 243, "focalAPIEnd": 259, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/carrotsearch/randomizedtesting/tree/master/junit4-ant/src/test/java/com/carrotsearch/ant/tasks/junit4/TestXmlStringsRoundtrip.java", "rawCode": "  @Test\n  @Repeat(iterations = 100)\n  public void testRoundTrip() throws Exception {\n    char[] chars = new char[randomIntBetween(0, 1024)];\n    Random random = getRandom();\n    for (int i = 0; i < chars.length; i++) {\n      chars[i] = (char) random.nextInt();\n    }\n\n    check(chars);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6623, "initialization": ["int bound = getParameterAsInt(String)", "Random random = getRandomGenerator(*)"], "initializationStart": [95, 492], "initializationEnd": [125, 574], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 645, "focalAPIEnd": 659, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["FlatCrispClusterModel.getClusterAt(element)"], "useStart": [685], "useEnd": [717], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ntj/ComplexRapidMiner/tree/master/src/com/rapidminer/operator/learner/clustering/clusterer/RandomFlatClusterer.java", "rawCode": "  public ClusterModel createClusterModel(ExampleSet es) throws OperatorException {\n    int k = getParameterAsInt(PARAMETER_K);\n\n    List<String> items = new ArrayList<String>();\n    Iterator<Example> er = es.iterator();\n    while (er.hasNext()) {\n      Example ex = er.next();\n      items.add(IdUtils.getIdFromExample(ex));\n    }\n\n    FlatCrispClusterModel result = new FlatCrispClusterModel();\n    for (int i = 0; i < k; i++) result.addCluster(new DefaultCluster(\"\" + i));\n\n    Random rng = RandomGenerator.getRandomGenerator(getParameterAsInt(PARAMETER_LOCAL_RANDOM_SEED));\n    for (int i = 0; i < items.size(); i++) {\n      int randomIndex = rng.nextInt(k);\n      ((DefaultCluster) result.getClusterAt(randomIndex)).addObject(items.get(i));\n    }\n\n    return result;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6624, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 441, "focalAPIEnd": 459, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/savoirtech/opennms-ng/tree/master/services/scheduler/src/main/java/org/opennms/ng/services/scheduler/Schedule.java", "rawCode": "    @Override\n    public void run() {\n      if (isExpired()) {\n        LOG.debug(\"Schedule \" + this + \" expired. No need to run.\");\n        return;\n      }\n\n      if (!m_interval.scheduledSuspension()) {\n        try {\n          org.opennms.ng.services.scheduler.Schedule.this.run();\n        } catch (PostponeNecessary e) {\n          // Chose a random number of seconds between 5 and 14 to wait before trying again\n          m_timer.schedule(random.nextInt(10) * 1000 + 5000, this);\n          return;\n        }\n      }\n\n      // if it is expired by the current run then don't reschedule\n      if (isExpired()) {\n        LOG.debug(\"Schedule \" + this + \" expired. No need to reschedule.\");\n        return;\n      }\n\n      long interval = m_interval.getInterval();\n      if (interval >= 0 && m_scheduled) m_timer.schedule(interval, this);\n    }\n"}, {"dataset": "randomNextInt", "exampleID": 6625, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 191, "focalAPIEnd": 220, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/dbroeglin/cipango/tree/master/cipango-server/src/test/java/org/cipango/util/TimerQueueTest.java", "rawCode": "  @Test\n  public void testRemove() {\n    for (int n = 0; n < 1000; n++) {\n      fillQueue(100);\n\n      Node[] nodes = _queue.toArray();\n\n      for (int i = 0; i < 500; i++) {\n        int j = _random.nextInt(nodes.length);\n        Node node = nodes[j];\n        nodes[j] = null;\n\n        if (node != null) _queue.remove(node);\n      }\n\n      checkPriority();\n\n      while (_queue.getSize() > 0) _queue.poll();\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6626, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 238, "focalAPIEnd": 253, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt(int)", "random.nextInt(int)", "random.nextInt(int)"], "useStart": [391, 597, 1080], "useEnd": [406, 612, 1095], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tkymx/card-of-diffence/tree/master/GLSurfaceView/src/com/example/user/EnemyAppear.java", "rawCode": "  private int compareEnemyToPlayer() {\n    int line1, line2, line3;\n\n    line1 = pline1 - eline1;\n    line2 = pline2 - eline2;\n    line3 = pline3 - eline3;\n\n    // すべてのlineが同じとき\n    if ((line1 == line2) && (line1 == line3)) {\n      ran = rand.nextInt(3) + 1;\n\n      return ran;\n    }\n    // 1と2が同じ時\n    else if (line1 == line2) {\n      // 1より3が大きいとき\n      if (line1 > line3) {\n        ran = rand.nextInt(2) + 1;\n\n        return ran;\n      } else {\n        return Const.LINE3;\n      }\n    }\n    // 1と3が同じとき\n    else if (line1 == line3) {\n      // 2より1が大きい時\n      if (line1 > line2) {\n        ran = rand.nextInt(2);\n\n        switch (ran) {\n          case 0:\n            return Const.LINE1;\n          default:\n            return Const.LINE3;\n        }\n      } else {\n        return Const.LINE2;\n      }\n    }\n    // line1が一番大きいとき\n    else if ((line1 > line2) && (line1 > line3)) {\n      return Const.LINE1;\n    }\n    // 2より1が大きいとき\n    else if (line1 > line2) {\n      return Const.LINE3;\n    }\n    // 3より1が大きい時\n    else if (line1 > line3) {\n      return Const.LINE2;\n    }\n\n    ran = rand.nextInt(3) + 1;\n\n    return ran;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6627, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 635, "focalAPIEnd": 656, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt(int)"], "useStart": [696], "useEnd": [717], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RebelKeithy/Metallurgy/tree/master/common/shadow/mods/metallurgy/MetallurgyWorldGenMinable.java", "rawCode": "  public boolean generate(World par1World, Random par2Random, int x, int y, int z) {\n    float var6 = par2Random.nextFloat() * (float) Math.PI;\n    double var7 =\n        (double) ((float) (x + 8) + MathHelper.sin(var6) * (float) this.numberOfBlocks / 8.0F);\n    double var9 =\n        (double) ((float) (x + 8) - MathHelper.sin(var6) * (float) this.numberOfBlocks / 8.0F);\n    double var11 =\n        (double) ((float) (z + 8) + MathHelper.cos(var6) * (float) this.numberOfBlocks / 8.0F);\n    double var13 =\n        (double) ((float) (z + 8) - MathHelper.cos(var6) * (float) this.numberOfBlocks / 8.0F);\n    double var15 = (double) (y + par2Random.nextInt(3) - 2);\n    double var17 = (double) (y + par2Random.nextInt(3) - 2);\n\n    for (int var19 = 0; var19 <= this.numberOfBlocks; ++var19) {\n      double var20 = var7 + (var9 - var7) * (double) var19 / (double) this.numberOfBlocks;\n      double var22 = var15 + (var17 - var15) * (double) var19 / (double) this.numberOfBlocks;\n      double var24 = var11 + (var13 - var11) * (double) var19 / (double) this.numberOfBlocks;\n      double var26 = par2Random.nextDouble() * (double) this.numberOfBlocks / 16.0D;\n      double var28 =\n          (double)\n                      (MathHelper.sin((float) var19 * (float) Math.PI / (float) this.numberOfBlocks)\n                          + 1.0F)\n                  * var26\n              + 1.0D;\n      double var30 =\n          (double)\n                      (MathHelper.sin((float) var19 * (float) Math.PI / (float) this.numberOfBlocks)\n                          + 1.0F)\n                  * var26\n              + 1.0D;\n      int var32 = MathHelper.floor_double(var20 - var28 / 2.0D);\n      int var33 = MathHelper.floor_double(var22 - var30 / 2.0D);\n      int var34 = MathHelper.floor_double(var24 - var28 / 2.0D);\n      int var35 = MathHelper.floor_double(var20 + var28 / 2.0D);\n      int var36 = MathHelper.floor_double(var22 + var30 / 2.0D);\n      int var37 = MathHelper.floor_double(var24 + var28 / 2.0D);\n\n      for (int var38 = var32; var38 <= var35; ++var38) {\n        double var39 = ((double) var38 + 0.5D - var20) / (var28 / 2.0D);\n\n        if (var39 * var39 < 1.0D) {\n          for (int var41 = var33; var41 <= var36; ++var41) {\n            double var42 = ((double) var41 + 0.5D - var22) / (var30 / 2.0D);\n\n            if (var39 * var39 + var42 * var42 < 1.0D) {\n              for (int var44 = var34; var44 <= var37; ++var44) {\n                double var45 = ((double) var44 + 0.5D - var24) / (var28 / 2.0D);\n\n                if (var39 * var39 + var42 * var42 + var45 * var45 < 1.0D\n                    && par1World.getBlockId(var38, var41, var44) == Block.stone.blockID) {\n                  MetalSet.oreSpawnCount++;\n                  par1World.setBlock(var38, var41, var44, this.minableBlockId);\n                  par1World.setBlockMetadata(var38, var41, var44, this.metadata);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6628, "initialization": ["Random random = getRandom(String)"], "initializationStart": [60], "initializationEnd": [78], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 95, "focalAPIEnd": 107, "followUpCheck": "an[element] != \"\"", "checkType": "IF", "followUpCheckExpressionStart": 147, "followUpCheckExpressionEnd": 170, "followUpCheckBlockStart": 147, "followUpCheckBlockEnd": 396, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.3.11/samples/samples/misc/equations/q1.java", "rawCode": "  protected void init() throws OmException {\n    Random r = getRandom(\"eigen\");\n    iVariant = r.nextInt(5);\n\n    equation = \"\\\\Psi (x,t) = \";\n    if (an[iVariant] != \"\") {\n      equation +=\n          \"\\\\frac{\"\n              + an[iVariant]\n              + \"}{\"\n              + ad[iVariant]\n              + \"}\"\n              + \"\\\\psi _0 (x) exp\\\\left( \\\\frac{-i\\\\omega _{0}t}{2}\\\\right) + \";\n    }\n    if (bn[iVariant] != \"\") {\n      equation +=\n          \"\\\\frac{\"\n              + bn[iVariant]\n              + \"}{\"\n              + bd[iVariant]\n              + \"}\"\n              + \"\\\\psi _0 (x) exp\\\\left( \\\\frac{-3i\\\\omega _{0}t}{2}\\\\right) + \";\n    }\n    if (cn[iVariant] != \"\") {\n      equation +=\n          \"\\\\frac{\"\n              + cn[iVariant]\n              + \"}{\"\n              + cd[iVariant]\n              + \"}\"\n              + \"\\\\psi _3 (x) exp\\\\left( \\\\frac{-5i\\\\omega _{0}t}{2}\\\\right)\";\n    }\n    if (dn[iVariant] != \"\") {\n      equation +=\n          \"\\\\frac{\"\n              + dn[iVariant]\n              + \"}{\"\n              + dd[iVariant]\n              + \"}\"\n              + \"\\\\psi _3 (x) exp\\\\left( \\\\frac{-7i\\\\omega _{0}t}{2}\\\\right)\";\n    }\n\n    if (cn[iVariant] == \"\") cStr = \"0\";\n    else cStr = \"\\\\frac{\" + cn[iVariant] + \" }{\" + cd[iVariant] + \"}\";\n\n    e2Str = \"\\\\frac{\" + e2n[iVariant] + \" }{\" + e2d[iVariant] + \"}\";\n\n    setPlaceholder(\"EQ\", equation);\n    setPlaceholder(\"C\", cStr);\n    setPlaceholder(\"E\", LETTERS_E[iVariant]);\n    setPlaceholder(\"EE\", LETTERS_EE[iVariant]);\n    setPlaceholder(\"E2\", e2Str);\n    setPlaceholder(\"F\", LETTERS_F[iVariant]);\n    setPlaceholder(\"G\", LETTERS_G[iVariant]);\n    setPlaceholder(\"N\", \"\" + (int) CORRECT_N[iVariant]);\n    setPlaceholder(\"D\", \"\" + (int) CORRECT_D[iVariant]);\n\n    // store question information\n    getResults().setQuestionLine(\"Variant (counting from zero): \" + iVariant);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6629, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(bound==0)", "guardType": "IF {", "guardExpressionStart": 102, "guardExpressionEnd": 114, "guardBlockStart": 102, "guardBlockEnd": 125, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 185, "focalAPIEnd": 201, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["fastSet(element)"], "useStart": [174], "useEnd": [202], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sudarshang/lucene-solr/tree/master/solr/core/src/test/org/apache/solr/search/TestDocSet.java", "rawCode": "  public OpenBitSet getRandomSet(int sz, int bitsToSet) {\n    OpenBitSet bs = new OpenBitSet(sz);\n    if (sz == 0) return bs;\n    for (int i = 0; i < bitsToSet; i++) {\n      bs.fastSet(rand.nextInt(sz));\n    }\n    return bs;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6630, "initialization": ["Random random = new Random()"], "initializationStart": [209], "initializationEnd": [221], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 493, "focalAPIEnd": 518, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ansell/openrdf-sesame/tree/master/compliance/http/src/test/java/org/openrdf/http/server/ProtocolTest.java", "rawCode": "  /**\n   * Test for SES-1861\n   *\n   * @throws Exception\n   */\n  @Test\n  public void testSequentialNamespaceUpdates() throws Exception {\n    int limitCount = 1000;\n    int limitPrefix = 50;\n\n    Random prng = new Random();\n    // String repositoryLocation =\n    // Protocol.getRepositoryLocation(\"http://localhost:8080/openrdf-sesame\",\n    // \"Test-NativeStore\");\n    String repositoryLocation = TestServer.REPOSITORY_URL;\n\n    for (int count = 0; count < limitCount; count++) {\n      int i = prng.nextInt(limitPrefix);\n      String prefix = \"prefix\" + i;\n      String ns = \"http://example.org/namespace\" + i;\n\n      String location = Protocol.getNamespacePrefixLocation(repositoryLocation, prefix);\n\n      if (count % 2 == 0) {\n        putNamespace(location, ns);\n      } else {\n        deleteNamespace(location);\n      }\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6631, "initialization": ["Random random = getRandom(*,boolean)"], "initializationStart": [602], "initializationEnd": [640], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 654, "focalAPIEnd": 675, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1_9_1/src/om/stdquestion/StandardQuestion.java", "rawCode": "  /**\n   * Returns a variant number between 0 (inclusive) and maxVariant (exclusive). Use this method to\n   * get the next variant of a question in sequence. For the first attempt it returns a random\n   * variant and for the repeat attempts it returns next variants in sequence, when the last variant\n   * is reached it cycles back to the beginning.\n   *\n   * @param maxVariant\n   * @return variant number\n   */\n  public int getNextVariant(int maxVariant) {\n    // Passing false for the 'incrementSeed' parameter to get the same\n    // random number generator for all question attempts.\n    Random r = getRandom(getClass().getName(), false);\n    return (r.nextInt(maxVariant) + ip.getAttempt() - 1) % maxVariant;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6632, "initialization": ["Random random = new Random(int)"], "initializationStart": [532], "initializationEnd": [545], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 634, "focalAPIEnd": 655, "followUpCheck": "ra.getFilePointer() > element", "checkType": "IF", "followUpCheckExpressionStart": 1290, "followUpCheckExpressionEnd": 1320, "followUpCheckBlockStart": 1290, "followUpCheckBlockEnd": 1387, "use": ["random.nextInt(int)", "min(element,*)", "FileObject.seek(element)", "RandomAccessFile.seek(element)", "random.nextBytes(byte[])", "FileObject.setFileLength(element)", "RandomAccessFile.setLength(element)", "random.nextInt(int)"], "useStart": [671, 744, 818, 843, 988, 1225, 1259, 1508], "useEnd": [688, 770, 829, 855, 1012, 1245, 1276, 1528], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/angusmacdonald/h2o/tree/master/src/test/org/h2/test/unit/TestFileSystem.java", "rawCode": "  private void testRandomAccess(String fsBase) throws Exception {\n    FileSystem fs = FileSystem.getInstance(fsBase);\n    String s = fs.createTempFile(fsBase + \"/temp\", \".tmp\", false, false);\n    File file = new File(baseDir + \"/temp\");\n    file.delete();\n    RandomAccessFile ra = new RandomAccessFile(file, \"rw\");\n    fs.delete(s);\n    FileObject f = fs.openFileObject(s, \"rw\");\n    try {\n      f.readFully(new byte[1], 0, 1);\n      fail();\n    } catch (EOFException e) {\n      // expected\n    }\n    f.sync();\n    Random random = new Random(1);\n    int size = getSize(100, 500);\n    for (int i = 0; i < size; i++) {\n      int pos = random.nextInt(10000);\n      switch (random.nextInt(7)) {\n        case 0:\n          {\n            pos = (int) Math.min(pos, ra.length());\n            trace(\"seek \" + pos);\n            f.seek(pos);\n            ra.seek(pos);\n            break;\n          }\n        case 1:\n          {\n            byte[] buffer = new byte[random.nextInt(1000)];\n            random.nextBytes(buffer);\n            trace(\"write \" + buffer.length);\n            f.write(buffer, 0, buffer.length);\n            ra.write(buffer, 0, buffer.length);\n            break;\n          }\n        case 2:\n          {\n            f.setFileLength(pos);\n            ra.setLength(pos);\n            if (ra.getFilePointer() > pos) {\n              f.seek(0);\n              ra.seek(0);\n            }\n            trace(\"setLength \" + pos);\n            break;\n          }\n        case 3:\n          {\n            int len = random.nextInt(1000);\n            len = (int) Math.min(len, ra.length() - ra.getFilePointer());\n            byte[] b1 = new byte[len];\n            byte[] b2 = new byte[len];\n            ra.readFully(b1, 0, len);\n            f.readFully(b2, 0, len);\n            trace(\"readFully \" + len);\n            assertEquals(b1, b2);\n            break;\n          }\n        case 4:\n          {\n            trace(\"getFilePointer\");\n            assertEquals(ra.getFilePointer(), f.getFilePointer());\n            break;\n          }\n        case 5:\n          {\n            trace(\"length \" + ra.length());\n            assertEquals(ra.length(), f.length());\n            break;\n          }\n        case 6:\n          {\n            trace(\"reopen\");\n            f.close();\n            ra.close();\n            ra = new RandomAccessFile(file, \"rw\");\n            f = fs.openFileObject(s, \"rw\");\n            assertEquals(ra.length(), f.length());\n            break;\n          }\n        default:\n      }\n    }\n    f.close();\n    ra.close();\n    fs.close();\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6633, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 63, "focalAPIEnd": 79, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt()", "new LocationImpl(Resource,element,int)", "assertEquals(*,element)", "format(String,Resource,element,int)"], "useStart": [98, 134, 224, 330], "useEnd": [114, 174, 255, 393], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/newtonik/preppa/tree/master/lib/tapestry-src-5.0.18/tapestry-ioc/src/test/java/org/apache/tapestry5/ioc/internal/util/LocationImplTest.java", "rawCode": "  @Test\n  public void all_three_parameters() {\n\n    int line = random.nextInt();\n    int column = random.nextInt();\n\n    Location l = new LocationImpl(resource, line, column);\n\n    assertSame(l.getResource(), resource);\n    assertEquals(l.getLine(), line);\n    assertEquals(l.getColumn(), column);\n\n    assertEquals(l.toString(), String.format(\"%s, line %d, column %d\", resource, line, column));\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6634, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 277, "focalAPIEnd": 298, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/carrotsearch/randomizedtesting/tree/master/randomized-runner/src/main/java/com/carrotsearch/randomizedtesting/generators/CodepointSetGenerator.java", "rawCode": "  @Override\n  public String ofCodePointsLength(Random r, int minCodePoints, int maxCodePoints) {\n    int length = RandomNumbers.randomIntBetween(r, minCodePoints, maxCodePoints);\n    int[] codepoints = new int[length];\n    while (length > 0) {\n      codepoints[--length] = all[r.nextInt(all.length)];\n    }\n    return new String(codepoints, 0, codepoints.length);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6635, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 113, "focalAPIEnd": 138, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Morgan-Allen/Presidium/tree/master/src/util/Rand.java", "rawCode": "  public static final Object pickFrom(Object[] array) {\n    if (array.length == 0) return null;\n    return array[GEN.nextInt(array.length)];\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6636, "initialization": ["Random random = new Random(long)"], "initializationStart": [274], "initializationEnd": [290], "hasTryCatch": 1, "exceptionType": "Exception", "exceptionHandlingCall": ["printStackTrace()"], "tryExpressionStart": 56, "tryExpressionEnd": 60, "tryBlockStart": 56, "tryBlockEnd": 955, "catchExpressionStart": 901, "catchExpressionEnd": 921, "catchBlockStart": 901, "catchBlockEnd": 955, "exceptionHandlingCallStart": [929], "exceptionHandlingCallEnd": [948], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 512, "focalAPIEnd": 530, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt(int)", "random.nextInt(int)", "random.nextInt(int)", "new Rect(int,element,*,*)"], "useStart": [555, 597, 631, 693], "useEnd": [573, 616, 650, 727], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/chgenly/experiment/tree/master/DataExtractionOSM/src/rtree/rTreeDemo.java", "rawCode": "  public void trySeed(String sdTree, RTree rtree) {\n    try {\n      // System.out.println(\"rTreeDemo.trySeed : height of rtree is \" + rtree.getHeight());\n      SdTree sdt = new SdTree(sdTree, rtree);\n      // now grow\n      int ix, iy, xx, xy; // mIn,maX\n      Random rnd = new Random(seed);\n      long start = System.currentTimeMillis();\n      // LeafElement llf = new LeafElement(new Rect(1752, 2179, 5999888, 14999646),218);\n      // sdt.growLeaf(llf);\n\n      for (int i = 0; i < 2000000; i++) {\n        iy = rnd.nextInt(h - 2); // height\n        ix = rnd.nextInt(w - 2); // width\n        xy = rnd.nextInt(h - iy);\n        xx = rnd.nextInt(w - ix);\n        LeafElement lf = new LeafElement(new Rect(ix, iy, ix + xx, iy + xy), 218);\n        sdt.growLeaf(lf);\n      }\n      sdt.cleanUp();\n      (new RTree(sdTree)).flush();\n      // RTreeRead rd = new RTreeRead(sdTree);\n      // rd.readSeq();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6637, "initialization": ["Random random = new Random(int)"], "initializationStart": [60], "initializationEnd": [77], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 138, "focalAPIEnd": 152, "followUpCheck": "i < element", "checkType": "LOOP", "followUpCheckExpressionStart": 195, "followUpCheckExpressionEnd": 224, "followUpCheckBlockStart": 195, "followUpCheckBlockEnd": 275, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/STS-Dev-Team/android_frameworks_opt_telephony/tree/master/tests/telephonytests/src/com/android/internal/telephony/cdma/CdmaSmsCbTest.java", "rawCode": "  public void testRandomBearerStreamData() {\n    Random r = new Random(54321);\n    for (int run = 0; run < 1000; run++) {\n      int len = r.nextInt(140);\n      byte[] data = new byte[len];\n      for (int i = 0; i < len; i++) {\n        data[i] = (byte) r.nextInt(256);\n      }\n      // Log.d(\"CdmaSmsCbTest\", \"trying random bearer data run \" + run + \" length \" + len);\n      try {\n        int category = 0x0ff0 + r.nextInt(32); // half CMAS, half non-CMAS\n        Parcel p = createBroadcastParcel(category);\n        SmsMessage msg = createMessageFromParcel(p, data);\n        SmsCbMessage cbMessage = msg.parseBroadcastSms();\n        // with random input, cbMessage will almost always be null (log when it isn't)\n        if (cbMessage != null) {\n          Log.d(\"CdmaSmsCbTest\", \"success: \" + cbMessage);\n        }\n      } catch (Exception e) {\n        Log.d(\"CdmaSmsCbTest\", \"exception thrown\", e);\n        fail(\"Exception in decoder at run \" + run + \" length \" + len + \": \" + e);\n      }\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6638, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["warn(String)"], "tryExpressionStart": 252, "tryExpressionEnd": 256, "tryBlockStart": 252, "tryBlockEnd": 1748, "catchExpressionStart": 1662, "catchExpressionEnd": 1684, "catchBlockStart": 1662, "catchBlockEnd": 1748, "exceptionHandlingCallStart": [1692], "exceptionHandlingCallEnd": [1741], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 1093, "focalAPIEnd": 1107, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anbangr/trusted-mr/tree/master/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/LocalFileSystem.java", "rawCode": "  /**\n   * Moves files to a bad file directory on the same device, so that their storage will not be\n   * reused.\n   */\n  public boolean reportChecksumFailure(\n      Path p, FSDataInputStream in, long inPos, FSDataInputStream sums, long sumsPos) {\n    try {\n      // canonicalize f\n      File f = ((RawLocalFileSystem) fs).pathToFile(p).getCanonicalFile();\n\n      // find highest writable parent dir of f on the same device\n      String device = new DF(f, getConf()).getMount();\n      File parent = f.getParentFile();\n      File dir = null;\n      while (parent != null && parent.canWrite() && parent.toString().startsWith(device)) {\n        dir = parent;\n        parent = parent.getParentFile();\n      }\n\n      if (dir == null) {\n        throw new IOException(\"not able to find the highest writable parent dir\");\n      }\n\n      // move the file there\n      File badDir = new File(dir, \"bad_files\");\n      if (!badDir.mkdirs()) {\n        if (!badDir.isDirectory()) {\n          throw new IOException(\"Mkdirs failed to create \" + badDir.toString());\n        }\n      }\n      String suffix = \".\" + rand.nextInt();\n      File badFile = new File(badDir, f.getName() + suffix);\n      LOG.warn(\"Moving bad file \" + f + \" to \" + badFile);\n      in.close(); // close it first\n      boolean b = f.renameTo(badFile); // rename it\n      if (!b) {\n        LOG.warn(\"Ignoring failure of renameTo\");\n      }\n      // move checksum file too\n      File checkFile = ((RawLocalFileSystem) fs).pathToFile(getChecksumFile(p));\n      b = checkFile.renameTo(new File(badDir, checkFile.getName() + suffix));\n      if (!b) {\n        LOG.warn(\"Ignoring failure of renameTo\");\n      }\n    } catch (IOException e) {\n      LOG.warn(\"Error moving bad file \" + p + \": \" + e);\n    }\n    return false;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6639, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 204, "focalAPIEnd": 236, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/mnip91/proactive-component-monitoring/tree/master/src/Examples/org/objectweb/proactive/examples/c3d/prim/Surface.java", "rawCode": "  /**\n   * Generate a random color.\n   *\n   * @return a Surface with random parameters\n   */\n  public static Surface random() {\n    Random randomGen = new Random();\n    return new Surface(\n        colors[randomGen.nextInt(colors.length)],\n        Math.random(),\n        Math.random(),\n        Math.random() * 20.0,\n        0.,\n        1.);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6640, "initialization": ["Random random = getRandom()"], "initializationStart": [61], "initializationEnd": [72], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 87, "focalAPIEnd": 99, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/trunk/trunk-archive/samples/samples/mu120/module5/question04/Q4.java", "rawCode": "  protected void init() throws OmException {\n\n    Random r = getRandom();\n    int ab = r.nextInt(2);\n    int cd = 2 + r.nextInt(2);\n    int ef = 4 + r.nextInt(2);\n    int gh = 6 + r.nextInt(2);\n\n    ABs = pLabels[ab];\n    ABx = pXs[ab];\n    ABy = pYs[ab];\n    CDs = pLabels[cd];\n    CDx = pXs[cd];\n    CDy = pYs[cd];\n    EFs = pLabels[ef];\n    EFx = pXs[ef];\n    EFy = pYs[ef];\n    GHs = pLabels[gh];\n    GHx = pXs[gh];\n    GHy = pYs[gh];\n\n    setPlaceholder(\"ABs\", ABs);\n    setPlaceholder(\"CDs\", CDs);\n    setPlaceholder(\"EFs\", EFs);\n    setPlaceholder(\"GHs\", GHs);\n\n    setPlaceholder(\"ABx\", \"\" + ABx);\n    setPlaceholder(\"CDx\", \"\" + CDx);\n    setPlaceholder(\"EFx\", \"\" + EFx);\n    setPlaceholder(\"GHx\", \"\" + GHx);\n\n    setPlaceholder(\"ABy\", \"\" + ABy);\n    setPlaceholder(\"CDy\", \"\" + CDy);\n    setPlaceholder(\"EFy\", \"\" + EFy);\n    setPlaceholder(\"GHy\", \"\" + GHy);\n\n    Graph54 g54 = new Graph54(xFromTo, yFromTo, \"x\", xLabels, \"y\", yLabels);\n\n    CanvasComponent cc = (CanvasComponent) getComponent(\"graph1\"); // question graph\n    Graphics g = cc.getGraphics().create();\n    // draw background grid, i.e. the graph paper\n    g.setColor(Color.LIGHT_GRAY);\n    g54.fit(g, 10, 0, 256, 256);\n    for (int j = xFromTo[0]; j <= xFromTo[1]; j++) g54.drawLine(g, j, yFromTo[0], j, yFromTo[1]);\n    for (int i = yFromTo[0]; i <= yFromTo[1]; i++) g54.drawLine(g, xFromTo[0], i, xFromTo[1], i);\n    // draw the graph\n    g.setColor(Color.BLACK); // was: g.setColor(new Color(115,111,234));\n    g54.paint(g, 10, 0, 256, 256);\n    // draw the points\n    g.setColor(new Color(92, 47, 138));\n    for (int i = 0; i < pLabels.length; i++) g54.drawPoint(g, pLabels[i], pXs[i], pYs[i]);\n    g.dispose();\n\n    cc = (CanvasComponent) getComponent(\"graph2\"); // answer graph\n    g = cc.getGraphics().create();\n    // draw lines to points refered to\n    g.setColor(Color.LIGHT_GRAY);\n    g54.drawLine(g, ABx, 0, ABx, ABy);\n    g54.drawLine(g, 0, ABy, ABx, ABy);\n    g54.drawLine(g, CDx, 0, CDx, CDy);\n    g54.drawLine(g, 0, CDy, CDx, CDy);\n    g54.drawLine(g, EFx, 0, EFx, EFy);\n    g54.drawLine(g, 0, EFy, EFx, EFy);\n    g54.drawLine(g, GHx, 0, GHx, GHy);\n    g54.drawLine(g, 0, GHy, GHx, GHy);\n    // draw graph\n    g.setColor(Color.BLACK); // was: g.setColor(new Color(115,111,234));\n    g54.paint(g, 10, 0, 256, 256);\n    // draw the points\n    g.setColor(new Color(92, 47, 138));\n    for (int i = 0; i < pLabels.length; i++) g54.drawPoint(g, pLabels[i], pXs[i], pYs[i]);\n    g.dispose();\n\n    getComponent(\"inputbox\").setDisplay(true);\n    // cc.markChanged();\n\n    // store question information\n    getResults()\n        .setQuestionLine(\n            \"find (x,y) coordinates for: \" + ABs + \", \" + CDs + \", \" + EFs + \", \" + GHs);\n    getResults()\n        .setAnswerLine(\n            \"(\" + \"(\" + ABx + \",\" + ABy + \")\" + \", \" + \"(\" + CDx + \",\" + CDy + \")\" + \", \" + \"(\"\n                + EFx + \",\" + EFy + \")\" + \", \" + \"(\" + GHx + \",\" + GHy + \")\" + \")\");\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6641, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 60, "focalAPIEnd": 87, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/motech/motech-server-pillreminder/tree/master/modules/appointments/api/src/test/java/org/motechproject/appointments/api/it/VisitsQueryServicePerformanceTest.java", "rawCode": "  private int rand(int start, int end) {\n    return start + random.nextInt(end - start);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6642, "initialization": ["Random random = new Random()"], "initializationStart": [181], "initializationEnd": [193], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 226, "focalAPIEnd": 247, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/asascience-open/EDC/tree/master/src/com/asascience/edc/dap/ui/DapWorldwindProcessPanel.java", "rawCode": "  private String createSuitableLayerName(String name) {\n\n    // Generate a random name if it is null or blank\n    if ((name == null) || (name.isEmpty())) {\n      Random generator = new Random();\n      Integer rand = (Integer) generator.nextInt(10);\n      return \"Output_\" + rand.toString();\n    }\n\n    final StringBuilder result = new StringBuilder();\n    final StringCharacterIterator iterator = new StringCharacterIterator(name);\n    char character = iterator.current();\n    while (character != CharacterIterator.DONE) {\n      if (character == '.') {\n        result.append(\"_\");\n      } else if (character == ',') {\n        result.append(\"_\");\n      } else if (character == '\\\\') {\n        result.append(\"\");\n      } else if (character == '?') {\n        result.append(\"\");\n      } else if (character == '*') {\n        result.append(\"\");\n      } else if (character == '+') {\n        result.append(\"\");\n      } else if (character == '&') {\n        result.append(\"\");\n      } else if (character == ':') {\n        result.append(\"\");\n      } else if (character == '{') {\n        result.append(\"\");\n      } else if (character == '}') {\n        result.append(\"\");\n      } else if (character == '[') {\n        result.append(\"\");\n      } else if (character == ']') {\n        result.append(\"\");\n      } else if (character == '(') {\n        result.append(\"\");\n      } else if (character == ')') {\n        result.append(\"\");\n      } else if (character == '^') {\n        result.append(\"\");\n      } else if (character == '$') {\n        result.append(\"\");\n      } else if (character == ' ') {\n        result.append(\"\");\n      } else {\n        // the char is not a special one\n        // add it to the result as is\n        result.append(character);\n      }\n      character = iterator.next();\n    }\n    return result.toString();\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6643, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 643, "focalAPIEnd": 660, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["AtomicInteger.decrementAndGet()", "InterProcessLock.release()"], "finallyExpressionStart": 673, "finallyExpressionEnd": 681, "finallyBlockStart": 673, "finallyBlockEnd": 791, "cleanUpCallStart": [719, 762], "cleanUpCallEnd": [752, 776], "url": "https://github.com/dfjones/curator/tree/master/curator-recipes/src/test/java/org/apache/curator/framework/recipes/locks/TestInterProcessReadWriteLock.java", "rawCode": "  private void doLocking(\n      InterProcessLock lock,\n      AtomicInteger concurrentCount,\n      AtomicInteger maxConcurrentCount,\n      Random random,\n      int maxAllowed)\n      throws Exception {\n    try {\n      Assert.assertTrue(lock.acquire(10, TimeUnit.SECONDS));\n      int localConcurrentCount;\n      synchronized (this) {\n        localConcurrentCount = concurrentCount.incrementAndGet();\n        if (localConcurrentCount > maxConcurrentCount.get()) {\n          maxConcurrentCount.set(localConcurrentCount);\n        }\n      }\n\n      Assert.assertTrue(localConcurrentCount <= maxAllowed, \"\" + localConcurrentCount);\n\n      Thread.sleep(random.nextInt(9) + 1);\n    } finally {\n      synchronized (this) {\n        concurrentCount.decrementAndGet();\n        lock.release();\n      }\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6644, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 47, "focalAPIEnd": 60, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt()"], "useStart": [74], "useEnd": [87], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ieure/lucene-solr-snapshot/tree/master/solr/src/test/org/apache/solr/util/TestNumberUtils.java", "rawCode": "  static float getFloatSpecial() {\n    int i = rng.nextInt();\n    int j = rng.nextInt();\n    float f = Float.intBitsToFloat(j);\n    if (f != f) f = 0; // get rid of NaN for comparison purposes\n    if ((i & 0x10) != 0) return f;\n    return fspecial[(j & 0x7fffffff) % fspecial.length] * ((i & 0x20) == 0 ? 1 : -1)\n        + ((i & 0x03) - 1);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6645, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 177, "focalAPIEnd": 199, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["getIntegerArray(element)", "random.nextInt(int)", "getIntegerArray(element)"], "useStart": [231, 573, 627], "useEnd": [252, 595, 648], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ikeji/openjdk7-jdk/tree/master/test/java/util/Arrays/Correct.java", "rawCode": "  public static void main(String[] args) throws Exception {\n    Object[] array1 = null;\n    Object[] array2 = null;\n\n    for (int i = 0; i < ITERATIONS; i++) {\n      int size = rnd.nextInt(TEST_SIZE) + 1;\n      array1 = (Object[]) getIntegerArray(size);\n      array2 = (Object[]) array1.clone();\n      Arrays.sort(array1, array1.length / 3, array1.length / 2);\n      stupidSort(array2, array2.length / 3, array2.length / 2);\n      if (!Arrays.equals(array1, array2)) throw new RuntimeException(\"failed!\");\n    }\n\n    for (int i = 0; i < ITERATIONS; i++) {\n      int size = rnd.nextInt(TEST_SIZE) + 1;\n      array1 = (Object[]) getIntegerArray(size);\n      array2 = (Object[]) array1.clone();\n      Arrays.sort(array1, array1.length / 3, array1.length / 2, TEST_ORDER);\n      stupidSort(array2, array2.length / 3, array2.length / 2);\n      if (!Arrays.equals(array1, array2)) throw new RuntimeException(\"failed!\");\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6646, "initialization": ["Random random = getRandom()"], "initializationStart": [60], "initializationEnd": [71], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 88, "focalAPIEnd": 115, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.7.2/trunk/samples/samples/numeric/scientificnotation/Q10.java", "rawCode": "  protected void init() throws OmException {\n    Random r = getRandom();\n    iVariant = r.nextInt(NUMBERS_A.length);\n\n    setPlaceholder(\"A\", NUMBERS_A[iVariant]);\n    setPlaceholder(\"B\", NUMBERS_B[iVariant]);\n    setPlaceholder(\"C\", NUMBERS_C[iVariant]);\n    setPlaceholder(\"D\", NUMBERS_D[iVariant]);\n    setPlaceholder(\"E\", NUMBERS_E[iVariant]);\n    setPlaceholder(\"F\", NUMBERS_F[iVariant]);\n\n    getResults()\n        .setQuestionLine(\n            \"What is sqrt(\"\n                + NUMBERS_A[iVariant]\n                + \" � 10^\"\n                + NUMBERS_C[iVariant]\n                + \")/(\"\n                + NUMBERS_B[iVariant]\n                + \" � 10^{�\"\n                + NUMBERS_D[iVariant]\n                + \" � 10^5} in scientific notation\");\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6647, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 126, "focalAPIEnd": 152, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["AtomicLongMap<String>.put(String,element)", "assertEquals(element,long)"], "useStart": [251, 314], "useEnd": [273, 343], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/npvincent/guava/tree/master/guava-gwt/test-super/com/google/common/util/concurrent/super/com/google/common/util/concurrent/AtomicLongMapTest.java", "rawCode": "  public void testPut() {\n    AtomicLongMap<String> map = AtomicLongMap.create();\n    String key = \"key\";\n    long newValue = random.nextInt(MAX_ADDEND);\n    for (int i = 0; i < ITERATIONS; i++) {\n      long before = map.get(key);\n      long result = map.put(key, newValue);\n      long after = map.get(key);\n      assertEquals(newValue, after);\n      assertEquals(before, result);\n      newValue += newValue;\n    }\n    assertEquals(1, map.size());\n    assertTrue(!map.isEmpty());\n    assertTrue(map.containsKey(key));\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6648, "initialization": ["Random random = new Random()"], "initializationStart": [9899], "initializationEnd": [9911], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 10042, "focalAPIEnd": 10061, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt(int)", "new Color(int,element,*,int)"], "useStart": [10063, 10027], "useEnd": [10082, 10088], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/anhquang/contiki/tree/master/tools/cooja/apps/mrm/java/se/sics/mrm/AreaViewer.java", "rawCode": "  /**\n   * Repaint the canvas\n   *\n   * @param g2d Current graphics to paint on\n   */\n  protected void repaintCanvas(Graphics2D g2d) {\n    AffineTransform originalTransform = g2d.getTransform();\n\n    // Create \"real-world\" transformation (scaled 100 times to reduce double->int rounding errors)\n    g2d.scale(currentZoomX, currentZoomY);\n    g2d.translate(currentPanX, currentPanY);\n    AffineTransform realWorldTransform = g2d.getTransform();\n    g2d.scale(0.01, 0.01);\n    AffineTransform realWorldTransformScaled = g2d.getTransform();\n\n    // -- Draw background image if any --\n    if (drawBackgroundImage && backgroundImage != null) {\n      g2d.setTransform(realWorldTransformScaled);\n\n      g2d.drawImage(\n          backgroundImage,\n          (int) (backgroundStartX * 100.0),\n          (int) (backgroundStartY * 100.0),\n          (int) (backgroundWidth * 100.0),\n          (int) (backgroundHeight * 100.0),\n          this);\n    }\n\n    // -- Draw calculated obstacles --\n    if (drawCalculatedObstacles) {\n\n      // (Re)create obstacle image if needed\n      if (obstacleImage == null || needToRepaintObstacleImage) {\n\n        // Abort if no obstacles exist\n        if (currentChannelModel.getNumberOfObstacles() > 0) {\n\n          // Get bounds of obstacles\n          obstacleStartX = currentChannelModel.getObstacle(0).getMinX();\n          obstacleStartY = currentChannelModel.getObstacle(0).getMinY();\n          obstacleWidth = currentChannelModel.getObstacle(0).getMaxX();\n          obstacleHeight = currentChannelModel.getObstacle(0).getMaxY();\n\n          double tempVal = 0;\n          for (int i = 0; i < currentChannelModel.getNumberOfObstacles(); i++) {\n            if ((tempVal = currentChannelModel.getObstacle(i).getMinX()) < obstacleStartX) {\n              obstacleStartX = tempVal;\n            }\n            if ((tempVal = currentChannelModel.getObstacle(i).getMinY()) < obstacleStartY) {\n              obstacleStartY = tempVal;\n            }\n            if ((tempVal = currentChannelModel.getObstacle(i).getMaxX()) > obstacleWidth) {\n              obstacleWidth = tempVal;\n            }\n            if ((tempVal = currentChannelModel.getObstacle(i).getMaxY()) > obstacleHeight) {\n              obstacleHeight = tempVal;\n            }\n          }\n          obstacleWidth -= obstacleStartX;\n          obstacleHeight -= obstacleStartY;\n\n          // Create new obstacle image\n          BufferedImage tempObstacleImage;\n          if (backgroundImage != null) {\n            tempObstacleImage =\n                new BufferedImage(\n                    Math.max(600, backgroundImage.getWidth(null)),\n                    Math.max(600, backgroundImage.getHeight(null)),\n                    BufferedImage.TYPE_INT_ARGB);\n          } else {\n            tempObstacleImage = new BufferedImage(600, 600, BufferedImage.TYPE_INT_ARGB);\n          }\n\n          Graphics2D obstacleGraphics = (Graphics2D) tempObstacleImage.getGraphics();\n\n          // Set real world transform\n          obstacleGraphics.scale(\n              tempObstacleImage.getWidth() / obstacleWidth,\n              tempObstacleImage.getHeight() / obstacleHeight);\n          obstacleGraphics.translate(-obstacleStartX, -obstacleStartY);\n\n          // Paint all obstacles\n          obstacleGraphics.setColor(new Color(0, 0, 0, 128));\n\n          // DEBUG: Use random obstacle color to distinguish different obstacles\n          // Random random = new Random();\n\n          for (int i = 0; i < currentChannelModel.getNumberOfObstacles(); i++) {\n            // obstacleGraphics.setColor((new Color(random.nextInt(255), random.nextInt(255),\n            // random.nextInt(255), 128)));\n            obstacleGraphics.fill(currentChannelModel.getObstacle(i));\n          }\n          obstacleImage = tempObstacleImage;\n\n        } else {\n\n          // No obstacles exist - create dummy obstacle image\n          obstacleStartX = 0;\n          obstacleStartY = 0;\n          obstacleWidth = 1;\n          obstacleHeight = 1;\n          obstacleImage = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);\n        }\n\n        needToRepaintObstacleImage = false;\n      }\n\n      // Painting in real world coordinates\n      g2d.setTransform(realWorldTransformScaled);\n\n      g2d.drawImage(\n          obstacleImage,\n          (int) (obstacleStartX * 100.0),\n          (int) (obstacleStartY * 100.0),\n          (int) (obstacleWidth * 100.0),\n          (int) (obstacleHeight * 100.0),\n          this);\n    }\n\n    // -- Draw channel probabilities if calculated --\n    if (drawChannelProbabilities && channelImage != null) {\n      g2d.setTransform(realWorldTransformScaled);\n\n      g2d.drawImage(\n          channelImage,\n          (int) (channelStartX * 100.0),\n          (int) (channelStartY * 100.0),\n          (int) (channelWidth * 100.0),\n          (int) (channelHeight * 100.0),\n          this);\n    }\n\n    // -- Draw radios --\n    if (drawRadios) {\n      for (int i = 0; i < currentRadioMedium.getRegisteredRadioCount(); i++) {\n        g2d.setStroke(new BasicStroke((float) 0.0));\n        g2d.setTransform(realWorldTransform);\n\n        // Translate to real world radio position\n        Radio radio = currentRadioMedium.getRegisteredRadio(i);\n        Position radioPosition = radio.getPosition();\n        g2d.translate(radioPosition.getXCoordinate(), radioPosition.getYCoordinate());\n\n        // Fetch current translation\n        double xPos = g2d.getTransform().getTranslateX();\n        double yPos = g2d.getTransform().getTranslateY();\n\n        // Jump to identity transform and paint without scaling\n        g2d.setTransform(new AffineTransform());\n\n        if (selectedRadio == radio) {\n          g2d.setColor(new Color(255, 0, 0, 100));\n          g2d.fillRect(\n              (int) xPos - antennaImage.getWidth(this) / 2,\n              (int) yPos - antennaImage.getHeight(this) / 2,\n              antennaImage.getWidth(this),\n              antennaImage.getHeight(this));\n          g2d.setColor(Color.BLUE);\n          g2d.drawRect(\n              (int) xPos - antennaImage.getWidth(this) / 2,\n              (int) yPos - antennaImage.getHeight(this) / 2,\n              antennaImage.getWidth(this),\n              antennaImage.getHeight(this));\n        }\n\n        g2d.drawImage(\n            antennaImage,\n            (int) xPos - antennaImage.getWidth(this) / 2,\n            (int) yPos - antennaImage.getHeight(this) / 2,\n            this);\n      }\n    }\n\n    // -- Draw radio activity --\n    // if (drawRadioActivity) {\n    // for (RadioConnection connection: currentRadioMedium.getActiveConnections()) {\n    // Position sourcePosition = connection.getSource().getPosition();\n    //\n    // // Paint scaled (otherwise bad rounding to integers may occur)\n    // g2d.setTransform(realWorldTransformScaled);\n    // g2d.setStroke(new BasicStroke((float) 0.0));\n    //\n    // for (Radio receivingRadio: connection.getDestinations()) {\n    // g2d.setColor(Color.GREEN);\n    //\n    // // Get source and destination coordinates\n    // Position destinationPosition = receivingRadio.getPosition();\n    //\n    // g2d.draw(new Line2D.Double(\n    // sourcePosition.getXCoordinate()*100.0,\n    // sourcePosition.getYCoordinate()*100.0,\n    // destinationPosition.getXCoordinate()*100.0,\n    // destinationPosition.getYCoordinate()*100.0\n    // ));\n    // }\n    //\n    // for (Radio interferedRadio: connection.getInterfered()) {\n    // g2d.setColor(Color.RED);\n    //\n    // // Get source and destination coordinates\n    // Position destinationPosition = interferedRadio.getPosition();\n    //\n    // g2d.draw(new Line2D.Double(\n    // sourcePosition.getXCoordinate()*100.0,\n    // sourcePosition.getYCoordinate()*100.0,\n    // destinationPosition.getXCoordinate()*100.0,\n    // destinationPosition.getYCoordinate()*100.0\n    // ));\n    // }\n    //\n    // g2d.setColor(Color.BLUE);\n    // g2d.setTransform(realWorldTransform);\n    //\n    // g2d.translate(\n    // sourcePosition.getXCoordinate(),\n    // sourcePosition.getYCoordinate()\n    // );\n    //\n    // // Fetch current translation\n    // double xPos = g2d.getTransform().getTranslateX();\n    // double yPos = g2d.getTransform().getTranslateY();\n    //\n    // // Jump to identity transform and paint without scaling\n    // g2d.setTransform(new AffineTransform());\n    //\n    // g2d.fillOval(\n    // (int) xPos,\n    // (int) yPos,\n    // 5,\n    // 5\n    // );\n    //\n    // }\n    // }\n\n    // -- Draw scale arrow --\n    if (drawScaleArrow) {\n      g2d.setStroke(new BasicStroke((float) .0));\n\n      g2d.setColor(Color.BLACK);\n\n      // Decide on scale comparator\n      double currentArrowDistance = 0.1; // in meters\n      if (currentZoomX < canvas.getWidth() / 2) {\n        currentArrowDistance = 0.1; // 0.1m\n      }\n      if (currentZoomX < canvas.getWidth() / 2) {\n        currentArrowDistance = 1; // 1m\n      }\n      if (10 * currentZoomX < canvas.getWidth() / 2) {\n        currentArrowDistance = 10; // 10m\n      }\n      if (100 * currentZoomX < canvas.getWidth() / 2) {\n        currentArrowDistance = 100; // 100m\n      }\n      if (1000 * currentZoomX < canvas.getWidth() / 2) {\n        currentArrowDistance = 1000; // 100m\n      }\n\n      // \"Arrow\" points\n      int pixelArrowLength = (int) (currentArrowDistance * currentZoomX);\n      int xPoints[] = new int[] {-pixelArrowLength, -pixelArrowLength, -pixelArrowLength, 0, 0, 0};\n      int yPoints[] = new int[] {-5, 5, 0, 0, -5, 5};\n\n      // Paint arrow and text\n      g2d.setTransform(originalTransform);\n      g2d.translate(canvas.getWidth() - 120, canvas.getHeight() - 20);\n      g2d.drawString(currentArrowDistance + \"m\", -30, -10);\n      g2d.drawPolyline(xPoints, yPoints, xPoints.length);\n    }\n\n    // -- Draw tracked components (if any) --\n    if (!currentSimulation.isRunning() && inTrackMode && trackedComponents != null) {\n      g2d.setTransform(realWorldTransformScaled);\n      g2d.setStroke(new BasicStroke((float) 0.0));\n\n      Random random = new Random(); /* Do not use main random generator */\n      for (Line2D l : trackedComponents.components) {\n        g2d.setColor(new Color(255, random.nextInt(255), random.nextInt(255), 255));\n        Line2D newLine =\n            new Line2D.Double(\n                l.getX1() * 100.0, l.getY1() * 100.0, l.getX2() * 100.0, l.getY2() * 100.0);\n        g2d.draw(newLine);\n      }\n    }\n\n    g2d.setTransform(originalTransform);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6649, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 223, "focalAPIEnd": 239, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Enough-Software/j2mepolish/tree/master/enough-polish-j2me/source/test/de/enough/polish/util/ZipUtilTest.java", "rawCode": "  public void testRgbToByteConversion() {\n    Random random = new Random(System.currentTimeMillis());\n    int[] rgb = new int[8 * 1024 + random.nextInt(8 * 1024)];\n    for (int i = 0; i < rgb.length; i++) {\n      rgb[i] = (random.nextInt() & 0x00ffffff);\n    }\n\n    byte[] data = ZipUtil.convertRgbToByteArray(rgb);\n    assertEquals(rgb.length * 3, data.length);\n\n    int[] rgb2 = ZipUtil.convertByteToRgbArray(data);\n    assertEquals(rgb.length, rgb2.length);\n    for (int i = 0; i < rgb2.length; i++) {\n      assertEquals(rgb[i], rgb2[i]);\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6650, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 374, "focalAPIEnd": 405, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["generateSentence(element)"], "useStart": [559], "useEnd": [587], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/guoliqiang/coding/tree/master/third_part/hadoop/hadoop-1.1.2/src/examples/org/apache/hadoop/examples/RandomTextWriter.java", "rawCode": "    /** Given an output filename, write a bunch of random records to it. */\n    public void map(Text key, Text value, OutputCollector<Text, Text> output, Reporter reporter)\n        throws IOException {\n      int itemCount = 0;\n      while (numBytesToWrite > 0) {\n        // Generate the key/value\n        int noWordsKey =\n            minWordsInKey + (wordsInKeyRange != 0 ? random.nextInt(wordsInKeyRange) : 0);\n        int noWordsValue =\n            minWordsInValue + (wordsInValueRange != 0 ? random.nextInt(wordsInValueRange) : 0);\n        Text keyWords = generateSentence(noWordsKey);\n        Text valueWords = generateSentence(noWordsValue);\n\n        // Write the sentence\n        output.collect(keyWords, valueWords);\n\n        numBytesToWrite -= (keyWords.getLength() + valueWords.getLength());\n\n        // Update counters, progress etc.\n        reporter.incrCounter(\n            Counters.BYTES_WRITTEN, (keyWords.getLength() + valueWords.getLength()));\n        reporter.incrCounter(Counters.RECORDS_WRITTEN, 1);\n        if (++itemCount % 200 == 0) {\n          reporter.setStatus(\"wrote record \" + itemCount + \". \" + numBytesToWrite + \" bytes left.\");\n        }\n      }\n      reporter.setStatus(\"done with \" + itemCount + \" records.\");\n    }\n"}, {"dataset": "randomNextInt", "exampleID": 6651, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 569, "focalAPIEnd": 592, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/iansealy/picard-detct/tree/master/src/java/net/sf/samtools/SAMRecordSetBuilder.java", "rawCode": "  /**\n   * Fills in bases and qualities with a set default quality. If the defaultQuality is set to -1\n   * quality scores will be randomly generated. Relies on the alignment start and end having been\n   * set to get read length.\n   */\n  private void fillInBasesAndQualities(final SAMRecord rec, final int defaultQuality) {\n    final int length = this.readLength;\n    final byte[] quals = new byte[length];\n\n    if (-1 != defaultQuality) {\n      Arrays.fill(quals, (byte) defaultQuality);\n    } else {\n      for (int i = 0; i < length; ++i) {\n        quals[i] = (byte) this.random.nextInt(50);\n      }\n    }\n    rec.setBaseQualities(quals);\n    fillInBases(rec);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6652, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 147, "focalAPIEnd": 161, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/svn2github/H2-Mirror/tree/master/h2/src/test/org/h2/test/unit/TestIntIntHashMap.java", "rawCode": "  private void test(boolean random) {\n    int len = 2000;\n    int[] x = new int[len];\n    for (int i = 0; i < len; i++) {\n      int key = random ? rand.nextInt() : i;\n      x[i] = key;\n    }\n    IntIntHashMap map = new IntIntHashMap();\n    for (int i = 0; i < len; i++) {\n      map.put(x[i], i);\n    }\n    for (int i = 0; i < len; i++) {\n      if (map.get(x[i]) != i) {\n        throw new AssertionError(\"get \" + x[i] + \" = \" + map.get(i) + \" should be \" + i);\n      }\n    }\n    for (int i = 1; i < len; i += 2) {\n      map.remove(x[i]);\n    }\n    for (int i = 1; i < len; i += 2) {\n      if (map.get(x[i]) != -1) {\n        throw new AssertionError(\"get \" + x[i] + \" = \" + map.get(i) + \" should be <=0\");\n      }\n    }\n    for (int i = 1; i < len; i += 2) {\n      map.put(x[i], i);\n    }\n    for (int i = 0; i < len; i++) {\n      if (map.get(x[i]) != i) {\n        throw new AssertionError(\"get \" + x[i] + \" = \" + map.get(i) + \" should be \" + i);\n      }\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6653, "initialization": ["Random random = new Random(int)"], "initializationStart": [60], "initializationEnd": [77], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 138, "focalAPIEnd": 152, "followUpCheck": "i < element", "checkType": "LOOP", "followUpCheckExpressionStart": 195, "followUpCheckExpressionEnd": 224, "followUpCheckBlockStart": 195, "followUpCheckBlockEnd": 275, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/davros-/platform_frameworks_base/tree/master/telephony/tests/telephonytests/src/com/android/internal/telephony/cdma/CdmaSmsCbTest.java", "rawCode": "  public void testRandomBearerStreamData() {\n    Random r = new Random(54321);\n    for (int run = 0; run < 1000; run++) {\n      int len = r.nextInt(140);\n      byte[] data = new byte[len];\n      for (int i = 0; i < len; i++) {\n        data[i] = (byte) r.nextInt(256);\n      }\n      // Log.d(\"CdmaSmsCbTest\", \"trying random bearer data run \" + run + \" length \" + len);\n      try {\n        int category = 0x0ff0 + r.nextInt(32); // half CMAS, half non-CMAS\n        Parcel p = createBroadcastParcel(category);\n        SmsMessage msg = createMessageFromParcel(p, data);\n        SmsCbMessage cbMessage = msg.parseBroadcastSms();\n        // with random input, cbMessage will almost always be null (log when it isn't)\n        if (cbMessage != null) {\n          Log.d(\"CdmaSmsCbTest\", \"success: \" + cbMessage);\n        }\n      } catch (Exception e) {\n        Log.d(\"CdmaSmsCbTest\", \"exception thrown\", e);\n        fail(\"Exception in decoder at run \" + run + \" length \" + len + \": \" + e);\n      }\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6654, "initialization": ["Random random = new Random()"], "initializationStart": [96], "initializationEnd": [108], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 128, "focalAPIEnd": 164, "followUpCheck": "element == 1", "checkType": "IF", "followUpCheckExpressionStart": 175, "followUpCheckExpressionEnd": 191, "followUpCheckBlockStart": 175, "followUpCheckBlockEnd": 244, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/VivaDaylight3/myrmecology/tree/master/src/minecraft/vivadaylight3/myrmecology/common/handler/WorldGen.java", "rawCode": "  private void generateOverworld(World world, Random random, int i, int j) {\n\n    Random rand = new Random();\n\n    int chance = rand.nextInt(Register.hillSpawnRate) + 1;\n\n    if (chance == 1) {\n\n      generateAntHill(world, random, i, j);\n    }\n\n    int blockX = i + random.nextInt(16);\n    int blockZ = j + random.nextInt(16);\n    int blockY = world.getHeightValue(blockX, blockZ);\n\n    BiomeGenBase biome = world.getBiomeGenForCoords(i, j);\n\n    if (biome == BiomeGenBase.swampland) {\n\n      world.setBlock(blockX, blockY, blockZ, Register.blockFungi.blockID);\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6655, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 232, "focalAPIEnd": 250, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/peixere/gotom/tree/master/commons/cn.gotom.commons/src/main/java/cn/gotom/util/StringUtils.java", "rawCode": "  /**\n   * 生成随机数跳步密码\n   *\n   * @param length 随机数长度\n   * @return\n   */\n  public static String getRandPassword(int length) {\n    Random random = new Random();\n    String password = \"\";\n    for (int i = 0; i < length; i++) password += random.nextInt(10) + \"\";\n    return password;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6656, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 74, "focalAPIEnd": 87, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.util.Random.nextBytes(byte[])"], "useStart": [124], "useEnd": [139], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/prsebastian/gwt-issue8215/tree/master/user/test/com/google/gwt/user/server/Base64Test.java", "rawCode": "  private static void base64RoundTrip(java.util.Random r) {\n    int len = r.nextInt(10);\n    byte[] b1 = new byte[len];\n    r.nextBytes(b1);\n\n    base64RoundTrip(b1);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6657, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "Throwable", "exceptionHandlingCall": ["println(*)", "Map<String, List<StepStats>>.remove(String)"], "tryExpressionStart": 191, "tryExpressionEnd": 195, "tryBlockStart": 191, "tryBlockEnd": 2335, "catchExpressionStart": 2189, "catchExpressionEnd": 2209, "catchBlockStart": 2189, "catchBlockEnd": 2335, "exceptionHandlingCallStart": [2217, 2300], "exceptionHandlingCallEnd": [2260, 2320], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "random!=null", "guardType": "IF {", "guardExpressionStart": 279, "guardExpressionEnd": 293, "guardBlockStart": 279, "guardBlockEnd": 354, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 307, "focalAPIEnd": 341, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt(int)"], "useStart": [1456], "useEnd": [1490], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/gmfawcett/openmark-mvn/tree/master/tags/v1.5.6/trunk/src/om/loadtest/TNTester.java", "rawCode": "  /**\n   * Runs through the sequence with one user.\n   *\n   * @param ahsi Array of script items\n   */\n  private void doSequence(Random r, int iServer) {\n    String sOUCU = getNextOUCU();\n    try {\n      // Random delay before starting (so all threads don't begin in synch)\n      if (r != null) Thread.sleep(r.nextInt(DELAYMAX - DELAYMIN + 1) + DELAYMIN);\n\n      Map<String, String> mTokens = new HashMap<String, String>();\n      mTokens.put(\n          \"AUTHCOOKIE\",\n          \"1ed6b71fed0260d1d9aa1730b77325a5430cba4a\" + sOUCU + \"%2E%2E00000000%2E%2E\");\n      String sCookie = sendRequestGetCookie(iServer, mTokens, ahsi[0]);\n      mTokens.put(\"SESSIONCOOKIE\", sCookie);\n\n      if (DEBUG) System.err.println(\"* Got cookie: \" + sCookie);\n\n      List<StepStats> lSteps;\n      synchronized (mStats) {\n        lSteps = mStats.get(sOUCU);\n        if (lSteps == null) {\n          lSteps = new LinkedList<StepStats>();\n          mStats.put(sOUCU, lSteps);\n        } else throw new Error(\"wtf?\");\n        mHosts.put(sOUCU, HOSTS[iServer]);\n      }\n\n      for (int iItem = 1; iItem < ahsi.length; iItem++) {\n        HttpScript.Item i = ahsi[iItem];\n        if (i.getURL().matches(\"^.*/simple1/(\\\\?.*)?$\")) {\n          StepStats ss = new StepStats();\n          lSteps.add(ss);\n\n          if (DEBUG) System.err.println(\"* Step \" + (lSteps.size() - 1));\n          sendRequestGetMedia(iServer, mTokens, i, ss);\n\n          // Delay\n          if (r != null) Thread.sleep(r.nextInt(DELAYMAX - DELAYMIN + 1) + DELAYMIN);\n        }\n      }\n\n      StringBuffer sb = new StringBuffer(sOUCU + \"\\t\" + HOSTS[iServer] + \"\\n\");\n      sb.append(\"\\tXHTML\");\n      long lTotal = 0;\n      for (Iterator i = lSteps.iterator(); i.hasNext(); ) {\n        StepStats ss = (StepStats) i.next();\n        sb.append(\"\\t\" + ss.lTime);\n        lTotal += ss.lTime;\n      }\n      sb.append(\"\\t\\t\" + lTotal);\n      sb.append(\"\\n\\tMedia\");\n      lTotal = 0;\n      for (Iterator i = lSteps.iterator(); i.hasNext(); ) {\n        StepStats ss = (StepStats) i.next();\n        sb.append(\"\\t\" + ss.getMediaTime());\n        lTotal += ss.getMediaTime();\n      }\n      sb.append(\"\\t\\t\" + lTotal);\n      System.out.println(sb.toString());\n    } catch (Throwable t) {\n      System.err.println(sOUCU + \"\\tError\\t\" + t);\n      synchronized (mStats) {\n        mStats.remove(sOUCU);\n      }\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6658, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 535, "focalAPIEnd": 549, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/madiator/HadoopUSC/tree/master/src/hdfs/org/apache/hadoop/hdfs/server/datanode/FSDataset.java", "rawCode": "  /**\n   * Register the FSDataset MBean using the name\n   * \"hadoop:service=DataNode,name=FSDatasetState-<storageid>\"\n   */\n  void registerMBean(final String storageId) {\n    // We wrap to bypass standard mbean naming convetion.\n    // This wraping can be removed in java 6 as it is more flexible in\n    // package naming for mbeans and their impl.\n    StandardMBean bean;\n    String storageName;\n    if (storageId == null || storageId.equals(\"\")) { // Temp fix for the uninitialized storage\n      storageName = \"UndefinedStorageId\" + rand.nextInt();\n    } else {\n      storageName = storageId;\n    }\n    try {\n      bean = new StandardMBean(this, FSDatasetMBean.class);\n      mbeanName = MBeanUtil.registerMBean(\"DataNode\", \"FSDatasetState-\" + storageName, bean);\n      versionBeanName = VersionInfo.registerJMX(\"DataNode\");\n    } catch (NotCompliantMBeanException e) {\n      e.printStackTrace();\n    }\n\n    DataNode.LOG.info(\"Registered FSDatasetStatusMBean\");\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6659, "initialization": ["Random random = new Random()"], "initializationStart": [59], "initializationEnd": [71], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 106, "focalAPIEnd": 122, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt()"], "useStart": [139], "useEnd": [155], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sala223/DelicacyFusion/tree/master/modules/server/core/src/main/java/com/df/core/common/utils/SecurityUtils.java", "rawCode": "  public static char getRandomChar() {\n    Random random = new Random();\n    char newChar;\n    int next = random.nextInt();\n    int type = random.nextInt() % 3;\n    int d;\n    switch (type) {\n      case 0:\n        d = next % 10;\n        if (d < 0) {\n          d = d * (-1);\n        }\n        newChar = (char) (d + 48);\n        break;\n      case 1:\n        d = next % 26;\n        if (d < 0) {\n          d = d * (-1);\n        }\n        newChar = (char) (d + 97);\n        break;\n      default:\n        d = (next % 26);\n        if (d < 0) {\n          d = d * (-1);\n        }\n        newChar = (char) (d + 65);\n    }\n    return newChar;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6660, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 64, "focalAPIEnd": 86, "followUpCheck": "bound <= element", "checkType": "IF", "followUpCheckExpressionStart": 197, "followUpCheckExpressionEnd": 218, "followUpCheckBlockStart": 197, "followUpCheckBlockEnd": 227, "use": ["AtomicReferenceArray<Entry>.get(element)"], "useStart": [251], "useEnd": [265], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/pdinc-oss/jgit/tree/master/org.eclipse.jgit/src/org/eclipse/jgit/storage/file/WindowCache.java", "rawCode": "  private void evict() {\n    while (isFull()) {\n      int ptr = rng.nextInt(tableSize);\n      Entry old = null;\n      int slot = 0;\n      for (int b = evictBatch - 1; b >= 0; b--, ptr++) {\n        if (tableSize <= ptr) ptr = 0;\n        for (Entry e = table.get(ptr); e != null; e = e.next) {\n          if (e.dead) continue;\n          if (old == null || e.ref.lastAccess < old.ref.lastAccess) {\n            old = e;\n            slot = ptr;\n          }\n        }\n      }\n      if (old != null) {\n        old.kill();\n        gc();\n        final Entry e1 = table.get(slot);\n        table.compareAndSet(slot, e1, clean(e1));\n      }\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6661, "initialization": ["int bound = Vector.size()", "Random random = new Random()"], "initializationStart": [746, 849], "initializationEnd": [758, 861], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 881, "focalAPIEnd": 901, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["elementAt(element)"], "useStart": [991], "useEnd": [1009], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/Starlink/starjava/tree/master/ant/src/main/org/apache/tools/ant/taskdefs/optional/sound/SoundTask.java", "rawCode": "    /**\n     * Gets the location of the file to get the audio.\n     *\n     * @return the file location\n     */\n    public File getSource() {\n      File nofile = null;\n      // Check if source is a directory\n      if (source.exists()) {\n        if (source.isDirectory()) {\n          // get the list of files in the dir\n          String[] entries = source.list();\n          Vector files = new Vector();\n          for (int i = 0; i < entries.length; i++) {\n            File f = new File(source, entries[i]);\n            if (f.isFile()) {\n              files.addElement(f);\n            }\n          }\n          if (files.size() < 1) {\n            throw new BuildException(\"No files found in directory \" + source);\n          }\n          int numfiles = files.size();\n          // get a random number between 0 and the number of files\n          Random rn = new Random();\n          int x = rn.nextInt(numfiles);\n          // set the source to the file at that location\n          this.source = (File) files.elementAt(x);\n        }\n      } else {\n        log(source + \": invalid path.\", Project.MSG_WARN);\n        this.source = nofile;\n      }\n      return this.source;\n    }\n"}, {"dataset": "randomNextInt", "exampleID": 6662, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 284, "focalAPIEnd": 305, "followUpCheck": "element < minVal", "checkType": "IF", "followUpCheckExpressionStart": 372, "followUpCheckExpressionEnd": 389, "followUpCheckBlockStart": 372, "followUpCheckBlockEnd": 421, "use": ["new Integer(element)", "new Integer(element)", "new Integer(element)", "random.nextInt(int)", "new Integer(element)", "new Integer(element)", "new Integer(element)"], "useStart": [491, 535, 1249, 1419, 1533, 1581, 1819], "useEnd": [507, 551, 1265, 1440, 1549, 1597, 1835], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/brachior/platform_libcore/tree/master/luni/src/test/java/libcore/java/util/OldAndroidTreeMapTest.java", "rawCode": "  private void doTest() {\n    TreeMap<Integer, String> tm = new TreeMap<Integer, String>();\n    HashMap<Integer, String> hm = new HashMap<Integer, String>();\n\n    int minVal = Integer.MAX_VALUE;\n    int maxVal = Integer.MIN_VALUE;\n\n    for (int i = 0; i < 100; i++) {\n      int val = mRandom.nextInt(1000);\n      if (SPEW) System.out.println(\"Adding val = \" + val);\n      if (val < minVal) {\n        minVal = val;\n      }\n      if (val > maxVal) {\n        maxVal = val;\n      }\n      tm.put(new Integer(val), \"V:\" + val);\n      hm.put(new Integer(val), \"V:\" + val);\n\n      if (SPEW) System.out.println(\"tm = \" + tm);\n\n      if (SPEW) System.out.println(\"tm.size() = \" + tm.size());\n      if (SPEW) System.out.println(\"hm.size() = \" + hm.size());\n      assertEquals(tm.size(), hm.size());\n\n      if (SPEW) System.out.println(\"tm.firstKey() = \" + tm.firstKey());\n      if (SPEW) System.out.println(\"minVal = \" + minVal);\n      if (SPEW) System.out.println(\"tm.lastKey() = \" + tm.lastKey());\n      if (SPEW) System.out.println(\"maxVal = \" + maxVal);\n      assertEquals(minVal, tm.firstKey().intValue());\n      assertEquals(maxVal, tm.lastKey().intValue());\n    }\n\n    // Check for equality\n    for (int val = 0; val < 1000; val++) {\n      Integer vv = new Integer(val);\n      String tms = tm.get(vv);\n      String hms = hm.get(vv);\n      assertEquals(tms, hms);\n    }\n\n    for (int i = 0; i < 1000; i++) {\n      int val = mRandom.nextInt(1000);\n      if (SPEW) System.out.println(\"Removing val = \" + val);\n\n      String tms = tm.remove(new Integer(val));\n      String hms = hm.remove(new Integer(val));\n\n      if (SPEW) System.out.println(\"tm = \" + tm);\n\n      assertEquals(tm.size(), hm.size());\n      assertEquals(tms, hms);\n    }\n\n    // Check for equality\n    for (int val = 0; val < 1000; val++) {\n      Integer vv = new Integer(val);\n      String tms = tm.get(vv);\n      String hms = hm.get(vv);\n      assertEquals(tms, hms);\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6663, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 58, "focalAPIEnd": 85, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/exoplatform/ks/tree/master/eXoApplication/forum/service/src/main/java/org/exoplatform/forum/bench/RandomForumDataProvider.java", "rawCode": "  private int getMaxCategory() {\n    return (randomize) ? rand.nextInt(maxCategories) : maxCategories;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6664, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 833, "focalAPIEnd": 857, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["HttpServer.stop()"], "finallyExpressionStart": 1309, "finallyExpressionEnd": 1317, "finallyBlockStart": 1309, "finallyBlockEnd": 1343, "cleanUpCallStart": [1325], "cleanUpCallEnd": [1336], "url": "https://github.com/bryanjimenez/empanada/tree/master/hadoop/hadoop-1.2.1/src/test/org/apache/hadoop/http/TestServletFilter.java", "rawCode": "  public void testServletFilter() throws Exception {\n    Configuration conf = new Configuration();\n\n    // start a http server with CountingFilter\n    conf.set(HttpServer.FILTER_INITIALIZER_PROPERTY, SimpleFilter.Initializer.class.getName());\n    HttpServer http = new HttpServer(\"datanode\", \"localhost\", 0, true, conf);\n    http.start();\n\n    final String fsckURL = \"/fsck\";\n    final String stacksURL = \"/stacks\";\n    final String ajspURL = \"/a.jsp\";\n    final String logURL = \"/logs/a.log\";\n    final String hadooplogoURL = \"/static/hadoop-logo.jpg\";\n\n    final String[] urls = {fsckURL, stacksURL, ajspURL, logURL, hadooplogoURL};\n    final Random ran = new Random();\n    final int[] sequence = new int[50];\n\n    // generate a random sequence and update counts\n    for (int i = 0; i < sequence.length; i++) {\n      sequence[i] = ran.nextInt(urls.length);\n    }\n\n    // access the urls as the sequence\n    final String prefix = \"http://localhost:\" + http.getPort();\n    try {\n      for (int i = 0; i < sequence.length; i++) {\n        access(prefix + urls[sequence[i]]);\n\n        // make sure everything except fsck get filtered\n        if (sequence[i] == 0) {\n          assertEquals(null, uri);\n        } else {\n          assertEquals(urls[sequence[i]], uri);\n          uri = null;\n        }\n      }\n    } finally {\n      http.stop();\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6665, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 70, "focalAPIEnd": 104, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/goodow/gwt/tree/master/samples/dynatablerf/src/main/java/com/google/gwt/sample/dynatablerf/server/PersonFuzzer.java", "rawCode": "  private static boolean isChosenAsProfessor(Random rnd) {\n    return rnd.nextInt(STUDENTS_PER_PROF + 1) == 0;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6666, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 341, "focalAPIEnd": 360, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Integer(element)", "swap(int,element)", "new Integer(element)", "swap(int,element)", "random.nextInt(int)", "new Integer(element)", "swap(int,element)", "new Integer(element)"], "useStart": [381, 536, 597, 730, 860, 900, 1043, 1148], "useEnd": [395, 546, 611, 740, 879, 914, 1053, 1162], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/timcheadle/cs-projects/tree/master/other/n-queens/src/NQueens.java", "rawCode": "  private int initialSearch() {\n    int i = 0;\n    int j = 0;\n    int m = 0;\n\n    // Place the queens on the diagonal\n    for (i = 0; i < n; i++) {\n      queens[i] = i;\n    }\n\n    // Now place the queens smartly a certain # of times, avoiding all collisions\n    i = 0;\n    while (i < (3.08 * n)) {\n      Integer mInt;\n      do {\n        m = rand.nextInt(n - j) + j;\n        mInt = new Integer(m);\n        System.out.print(\"#\");\n        i++;\n      } while (rows.contains(mInt) && i < (3.08 * n));\n      System.out.println(\"woo\");\n\n      swap(j, m);\n      if (collisions(j) == 0) {\n        rows.add(new Integer(m));\n        j++;\n        System.out.println(\"initial: placed queen in col \" + j + \", row \" + m);\n      } else {\n        swap(j, m);\n      }\n    }\n\n    // Randomy place the rest\n    for (i = j; i < n; i++) {\n      Integer mInt;\n      do {\n        m = rand.nextInt(n - j) + j;\n        mInt = new Integer(m);\n        System.out.print(\"%\");\n      } while (rows.contains(mInt) && rows.size() <= n);\n      System.out.println(\"unf\");\n      swap(j, m);\n      System.out.println(\"initial: placed queen in col \" + j + \", row \" + m);\n      rows.add(new Integer(m));\n    }\n\n    return n - j;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6667, "initialization": ["Random random = new Random()"], "initializationStart": [125], "initializationEnd": [137], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 173, "focalAPIEnd": 189, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["new Box(element,*)"], "useStart": [230], "useEnd": [267], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nvpanov/goptimum/tree/master/tests/functions/Function_Rastrigin10_2DTest.java", "rawCode": "  @Test\n  public void testWrongDimension() {\n    Function_Rastrigin10_2D f = new Function_Rastrigin10_2D();\n    Random rnd = new Random();\n    int dim;\n    do {\n      dim = rnd.nextInt(100);\n    } while (dim == 2);\n\n    Box box = new Box(dim, new RealInterval(-1, 1));\n    double point[] = new double[dim];\n\n    try {\n      f.calculate(box);\n      fail(\n          \"exception expected! Don't you forget to add -ea option to JavaVM arguments? (Window->Preferences->Jnstalled JREs->Edit->Default VM arguments)\");\n    } catch (AssertionError e) {\n      // assertTrue(1 == 1);\n    }\n    try {\n      f.calculatePoint(point);\n      fail(\"exception expected\");\n    } catch (AssertionError e) {\n      // assertTrue(1 == 1);\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6668, "initialization": ["Random random = new Random()"], "initializationStart": [353], "initializationEnd": [365], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 438, "focalAPIEnd": 454, "followUpCheck": "frame.element() == frame.src()", "checkType": "IF", "followUpCheckExpressionStart": 1034, "followUpCheckExpressionEnd": 1066, "followUpCheckBlockStart": 1034, "followUpCheckBlockEnd": 1396, "use": ["random.nextInt(int)", "Ring0TokenFrame.set_dest(element)"], "useStart": [789, 937], "useEnd": [804, 957], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/audiohacked/audiohacked/tree/master/cs353-project2/Ring0ClientNode.java", "rawCode": "  void generate_frames(String str, int count) throws IOException {\n    /* if we are not the last frame to be created we call ourself */\n    if (count > 0) generate_frames(str, count - 1);\n\n    /* create a Frame object */\n    Ring0TokenFrame frame = new Ring0TokenFrame(node_name, this.status);\n\n    /* initialize a random generator */\n    Random rand = new Random();\n\n    /* generate a random node to send the frame */\n    Integer dest = rand.nextInt(10);\n\n    /* set the data String to someting */\n    frame.set_data(\n        \" This MAC STR frame sent from node \"\n            + this.this_node_num.toString()\n            + \" to node \"\n            + dest.toString()\n            + \" \");\n\n    /* generate if we make a token for passing; or if its a data frame */\n    frame.set_access_control(rand.nextInt(2));\n\n    /* set the data frame size automatically */\n    frame.set_data_size();\n\n    /* set the destination node for the frame */\n    frame.set_dest(dest);\n\n    /* set the source node */\n    frame.set_src(this.this_node_num);\n\n    if (frame.dest() == frame.src()) {\n      generate_frames(str, count);\n    } else {\n      /* open the input file for writing and saving each frame */\n      PrintWriter infile_write = new PrintWriter(new FileWriter(this.f_input, true));\n      infile_write.println(frame.print()); /* print frame to input file */\n      infile_write.close(); /* close buffer */\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6669, "initialization": ["Random random = new Random()"], "initializationStart": [308], "initializationEnd": [320], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 531, "focalAPIEnd": 548, "followUpCheck": "element == '\\n' || element == '\\r'", "checkType": "LOOP {", "followUpCheckExpressionStart": 558, "followUpCheckExpressionEnd": 588, "followUpCheckBlockStart": 558, "followUpCheckBlockEnd": 611, "use": ["random.nextInt(int)"], "useStart": [593], "useEnd": [610], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/apache/avro/tree/master/lang/java/tools/src/test/java/org/apache/avro/tool/TestTextFileTools.java", "rawCode": "  @BeforeClass\n  public static void writeRandomFile() throws IOException {\n    schema = Schema.create(Type.BYTES);\n    lines = new ByteBuffer[COUNT];\n    linesFile = new File(DIR.getRoot(), \"random.lines\");\n\n    OutputStream out = new BufferedOutputStream(new FileOutputStream(linesFile));\n    Random rand = new Random();\n    for (int j = 0; j < COUNT; j++) {\n      byte[] line = new byte[rand.nextInt(512)];\n      System.out.println(\"Creating line = \" + line.length);\n      for (int i = 0; i < line.length; i++) {\n        int b = rand.nextInt(256);\n        while (b == '\\n' || b == '\\r') b = rand.nextInt(256);\n        line[i] = (byte) b;\n      }\n      out.write(line);\n      out.write(LINE_SEP);\n      lines[j] = ByteBuffer.wrap(line);\n    }\n    out.close();\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6670, "initialization": ["Random random = new Random()", "int bound = LinkedList<SituationWithRating>.size()"], "initializationStart": [172, 381], "initializationEnd": [184, 392], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 551, "focalAPIEnd": 574, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["get(element)"], "useStart": [542], "useEnd": [575], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/tubs-legolabor-teamprojekt/schach/tree/master/ai/gameTree/NextMove.java", "rawCode": "  private void findBestSituationWithPositionInListMax() {\n    // Stelle der am besten bewerteten Situation in der ArrayList\n    int figureHelp = -INFINITY;\n    Random rn = new Random();\n    for (int i = 0; i < list.size(); i++) {\n      if (list.get(i).getPositionRating() > figureHelp) {\n        figureHelp = list.get(i).getPositionRating();\n      }\n    }\n\n    for (int i = 0; i < list.size(); i += 0) {\n      if (list.get(i).getPositionRating() != figureHelp) {\n        list.remove(i);\n        i--;\n      }\n      i++;\n    }\n    afterField = list.get(rn.nextInt(list.size())).getMap();\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6671, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 728, "focalAPIEnd": 744, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt()"], "useStart": [1270], "useEnd": [1286], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/escidoc/escidoc-core/tree/master/utilities/src/main/java/org/escidoc/core/utils/io/FileUtils.java", "rawCode": "  public static synchronized File getDefaultTempDirectory() {\n    if (defaultTempDirectory != null && defaultTempDirectory.exists()) {\n      return defaultTempDirectory;\n    }\n    String tempDirectoryProperty = null;\n    try {\n      tempDirectoryProperty = System.getProperty(FileUtils.class.getName() + \".TempDirectory\");\n    } catch (SecurityException e) {\n      // Ignorable, we'll use the default\n    }\n    if (tempDirectoryProperty != null) {\n      // assume someone outside of us will manage the directory\n      final File tempDirectory = new File(tempDirectoryProperty);\n      if (tempDirectory.mkdirs()) {\n        defaultTempDirectory = tempDirectory;\n      }\n    }\n    if (defaultTempDirectory == null) {\n      int x = RANDOM.nextInt();\n      tempDirectoryProperty = System.getProperty(\"java.io.tmpdir\");\n      final File tmpDirectory = new File(tempDirectoryProperty);\n      if (!tmpDirectory.exists()) {\n        throw new RuntimeException(\n            \"The directory \"\n                + tmpDirectory.getAbsolutePath()\n                + \" does not exist, please set java.io.tempdir\"\n                + \" to an existing directory\");\n      }\n      File tempFile = new File(tempDirectoryProperty, \"escidoc-tmp-\" + x);\n      while (!tempFile.mkdir()) {\n        x = RANDOM.nextInt();\n        tempFile = new File(tempDirectoryProperty, \"escidoc-tmp-\" + x);\n      }\n      defaultTempDirectory = tempFile;\n      final File f2 = tempFile;\n      final Thread hook =\n          new Thread() {\n            @Override\n            public void run() {\n              removeDirectory(f2, true);\n            }\n          };\n      Runtime.getRuntime().addShutdownHook(hook);\n    }\n    return defaultTempDirectory;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6672, "initialization": ["Random random = new Random(int)"], "initializationStart": [167], "initializationEnd": [180], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 250, "focalAPIEnd": 271, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt(int)", "random.nextInt(int)", "random.nextInt(int)", "new ErgebnisKombination(element,int)"], "useStart": [298, 359, 407, 477], "useEnd": [330, 380, 439, 518], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/hitzemann/MasterMindSolver/tree/master/src/test/java/org/hitzemann/mms/model/ErgebnisKombinationTest.java", "rawCode": "  /** Testet stichprobenartig, ob die Relation { (a,b) | a.compareTo(b) <= 0 } total ist. */\n  @Test\n  public final void testCompareToTotal() {\n    final Random rng = new Random(1);\n\n    for (int i = 0; i < SAMPLES; i++) {\n      final int aSchwarz = rng.nextInt(MAX_PINS);\n      final int aWeiss = rng.nextInt(MAX_PINS - aSchwarz);\n      final int bSchwarz = rng.nextInt(MAX_PINS);\n      final int bWeiss = rng.nextInt(MAX_PINS - bSchwarz);\n      final ErgebnisKombination a = new ErgebnisKombination(aSchwarz, aWeiss);\n      final ErgebnisKombination b = new ErgebnisKombination(bSchwarz, bWeiss);\n      assertTrue(\n          \"compareTo not total for a = \" + a + \", b = \" + b,\n          a.compareTo(b) <= 0 || b.compareTo(a) <= 0);\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6673, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 69, "focalAPIEnd": 81, "followUpCheck": "i < element", "checkType": "LOOP", "followUpCheckExpressionStart": 123, "followUpCheckExpressionEnd": 151, "followUpCheckBlockStart": 123, "followUpCheckBlockEnd": 203, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thihy/lucene/tree/master/solr/solrj/src/test/org/apache/solr/common/util/TestNamedListCodec.java", "rawCode": "  public NamedList rNamedList(int lev) {\n    int sz = lev <= 0 ? 0 : r.nextInt(3);\n    NamedList nl = new NamedList();\n    for (int i = 0; i < sz; i++) {\n      nl.add(rStr(2), makeRandom(lev - 1));\n    }\n    return nl;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6674, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "!(true||bound==0)", "guardType": "IF {", "guardExpressionStart": 89, "guardExpressionEnd": 138, "guardBlockStart": 89, "guardBlockEnd": 272, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 295, "focalAPIEnd": 331, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/killme2008/Metamorphosis/tree/master/metamorphosis-client/src/main/java/com/taobao/metamorphosis/client/producer/SimpleXAMessageProducer.java", "rawCode": "  private String selectTransactionBrokerURL() {\n    String[] copiedUrls = this.urls;\n    if (copiedUrls == null || copiedUrls.length == 0) {\n      throw new InvalidBrokerException(\n          \"Could not select a common broker url for topics:\" + this.publishedTopics);\n    }\n    return copiedUrls[this.rand.nextInt(copiedUrls.length)];\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6675, "initialization": ["Random random = new Random(*)"], "initializationStart": [178], "initializationEnd": [196], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 916, "focalAPIEnd": 930, "followUpCheck": "element >= sNumCharacterClasses", "checkType": "IF", "followUpCheckExpressionStart": 940, "followUpCheckExpressionEnd": 978, "followUpCheckBlockStart": 940, "followUpCheckBlockEnd": 1061, "use": ["random.nextInt(int)", "CounterHelper.addChar(element)"], "useStart": [1187, 1249], "useEnd": [1209, 1270], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/faux123/android_frameworks_base/tree/master/telephony/tests/telephonytests/src/com/android/internal/telephony/SmsMessageBodyTest.java", "rawCode": "  @LargeTest\n  public void testCalcLengthMixed7bit() throws Exception {\n    StringBuilder sb = new StringBuilder(320);\n    CounterHelper ch = new CounterHelper();\n    Random r = new Random(0x4321); // use the same seed for reproducibility\n    int[] expectedValues = new int[6];\n    int[] origLockingShiftTables = GsmAlphabet.getEnabledLockingShiftTables();\n    int[] origSingleShiftTables = GsmAlphabet.getEnabledSingleShiftTables();\n    int enabledLanguagesTestCases = sEnabledSingleShiftTables.length;\n    long startTime = System.currentTimeMillis();\n\n    // Repeat for 10 test runs\n    for (int run = 0; run < 10; run++) {\n      sb.setLength(0);\n      ch.clear();\n      int unicodeOnlyCount = 0;\n\n      // Test incrementally from 1 to 320 character random messages\n      for (int i = 1; i < 320; i++) {\n        // 1% chance to add from each special character class, else add an ASCII char\n        int charClass = r.nextInt(100);\n        if (charClass >= sNumCharacterClasses) {\n          charClass = sNumCharacterClasses - 1; // last class is ASCII\n        }\n        int classLength = sCharacterClasses[charClass].length();\n        char nextChar = sCharacterClasses[charClass].charAt(r.nextInt(classLength));\n        sb.append(nextChar);\n        ch.addChar(charClass);\n\n        // if (i % 20 == 0) {\n        // Log.d(TAG, \"test string: \" + sb);\n        // }\n\n        // Test string against all combinations of enabled languages\n        boolean unicodeOnly = true;\n        for (int j = 0; j < enabledLanguagesTestCases; j++) {\n          GsmAlphabet.setEnabledSingleShiftTables(sEnabledSingleShiftTables[j]);\n          GsmAlphabet.setEnabledLockingShiftTables(sEnabledLockingShiftTables[j]);\n          ch.fillData(j, false, expectedValues, i);\n          if (expectedValues[3] == SmsMessage.ENCODING_7BIT) {\n            unicodeOnly = false;\n          }\n          callGsmLengthMethods(sb, false, expectedValues);\n          // test 7 bit only mode\n          ch.fillData(j, true, expectedValues, i);\n          callGsmLengthMethods(sb, true, expectedValues);\n        }\n        // after 10 iterations with a Unicode-only string, skip to next test string\n        // so we can spend more time testing strings that do encode into 7 bits.\n        if (unicodeOnly && ++unicodeOnlyCount == 10) {\n          // Log.d(TAG, \"Unicode only: skipping to next test string\");\n          break;\n        }\n      }\n    }\n    ch.printStats();\n    Log.d(TAG, \"Completed in \" + (System.currentTimeMillis() - startTime) + \" ms\");\n    GsmAlphabet.setEnabledLockingShiftTables(origLockingShiftTables);\n    GsmAlphabet.setEnabledSingleShiftTables(origSingleShiftTables);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6676, "initialization": ["Random random = new Random()"], "initializationStart": [99], "initializationEnd": [111], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 134, "focalAPIEnd": 153, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["abs(element)"], "useStart": [125], "useEnd": [154], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nickleus-j/StorySenseWeb/tree/master/StorySense/src/ajaxAdmin/TemplateWriter.java", "rawCode": "  private String generateTemplateName(String givenName, User sessionUser) {\n    Random generator = new Random();\n    int r = Math.abs(generator.nextInt());\n\n    return givenName + r + \"-\" + sessionUser.getName();\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6677, "initialization": ["Random random = new Random()"], "initializationStart": [88], "initializationEnd": [100], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 187, "focalAPIEnd": 224, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["valueOf(element)", "valueOf(element)"], "useStart": [254, 466], "useEnd": [276, 488], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/sugarcrm/candybean/tree/master/src/test/java/com/sugarcrm/candybean/examples/mobile/AppiumIosTest.java", "rawCode": "  @Test\n  public void testFindElementByTagName() throws Exception {\n    Random random = new Random();\n\n    WebElement text = driver.findElement(By.tagName(\"textField\"));\n    int number = random.nextInt(MAXIMUM - MINIMUM + 1) + MINIMUM;\n    text.sendKeys(String.valueOf(number));\n\n    driver.findElement(By.tagName(\"button\")).click();\n\n    // is sum equal ?\n    WebElement sumLabel = driver.findElement(By.tagName(\"staticText\"));\n    assertEquals(sumLabel.getText(), String.valueOf(number));\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6678, "initialization": ["Random random = new Random()"], "initializationStart": [72], "initializationEnd": [84], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 276, "focalAPIEnd": 287, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["JMSProducer.send(Topic,element)"], "useStart": [297], "useEnd": [326], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/arun-gupta/javaee7-samples/tree/master/jms/jms-batch/src/test/java/org/javaee7/jms/batch/JmsItemReaderTest.java", "rawCode": "  private int sendMessages(int count) {\n    int sum = 0;\n    Random r = new Random();\n    try (JMSContext jms = factory.createContext(Session.AUTO_ACKNOWLEDGE)) {\n      JMSProducer producer = jms.createProducer();\n      for (int i = 0; i < count; i++) {\n        int payload = r.nextInt();\n        producer.send(topic, payload);\n        sum += payload;\n      }\n    }\n    return sum;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6679, "initialization": ["Random random = new Random()"], "initializationStart": [84], "initializationEnd": [96], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 260, "focalAPIEnd": 291, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["forDigit(element,*)"], "useStart": [241], "useEnd": [313], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AllBinary/phoneme-components-cdc/tree/master/src/share/javavm/test/GCTest/IndirectMem/Jsrc/IDArrayRWCharTest.java", "rawCode": "  public void run() {\n    int arrayLength;\n    boolean pass = true;\n    Random rd = new Random();\n\n    arrayLength = getArrayLength();\n\n    char[] inArray = new char[arrayLength];\n    for (int i = 0; i < arrayLength; i++)\n      inArray[i] = Character.forDigit(rd.nextInt(Character.MAX_RADIX), Character.MAX_RADIX);\n\n    setArray(inArray);\n    char[] outArray = getArray();\n\n    for (int i = 0; i < arrayLength; i++) {\n      if (outArray[i] != inArray[i]) {\n        pass = false;\n        break;\n      }\n    }\n\n    System.out.println();\n\n    if (pass) System.out.println(\"PASS: IDArrayRWCharTest, Data written and read were same\");\n    else System.out.println(\"FAIL: IDArrayRWCharTest, Data written and read were not same\");\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6680, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 106, "focalAPIEnd": 128, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/lemmy/dnsjava/tree/master/tags/dnsjava-1-6-1/org/xbill/DNS/Header.java", "rawCode": "  /** Generates a random number suitable for use as a message ID */\n  static int randomID() {\n    return (random.nextInt(0xffff));\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6681, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 628, "focalAPIEnd": 641, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/AllBinary/phoneme-components-cdc/tree/master/src/share/classes/java/math/BigInteger.java", "rawCode": "  /**\n   * Find a random number of the specified bitLength that is probably prime. This method is used for\n   * smaller primes, its performance degrades on larger bitlengths.\n   *\n   * <p>This method assumes bitLength > 1.\n   */\n  private static BigInteger smallPrime(int bitLength, int certainty, Random rnd) {\n    int magLen = (bitLength + 31) >>> 5;\n    int temp[] = new int[magLen];\n    int highBit = 1 << ((bitLength + 31) & 0x1f); // High bit of high int\n    int highMask = (highBit << 1) - 1; // Bits to keep in high int\n\n    while (true) {\n      // Construct a candidate\n      for (int i = 0; i < magLen; i++) temp[i] = rnd.nextInt();\n      temp[0] = (temp[0] & highMask) | highBit; // Ensure exact length\n      if (bitLength > 2) temp[magLen - 1] |= 1; // Make odd if bitlen > 2\n\n      BigInteger p = new BigInteger(temp, 1);\n\n      // Do cheap \"pre-test\" if applicable\n      if (bitLength > 6) {\n        long r = p.remainder(SMALL_PRIME_PRODUCT).longValue();\n        if ((r % 3 == 0) || (r % 5 == 0) || (r % 7 == 0) || (r % 11 == 0) || (r % 13 == 0)\n            || (r % 17 == 0) || (r % 19 == 0) || (r % 23 == 0) || (r % 29 == 0) || (r % 31 == 0)\n            || (r % 37 == 0) || (r % 41 == 0)) continue; // Candidate is composite; try another\n      }\n\n      // All candidates of bitLength 2 and 3 are prime by this point\n      if (bitLength < 4) return p;\n\n      // Do expensive test if we survive pre-test (or it's inapplicable)\n      if (p.primeToCertainty(certainty)) return p;\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6682, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 1, "exceptionType": "HyracksDataException", "exceptionHandlingCall": [], "tryExpressionStart": 1063, "tryExpressionEnd": 1067, "tryBlockStart": 1063, "tryBlockEnd": 1428, "catchExpressionStart": 1765, "catchExpressionEnd": 1796, "catchBlockStart": 1765, "catchBlockEnd": 1833, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 1198, "focalAPIEnd": 1211, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["abs(element)", "random.nextInt()", "abs(element)", "random.nextInt()", "abs(element)"], "useStart": [1189, 2067, 2058, 3060, 3051], "useEnd": [1212, 2080, 2081, 3073, 3074], "hasFinally": 1, "cleanUpCall": ["ICachedPage.releaseWriteLatch()", "IBufferCache.unpin(ICachedPage)"], "finallyExpressionStart": 1344, "finallyExpressionEnd": 1352, "finallyBlockStart": 1344, "finallyBlockEnd": 1428, "cleanUpCallStart": [1362, 1396], "cleanUpCallEnd": [1386, 1419], "url": "https://github.com/jarodwen/hyracks/tree/master/fullstack/hyracks/hyracks-tests/hyracks-storage-common-test/src/test/java/edu/uci/ics/hyracks/storage/common/BufferCacheTest.java", "rawCode": "  @Test\n  public void contentCheckingMaxOpenFilesTest() throws HyracksDataException {\n    TestStorageManagerComponentHolder.init(PAGE_SIZE, NUM_PAGES, MAX_OPEN_FILES);\n    IBufferCache bufferCache = TestStorageManagerComponentHolder.getBufferCache(ctx);\n    IFileMapProvider fmp = TestStorageManagerComponentHolder.getFileMapProvider(ctx);\n\n    List<Integer> fileIds = new ArrayList<Integer>();\n    Map<Integer, ArrayList<Integer>> pageContents = new HashMap<Integer, ArrayList<Integer>>();\n    int num = 10;\n    int testPageId = 0;\n\n    // open max number of files and write some stuff into their first page\n    for (int i = 0; i < MAX_OPEN_FILES; i++) {\n      String fileName = getFileName();\n      FileReference file = new FileReference(new File(fileName));\n      bufferCache.createFile(file);\n      int fileId = fmp.lookupFileId(file);\n      bufferCache.openFile(fileId);\n      fileIds.add(fileId);\n\n      ICachedPage page = null;\n      page = bufferCache.pin(BufferedFileHandle.getDiskPageId(fileId, testPageId), true);\n      page.acquireWriteLatch();\n      try {\n        ArrayList<Integer> values = new ArrayList<Integer>();\n        for (int j = 0; j < num; j++) {\n          int x = Math.abs(rnd.nextInt());\n          page.getBuffer().putInt(j * 4, x);\n          values.add(x);\n        }\n        pageContents.put(fileId, values);\n      } finally {\n        page.releaseWriteLatch();\n        bufferCache.unpin(page);\n      }\n    }\n\n    boolean exceptionThrown = false;\n\n    // since all files are open, next open should fail\n    try {\n      String fileName = getFileName();\n      FileReference file = new FileReference(new File(fileName));\n      bufferCache.createFile(file);\n      int fileId = fmp.lookupFileId(file);\n      bufferCache.openFile(fileId);\n    } catch (HyracksDataException e) {\n      exceptionThrown = true;\n    }\n    Assert.assertTrue(exceptionThrown);\n\n    // close a few random files\n    ArrayList<Integer> closedFileIds = new ArrayList<Integer>();\n    int filesToClose = 5;\n    for (int i = 0; i < filesToClose; i++) {\n      int ix = Math.abs(rnd.nextInt()) % fileIds.size();\n      bufferCache.closeFile(fileIds.get(ix));\n      closedFileIds.add(fileIds.get(ix));\n      fileIds.remove(ix);\n    }\n\n    // now open a few new files\n    for (int i = 0; i < filesToClose; i++) {\n      String fileName = getFileName();\n      FileReference file = new FileReference(new File(fileName));\n      bufferCache.createFile(file);\n      int fileId = fmp.lookupFileId(file);\n      bufferCache.openFile(fileId);\n      fileIds.add(fileId);\n    }\n\n    // since all files are open, next open should fail\n    try {\n      String fileName = getFileName();\n      FileReference file = new FileReference(new File(fileName));\n      bufferCache.createFile(file);\n      int fileId = fmp.lookupFileId(file);\n      bufferCache.openFile(fileId);\n    } catch (HyracksDataException e) {\n      exceptionThrown = true;\n    }\n    Assert.assertTrue(exceptionThrown);\n\n    // close a few random files again\n    for (int i = 0; i < filesToClose; i++) {\n      int ix = Math.abs(rnd.nextInt()) % fileIds.size();\n      bufferCache.closeFile(fileIds.get(ix));\n      closedFileIds.add(fileIds.get(ix));\n      fileIds.remove(ix);\n    }\n\n    // now open those closed files again and verify their contents\n    for (int i = 0; i < filesToClose; i++) {\n      int closedFileId = closedFileIds.get(i);\n      bufferCache.openFile(closedFileId);\n      fileIds.add(closedFileId);\n\n      // pin first page and verify contents\n      ICachedPage page = null;\n      page = bufferCache.pin(BufferedFileHandle.getDiskPageId(closedFileId, testPageId), false);\n      page.acquireReadLatch();\n      try {\n        ArrayList<Integer> values = pageContents.get(closedFileId);\n        for (int j = 0; j < values.size(); j++) {\n          Assert.assertEquals(values.get(j).intValue(), page.getBuffer().getInt(j * 4));\n        }\n      } finally {\n        page.releaseReadLatch();\n        bufferCache.unpin(page);\n      }\n    }\n\n    for (Integer i : fileIds) {\n      bufferCache.closeFile(i.intValue());\n    }\n\n    bufferCache.close();\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6683, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 528, "focalAPIEnd": 556, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 1, "cleanUpCall": ["Socket.close()"], "finallyExpressionStart": 1009, "finallyExpressionEnd": 1017, "finallyBlockStart": 1009, "finallyBlockEnd": 1050, "cleanUpCallStart": [1027], "cleanUpCallEnd": [1041], "url": "https://github.com/jetty-project/jetty-plugin-support/tree/master/jetty-server/src/test/java/org/eclipse/jetty/server/HttpServerTestBase.java", "rawCode": "  @Test\n  public void testRequest2Fragments() throws Exception {\n    configureServer(new EchoHandler());\n\n    byte[] bytes = REQUEST2.getBytes();\n    final int pointCount = 2;\n    Random random = new Random(System.currentTimeMillis());\n    for (int i = 0; i < LOOPS; i++) {\n      int[] points = new int[pointCount];\n      StringBuilder message = new StringBuilder();\n\n      message.append(\"iteration #\").append(i + 1);\n\n      // Pick fragment points at random\n      for (int j = 0; j < points.length; ++j) {\n        points[j] = random.nextInt(bytes.length);\n      }\n\n      // Sort the list\n      Arrays.sort(points);\n\n      Socket client = newSocket(HOST, _connector.getLocalPort());\n      try {\n        OutputStream os = client.getOutputStream();\n\n        writeFragments(bytes, points, message, os);\n\n        // Read the response\n        String response = readResponse(client);\n\n        // Check the response\n        assertEquals(\"response for \" + i + \" \" + message.toString(), RESPONSE2, response);\n      } finally {\n        client.close();\n      }\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6684, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 125, "focalAPIEnd": 139, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/deathmarine/DiabloDrops/tree/master/src/us/deathmarine/diablodrops/items/ItemAPI.java", "rawCode": "  /**\n   * Gets random kind of spade\n   *\n   * @return random kind of spade\n   */\n  public Material getSpade() {\n    switch (gen.nextInt(5)) {\n      case 0:\n        return Material.WOOD_SPADE;\n      case 1:\n        return Material.STONE_SPADE;\n      case 2:\n        return Material.GOLD_SPADE;\n      case 3:\n        return Material.IRON_SPADE;\n      case 4:\n        return Material.DIAMOND_SPADE;\n      default:\n        return null;\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6685, "initialization": ["Random random = getRandomNumberGenerator(*)"], "initializationStart": [1214], "initializationEnd": [1251], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 1407, "focalAPIEnd": 1423, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["Random.setSeed(element)"], "useStart": [1365], "useEnd": [1424], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/johdah/Weka/tree/master/src/main/java/weka/classifiers/meta/RandomSubSpace.java", "rawCode": "  /**\n   * builds the classifier.\n   *\n   * @param data the training data to be used for generating the classifier.\n   * @throws Exception if the classifier could not be built successfully\n   */\n  public void buildClassifier(Instances data) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(data);\n\n    // remove instances with missing class\n    m_data = new Instances(data);\n    m_data.deleteWithMissingClass();\n\n    // only class? -> build ZeroR model\n    if (m_data.numAttributes() == 1) {\n      System.err.println(\n          \"Cannot build model (only class attribute present in data!), \"\n              + \"using ZeroR model instead!\");\n      m_ZeroR = new weka.classifiers.rules.ZeroR();\n      m_ZeroR.buildClassifier(m_data);\n      return;\n    } else {\n      m_ZeroR = null;\n    }\n\n    super.buildClassifier(data);\n\n    Integer[] indices = new Integer[data.numAttributes() - 1];\n    int classIndex = data.classIndex();\n    int offset = 0;\n    for (int i = 0; i < indices.length + 1; i++) {\n      if (i != classIndex) {\n        indices[offset++] = i + 1;\n      }\n    }\n    int subSpaceSize = numberOfAttributes(indices.length, getSubSpaceSize());\n    Random random = data.getRandomNumberGenerator(m_Seed);\n\n    for (int j = 0; j < m_Classifiers.length; j++) {\n      if (m_Classifier instanceof Randomizable) {\n        ((Randomizable) m_Classifiers[j]).setSeed(random.nextInt());\n      }\n      FilteredClassifier fc = new FilteredClassifier();\n      fc.setClassifier(m_Classifiers[j]);\n      m_Classifiers[j] = fc;\n      Remove rm = new Remove();\n      rm.setOptions(\n          new String[] {\"-V\", \"-R\", randomSubSpace(indices, subSpaceSize, classIndex + 1, random)});\n      fc.setFilter(rm);\n\n      // build the classifier\n      // m_Classifiers[j].buildClassifier(m_data);\n    }\n\n    buildClassifiers();\n\n    // save memory\n    m_data = null;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6686, "initialization": ["Random random = new Random()"], "initializationStart": [173], "initializationEnd": [185], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 199, "focalAPIEnd": 211, "followUpCheck": "j == element || forbiddenColorPair(element,j)", "checkType": "LOOP {", "followUpCheckExpressionStart": 276, "followUpCheckExpressionEnd": 318, "followUpCheckBlockStart": 276, "followUpCheckBlockEnd": 350, "use": ["random.nextInt(int)"], "useStart": [331], "useEnd": [343], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/forssenm/kandidat-projekt/tree/master/Kandidat33MobileGame/src/spatial/hazard/AbstractFireball.java", "rawCode": "  private ParticleEmitter getFireballParticleEmitter(AssetManager assetManager) {\n    ParticleEmitter fire = StandardParticleEmitter.standard(assetManager);\n\n    Random r = new Random();\n    int i = r.nextInt(8) + 1; // doesn't make White the primary color\n    int j = i;\n    while (j == i || forbiddenColorPair(i, j)) {\n      j = r.nextInt(9);\n    }\n\n    fire.setStartColor(colorArray[i]);\n    fire.setEndColor(colorArray[j]);\n    fire.getParticleInfluencer().setInitialVelocity(new Vector3f(0, 2, 0));\n    fire.setStartSize(2.5f);\n    fire.setEndSize(0.1f);\n    fire.setGravity(0, 0, 0);\n    fire.setLowLife(0.4f);\n    fire.setHighLife(0.6f);\n    fire.getParticleInfluencer().setVelocityVariation(0.3f);\n    return fire;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6687, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 127, "focalAPIEnd": 163, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/europeana/contrib/tree/master/ntua/mint2/src/main/java/gr/ntua/ivml/mint/actions/Reminder.java", "rawCode": "  private String getRandomPassword() {\n    String password = \"\";\n    for (int i = 0; i < PASSWORD_LENGTH; i++) {\n      int r = random.nextInt(alphaNumberic.length);\n      password += alphaNumberic[r];\n    }\n\n    return password;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6688, "initialization": ["Random random = new Random()"], "initializationStart": [82], "initializationEnd": [94], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "i<bound", "guardType": "LOOP {", "guardExpressionStart": 122, "guardExpressionEnd": 155, "guardBlockStart": 122, "guardBlockEnd": 335, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 177, "focalAPIEnd": 200, "followUpCheck": "element > bound", "checkType": "IF", "followUpCheckExpressionStart": 297, "followUpCheckExpressionEnd": 318, "followUpCheckBlockStart": 297, "followUpCheckBlockEnd": 329, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/delta458/DSLAB2/tree/master/test/LoadTest/TestRandomClass.java", "rawCode": "  @Test\n  public void testParseList() {\n    int maximum = 30;\n    Random random = new Random();\n    boolean b = true;\n    for (int i = 0; i < maximum; i++) {\n      int select = random.nextInt(maximum);\n      if ((i % 10) == 0) System.out.println(\"\\n\");\n      System.out.print(select + \" \");\n      if (select > maximum) b = false;\n    }\n\n    assertEquals(true, b);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6689, "initialization": ["Random random = new Random()"], "initializationStart": [259], "initializationEnd": [271], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "i<bound", "guardType": "LOOP {", "guardExpressionStart": 331, "guardExpressionEnd": 361, "guardBlockStart": 331, "guardBlockEnd": 668, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 436, "focalAPIEnd": 456, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["setProperty(String,element)", "random.nextInt(int)"], "useStart": [415, 608], "useEnd": [457, 632], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/thinkaurelius/titan/tree/master/titan-test/src/main/java/com/thinkaurelius/titan/graphdb/TitanGraphTest.java", "rawCode": "  @Test\n  public void testWithoutIndex() {\n    TitanKey kid = graph.makeKey(\"kid\").dataType(Long.class).single().make();\n    graph.makeKey(\"name\").dataType(String.class).single().make();\n    graph.makeLabel(\"knows\").signature(kid).make();\n    Random random = new Random();\n    int numV = 1000;\n    TitanVertex previous = null;\n    for (int i = 0; i < numV; i++) {\n      TitanVertex v = graph.addVertex(null);\n      v.setProperty(\"kid\", random.nextInt(numV));\n      v.setProperty(\"name\", \"v\" + i);\n      if (previous != null) {\n        TitanEdge e = v.addEdge(\"knows\", previous);\n        e.setProperty(\"kid\", random.nextInt(numV / 2));\n      }\n      previous = v;\n    }\n    clopen();\n\n    TestUtil.verifyElementOrder(\n        graph.query().orderBy(\"kid\", Order.ASC).limit(500).vertices(), \"kid\", Order.ASC, 500);\n    TestUtil.verifyElementOrder(\n        graph.query().orderBy(\"kid\", Order.ASC).limit(300).edges(), \"kid\", Order.ASC, 300);\n    TestUtil.verifyElementOrder(\n        graph.query().orderBy(\"kid\", Order.DESC).limit(400).vertices(), \"kid\", Order.DESC, 400);\n    TestUtil.verifyElementOrder(\n        graph.query().orderBy(\"kid\", Order.DESC).limit(200).edges(), \"kid\", Order.DESC, 200);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6690, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 112, "focalAPIEnd": 128, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/RichardHightower/datarepo/tree/master/datarepo/src/test/java/org/datarepo/tests/RandomWordUtil.java", "rawCode": "  private static char randomConsonant(Random random) {\n    char letter;\n    letter = consonants.charAt(Math.abs(random.nextInt() % consonants.length()));\n    return letter;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6691, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 1000, "focalAPIEnd": 1021, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["random.nextInt(int)", "random.nextInt(int)", "random.nextInt(int)", "toString(element)"], "useStart": [1052, 1104, 1160, 1308], "useEnd": [1073, 1125, 1180, 1332], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/bokormen/IT1901/tree/master/src/database/RandomTestData.java", "rawCode": "  /**\n   * sletter eller oppretter sauer for en bruker slik at brukeren har oppgitt antall sauer, funker\n   * bare for testbrukere\n   *\n   * @param user\n   * @param numberOfSheep\n   */\n  public static void maxSheepsForTestUser(String user, int numberOfSheep) {\n    ArrayList<String> testUsers = DatabaseConnector.getAllTestUserEmail();\n    int j = testUsers.indexOf(user);\n    ArrayList<Integer> numberOfTestSheep = DatabaseConnector.getNumberOfSheepForTestusers();\n    int numberOfSheeps = numberOfTestSheep.get(j);\n    ArrayList<String> Sheep = DatabaseConnector.getAllSheepIDs(user);\n    if (numberOfSheeps > numberOfSheep) {\n      for (int i = 0; i < numberOfSheeps - numberOfSheep; i++) {\n        DatabaseConnector.deleteSheep(Sheep.get(i));\n      }\n    } else if (numberOfSheeps < numberOfSheep) {\n      for (int i = numberOfSheeps; i < numberOfSheep; i++) {\n        String name = \"testSheep\";\n        String owner = user;\n        String gender = Gender.getRandomGender();\n        int weight = generator.nextInt(10) + 20;\n        int heartrate = generator.nextInt(30) + 60;\n        int birthyear = generator.nextInt(12) + 2001;\n        int temperature = generator.nextInt(2) + 38;\n        DatabaseConnector.newSheep(\n            name,\n            owner,\n            \"\",\n            gender,\n            Integer.toString(weight),\n            Integer.toString(heartrate),\n            Integer.toString(temperature),\n            Integer.toString(birthyear),\n            \"63.23,10.36\");\n      }\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6692, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 486, "focalAPIEnd": 505, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/eswartz/emul/tree/master/org.eclipse.tcf/plugins/org.eclipse.tm.tcf.debug/src/org/eclipse/tm/internal/tcf/debug/tests/TestFileSystem.java", "rawCode": "  public void doneStat(IToken token, FileSystemException error, FileAttrs attrs) {\n    if (error != null) {\n      exit(error);\n    } else if (state == STATE_READ) {\n      if (attrs.size != data.length) {\n        exit(new Exception(\"Invalid FileSysrem.fstat responce: wrong file size\"));\n      } else {\n        files.close(handle, this);\n      }\n    } else if (state == STATE_WRITE) {\n      char[] bf = new char[64];\n      for (int i = 0; i < bf.length; i++) {\n        char ch = (char) (rnd.nextInt(0x4000) + 0x20);\n        switch (ch) {\n          case '<':\n          case '>':\n          case ':':\n          case '\"':\n          case '/':\n          case '\\\\':\n          case '|':\n          case '?':\n          case '*':\n          case '~':\n            ch = '-';\n            break;\n        }\n        bf[i] = ch;\n      }\n      file_name = tmp_path + \"/tcf-test-\" + channel_id + \"-\" + new String(bf) + \".tmp\";\n      files.open(\n          file_name,\n          IFileSystem.TCF_O_CREAT | IFileSystem.TCF_O_TRUNC | IFileSystem.TCF_O_WRITE,\n          null,\n          this);\n    } else {\n      assert false;\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6693, "initialization": ["Random random = new Random()"], "initializationStart": [567], "initializationEnd": [579], "hasTryCatch": 1, "exceptionType": "IOException", "exceptionHandlingCall": ["println(*)"], "tryExpressionStart": 659, "tryExpressionEnd": 663, "tryBlockStart": 659, "tryBlockEnd": 3536, "catchExpressionStart": 3371, "catchExpressionEnd": 3446, "catchBlockStart": 3371, "catchBlockEnd": 3536, "exceptionHandlingCallStart": [3454], "exceptionHandlingCallEnd": [3529], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 2115, "focalAPIEnd": 2130, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["set_frame_status(element)"], "useStart": [2092], "useEnd": [2131], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/audiohacked/audiohacked/tree/master/cs353-project2/Ring0ClientNode.java", "rawCode": "  void listen_state(String node_name) {\n    /* if somehow we stumble into the listen state when we should be\n     * the the transmit state, we need to return to the transmit_state\n     * idealistically we should never be here if we still have the rights\n     * to continue transmitting */\n    if (this.flag) {\n      System.out.println(node_name + \": We Still have the Token!\");\n      transmit_state(node_name);\n      return;\n    }\n\n    System.out.println(node_name + \": Starting Listening State...\");\n    Socket conn = null;\n    String data = null;\n    Random rand = new Random();\n    Ring0TokenFrame frame = new Ring0TokenFrame(node_name, this.status);\n\n    try {\n      /*\n       * we block execution till we get a connection from our neighbor\n       */\n      conn = this.recv_socket.accept();\n      /* once we do get a connection we must open a Buffer for the data\n       * being received */\n      BufferedReader si = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n      data = si.readLine(); /* in this implementation we send newlines */\n\n      if (data != null)\n      /* if for some reason we don't get data we move on\n       * but if the data is good we process the data */\n      {\n        System.out.println(node_name + \": Intercepted Packet...\");\n        frame.from_existing(data); /* we create a Token Frame object\n* from the incoming data frame */\n        conn.close(); /* since we have what we need, we can close the\n* connection */\n\n        if (frame.access_control().equals(0)) {\n          /*\n           * if the incoming packet is a access control packet\n           * it means that the previous node is passing the\n           * token to us. And we move into our transmit state\n           */\n          System.out.println(node_name + \": Got Token!\");\n          this.flag = true;\n          transmit_state(node_name);\n        } else /* otherwise we either pass or keep */ {\n          if (frame.dest().equals(this.this_node_num))\n          /* if we are the recipient, we process */\n          {\n            /* we determine if the frame is good or bad */\n            frame.set_frame_status(rand.nextInt(2));\n\n            /* we have corruption, we pass it? */\n            if (frame.frame_status().equals(0)) send_frame(node_name, frame);\n            else {\n              /* if we find out the frame is good we save it */\n              save_frame_to_output(node_name, frame);\n            }\n          } else {\n            /* if the frame is not for us:\n             * if we're the sender we either drop or reTx later\n             * otherwise we, we pass it\n             */\n            System.out.println(node_name + \": We are not the recipent\");\n            if (frame.src().equals(this.this_node_num)) {\n              if (frame.frame_status().equals(1))\n                System.out.println(node_name + \": listen: draining frame\");\n              else {\n                /* if the frame status is 0, then we have an\n                 * orphaned frame; right now we ignore this\n                 * case\n                 */\n                System.out.println(node_name + \": listen: reTx, when we have Token\");\n                if (this.flag) {\n                  send_frame(node_name, frame);\n                }\n              }\n            } else /* if the source is not use we just pass it */ send_frame(node_name, frame);\n          }\n        }\n      }\n    } catch (IOException io) /* catch IO Exception errors from BufferedReader */ {\n      System.err.println(node_name + \": listen state: IO Error, Buffered Reader\");\n    }\n\n    /* decision for next state: continue or switch states */\n    if (this.flag) transmit_state(node_name);\n    else listen_state(node_name);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6694, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 55, "focalAPIEnd": 88, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/nruth/fingar/tree/master/nruth/fingar/domain/specs/NoteSpec.java", "rawCode": "    public static int getRandomOctave() {\n      return seed.nextInt(Guitar.OCTAVE_RANGE) + 1;\n    }\n"}, {"dataset": "randomNextInt", "exampleID": 6695, "initialization": ["Random random = new Random(*)"], "initializationStart": [69], "initializationEnd": [121], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 248, "focalAPIEnd": 268, "followUpCheck": "c < array.element", "checkType": "LOOP", "followUpCheckExpressionStart": 394, "followUpCheckExpressionEnd": 432, "followUpCheckBlockStart": 394, "followUpCheckBlockEnd": 639, "use": ["newArrayListWithCapacity(element)"], "useStart": [348], "useEnd": [386], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/cmeury/playground/tree/master/daai/src/test/java/ch/wurmlo/daai/week2/QuickSortTest.java", "rawCode": "  @Test\n  public void shouldSortRandomArrays() {\n    Random random = new Random(Calendar.getInstance().getTimeInMillis());\n\n    int ITERATIONS = 10;\n    int SIZE = 10000;\n    for (int i = 0; i < ITERATIONS; i++) {\n      // given\n      int length = random.nextInt(SIZE) + 1;\n      int[] array = new int[length];\n      List<Integer> alreadyInArray = Lists.newArrayListWithCapacity(length);\n      for (int c = 0; c < array.length; c++) {\n        int nextInt;\n        do {\n          nextInt = random.nextInt(SIZE) + 1;\n        } while (alreadyInArray.contains(nextInt));\n        alreadyInArray.add(nextInt);\n        array[c] = nextInt;\n      }\n      QuickSort sorter = new QuickSort(new FirstElementChooser());\n\n      // when\n      sorter.sort(array, 0, array.length - 1);\n\n      // then\n      int[] clone = Arrays.copyOf(array, array.length);\n      Arrays.sort(clone);\n      assertArrayEquals(clone, array);\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6696, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": ["random.setSeed(long)"], "configurationStart": [152], "configurationEnd": [181], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 668, "focalAPIEnd": 693, "followUpCheck": "x1 < element + length + 1", "checkType": "LOOP", "followUpCheckExpressionStart": 906, "followUpCheckExpressionEnd": 958, "followUpCheckBlockStart": 906, "followUpCheckBlockEnd": 1184, "use": ["random.nextInt()", "random.nextInt()", "random.nextInt()", "random.nextInt()", "random.nextInt()", "random.nextInt()", "random.nextInt()"], "useStart": [736, 809, 1643, 1712, 1833, 4028, 4097], "useEnd": [761, 834, 1668, 1737, 1858, 4053, 4122], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/miho/VRL/tree/master/VRL/src/eu/mihosoft/vrl/ext/com/jhlabs/image/SmearFilter.java", "rawCode": "  protected int[] filterPixels(int width, int height, int[] inPixels, Rectangle transformedSpace) {\n    int[] outPixels = new int[width * height];\n\n    randomGenerator.setSeed(seed);\n    float sinAngle = (float) Math.sin(angle);\n    float cosAngle = (float) Math.cos(angle);\n\n    int i = 0;\n    int numShapes;\n\n    for (int y = 0; y < height; y++)\n      for (int x = 0; x < width; x++) {\n        outPixels[i] = background ? 0xffffffff : inPixels[i];\n        i++;\n      }\n\n    switch (shape) {\n      case CROSSES:\n        // Crosses\n        numShapes = (int) (2 * density * width * height / (distance + 1));\n        for (i = 0; i < numShapes; i++) {\n          int x = (randomGenerator.nextInt() & 0x7fffffff) % width;\n          int y = (randomGenerator.nextInt() & 0x7fffffff) % height;\n          int length = randomGenerator.nextInt() % distance + 1;\n          int rgb = inPixels[y * width + x];\n          for (int x1 = x - length; x1 < x + length + 1; x1++) {\n            if (x1 >= 0 && x1 < width) {\n              int rgb2 = background ? 0xffffffff : outPixels[y * width + x1];\n              outPixels[y * width + x1] = ImageMath.mixColors(mix, rgb2, rgb);\n            }\n          }\n          for (int y1 = y - length; y1 < y + length + 1; y1++) {\n            if (y1 >= 0 && y1 < height) {\n              int rgb2 = background ? 0xffffffff : outPixels[y1 * width + x];\n              outPixels[y1 * width + x] = ImageMath.mixColors(mix, rgb2, rgb);\n            }\n          }\n        }\n        break;\n      case LINES:\n        numShapes = (int) (2 * density * width * height / 2);\n\n        for (i = 0; i < numShapes; i++) {\n          int sx = (randomGenerator.nextInt() & 0x7fffffff) % width;\n          int sy = (randomGenerator.nextInt() & 0x7fffffff) % height;\n          int rgb = inPixels[sy * width + sx];\n          int length = (randomGenerator.nextInt() & 0x7fffffff) % distance;\n          int dx = (int) (length * cosAngle);\n          int dy = (int) (length * sinAngle);\n\n          int x0 = sx - dx;\n          int y0 = sy - dy;\n          int x1 = sx + dx;\n          int y1 = sy + dy;\n          int x, y, d, incrE, incrNE, ddx, ddy;\n\n          if (x1 < x0) ddx = -1;\n          else ddx = 1;\n          if (y1 < y0) ddy = -1;\n          else ddy = 1;\n          dx = x1 - x0;\n          dy = y1 - y0;\n          dx = Math.abs(dx);\n          dy = Math.abs(dy);\n          x = x0;\n          y = y0;\n\n          if (x < width && x >= 0 && y < height && y >= 0) {\n            int rgb2 = background ? 0xffffffff : outPixels[y * width + x];\n            outPixels[y * width + x] = ImageMath.mixColors(mix, rgb2, rgb);\n          }\n          if (Math.abs(dx) > Math.abs(dy)) {\n            d = 2 * dy - dx;\n            incrE = 2 * dy;\n            incrNE = 2 * (dy - dx);\n\n            while (x != x1) {\n              if (d <= 0) d += incrE;\n              else {\n                d += incrNE;\n                y += ddy;\n              }\n              x += ddx;\n              if (x < width && x >= 0 && y < height && y >= 0) {\n                int rgb2 = background ? 0xffffffff : outPixels[y * width + x];\n                outPixels[y * width + x] = ImageMath.mixColors(mix, rgb2, rgb);\n              }\n            }\n          } else {\n            d = 2 * dx - dy;\n            incrE = 2 * dx;\n            incrNE = 2 * (dx - dy);\n\n            while (y != y1) {\n              if (d <= 0) d += incrE;\n              else {\n                d += incrNE;\n                x += ddx;\n              }\n              y += ddy;\n              if (x < width && x >= 0 && y < height && y >= 0) {\n                int rgb2 = background ? 0xffffffff : outPixels[y * width + x];\n                outPixels[y * width + x] = ImageMath.mixColors(mix, rgb2, rgb);\n              }\n            }\n          }\n        }\n        break;\n      case SQUARES:\n      case CIRCLES:\n        int radius = distance + 1;\n        int radius2 = radius * radius;\n        numShapes = (int) (2 * density * width * height / radius);\n        for (i = 0; i < numShapes; i++) {\n          int sx = (randomGenerator.nextInt() & 0x7fffffff) % width;\n          int sy = (randomGenerator.nextInt() & 0x7fffffff) % height;\n          int rgb = inPixels[sy * width + sx];\n          for (int x = sx - radius; x < sx + radius + 1; x++) {\n            for (int y = sy - radius; y < sy + radius + 1; y++) {\n              int f;\n              if (shape == CIRCLES) f = (x - sx) * (x - sx) + (y - sy) * (y - sy);\n              else f = 0;\n              if (x >= 0 && x < width && y >= 0 && y < height && f <= radius2) {\n                int rgb2 = background ? 0xffffffff : outPixels[y * width + x];\n                outPixels[y * width + x] = ImageMath.mixColors(mix, rgb2, rgb);\n              }\n            }\n          }\n        }\n    }\n\n    return outPixels;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6697, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 294, "focalAPIEnd": 312, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["append(element)"], "useStart": [269], "useEnd": [315], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/noname2020/Bioc/tree/master/external/lingpipe-4.1.0/src/com/aliasi/test/unit/classify/LogisticRegressionClassifierTest.java", "rawCode": "  static StringBuilder generateExample(int j) {\n    Random random = new Random();\n    StringBuilder sb = new StringBuilder();\n    for (int k = 0; k < 100; ++k) {\n      if (k > 0) sb.append(' ');\n      if (random.nextBoolean()) sb.append(((char) ('a' + j)));\n      else sb.append(((char) ('a' + random.nextInt(10))));\n    }\n    return sb;\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6698, "initialization": ["Random random = new Random(long)"], "initializationStart": [92], "initializationEnd": [108], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt()", "focalAPIStart": 324, "focalAPIEnd": 340, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": ["add(element)", "random.nextInt(int)", "random.nextInt()", "add(element)"], "useStart": [313, 425, 553, 542], "useEnd": [341, 454, 569, 570], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/ytfei/guava/tree/master/guava-tests/test/com/google/common/collect/MinMaxPriorityQueueTest.java", "rawCode": "  public void testRemoveAt() {\n    long seed = new Random().nextLong();\n    Random random = new Random(seed);\n    int heapSize = 999;\n    int numberOfModifications = 500;\n    MinMaxPriorityQueue<Integer> mmHeap = MinMaxPriorityQueue.expectedSize(heapSize).create();\n    for (int i = 0; i < heapSize; i++) {\n      mmHeap.add(random.nextInt());\n    }\n    for (int i = 0; i < numberOfModifications; i++) {\n      mmHeap.removeAt(random.nextInt(mmHeap.size()));\n      assertTrue(\"Modification \" + i + \" of seed \" + seed, mmHeap.isIntact());\n      mmHeap.add(random.nextInt());\n      assertTrue(\"Modification \" + i + \" of seed \" + seed, mmHeap.isIntact());\n    }\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6699, "initialization": [], "initializationStart": [], "initializationEnd": [], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 194, "focalAPIEnd": 214, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/jmkl/test/tree/master/Substrate/src/org/hermit/substrate/EyeCandy.java", "rawCode": "  /**\n   * Return a random integer in the range [0-a[.\n   *\n   * @param a Upper (non-inclusive) bound.\n   * @return A random int in [0-a[.\n   */\n  protected final int random(int a) {\n    return randomGen.nextInt(a);\n  }\n"}, {"dataset": "randomNextInt", "exampleID": 6700, "initialization": ["Random random = new Random(int)"], "initializationStart": [83], "initializationEnd": [97], "hasTryCatch": 0, "exceptionType": "empty", "exceptionHandlingCall": [], "tryExpressionStart": -1, "tryExpressionEnd": -1, "tryBlockStart": -1, "tryBlockEnd": -1, "catchExpressionStart": -1, "catchExpressionEnd": -1, "catchBlockStart": -1, "catchBlockEnd": -1, "exceptionHandlingCallStart": [], "exceptionHandlingCallEnd": [], "configuration": [], "configurationStart": [], "configurationEnd": [], "guardCondition": "empty", "guardType": "empty", "guardExpressionStart": -1, "guardExpressionEnd": -1, "guardBlockStart": -1, "guardBlockEnd": -1, "focalAPI": "element = random.nextInt(bound)", "focalAPIStart": 155, "focalAPIEnd": 177, "followUpCheck": "empty", "checkType": "empty", "followUpCheckExpressionStart": -1, "followUpCheckExpressionEnd": -1, "followUpCheckBlockStart": -1, "followUpCheckBlockEnd": -1, "use": [], "useStart": [], "useEnd": [], "hasFinally": 0, "cleanUpCall": [], "finallyExpressionStart": -1, "finallyExpressionEnd": -1, "finallyBlockStart": -1, "finallyBlockEnd": -1, "cleanUpCallStart": [], "cleanUpCallEnd": [], "url": "https://github.com/spacecaker/android_frameworks_base_CSM9.1/tree/master/core/tests/coretests/src/android/database/NewDatabasePerformanceTests.java", "rawCode": "    @Override\n    public void setUp() {\n      super.setUp();\n      Random random = new Random(42);\n\n      for (int i = 0; i < SIZE; i++) {\n        int r = random.nextInt(100000);\n        statements[i] = \"INSERT INTO t1 VALUES(\" + i + \",\" + r + \",'\" + numberName(r) + \"')\";\n      }\n\n      mDatabase.execSQL(\"CREATE TABLE t1(a INTEGER, b INTEGER, c VARCHAR(100))\");\n    }\n"}]